begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)autoconf.c	7.5 (Berkeley) %G%  *  * from: $Header: autoconf.c,v 1.32 93/05/28 03:55:59 torek Exp $ (LBL)  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bsd_openprom.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/*  * The following several variables are related to  * the configuration process, and are used in initializing  * the machine.  */
end_comment

begin_decl_stmt
name|int
name|cold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if 1, still working on cold-start */
end_comment

begin_decl_stmt
name|int
name|dkn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of iostat dk numbers assigned so far */
end_comment

begin_decl_stmt
name|int
name|fbnode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* node ID of ROM's console frame buffer */
end_comment

begin_decl_stmt
name|int
name|optionsnode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* node ID of ROM's options */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|promvec
modifier|*
name|promvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rootnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|findroot
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|setroot
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getstr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findblkmajor
name|__P
argument_list|(
operator|(
expr|struct
name|dkdevice
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|device
modifier|*
name|getdisk
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|dev_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|device
modifier|*
name|parsedisk
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|dev_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bootpath
name|bootpath
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Most configuration on the SPARC is done by matching OPENPROM Forth  * device names with our internal names.  */
end_comment

begin_function
name|int
name|matchbyname
parameter_list|(
name|parent
parameter_list|,
name|cf
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cf
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|cf
operator|->
name|cf_driver
operator|->
name|cd_name
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|aux
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert hex ASCII string to a value.  Returns updated pointer.  * Depends on ASCII order (this *is* machine-dependent code, you know).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|str2hex
parameter_list|(
name|str
parameter_list|,
name|vp
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
modifier|*
name|vp
decl_stmt|;
block|{
specifier|register
name|int
name|v
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
condition|;
name|v
operator|=
name|v
operator|*
literal|16
operator|+
name|c
operator|,
name|str
operator|++
control|)
block|{
name|c
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|str
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|-=
literal|'0'
operator|)
operator|<
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
literal|'F'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|-=
literal|'A'
operator|-
literal|10
operator|)
operator|<
literal|10
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
literal|'f'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|-=
literal|'a'
operator|-
literal|10
operator|)
operator|<
literal|10
condition|)
break|break;
block|}
else|else
break|break;
block|}
operator|*
name|vp
operator|=
name|v
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * locore.s code calls bootstrap() just before calling main(), after double  * mapping the kernel to high memory and setting up the trap base register.  * We must finish mapping the kernel properly and glean any bootstrap info.  */
end_comment

begin_function
name|void
name|bootstrap
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|bootpath
modifier|*
name|bp
decl_stmt|;
name|int
name|v0val
index|[
literal|3
index|]
decl_stmt|;
name|int
name|nmmu
decl_stmt|,
name|ncontext
decl_stmt|,
name|node
decl_stmt|;
ifdef|#
directive|ifdef
name|KGDB
specifier|extern
name|int
name|kgdb_debug_panic
decl_stmt|;
endif|#
directive|endif
name|node
operator|=
name|findroot
argument_list|()
expr_stmt|;
name|nmmu
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"mmu-npmg"
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|ncontext
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"mmu-nctx"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|pmap_bootstrap
argument_list|(
name|nmmu
argument_list|,
name|ncontext
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KGDB
name|zs_kgdb_init
argument_list|()
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
comment|/* 	 * On SS1s, promvec->pv_v0bootargs->ba_argv[1] contains the flags 	 * that were given after the boot command.  On SS2s, pv_v0bootargs 	 * is NULL but *promvec->pv_v2bootargs.v2_bootargs points to 	 * "vmunix -s" or whatever. 	 * ###	DO THIS BEFORE pmap_boostrap? 	 */
name|bp
operator|=
name|bootpath
expr_stmt|;
if|if
condition|(
name|promvec
operator|->
name|pv_romvec_vers
operator|<
literal|2
condition|)
block|{
comment|/* Grab boot device name and values. */
name|cp
operator|=
operator|(
operator|*
name|promvec
operator|->
name|pv_v0bootargs
operator|)
operator|->
name|ba_argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
comment|/* Kludge something up */
name|pp
operator|=
name|cp
operator|+
literal|2
expr_stmt|;
name|v0val
index|[
literal|0
index|]
operator|=
name|v0val
index|[
literal|1
index|]
operator|=
name|v0val
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
literal|'('
operator|&&
operator|*
operator|(
name|pp
operator|=
name|str2hex
argument_list|(
operator|++
name|pp
argument_list|,
operator|&
name|v0val
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
literal|','
operator|&&
operator|*
operator|(
name|pp
operator|=
name|str2hex
argument_list|(
operator|++
name|pp
argument_list|,
operator|&
name|v0val
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
literal|','
condition|)
operator|(
name|void
operator|)
name|str2hex
argument_list|(
operator|++
name|pp
argument_list|,
operator|&
name|v0val
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Assume sbus0 */
name|strcpy
argument_list|(
name|bp
operator|->
name|name
argument_list|,
literal|"sbus"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|bp
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* le */
name|strcpy
argument_list|(
name|bp
operator|->
name|name
argument_list|,
literal|"le"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|val
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|bp
operator|->
name|val
index|[
literal|1
index|]
operator|=
name|v0val
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* sd or maybe st; assume espN */
name|strcpy
argument_list|(
name|bp
operator|->
name|name
argument_list|,
literal|"esp"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|val
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|bp
operator|->
name|val
index|[
literal|1
index|]
operator|=
name|v0val
index|[
literal|0
index|]
expr_stmt|;
comment|/* XXX map target 0 to 3, 3 to 0. Should really see how the prom is configed */
define|#
directive|define
name|CRAZYMAP
parameter_list|(
name|v
parameter_list|)
value|((v) == 3 ? 0 : (v) == 0 ? 3 : (v))
operator|++
name|bp
expr_stmt|;
name|bp
operator|->
name|name
index|[
literal|0
index|]
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|bp
operator|->
name|name
index|[
literal|1
index|]
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|bp
operator|->
name|name
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bp
operator|->
name|val
index|[
literal|0
index|]
operator|=
name|CRAZYMAP
argument_list|(
name|v0val
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bp
operator|->
name|val
index|[
literal|1
index|]
operator|=
name|v0val
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
comment|/* Setup pointer to boot flags */
name|cp
operator|=
operator|(
operator|*
name|promvec
operator|->
name|pv_v0bootargs
operator|)
operator|->
name|ba_argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|!=
literal|'-'
condition|)
return|return;
block|}
else|else
block|{
comment|/* Grab boot path */
name|cp
operator|=
operator|*
name|promvec
operator|->
name|pv_v2bootargs
operator|.
name|v2_bootpath
expr_stmt|;
while|while
condition|(
name|cp
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
comment|/* Step over '/' */
operator|++
name|cp
expr_stmt|;
comment|/* Extract name */
name|pp
operator|=
name|bp
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'@'
operator|&&
operator|*
name|cp
operator|!=
literal|'/'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|pp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|pp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|cp
operator|=
name|str2hex
argument_list|(
operator|++
name|cp
argument_list|,
operator|&
name|bp
operator|->
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|','
condition|)
name|cp
operator|=
name|str2hex
argument_list|(
operator|++
name|cp
argument_list|,
operator|&
name|bp
operator|->
name|val
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
operator|++
name|bp
expr_stmt|;
block|}
comment|/* Setup pointer to boot flags */
name|cp
operator|=
operator|*
name|promvec
operator|->
name|pv_v2bootargs
operator|.
name|v2_bootargs
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'-'
condition|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\0'
condition|)
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
case|case
literal|'\0'
case|:
return|return;
case|case
literal|'a'
case|:
name|boothowto
operator||=
name|RB_ASKNAME
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|boothowto
operator||=
name|RB_DFLTROOT
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* kgdb - always on zs	XXX */
ifdef|#
directive|ifdef
name|KGDB
name|boothowto
operator||=
name|RB_KDB
expr_stmt|;
comment|/* XXX unused */
name|kgdb_debug_panic
operator|=
literal|1
expr_stmt|;
name|kgdb_connect
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"kernel not compiled with KGDB\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'s'
case|:
name|boothowto
operator||=
name|RB_SINGLE
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Determine mass storage and memory configuration for a machine.  * We get the PROM's root device and make sure we understand it, then  * attach it as `mainbus0'.  We also set up to handle the PROM `sync'  * command.  */
end_comment

begin_macro
name|configure
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|node
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|romaux
name|ra
decl_stmt|;
name|void
name|sync_crash
parameter_list|()
function_decl|;
name|node
operator|=
name|findroot
argument_list|()
expr_stmt|;
name|cp
operator|=
name|getpropstring
argument_list|(
name|node
argument_list|,
literal|"device_type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"cpu"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PROM root device type = %s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"need CPU as root"
argument_list|)
expr_stmt|;
block|}
operator|*
name|promvec
operator|->
name|pv_synchook
operator|=
name|sync_crash
expr_stmt|;
name|ra
operator|.
name|ra_node
operator|=
name|node
expr_stmt|;
name|ra
operator|.
name|ra_name
operator|=
name|cp
operator|=
literal|"mainbus"
expr_stmt|;
if|if
condition|(
operator|!
name|config_rootfound
argument_list|(
name|cp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ra
argument_list|)
condition|)
name|panic
argument_list|(
literal|"mainbus not configured"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
name|bootdv
condition|)
name|printf
argument_list|(
literal|"Found boot device %s\n"
argument_list|,
name|bootdv
operator|->
name|dv_xname
argument_list|)
expr_stmt|;
name|cold
operator|=
literal|0
expr_stmt|;
name|setroot
argument_list|()
expr_stmt|;
name|swapconf
argument_list|()
expr_stmt|;
name|dumpconf
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Console `sync' command.  SunOS just does a `panic: zero' so I guess  * no one really wants anything fancy...  */
end_comment

begin_function
name|void
name|sync_crash
parameter_list|()
block|{
name|panic
argument_list|(
literal|"PROM sync command"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|clockfreq
parameter_list|(
name|freq
parameter_list|)
specifier|register
name|int
name|freq
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|freq
operator|/=
literal|1000
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|freq
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|freq
operator|%=
literal|1000
expr_stmt|;
if|if
condition|(
name|freq
condition|)
block|{
name|freq
operator|+=
literal|1000
expr_stmt|;
comment|/* now in 1000..1999 */
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
comment|/* now buf = %d.%3d */
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|mbprint
parameter_list|(
name|aux
parameter_list|,
name|name
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|romaux
modifier|*
name|ra
init|=
name|aux
decl_stmt|;
if|if
condition|(
name|name
condition|)
name|printf
argument_list|(
literal|"%s at %s"
argument_list|,
name|ra
operator|->
name|ra_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
operator|->
name|ra_paddr
condition|)
name|printf
argument_list|(
literal|" %saddr 0x%x"
argument_list|,
name|ra
operator|->
name|ra_iospace
condition|?
literal|"io"
else|:
literal|""
argument_list|,
operator|(
name|int
operator|)
name|ra
operator|->
name|ra_paddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNCONF
operator|)
return|;
block|}
end_function

begin_function
name|int
name|findroot
parameter_list|()
block|{
specifier|register
name|int
name|node
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|rootnode
operator|)
operator|==
literal|0
operator|&&
operator|(
name|node
operator|=
name|nextsibling
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no PROM root device"
argument_list|)
expr_stmt|;
name|rootnode
operator|=
name|node
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a `first child' node number, locate the node with the given name.  * Return the node number, or 0 if not found.  */
end_comment

begin_function
name|int
name|findnode
parameter_list|(
name|first
parameter_list|,
name|name
parameter_list|)
name|int
name|first
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|first
init|;
name|node
condition|;
name|node
operator|=
name|nextsibling
argument_list|(
name|node
argument_list|)
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|getpropstring
argument_list|(
name|node
argument_list|,
literal|"name"
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|node
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in a romaux.  Returns 1 on success, 0 if the register property  * was not the right size.  */
end_comment

begin_function
name|int
name|romprop
parameter_list|(
name|rp
parameter_list|,
name|cp
parameter_list|,
name|node
parameter_list|)
specifier|register
name|struct
name|romaux
modifier|*
name|rp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|node
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
union|union
block|{
name|char
name|regbuf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|ireg
index|[
literal|3
index|]
decl_stmt|;
block|}
name|u
union|;
specifier|static
specifier|const
name|char
name|pl
index|[]
init|=
literal|"property length"
decl_stmt|;
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
literal|"reg"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|u
operator|.
name|regbuf
argument_list|,
sizeof|sizeof
name|u
operator|.
name|regbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|12
condition|)
block|{
name|printf
argument_list|(
literal|"%s \"reg\" %s = %d (need 12)\n"
argument_list|,
name|cp
argument_list|,
name|pl
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>
literal|12
condition|)
name|printf
argument_list|(
literal|"warning: %s \"reg\" %s %d> 12, excess ignored\n"
argument_list|,
name|cp
argument_list|,
name|pl
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ra_node
operator|=
name|node
expr_stmt|;
name|rp
operator|->
name|ra_name
operator|=
name|cp
expr_stmt|;
name|rp
operator|->
name|ra_iospace
operator|=
name|u
operator|.
name|ireg
index|[
literal|0
index|]
expr_stmt|;
name|rp
operator|->
name|ra_paddr
operator|=
operator|(
name|caddr_t
operator|)
name|u
operator|.
name|ireg
index|[
literal|1
index|]
expr_stmt|;
name|rp
operator|->
name|ra_len
operator|=
name|u
operator|.
name|ireg
index|[
literal|2
index|]
expr_stmt|;
name|rp
operator|->
name|ra_vaddr
operator|=
operator|(
name|caddr_t
operator|)
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"address"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
literal|"intr"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rp
operator|->
name|ra_intr
argument_list|,
sizeof|sizeof
name|rp
operator|->
name|ra_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"%s \"intr\" %s = %d (need multiple of 8)\n"
argument_list|,
name|cp
argument_list|,
name|pl
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|rp
operator|->
name|ra_nintr
operator|=
name|len
operator|>>=
literal|3
expr_stmt|;
comment|/* SPARCstation interrupts are not hardware-vectored */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|ra_intr
index|[
name|len
index|]
operator|.
name|int_vec
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: %s interrupt %d has nonzero vector\n"
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the mainbus.  *  * Our main job is to attach the CPU (the root node we got in configure())  * and iterate down the list of `mainbus devices' (children of that node).  * We also record the `node id' of the default frame buffer, if any.  */
end_comment

begin_function
specifier|static
name|void
name|mainbus_attach
parameter_list|(
name|parent
parameter_list|,
name|dev
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|dev
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|aux
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|node0
decl_stmt|,
name|node
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|ssp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
define|#
directive|define
name|L1A_HACK
comment|/* XXX hack to allow L1-A during autoconf */
ifdef|#
directive|ifdef
name|L1A_HACK
name|int
name|nzs
init|=
literal|0
decl_stmt|,
name|audio
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|struct
name|romaux
name|ra
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|special
index|[]
init|=
block|{
comment|/* find these first (end with empty string) */
literal|"memory-error"
block|,
literal|"eeprom"
block|,
literal|"counter-timer"
block|,
literal|""
block|,
comment|/* ignore these (end with NULL) */
literal|"options"
block|,
literal|"packages"
block|,
literal|"openprom"
block|,
literal|"memory"
block|,
literal|"virtual-memory"
block|,
literal|"interrupt-enable"
block|,
name|NULL
block|}
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* configure the cpu */
name|node
operator|=
operator|(
operator|(
expr|struct
name|romaux
operator|*
operator|)
name|aux
operator|)
operator|->
name|ra_node
expr_stmt|;
name|ra
operator|.
name|ra_node
operator|=
name|node
expr_stmt|;
name|ra
operator|.
name|ra_name
operator|=
name|cp
operator|=
literal|"cpu"
expr_stmt|;
name|ra
operator|.
name|ra_paddr
operator|=
literal|0
expr_stmt|;
name|config_found
argument_list|(
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ra
argument_list|,
name|mbprint
argument_list|)
expr_stmt|;
comment|/* remember which frame buffer, if any, is to be /dev/fb */
name|fbnode
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"fb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Find the "options" node */
name|node0
operator|=
name|firstchild
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|optionsnode
operator|=
name|findnode
argument_list|(
name|node0
argument_list|,
literal|"options"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optionsnode
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no options in OPENPROM"
argument_list|)
expr_stmt|;
comment|/* Start at the beginning of the bootpath */
name|ra
operator|.
name|ra_bp
operator|=
name|bootpath
expr_stmt|;
comment|/* 	 * Locate and configure the ``early'' devices.  These must be 	 * configured before we can do the rest.  For instance, the 	 * EEPROM contains the Ethernet address for the LANCE chip. 	 * If the device cannot be located or configured, panic. 	 */
for|for
control|(
name|ssp
operator|=
name|special
init|;
operator|*
operator|(
name|sp
operator|=
operator|*
name|ssp
operator|)
operator|!=
literal|0
condition|;
name|ssp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|node
operator|=
name|findnode
argument_list|(
name|node0
argument_list|,
name|sp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"could not find %s in OPENPROM\n"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|panic
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|romprop
argument_list|(
operator|&
name|ra
argument_list|,
name|sp
argument_list|,
name|node
argument_list|)
operator|||
operator|!
name|config_found
argument_list|(
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ra
argument_list|,
name|mbprint
argument_list|)
condition|)
name|panic
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Configure the rest of the devices, in PROM order.  Skip 	 * PROM entries that are not for devices, or which must be 	 * done before we get here. 	 */
for|for
control|(
name|node
operator|=
name|node0
init|;
name|node
condition|;
name|node
operator|=
name|nextsibling
argument_list|(
name|node
argument_list|)
control|)
block|{
name|cp
operator|=
name|getpropstring
argument_list|(
name|node
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
for|for
control|(
name|ssp
operator|=
name|special
init|;
operator|(
name|sp
operator|=
operator|*
name|ssp
operator|)
operator|!=
name|NULL
condition|;
name|ssp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|&&
name|romprop
argument_list|(
operator|&
name|ra
argument_list|,
name|cp
argument_list|,
name|node
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|L1A_HACK
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"audio"
argument_list|)
operator|==
literal|0
condition|)
name|audio
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"zs"
argument_list|)
operator|==
literal|0
condition|)
name|nzs
operator|++
expr_stmt|;
if|if
condition|(
name|audio
operator|&&
name|nzs
operator|>=
literal|2
condition|)
operator|(
name|void
operator|)
name|splx
argument_list|(
literal|11
operator|<<
literal|8
argument_list|)
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
operator|(
name|void
operator|)
name|config_found
argument_list|(
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ra
argument_list|,
name|mbprint
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|struct
name|cfdriver
name|mainbuscd
init|=
block|{
name|NULL
block|,
literal|"mainbus"
block|,
name|matchbyname
block|,
name|mainbus_attach
block|,
name|DV_DULL
block|,
expr|sizeof
operator|(
expr|struct
name|device
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * findzs() is called from the zs driver (which is, at least in theory,  * generic to any machine with a Zilog ZSCC chip).  It should return the  * address of the corresponding zs channel.  It may not fail, and it  * may be called before the VM code can be used.  Here we count on the  * FORTH PROM to map in the required zs chips.  */
end_comment

begin_function
name|void
modifier|*
name|findzs
parameter_list|(
name|zs
parameter_list|)
name|int
name|zs
decl_stmt|;
block|{
specifier|register
name|int
name|node
decl_stmt|,
name|addr
decl_stmt|;
name|node
operator|=
name|firstchild
argument_list|(
name|findroot
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|findnode
argument_list|(
name|node
argument_list|,
literal|"zs"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"slave"
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|zs
condition|)
block|{
if|if
condition|(
operator|(
name|addr
operator|=
name|getpropint
argument_list|(
name|node
argument_list|,
literal|"address"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"findzs: zs%d not mapped by PROM"
argument_list|,
name|zs
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|addr
operator|)
return|;
block|}
name|node
operator|=
name|nextsibling
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"findzs: cannot find zs%d"
argument_list|,
name|zs
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|makememarr
parameter_list|(
name|ap
parameter_list|,
name|max
parameter_list|,
name|which
parameter_list|)
specifier|register
name|struct
name|memarr
modifier|*
name|ap
decl_stmt|;
name|int
name|max
decl_stmt|,
name|which
decl_stmt|;
block|{
struct|struct
name|v2rmi
block|{
name|int
name|zero
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|v2rmi
index|[
literal|200
index|]
struct|;
comment|/* version 2 rom meminfo layout */
define|#
directive|define
name|MAXMEMINFO
value|(sizeof(v2rmi) / sizeof(*v2rmi))
specifier|register
name|struct
name|v0mlist
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|node
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|prop
decl_stmt|;
switch|switch
condition|(
name|i
operator|=
name|promvec
operator|->
name|pv_romvec_vers
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Version 0 PROMs use a linked list to describe these 		 * guys. 		 */
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|MEMARR_AVAILPHYS
case|:
name|mp
operator|=
operator|*
name|promvec
operator|->
name|pv_v0mem
operator|.
name|v0_physavail
expr_stmt|;
break|break;
case|case
name|MEMARR_TOTALPHYS
case|:
name|mp
operator|=
operator|*
name|promvec
operator|->
name|pv_v0mem
operator|.
name|v0_phystot
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"makememarr"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|max
condition|)
goto|goto
name|overflow
goto|;
name|ap
operator|->
name|addr
operator|=
operator|(
name|u_int
operator|)
name|mp
operator|->
name|addr
expr_stmt|;
name|ap
operator|->
name|len
operator|=
name|mp
operator|->
name|nbytes
expr_stmt|;
name|ap
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"makememarr: hope version %d PROM is like version 2\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
comment|/* 		 * Version 2 PROMs use a property array to describe them. 		 */
if|if
condition|(
name|max
operator|>
name|MAXMEMINFO
condition|)
block|{
name|printf
argument_list|(
literal|"makememarr: limited to %d\n"
argument_list|,
name|MAXMEMINFO
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAXMEMINFO
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|node
operator|=
name|findnode
argument_list|(
name|firstchild
argument_list|(
name|findroot
argument_list|()
argument_list|)
argument_list|,
literal|"memory"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"makememarr: cannot find \"memory\" node"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|MEMARR_AVAILPHYS
case|:
name|prop
operator|=
literal|"available"
expr_stmt|;
break|break;
case|case
name|MEMARR_TOTALPHYS
case|:
name|prop
operator|=
literal|"reg"
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"makememarr"
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
name|prop
argument_list|,
operator|(
name|void
operator|*
operator|)
name|v2rmi
argument_list|,
sizeof|sizeof
name|v2rmi
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|v2rmi
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|max
condition|)
goto|goto
name|overflow
goto|;
name|ap
operator|->
name|addr
operator|=
name|v2rmi
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|ap
operator|->
name|len
operator|=
name|v2rmi
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|ap
operator|++
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * Success!  (Hooray) 	 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"makememarr: no memory found"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
name|overflow
label|:
comment|/* 	 * Oops, there are more things in the PROM than our caller 	 * provided space for.  Truncate any extras. 	 */
name|printf
argument_list|(
literal|"makememarr: WARNING: lost some memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal form of getprop().  Returns the actual length.  */
end_comment

begin_function
name|int
name|getprop
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|buf
parameter_list|,
name|bufsiz
parameter_list|)
name|int
name|node
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|bufsiz
decl_stmt|;
block|{
specifier|register
name|struct
name|nodeops
modifier|*
name|no
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|no
operator|=
name|promvec
operator|->
name|pv_nodeops
expr_stmt|;
name|len
operator|=
name|no
operator|->
name|no_proplen
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|bufsiz
condition|)
block|{
name|printf
argument_list|(
literal|"node %x property %s length %d> %d\n"
argument_list|,
name|node
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|panic
argument_list|(
literal|"getprop"
argument_list|)
expr_stmt|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|no
operator|->
name|no_getprop
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a string property.  There is a (small) limit on the length;  * the string is fetched into a static buffer which is overwritten on  * subsequent calls.  */
end_comment

begin_function
name|char
modifier|*
name|getpropstring
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|)
name|int
name|node
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|static
name|char
name|stringbuf
index|[
literal|32
index|]
decl_stmt|;
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stringbuf
argument_list|,
sizeof|sizeof
name|stringbuf
operator|-
literal|1
argument_list|)
expr_stmt|;
name|stringbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* usually unnecessary */
return|return
operator|(
name|stringbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch an integer (or pointer) property.  * The return value is the property, or the default if there was none.  */
end_comment

begin_function
name|int
name|getpropint
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|deflt
parameter_list|)
name|int
name|node
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|deflt
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|char
name|intbuf
index|[
literal|16
index|]
decl_stmt|;
name|len
operator|=
name|getprop
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|intbuf
argument_list|,
sizeof|sizeof
name|intbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
return|return
operator|(
name|deflt
operator|)
return|;
return|return
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|intbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * OPENPROM functions.  These are here mainly to hide the OPENPROM interface  * from the rest of the kernel.  */
end_comment

begin_function
name|int
name|firstchild
parameter_list|(
name|node
parameter_list|)
name|int
name|node
decl_stmt|;
block|{
return|return
operator|(
name|promvec
operator|->
name|pv_nodeops
operator|->
name|no_child
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nextsibling
parameter_list|(
name|node
parameter_list|)
name|int
name|node
decl_stmt|;
block|{
return|return
operator|(
name|promvec
operator|->
name|pv_nodeops
operator|->
name|no_nextnode
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass a string to the FORTH PROM to be interpreted */
end_comment

begin_function
name|void
name|rominterpret
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|promvec
operator|->
name|pv_romvec_vers
operator|<
literal|2
condition|)
name|promvec
operator|->
name|pv_fortheval
operator|.
name|v0_eval
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|promvec
operator|->
name|pv_fortheval
operator|.
name|v2_eval
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|volatile
name|void
name|romhalt
parameter_list|()
block|{
name|promvec
operator|->
name|pv_halt
argument_list|()
expr_stmt|;
name|panic
argument_list|(
literal|"PROM exit failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|volatile
name|void
name|romboot
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|promvec
operator|->
name|pv_reboot
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"PROM boot failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|callrom
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* sun4c FORTH PROMs do this for us */
name|fb_unblank
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|promvec
operator|->
name|pv_abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Configure swap space and related parameters.  */
end_comment

begin_macro
name|swapconf
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|swdevt
modifier|*
name|swp
decl_stmt|;
specifier|register
name|int
name|nblks
decl_stmt|;
for|for
control|(
name|swp
operator|=
name|swdevt
init|;
name|swp
operator|->
name|sw_dev
operator|!=
name|NODEV
condition|;
name|swp
operator|++
control|)
if|if
condition|(
name|bdevsw
index|[
name|major
argument_list|(
name|swp
operator|->
name|sw_dev
argument_list|)
index|]
operator|.
name|d_psize
condition|)
block|{
name|nblks
operator|=
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|swp
operator|->
name|sw_dev
argument_list|)
index|]
operator|.
name|d_psize
operator|)
operator|(
name|swp
operator|->
name|sw_dev
operator|)
expr_stmt|;
if|if
condition|(
name|nblks
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|swp
operator|->
name|sw_nblks
operator|==
literal|0
operator|||
name|swp
operator|->
name|sw_nblks
operator|>
name|nblks
operator|)
condition|)
name|swp
operator|->
name|sw_nblks
operator|=
name|nblks
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|DOSWAP
end_define

begin_comment
comment|/* Change swdevt and dumpdev too */
end_comment

begin_decl_stmt
name|u_long
name|bootdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should be dev_t, but not until 32 bits */
end_comment

begin_define
define|#
directive|define
name|PARTITIONMASK
value|0x7
end_define

begin_define
define|#
directive|define
name|PARTITIONSHIFT
value|3
end_define

begin_function
specifier|static
name|int
name|findblkmajor
parameter_list|(
name|dv
parameter_list|)
specifier|register
name|struct
name|dkdevice
modifier|*
name|dv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblkdev
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buf
operator|*
argument_list|)
operator|)
name|bdevsw
index|[
name|i
index|]
operator|.
name|d_strategy
operator|==
name|dv
operator|->
name|dk_driver
operator|->
name|d_strategy
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|device
modifier|*
name|getdisk
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|defpart
parameter_list|,
name|devp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|,
name|defpart
decl_stmt|;
name|dev_t
modifier|*
name|devp
decl_stmt|;
block|{
specifier|register
name|struct
name|device
modifier|*
name|dv
decl_stmt|;
if|if
condition|(
operator|(
name|dv
operator|=
name|parsedisk
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|defpart
argument_list|,
name|devp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"use one of:"
argument_list|)
expr_stmt|;
for|for
control|(
name|dv
operator|=
name|alldevs
init|;
name|dv
operator|!=
name|NULL
condition|;
name|dv
operator|=
name|dv
operator|->
name|dv_next
control|)
if|if
condition|(
name|dv
operator|->
name|dv_class
operator|==
name|DV_DISK
condition|)
name|printf
argument_list|(
literal|" %s[a-h]"
argument_list|,
name|dv
operator|->
name|dv_xname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|device
modifier|*
name|parsedisk
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|defpart
parameter_list|,
name|devp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|,
name|defpart
decl_stmt|;
name|dev_t
modifier|*
name|devp
decl_stmt|;
block|{
specifier|register
name|struct
name|device
modifier|*
name|dv
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|majdev
decl_stmt|,
name|mindev
decl_stmt|,
name|part
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cp
operator|=
name|str
operator|+
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|>=
literal|'a'
operator|&&
operator|*
name|cp
operator|<=
literal|'h'
condition|)
block|{
name|part
operator|=
operator|*
name|cp
operator|-
literal|'a'
expr_stmt|;
operator|*
name|cp
operator|--
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|part
operator|=
name|defpart
expr_stmt|;
for|for
control|(
name|dv
operator|=
name|alldevs
init|;
name|dv
operator|!=
name|NULL
condition|;
name|dv
operator|=
name|dv
operator|->
name|dv_next
control|)
if|if
condition|(
name|dv
operator|->
name|dv_class
operator|==
name|DV_DISK
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
name|dv
operator|->
name|dv_xname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|majdev
operator|=
name|findblkmajor
argument_list|(
operator|(
expr|struct
name|dkdevice
operator|*
operator|)
name|dv
argument_list|)
expr_stmt|;
if|if
condition|(
name|majdev
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"parsedisk"
argument_list|)
expr_stmt|;
name|mindev
operator|=
operator|(
name|dv
operator|->
name|dv_unit
operator|<<
name|PARTITIONSHIFT
operator|)
operator|+
name|part
expr_stmt|;
operator|*
name|devp
operator|=
name|makedev
argument_list|(
name|majdev
argument_list|,
name|mindev
argument_list|)
expr_stmt|;
return|return
operator|(
name|dv
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to find the device from which we were booted.  * If we can do so, and not instructed not to do so,  * change rootdev to correspond to the load device.  */
end_comment

begin_function
name|void
name|setroot
parameter_list|()
block|{
specifier|register
name|struct
name|swdevt
modifier|*
name|swp
decl_stmt|;
specifier|register
name|struct
name|device
modifier|*
name|dv
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|majdev
decl_stmt|,
name|mindev
decl_stmt|,
name|part
decl_stmt|;
name|dev_t
name|nrootdev
decl_stmt|,
name|nswapdev
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DOSWAP
name|dev_t
name|temp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NFS
specifier|extern
name|int
argument_list|(
operator|*
name|mountroot
argument_list|)
argument_list|()
decl_stmt|,
name|nfs_mountroot
argument_list|()
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|boothowto
operator|&
name|RB_ASKNAME
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"root device? "
argument_list|)
expr_stmt|;
name|len
operator|=
name|getstr
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GENERIC
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|buf
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dv
operator|=
name|getdisk
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
operator|&
name|nrootdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dv
operator|!=
name|NULL
condition|)
block|{
name|bootdv
operator|=
name|dv
expr_stmt|;
name|nswapdev
operator|=
name|nrootdev
expr_stmt|;
goto|goto
name|gotswap
goto|;
block|}
block|}
endif|#
directive|endif
name|dv
operator|=
name|getdisk
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|&
name|nrootdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dv
operator|!=
name|NULL
condition|)
block|{
name|bootdv
operator|=
name|dv
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"swap device (default %sb)? "
argument_list|,
name|bootdv
operator|->
name|dv_xname
argument_list|)
expr_stmt|;
name|len
operator|=
name|getstr
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|nswapdev
operator|=
name|makedev
argument_list|(
name|major
argument_list|(
name|nrootdev
argument_list|)
argument_list|,
operator|(
name|minor
argument_list|(
name|nrootdev
argument_list|)
operator|&
operator|~
name|PARTITIONMASK
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|getdisk
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
operator|&
name|nswapdev
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|GENERIC
name|gotswap
label|:
endif|#
directive|endif
name|rootdev
operator|=
name|nrootdev
expr_stmt|;
name|swapdev
operator|=
name|nswapdev
expr_stmt|;
name|dumpdev
operator|=
name|nswapdev
expr_stmt|;
comment|/* ??? */
name|swdevt
index|[
literal|0
index|]
operator|.
name|sw_dev
operator|=
name|nswapdev
expr_stmt|;
name|swdevt
index|[
literal|1
index|]
operator|.
name|sw_dev
operator|=
name|NODEV
expr_stmt|;
return|return;
block|}
comment|/* XXX currently there's no way to set RB_DFLTROOT... */
if|if
condition|(
name|boothowto
operator|&
name|RB_DFLTROOT
operator|||
name|bootdv
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|bootdv
operator|->
name|dv_class
condition|)
block|{
ifdef|#
directive|ifdef
name|NFS
case|case
name|DV_IFNET
case|:
name|mountroot
operator|=
name|nfs_mountroot
expr_stmt|;
ifdef|#
directive|ifdef
name|LBL
name|lbl_diskless_setup
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FFS
argument_list|)
operator|||
name|defined
argument_list|(
name|LFS
argument_list|)
case|case
name|DV_DISK
case|:
name|majdev
operator|=
name|findblkmajor
argument_list|(
operator|(
expr|struct
name|dkdevice
operator|*
operator|)
name|bootdv
argument_list|)
expr_stmt|;
if|if
condition|(
name|majdev
operator|<
literal|0
condition|)
return|return;
name|part
operator|=
literal|0
expr_stmt|;
name|mindev
operator|=
operator|(
name|bootdv
operator|->
name|dv_unit
operator|<<
name|PARTITIONSHIFT
operator|)
operator|+
name|part
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"can't figure root, hope your kernel is right\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Form a new rootdev 	 */
name|nrootdev
operator|=
name|makedev
argument_list|(
name|majdev
argument_list|,
name|mindev
argument_list|)
expr_stmt|;
comment|/* 	 * If the original rootdev is the same as the one 	 * just calculated, don't need to adjust the swap configuration. 	 */
if|if
condition|(
name|rootdev
operator|==
name|nrootdev
condition|)
return|return;
name|rootdev
operator|=
name|nrootdev
expr_stmt|;
name|printf
argument_list|(
literal|"Changing root device to %s%c\n"
argument_list|,
name|bootdv
operator|->
name|dv_xname
argument_list|,
name|part
operator|+
literal|'a'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOSWAP
name|mindev
operator|&=
operator|~
name|PARTITIONMASK
expr_stmt|;
name|temp
operator|=
name|NODEV
expr_stmt|;
for|for
control|(
name|swp
operator|=
name|swdevt
init|;
name|swp
operator|->
name|sw_dev
operator|!=
name|NODEV
condition|;
name|swp
operator|++
control|)
block|{
if|if
condition|(
name|majdev
operator|==
name|major
argument_list|(
name|swp
operator|->
name|sw_dev
argument_list|)
operator|&&
name|mindev
operator|==
operator|(
name|minor
argument_list|(
name|swp
operator|->
name|sw_dev
argument_list|)
operator|&
operator|~
name|PARTITIONMASK
operator|)
condition|)
block|{
name|temp
operator|=
name|swdevt
index|[
literal|0
index|]
operator|.
name|sw_dev
expr_stmt|;
name|swdevt
index|[
literal|0
index|]
operator|.
name|sw_dev
operator|=
name|swp
operator|->
name|sw_dev
expr_stmt|;
name|swp
operator|->
name|sw_dev
operator|=
name|temp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|swp
operator|->
name|sw_dev
operator|==
name|NODEV
condition|)
return|return;
comment|/* 	 * If dumpdev was the same as the old primary swap device, move 	 * it to the new primary swap device. 	 */
if|if
condition|(
name|temp
operator|==
name|dumpdev
condition|)
name|dumpdev
operator|=
name|swdevt
index|[
literal|0
index|]
operator|.
name|sw_dev
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|getstr
parameter_list|(
name|cp
parameter_list|,
name|size
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|lp
operator|=
name|cp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|cngetc
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
case|case
literal|'\b'
case|:
case|case
literal|'\177'
case|:
case|case
literal|'#'
case|:
if|if
condition|(
name|len
condition|)
block|{
operator|--
name|len
expr_stmt|;
operator|--
name|lp
expr_stmt|;
name|printf
argument_list|(
literal|" \b "
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|'@'
case|:
case|case
literal|'u'
operator|&
literal|037
case|:
name|len
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|cp
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|len
operator|+
literal|1
operator|>=
name|size
operator|||
name|c
operator|<
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|"\007"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

