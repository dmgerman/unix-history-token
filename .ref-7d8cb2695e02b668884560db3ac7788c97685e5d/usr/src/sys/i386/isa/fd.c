begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Don Ahn.  *  * %sccs.include.redist.c%  *  *	@(#)fd.c	7.8 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"fd.h"
end_include

begin_if
if|#
directive|if
name|NFD
operator|>
literal|0
end_if

begin_comment
comment|/*  * This driver assumed that NFD == 2. Now it works for NFD == 1 or NFD == 2  * It will probably not work for NFD> 2.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/fdreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_define
define|#
directive|define
name|FDUNIT
parameter_list|(
name|s
parameter_list|)
value|((s)&1)
end_define

begin_define
define|#
directive|define
name|FDTYPE
parameter_list|(
name|s
parameter_list|)
value|(((s)>>1)&7)
end_define

begin_define
define|#
directive|define
name|FDMOTOR
parameter_list|(
name|u
parameter_list|)
value|(fd_unit[(u)].motor ? (1<< (4 + (u))) : 0)
end_define

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_define
define|#
directive|define
name|b_step
value|b_resid
end_define

begin_define
define|#
directive|define
name|FDBLK
value|512
end_define

begin_define
define|#
directive|define
name|NUMTYPES
value|4
end_define

begin_struct
struct|struct
name|fd_type
block|{
name|int
name|sectrac
decl_stmt|;
comment|/* sectors per track         */
name|int
name|secsize
decl_stmt|;
comment|/* size code for sectors     */
name|int
name|datalen
decl_stmt|;
comment|/* data len when secsize = 0 */
name|int
name|gap
decl_stmt|;
comment|/* gap len between sectors   */
name|int
name|tracks
decl_stmt|;
comment|/* total num of tracks       */
name|int
name|size
decl_stmt|;
comment|/* size of disk in sectors   */
name|int
name|steptrac
decl_stmt|;
comment|/* steps per cylinder        */
name|int
name|trans
decl_stmt|;
comment|/* transfer speed code       */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|fd_type
name|fd_types
index|[
name|NUMTYPES
index|]
init|=
block|{
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2880
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* 1.44 meg HD 3.5in floppy    */
block|{
literal|15
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2400
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* 1.2 meg HD floppy           */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x23
block|,
literal|40
block|,
literal|720
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 360k floppy in 1.2meg drive */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x2A
block|,
literal|40
block|,
literal|720
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 360k floppy in DD drive     */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fd_u
block|{
name|int
name|type
decl_stmt|;
comment|/* Drive type (HD, DD     */
name|int
name|active
decl_stmt|;
comment|/* Drive activity boolean */
name|int
name|motor
decl_stmt|;
comment|/* Motor on flag          */
name|struct
name|buf
name|head
decl_stmt|;
comment|/* Head of buf chain      */
name|struct
name|buf
name|rhead
decl_stmt|;
comment|/* Raw head of buf chain  */
name|int
name|reset
decl_stmt|;
block|}
name|fd_unit
index|[
name|NFD
index|]
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state needed for current transfer */
end_comment

begin_expr_stmt
specifier|static
name|fdc
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* floppy disk controller io base register */
end_comment

begin_decl_stmt
name|int
name|fd_dmachan
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_retry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_drive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_track
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_status
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	make sure bounce buffer for DMA is aligned since the DMA chip 	doesn't roll over properly over a 64k boundary */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|buf
modifier|*
name|dma_bounce
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                      autoconfiguration stuff                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_decl_stmt
name|int
name|fdprobe
argument_list|()
decl_stmt|,
name|fdattach
argument_list|()
decl_stmt|,
name|fd_turnoff
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|fddriver
init|=
block|{
name|fdprobe
block|,
name|fdattach
block|,
literal|"fd"
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|fdprobe
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
literal|1
return|;
block|}
end_block

begin_macro
name|fdattach
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|fdc
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* Set transfer to 500kbps */
name|outb
argument_list|(
name|fdc
operator|+
name|fdctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fd_turnoff
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|Fdsize
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
return|return
operator|(
literal|2400
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                               fdstrategy                                 */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
name|Fdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* IO operation to perform */
end_comment

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|long
name|nblocks
decl_stmt|,
name|blknum
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|type
decl_stmt|,
name|s
decl_stmt|;
name|unit
operator|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|FDTYPE
argument_list|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"fdstrat%d, blk = %d, bcount = %d, addr = %x|"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|unit
operator|>=
name|NFD
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fdstrat: unit = %d, blkno = %d, bcount = %d\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|pg
argument_list|(
literal|"fd:error in fdstrategy"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Set up block calculations. 	 */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|FDBLK
expr_stmt|;
name|nblocks
operator|=
name|fd_types
index|[
name|type
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|blknum
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|FDBLK
operator|)
operator|>
name|nblocks
condition|)
block|{
if|if
condition|(
name|blknum
operator|==
name|nblocks
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENOSPC
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"fdstrat%d, too big\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
name|blknum
operator|/
operator|(
name|fd_types
index|[
name|type
index|]
operator|.
name|sectrac
operator|*
literal|2
operator|)
expr_stmt|;
name|dp
operator|=
operator|&
name|fd_unit
index|[
name|unit
index|]
operator|.
name|head
expr_stmt|;
name|dp
operator|->
name|b_step
operator|=
operator|(
name|fd_types
index|[
name|fd_unit
index|[
name|unit
index|]
operator|.
name|type
index|]
operator|.
name|steptrac
operator|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd_unit
index|[
literal|0
index|]
operator|.
name|head
operator|.
name|b_active
operator|==
literal|0
operator|)
if|#
directive|if
name|NFD
operator|>
literal|1
operator|&&
operator|(
name|fd_unit
index|[
literal|1
index|]
operator|.
name|head
operator|.
name|b_active
operator|==
literal|0
operator|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|FDDEBUG
name|printf
argument_list|(
literal|"T|"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|fd_drive
operator|=
name|unit
expr_stmt|;
name|fd_track
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* force seek on first xfer */
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* start drive if idle */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                            motor control stuff                           */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|set_motor
argument_list|(
argument|unit
argument_list|,
argument|reset
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|reset
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outb
argument_list|(
name|fdc
operator|+
name|fdout
argument_list|,
name|unit
operator||
operator|(
name|reset
condition|?
literal|0
else|:
literal|0xC
operator|)
operator||
name|FDMOTOR
argument_list|(
literal|0
argument_list|)
if|#
directive|if
name|NFD
operator|>
literal|1
operator||
name|FDMOTOR
argument_list|(
literal|1
argument_list|)
endif|#
directive|endif
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fd_turnoff
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fd_unit
index|[
name|unit
index|]
operator|.
name|motor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unit
condition|)
name|set_motor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|set_motor
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fd_turnon
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fd_unit
index|[
name|unit
index|]
operator|.
name|motor
operator|=
literal|1
expr_stmt|;
name|set_motor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                             fdc in/out                                   */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
name|int
name|in_fdc
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|inb
argument_list|(
name|fdc
operator|+
name|fdsts
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|)
operator|!=
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
condition|)
if|if
condition|(
name|i
operator|==
name|NE7_RQM
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|inb
argument_list|(
name|fdc
operator|+
name|fddata
argument_list|)
return|;
block|}
end_function

begin_macro
name|dump_stat
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|fd_status
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
if|if
condition|(
name|fd_status
index|[
name|i
index|]
operator|<
literal|0
condition|)
break|break;
block|}
name|printf
argument_list|(
literal|"FD bad status :%lx %lx %lx %lx %lx %lx %lx\n"
argument_list|,
name|fd_status
index|[
literal|0
index|]
argument_list|,
name|fd_status
index|[
literal|1
index|]
argument_list|,
name|fd_status
index|[
literal|2
index|]
argument_list|,
name|fd_status
index|[
literal|3
index|]
argument_list|,
name|fd_status
index|[
literal|4
index|]
argument_list|,
name|fd_status
index|[
literal|5
index|]
argument_list|,
name|fd_status
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|out_fdc
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|r
decl_stmt|,
name|errcnt
decl_stmt|;
specifier|static
name|int
name|maxcnt
init|=
literal|0
decl_stmt|;
name|errcnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|r
operator|=
operator|(
name|inb
argument_list|(
name|fdc
operator|+
name|fdsts
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NE7_RQM
condition|)
break|break;
if|if
condition|(
name|r
operator|==
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
condition|)
block|{
name|dump_stat
argument_list|()
expr_stmt|;
comment|/* error: direction. eat up output */
ifdef|#
directive|ifdef
name|FDOTHER
name|printf
argument_list|(
literal|"%lx\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* printf("Error r = %d:",r); */
name|errcnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
name|errcnt
operator|>
name|maxcnt
condition|)
block|{
name|maxcnt
operator|=
name|errcnt
expr_stmt|;
ifdef|#
directive|ifdef
name|FDOTHER
name|printf
argument_list|(
literal|"New MAX = %d\n"
argument_list|,
name|maxcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|outb
argument_list|(
name|fdc
operator|+
name|fddata
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* see if fdc responding */
end_comment

begin_function
name|int
name|check_fdc
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|fdc
operator|+
name|fdsts
argument_list|)
operator|&
name|NE7_RQM
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                           fdopen/fdclose                                 */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|Fdopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|FDTYPE
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|printf
argument_list|(
literal|"fdopen %x %d %d\n"
argument_list|,
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|unit
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* check bounds */
if|if
condition|(
name|unit
operator|>=
name|NFD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|type
operator|>=
name|NUMTYPES
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	if (check_fdc()) return(EBUSY); */
comment|/* Set proper disk type, only allow one type */
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|Fdclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                            fdread/fdwrite                                */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*  * Routines to do raw IO for a unit.  */
end_comment

begin_macro
name|Fdread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_comment
comment|/* character read routine */
end_comment

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NFD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|Fdstrategy
argument_list|,
operator|&
name|fd_unit
index|[
name|unit
index|]
operator|.
name|rhead
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|Fdwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_comment
comment|/* character write routine */
end_comment

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NFD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|Fdstrategy
argument_list|,
operator|&
name|fd_unit
index|[
name|unit
index|]
operator|.
name|rhead
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                                 fdstart                                  */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|fdstart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"fd%d|"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fd_unit
index|[
name|unit
index|]
operator|.
name|motor
condition|)
block|{
name|fd_turnon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Wait for 1 sec */
name|timeout
argument_list|(
name|fdstart
argument_list|,
name|unit
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/*DELAY(1000000);*/
block|}
else|else
block|{
comment|/* make sure drive is selected as well as on */
comment|/*set_motor(unit,0);*/
name|dp
operator|=
operator|&
name|fd_unit
index|[
name|unit
index|]
operator|.
name|head
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|fd_retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fd_unit
index|[
name|unit
index|]
operator|.
name|reset
condition|)
name|fd_state
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* DO a RESET */
name|fd_unit
index|[
name|unit
index|]
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|fd_state
operator|=
literal|5
expr_stmt|;
block|}
name|fd_skip
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FDDEBUG
name|printf
argument_list|(
literal|"Seek %d %d\n"
argument_list|,
name|bp
operator|->
name|b_cylin
argument_list|,
name|dp
operator|->
name|b_step
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|!=
name|fd_track
condition|)
block|{
comment|/* Seek necessary, never quite sure where head is at! */
name|out_fdc
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* Seek function */
name|out_fdc
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Drive number */
name|out_fdc
argument_list|(
name|bp
operator|->
name|b_cylin
operator|*
name|dp
operator|->
name|b_step
argument_list|)
expr_stmt|;
block|}
else|else
name|fdintr
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fd_timeout
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|dp
operator|=
operator|&
name|fd_unit
index|[
name|fd_drive
index|]
operator|.
name|head
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|out_fdc
argument_list|(
literal|0x4
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
name|i
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Timeout drive status %lx\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
literal|0x8
argument_list|)
expr_stmt|;
name|i
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|j
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ST0 = %lx, PCN = %lx\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|badtrans
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                                 fdintr                                   */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|fdintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dpother
decl_stmt|;
name|int
name|read
decl_stmt|,
name|head
decl_stmt|,
name|trac
decl_stmt|,
name|sec
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|,
name|sectrac
decl_stmt|,
name|cyl
decl_stmt|;
name|unsigned
name|long
name|blknum
decl_stmt|;
name|struct
name|fd_type
modifier|*
name|ft
decl_stmt|;
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"state %d, unit %d, dr %d|"
argument_list|,
name|fd_state
argument_list|,
name|unit
argument_list|,
name|fd_drive
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
operator|&
name|fd_unit
index|[
name|fd_drive
index|]
operator|.
name|head
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|read
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
expr_stmt|;
name|ft
operator|=
operator|&
name|fd_types
index|[
name|FDTYPE
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
switch|switch
condition|(
name|fd_state
condition|)
block|{
case|case
literal|1
case|:
comment|/* SEEK DONE, START DMA */
comment|/* Make sure seek really happened*/
if|if
condition|(
name|unit
operator|!=
literal|0xff
condition|)
block|{
name|out_fdc
argument_list|(
literal|0x8
argument_list|)
expr_stmt|;
name|i
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|0x20
operator|)
operator|||
operator|(
name|cyl
operator|!=
name|bp
operator|->
name|b_cylin
operator|*
name|dp
operator|->
name|b_step
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Stray int ST0 = %lx, PCN = %lx:"
argument_list|,
name|i
argument_list|,
name|cyl
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fd_track
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|at_dma
argument_list|(
name|read
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|fd_skip
argument_list|,
name|FDBLK
argument_list|,
name|fd_dmachan
argument_list|)
expr_stmt|;
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|FDBLK
operator|+
name|fd_skip
operator|/
name|FDBLK
expr_stmt|;
name|sectrac
operator|=
name|ft
operator|->
name|sectrac
expr_stmt|;
name|sec
operator|=
name|blknum
operator|%
operator|(
name|sectrac
operator|*
literal|2
operator|)
expr_stmt|;
name|head
operator|=
name|sec
operator|/
name|sectrac
expr_stmt|;
name|sec
operator|=
name|sec
operator|%
name|sectrac
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|read
condition|)
name|out_fdc
argument_list|(
literal|0xE6
argument_list|)
expr_stmt|;
comment|/* READ */
else|else
name|out_fdc
argument_list|(
literal|0xC5
argument_list|)
expr_stmt|;
comment|/* WRITE */
name|out_fdc
argument_list|(
name|head
operator|<<
literal|2
operator||
name|fd_drive
argument_list|)
expr_stmt|;
comment|/* head& unit */
name|out_fdc
argument_list|(
name|fd_track
argument_list|)
expr_stmt|;
comment|/* track */
name|out_fdc
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* sector XXX +1? */
name|out_fdc
argument_list|(
name|ft
operator|->
name|secsize
argument_list|)
expr_stmt|;
comment|/* sector size */
name|out_fdc
argument_list|(
name|sectrac
argument_list|)
expr_stmt|;
comment|/* sectors/track */
name|out_fdc
argument_list|(
name|ft
operator|->
name|gap
argument_list|)
expr_stmt|;
comment|/* gap size */
name|out_fdc
argument_list|(
name|ft
operator|->
name|datalen
argument_list|)
expr_stmt|;
comment|/* data length */
name|fd_state
operator|=
literal|2
expr_stmt|;
comment|/* XXX PARANOIA */
name|untimeout
argument_list|(
name|fd_timeout
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|fd_timeout
argument_list|,
literal|2
argument_list|,
name|hz
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* IO DONE, post-analyze */
name|untimeout
argument_list|(
name|fd_timeout
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|fd_status
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fd_status
index|[
literal|0
index|]
operator|&
literal|0xF8
condition|)
block|{
ifdef|#
directive|ifdef
name|FDOTHER
name|printf
argument_list|(
literal|"status0 err %d:"
argument_list|,
name|fd_status
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|retry
goto|;
block|}
comment|/* 		if (fd_status[1]){ 			printf("status1 err %d:",fd_status[0]); 			goto retry; 		} 		if (fd_status[2]){ 			printf("status2 err %d:",fd_status[0]); 			goto retry; 		} */
comment|/* All OK */
if|if
condition|(
operator|!
name|kernel_space
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|fd_skip
argument_list|)
condition|)
block|{
comment|/* RAW transfer */
if|if
condition|(
name|read
condition|)
name|bcopy
argument_list|(
name|dma_bounce
index|[
name|fd_dmachan
index|]
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|fd_skip
argument_list|,
name|FDBLK
argument_list|)
expr_stmt|;
block|}
name|fd_skip
operator|+=
name|FDBLK
expr_stmt|;
if|if
condition|(
name|fd_skip
operator|>=
name|bp
operator|->
name|b_bcount
condition|)
block|{
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"DONE %d|"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ALL DONE */
name|fd_skip
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nextstate
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|FDDEBUG
name|printf
argument_list|(
literal|"next|"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set up next transfer */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|FDBLK
operator|+
name|fd_skip
operator|/
name|FDBLK
expr_stmt|;
name|fd_state
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|b_cylin
operator|=
operator|(
name|blknum
operator|/
operator|(
name|ft
operator|->
name|sectrac
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|!=
name|fd_track
condition|)
block|{
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"Seek|"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SEEK Necessary */
name|out_fdc
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* Seek function */
name|out_fdc
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
comment|/* Drive number */
name|out_fdc
argument_list|(
name|bp
operator|->
name|b_cylin
operator|*
name|dp
operator|->
name|b_step
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|fdintr
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
ifdef|#
directive|ifdef
name|FDOTHER
name|printf
argument_list|(
literal|"Seek %d %d\n"
argument_list|,
name|bp
operator|->
name|b_cylin
argument_list|,
name|dp
operator|->
name|b_step
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Seek necessary */
name|out_fdc
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* Seek function */
name|out_fdc
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
comment|/* Drive number */
name|out_fdc
argument_list|(
name|bp
operator|->
name|b_cylin
operator|*
name|dp
operator|->
name|b_step
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|out_fdc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* specify command */
name|out_fdc
argument_list|(
literal|0xDF
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
literal|7
argument_list|)
expr_stmt|;
comment|/* Recalibrate Function */
name|out_fdc
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|5
case|:
ifdef|#
directive|ifdef
name|FDOTHER
name|printf
argument_list|(
literal|"**RESET**\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Try a reset, keep motor on */
name|set_motor
argument_list|(
name|fd_drive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_motor
argument_list|(
name|fd_drive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|fdc
operator|+
name|fdctl
argument_list|,
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
name|fd_retry
operator|++
expr_stmt|;
name|fd_state
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unexpected FD int->"
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
literal|0x8
argument_list|)
expr_stmt|;
name|i
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|sec
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ST0 = %lx, PCN = %lx\n"
argument_list|,
name|i
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
literal|0x4A
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|fd_status
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"intr status :%lx %lx %lx %lx %lx %lx %lx "
argument_list|,
name|fd_status
index|[
literal|0
index|]
argument_list|,
name|fd_status
index|[
literal|1
index|]
argument_list|,
name|fd_status
index|[
literal|2
index|]
argument_list|,
name|fd_status
index|[
literal|3
index|]
argument_list|,
name|fd_status
index|[
literal|4
index|]
argument_list|,
name|fd_status
index|[
literal|5
index|]
argument_list|,
name|fd_status
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
name|retry
label|:
switch|switch
condition|(
name|fd_retry
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
break|break;
case|case
literal|4
case|:
name|fd_retry
operator|++
expr_stmt|;
name|fd_state
operator|=
literal|5
expr_stmt|;
name|fdintr
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"FD err %lx %lx %lx %lx %lx %lx %lx\n"
argument_list|,
name|fd_status
index|[
literal|0
index|]
argument_list|,
name|fd_status
index|[
literal|1
index|]
argument_list|,
name|fd_status
index|[
literal|2
index|]
argument_list|,
name|fd_status
index|[
literal|3
index|]
argument_list|,
name|fd_status
index|[
literal|4
index|]
argument_list|,
name|fd_status
index|[
literal|5
index|]
argument_list|,
name|fd_status
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|badtrans
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|fd_state
operator|=
literal|1
expr_stmt|;
name|fd_retry
operator|++
expr_stmt|;
name|fdintr
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|badtrans
argument_list|(
argument|dp
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|fd_skip
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|fd_skip
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nextstate
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	nextstate : After a transfer is done, continue processing 	requests on the current drive queue.  If empty, go to 	the other drives queue.  If that is empty too, timeout 	to turn off the current drive in 5 seconds, and go 	to state 0 (not expecting any interrupts). */
end_comment

begin_macro
name|nextstate
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|fdstart
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|NFD
operator|>
literal|1
name|struct
name|buf
modifier|*
name|dpother
decl_stmt|;
name|dpother
operator|=
operator|&
name|fd_unit
index|[
name|fd_drive
condition|?
literal|0
else|:
literal|1
index|]
operator|.
name|head
expr_stmt|;
if|if
condition|(
name|dpother
operator|->
name|b_actf
condition|)
block|{
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"switch|"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd_drive
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd_drive
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
name|fd_drive
operator|=
literal|1
operator|-
name|fd_drive
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dpother
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|fdstart
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"off|"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd_drive
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd_drive
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|Fdioctl
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|Fddump
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

