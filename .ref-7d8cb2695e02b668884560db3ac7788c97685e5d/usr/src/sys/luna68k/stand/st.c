begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 OMRON Corporation.  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * OMRON Corporation.  *  * %sccs.include.redist.c%  *  *	@(#)st.c	7.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * st.c -- SCSI Disk Device Driver for LUNA-68K  * remaked by A.Fujita, MAR-22-1992  */
end_comment

begin_comment
comment|/*  * SCSI CCS (Command Command Set) disk driver.  */
end_comment

begin_define
define|#
directive|define
name|NST
value|1
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<luna68k/dev/scsireg.h>
end_include

begin_include
include|#
directive|include
file|<luna68k/stand/device.h>
end_include

begin_function_decl
specifier|extern
name|int
name|scsi_test_unit_rdy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsi_request_sense
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsi_immed_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scgo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|scfree
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|stinit
argument_list|()
decl_stmt|,
name|ststrategy
argument_list|()
decl_stmt|,
name|ststart
argument_list|()
decl_stmt|,
name|stintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|stdriver
init|=
block|{
name|stinit
block|,
literal|"st"
block|,
name|ststart
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
name|stintr
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|st_softc
block|{
name|struct
name|hp_device
modifier|*
name|sc_hd
decl_stmt|;
name|struct
name|devqueue
name|sc_dq
decl_stmt|;
name|int
name|sc_flags
decl_stmt|;
name|short
name|sc_type
decl_stmt|;
comment|/* drive type */
name|short
name|sc_punit
decl_stmt|;
comment|/* physical unit (scsi lun) */
block|}
name|st_softc
index|[
name|NST
index|]
struct|;
end_struct

begin_comment
comment|/* softc flags */
end_comment

begin_define
define|#
directive|define
name|STF_ALIVE
value|0x0001
end_define

begin_define
define|#
directive|define
name|STF_OPEN
value|0x0002
end_define

begin_define
define|#
directive|define
name|STF_WMODE
value|0x0004
end_define

begin_define
define|#
directive|define
name|STF_WRTTN
value|0x0008
end_define

begin_define
define|#
directive|define
name|STF_CMD
value|0x0010
end_define

begin_define
define|#
directive|define
name|STF_LEOT
value|0x0020
end_define

begin_define
define|#
directive|define
name|STF_MOVED
value|0x0040
end_define

begin_decl_stmt
name|struct
name|scsi_fmt_sense
name|stsense
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|stunit
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& 3)
end_define

begin_define
define|#
directive|define
name|stpunit
parameter_list|(
name|x
parameter_list|)
value|((x)& 7)
end_define

begin_define
define|#
directive|define
name|STDEV_NOREWIND
value|0x04
end_define

begin_define
define|#
directive|define
name|STDEV_HIDENSITY
value|0x08
end_define

begin_define
define|#
directive|define
name|STDEV_EXSFMK
value|0x10
end_define

begin_define
define|#
directive|define
name|STDEV_FIXEDBLK
value|0x20
end_define

begin_define
define|#
directive|define
name|b_lba
value|b_resid
end_define

begin_define
define|#
directive|define
name|STRETRY
value|2
end_define

begin_comment
comment|/* IO retry count */
end_comment

begin_comment
comment|/*  * Initialize  */
end_comment

begin_function
name|int
name|stinit
parameter_list|(
name|hd
parameter_list|)
specifier|register
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
block|{
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|hd
operator|->
name|hp_unit
index|]
decl_stmt|;
name|sc
operator|->
name|sc_hd
operator|=
name|hd
expr_stmt|;
name|sc
operator|->
name|sc_punit
operator|=
name|stpunit
argument_list|(
name|hd
operator|->
name|hp_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_type
operator|=
name|stident
argument_list|(
name|sc
argument_list|,
name|hd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_unit
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_driver
operator|=
operator|&
name|stdriver
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|STF_ALIVE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|scsi_inquiry
name|inqbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_fmt_cdb
name|inq
init|=
block|{
literal|6
block|,
name|CMD_INQUIRY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|inqbuf
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|stident
parameter_list|(
name|sc
parameter_list|,
name|hd
parameter_list|)
name|struct
name|st_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
block|{
name|char
name|idstr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|;
specifier|register
name|int
name|tries
init|=
literal|10
decl_stmt|;
name|ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|unit
operator|=
name|sc
operator|->
name|sc_punit
expr_stmt|;
comment|/* 	 * See if unit exists and is a disk then read block size& nblocks. 	 */
while|while
condition|(
operator|(
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|inq
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|inqbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inqbuf
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|stat
operator|<
literal|0
operator|||
operator|--
name|tries
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|inqbuf
operator|.
name|type
condition|)
block|{
case|case
literal|1
case|:
comment|/* tape */
break|break;
default|default:
comment|/* not a disk */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|inqbuf
operator|.
name|vendor_id
argument_list|,
operator|(
name|caddr_t
operator|)
name|idstr
argument_list|,
literal|28
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|27
init|;
name|i
operator|>
literal|23
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|idstr
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
break|break;
name|idstr
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|23
init|;
name|i
operator|>
literal|7
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|idstr
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
break|break;
name|idstr
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|idstr
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
break|break;
name|idstr
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"st%d: %s %s rev %s\n"
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|,
name|idstr
argument_list|,
operator|&
name|idstr
index|[
literal|8
index|]
argument_list|,
operator|&
name|idstr
index|[
literal|24
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|inqbuf
operator|.
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open  */
end_comment

begin_function
name|int
name|stopen
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|stunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NST
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|STF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|STF_OPEN
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sc
operator|->
name|sc_flags
operator||=
name|STF_OPEN
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|STF_WMODE
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|STF_MOVED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|stclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|stunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|unit
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"st: sc->sc_flags = 0x%s\n"
argument_list|,
name|hexstr
argument_list|(
name|sc
operator|->
name|sc_flags
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|STF_WMODE
operator||
name|STF_WRTTN
operator|)
operator|)
operator|==
operator|(
name|STF_WMODE
operator||
name|STF_WRTTN
operator|)
condition|)
block|{
name|st_write_EOF
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|STDEV_NOREWIND
operator|)
operator|==
literal|0
condition|)
block|{
name|st_rewind
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|STF_OPEN
operator||
name|STF_WMODE
operator||
name|STF_WRTTN
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Strategy  */
end_comment

begin_function
name|int
name|ststrategy
parameter_list|()
block|{ }
end_function

begin_function
name|int
name|ststart
parameter_list|(
name|unit
parameter_list|)
specifier|register
name|int
name|unit
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*  * Interrupt  */
end_comment

begin_comment
comment|/*  * Return:  *	0	if not really an error  *<0	if we should do a retry  *>0	if a fatal error  */
end_comment

begin_function
specifier|static
name|int
name|sterror
parameter_list|(
name|unit
parameter_list|,
name|sc
parameter_list|,
name|hp
parameter_list|,
name|stat
parameter_list|)
name|int
name|unit
decl_stmt|,
name|stat
decl_stmt|;
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hp
decl_stmt|;
block|{
name|int
name|cond
init|=
literal|1
decl_stmt|;
name|stsense
index|[
name|unit
index|]
operator|.
name|status
operator|=
name|stat
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|STS_CHECKCOND
condition|)
block|{
name|struct
name|scsi_xsense
modifier|*
name|sp
decl_stmt|;
name|scsi_request_sense
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|stsense
index|[
name|unit
index|]
operator|.
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
name|stsense
index|[
name|unit
index|]
operator|.
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|scsi_xsense
operator|*
operator|)
name|stsense
index|[
name|unit
index|]
operator|.
name|sense
expr_stmt|;
name|printf
argument_list|(
literal|"st%d: scsi sense class %d, code %d"
argument_list|,
name|unit
argument_list|,
name|sp
operator|->
name|class
argument_list|,
name|sp
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|class
operator|==
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|", key %d"
argument_list|,
name|sp
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|valid
condition|)
name|printf
argument_list|(
literal|", blk %d"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|sp
operator|->
name|info1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|key
condition|)
block|{
comment|/* no sense, try again */
case|case
literal|0
case|:
name|cond
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
comment|/* recovered error, not a problem */
case|case
literal|1
case|:
name|cond
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cond
operator|)
return|;
block|}
end_function

begin_function
name|int
name|stintr
parameter_list|(
name|unit
parameter_list|,
name|stat
parameter_list|)
specifier|register
name|int
name|unit
decl_stmt|;
name|int
name|stat
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*  * RAW Device Routines  */
end_comment

begin_function
name|char
modifier|*
name|sense_key
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
if|if
condition|(
name|key
operator|==
literal|0
condition|)
return|return
operator|(
literal|"No Sense"
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|2
condition|)
return|return
operator|(
literal|"Not Ready"
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|3
condition|)
return|return
operator|(
literal|"Medium Error"
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|4
condition|)
return|return
operator|(
literal|"Hardware Error"
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|5
condition|)
return|return
operator|(
literal|"Illegal Request"
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|6
condition|)
return|return
operator|(
literal|"Unit Attention"
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|7
condition|)
return|return
operator|(
literal|"Data Protect"
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|8
condition|)
return|return
operator|(
literal|"No Data"
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|11
condition|)
return|return
operator|(
literal|"Aborted Command"
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|13
condition|)
return|return
operator|(
literal|"Volume Overflow"
operator|)
return|;
else|else
return|return
operator|(
literal|"Unknown Error"
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|scsi_fmt_cdb
name|st_cmd
init|=
block|{
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|sensebuf
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|stread
parameter_list|(
name|dev
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|stunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|scsi_fmt_cdb
modifier|*
name|cdb
init|=
operator|&
name|st_cmd
decl_stmt|;
specifier|register
name|int
name|nblk
init|=
name|size
operator|>>
name|DEV_BSHIFT
decl_stmt|;
name|struct
name|scsi_xsense
modifier|*
name|sp
init|=
operator|(
expr|struct
name|scsi_xsense
operator|*
operator|)
name|sensebuf
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|stat
decl_stmt|;
name|ctlr
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|CMD_READ
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* unknown setup */
name|cdb
operator|->
name|cdb
index|[
literal|2
index|]
operator|=
operator|(
name|nblk
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|3
index|]
operator|=
operator|(
name|nblk
operator|&
literal|0x00ff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
operator|(
name|nblk
operator|&
literal|0x0000ff
operator|)
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* unknown setup */
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|cdb
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
return|return
operator|(
name|size
operator|)
return|;
else|else
block|{
name|scsi_request_sense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|sp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|printf
argument_list|(
literal|"stread: Sense Key = [%s]"
argument_list|,
name|sense_key
argument_list|(
name|sp
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|filemark
condition|)
name|printf
argument_list|(
literal|" [EOF]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|eom
condition|)
name|printf
argument_list|(
literal|" [EOM]"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|stwrite
parameter_list|(
name|dev
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|stunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|scsi_fmt_cdb
modifier|*
name|cdb
init|=
operator|&
name|st_cmd
decl_stmt|;
name|struct
name|scsi_xsense
modifier|*
name|sp
init|=
operator|(
expr|struct
name|scsi_xsense
operator|*
operator|)
name|sensebuf
decl_stmt|;
specifier|register
name|int
name|nblk
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|stat
decl_stmt|;
name|nblk
operator|=
name|size
operator|>>
name|DEV_BSHIFT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|DEV_BSIZE
condition|)
name|nblk
operator|++
expr_stmt|;
name|size
operator|=
name|nblk
operator|<<
name|DEV_BSHIFT
expr_stmt|;
name|ctlr
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|STF_WRTTN
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|CMD_WRITE
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* unknown setup */
name|cdb
operator|->
name|cdb
index|[
literal|2
index|]
operator|=
operator|(
name|nblk
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|3
index|]
operator|=
operator|(
name|nblk
operator|&
literal|0x00ff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
operator|(
name|nblk
operator|&
literal|0x0000ff
operator|)
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* unknown setup */
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|cdb
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
return|return
operator|(
name|size
operator|)
return|;
else|else
block|{
name|scsi_request_sense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|sp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|printf
argument_list|(
literal|"stwrite: Sense Key = [%s]"
argument_list|,
name|sense_key
argument_list|(
name|sp
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|eom
condition|)
name|printf
argument_list|(
literal|" [EOM]"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|stioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{ }
end_function

begin_macro
name|st_rewind
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|stunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|scsi_fmt_cdb
modifier|*
name|cdb
init|=
operator|&
name|st_cmd
decl_stmt|;
name|struct
name|scsi_xsense
modifier|*
name|sp
init|=
operator|(
expr|struct
name|scsi_xsense
operator|*
operator|)
name|sensebuf
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|stat
decl_stmt|;
name|int
name|retry
init|=
literal|5
decl_stmt|;
name|ctlr
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|CMD_REWIND
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* command finished soon */
name|cdb
operator|->
name|cdb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* unknown setup */
name|rewind
label|:
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|cdb
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|scsi_request_sense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|sp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|printf
argument_list|(
literal|"st_rewind: Sense Key = [%s]"
argument_list|,
name|sense_key
argument_list|(
name|sp
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|>
literal|0
condition|)
block|{
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|retry
operator|--
expr_stmt|;
goto|goto
name|rewind
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|st_write_EOF
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|stunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|scsi_fmt_cdb
modifier|*
name|cdb
init|=
operator|&
name|st_cmd
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|stat
decl_stmt|;
name|int
name|marks
init|=
literal|1
decl_stmt|;
name|ctlr
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|CMD_WRITE_FILEMARK
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* command finished soon */
name|cdb
operator|->
name|cdb
index|[
literal|2
index|]
operator|=
operator|(
name|marks
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|3
index|]
operator|=
operator|(
name|marks
operator|&
literal|0x00ff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
operator|(
name|marks
operator|&
literal|0x0000ff
operator|)
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* unknown setup */
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|cdb
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|printf
argument_list|(
literal|"st: write EOF error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|int
name|st_skip
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|stunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|scsi_fmt_cdb
modifier|*
name|cdb
init|=
operator|&
name|st_cmd
decl_stmt|;
specifier|register
name|int
name|nfmk
init|=
literal|1
decl_stmt|;
name|struct
name|scsi_xsense
modifier|*
name|sp
init|=
operator|(
expr|struct
name|scsi_xsense
operator|*
operator|)
name|sensebuf
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|stat
decl_stmt|;
name|ctlr
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|CMD_SPACE
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* it mean skip until EOF */
name|cdb
operator|->
name|cdb
index|[
literal|2
index|]
operator|=
operator|(
name|nfmk
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|3
index|]
operator|=
operator|(
name|nfmk
operator|&
literal|0x00ff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
operator|(
name|nfmk
operator|&
literal|0x0000ff
operator|)
expr_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* unknown setup */
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|cdb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
block|{
name|scsi_request_sense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|,
name|sp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|printf
argument_list|(
literal|"st_skip: Sense Key = [%s]"
argument_list|,
name|sense_key
argument_list|(
name|sp
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|filemark
condition|)
name|printf
argument_list|(
literal|" [EOF]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|eom
condition|)
name|printf
argument_list|(
literal|" [EOM]"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump  */
end_comment

begin_function
name|int
name|stdump
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{ }
end_function

end_unit

