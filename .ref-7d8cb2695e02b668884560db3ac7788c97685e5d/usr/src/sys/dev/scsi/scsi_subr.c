begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratories.  *  * %sccs.include.redist.c%  *  *	@(#)scsi_subr.c	5.4 (Berkeley) %G%  *  * from: $Header: scsi_subr.c,v 1.10 93/02/01 19:21:58 torek Exp $ (LBL)  */
end_comment

begin_comment
comment|/*  * Generic SCSI host adapter driver.  * Does almost nothing (most work is relegated to per-hba drivers).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsivar.h>
end_include

begin_comment
comment|/*  * General subroutines, and scsi data.  */
end_comment

begin_comment
comment|/* table of lengths of scsi commands */
end_comment

begin_decl_stmt
specifier|const
name|char
name|scsicmdlen
index|[
literal|8
index|]
init|=
block|{
literal|6
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of lengths of scsi messages */
end_comment

begin_decl_stmt
specifier|const
name|signed
name|char
name|scsimsglen
index|[
literal|0x24
index|]
init|=
block|{
name|SMLEN_DONE
block|,
comment|/* MSG_CMD_COMPLETE */
name|SMLEN_EXTENDED
block|,
comment|/* MSG_EXT_MESSAGE */
literal|1
block|,
comment|/* MSG_SAVE_DATA_PTR */
literal|1
block|,
comment|/* MSG_RESTORE_PTR */
literal|1
block|,
comment|/* MSG_DISCONNECT */
literal|1
block|,
comment|/* MSG_INIT_DETECT_ERROR */
literal|1
block|,
comment|/* MSG_ABORT */
literal|1
block|,
comment|/* MSG_REJECT */
literal|1
block|,
comment|/* MSG_NOOP */
literal|1
block|,
comment|/* MSG_PARITY_ERROR */
literal|1
block|,
comment|/* MSG_LCC */
literal|1
block|,
comment|/* MSG_LCCF */
literal|1
block|,
comment|/* MSG_BUS_DEVICE_RESET */
literal|1
block|,
comment|/* MSG_ABORT_TAG */
literal|1
block|,
comment|/* MSG_CLEAR_QUEUE */
literal|1
block|,
comment|/* MSG_INITIATE_RECOVERY */
literal|1
block|,
comment|/* MSG_RELEASE_RECOVERY */
literal|1
block|,
comment|/* MSG_TERMINATE_PROCESS */
name|SMLEN_UNDEF
block|,
comment|/* 0x12 */
name|SMLEN_UNDEF
block|,
comment|/* 0x13 */
name|SMLEN_UNDEF
block|,
comment|/* 0x14 */
name|SMLEN_UNDEF
block|,
comment|/* 0x15 */
name|SMLEN_UNDEF
block|,
comment|/* 0x16 */
name|SMLEN_UNDEF
block|,
comment|/* 0x17 */
name|SMLEN_UNDEF
block|,
comment|/* 0x18 */
name|SMLEN_UNDEF
block|,
comment|/* 0x19 */
name|SMLEN_UNDEF
block|,
comment|/* 0x1a */
name|SMLEN_UNDEF
block|,
comment|/* 0x1b */
name|SMLEN_UNDEF
block|,
comment|/* 0x1c */
name|SMLEN_UNDEF
block|,
comment|/* 0x1d */
name|SMLEN_UNDEF
block|,
comment|/* 0x1e */
name|SMLEN_UNDEF
block|,
comment|/* 0x1f */
literal|2
block|,
comment|/* MSG_SIMPLE_QTAG */
literal|2
block|,
comment|/* MSG_HEAD_QTAG */
literal|2
block|,
comment|/* MSG_ORDERED_QTAG */
literal|2
block|,
comment|/* MSG_IGNORE_WIDE_RESID */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* definition of `tg' target driver for autoconfig */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scsi_targmatch
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|cfdata
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scsi_targattach
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cfdriver
name|tgcd
init|=
block|{
name|NULL
block|,
literal|"tg"
block|,
name|scsi_targmatch
block|,
name|scsi_targattach
block|,
name|DV_DULL
block|,
expr|sizeof
operator|(
expr|struct
name|targ
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|scsi_targstart
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|sq
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|,
name|scdgo_fn
operator|,
expr|struct
name|device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsi_targgo
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|int
name|targ
operator|,
name|scintr_fn
operator|,
expr|struct
name|device
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|scsi_targintr
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|scsi_targrel
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOBUF
value|((caddr_t)0)
end_define

begin_comment
comment|/*  * Perform a TEST UNIT READY immediate (polled) command  * on the given<target,unit> pair.  Return the status byte  * returned, or -1 for none.  */
end_comment

begin_function
name|int
name|scsi_test_unit_ready
parameter_list|(
name|hba
parameter_list|,
name|targ
parameter_list|,
name|unit
parameter_list|)
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|int
name|targ
decl_stmt|,
name|unit
decl_stmt|;
block|{
name|struct
name|scsi_cdb
name|cdb
decl_stmt|;
name|CDB6
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_cmd
operator|=
name|CMD_TEST_UNIT_READY
expr_stmt|;
name|CDB6
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lun_lbah
operator|=
name|unit
operator|<<
literal|5
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|CDB6
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lbam
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|CDB6
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|hba
operator|->
name|hba_driver
operator|->
name|hd_icmd
argument_list|(
name|hba
argument_list|,
name|targ
argument_list|,
operator|&
name|cdb
argument_list|,
name|NOBUF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Request sense.  The sense is to be written into the given buffer.  * The given length must be< 256.  */
end_comment

begin_function
name|int
name|scsi_request_sense
parameter_list|(
name|hba
parameter_list|,
name|targ
parameter_list|,
name|unit
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|int
name|targ
decl_stmt|,
name|unit
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|scsi_cdb
name|cdb
decl_stmt|;
name|CDB6
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_cmd
operator|=
name|CMD_REQUEST_SENSE
expr_stmt|;
name|CDB6
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lun_lbah
operator|=
name|unit
operator|<<
literal|5
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|CDB6
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lbam
operator|=
literal|0
expr_stmt|;
name|CDB6
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_len
operator|=
name|len
expr_stmt|;
name|CDB6
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_ctrl
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|hba
operator|->
name|hba_driver
operator|->
name|hd_icmd
argument_list|(
name|hba
argument_list|,
name|targ
argument_list|,
operator|&
name|cdb
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|B_READ
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called (indirectly, via config_found) from scsi_hbaattach.  * Print target number, and if no device was configured there,  * the hba as well.  */
end_comment

begin_function
name|int
name|scsi_targprint
parameter_list|(
name|aux
parameter_list|,
name|hba
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|char
modifier|*
name|hba
decl_stmt|;
block|{
if|if
condition|(
name|hba
condition|)
block|{
name|printf
argument_list|(
literal|"target %d on %s"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|aux
argument_list|,
name|hba
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNCONF
operator|)
return|;
block|}
name|printf
argument_list|(
literal|" target %d"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|aux
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUIET
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print information about a unit found on some target.  * If the unit was not configured, `targ' is the name of the target  * on which the unit was found.  If it was, targ is NULL and we  * let the unit's attach routine print the INQUIRE result if  * appropriate.  */
end_comment

begin_function
specifier|static
name|int
name|scsi_unitprint
parameter_list|(
name|aux
parameter_list|,
name|targ
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|char
modifier|*
name|targ
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_attach_args
modifier|*
name|sa
init|=
name|aux
decl_stmt|;
if|if
condition|(
name|targ
condition|)
block|{
name|printf
argument_list|(
literal|"unit %d at %s"
argument_list|,
name|sa
operator|->
name|sa_unit
argument_list|,
name|targ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sa
operator|->
name|sa_inq_status
operator|&
name|STS_MASK
operator|)
operator|==
name|STS_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
name|scsi_printinq
argument_list|(
operator|&
name|sa
operator|->
name|sa_si
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|UNCONF
operator|)
return|;
block|}
name|printf
argument_list|(
literal|" unit %d"
argument_list|,
name|sa
operator|->
name|sa_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUIET
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic target-match.  */
end_comment

begin_function
specifier|static
name|int
name|scsi_targmatch
parameter_list|(
name|parent
parameter_list|,
name|cf
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
specifier|register
name|struct
name|cfdata
modifier|*
name|cf
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
name|int
name|targ
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|aux
decl_stmt|;
return|return
operator|(
name|cf
operator|->
name|cf_loc
index|[
literal|0
index|]
operator|==
name|targ
operator|||
name|cf
operator|->
name|cf_loc
index|[
literal|0
index|]
operator|==
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * And now, a generic `target attach' routine.  * We assume that INQUIRY works.  */
end_comment

begin_function
specifier|static
name|void
name|scsi_targattach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|self
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|aux
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|targ
modifier|*
name|t
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
specifier|register
name|struct
name|hbadriver
modifier|*
name|hd
decl_stmt|;
specifier|register
name|int
name|targ
decl_stmt|,
name|unit
decl_stmt|;
name|struct
name|scsi_attach_args
name|sa
decl_stmt|;
name|struct
name|scsi_cdb
name|si
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_targ
operator|=
name|targ
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|aux
expr_stmt|;
name|hba
operator|=
operator|(
expr|struct
name|hba_softc
operator|*
operator|)
name|parent
expr_stmt|;
name|hba
operator|->
name|hba_targets
index|[
name|targ
index|]
operator|=
name|t
expr_stmt|;
comment|/* 	 * Probe each of the 8 units using the sequence 	 *	TEST UNIT READY 	 *	REQUEST SENSE 	 *	INQUIRY 	 * The first should not be necessary, but some SCSI devices 	 * refuse to speak until it is done.  The second is only necessary 	 * if the first returns a CHECK CONDITION status, but we do it 	 * anyway. 	 */
name|hd
operator|=
name|hba
operator|->
name|hba_driver
expr_stmt|;
name|sa
operator|.
name|sa_targ
operator|=
name|targ
expr_stmt|;
name|CDB6
argument_list|(
operator|&
name|si
argument_list|)
operator|->
name|cdb_cmd
operator|=
name|CMD_INQUIRY
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|CDB6
argument_list|(
operator|&
name|si
argument_list|)
operator|->
name|cdb_lbam
operator|=
literal|0
expr_stmt|;
name|CDB6
argument_list|(
operator|&
name|si
argument_list|)
operator|->
name|cdb_len
operator|=
sizeof|sizeof
name|sa
operator|.
name|sa_si
expr_stmt|;
name|CDB6
argument_list|(
operator|&
name|si
argument_list|)
operator|->
name|cdb_ctrl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
literal|8
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
name|scsi_test_unit_ready
argument_list|(
name|hba
argument_list|,
name|targ
argument_list|,
name|unit
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|sa
operator|.
name|sa_unit
operator|=
name|unit
expr_stmt|;
name|sa
operator|.
name|sa_req_status
operator|=
name|scsi_request_sense
argument_list|(
name|hba
argument_list|,
name|targ
argument_list|,
name|unit
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sa
operator|.
name|sa_sn
argument_list|,
sizeof|sizeof
name|sa
operator|.
name|sa_sn
argument_list|)
expr_stmt|;
name|CDB6
argument_list|(
operator|&
name|si
argument_list|)
operator|->
name|cdb_lun_lbah
operator|=
name|unit
operator|<<
literal|5
expr_stmt|;
name|sa
operator|.
name|sa_inq_status
operator|=
call|(
modifier|*
name|hd
operator|->
name|hd_icmd
call|)
argument_list|(
name|hba
argument_list|,
name|targ
argument_list|,
operator|&
name|si
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sa
operator|.
name|sa_si
argument_list|,
sizeof|sizeof
name|sa
operator|.
name|sa_si
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sa
operator|.
name|sa_inq_status
operator|&
name|STS_MASK
operator|)
operator|==
name|STS_GOOD
operator|&&
ifdef|#
directive|ifdef
name|notdef
comment|/* XXX don't know if this is a reasonable test */
operator|(
name|sa
operator|.
name|sa_si
operator|.
name|si_type
operator|&
name|TYPE_QUAL_MASK
operator|)
operator|==
name|TYPE_QUAL_NOTCONN
operator|&&
endif|#
directive|endif
operator|(
name|sa
operator|.
name|sa_si
operator|.
name|si_type
operator|&
name|TYPE_TYPE_MASK
operator|)
operator|==
name|TYPE_NP
condition|)
block|{
continue|continue;
block|}
name|config_found
argument_list|(
operator|&
name|t
operator|->
name|t_dev
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sa
argument_list|,
name|scsi_unitprint
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Each unit calls scsi_establish to tell the hba and target of  * its existence.  */
end_comment

begin_function
name|void
name|scsi_establish
parameter_list|(
name|u
parameter_list|,
name|dev
parameter_list|,
name|unit
parameter_list|)
specifier|register
name|struct
name|unit
modifier|*
name|u
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|targ
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
specifier|register
name|struct
name|hbadriver
modifier|*
name|hbd
decl_stmt|;
name|u
operator|->
name|u_dev
operator|=
name|dev
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|dev
operator|->
name|dv_parent
expr_stmt|;
name|hba
operator|=
operator|(
expr|struct
name|hba_softc
operator|*
operator|)
name|t
operator|->
name|t_dev
operator|.
name|dv_parent
expr_stmt|;
name|hbd
operator|=
name|hba
operator|->
name|hba_driver
expr_stmt|;
name|t
operator|->
name|t_units
index|[
name|unit
index|]
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_nunits
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is the first unit on the target.  We can 		 * probably just call the hba start code, avoiding 		 * one level of calls and queueing.  If we attach 		 * another target we will fix this in the code below. 		 */
name|u
operator|->
name|u_start
operator|=
name|hbd
operator|->
name|hd_start
expr_stmt|;
name|u
operator|->
name|u_go
operator|=
name|hbd
operator|->
name|hd_go
expr_stmt|;
name|u
operator|->
name|u_rel
operator|=
name|hbd
operator|->
name|hd_rel
expr_stmt|;
name|u
operator|->
name|u_updev
operator|=
operator|&
name|hba
operator|->
name|hba_dev
expr_stmt|;
name|t
operator|->
name|t_firstunit
operator|=
name|unit
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is not the only unit on the target, so we 		 * must call the target start code rather than the 		 * hba start code.  Fix the linkage on the first 		 * target too (possibly for the 2nd, 3rd, ..., time). 		 */
name|t
operator|->
name|t_units
index|[
name|t
operator|->
name|t_firstunit
index|]
operator|->
name|u_start
operator|=
name|scsi_targstart
expr_stmt|;
name|t
operator|->
name|t_units
index|[
name|t
operator|->
name|t_firstunit
index|]
operator|->
name|u_updev
operator|=
operator|&
name|t
operator|->
name|t_dev
expr_stmt|;
name|u
operator|->
name|u_start
operator|=
name|scsi_targstart
expr_stmt|;
name|u
operator|->
name|u_go
operator|=
name|scsi_targgo
expr_stmt|;
name|u
operator|->
name|u_rel
operator|=
name|scsi_targrel
expr_stmt|;
name|u
operator|->
name|u_updev
operator|=
operator|&
name|t
operator|->
name|t_dev
expr_stmt|;
block|}
name|t
operator|->
name|t_nunits
operator|++
expr_stmt|;
comment|/* another unit is alive */
name|u
operator|->
name|u_unit
operator|=
name|unit
expr_stmt|;
name|u
operator|->
name|u_targ
operator|=
name|t
operator|->
name|t_targ
expr_stmt|;
comment|/* record target number, */
name|u
operator|->
name|u_hba
operator|=
name|hba
expr_stmt|;
comment|/* hba ... */
name|u
operator|->
name|u_hbd
operator|=
name|hbd
expr_stmt|;
comment|/* and driver */
block|}
end_function

begin_comment
comment|/* NO DOUBT SOME OF THE STUFF PRINTED HERE IS USELESS */
end_comment

begin_function
name|void
name|scsi_printinq
parameter_list|(
name|inq
parameter_list|)
specifier|register
name|struct
name|scsi_inquiry
modifier|*
name|inq
decl_stmt|;
block|{
specifier|register
name|int
name|iso
decl_stmt|,
name|ecma
decl_stmt|,
name|ansi
decl_stmt|,
name|t
decl_stmt|;
specifier|static
name|char
modifier|*
name|types
index|[]
init|=
block|{
literal|"disk"
block|,
literal|"tape"
block|,
literal|"printer"
block|,
literal|"processor"
block|,
literal|"WORM"
block|,
literal|"ROM disk"
block|,
literal|"scanner"
block|,
literal|"magneto-optical"
block|,
literal|"jukebox"
block|,
literal|"lan"
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|inq
operator|->
name|si_type
operator|&
name|TYPE_QUAL_MASK
operator|)
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"type-qual=0x%x "
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|inq
operator|->
name|si_type
operator|&
name|TYPE_TYPE_MASK
expr_stmt|;
if|if
condition|(
name|t
operator|<
sizeof|sizeof
name|types
operator|/
sizeof|sizeof
expr|*
name|types
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|types
index|[
name|t
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<type %d>"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|inq
operator|->
name|si_qual
operator|&
name|QUAL_RMB
condition|)
name|printf
argument_list|(
literal|" (removable)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" qual=0x%x"
argument_list|,
name|inq
operator|->
name|si_qual
operator|&
name|QUAL_MASK
argument_list|)
expr_stmt|;
name|iso
operator|=
operator|(
name|inq
operator|->
name|si_qual
operator|>>
name|VER_ISO_SHIFT
operator|)
operator|&
name|VER_ISO_MASK
expr_stmt|;
name|ecma
operator|=
operator|(
name|inq
operator|->
name|si_qual
operator|>>
name|VER_ECMA_SHIFT
operator|)
operator|&
name|VER_ECMA_MASK
expr_stmt|;
name|ansi
operator|=
operator|(
name|inq
operator|->
name|si_qual
operator|>>
name|VER_ANSI_SHIFT
operator|)
operator|&
name|VER_ANSI_MASK
expr_stmt|;
name|printf
argument_list|(
literal|" version=<iso %d, ecma %d, ansi %d>"
argument_list|,
name|iso
argument_list|,
name|ecma
argument_list|,
name|ansi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ansi
operator|==
literal|1
operator|||
name|ansi
operator|==
literal|2
condition|)
block|{
name|char
name|v
index|[
literal|9
index|]
decl_stmt|,
name|p
index|[
literal|17
index|]
decl_stmt|,
name|r
index|[
literal|5
index|]
decl_stmt|;
name|scsi_inq_ansi
argument_list|(
operator|(
expr|struct
name|scsi_inq_ansi
operator|*
operator|)
name|inq
argument_list|,
name|v
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" vendor %s, product %s, rev %s"
argument_list|,
name|v
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* copy a counted string but trim trailing blanks; make the dest a C string */
end_comment

begin_function
specifier|static
name|void
name|scsi_str
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|src
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dst
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|void
name|scsi_inq_ansi
parameter_list|(
name|si
parameter_list|,
name|vendor
parameter_list|,
name|product
parameter_list|,
name|rev
parameter_list|)
specifier|register
name|struct
name|scsi_inq_ansi
modifier|*
name|si
decl_stmt|;
name|char
modifier|*
name|vendor
decl_stmt|,
decl|*
name|product
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
comment|/* if too short, extend with blanks */
name|len
operator|=
name|si
operator|->
name|si_len
operator|+
literal|5
expr_stmt|;
comment|/* 5 fixed; len is `additional' */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|<
sizeof|sizeof
expr|*
name|si
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
name|si
operator|)
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|scsi_str
argument_list|(
name|si
operator|->
name|si_vendor
argument_list|,
name|vendor
argument_list|,
sizeof|sizeof
name|si
operator|->
name|si_vendor
argument_list|)
expr_stmt|;
name|scsi_str
argument_list|(
name|si
operator|->
name|si_product
argument_list|,
name|product
argument_list|,
sizeof|sizeof
name|si
operator|->
name|si_product
argument_list|)
expr_stmt|;
name|scsi_str
argument_list|(
name|si
operator|->
name|si_rev
argument_list|,
name|rev
argument_list|,
sizeof|sizeof
name|si
operator|->
name|si_rev
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Tell all the devices on the given hba that it has been reset.  * SHOULD PROBABLY DO MORE HERE  */
end_comment

begin_function
name|void
name|scsi_reset_units
parameter_list|(
name|hba
parameter_list|)
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
block|{
specifier|register
name|int
name|targ
decl_stmt|,
name|unit
decl_stmt|;
specifier|register
name|struct
name|targ
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|unit
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|targ
operator|=
literal|0
init|;
name|targ
operator|<
literal|8
condition|;
name|targ
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|hba
operator|->
name|hba_targets
index|[
name|targ
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
literal|8
condition|;
name|unit
operator|++
control|)
if|if
condition|(
operator|(
name|u
operator|=
name|t
operator|->
name|t_units
index|[
name|unit
index|]
operator|)
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|u
operator|->
name|u_driver
operator|->
name|ud_reset
call|)
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start a unit on a target.  * If the target is busy, just enqueue the unit;  * once the target becomes free, we will call the hba start routine.  * Otherwise, call the hba start routine now, and then when the hba  * becomes free it will call the unit's dgo routine.  */
end_comment

begin_function
name|void
name|scsi_targstart
parameter_list|(
name|self
parameter_list|,
name|sq
parameter_list|,
name|bp
parameter_list|,
name|dgo
parameter_list|,
name|dev
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
specifier|register
name|struct
name|sq
modifier|*
name|sq
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|scdgo_fn
name|dgo
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|targ
modifier|*
name|t
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|sq
operator|->
name|sq_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_head
operator|==
name|NULL
condition|)
name|t
operator|->
name|t_head
operator|=
name|sq
expr_stmt|;
else|else
name|t
operator|->
name|t_tail
operator|->
name|sq_forw
operator|=
name|sq
expr_stmt|;
name|t
operator|->
name|t_tail
operator|=
name|sq
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_busy
operator|==
literal|0
condition|)
block|{
name|t
operator|->
name|t_busy
operator|=
literal|1
expr_stmt|;
name|hba
operator|=
operator|(
expr|struct
name|hba_softc
operator|*
operator|)
name|t
operator|->
name|t_dev
operator|.
name|dv_parent
expr_stmt|;
call|(
modifier|*
name|hba
operator|->
name|hba_driver
operator|->
name|hd_start
call|)
argument_list|(
operator|&
name|hba
operator|->
name|hba_dev
argument_list|,
operator|&
name|t
operator|->
name|t_forw
argument_list|,
name|bp
argument_list|,
name|dgo
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sq
operator|->
name|sq_bp
operator|=
name|bp
expr_stmt|;
name|sq
operator|->
name|sq_dgo
operator|=
name|dgo
expr_stmt|;
name|sq
operator|->
name|sq_dev
operator|=
name|dev
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The unit got the bus, and wants the hba to go.  * Remember its interrupt handler; substitute ours instead.  */
end_comment

begin_function
name|int
name|scsi_targgo
parameter_list|(
name|self
parameter_list|,
name|targ
parameter_list|,
name|intr
parameter_list|,
name|dev
parameter_list|,
name|bp
parameter_list|,
name|pad
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
name|int
name|targ
decl_stmt|;
name|scintr_fn
name|intr
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|pad
decl_stmt|;
block|{
specifier|register
name|struct
name|targ
modifier|*
name|t
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
name|t
operator|->
name|t_intr
operator|=
name|intr
expr_stmt|;
name|t
operator|->
name|t_intrdev
operator|=
name|dev
expr_stmt|;
name|hba
operator|=
operator|(
expr|struct
name|hba_softc
operator|*
operator|)
name|t
operator|->
name|t_dev
operator|.
name|dv_parent
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|hba
operator|->
name|hba_driver
operator|->
name|hd_go
call|)
argument_list|(
operator|&
name|hba
operator|->
name|hba_dev
argument_list|,
name|targ
argument_list|,
name|scsi_targintr
argument_list|,
operator|&
name|t
operator|->
name|t_dev
argument_list|,
name|bp
argument_list|,
name|pad
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The hba got an interrupt.  Dequeue the unit from the target  * (the target is already off the hba queue) and then call the  * underlying interrupt handler.  */
end_comment

begin_function
name|void
name|scsi_targintr
parameter_list|(
name|self
parameter_list|,
name|stat
parameter_list|,
name|resid
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
name|int
name|stat
decl_stmt|,
name|resid
decl_stmt|;
block|{
specifier|register
name|struct
name|targ
modifier|*
name|t
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
specifier|register
name|struct
name|sq
modifier|*
name|sq
decl_stmt|;
name|sq
operator|=
name|t
operator|->
name|t_head
expr_stmt|;
if|if
condition|(
name|sq
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"scsi_targintr"
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_head
operator|=
name|sq
operator|=
name|sq
operator|->
name|sq_forw
expr_stmt|;
call|(
modifier|*
name|t
operator|->
name|t_intr
call|)
argument_list|(
name|t
operator|->
name|t_intrdev
argument_list|,
name|stat
argument_list|,
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|!=
name|NULL
condition|)
block|{
name|hba
operator|=
operator|(
expr|struct
name|hba_softc
operator|*
operator|)
name|t
operator|->
name|t_dev
operator|.
name|dv_parent
expr_stmt|;
call|(
modifier|*
name|hba
operator|->
name|hba_driver
operator|->
name|hd_start
call|)
argument_list|(
operator|&
name|hba
operator|->
name|hba_dev
argument_list|,
operator|&
name|t
operator|->
name|t_forw
argument_list|,
name|sq
operator|->
name|sq_bp
argument_list|,
name|sq
operator|->
name|sq_dgo
argument_list|,
name|sq
operator|->
name|sq_dev
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|->
name|t_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The unit decided that it needed to `give up' its hold on the bus early.  */
end_comment

begin_function
name|void
name|scsi_targrel
parameter_list|(
name|self
parameter_list|)
name|struct
name|device
modifier|*
name|self
decl_stmt|;
block|{
specifier|register
name|struct
name|targ
modifier|*
name|t
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
specifier|register
name|struct
name|sq
modifier|*
name|sq
decl_stmt|;
name|hba
operator|=
operator|(
expr|struct
name|hba_softc
operator|*
operator|)
name|t
operator|->
name|t_dev
operator|.
name|dv_parent
expr_stmt|;
name|sq
operator|=
name|t
operator|->
name|t_head
expr_stmt|;
if|if
condition|(
name|sq
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"scsi_targrel"
argument_list|)
expr_stmt|;
comment|/* 	 * This target is at the head of the hba queue. 	 * Remove it by calling hba bus release.  Then, if the 	 * target queue is not empty, put it back on the hba queue. 	 * (This produces round robin service.) 	 */
call|(
modifier|*
name|hba
operator|->
name|hba_driver
operator|->
name|hd_rel
call|)
argument_list|(
operator|&
name|hba
operator|->
name|hba_dev
argument_list|)
expr_stmt|;
name|sq
operator|=
name|sq
operator|->
name|sq_forw
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|t_head
operator|=
name|sq
operator|)
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|hba
operator|->
name|hba_driver
operator|->
name|hd_start
call|)
argument_list|(
operator|&
name|hba
operator|->
name|hba_dev
argument_list|,
operator|&
name|t
operator|->
name|t_forw
argument_list|,
name|sq
operator|->
name|sq_bp
argument_list|,
name|sq
operator|->
name|sq_dgo
argument_list|,
name|sq
operator|->
name|sq_dev
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|t_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

