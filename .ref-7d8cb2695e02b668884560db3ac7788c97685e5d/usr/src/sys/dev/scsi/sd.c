begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)sd.c	5.7 (Berkeley) %G%  *  * from: $Header: sd.c,v 1.27 93/04/29 01:22:19 torek Exp $  */
end_comment

begin_comment
comment|/*  * SCSI CCS (Command Command Set) disk driver.  *  * MACHINE INDEPENDENT (do not put machine dependent goo in here!)  *  * (from sd.c,v 1.7 90/12/15 14:11:26 van Exp)  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/disk.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsi_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/sdtrace.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|SUN_LABEL_HACK
end_define

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUN_LABEL_HACK
end_ifdef

begin_include
include|#
directive|include
file|<sparc/sunos/sun_disklabel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Per-disk variables.  *  * sd_dk contains all the `disk' specific stuff (label/partitions,  * transfer rate, etc).  We need only things that are special to  * scsi disks.  Note that our blocks are in terms of DEV_BSIZE blocks.  */
end_comment

begin_struct
struct|struct
name|sd_softc
block|{
name|struct
name|dkdevice
name|sc_dk
decl_stmt|;
comment|/* base disk device, must be first */
name|struct
name|unit
name|sc_unit
decl_stmt|;
comment|/* scsi unit */
name|pid_t
name|sc_format_pid
decl_stmt|;
comment|/* process using "format" mode */
name|u_char
name|sc_type
decl_stmt|;
comment|/* drive type */
name|u_char
name|sc_bshift
decl_stmt|;
comment|/* convert device blocks to DEV_BSIZE blks */
name|short
name|sc_flags
decl_stmt|;
comment|/* see below */
name|u_int
name|sc_blks
decl_stmt|;
comment|/* number of blocks on device */
name|int
name|sc_blksize
decl_stmt|;
comment|/* device block size in bytes */
comment|/* should be in dkdevice?? */
name|struct
name|buf
name|sc_tab
decl_stmt|;
comment|/* transfer queue */
comment|/* statistics */
name|long
name|sc_resets
decl_stmt|;
comment|/* number of times reset */
name|long
name|sc_transfers
decl_stmt|;
comment|/* count of total transfers */
name|long
name|sc_partials
decl_stmt|;
comment|/* count of `partial' transfers */
comment|/* for user formatting */
name|struct
name|scsi_cdb
name|sc_cmd
decl_stmt|;
name|struct
name|scsi_fmt_sense
name|sc_sense
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SDF_ALIVE
value|1
end_define

begin_comment
comment|/* drive OK for regular kernel use */
end_comment

begin_comment
comment|/* definition of the autoconfig driver */
end_comment

begin_decl_stmt
name|int
name|sdmatch
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|cfdata
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sdattach
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cfdriver
name|sdcd
init|=
block|{
name|NULL
block|,
literal|"sd"
block|,
name|sdmatch
block|,
name|sdattach
block|,
name|DV_DISK
block|,
expr|sizeof
operator|(
expr|struct
name|sd_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* definition of the unit driver, for hba */
end_comment

begin_decl_stmt
name|void
name|sdigo
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|scsi_cdb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sdgo
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|scsi_cdb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sdintr
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sdreset
name|__P
argument_list|(
operator|(
expr|struct
name|unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unitdriver
name|sdunitdriver
init|=
block|{
comment|/*sdgo, sdintr*/
name|sdreset
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* definition of the disk driver, for kernel */
end_comment

begin_decl_stmt
name|void
name|sdstrategy
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dkdriver
name|sddkdriver
init|=
block|{
name|sdstrategy
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|sddebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SDB_ERROR
value|0x01
end_define

begin_define
define|#
directive|define
name|SDB_PARTIAL
value|0x02
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sdunit
parameter_list|(
name|x
parameter_list|)
value|(minor(x)>> 3)
end_define

begin_define
define|#
directive|define
name|sdpart
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& 0x7)
end_define

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_define
define|#
directive|define
name|SDRETRY
value|2
end_define

begin_comment
comment|/*  * Table of scsi commands users are allowed to access via `format'  * mode.  0 means not legal.  1 means `immediate' (doesn't need dma).  * -1 means needs dma and/or wait for intr (i.e., `slow').  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|legal_cmds
index|[
literal|256
index|]
init|=
block|{
comment|/*****  0   1   2   3   4   5   6   7     8   9   A   B   C   D   E   F */
comment|/*00*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*10*/
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*20*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*30*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*40*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*50*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*60*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*70*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*80*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*90*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*a0*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*b0*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*c0*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*d0*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*e0*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*f0*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sdmatch
parameter_list|(
name|parent
parameter_list|,
name|cf
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
specifier|register
name|struct
name|cfdata
modifier|*
name|cf
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_attach_args
modifier|*
name|sa
init|=
name|aux
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|char
modifier|*
name|whynot
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * unit number must match, or be given as `any' 	 */
if|if
condition|(
name|cf
operator|->
name|cf_loc
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|cf
operator|->
name|cf_loc
index|[
literal|0
index|]
operator|!=
name|sa
operator|->
name|sa_unit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * drive must be a disk, and of a kind we recognize 	 */
if|if
condition|(
operator|(
name|sa
operator|->
name|sa_inq_status
operator|&
name|STS_MASK
operator|)
operator|!=
name|STS_GOOD
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|whynot
operator|=
literal|"INQUIRY failed"
expr_stmt|;
endif|#
directive|endif
goto|goto
name|notdisk
goto|;
block|}
switch|switch
condition|(
name|sa
operator|->
name|sa_si
operator|.
name|si_type
operator|&
name|TYPE_TYPE_MASK
condition|)
block|{
case|case
name|TYPE_DAD
case|:
comment|/* disk */
case|case
name|TYPE_WORM
case|:
comment|/* WORM */
case|case
name|TYPE_ROM
case|:
comment|/* CD-ROM */
case|case
name|TYPE_MO
case|:
comment|/* Magneto-optical */
case|case
name|TYPE_JUKEBOX
case|:
comment|/* medium changer */
break|break;
default|default:
name|notdisk
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|whynot
operator|=
literal|"not a disk"
expr_stmt|;
name|printf
argument_list|(
literal|"[not matching `sd' at unit %d: %s]\n"
argument_list|,
name|sa
operator|->
name|sa_unit
argument_list|,
name|whynot
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * It is a disk of some kind; take it.  We will figure out 	 * the rest in the attach routine. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a disk (called after sdmatch returns true).  * Note that this routine is never reentered (so we can use statics).  */
end_comment

begin_function
name|void
name|sdattach
parameter_list|(
name|parent
parameter_list|,
name|self
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|,
decl|*
name|self
decl_stmt|;
end_function

begin_decl_stmt
name|void
modifier|*
name|aux
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sd_softc
operator|*
operator|)
name|self
decl_stmt|;
specifier|register
name|struct
name|scsi_attach_args
modifier|*
name|sa
init|=
name|aux
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|vendor
index|[
literal|10
index|]
decl_stmt|,
name|drive
index|[
literal|17
index|]
decl_stmt|,
name|rev
index|[
literal|5
index|]
decl_stmt|;
specifier|static
name|u_char
name|capbuf
index|[
literal|8
index|]
decl_stmt|;
specifier|static
name|struct
name|scsi_cdb
name|cap
init|=
block|{
name|CMD_READ_CAPACITY
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|SUN_LABEL_HACK
specifier|static
name|struct
name|scsi_cdb
name|rd0
init|=
block|{
name|CMD_READ10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
name|caddr_t
name|sector
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Declare our existence. 	 */
name|sc
operator|->
name|sc_unit
operator|.
name|u_driver
operator|=
operator|&
name|sdunitdriver
expr_stmt|;
name|scsi_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_unit
argument_list|,
operator|&
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
argument_list|,
name|sa
operator|->
name|sa_unit
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out what kind of disk this is. 	 * We only accepted it if the inquiry succeeded, so 	 * we can inspect those fields. 	 */
name|i
operator|=
operator|(
name|sa
operator|->
name|sa_si
operator|.
name|si_version
operator|>>
name|VER_ANSI_SHIFT
operator|)
operator|&
name|VER_ANSI_MASK
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
operator|||
name|i
operator|==
literal|2
condition|)
block|{
name|scsi_inq_ansi
argument_list|(
operator|(
expr|struct
name|scsi_inq_ansi
operator|*
operator|)
operator|&
name|sa
operator|->
name|sa_si
argument_list|,
name|vendor
argument_list|,
name|drive
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": %s %s"
argument_list|,
name|vendor
argument_list|,
name|drive
argument_list|)
expr_stmt|;
comment|/* XXX should we even ever bother printing this? */
if|if
condition|(
name|rev
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* bleah */
name|bcopy
argument_list|(
literal|"<unknown>"
argument_list|,
name|vendor
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"<unknown>"
argument_list|,
name|drive
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": type 0x%x, qual 0x%x, ver %d"
argument_list|,
name|sa
operator|->
name|sa_si
operator|.
name|si_type
argument_list|,
name|sa
operator|->
name|sa_si
operator|.
name|si_qual
argument_list|,
name|sa
operator|->
name|sa_si
operator|.
name|si_version
argument_list|)
expr_stmt|;
block|}
name|CDB10
argument_list|(
operator|&
name|cap
argument_list|)
operator|->
name|cdb_lun_rel
operator|=
name|sc
operator|->
name|sc_unit
operator|.
name|u_unit
operator|<<
literal|5
expr_stmt|;
name|i
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_unit
operator|.
name|u_hbd
operator|->
name|hd_icmd
call|)
argument_list|(
name|sc
operator|->
name|sc_unit
operator|.
name|u_hba
argument_list|,
name|sc
operator|->
name|sc_unit
operator|.
name|u_targ
argument_list|,
operator|&
name|cap
argument_list|,
operator|(
name|char
operator|*
operator|)
name|capbuf
argument_list|,
sizeof|sizeof
name|capbuf
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
name|i
operator|&=
name|STS_MASK
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|STS_GOOD
condition|)
block|{
define|#
directive|define
name|NUMBER
parameter_list|(
name|p
parameter_list|)
value|(((p)[0]<< 24) | ((p)[1]<< 16) | ((p)[2]<< 8) | (p)[3])
name|sc
operator|->
name|sc_blks
operator|=
name|NUMBER
argument_list|(
operator|&
name|capbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blksize
operator|=
name|NUMBER
argument_list|(
operator|&
name|capbuf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|STS_CHECKCOND
operator|&&
operator|(
name|strcmp
argument_list|(
name|vendor
argument_list|,
literal|"HP"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|drive
argument_list|,
literal|"S6300.650A"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* XXX unformatted or nonexistent MO medium: fake it */
name|sc
operator|->
name|sc_blks
operator|=
literal|318664
expr_stmt|;
name|sc
operator|->
name|sc_blksize
operator|=
literal|1024
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX shouldn't bail for removable media */
name|printf
argument_list|(
literal|": unable to determine drive capacity [sts=%x]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* return value from read capacity is last valid block, not nblocks */
name|sc
operator|->
name|sc_blks
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|", %u %d byte blocks\n"
argument_list|,
name|sc
operator|->
name|sc_blks
argument_list|,
name|sc
operator|->
name|sc_blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blksize
operator|!=
name|DEV_BSIZE
condition|)
block|{
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|sc_blksize
init|;
name|i
operator|>
name|DEV_BSIZE
condition|;
name|i
operator|>>=
literal|1
control|)
operator|++
name|sc
operator|->
name|sc_bshift
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|DEV_BSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: blksize not multiple of %d: cannot use\n"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_blks
operator|<<=
name|sc
operator|->
name|sc_bshift
expr_stmt|;
block|}
name|sc
operator|->
name|sc_type
operator|=
name|sa
operator|->
name|sa_si
operator|.
name|si_type
expr_stmt|;
comment|/* sufficient? */
name|sc
operator|->
name|sc_dk
operator|.
name|dk_driver
operator|=
operator|&
name|sddkdriver
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|dk_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_dk
argument_list|)
expr_stmt|;
comment|/* READ DISK LABEL HERE, UNLESS REMOVABLE MEDIUM... NEEDS THOUGHT */
else|#
directive|else
name|sc
operator|->
name|sc_dk
operator|.
name|dk_label
operator|.
name|d_secsize
operator|=
literal|512
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|sc_dk
operator|.
name|dk_bps
operator|=
operator|(
literal|3600
operator|/
literal|60
operator|)
operator|*
literal|32
operator|*
literal|512
expr_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|SUN_LABEL_HACK
name|sector
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|sc
operator|->
name|sc_blksize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|rd0
argument_list|)
operator|->
name|cdb_lun_rel
operator|=
name|sc
operator|->
name|sc_unit
operator|.
name|u_unit
operator|<<
literal|5
expr_stmt|;
name|i
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_unit
operator|.
name|u_hbd
operator|->
name|hd_icmd
call|)
argument_list|(
name|sc
operator|->
name|sc_unit
operator|.
name|u_hba
argument_list|,
name|sc
operator|->
name|sc_unit
operator|.
name|u_targ
argument_list|,
operator|&
name|rd0
argument_list|,
name|sector
argument_list|,
name|sc
operator|->
name|sc_blksize
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|STS_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"%s:<%s>\n"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|,
operator|(
operator|(
expr|struct
name|sun_disklabel
operator|*
operator|)
name|sector
operator|)
operator|->
name|sl_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|sun_disklabel
argument_list|(
name|sector
argument_list|,
operator|&
name|sc
operator|->
name|sc_dk
operator|.
name|dk_label
argument_list|)
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|SDF_ALIVE
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s: sun_disklabel fails\n"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: could not read sector 0 for disk label\n"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sector
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* notyet */
block|}
end_block

begin_comment
comment|/*  * Reset a disk, after a SCSI bus reset.  *  * XXX untested and probably incomplete/incorrect  */
end_comment

begin_function
name|void
name|sdreset
parameter_list|(
name|u
parameter_list|)
specifier|register
name|struct
name|unit
modifier|*
name|u
decl_stmt|;
block|{
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sd_softc
operator|*
operator|)
name|u
operator|->
name|u_dev
decl_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_resets
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dev_t is short, must use prototype syntax */
end_comment

begin_function
name|int
name|sdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|ifmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|int
name|unit
init|=
name|sdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|sdcd
operator|.
name|cd_ndevs
operator|||
operator|(
name|sc
operator|=
name|sdcd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SDF_ALIVE
operator|)
operator|==
literal|0
operator|&&
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|ifmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
init|=
name|sdcd
operator|.
name|cd_devs
index|[
name|sdunit
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|sc
operator|->
name|sc_format_pid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called for partial block transfers and non-aligned  * transfers (the latter only being possible on devices with a block size  * larger than DEV_BSIZE).  The operation is performed in three steps  * using a locally allocated buffer:  *	1. transfer any initial partial block  *	2. transfer full blocks  *	3. transfer any final partial block  */
end_comment

begin_function
specifier|static
name|void
name|sdlblkstrat
parameter_list|(
name|bp
parameter_list|,
name|bsize
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|bsize
decl_stmt|;
block|{
specifier|register
name|int
name|bn
decl_stmt|,
name|resid
decl_stmt|,
name|boff
decl_stmt|,
name|count
decl_stmt|;
specifier|register
name|caddr_t
name|addr
decl_stmt|,
name|cbuf
decl_stmt|;
name|struct
name|buf
modifier|*
name|tbp
decl_stmt|;
comment|/* should probably use geteblk() here, but I fear consequences */
name|cbuf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|tbp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|tbp
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|tbp
argument_list|,
sizeof|sizeof
expr|*
name|tbp
argument_list|)
expr_stmt|;
name|tbp
operator|->
name|b_proc
operator|=
name|curproc
expr_stmt|;
name|tbp
operator|->
name|b_dev
operator|=
name|bp
operator|->
name|b_dev
expr_stmt|;
name|bn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sddebug
operator|&
name|SDB_PARTIAL
condition|)
name|printf
argument_list|(
literal|"sdlblkstrat: bp %x flags %x bn %x resid %x addr %x\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bn
argument_list|,
name|resid
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
name|boff
operator|=
name|dbtob
argument_list|(
name|bn
argument_list|)
operator|&
operator|(
name|bsize
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|boff
operator|||
name|resid
operator|<
name|bsize
condition|)
block|{
name|struct
name|sd_softc
modifier|*
name|sc
init|=
name|sdcd
operator|.
name|cd_devs
index|[
name|sdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
name|sc
operator|->
name|sc_partials
operator|++
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|resid
argument_list|,
name|bsize
operator|-
name|boff
argument_list|)
expr_stmt|;
name|tbp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|tbp
operator|->
name|b_blkno
operator|=
name|bn
operator|-
name|btodb
argument_list|(
name|boff
argument_list|)
expr_stmt|;
name|tbp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|cbuf
expr_stmt|;
name|tbp
operator|->
name|b_bcount
operator|=
name|bsize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sddebug
operator|&
name|SDB_PARTIAL
condition|)
name|printf
argument_list|(
literal|" readahead: bn %x cnt %x off %x addr %x\n"
argument_list|,
name|tbp
operator|->
name|b_blkno
argument_list|,
name|count
argument_list|,
name|boff
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sdstrategy
argument_list|(
name|tbp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|tbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|tbp
operator|->
name|b_error
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|cbuf
index|[
name|boff
index|]
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|&
name|cbuf
index|[
name|boff
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sddebug
operator|&
name|SDB_PARTIAL
condition|)
name|printf
argument_list|(
literal|" writeback: bn %x cnt %x off %x addr %x\n"
argument_list|,
name|tbp
operator|->
name|b_blkno
argument_list|,
name|count
argument_list|,
name|boff
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|count
operator|=
name|resid
operator|&
operator|~
operator|(
name|bsize
operator|-
literal|1
operator|)
expr_stmt|;
name|tbp
operator|->
name|b_blkno
operator|=
name|bn
expr_stmt|;
name|tbp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|addr
expr_stmt|;
name|tbp
operator|->
name|b_bcount
operator|=
name|count
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sddebug
operator|&
name|SDB_PARTIAL
condition|)
name|printf
argument_list|(
literal|" fulltrans: bn %x cnt %x addr %x\n"
argument_list|,
name|tbp
operator|->
name|b_blkno
argument_list|,
name|count
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|tbp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
expr_stmt|;
name|sdstrategy
argument_list|(
name|tbp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|tbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|tbp
operator|->
name|b_error
expr_stmt|;
break|break;
block|}
name|done
label|:
name|bn
operator|+=
name|btodb
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|resid
operator|-=
name|count
expr_stmt|;
name|addr
operator|+=
name|count
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sddebug
operator|&
name|SDB_PARTIAL
condition|)
name|printf
argument_list|(
literal|" done: bn %x resid %x addr %x\n"
argument_list|,
name|bn
argument_list|,
name|resid
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|free
argument_list|(
name|cbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|tbp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a transfer on sc as described by bp  * (i.e., call hba or target start).  * If in format mode, we may not need dma.  */
end_comment

begin_define
define|#
directive|define
name|sdstart
parameter_list|(
name|sc
parameter_list|,
name|bp
parameter_list|)
value|{ \ 	SD_TRACE(T_START, sc, bp); \ 	if ((sc)->sc_format_pid&& legal_cmds[(sc)->sc_cmd.cdb_bytes[0]]> 0) \ 		(*(sc)->sc_unit.u_start)((sc)->sc_unit.u_updev, \&(sc)->sc_unit.u_forw, (struct buf *)NULL, \ 		    sdigo,&(sc)->sc_dk.dk_dev); \ 	else \ 		(*(sc)->sc_unit.u_start)((sc)->sc_unit.u_updev, \&(sc)->sc_unit.u_forw, bp, sdgo,&(sc)->sc_dk.dk_dev); \ }
end_define

begin_function
name|void
name|sdstrategy
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
init|=
name|sdcd
operator|.
name|cd_devs
index|[
name|sdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_format_pid
condition|)
block|{
comment|/* XXXXXXXXX SHOULD NOT COMPARE curproc IN HERE!?! */
comment|/* 		 * In format mode, only allow the owner to mess 		 * with the drive.  Skip all the partition checks. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_format_pid
operator|!=
name|curproc
operator|->
name|p_pid
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EPERM
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_cylin
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|daddr_t
name|bn
init|=
name|bp
operator|->
name|b_blkno
decl_stmt|;
specifier|register
name|int
name|sz
init|=
name|howmany
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|DEV_BSIZE
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|p
decl_stmt|;
comment|/* 		 * Make sure transfer is within partition. 		 * If it starts at the end, return EOF; if 		 * it extends past the end, truncate it. 		 */
name|p
operator|=
operator|&
name|sc
operator|->
name|sc_dk
operator|.
name|dk_label
operator|.
name|d_partitions
index|[
name|sdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|bn
operator|>=
name|p
operator|->
name|p_size
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|bn
operator|>
name|p
operator|->
name|p_size
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bn
operator|+
name|sz
operator|>
name|p
operator|->
name|p_size
condition|)
block|{
name|sz
operator|=
name|p
operator|->
name|p_size
operator|-
name|bn
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|dbtob
argument_list|(
name|sz
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Non-aligned or partial-block transfers handled specially. 		 * SHOULD THIS BE AT A HIGHER LEVEL? 		 */
name|s
operator|=
name|sc
operator|->
name|sc_blksize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dbtob
argument_list|(
name|bn
argument_list|)
operator|&
name|s
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_bcount
operator|&
name|s
operator|)
condition|)
block|{
name|sdlblkstrat
argument_list|(
name|bp
argument_list|,
name|sc
operator|->
name|sc_blksize
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_cylin
operator|=
operator|(
name|bn
operator|+
name|p
operator|->
name|p_offset
operator|)
operator|>>
name|sc
operator|->
name|sc_bshift
expr_stmt|;
block|}
comment|/* 	 * Transfer valid, or format mode.  Queue the request 	 * on the drive, and maybe try to start it. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
operator|&
name|sc
operator|->
name|sc_tab
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tab
operator|.
name|b_active
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
name|sdstart
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sderror
parameter_list|(
name|sc
parameter_list|,
name|stat
parameter_list|)
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_sense
modifier|*
name|sn
decl_stmt|;
name|int
name|retry
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|sc_sense
operator|.
name|status
operator|=
name|stat
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|STS_MASK
operator|)
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|sn
operator|=
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|sc
operator|->
name|sc_sense
operator|.
name|sense
expr_stmt|;
name|stat
operator|=
name|scsi_request_sense
argument_list|(
name|sc
operator|->
name|sc_unit
operator|.
name|u_hba
argument_list|,
name|sc
operator|->
name|sc_unit
operator|.
name|u_targ
argument_list|,
name|sc
operator|->
name|sc_unit
operator|.
name|u_unit
argument_list|,
operator|(
name|caddr_t
operator|)
name|sn
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|sc_sense
operator|.
name|sense
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sense
operator|.
name|status
operator|=
name|stat
expr_stmt|;
comment|/* ??? */
if|if
condition|(
operator|(
name|stat
operator|&
name|STS_MASK
operator|)
operator|!=
name|STS_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"%s: sense failed, status %x\n"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"%s: scsi sense class %d, code %d"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|,
name|SENSE_ECLASS
argument_list|(
name|sn
argument_list|)
argument_list|,
name|SENSE_ECODE
argument_list|(
name|sn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SENSE_ISXSENSE
argument_list|(
name|sn
argument_list|)
operator|&&
name|XSENSE_ISSTD
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|int
name|key
decl_stmt|;
comment|/* 			 * Standard extended sense: can examine sense key 			 * and (if valid) info. 			 */
name|key
operator|=
name|XSENSE_KEY
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", key %d"
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSENSE_IVALID
argument_list|(
name|sn
argument_list|)
condition|)
name|printf
argument_list|(
literal|", blk %d"
argument_list|,
name|XSENSE_INFO
argument_list|(
name|sn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no sense or recovered error, try again */
if|if
condition|(
name|key
operator|==
literal|0
operator|||
name|key
operator|==
literal|1
condition|)
name|retry
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sdigo is called from the hba driver when it has got the scsi bus  * for us, and we were doing a format op that did not need dma.  */
end_comment

begin_function
name|void
name|sdigo
parameter_list|(
name|sc0
parameter_list|,
name|cdb
parameter_list|)
name|struct
name|device
modifier|*
name|sc0
decl_stmt|;
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
block|{
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sd_softc
operator|*
operator|)
name|sc0
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|sc
operator|->
name|sc_tab
operator|.
name|b_actf
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|;
name|stat
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_unit
operator|.
name|u_hbd
operator|->
name|hd_icmd
call|)
argument_list|(
name|sc
operator|->
name|sc_unit
operator|.
name|u_hba
argument_list|,
name|sc
operator|->
name|sc_unit
operator|.
name|u_targ
argument_list|,
operator|&
name|sc
operator|->
name|sc_cmd
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sense
operator|.
name|status
operator|=
name|stat
expr_stmt|;
if|if
condition|(
name|stat
operator|&
literal|0xfe
condition|)
block|{
comment|/* XXX */
operator|(
name|void
operator|)
name|sderror
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
block|}
comment|/* 	 * Done with SCSI bus, before we `ought' to be.  Release it. 	 */
call|(
modifier|*
name|sc
operator|->
name|sc_unit
operator|.
name|u_rel
call|)
argument_list|(
name|sc
operator|->
name|sc_unit
operator|.
name|u_updev
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tab
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|sc
operator|->
name|sc_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
name|sc
operator|->
name|sc_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
else|else
name|sdstart
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sdgo is called from the hba driver or target code when it has  * allocated the scsi bus and DMA resources and target datapath for us.  */
end_comment

begin_function
name|void
name|sdgo
parameter_list|(
name|sc0
parameter_list|,
name|cdb
parameter_list|)
name|struct
name|device
modifier|*
name|sc0
decl_stmt|;
specifier|register
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
block|{
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sd_softc
operator|*
operator|)
name|sc0
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|sc
operator|->
name|sc_tab
operator|.
name|b_actf
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|unsigned
name|int
name|u
decl_stmt|;
name|SD_TRACE
argument_list|(
name|T_MKCDB
argument_list|,
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_format_pid
condition|)
block|{
operator|*
name|cdb
operator|=
name|sc
operator|->
name|sc_cmd
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_cmd
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|CMD_READ10
else|:
name|CMD_WRITE10
expr_stmt|;
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_lun_rel
operator|=
name|sc
operator|->
name|sc_unit
operator|.
name|u_unit
operator|<<
literal|5
expr_stmt|;
name|u
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_lbah
operator|=
name|u
operator|>>
literal|24
expr_stmt|;
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_lbahm
operator|=
name|u
operator|>>
literal|16
expr_stmt|;
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_lbalm
operator|=
name|u
operator|>>
literal|8
expr_stmt|;
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_lbal
operator|=
name|u
expr_stmt|;
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_xxx
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|sc
operator|->
name|sc_blksize
operator|-
literal|1
expr_stmt|;
name|u
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
name|n
operator|)
operator|>>
operator|(
name|DEV_BSHIFT
operator|+
name|sc
operator|->
name|sc_bshift
operator|)
expr_stmt|;
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_lenh
operator|=
name|u
operator|>>
literal|8
expr_stmt|;
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_lenl
operator|=
name|u
expr_stmt|;
name|CDB10
argument_list|(
name|cdb
argument_list|)
operator|->
name|cdb_ctrl
operator|=
literal|0
expr_stmt|;
name|n
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|&
name|n
operator|)
operator|!=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|n
condition|)
name|printf
argument_list|(
literal|"%s: partial block xfer -- %x bytes\n"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_transfers
operator|++
expr_stmt|;
block|}
if|if
condition|(
call|(
modifier|*
name|sc
operator|->
name|sc_unit
operator|.
name|u_go
call|)
argument_list|(
name|sc
operator|->
name|sc_unit
operator|.
name|u_updev
argument_list|,
name|sc
operator|->
name|sc_unit
operator|.
name|u_targ
argument_list|,
name|sdintr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
name|bp
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|sc
operator|->
name|sc_dk
operator|.
name|dk_busy
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_dk
operator|.
name|dk_seek
operator|++
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|sc_dk
operator|.
name|dk_xfer
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_dk
operator|.
name|dk_wds
operator|+=
name|bp
operator|->
name|b_bcount
operator|>>
literal|6
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * Some sort of nasty unrecoverable error: clobber the 	 * transfer.  Call the bus release function first, though. 	 */
call|(
modifier|*
name|sc
operator|->
name|sc_unit
operator|.
name|u_rel
call|)
argument_list|(
name|sc
operator|->
name|sc_unit
operator|.
name|u_updev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sddebug
operator|&
name|SDB_ERROR
condition|)
name|printf
argument_list|(
literal|"%s: sdgo: %s adr %d blk %d len %d ecnt %d\n"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|,
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_cylin
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|sc
operator|->
name|sc_tab
operator|.
name|b_errcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tab
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|sc
operator|->
name|sc_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
name|sc
operator|->
name|sc_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
else|else
name|sdstart
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A transfer finished (or, someday, disconnected).  * We are already off the target/hba queues.  * Restart this one for error recovery, or start the next, as appropriate.  */
end_comment

begin_function
name|void
name|sdintr
parameter_list|(
name|sc0
parameter_list|,
name|stat
parameter_list|,
name|resid
parameter_list|)
name|struct
name|device
modifier|*
name|sc0
decl_stmt|;
name|int
name|stat
decl_stmt|,
name|resid
decl_stmt|;
block|{
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sd_softc
operator|*
operator|)
name|sc0
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|sc
operator|->
name|sc_tab
operator|.
name|b_actf
decl_stmt|;
name|int
name|retry
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"sdintr"
argument_list|)
expr_stmt|;
name|SD_TRACE
argument_list|(
name|T_INTR
argument_list|,
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|sc
operator|->
name|sc_dk
operator|.
name|dk_busy
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|stat
operator|&
name|STS_MASK
operator|)
operator|!=
name|STS_GOOD
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sddebug
operator|&
name|SDB_ERROR
condition|)
name|printf
argument_list|(
literal|"%s: sdintr scsi status 0x%x resid %d\n"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|,
name|stat
argument_list|,
name|resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retry
operator|=
name|sderror
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|&&
operator|++
name|sc
operator|->
name|sc_tab
operator|.
name|b_errcnt
operator|<=
name|SDRETRY
condition|)
block|{
name|printf
argument_list|(
literal|"%s: retry %d\n"
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_tab
operator|.
name|b_errcnt
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
block|}
name|bp
operator|->
name|b_resid
operator|=
name|resid
expr_stmt|;
name|sc
operator|->
name|sc_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tab
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|sc
operator|->
name|sc_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
name|sc
operator|->
name|sc_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|restart
label|:
name|sdstart
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|sdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
specifier|register
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
init|=
name|sdcd
operator|.
name|cd_devs
index|[
name|sdunit
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_SUNOS
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sun_dkioctl
argument_list|(
operator|&
name|sc
operator|->
name|sc_dk
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|sdpart
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SDIOCSFORMAT
case|:
comment|/* take this device into or out of "format" mode */
if|if
condition|(
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_format_pid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|sc
operator|->
name|sc_format_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_format_pid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SDIOCGFORMAT
case|:
comment|/* find out who has the device in format mode */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_format_pid
expr_stmt|;
break|break;
case|case
name|SDIOCSCSICOMMAND
case|:
define|#
directive|define
name|cdb
value|((struct scsi_cdb *)data)
comment|/* 		 * Save what user gave us as SCSI cdb to use with next 		 * read or write to the char device.  Be sure to replace 		 * the lun field with the actual unit number. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_format_pid
operator|!=
name|p
operator|->
name|p_pid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|legal_cmds
index|[
name|cdb
operator|->
name|cdb_bytes
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|->
name|sc_cmd
operator|=
operator|*
name|cdb
expr_stmt|;
name|sc
operator|->
name|sc_cmd
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator|=
operator|(
name|sc
operator|->
name|sc_cmd
operator|.
name|cdb_bytes
index|[
literal|1
index|]
operator|&
operator|~
operator|(
literal|7
operator|<<
literal|5
operator|)
operator|)
operator||
operator|(
name|sc
operator|->
name|sc_unit
operator|.
name|u_unit
operator|<<
literal|5
operator|)
expr_stmt|;
undef|#
directive|undef
name|cdb
break|break;
case|case
name|SDIOCSENSE
case|:
comment|/* 		 * return the SCSI sense data saved after the last 		 * operation that completed with "check condition" status. 		 */
name|sc
operator|->
name|sc_sense
operator|=
operator|*
operator|(
expr|struct
name|scsi_fmt_sense
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_dk
operator|.
name|dk_label
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|disklab
operator|=
operator|&
name|sc
operator|->
name|sc_dk
operator|.
name|dk_label
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|part
operator|=
operator|&
name|sc
operator|->
name|sc_dk
operator|.
name|dk_label
operator|.
name|d_partitions
index|[
name|sdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
specifier|register
name|int
name|unit
init|=
name|sdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|sdcd
operator|.
name|cd_ndevs
operator|||
operator|(
name|sc
operator|=
name|sdcd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SDF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|sc
operator|->
name|sc_dk
operator|.
name|dk_label
operator|.
name|d_partitions
index|[
name|sdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write `len' bytes from address `addr' to drive and partition in `dev',  * at block blkoff from the beginning of the partition.  The address is  * either kernel virtual or physical (some machines may never use one or  * the other, but we need it in the protocol to stay machine-independent).  */
end_comment

begin_function
name|int
name|sddump
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|daddr_t
name|blkoff
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|struct
name|sd_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|p
decl_stmt|;
specifier|register
name|daddr_t
name|bn
decl_stmt|,
name|n
decl_stmt|,
name|nblks
decl_stmt|;
specifier|register
name|struct
name|hba_softc
modifier|*
name|hba
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|,
name|unit
decl_stmt|;
name|struct
name|scsi_cdb
name|cdb
decl_stmt|;
comment|/* drive ok? */
name|unit
operator|=
name|sdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|sdcd
operator|.
name|cd_ndevs
operator|||
operator|(
name|sc
operator|=
name|sdcd
operator|.
name|cd_devs
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SDF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* blocks in range? */
name|p
operator|=
operator|&
name|sc
operator|->
name|sc_dk
operator|.
name|dk_label
operator|.
name|d_partitions
index|[
name|sdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|n
operator|=
operator|(
name|len
operator|+
name|sc
operator|->
name|sc_blksize
operator|-
literal|1
operator|)
operator|>>
name|DEV_BSHIFT
expr_stmt|;
if|if
condition|(
name|blkoff
operator|<
literal|0
operator|||
name|blkoff
operator|>=
name|p
operator|->
name|p_size
operator|||
name|blkoff
operator|+
name|n
operator|>
name|p
operator|->
name|p_size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bn
operator|=
name|blkoff
operator|+
name|p
operator|->
name|p_offset
expr_stmt|;
name|bn
operator|>>=
name|sc
operator|->
name|sc_bshift
expr_stmt|;
comment|/* scsi bus idle? */
name|hba
operator|=
name|sc
operator|->
name|sc_unit
operator|.
name|u_hba
expr_stmt|;
if|if
condition|(
name|hba
operator|->
name|hba_head
condition|)
block|{
call|(
modifier|*
name|hba
operator|->
name|hba_driver
operator|->
name|hd_reset
call|)
argument_list|(
name|hba
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[reset %s] "
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
block|}
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_cmd
operator|=
name|CMD_WRITE10
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lun_rel
operator|=
name|sc
operator|->
name|sc_unit
operator|.
name|u_unit
operator|<<
literal|5
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_xxx
operator|=
literal|0
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_ctrl
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|DUMP_MAX
value|(32 * 1024)
comment|/* no more than 32k per write */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|len
operator|)
operator|>
name|DUMP_MAX
condition|)
name|n
operator|=
name|DUMP_MAX
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lbah
operator|=
name|bn
operator|>>
literal|24
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lbahm
operator|=
name|bn
operator|>>
literal|16
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lbalm
operator|=
name|bn
operator|>>
literal|8
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lbal
operator|=
name|bn
expr_stmt|;
name|nblks
operator|=
name|n
operator|>>
operator|(
name|DEV_BSHIFT
operator|+
name|sc
operator|->
name|sc_bshift
operator|)
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lenh
operator|=
name|nblks
operator|>>
literal|8
expr_stmt|;
name|CDB10
argument_list|(
operator|&
name|cdb
argument_list|)
operator|->
name|cdb_lenl
operator|=
name|nblks
expr_stmt|;
name|stat
operator|=
name|hba
operator|->
name|hba_driver
operator|->
name|hd_dump
argument_list|(
name|hba
argument_list|,
name|sc
operator|->
name|sc_unit
operator|.
name|u_targ
argument_list|,
operator|&
name|cdb
argument_list|,
name|addr
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|STS_MASK
operator|)
operator|!=
name|STS_GOOD
condition|)
block|{
name|printf
argument_list|(
literal|"%s: scsi write error 0x%x\ndump "
argument_list|,
name|sc
operator|->
name|sc_dk
operator|.
name|dk_dev
operator|.
name|dv_xname
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|-=
name|n
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|addr
operator|+=
name|n
expr_stmt|;
name|bn
operator|+=
name|nblks
expr_stmt|;
block|}
block|}
end_function

end_unit

