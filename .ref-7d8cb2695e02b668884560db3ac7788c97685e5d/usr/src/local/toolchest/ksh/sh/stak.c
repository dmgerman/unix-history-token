begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)stak.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * AT&T Bell Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|setbrk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|rmtemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ========	storage allocation	======== */
end_comment

begin_comment
comment|/*  * allocate requested stack  */
end_comment

begin_function
name|STKPTR
name|getstak
parameter_list|(
name|asize
parameter_list|)
name|int
name|asize
decl_stmt|;
block|{
specifier|register
name|STKPTR
name|oldstak
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|size
operator|=
name|round
argument_list|(
name|asize
argument_list|,
name|BYTESPERWORD
argument_list|)
expr_stmt|;
name|oldstak
operator|=
name|stakbot
expr_stmt|;
name|staktop
operator|=
name|stakbot
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|staktop
operator|>=
name|brkend
condition|)
name|setbrk
argument_list|(
name|round
argument_list|(
name|staktop
operator|-
name|brkend
argument_list|,
name|BRKINCR
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldstak
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set up stack for local use  * should be followed by `endstak'  */
end_comment

begin_function
name|STKPTR
name|locstak
parameter_list|()
block|{
if|if
condition|(
name|brkend
operator|-
name|stakbot
operator|<
name|BRKINCR
condition|)
name|setbrk
argument_list|(
name|BRKINCR
argument_list|)
expr_stmt|;
return|return
operator|(
name|staktop
operator|=
name|stakbot
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tidy up after `locstak'  */
end_comment

begin_function
name|STKPTR
name|endstak
parameter_list|(
name|argp
parameter_list|)
specifier|register
name|char
modifier|*
name|argp
decl_stmt|;
block|{
specifier|register
name|STKPTR
name|oldstak
decl_stmt|;
operator|*
name|argp
operator|++
operator|=
literal|0
expr_stmt|;
name|oldstak
operator|=
name|stakbot
expr_stmt|;
name|stakbot
operator|=
name|staktop
operator|=
operator|(
name|STKPTR
operator|)
name|round
argument_list|(
name|argp
argument_list|,
name|BYTESPERWORD
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldstak
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * try to bring stack back to x  */
end_comment

begin_function
name|void
name|tdystak
parameter_list|(
name|x
parameter_list|)
specifier|register
name|STKPTR
name|x
decl_stmt|;
block|{
while|while
condition|(
name|ADR
argument_list|(
name|stakbsy
argument_list|)
operator|>
name|ADR
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stakbsy
argument_list|)
expr_stmt|;
name|stakbsy
operator|=
name|stakbsy
operator|->
name|word
expr_stmt|;
block|}
name|staktop
operator|=
name|stakbot
operator|=
name|max
argument_list|(
name|ADR
argument_list|(
name|x
argument_list|)
argument_list|,
name|ADR
argument_list|(
name|stakbas
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iotemp
operator|>
operator|(
name|IOPTR
operator|)
name|x
condition|)
name|rmtemp
argument_list|(
operator|(
name|IOPTR
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|stakchk
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|size
init|=
operator|-
literal|3
operator|*
name|BRKINCR
decl_stmt|;
ifdef|#
directive|ifdef
name|INT16
if|if
condition|(
operator|(
name|brkend
operator|-
name|stakbas
operator|)
operator|>=
name|BRKMAX
condition|)
name|size
operator|=
name|BRKMAX
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* INT16 */
name|size
operator|+=
name|round
argument_list|(
name|brkend
operator|-
name|stakbas
argument_list|,
name|BRKINCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|setbrk
argument_list|(
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|STKPTR
name|cpystak
parameter_list|(
name|x
parameter_list|)
name|STKPTR
name|x
decl_stmt|;
block|{
return|return
operator|(
name|endstak
argument_list|(
name|movstr
argument_list|(
name|x
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|locstak
argument_list|()
operator|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

