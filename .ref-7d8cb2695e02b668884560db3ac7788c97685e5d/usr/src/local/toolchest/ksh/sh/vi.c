begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)vi.c	1.1 */
end_comment

begin_comment
comment|/* Adapted for ksh by David Korn */
end_comment

begin_comment
comment|/*+	VI.C			P.D. Sullivan  *  *	One line editor for the shell based on the vi editor.  *  *	Questions to:  *		P.D. Sullivan  *		cbosg!pds -*/
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KSHELL
end_ifdef

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_define
define|#
directive|define
name|NTICKS
value|5
end_define

begin_comment
comment|/* number of ticks for typeahead */
end_comment

begin_define
define|#
directive|define
name|MAXCHAR
value|MAXLINE-2
end_define

begin_comment
comment|/* max char per line */
end_comment

begin_define
define|#
directive|define
name|PRSIZE
value|80
end_define

begin_comment
comment|/* max prompt size */
end_comment

begin_define
define|#
directive|define
name|WINDOW
value|MAXWINDOW
end_define

begin_comment
comment|/* max char in window of which */
end_comment

begin_comment
comment|/* WINDOW-2 are available to user */
end_comment

begin_comment
comment|/* actual window size may be smaller */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KSHELL
end_ifndef

begin_decl_stmt
specifier|extern
name|char
name|trapnote
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|output
value|stderr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KSHELL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|bigvi
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|gencpy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|e_gencpy(a,b)
end_define

begin_define
define|#
directive|define
name|genncpy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
value|e_genncpy(a,b,n)
end_define

begin_define
define|#
directive|define
name|genlen
parameter_list|(
name|str
parameter_list|)
value|e_genlen(str)
end_define

begin_define
define|#
directive|define
name|digit
parameter_list|(
name|c
parameter_list|)
value|((c&~STRIP)==0&& isdigit(c))
end_define

begin_define
define|#
directive|define
name|is_print
parameter_list|(
name|c
parameter_list|)
value|((c&~STRIP) || isprint(c))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|gencpy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strcpy((char*)(a),(char*)(b))
end_define

begin_define
define|#
directive|define
name|genncpy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
value|strncpy((char*)(a),(char*)(b),n)
end_define

begin_define
define|#
directive|define
name|genlen
parameter_list|(
name|str
parameter_list|)
value|strlen(str)
end_define

begin_define
define|#
directive|define
name|isalph
parameter_list|(
name|v
parameter_list|)
value|isalnum(virtual[v])
end_define

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|v
parameter_list|)
value|isspace(virtual[v])
end_define

begin_define
define|#
directive|define
name|ismetach
parameter_list|(
name|v
parameter_list|)
value|ismeta(virtual[v])
end_define

begin_define
define|#
directive|define
name|digit
parameter_list|(
name|c
parameter_list|)
value|isdigit(c)
end_define

begin_define
define|#
directive|define
name|is_print
parameter_list|(
name|c
parameter_list|)
value|isprint(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE */
end_comment

begin_define
define|#
directive|define
name|fold
parameter_list|(
name|c
parameter_list|)
value|((c)&~040)
end_define

begin_comment
comment|/* lower and uppercase equivalent */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INT16
end_ifdef

begin_comment
comment|/* save space by defining functions for these */
end_comment

begin_undef
undef|#
directive|undef
name|isalph
end_undef

begin_undef
undef|#
directive|undef
name|isblank
end_undef

begin_undef
undef|#
directive|undef
name|ismetach
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INT16 */
end_comment

begin_undef
undef|#
directive|undef
name|putchar
end_undef

begin_undef
undef|#
directive|undef
name|getchar
end_undef

begin_define
define|#
directive|define
name|getchar
parameter_list|()
value|e_getchar()
end_define

begin_define
define|#
directive|define
name|putchar
parameter_list|(
name|c
parameter_list|)
value|e_putchar(c)
end_define

begin_define
define|#
directive|define
name|bell
value|e_ringbell()
end_define

begin_comment
comment|/* ring terminal's bell */
end_comment

begin_define
define|#
directive|define
name|crlf
value|e_crlf()
end_define

begin_comment
comment|/* return and linefeed */
end_comment

begin_define
define|#
directive|define
name|addnl
value|editb.e_addnl
end_define

begin_comment
comment|/* boolean - add newline flag */
end_comment

begin_define
define|#
directive|define
name|crallowed
value|editb.e_crlf
end_define

begin_define
define|#
directive|define
name|cur_virt
value|editb.e_cur
end_define

begin_comment
comment|/* current virtual column */
end_comment

begin_define
define|#
directive|define
name|cur_phys
value|editb.e_pcur
end_define

begin_comment
comment|/* current phys column cursor is at */
end_comment

begin_define
define|#
directive|define
name|curhline
value|editb.e_hline
end_define

begin_comment
comment|/* current history line */
end_comment

begin_define
define|#
directive|define
name|env
value|editb.e_env
end_define

begin_define
define|#
directive|define
name|fildes
value|editb.e_fd
end_define

begin_define
define|#
directive|define
name|findchar
value|editb.e_fchar
end_define

begin_comment
comment|/* last find char */
end_comment

begin_define
define|#
directive|define
name|first_virt
value|editb.e_fcol
end_define

begin_comment
comment|/* first allowable column */
end_comment

begin_define
define|#
directive|define
name|first_wind
value|editb.e_globals[0]
end_define

begin_comment
comment|/* first column of window */
end_comment

begin_define
define|#
directive|define
name|globals
value|editb.e_globals
end_define

begin_comment
comment|/* local global variables */
end_comment

begin_define
define|#
directive|define
name|histmin
value|editb.e_hismin
end_define

begin_define
define|#
directive|define
name|histmax
value|editb.e_hismax
end_define

begin_define
define|#
directive|define
name|last_phys
value|editb.e_peol
end_define

begin_comment
comment|/* last column in physical */
end_comment

begin_define
define|#
directive|define
name|last_virt
value|editb.e_eol
end_define

begin_comment
comment|/* last column */
end_comment

begin_define
define|#
directive|define
name|last_wind
value|editb.e_globals[1]
end_define

begin_comment
comment|/* last column in window */
end_comment

begin_define
define|#
directive|define
name|lastline
value|editb.e_tmp
end_define

begin_comment
comment|/* last line entered */
end_comment

begin_define
define|#
directive|define
name|lastmotion
value|editb.e_globals[2]
end_define

begin_comment
comment|/* last motion */
end_comment

begin_define
define|#
directive|define
name|lastrepeat
value|editb.e_mode
end_define

begin_comment
comment|/* last repeat count for motion cmds */
end_comment

begin_define
define|#
directive|define
name|long_char
value|editb.e_globals[3]
end_define

begin_comment
comment|/* line bigger than window */
end_comment

begin_define
define|#
directive|define
name|long_line
value|editb.e_globals[4]
end_define

begin_comment
comment|/* line bigger than window */
end_comment

begin_define
define|#
directive|define
name|lsearch
value|editb.e_search
end_define

begin_comment
comment|/* last search string */
end_comment

begin_define
define|#
directive|define
name|lookahead
value|editb.e_index
end_define

begin_comment
comment|/* characters in buffer */
end_comment

begin_define
define|#
directive|define
name|previous
value|editb.e_lbuf
end_define

begin_comment
comment|/* lookahead buffer */
end_comment

begin_define
define|#
directive|define
name|max_col
value|editb.e_llimit
end_define

begin_comment
comment|/* maximum column */
end_comment

begin_define
define|#
directive|define
name|ocur_phys
value|editb.e_globals[5]
end_define

begin_comment
comment|/* old current physical position */
end_comment

begin_define
define|#
directive|define
name|ocur_virt
value|editb.e_globals[6]
end_define

begin_comment
comment|/* old last virtual position */
end_comment

begin_define
define|#
directive|define
name|ofirst_wind
value|editb.e_globals[7]
end_define

begin_comment
comment|/* old window first col */
end_comment

begin_define
define|#
directive|define
name|o_v_char
value|editb.e_globals[8]
end_define

begin_comment
comment|/* prev virtual[ocur_virt] */
end_comment

begin_define
define|#
directive|define
name|Prompt
value|editb.e_prompt
end_define

begin_comment
comment|/* pointer to prompt */
end_comment

begin_define
define|#
directive|define
name|plen
value|editb.e_plen
end_define

begin_comment
comment|/* length of prompt */
end_comment

begin_define
define|#
directive|define
name|physical
value|editb.e_physbuf
end_define

begin_comment
comment|/* physical image */
end_comment

begin_define
define|#
directive|define
name|repeat
value|editb.e_repeat
end_define

begin_comment
comment|/* repeat count for motion cmds */
end_comment

begin_define
define|#
directive|define
name|ttyspeed
value|editb.e_ttyspeed
end_define

begin_comment
comment|/* tty speed */
end_comment

begin_define
define|#
directive|define
name|u_column
value|editb.e_ucol
end_define

begin_comment
comment|/* undo current column */
end_comment

begin_define
define|#
directive|define
name|U_saved
value|editb.e_saved
end_define

begin_comment
comment|/* original virtual saved */
end_comment

begin_define
define|#
directive|define
name|U_space
value|editb.e_Ubuf
end_define

begin_comment
comment|/* used for U command */
end_comment

begin_define
define|#
directive|define
name|u_space
value|editb.e_ubuf
end_define

begin_comment
comment|/* used for u command */
end_comment

begin_define
define|#
directive|define
name|usreof
value|editb.e_eof
end_define

begin_comment
comment|/* user defined eof char */
end_comment

begin_define
define|#
directive|define
name|usrerase
value|editb.e_erase
end_define

begin_comment
comment|/* user defined erase char */
end_comment

begin_define
define|#
directive|define
name|usrintr
value|editb.e_intr
end_define

begin_comment
comment|/* user defined intr char */
end_comment

begin_define
define|#
directive|define
name|usrkill
value|editb.e_kill
end_define

begin_comment
comment|/* user defined kill char */
end_comment

begin_define
define|#
directive|define
name|usrquit
value|editb.e_quit
end_define

begin_comment
comment|/* user defined quit char */
end_comment

begin_define
define|#
directive|define
name|virtual
value|editb.e_inbuf
end_define

begin_comment
comment|/* pointer to virtual image buffer */
end_comment

begin_define
define|#
directive|define
name|window
value|editb.e_window
end_define

begin_comment
comment|/* window buffer */
end_comment

begin_define
define|#
directive|define
name|w_size
value|editb.e_wsize
end_define

begin_comment
comment|/* window size */
end_comment

begin_define
define|#
directive|define
name|inmacro
value|editb.e_inmacro
end_define

begin_comment
comment|/* true when in macro */
end_comment

begin_decl_stmt
name|genchar
modifier|*
name|yankbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* yank/delete buffer */
end_comment

begin_function_decl
specifier|extern
name|histloc
name|hist_find
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|hist_word
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strncpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|times
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|e_flush
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ABORT
value|-2
end_define

begin_comment
comment|/* user abort */
end_comment

begin_define
define|#
directive|define
name|APPEND
value|-10
end_define

begin_comment
comment|/* append chars */
end_comment

begin_define
define|#
directive|define
name|BAD
value|-1
end_define

begin_comment
comment|/* failure flag */
end_comment

begin_define
define|#
directive|define
name|BIGVI
value|-15
end_define

begin_comment
comment|/* user wants real vi */
end_comment

begin_define
define|#
directive|define
name|CONTROL
value|-20
end_define

begin_comment
comment|/* control mode */
end_comment

begin_define
define|#
directive|define
name|ENTER
value|-25
end_define

begin_comment
comment|/* enter flag */
end_comment

begin_define
define|#
directive|define
name|GOOD
value|0
end_define

begin_comment
comment|/* success flag */
end_comment

begin_define
define|#
directive|define
name|INPUT
value|-30
end_define

begin_comment
comment|/* input mode */
end_comment

begin_define
define|#
directive|define
name|INSERT
value|-35
end_define

begin_comment
comment|/* insert mode */
end_comment

begin_define
define|#
directive|define
name|REPLACE
value|-40
end_define

begin_comment
comment|/* replace chars */
end_comment

begin_define
define|#
directive|define
name|SEARCH
value|-45
end_define

begin_comment
comment|/* search flag */
end_comment

begin_define
define|#
directive|define
name|TRANSLATE
value|-50
end_define

begin_comment
comment|/* translate virt to phys only */
end_comment

begin_define
define|#
directive|define
name|DEL
value|'\177'
end_define

begin_comment
comment|/* interrupt char */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|INVALID
value|(-1)
end_define

begin_comment
comment|/* invalid column */
end_comment

begin_define
define|#
directive|define
name|QUIT_C
value|'\34'
end_define

begin_comment
comment|/* quit char */
end_comment

begin_define
define|#
directive|define
name|SYSERR
value|(-1)
end_define

begin_comment
comment|/* system error */
end_comment

begin_decl_stmt
specifier|static
name|char
name|last_cmd
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last command */
end_comment

begin_decl_stmt
specifier|static
name|char
name|repeat_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|nonewline
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|typeahead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* typeahead occurred */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|typeahead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* typeahead occurred */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_function_decl
specifier|static
name|void
name|pr_prompt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pr_string
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*+	VREAD( fd, shbuf, nchar )  *  *	This routine implements a one line version of vi and is  * called by _filbuf.c  * -*/
end_comment

begin_macro
name|vread
argument_list|(
argument|fd
argument_list|,
argument|shbuf
argument_list|,
argument|nchar
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file descriptor */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|shbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shell line buffer */
end_comment

begin_decl_stmt
name|int
name|nchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of chars to read */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* general variable */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* general variable */
specifier|register
name|int
name|term_char
decl_stmt|;
comment|/* read() termination character */
name|char
name|prompt
index|[
name|PRSIZE
index|]
decl_stmt|;
comment|/* prompt */
name|char
name|Lsearch
index|[
name|MAXCHAR
operator|+
literal|2
index|]
decl_stmt|;
comment|/* last search string */
name|genchar
name|Physical
index|[
literal|2
operator|*
name|MAXCHAR
operator|+
literal|2
index|]
decl_stmt|;
comment|/* physical image */
name|genchar
name|Ubuf
index|[
name|MAXCHAR
operator|+
literal|2
index|]
decl_stmt|;
comment|/* used for U command */
name|genchar
name|ubuf
index|[
name|MAXCHAR
operator|+
literal|2
index|]
decl_stmt|;
comment|/* used for u command */
name|genchar
name|Window
index|[
name|WINDOW
operator|+
literal|10
index|]
decl_stmt|;
comment|/* window image */
ifndef|#
directive|ifndef
name|BSD
name|char
name|cntl_char
decl_stmt|;
comment|/* TRUE if control character present */
endif|#
directive|endif
comment|/* BSD */
name|int
name|Globals
index|[
literal|9
index|]
decl_stmt|;
comment|/* local global variables */
ifndef|#
directive|ifndef
name|BSD
name|long
name|oldtime
decl_stmt|,
name|newtime
decl_stmt|;
struct|struct
name|tbuffer
block|{
name|long
name|utime
decl_stmt|;
name|long
name|stime
decl_stmt|;
name|long
name|cutime
decl_stmt|;
name|long
name|cstime
decl_stmt|;
block|}
name|dummy
struct|;
endif|#
directive|endif
comment|/* BSD */
comment|/*** setup prompt ***/
name|Prompt
operator|=
name|prompt
expr_stmt|;
name|e_setup
argument_list|(
name|fd
argument_list|,
name|PRSIZE
operator|-
literal|2
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RAWONLY
if|if
condition|(
operator|!
name|is_option
argument_list|(
name|VIRAW
argument_list|)
condition|)
block|{
comment|/*** Change the eol characters to '\r' and eof  ***/
comment|/* in addition to '\n' and make eof an ESC	*/
if|if
condition|(
name|setalt
argument_list|(
name|fd
argument_list|)
operator|==
name|BAD
condition|)
block|{
return|return
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|shbuf
argument_list|,
name|nchar
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|BSD
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|typeahead
argument_list|)
expr_stmt|;
comment|/*** Read the line ***/
name|trapnote
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|shbuf
argument_list|,
name|nchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
comment|/*** read error or eof typed ***/
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|term_char
operator|=
name|shbuf
index|[
operator|--
name|i
index|]
expr_stmt|;
if|if
condition|(
name|term_char
operator|==
literal|'\r'
condition|)
name|term_char
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|term_char
operator|==
literal|'\n'
operator|||
name|term_char
operator|==
name|ESC
condition|)
name|shbuf
index|[
name|i
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|shbuf
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
comment|/*** save the current time to determine typeahead ***/
comment|/* if typeahead occurs, want to write user's line */
name|oldtime
operator|=
name|times
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
comment|/*** Read the line ***/
name|trapnote
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|shbuf
argument_list|,
name|nchar
argument_list|)
expr_stmt|;
name|newtime
operator|=
name|times
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|typeahead
operator|=
operator|(
operator|(
name|newtime
operator|-
name|oldtime
operator|)
operator|<
name|NTICKS
operator|)
expr_stmt|;
name|c
operator|=
name|shbuf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|c
operator|==
name|usreof
condition|)
block|{
comment|/*** read error or eof typed ***/
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|usreof
condition|)
name|i
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|/*** Save and remove the last character if its an eol, ***/
comment|/* changing '\r' to '\n' */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/*** ESC was typed as first char of line ***/
name|term_char
operator|=
name|ESC
expr_stmt|;
name|shbuf
index|[
name|i
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate line */
block|}
else|else
block|{
name|term_char
operator|=
name|shbuf
index|[
operator|--
name|i
index|]
expr_stmt|;
if|if
condition|(
name|term_char
operator|==
literal|'\r'
condition|)
name|term_char
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|term_char
operator|==
literal|'\n'
operator|||
name|term_char
operator|==
name|usreof
condition|)
block|{
comment|/*** remove terminator& null terminate ***/
name|shbuf
index|[
name|i
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/** terminator was ESC, which is not xmitted **/
name|term_char
operator|=
name|ESC
expr_stmt|;
name|shbuf
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* BSD */
block|}
else|else
endif|#
directive|endif
comment|/* RAWONLY */
block|{
comment|/*** Set raw mode ***/
ifndef|#
directive|ifndef
name|RAWONLY
if|if
condition|(
name|ttyspeed
operator|==
literal|0
condition|)
block|{
comment|/*** never did TCGETA, so do it ***/
comment|/* avoids problem if user does 'sh -o viraw' */
name|setalt
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|setraw
argument_list|(
name|fd
argument_list|)
operator|==
name|BAD
condition|)
block|{
return|return
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|shbuf
argument_list|,
name|nchar
argument_list|)
operator|)
return|;
block|}
name|i
operator|=
name|INVALID
expr_stmt|;
block|}
comment|/*** Initialize some things ***/
name|virtual
operator|=
operator|(
name|genchar
operator|*
operator|)
name|shbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|shbuf
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|e_internal
argument_list|(
name|shbuf
argument_list|,
name|virtual
argument_list|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|globals
operator|=
name|Globals
expr_stmt|;
name|cur_phys
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|cur_virt
operator|=
name|i
expr_stmt|;
name|fildes
operator|=
name|fd
expr_stmt|;
name|first_virt
operator|=
literal|0
expr_stmt|;
name|first_wind
operator|=
literal|0
expr_stmt|;
name|last_virt
operator|=
name|i
expr_stmt|;
name|last_phys
operator|=
name|i
expr_stmt|;
name|last_wind
operator|=
name|i
expr_stmt|;
name|lsearch
operator|=
name|Lsearch
expr_stmt|;
name|lsearch
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|long_line
operator|=
literal|' '
expr_stmt|;
name|long_char
operator|=
literal|' '
expr_stmt|;
name|o_v_char
operator|=
literal|'\0'
expr_stmt|;
name|ocur_phys
operator|=
literal|0
expr_stmt|;
name|ocur_virt
operator|=
name|MAXCHAR
expr_stmt|;
name|ofirst_wind
operator|=
literal|0
expr_stmt|;
name|physical
operator|=
name|Physical
expr_stmt|;
name|u_column
operator|=
name|INVALID
operator|-
literal|1
expr_stmt|;
name|U_space
operator|=
name|Ubuf
expr_stmt|;
name|u_space
operator|=
name|ubuf
expr_stmt|;
name|window
operator|=
name|Window
expr_stmt|;
name|window
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|last_cmd
operator|==
literal|'\0'
condition|)
block|{
comment|/*** first time for this shell ***/
name|last_cmd
operator|=
literal|'i'
expr_stmt|;
name|findchar
operator|=
name|INVALID
expr_stmt|;
name|lastmotion
operator|=
literal|'\0'
expr_stmt|;
name|lastrepeat
operator|=
literal|1
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|KSHELL
operator|&&
operator|(
name|CHARSISE
operator|*
operator|(
name|MAXLINE
operator|+
name|MAXCHAR
operator|+
literal|2
operator|)
operator|)
operator|<
name|BUFSIZE
name|lastline
operator|=
name|shbuf
operator|+
name|MAXLINE
operator|*
sizeof|sizeof
argument_list|(
name|genchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|lastline
operator|=
operator|(
name|genchar
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|genchar
argument_list|)
operator|*
operator|(
name|MAXCHAR
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|KSHELL
operator|&&
operator|(
name|CHARSISE
operator|*
operator|(
name|MAXLINE
operator|+
name|MAXCHAR
operator|+
literal|2
operator|+
name|MAXCHAR
operator|+
literal|2
operator|)
operator|)
operator|<
name|BUFSIZE
name|yankbuf
operator|=
name|shbuf
operator|+
operator|(
name|MAXLINE
operator|+
name|MAXCHAR
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|genchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|yankbuf
operator|=
operator|(
name|genchar
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|genchar
argument_list|)
operator|*
operator|(
name|MAXCHAR
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*** fiddle around with prompt length ***/
if|if
condition|(
name|nchar
operator|+
name|plen
operator|>
name|MAXCHAR
condition|)
name|nchar
operator|=
name|MAXCHAR
operator|-
name|plen
expr_stmt|;
name|max_col
operator|=
name|nchar
operator|-
literal|2
expr_stmt|;
name|w_size
operator|-=
name|plen
expr_stmt|;
ifndef|#
directive|ifndef
name|RAWONLY
if|if
condition|(
operator|!
name|is_option
argument_list|(
name|VIRAW
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|BSD
name|cntl_char
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|last_virt
condition|;
operator|++
name|i
control|)
block|{
comment|/*** change \r to \n, check for control characters, ***/
comment|/* delete appropriate ^Vs,			*/
comment|/* and estimate last physical column */
if|if
condition|(
name|virtual
index|[
name|i
index|]
operator|==
literal|'\r'
condition|)
name|virtual
index|[
name|i
index|]
operator|=
literal|'\n'
expr_stmt|;
name|c
operator|=
name|virtual
index|[
name|i
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD
if|if
condition|(
name|c
operator|==
name|usrerase
operator|||
name|c
operator|==
name|usrkill
condition|)
block|{
comment|/*** user typed escaped erase or kill char ***/
name|cntl_char
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_print
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|cntl_char
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|cntl
argument_list|(
name|V
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|last_virt
condition|)
block|{
comment|/*** eol/eof was escaped ***/
comment|/* so replace ^V with it */
name|virtual
index|[
name|i
index|]
operator|=
name|term_char
expr_stmt|;
break|break;
block|}
comment|/*** delete ^V ***/
name|gencpy
argument_list|(
operator|(
operator|&
name|virtual
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
operator|&
name|virtual
index|[
name|i
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
operator|--
name|cur_virt
expr_stmt|;
operator|--
name|last_virt
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* BSD */
block|}
comment|/*** copy virtual image to window ***/
if|if
condition|(
name|last_virt
operator|>
literal|0
condition|)
name|last_phys
operator|=
name|e_virt_to_phys
argument_list|(
name|virtual
argument_list|,
name|physical
argument_list|,
name|last_virt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_phys
operator|>=
name|w_size
condition|)
block|{
comment|/*** line longer than window ***/
name|last_wind
operator|=
name|w_size
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|last_wind
operator|=
name|last_phys
expr_stmt|;
name|genncpy
argument_list|(
name|window
argument_list|,
name|virtual
argument_list|,
name|last_wind
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|term_char
operator|!=
name|ESC
operator|&&
operator|(
name|last_virt
operator|==
name|INVALID
operator|||
name|virtual
index|[
name|last_virt
index|]
operator|!=
name|term_char
operator|)
condition|)
block|{
comment|/*** Line not terminated with ESC or escaped (^V) ***/
comment|/* eol, so return after doing a total update */
comment|/* if( (speed is greater or equal to 1200 */
comment|/* and something was typed) and */
comment|/* (control character present */
comment|/* or typeahead occurred) ) */
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyspeed
operator|==
name|FAST
operator|&&
name|last_virt
operator|!=
name|INVALID
ifdef|#
directive|ifdef
name|BSD
operator|&&
name|typeahead
condition|)
else|#
directive|else
operator|&&
operator|(
name|typeahead
operator|||
name|cntl_char
operator|==
name|TRUE
operator|)
block|)
endif|#
directive|endif
block|{
name|refresh
argument_list|(
name|TRANSLATE
argument_list|)
expr_stmt|;
name|pr_prompt
argument_list|()
expr_stmt|;
name|putstring
argument_list|(
literal|0
argument_list|,
name|last_phys
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|crlf
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
block|}
if|if
condition|(
name|term_char
operator|==
literal|'\n'
condition|)
block|{
ifndef|#
directive|ifndef
name|BSD
name|crlf
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|virtual
index|[
operator|++
name|last_virt
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
name|last_cmd
operator|=
literal|'i'
expr_stmt|;
name|save_last
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|virtual
index|[
name|last_virt
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|last_virt
operator|=
name|e_external
argument_list|(
name|virtual
argument_list|,
name|shbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|last_virt
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|++
name|last_virt
operator|)
return|;
endif|#
directive|endif
comment|/* MULTIBYTE */
block|}
comment|/*** Line terminated with escape, or escaped eol/eof, ***/
comment|/*  so set raw mode */
if|if
condition|(
name|setraw
argument_list|(
name|fd
argument_list|)
operator|==
name|BAD
condition|)
block|{
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|virtual
index|[
operator|++
name|last_virt
index|]
operator|=
literal|'\n'
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|virtual
index|[
name|last_virt
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|last_virt
operator|=
name|e_external
argument_list|(
name|virtual
argument_list|,
name|shbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|last_virt
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|++
name|last_virt
operator|)
return|;
endif|#
directive|endif
comment|/* MULTIBYTE */
block|}
ifdef|#
directive|ifdef
name|BSD
comment|/*** for BSD erase the ^[ ***/
name|pr_string
argument_list|(
literal|"\b\b  \b\b"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
if|if
condition|(
name|crallowed
operator|==
name|YES
condition|)
block|{
comment|/*** start over since there may be ***/
comment|/*** a control char, or cursor might not ***/
comment|/*** be at left margin (this lets us know ***/
comment|/*** where we are ***/
name|cur_phys
operator|=
literal|0
expr_stmt|;
name|window
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pr_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|term_char
operator|==
name|ESC
operator|&&
name|virtual
index|[
name|last_virt
index|]
operator|!=
name|ESC
condition|)
name|refresh
argument_list|(
name|CONTROL
argument_list|)
expr_stmt|;
else|else
name|refresh
argument_list|(
name|INPUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*** just update everything internally ***/
name|refresh
argument_list|(
name|TRANSLATE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_else
else|else
endif|#
directive|endif
comment|/* RAWONLY */
name|virtual
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
end_else

begin_comment
comment|/*** Handle usrintr, usrquit, or EOF ***/
end_comment

begin_if
if|if
condition|(
operator|(
name|i
operator|=
name|setjmp
argument_list|(
name|env
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|virtual
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|UEOF
case|:
comment|/*** EOF ***/
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|UINTR
case|:
comment|/** interrupt **/
return|return
operator|(
name|SYSERR
operator|)
return|;
block|}
return|return
operator|(
name|SYSERR
operator|)
return|;
block|}
end_if

begin_comment
comment|/*** Get a line from the terminal ***/
end_comment

begin_expr_stmt
name|U_saved
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RAWONLY
end_ifdef

begin_expr_stmt
name|getline
argument_list|(
name|APPEND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|is_option
argument_list|(
name|VIRAW
argument_list|)
operator|||
name|virtual
index|[
name|last_virt
index|]
operator|==
name|term_char
condition|)
name|getline
argument_list|(
name|APPEND
argument_list|)
expr_stmt|;
else|else
name|getline
argument_list|(
name|ESC
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAWONLY */
end_comment

begin_comment
comment|/*** add a new line if user typed unescaped \n ***/
end_comment

begin_comment
comment|/* to cause the shell to process the line */
end_comment

begin_if
if|if
condition|(
name|addnl
condition|)
block|{
name|virtual
index|[
operator|++
name|last_virt
index|]
operator|=
literal|'\n'
expr_stmt|;
name|crlf
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|setcooked
argument_list|(
name|fd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|++
name|last_virt
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE
if|if
condition|(
name|bigvi
condition|)
block|{
name|bigvi
operator|=
literal|0
expr_stmt|;
name|shbuf
index|[
name|last_virt
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
block|{
name|virtual
index|[
name|last_virt
index|]
operator|=
literal|0
expr_stmt|;
name|last_virt
operator|=
name|e_external
argument_list|(
name|virtual
argument_list|,
name|shbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MULTIBYTE */
return|return
operator|(
name|last_virt
operator|)
return|;
block|}
else|else
return|return
operator|(
name|SYSERR
operator|)
return|;
end_if

begin_comment
unit|}
comment|/*{	APPEND( char, mode )  *  *	This routine will append char after cur_virt in the virtual image.  * mode	=	APPEND, shift chars right before appending  *		REPLACE, replace char if possible  * }*/
end_comment

begin_function
unit|static
name|int
name|append
parameter_list|(
name|c
parameter_list|,
name|mode
parameter_list|)
name|int
name|c
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|last_virt
operator|<
name|max_col
operator|&&
name|last_phys
operator|<
name|max_col
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|APPEND
operator|||
name|cur_virt
operator|==
name|last_virt
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|++
name|last_virt
init|;
name|i
operator|>
name|cur_virt
condition|;
operator|--
name|i
control|)
block|{
name|virtual
index|[
name|i
index|]
operator|=
name|virtual
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
name|virtual
index|[
operator|++
name|cur_virt
index|]
operator|=
name|c
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*{	BACKWORD( nwords, cmd )  *  *	This routine will position cur_virt at the nth previous word.  * }*/
end_comment

begin_function
specifier|static
name|int
name|backword
parameter_list|(
name|nwords
parameter_list|,
name|cmd
parameter_list|)
name|int
name|nwords
decl_stmt|;
specifier|register
name|int
name|cmd
decl_stmt|;
block|{
specifier|register
name|int
name|tcur_virt
init|=
name|cur_virt
decl_stmt|;
while|while
condition|(
name|nwords
operator|--
operator|&&
name|tcur_virt
operator|>
name|first_virt
condition|)
block|{
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|isblank
argument_list|(
name|tcur_virt
operator|-
literal|1
argument_list|)
operator|&&
name|tcur_virt
operator|>
name|first_virt
condition|)
operator|--
name|tcur_virt
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|!=
literal|'B'
condition|)
block|{
specifier|register
name|int
name|last
init|=
name|isalph
argument_list|(
name|tcur_virt
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|last
operator|)
operator|||
operator|(
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
operator|!
name|last
operator|)
condition|)
operator|--
name|tcur_virt
expr_stmt|;
block|}
while|while
condition|(
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|>=
name|first_virt
condition|)
operator|--
name|tcur_virt
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'B'
condition|)
block|{
while|while
condition|(
operator|!
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|>=
name|first_virt
condition|)
operator|--
name|tcur_virt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
condition|)
while|while
condition|(
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|>=
name|first_virt
condition|)
operator|--
name|tcur_virt
expr_stmt|;
else|else
while|while
condition|(
operator|!
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
operator|!
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|>=
name|first_virt
condition|)
operator|--
name|tcur_virt
expr_stmt|;
block|}
name|cur_virt
operator|=
operator|++
name|tcur_virt
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*{	CNTLMODE()  *  *	This routine implements the vi command subset.  *	The cursor will always be positioned at the char of interest.  * }*/
end_comment

begin_function
specifier|static
name|int
name|cntlmode
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|genchar
name|tmp_u_space
index|[
name|MAXCHAR
operator|+
literal|2
index|]
decl_stmt|;
comment|/* temporary u_space */
name|genchar
modifier|*
name|real_u_space
decl_stmt|;
comment|/* points to real u_space */
name|int
name|tmp_u_column
decl_stmt|;
comment|/* temporary u_column */
if|if
condition|(
name|U_saved
operator|==
name|FALSE
condition|)
block|{
comment|/*** save virtual image if never done before ***/
name|virtual
index|[
name|last_virt
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|gencpy
argument_list|(
name|U_space
argument_list|,
name|virtual
argument_list|)
expr_stmt|;
name|U_saved
operator|=
name|TRUE
expr_stmt|;
block|}
name|save_last
argument_list|()
expr_stmt|;
name|real_u_space
operator|=
name|u_space
expr_stmt|;
name|curhline
operator|=
name|histmax
expr_stmt|;
name|first_virt
operator|=
literal|0
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cur_virt
operator|>
name|INVALID
condition|)
block|{
comment|/*** make sure cursor is at the last char ***/
name|sync_cursor
argument_list|()
expr_stmt|;
block|}
comment|/*** Read control char until something happens to cause a ***/
comment|/* return to APPEND/REPLACE mode	*/
while|while
condition|(
name|c
operator|=
name|getchar
argument_list|()
condition|)
block|{
name|repeat_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
comment|/*** move to leftmost column ***/
name|cur_virt
operator|=
literal|0
expr_stmt|;
name|sync_cursor
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|lastrepeat
operator|=
name|repeat
expr_stmt|;
name|c
operator|=
name|getcount
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
name|lastrepeat
operator|=
name|repeat
expr_stmt|;
block|}
comment|/*** see if it's a move cursor command ***/
if|if
condition|(
name|mvcursor
argument_list|(
name|c
argument_list|)
operator|==
name|GOOD
condition|)
block|{
name|sync_cursor
argument_list|()
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/*** see if it's a repeat of the last command ***/
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
name|last_cmd
expr_stmt|;
name|repeat
operator|=
name|lastrepeat
expr_stmt|;
name|i
operator|=
name|textmod
argument_list|(
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|textmod
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*** see if it's a text modification command ***/
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|BAD
case|:
break|break;
default|default:
comment|/** input mode **/
name|last_cmd
operator|=
name|c
expr_stmt|;
name|lastrepeat
operator|=
name|repeat
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|GOOD
condition|)
continue|continue;
return|return
operator|(
name|i
operator|)
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
comment|/***** Other stuff *****/
case|case
name|cntl
argument_list|(
name|L
argument_list|)
case|:
comment|/** Redraw line **/
comment|/*** print the prompt and ***/
comment|/* force a total refresh */
if|if
condition|(
name|nonewline
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|nonewline
operator|=
literal|0
expr_stmt|;
name|pr_prompt
argument_list|()
expr_stmt|;
name|window
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cur_phys
operator|=
name|first_wind
expr_stmt|;
name|ofirst_wind
operator|=
name|INVALID
expr_stmt|;
name|long_line
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/** Search **/
case|case
literal|'?'
case|:
case|case
literal|'N'
case|:
case|case
literal|'n'
case|:
name|save_v
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|search
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|GOOD
case|:
comment|/*** force a total refresh ***/
name|window
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|newhist
goto|;
case|case
name|BAD
case|:
comment|/*** no match ***/
name|bell
expr_stmt|;
default|default:
if|if
condition|(
name|u_column
operator|==
name|INVALID
condition|)
name|del_line
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
else|else
name|restore_v
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'j'
case|:
comment|/** get next command **/
case|case
literal|'+'
case|:
comment|/** get next command **/
name|curhline
operator|+=
name|repeat
expr_stmt|;
if|if
condition|(
name|curhline
operator|>
name|histmax
condition|)
block|{
name|curhline
operator|=
name|histmax
expr_stmt|;
goto|goto
name|ringbell
goto|;
block|}
elseif|else
if|if
condition|(
name|curhline
operator|==
name|histmax
operator|&&
name|tmp_u_column
operator|!=
name|INVALID
condition|)
block|{
name|u_space
operator|=
name|tmp_u_space
expr_stmt|;
name|u_column
operator|=
name|tmp_u_column
expr_stmt|;
name|restore_v
argument_list|()
expr_stmt|;
name|u_space
operator|=
name|real_u_space
expr_stmt|;
break|break;
block|}
name|save_v
argument_list|()
expr_stmt|;
goto|goto
name|newhist
goto|;
case|case
literal|'k'
case|:
comment|/** get previous command **/
case|case
literal|'-'
case|:
comment|/** get previous command **/
if|if
condition|(
name|curhline
operator|==
name|histmax
condition|)
block|{
name|u_space
operator|=
name|tmp_u_space
expr_stmt|;
name|i
operator|=
name|u_column
expr_stmt|;
name|save_v
argument_list|()
expr_stmt|;
name|u_space
operator|=
name|real_u_space
expr_stmt|;
name|tmp_u_column
operator|=
name|u_column
expr_stmt|;
name|u_column
operator|=
name|i
expr_stmt|;
block|}
name|curhline
operator|-=
name|repeat
expr_stmt|;
if|if
condition|(
name|curhline
operator|<=
name|histmin
condition|)
block|{
name|curhline
operator|=
name|histmin
operator|+
literal|1
expr_stmt|;
goto|goto
name|ringbell
goto|;
block|}
name|save_v
argument_list|()
expr_stmt|;
name|newhist
label|:
name|hist_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|virtual
argument_list|,
name|curhline
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|e_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|virtual
argument_list|,
name|virtual
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
if|if
condition|(
operator|(
name|last_virt
operator|=
name|genlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|virtual
argument_list|)
operator|-
literal|1
operator|)
operator|>
literal|0
condition|)
name|cur_virt
operator|=
literal|0
expr_stmt|;
else|else
name|cur_virt
operator|=
name|INVALID
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/** undo the last thing done **/
name|restore_v
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/** Undo everything **/
name|save_v
argument_list|()
expr_stmt|;
if|if
condition|(
name|virtual
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|ringbell
goto|;
else|else
block|{
name|gencpy
argument_list|(
name|virtual
argument_list|,
name|U_space
argument_list|)
expr_stmt|;
name|last_virt
operator|=
name|genlen
argument_list|(
name|U_space
argument_list|)
operator|-
literal|1
expr_stmt|;
name|cur_virt
operator|=
literal|0
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|KSHELL
case|case
literal|'v'
case|:
if|if
condition|(
name|repeat_set
operator|==
literal|0
condition|)
goto|goto
name|vcommand
goto|;
endif|#
directive|endif
comment|/* KSHELL */
case|case
literal|'G'
case|:
comment|/** goto command repeat **/
if|if
condition|(
name|repeat_set
operator|==
literal|0
condition|)
name|repeat
operator|=
name|histmin
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|repeat
operator|<=
name|histmin
operator|||
name|repeat
operator|>
name|histmax
condition|)
block|{
goto|goto
name|ringbell
goto|;
block|}
name|curhline
operator|=
name|repeat
expr_stmt|;
name|save_v
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'G'
condition|)
goto|goto
name|newhist
goto|;
ifdef|#
directive|ifdef
name|KSHELL
name|vcommand
label|:
block|{
comment|/* use EDITOR on current command */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|curhline
operator|==
name|histmax
condition|)
block|{
if|if
condition|(
name|last_virt
operator|<=
literal|0
condition|)
goto|goto
name|ringbell
goto|;
name|virtual
index|[
name|last_virt
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
operator|(
name|char
operator|*
operator|)
name|virtual
argument_list|,
name|fc_fix
operator|->
name|fixfd
argument_list|)
expr_stmt|;
name|states
operator||=
name|FIXFLG
expr_stmt|;
name|hist_flush
argument_list|()
expr_stmt|;
block|}
name|cp
operator|=
name|movstr
argument_list|(
name|big_vi
argument_list|,
operator|(
name|char
operator|*
operator|)
name|virtual
argument_list|)
expr_stmt|;
name|cp
operator|=
name|movstr
argument_list|(
name|itos
argument_list|(
name|curhline
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|last_virt
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cp
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|virtual
expr_stmt|;
return|return
operator|(
name|BIGVI
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* KSHELL */
case|case
literal|'#'
case|:
comment|/** insert # to no-op command **/
if|if
condition|(
name|cur_virt
operator|!=
name|INVALID
condition|)
block|{
comment|/*** something was typed, so no-op it ***/
name|cur_virt
operator|=
name|INVALID
expr_stmt|;
name|append
argument_list|(
literal|'#'
argument_list|,
name|APPEND
argument_list|)
expr_stmt|;
name|refresh
argument_list|(
name|INPUT
argument_list|)
expr_stmt|;
block|}
case|case
literal|'\n'
case|:
comment|/** send to shell **/
return|return
operator|(
name|ENTER
operator|)
return|;
default|default:
name|ringbell
label|:
name|bell
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|refresh
argument_list|(
name|CONTROL
argument_list|)
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*{	CURSOR( new_current_physical )  *  *	This routine will position the virtual cursor at  * physical column x in the window.  * }*/
end_comment

begin_function
specifier|static
name|int
name|cursor
parameter_list|(
name|x
parameter_list|)
specifier|register
name|int
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|delta
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
while|while
condition|(
name|physical
index|[
name|x
index|]
operator|==
name|MARKER
condition|)
name|x
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|delta
operator|=
name|x
operator|-
name|cur_phys
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
comment|/*** move to right ***/
name|putstring
argument_list|(
name|cur_phys
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*** move to left ***/
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
comment|/*** attempt to optimize cursor movement ***/
if|if
condition|(
name|crallowed
operator|==
name|NO
operator|||
operator|(
name|delta
operator|<=
operator|(
operator|(
name|cur_phys
operator|-
name|first_wind
operator|)
operator|+
name|plen
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
while|while
condition|(
name|delta
operator|--
condition|)
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pr_prompt
argument_list|()
expr_stmt|;
name|putstring
argument_list|(
name|first_wind
argument_list|,
name|x
operator|-
name|first_wind
argument_list|)
expr_stmt|;
block|}
block|}
name|cur_phys
operator|=
name|x
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*{	DELETE( nchars, mode )  *  *	Delete nchars from the virtual space and leave cur_virt positioned  * at cur_virt-1.  *  *	If mode	= 'c', do not save the characters deleted  *		= 'd', save them in yankbuf and delete.  *		= 'y', save them in yankbuf but do not delete.  * }*/
end_comment

begin_function
specifier|static
name|int
name|delete
parameter_list|(
name|nchars
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|int
name|nchars
decl_stmt|;
name|char
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|genchar
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
name|cur_virt
operator|<
name|first_virt
condition|)
block|{
name|bell
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nchars
operator|>
literal|0
condition|)
block|{
name|vp
operator|=
name|virtual
operator|+
name|cur_virt
expr_stmt|;
if|if
condition|(
operator|(
name|cur_virt
operator|--
operator|+
name|nchars
operator|)
operator|>
name|last_virt
condition|)
block|{
comment|/*** set nchars to number actually deleted ***/
name|nchars
operator|=
name|last_virt
operator|-
name|cur_virt
expr_stmt|;
block|}
comment|/*** save characters to be deleted ***/
if|if
condition|(
name|mode
operator|!=
literal|'c'
condition|)
block|{
name|i
operator|=
name|vp
index|[
name|nchars
index|]
expr_stmt|;
name|vp
index|[
name|nchars
index|]
operator|=
literal|0
expr_stmt|;
name|gencpy
argument_list|(
name|yankbuf
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|vp
index|[
name|nchars
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/*** now delete these characters ***/
if|if
condition|(
name|mode
operator|!=
literal|'y'
condition|)
block|{
name|gencpy
argument_list|(
name|vp
argument_list|,
name|vp
operator|+
name|nchars
argument_list|)
expr_stmt|;
name|last_virt
operator|-=
name|nchars
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*{	DEL_LINE( mode )  *  *	This routine will delete the line.  *	mode = GOOD, do a save_v()  * }*/
end_comment

begin_function
specifier|static
name|int
name|del_line
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|last_virt
operator|==
name|INVALID
condition|)
return|return;
if|if
condition|(
name|mode
operator|==
name|GOOD
condition|)
name|save_v
argument_list|()
expr_stmt|;
name|cur_virt
operator|=
literal|0
expr_stmt|;
name|first_virt
operator|=
literal|0
expr_stmt|;
name|delete
argument_list|(
name|last_virt
operator|+
literal|1
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
name|refresh
argument_list|(
name|CONTROL
argument_list|)
expr_stmt|;
name|cur_virt
operator|=
name|INVALID
expr_stmt|;
name|cur_phys
operator|=
literal|0
expr_stmt|;
name|findchar
operator|=
name|INVALID
expr_stmt|;
name|last_phys
operator|=
name|INVALID
expr_stmt|;
name|last_virt
operator|=
name|INVALID
expr_stmt|;
name|last_wind
operator|=
name|INVALID
expr_stmt|;
name|first_wind
operator|=
literal|0
expr_stmt|;
name|o_v_char
operator|=
literal|'\0'
expr_stmt|;
name|ocur_phys
operator|=
literal|0
expr_stmt|;
name|ocur_virt
operator|=
name|MAXCHAR
expr_stmt|;
name|ofirst_wind
operator|=
literal|0
expr_stmt|;
name|window
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*{	DELMOTION( motion, mode )  *  *	Delete thru motion.  *  *	mode	= 'd', save deleted characters, delete  *		= 'c', do not save characters, change  *		= 'y', save characters, yank  *  *	Returns GOOD if operation successful; else BAD.  * }*/
end_comment

begin_function
specifier|static
name|int
name|delmotion
parameter_list|(
name|motion
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|int
name|motion
decl_stmt|;
name|char
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|cur_virt
operator|==
name|INVALID
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
if|if
condition|(
name|mode
operator|!=
literal|'y'
condition|)
name|save_v
argument_list|()
expr_stmt|;
name|i
operator|=
name|cur_virt
expr_stmt|;
comment|/*** fake out the motion routines by appending a blank ***/
name|virtual
index|[
operator|++
name|last_virt
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|mvcursor
argument_list|(
name|motion
argument_list|)
operator|==
name|BAD
operator|&&
name|strchr
argument_list|(
literal|";,TtFf"
argument_list|,
name|motion
argument_list|)
condition|)
block|{
operator|--
name|last_virt
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
block|}
operator|--
name|last_virt
expr_stmt|;
name|j
operator|=
name|cur_virt
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|'c'
operator|&&
name|j
operator|>
name|i
condition|)
block|{
comment|/*** called by change operation ***/
while|while
condition|(
name|j
operator|>
name|i
operator|&&
name|isblank
argument_list|(
name|j
operator|-
literal|1
argument_list|)
condition|)
operator|--
name|j
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
name|i
condition|)
block|{
name|cur_virt
operator|=
name|i
expr_stmt|;
name|j
operator|-=
name|i
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
name|i
operator|-
name|j
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|"wWh\bl "
argument_list|,
name|motion
argument_list|)
condition|)
operator|++
name|j
expr_stmt|;
name|delete
argument_list|(
name|j
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|'y'
condition|)
name|cur_virt
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*{	ENDWORD( nwords, cmd )  *  *	This routine will move cur_virt to the end of the nth word.  * }*/
end_comment

begin_function
specifier|static
name|int
name|endword
parameter_list|(
name|nwords
parameter_list|,
name|cmd
parameter_list|)
name|int
name|nwords
decl_stmt|;
specifier|register
name|int
name|cmd
decl_stmt|;
block|{
specifier|register
name|int
name|tcur_virt
init|=
name|cur_virt
decl_stmt|;
while|while
condition|(
name|nwords
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<=
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
while|while
condition|(
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<=
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'E'
condition|)
block|{
while|while
condition|(
operator|!
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<=
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
condition|)
while|while
condition|(
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<=
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
else|else
while|while
condition|(
operator|!
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
operator|!
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<=
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
block|}
if|if
condition|(
name|tcur_virt
operator|>
name|first_virt
condition|)
name|tcur_virt
operator|--
expr_stmt|;
block|}
name|cur_virt
operator|=
name|tcur_virt
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*{	FORWARD( nwords, cmd )  *  *	This routine will move cur_virt forward to the next nth word.  * }*/
end_comment

begin_function
specifier|static
name|int
name|forward
parameter_list|(
name|nwords
parameter_list|,
name|cmd
parameter_list|)
specifier|register
name|int
name|nwords
decl_stmt|;
name|char
name|cmd
decl_stmt|;
block|{
specifier|register
name|tcur_virt
operator|=
name|cur_virt
expr_stmt|;
while|while
condition|(
name|nwords
operator|--
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
literal|'W'
condition|)
block|{
while|while
condition|(
operator|!
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
condition|)
block|{
while|while
condition|(
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|isalph
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
operator|!
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
block|}
block|}
while|while
condition|(
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
block|}
name|cur_virt
operator|=
name|tcur_virt
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*{	GETCOUNT(c)  *  *	Set repeat to the user typed number and return the terminating  * character.  * }*/
end_comment

begin_function
specifier|static
name|int
name|getcount
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*** get any repeat count ***/
name|repeat_set
operator|++
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|i
operator|=
name|i
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
name|repeat
operator|*=
name|i
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*{	GETLINE( mode )  *  *	This routine will fetch a line.  *	mode	= APPEND, allow escape to cntlmode subroutine  *		  appending characters.  *		= REPLACE, allow escape to cntlmode subroutine  *		  replacing characters.  *		= SEARCH, no escape allowed  *		= ESC, enter control mode immediately  *  *	The cursor will always be positioned after the last  * char printed.  *  *	This routine returns when cr, nl, or (eof in column 0) is  * received (column 0 is the first char position).  * }*/
end_comment

begin_function
specifier|static
name|int
name|getline
parameter_list|(
name|mode
parameter_list|)
specifier|register
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|;
name|addnl
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|ESC
condition|)
block|{
comment|/*** go directly to control mode ***/
goto|goto
name|escape
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|last_virt
operator|>=
name|max_col
operator|||
name|last_phys
operator|>=
name|max_col
condition|)
block|{
if|if
condition|(
name|virtual
index|[
name|last_virt
index|]
operator|!=
literal|'\\'
condition|)
name|virtual
index|[
operator|++
name|last_virt
index|]
operator|=
literal|'\\'
expr_stmt|;
name|refresh
argument_list|(
name|INPUT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|cntl
argument_list|(
name|V
argument_list|)
condition|)
block|{
comment|/*** implement ^V to escape next char ***/
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|c
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|refresh
argument_list|(
name|INPUT
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|usreof
condition|)
name|c
operator|=
name|UEOF
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|usrerase
condition|)
name|c
operator|=
name|UERASE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|usrkill
condition|)
name|c
operator|=
name|UKILL
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ESC
case|:
comment|/** enter control mode **/
if|if
condition|(
name|mode
operator|==
name|SEARCH
condition|)
block|{
name|bell
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|escape
label|:
if|if
condition|(
name|mode
operator|==
name|REPLACE
condition|)
operator|--
name|cur_virt
expr_stmt|;
name|tmp
operator|=
name|cntlmode
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|ENTER
operator|||
name|tmp
operator|==
name|BIGVI
condition|)
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE
name|bigvi
operator|=
operator|(
name|tmp
operator|==
name|BIGVI
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
return|return;
block|}
if|if
condition|(
name|tmp
operator|==
name|INSERT
condition|)
block|{
name|mode
operator|=
name|APPEND
expr_stmt|;
continue|continue;
block|}
name|mode
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
case|case
name|UERASE
case|:
comment|/** user erase char **/
comment|/*** treat as backspace ***/
case|case
literal|'\b'
case|:
comment|/** backspace **/
if|if
condition|(
name|virtual
index|[
name|cur_virt
index|]
operator|==
literal|'\\'
condition|)
block|{
name|delete
argument_list|(
literal|1
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|usrerase
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|SEARCH
operator|&&
name|cur_virt
operator|==
literal|0
condition|)
block|{
name|first_virt
operator|=
literal|0
expr_stmt|;
name|delete
argument_list|(
literal|1
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
return|return;
block|}
name|delete
argument_list|(
literal|1
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|cntl
argument_list|(
name|W
argument_list|)
case|:
comment|/** delete back word **/
if|if
condition|(
name|cur_virt
operator|>
name|first_virt
operator|&&
name|isblank
argument_list|(
name|cur_virt
operator|-
literal|1
argument_list|)
condition|)
block|{
name|delete
argument_list|(
literal|1
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|cur_virt
expr_stmt|;
name|backword
argument_list|(
literal|1
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|tmp
operator|-
name|cur_virt
operator|+
literal|1
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UKILL
case|:
comment|/** user kill line char **/
if|if
condition|(
name|virtual
index|[
name|cur_virt
index|]
operator|==
literal|'\\'
condition|)
block|{
name|delete
argument_list|(
literal|1
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|usrkill
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|SEARCH
condition|)
block|{
name|cur_virt
operator|=
literal|1
expr_stmt|;
name|delmotion
argument_list|(
literal|'$'
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
block|}
else|else
name|del_line
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UEOF
case|:
comment|/** eof char **/
if|if
condition|(
name|cur_virt
operator|!=
name|INVALID
condition|)
continue|continue;
name|addnl
operator|=
name|FALSE
expr_stmt|;
case|case
literal|'\n'
case|:
comment|/** newline or return **/
if|if
condition|(
name|mode
operator|!=
name|SEARCH
condition|)
name|save_last
argument_list|()
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|mode
operator|==
name|REPLACE
condition|)
block|{
if|if
condition|(
name|cur_virt
operator|<
name|last_virt
condition|)
block|{
name|replace
argument_list|(
name|c
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|delete
argument_list|(
literal|1
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
name|mode
operator|=
name|APPEND
expr_stmt|;
block|}
name|append
argument_list|(
name|c
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
name|refresh
argument_list|(
name|INPUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*{	MVCURSOR( motion )  *  *	This routine will move the virtual cursor according to motion  * for repeat times.  *  * It returns GOOD if successful; else BAD.  * }*/
end_comment

begin_function
specifier|static
name|int
name|mvcursor
parameter_list|(
name|motion
parameter_list|)
specifier|register
name|int
name|motion
decl_stmt|;
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|tcur_virt
decl_stmt|;
specifier|register
name|int
name|incr
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|bound
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|last_find
init|=
literal|0
decl_stmt|;
comment|/* last find command */
switch|switch
condition|(
name|motion
condition|)
block|{
comment|/***** Cursor move commands *****/
case|case
literal|'0'
case|:
comment|/** First column **/
name|tcur_virt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
comment|/** First nonblank character **/
name|tcur_virt
operator|=
name|first_virt
expr_stmt|;
while|while
condition|(
name|isblank
argument_list|(
name|tcur_virt
argument_list|)
operator|&&
name|tcur_virt
operator|<
name|last_virt
condition|)
operator|++
name|tcur_virt
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/** End of line **/
name|tcur_virt
operator|=
name|last_virt
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/** Left one **/
case|case
literal|'\b'
case|:
name|motion
operator|=
name|first_virt
expr_stmt|;
goto|goto
name|walk
goto|;
case|case
literal|' '
case|:
case|case
literal|'l'
case|:
comment|/** Right one **/
name|motion
operator|=
name|last_virt
expr_stmt|;
name|incr
operator|=
literal|1
expr_stmt|;
name|walk
label|:
name|tcur_virt
operator|=
name|cur_virt
expr_stmt|;
if|if
condition|(
name|incr
operator|*
name|tcur_virt
operator|<
name|motion
condition|)
block|{
name|tcur_virt
operator|+=
name|repeat
operator|*
name|incr
expr_stmt|;
if|if
condition|(
name|incr
operator|*
name|tcur_virt
operator|>
name|motion
condition|)
name|tcur_virt
operator|=
name|motion
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|BAD
operator|)
return|;
block|}
break|break;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
comment|/** back word **/
name|tcur_virt
operator|=
name|cur_virt
expr_stmt|;
name|backword
argument_list|(
name|repeat
argument_list|,
name|motion
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_virt
operator|==
name|tcur_virt
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
comment|/** end of word **/
name|tcur_virt
operator|=
name|cur_virt
expr_stmt|;
name|endword
argument_list|(
name|repeat
argument_list|,
name|motion
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_virt
operator|==
name|tcur_virt
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
literal|','
case|:
comment|/** reverse find old char **/
case|case
literal|';'
case|:
comment|/** find old char **/
switch|switch
condition|(
name|last_find
condition|)
block|{
case|case
literal|'t'
case|:
case|case
literal|'f'
case|:
if|if
condition|(
name|motion
operator|==
literal|';'
condition|)
block|{
name|bound
operator|=
name|last_virt
expr_stmt|;
name|incr
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|find_b
goto|;
case|case
literal|'T'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|motion
operator|==
literal|','
condition|)
block|{
name|bound
operator|=
name|last_virt
expr_stmt|;
name|incr
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|find_b
goto|;
default|default:
return|return
operator|(
name|BAD
operator|)
return|;
block|}
case|case
literal|'t'
case|:
comment|/** find up to new char forward **/
case|case
literal|'f'
case|:
comment|/** find new char forward **/
name|bound
operator|=
name|last_virt
expr_stmt|;
name|incr
operator|=
literal|1
expr_stmt|;
case|case
literal|'T'
case|:
comment|/** find up to new char backward **/
case|case
literal|'F'
case|:
comment|/** find new char backward **/
name|last_find
operator|=
name|motion
expr_stmt|;
name|findchar
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|find_b
label|:
name|tcur_virt
operator|=
name|cur_virt
expr_stmt|;
name|count
operator|=
name|repeat
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
while|while
condition|(
name|incr
operator|*
operator|(
name|tcur_virt
operator|+=
name|incr
operator|)
operator|<=
name|bound
operator|&&
name|virtual
index|[
name|tcur_virt
index|]
operator|!=
name|findchar
condition|)
empty_stmt|;
if|if
condition|(
name|incr
operator|*
name|tcur_virt
operator|>
name|bound
condition|)
block|{
return|return
operator|(
name|BAD
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fold
argument_list|(
name|last_find
argument_list|)
operator|==
literal|'T'
condition|)
name|tcur_virt
operator|-=
name|incr
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
comment|/** forward word **/
name|tcur_virt
operator|=
name|cur_virt
expr_stmt|;
name|forward
argument_list|(
name|repeat
argument_list|,
name|motion
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcur_virt
operator|==
name|cur_virt
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
default|default:
return|return
operator|(
name|BAD
operator|)
return|;
block|}
name|cur_virt
operator|=
name|tcur_virt
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*{	PR_PROMPT()  *  *	Print the prompt.  * }*/
end_comment

begin_function
specifier|static
name|void
name|pr_prompt
parameter_list|()
block|{
name|pr_string
argument_list|(
name|Prompt
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * print a string  */
end_comment

begin_function
specifier|static
name|void
name|pr_string
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/*** copy string s ***/
specifier|register
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|editb
operator|.
name|e_outptr
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|editb
operator|.
name|e_outptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptr
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*{	PUTSTRING( column, nchars )  *  *	Put nchars starting at column of physical into the workspace  * to be printed.  * }*/
end_comment

begin_function
specifier|static
name|int
name|putstring
parameter_list|(
name|col
parameter_list|,
name|nchars
parameter_list|)
specifier|register
name|int
name|col
decl_stmt|;
specifier|register
name|int
name|nchars
decl_stmt|;
block|{
while|while
condition|(
name|nchars
operator|--
condition|)
name|putchar
argument_list|(
name|physical
index|[
name|col
operator|++
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*{	REFRESH( mode )  *  *	This routine will refresh the crt so the physical image matches  * the virtual image and display the proper window.  *  *	mode	= CONTROL, refresh in control mode, ie. leave cursor  *			positioned at last char printed.  *		= INPUT, refresh in input mode; leave cursor positioned  *			after last char printed.  *		= TRANSLATE, perform virtual to physical translation  *			and adjust left margin only.  *  *		+-------------------------------+  *		|   | |    virtual	  | |   |  *		+-------------------------------+  *		  cur_virt		last_virt  *  *		+-----------------------------------------------+  *		|	  | |	        physical	 | |    |  *		+-----------------------------------------------+  *			cur_phys			last_phys  *  *				0			w_size - 1  *				+-----------------------+  *				| | |  window		|  *				+-----------------------+  *				cur_window = cur_phys - first_wind }*/
end_comment

begin_function
specifier|static
name|int
name|refresh
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|p
decl_stmt|;
specifier|register
name|int
name|regb
decl_stmt|;
specifier|register
name|int
name|first_w
init|=
name|first_wind
decl_stmt|;
name|int
name|p_differ
decl_stmt|;
name|int
name|new_lw
decl_stmt|;
name|int
name|ncur_phys
decl_stmt|;
name|int
name|opflag
decl_stmt|;
comment|/* search optimize flag */
define|#
directive|define
name|w
value|regb
define|#
directive|define
name|v
value|regb
comment|/*** find out if it's necessary to start translating at beginning ***/
if|if
condition|(
name|lookahead
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|previous
index|[
name|lookahead
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|ESC
operator|&&
name|p
operator|!=
literal|'\n'
operator|&&
name|p
operator|!=
literal|'\r'
condition|)
block|{
name|ocur_virt
operator|=
name|INVALID
expr_stmt|;
return|return;
block|}
block|}
name|v
operator|=
name|cur_virt
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|ocur_virt
operator|||
name|ocur_virt
operator|==
name|INVALID
operator|||
operator|(
name|v
operator|==
name|ocur_virt
operator|&&
operator|(
operator|!
name|is_print
argument_list|(
name|virtual
index|[
name|v
index|]
argument_list|)
operator|||
operator|!
name|is_print
argument_list|(
name|o_v_char
argument_list|)
operator|)
operator|)
condition|)
block|{
name|opflag
operator|=
name|FALSE
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|opflag
operator|=
name|TRUE
expr_stmt|;
name|p
operator|=
name|ocur_phys
expr_stmt|;
name|v
operator|=
name|ocur_virt
expr_stmt|;
if|if
condition|(
operator|!
name|is_print
argument_list|(
name|virtual
index|[
name|v
index|]
argument_list|)
condition|)
block|{
comment|/*** avoid double ^'s ***/
operator|++
name|p
expr_stmt|;
operator|++
name|v
expr_stmt|;
block|}
block|}
name|virtual
index|[
name|last_virt
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ncur_phys
operator|=
name|e_virt_to_phys
argument_list|(
name|virtual
argument_list|,
name|physical
argument_list|,
name|cur_virt
argument_list|,
name|v
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|genlen
argument_list|(
name|physical
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|p
operator|<
literal|0
condition|)
name|last_phys
operator|=
literal|0
expr_stmt|;
else|else
name|last_phys
operator|=
name|p
expr_stmt|;
comment|/*** see if this was a translate only ***/
if|if
condition|(
name|mode
operator|==
name|TRANSLATE
condition|)
return|return;
comment|/*** adjust left margin if necessary ***/
if|if
condition|(
name|ncur_phys
operator|<
name|first_w
operator|||
name|ncur_phys
operator|>=
operator|(
name|first_w
operator|+
name|w_size
operator|)
condition|)
block|{
name|cursor
argument_list|(
name|first_w
argument_list|)
expr_stmt|;
name|first_w
operator|=
name|ncur_phys
operator|-
operator|(
name|w_size
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|first_w
operator|<
literal|0
condition|)
name|first_w
operator|=
literal|0
expr_stmt|;
name|first_wind
operator|=
name|cur_phys
operator|=
name|first_w
expr_stmt|;
block|}
comment|/*** attempt to optimize search somewhat to find ***/
comment|/*** out where physical and window images differ ***/
if|if
condition|(
name|first_w
operator|==
name|ofirst_wind
operator|&&
name|ncur_phys
operator|>=
name|ocur_phys
operator|&&
name|opflag
operator|==
name|TRUE
condition|)
block|{
name|p
operator|=
name|ocur_phys
expr_stmt|;
name|w
operator|=
name|p
operator|-
name|first_w
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|first_w
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
operator|(
name|p
operator|<=
name|last_phys
operator|&&
name|w
operator|<=
name|last_wind
operator|)
condition|;
operator|++
name|p
operator|,
operator|++
name|w
control|)
block|{
if|if
condition|(
name|window
index|[
name|w
index|]
operator|!=
name|physical
index|[
name|p
index|]
condition|)
break|break;
block|}
name|p_differ
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|>
name|last_phys
operator|||
name|p
operator|>=
name|first_w
operator|+
name|w_size
operator|)
operator|&&
name|w
operator|>
name|last_wind
operator|&&
name|cur_virt
operator|==
name|ocur_virt
condition|)
block|{
comment|/*** images are identical ***/
return|return;
block|}
comment|/*** copy the physical image to the window image ***/
if|if
condition|(
name|last_virt
operator|!=
name|INVALID
condition|)
block|{
while|while
condition|(
name|p
operator|<=
name|last_phys
operator|&&
name|w
operator|<
name|w_size
condition|)
name|window
index|[
name|w
operator|++
index|]
operator|=
name|physical
index|[
name|p
operator|++
index|]
expr_stmt|;
block|}
name|new_lw
operator|=
name|w
expr_stmt|;
comment|/*** erase trailing characters if needed ***/
while|while
condition|(
name|w
operator|<=
name|last_wind
condition|)
name|window
index|[
name|w
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|last_wind
operator|=
operator|--
name|w
expr_stmt|;
name|p
operator|=
name|p_differ
expr_stmt|;
comment|/*** move cursor to start of difference ***/
name|cursor
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/*** and output difference ***/
name|w
operator|=
name|p
operator|-
name|first_w
expr_stmt|;
while|while
condition|(
name|w
operator|<=
name|last_wind
condition|)
name|putchar
argument_list|(
name|window
index|[
name|w
operator|++
index|]
argument_list|)
expr_stmt|;
name|cur_phys
operator|=
name|w
operator|+
name|first_w
expr_stmt|;
name|last_wind
operator|=
operator|--
name|new_lw
expr_stmt|;
if|if
condition|(
name|last_phys
operator|>=
name|w_size
condition|)
block|{
if|if
condition|(
name|first_w
operator|==
literal|0
condition|)
name|long_char
operator|=
literal|'>'
expr_stmt|;
elseif|else
if|if
condition|(
name|last_phys
operator|<
operator|(
name|first_w
operator|+
name|w_size
operator|)
condition|)
name|long_char
operator|=
literal|'<'
expr_stmt|;
else|else
name|long_char
operator|=
literal|'*'
expr_stmt|;
block|}
else|else
name|long_char
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|long_line
operator|!=
name|long_char
condition|)
block|{
comment|/*** indicate lines longer than window ***/
while|while
condition|(
name|w
operator|++
operator|<
name|w_size
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|cur_phys
expr_stmt|;
block|}
name|putchar
argument_list|(
name|long_char
argument_list|)
expr_stmt|;
operator|++
name|cur_phys
expr_stmt|;
name|long_line
operator|=
name|long_char
expr_stmt|;
block|}
name|ocur_phys
operator|=
name|ncur_phys
expr_stmt|;
name|ocur_virt
operator|=
name|cur_virt
expr_stmt|;
name|ofirst_wind
operator|=
name|first_w
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|INPUT
operator|&&
name|cur_virt
operator|>
name|INVALID
condition|)
operator|++
name|ncur_phys
expr_stmt|;
name|cursor
argument_list|(
name|ncur_phys
argument_list|)
expr_stmt|;
name|e_flush
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*{	REPLACE( char, increment )  *  *	Replace the cur_virt character with char.  This routine attempts  * to avoid using refresh().  *  *	increment	= TRUE, increment cur_virt after replacement.  *			= FALSE, leave cur_virt where it is.  * }*/
end_comment

begin_function
specifier|static
name|int
name|replace
parameter_list|(
name|c
parameter_list|,
name|increment
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|increment
decl_stmt|;
block|{
specifier|register
name|int
name|cur_window
decl_stmt|;
name|cur_window
operator|=
name|cur_phys
operator|-
name|first_wind
expr_stmt|;
if|if
condition|(
name|ocur_virt
operator|==
name|INVALID
operator|||
operator|(
operator|!
name|is_print
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|is_print
argument_list|(
name|o_v_char
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|MULTIBYTE
operator|||
name|icharset
argument_list|(
name|c
argument_list|)
operator|||
name|out_csize
argument_list|(
name|icharset
argument_list|(
name|o_v_char
argument_list|)
argument_list|)
operator|>
literal|1
endif|#
directive|endif
comment|/* MULTIBYTE */
operator|||
operator|(
name|increment
operator|==
name|TRUE
operator|&&
operator|(
name|cur_window
operator|==
name|w_size
operator|-
literal|1
operator|)
operator|||
operator|!
name|is_print
argument_list|(
name|virtual
index|[
name|cur_virt
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/*** must use standard refresh routine ***/
name|delete
argument_list|(
literal|1
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|c
argument_list|,
name|APPEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment
operator|==
name|TRUE
operator|&&
name|cur_virt
operator|<
name|last_virt
condition|)
operator|++
name|cur_virt
expr_stmt|;
name|refresh
argument_list|(
name|CONTROL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|virtual
index|[
name|cur_virt
index|]
operator|=
name|c
expr_stmt|;
name|physical
index|[
name|cur_phys
index|]
operator|=
name|c
expr_stmt|;
name|window
index|[
name|cur_window
index|]
operator|=
name|c
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment
operator|==
name|TRUE
condition|)
block|{
name|c
operator|=
name|virtual
index|[
operator|++
name|cur_virt
index|]
expr_stmt|;
operator|++
name|cur_phys
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
name|o_v_char
operator|=
name|c
expr_stmt|;
name|e_flush
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*{	RESTORE_V()  *  *	Restore the contents of virtual space from u_space.  * }*/
end_comment

begin_function
specifier|static
name|int
name|restore_v
parameter_list|()
block|{
specifier|register
name|int
name|tmpcol
decl_stmt|;
name|genchar
name|tmpspace
index|[
name|MAXCHAR
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|u_column
operator|==
name|INVALID
operator|-
literal|1
condition|)
block|{
comment|/*** never saved anything ***/
name|bell
expr_stmt|;
return|return;
block|}
name|gencpy
argument_list|(
name|tmpspace
argument_list|,
name|u_space
argument_list|)
expr_stmt|;
name|tmpcol
operator|=
name|u_column
expr_stmt|;
name|save_v
argument_list|()
expr_stmt|;
name|gencpy
argument_list|(
name|virtual
argument_list|,
name|tmpspace
argument_list|)
expr_stmt|;
name|cur_virt
operator|=
name|tmpcol
expr_stmt|;
name|last_virt
operator|=
name|genlen
argument_list|(
name|tmpspace
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ocur_virt
operator|=
name|MAXCHAR
expr_stmt|;
comment|/** invalidate refresh optimization **/
return|return;
block|}
end_function

begin_comment
comment|/*{	SAVE_LAST()  *  *	If the user has typed something, save it in last line.  * }*/
end_comment

begin_function
specifier|static
name|int
name|save_last
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|cur_virt
operator|-
name|first_virt
operator|+
literal|1
operator|)
operator|>
literal|0
condition|)
block|{
comment|/*** save last thing user typed ***/
name|genncpy
argument_list|(
name|lastline
argument_list|,
operator|(
operator|&
name|virtual
index|[
name|first_virt
index|]
operator|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lastline
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*{	SAVE_V()  *  *	This routine will save the contents of virtual in u_space.  * }*/
end_comment

begin_function
specifier|static
name|int
name|save_v
parameter_list|()
block|{
if|if
condition|(
operator|!
name|inmacro
condition|)
block|{
name|virtual
index|[
name|last_virt
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|gencpy
argument_list|(
name|u_space
argument_list|,
name|virtual
argument_list|)
expr_stmt|;
name|u_column
operator|=
name|cur_virt
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*{	SEARCH( mode )  *  *	Search history file for regular expression.  *  *	mode	= '/'	require search string and search new to old  *	mode	= '?'	require search string and search old to new  *	mode	= 'N'	repeat last search in reverse direction  *	mode	= 'n'	repeat last search  * }*/
end_comment

begin_function
specifier|static
name|int
name|search
parameter_list|(
name|mode
parameter_list|)
specifier|register
name|char
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|new_direction
decl_stmt|;
specifier|register
name|int
name|oldcurhline
decl_stmt|;
specifier|static
name|int
name|direction
init|=
operator|-
literal|1
decl_stmt|;
name|histloc
name|location
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|'/'
operator|||
name|mode
operator|==
literal|'?'
condition|)
block|{
comment|/*** new search expression ***/
name|del_line
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|mode
argument_list|,
name|APPEND
argument_list|)
expr_stmt|;
name|refresh
argument_list|(
name|INPUT
argument_list|)
expr_stmt|;
name|first_virt
operator|=
literal|1
expr_stmt|;
name|getline
argument_list|(
name|SEARCH
argument_list|)
expr_stmt|;
name|first_virt
operator|=
literal|0
expr_stmt|;
name|virtual
index|[
name|last_virt
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*** make null terminated ***/
name|direction
operator|=
name|mode
operator|==
literal|'/'
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cur_virt
operator|==
name|INVALID
condition|)
block|{
comment|/*** no operation ***/
return|return
operator|(
name|ABORT
operator|)
return|;
block|}
if|if
condition|(
name|cur_virt
operator|==
literal|0
operator|||
name|fold
argument_list|(
name|mode
argument_list|)
operator|==
literal|'N'
condition|)
block|{
comment|/*** user wants repeat of last search ***/
name|del_line
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|virtual
operator|)
operator|+
literal|1
argument_list|,
name|lsearch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|virtual
operator|)
operator|=
literal|'/'
expr_stmt|;
name|e_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|virtual
argument_list|,
name|virtual
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
block|}
if|if
condition|(
name|mode
operator|==
literal|'N'
condition|)
name|new_direction
operator|=
operator|-
name|direction
expr_stmt|;
else|else
name|new_direction
operator|=
name|direction
expr_stmt|;
if|if
condition|(
name|new_direction
operator|==
literal|1
operator|&&
name|curhline
operator|>=
name|histmax
condition|)
name|curhline
operator|=
name|histmin
operator|+
literal|1
expr_stmt|;
comment|/*** now search ***/
name|oldcurhline
operator|=
name|curhline
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
name|e_external
argument_list|(
name|virtual
argument_list|,
operator|(
name|char
operator|*
operator|)
name|virtual
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|location
operator|=
name|hist_find
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|virtual
operator|)
operator|+
literal|1
argument_list|,
name|curhline
argument_list|,
literal|1
argument_list|,
name|new_direction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curhline
operator|=
name|location
operator|.
name|his_command
operator|)
operator|>=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|lsearch
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|virtual
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
comment|/*** could not find matching line ***/
name|curhline
operator|=
name|oldcurhline
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*{	SYNC_CURSOR()  *  *	This routine will move the physical cursor to the same  * column as the virtual cursor.  * }*/
end_comment

begin_function
specifier|static
name|int
name|sync_cursor
parameter_list|()
block|{
specifier|register
name|int
name|p
decl_stmt|;
specifier|register
name|int
name|v
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|new_phys
decl_stmt|;
if|if
condition|(
name|cur_virt
operator|==
name|INVALID
condition|)
return|return;
comment|/*** find physical col that corresponds to virtual col ***/
name|new_phys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first_wind
operator|==
name|ofirst_wind
operator|&&
name|cur_virt
operator|>
name|ocur_virt
condition|)
block|{
comment|/*** try to optimize search a little ***/
name|p
operator|=
name|ocur_phys
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
while|while
condition|(
name|physical
index|[
name|p
index|]
operator|==
name|MARKER
condition|)
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|v
operator|=
name|ocur_virt
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
literal|0
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|v
operator|<=
name|last_virt
condition|;
operator|++
name|p
operator|,
operator|++
name|v
control|)
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE
name|int
name|d
decl_stmt|;
name|c
operator|=
name|virtual
index|[
name|v
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|=
name|icharset
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|v
operator|!=
name|cur_virt
condition|)
name|p
operator|+=
operator|(
name|out_csize
argument_list|(
name|d
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
else|#
directive|else
name|c
operator|=
name|virtual
index|[
name|v
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|p
operator|=
operator|(
name|p
operator|+
literal|8
operator|)
operator|&
operator|~
literal|07
expr_stmt|;
operator|--
name|p
expr_stmt|;
block|}
else|else
block|{
operator|++
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|==
name|cur_virt
condition|)
block|{
name|new_phys
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_phys
operator|<
name|first_wind
operator|||
name|new_phys
operator|>=
name|first_wind
operator|+
name|w_size
condition|)
block|{
comment|/*** asked to move outside of window ***/
name|window
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|refresh
argument_list|(
name|CONTROL
argument_list|)
expr_stmt|;
return|return;
block|}
name|cursor
argument_list|(
name|new_phys
argument_list|)
expr_stmt|;
name|e_flush
argument_list|()
expr_stmt|;
name|ocur_phys
operator|=
name|cur_phys
expr_stmt|;
name|ocur_virt
operator|=
name|cur_virt
expr_stmt|;
name|o_v_char
operator|=
name|virtual
index|[
name|ocur_virt
index|]
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*{	TEXTMOD( command, mode )  *  *	Modify text operations.  *  *	mode != 0, repeat previous operation  * }*/
end_comment

begin_function
specifier|static
name|int
name|textmod
parameter_list|(
name|c
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|genchar
modifier|*
name|p
init|=
name|lastline
decl_stmt|;
specifier|register
name|int
name|trepeat
init|=
name|repeat
decl_stmt|;
name|genchar
modifier|*
name|savep
decl_stmt|;
if|if
condition|(
name|mode
operator|&&
operator|(
name|fold
argument_list|(
name|lastmotion
argument_list|)
operator|==
literal|'F'
operator|||
name|fold
argument_list|(
name|lastmotion
argument_list|)
operator|==
literal|'T'
operator|)
condition|)
name|lastmotion
operator|=
literal|';'
expr_stmt|;
if|if
condition|(
name|fold
argument_list|(
name|c
argument_list|)
operator|==
literal|'P'
condition|)
block|{
comment|/*** change p from lastline to yankbuf ***/
name|p
operator|=
name|yankbuf
expr_stmt|;
block|}
name|addin
label|:
switch|switch
condition|(
name|c
condition|)
block|{
comment|/***** Input commands *****/
ifdef|#
directive|ifdef
name|KSHELL
case|case
literal|'*'
case|:
comment|/** do file name expansion in place **/
if|if
condition|(
name|cur_virt
operator|==
name|INVALID
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
case|case
literal|'='
case|:
comment|/** list file name expansions **/
name|save_v
argument_list|()
expr_stmt|;
name|i
operator|=
name|last_virt
expr_stmt|;
operator|++
name|last_virt
expr_stmt|;
name|virtual
index|[
name|last_virt
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q_expand
argument_list|(
operator|(
name|char
operator|*
operator|)
name|virtual
argument_list|,
operator|&
name|cur_virt
argument_list|,
operator|&
name|last_virt
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|last_virt
operator|=
name|i
expr_stmt|;
name|bell
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|last_virt
operator|=
name|i
expr_stmt|;
name|nonewline
operator|++
expr_stmt|;
name|ungetchar
argument_list|(
name|cntl
argument_list|(
name|L
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
else|else
block|{
operator|--
name|cur_virt
expr_stmt|;
operator|--
name|last_virt
expr_stmt|;
name|ocur_virt
operator|=
name|MAXCHAR
expr_stmt|;
return|return
operator|(
name|APPEND
operator|)
return|;
block|}
break|break;
case|case
literal|'@'
case|:
comment|/** macro expansion **/
if|if
condition|(
name|mode
condition|)
name|c
operator|=
operator|*
name|p
expr_stmt|;
else|else
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|e_macro
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|save_v
argument_list|()
expr_stmt|;
name|inmacro
operator|++
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
name|bell
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
endif|#
directive|endif
comment|/* KSHELL */
case|case
literal|'_'
case|:
comment|/** append last argument of prev command **/
name|save_v
argument_list|()
expr_stmt|;
block|{
name|genchar
name|tmpbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|repeat_set
operator|==
literal|0
condition|)
name|repeat
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|genchar
operator|*
operator|)
name|hist_word
argument_list|(
name|tmpbuf
argument_list|,
name|repeat
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|KSHELL
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|bell
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* KSHELL */
ifdef|#
directive|ifdef
name|MULTIBYTE
name|e_internal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmpbuf
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
name|i
operator|=
literal|' '
expr_stmt|;
do|do
block|{
name|append
argument_list|(
name|i
argument_list|,
name|APPEND
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|=
operator|*
name|p
operator|++
condition|)
do|;
return|return
operator|(
name|APPEND
operator|)
return|;
block|}
case|case
literal|'A'
case|:
comment|/** append to end of line **/
name|cur_virt
operator|=
name|last_virt
expr_stmt|;
name|sync_cursor
argument_list|()
expr_stmt|;
case|case
literal|'a'
case|:
comment|/** append **/
if|if
condition|(
name|fold
argument_list|(
name|mode
argument_list|)
operator|==
literal|'A'
condition|)
block|{
name|c
operator|=
literal|'p'
expr_stmt|;
goto|goto
name|addin
goto|;
block|}
name|save_v
argument_list|()
expr_stmt|;
if|if
condition|(
name|cur_virt
operator|!=
name|INVALID
condition|)
block|{
name|first_virt
operator|=
name|cur_virt
operator|+
literal|1
expr_stmt|;
name|cursor
argument_list|(
name|cur_phys
operator|+
literal|1
argument_list|)
expr_stmt|;
name|e_flush
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|APPEND
operator|)
return|;
case|case
literal|'I'
case|:
comment|/** insert at beginning of line **/
name|cur_virt
operator|=
name|first_virt
expr_stmt|;
name|sync_cursor
argument_list|()
expr_stmt|;
case|case
literal|'i'
case|:
comment|/** insert **/
if|if
condition|(
name|fold
argument_list|(
name|mode
argument_list|)
operator|==
literal|'I'
condition|)
block|{
name|c
operator|=
literal|'P'
expr_stmt|;
goto|goto
name|addin
goto|;
block|}
name|save_v
argument_list|()
expr_stmt|;
if|if
condition|(
name|cur_virt
operator|!=
name|INVALID
condition|)
name|first_virt
operator|=
name|cur_virt
operator|--
expr_stmt|;
return|return
operator|(
name|INSERT
operator|)
return|;
case|case
literal|'C'
case|:
comment|/** change to eol **/
name|c
operator|=
literal|'$'
expr_stmt|;
goto|goto
name|chgeol
goto|;
case|case
literal|'c'
case|:
comment|/** change **/
if|if
condition|(
name|mode
condition|)
name|c
operator|=
name|lastmotion
expr_stmt|;
else|else
name|c
operator|=
name|getcount
argument_list|(
name|getchar
argument_list|()
argument_list|)
expr_stmt|;
name|chgeol
label|:
name|lastmotion
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'c'
condition|)
block|{
name|del_line
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
return|return
operator|(
name|APPEND
operator|)
return|;
block|}
if|if
condition|(
name|delmotion
argument_list|(
name|c
argument_list|,
literal|'c'
argument_list|)
operator|==
name|BAD
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
if|if
condition|(
name|mode
operator|==
literal|'c'
condition|)
block|{
name|c
operator|=
literal|'p'
expr_stmt|;
name|trepeat
operator|=
literal|1
expr_stmt|;
goto|goto
name|addin
goto|;
block|}
name|first_virt
operator|=
name|cur_virt
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|APPEND
operator|)
return|;
case|case
literal|'D'
case|:
comment|/** delete to eol **/
name|c
operator|=
literal|'$'
expr_stmt|;
goto|goto
name|deleol
goto|;
case|case
literal|'d'
case|:
comment|/** delete **/
if|if
condition|(
name|mode
condition|)
name|c
operator|=
name|lastmotion
expr_stmt|;
else|else
name|c
operator|=
name|getcount
argument_list|(
name|getchar
argument_list|()
argument_list|)
expr_stmt|;
name|deleol
label|:
name|lastmotion
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
name|del_line
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|delmotion
argument_list|(
name|c
argument_list|,
literal|'d'
argument_list|)
operator|==
name|BAD
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
if|if
condition|(
name|cur_virt
operator|<
name|last_virt
condition|)
operator|++
name|cur_virt
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
if|if
condition|(
name|cur_virt
operator|!=
name|INVALID
condition|)
operator|--
name|cur_virt
expr_stmt|;
case|case
literal|'p'
case|:
comment|/** print **/
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
if|if
condition|(
name|mode
operator|!=
literal|'s'
operator|&&
name|mode
operator|!=
literal|'c'
condition|)
block|{
name|save_v
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'P'
condition|)
block|{
comment|/*** fix stored cur_virt ***/
operator|++
name|u_column
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
literal|'R'
condition|)
name|mode
operator|=
name|REPLACE
expr_stmt|;
else|else
name|mode
operator|=
name|APPEND
expr_stmt|;
name|savep
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|trepeat
condition|;
operator|++
name|i
control|)
block|{
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
name|append
argument_list|(
name|c
argument_list|,
name|APPEND
argument_list|)
expr_stmt|;
name|p
operator|=
name|savep
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
comment|/* Replace many chars **/
if|if
condition|(
name|mode
operator|==
literal|'R'
condition|)
block|{
name|c
operator|=
literal|'P'
expr_stmt|;
goto|goto
name|addin
goto|;
block|}
name|save_v
argument_list|()
expr_stmt|;
if|if
condition|(
name|cur_virt
operator|!=
name|INVALID
condition|)
name|first_virt
operator|=
name|cur_virt
expr_stmt|;
return|return
operator|(
name|REPLACE
operator|)
return|;
case|case
literal|'r'
case|:
comment|/** replace **/
if|if
condition|(
name|mode
condition|)
name|c
operator|=
operator|*
name|p
expr_stmt|;
else|else
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|save_v
argument_list|()
expr_stmt|;
name|replace
argument_list|(
name|c
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
literal|'S'
case|:
comment|/** Substitute line - cc **/
name|c
operator|=
literal|'c'
expr_stmt|;
goto|goto
name|chgeol
goto|;
case|case
literal|'s'
case|:
comment|/** substitute **/
name|save_v
argument_list|()
expr_stmt|;
name|delete
argument_list|(
name|repeat
argument_list|,
name|BAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
condition|)
block|{
name|c
operator|=
literal|'p'
expr_stmt|;
name|trepeat
operator|=
literal|1
expr_stmt|;
goto|goto
name|addin
goto|;
block|}
name|first_virt
operator|=
name|cur_virt
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|APPEND
operator|)
return|;
case|case
literal|'Y'
case|:
comment|/** Yank to end of line **/
name|c
operator|=
literal|'$'
expr_stmt|;
goto|goto
name|yankeol
goto|;
case|case
literal|'y'
case|:
comment|/** yank thru motion **/
if|if
condition|(
name|mode
condition|)
name|c
operator|=
name|lastmotion
expr_stmt|;
else|else
name|c
operator|=
name|getcount
argument_list|(
name|getchar
argument_list|()
argument_list|)
expr_stmt|;
name|yankeol
label|:
name|lastmotion
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'y'
condition|)
block|{
name|gencpy
argument_list|(
name|yankbuf
argument_list|,
name|virtual
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delmotion
argument_list|(
name|c
argument_list|,
literal|'y'
argument_list|)
operator|==
name|BAD
condition|)
block|{
return|return
operator|(
name|BAD
operator|)
return|;
block|}
break|break;
case|case
literal|'x'
case|:
comment|/** delete repeat chars forward - dl **/
name|c
operator|=
literal|'l'
expr_stmt|;
goto|goto
name|deleol
goto|;
case|case
literal|'X'
case|:
comment|/** delete repeat chars backward - dh **/
name|c
operator|=
literal|'h'
expr_stmt|;
goto|goto
name|deleol
goto|;
case|case
literal|'~'
case|:
comment|/** invert case and advance **/
if|if
condition|(
name|cur_virt
operator|!=
name|INVALID
condition|)
block|{
name|save_v
argument_list|()
expr_stmt|;
name|c
operator|=
name|virtual
index|[
name|cur_virt
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
if|if
condition|(
operator|(
name|c
operator|&
operator|~
name|STRIP
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* MULTIBYTE */
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|replace
argument_list|(
name|c
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
else|else
return|return
operator|(
name|BAD
operator|)
return|;
default|default:
return|return
operator|(
name|BAD
operator|)
return|;
block|}
name|refresh
argument_list|(
name|CONTROL
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INT16
end_ifdef

begin_comment
comment|/* making these functions reduces the size of the text region */
end_comment

begin_function
name|int
name|isalph
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|v
init|=
name|virtual
index|[
name|c
index|]
decl_stmt|;
return|return
operator|(
name|isalnum
argument_list|(
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isblank
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|v
init|=
name|virtual
index|[
name|c
index|]
decl_stmt|;
return|return
operator|(
name|isspace
argument_list|(
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ismetach
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|v
init|=
name|virtual
index|[
name|c
index|]
decl_stmt|;
return|return
operator|(
name|ismeta
argument_list|(
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INT16 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE
end_ifdef

begin_function
name|int
name|isalph
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|v
init|=
name|virtual
index|[
name|c
index|]
decl_stmt|;
return|return
operator|(
operator|(
name|v
operator|&
operator|~
name|STRIP
operator|)
operator|||
name|isalnum
argument_list|(
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isblank
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|v
init|=
name|virtual
index|[
name|c
index|]
decl_stmt|;
return|return
operator|(
operator|(
name|v
operator|&
operator|~
name|STRIP
operator|)
operator|==
literal|0
operator|&&
name|isspace
argument_list|(
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ismetach
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|v
init|=
name|virtual
index|[
name|c
index|]
decl_stmt|;
return|return
operator|(
operator|(
name|v
operator|&
operator|~
name|STRIP
operator|)
operator|==
literal|0
operator|&&
name|ismeta
argument_list|(
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE */
end_comment

end_unit

