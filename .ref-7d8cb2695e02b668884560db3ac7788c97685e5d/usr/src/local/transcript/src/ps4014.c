begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Notice
index|[]
init|=
literal|"Copyright (c) 1985 Adobe Systems Incorporated"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSID
init|=
literal|"$Header: ps4014.c,v 2.1 85/11/24 11:49:18 shore Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ps4014.c  *  * Copyright (c) 1985 Adobe Systems Incorporated  *  * tektronics 4014 to PostScript filter  *  * Edit History:  * Original Version: Tom Malloy  * Andrew Shore: Mon Nov  4 13:46:08 1985  * End Edit History.  *  * RCSLOG:  * $Log:	ps4014.c,v $  * Revision 2.1  85/11/24  11:49:18  shore  * Product Release 2.0  *   * Revision 1.1  85/11/20  00:16:33  shore  * Initial revision  *   *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"transcript.h"
end_include

begin_comment
comment|/* move this to transcript.h some day */
end_comment

begin_decl_stmt
name|private
name|char
name|scProlog
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|Params
block|{
name|char
modifier|*
name|scSrcFile
decl_stmt|;
comment|/* string name of 4014 source file */
name|char
modifier|*
name|scDstFile
decl_stmt|;
comment|/* string name of PS destination file */
name|char
modifier|*
name|scDbgFile
decl_stmt|;
comment|/* string name of debug output file */
name|short
name|fCrGenLf
decl_stmt|;
comment|/* true if carriage return generates line     				   feed */
name|short
name|fLfGenCr
decl_stmt|;
comment|/* true if line feed generates carriage 				   return  */
name|short
name|fMarg2
decl_stmt|;
comment|/* true if there are two left margins for 				   text, one a left and one in the middle 				   of the page */
name|short
name|fDbg
decl_stmt|;
comment|/* true if debug output should be 				   generated */
name|float
name|xRtInch
decl_stmt|;
comment|/* top, left location of output on page */
name|float
name|yBotInch
decl_stmt|;
name|float
name|dxWidInch
decl_stmt|;
comment|/* width, height of output */
name|float
name|dyHtInch
decl_stmt|;
name|int
name|fLandscape
decl_stmt|;
comment|/* do landscape page */
block|}
struct|;
end_struct

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|Real4110
block|{
name|long
name|mantissa
decl_stmt|,
name|exp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* 4110-format real number */
end_comment

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|Sts
block|{
name|short
name|md
decl_stmt|;
comment|/* current mode */
name|int
name|xh
decl_stmt|;
comment|/* current x-position (in 4096ths) */
name|int
name|yh
decl_stmt|;
comment|/* current y-position (in 4096ths) */
name|char
name|chHiY
decl_stmt|,
name|chHiX
decl_stmt|,
name|chExtra
decl_stmt|,
name|chLoY
decl_stmt|;
comment|/* current values for the vector-mode address bytes that may be omitted     when sending an address - see GetXhYh */
name|short
name|syline
decl_stmt|;
comment|/* current line style from 4014 input 				   viewpoint */
name|short
name|sychar
decl_stmt|;
comment|/* current character style */
name|short
name|charset
decl_stmt|;
comment|/* normal or alternate character set */
name|short
name|sylinePrt
decl_stmt|;
comment|/* current line style from printers 				   viewpoint */
name|short
name|sycharPrt
decl_stmt|;
comment|/* current character style from printers 				   viewpoint */
name|short
name|charsetPrt
decl_stmt|;
comment|/* normal or alternate characters from 				   printers viewpoint */
name|short
name|fPenDown
decl_stmt|;
comment|/* true implies vector command draws false 				   implies vector command moves */
name|short
name|fMovePending
decl_stmt|;
comment|/* true implies 4014 position and 				   PostScript position are different */
name|short
name|fVectorDrawn
decl_stmt|;
comment|/* true implies Stroke command is pending 				   on current PostScript path */
name|short
name|dir
decl_stmt|;
comment|/* current incremental point plot 				   direction */
name|int
name|cincr
decl_stmt|;
comment|/* count of increments tom move/draw in 				   current incremental point plot 				   direction */
name|int
name|xhLeftMarg
decl_stmt|;
comment|/* current left margin */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|mdAlpha
value|0
end_define

begin_comment
comment|/* Alpha mode */
end_comment

begin_define
define|#
directive|define
name|mdVector
value|1
end_define

begin_comment
comment|/* Vector graphics mode */
end_comment

begin_define
define|#
directive|define
name|mdPtPlot
value|2
end_define

begin_comment
comment|/* Point plot mode */
end_comment

begin_define
define|#
directive|define
name|mdSpecPtPlot
value|3
end_define

begin_comment
comment|/* Special point plot mode */
end_comment

begin_define
define|#
directive|define
name|mdIncrPtPlot
value|4
end_define

begin_comment
comment|/* Incremental point plot mode */
end_comment

begin_define
define|#
directive|define
name|mdBypass
value|5
end_define

begin_comment
comment|/* Bypass mode */
end_comment

begin_define
define|#
directive|define
name|chFstSyline
value|'`'
end_define

begin_comment
comment|/* first valid line style command 				   character */
end_comment

begin_define
define|#
directive|define
name|chLstSyline
value|'w'
end_define

begin_comment
comment|/* last valid line style command character */
end_comment

begin_define
define|#
directive|define
name|sylineNormal
value|0
end_define

begin_comment
comment|/* normal line style */
end_comment

begin_define
define|#
directive|define
name|sylineDot
value|1
end_define

begin_comment
comment|/* dotted line style */
end_comment

begin_define
define|#
directive|define
name|sylineDotDashed
value|2
end_define

begin_comment
comment|/* dot-dashed line style */
end_comment

begin_define
define|#
directive|define
name|sylineShortDash
value|3
end_define

begin_comment
comment|/* short dash line style */
end_comment

begin_define
define|#
directive|define
name|sylineLongDash
value|4
end_define

begin_comment
comment|/* long dash line style */
end_comment

begin_define
define|#
directive|define
name|sylineMax
value|5
end_define

begin_comment
comment|/* number of valid line styles */
end_comment

begin_define
define|#
directive|define
name|mskSyline
value|7
end_define

begin_comment
comment|/* mask for extracting line style indexes 				   from line style command characters. */
end_comment

begin_define
define|#
directive|define
name|chFstSychar
value|'8'
end_define

begin_comment
comment|/* first valid character style command 				   character */
end_comment

begin_define
define|#
directive|define
name|chLstSychar
value|';'
end_define

begin_comment
comment|/* last valid character style command 				   character */
end_comment

begin_define
define|#
directive|define
name|sycharLarge
value|0
end_define

begin_comment
comment|/* character style: large character */
end_comment

begin_define
define|#
directive|define
name|sychar2
value|1
end_define

begin_comment
comment|/* character style 2 */
end_comment

begin_define
define|#
directive|define
name|sychar3
value|2
end_define

begin_comment
comment|/* charactr style 3 */
end_comment

begin_define
define|#
directive|define
name|sycharSmall
value|3
end_define

begin_comment
comment|/* charactr style: small characters */
end_comment

begin_define
define|#
directive|define
name|sycharMax
value|4
end_define

begin_comment
comment|/* number of valid character styles */
end_comment

begin_define
define|#
directive|define
name|charsetStd
value|0
end_define

begin_comment
comment|/* normal character set */
end_comment

begin_define
define|#
directive|define
name|charsetAlt
value|1
end_define

begin_comment
comment|/* Alternate character set */
end_comment

begin_define
define|#
directive|define
name|chFstShow
value|' '
end_define

begin_comment
comment|/* first valid printable character */
end_comment

begin_define
define|#
directive|define
name|chLstShow
value|126
end_define

begin_comment
comment|/* last valid printable character */
end_comment

begin_define
define|#
directive|define
name|chFstCoord
value|' '
end_define

begin_comment
comment|/* first valid graphics address byte */
end_comment

begin_define
define|#
directive|define
name|chLstCoord
value|127
end_define

begin_comment
comment|/* last valid graphcs address byte */
end_comment

begin_define
define|#
directive|define
name|chFstLoX
value|'@'
end_define

begin_comment
comment|/* first valid low x byte */
end_comment

begin_define
define|#
directive|define
name|chFstLoY
value|'`'
end_define

begin_comment
comment|/* last valid low x byte */
end_comment

begin_define
define|#
directive|define
name|mskLoBits
value|3
end_define

begin_comment
comment|/* mask for extracting low order address 				   bits from extra byte */
end_comment

begin_define
define|#
directive|define
name|mskBit4
value|16
end_define

begin_comment
comment|/* mask for extracting margin bit from 				   extra byte */
end_comment

begin_define
define|#
directive|define
name|shiftHiByte
value|7
end_define

begin_comment
comment|/* number of bits to shift high-byte 				   address bits in composed address */
end_comment

begin_define
define|#
directive|define
name|shiftLoByte
value|2
end_define

begin_comment
comment|/* number of bits to shift low-byte 				   address bits in composed address */
end_comment

begin_define
define|#
directive|define
name|shiftYExtra
value|2
end_define

begin_comment
comment|/* number of bits to shift extra byte to 				   right align the low order y bits */
end_comment

begin_comment
comment|/* Some 4110 command code definitions */
end_comment

begin_define
define|#
directive|define
name|chFst4110
value|'I'
end_define

begin_comment
comment|/* first valid 4110 command code character 				   */
end_comment

begin_define
define|#
directive|define
name|chLst4110
value|'Z'
end_define

begin_comment
comment|/* last valid 4110 command code character  				*/
end_comment

begin_define
define|#
directive|define
name|chFstEsc2
value|'A'
end_define

begin_comment
comment|/* first valid character for the second 				   character of a 2-byte 4110 command code 				   sequence */
end_comment

begin_define
define|#
directive|define
name|chLstEsc2
value|'Z'
end_define

begin_comment
comment|/* last valid character for the second 				   character of a 2-byte 4110 command code 				   sequence */
end_comment

begin_define
define|#
directive|define
name|chFstHiInt
value|'@'
end_define

begin_comment
comment|/* first valid character for non-low-order 				   portion of integer parameter */
end_comment

begin_define
define|#
directive|define
name|chLstHiInt
value|127
end_define

begin_comment
comment|/* last valid character for non-low-order 				   portion of integer parameter */
end_comment

begin_define
define|#
directive|define
name|chFstLoPosInt
value|'0'
end_define

begin_comment
comment|/* first valid character for low-order 				   portion of positive integer */
end_comment

begin_define
define|#
directive|define
name|chLstLoPosInt
value|'?'
end_define

begin_comment
comment|/* last valid character for low-order 				   portion of positive integer */
end_comment

begin_define
define|#
directive|define
name|chFstLoNegInt
value|32
end_define

begin_comment
comment|/* first valid character for low-order 				   portion of negative integer */
end_comment

begin_define
define|#
directive|define
name|chLstLoNegInt
value|'/'
end_define

begin_comment
comment|/* last valid character for low-order 				   portion of positive integer */
end_comment

begin_comment
comment|/* Some useful ASCII command character defintions */
end_comment

begin_define
define|#
directive|define
name|chNull
value|0x0
end_define

begin_define
define|#
directive|define
name|chEnq
value|0x5
end_define

begin_define
define|#
directive|define
name|chBell
value|0x7
end_define

begin_define
define|#
directive|define
name|chBs
value|0x8
end_define

begin_define
define|#
directive|define
name|chTab
value|0x9
end_define

begin_define
define|#
directive|define
name|chLf
value|0xA
end_define

begin_define
define|#
directive|define
name|chVTab
value|0xB
end_define

begin_define
define|#
directive|define
name|chFf
value|0xC
end_define

begin_define
define|#
directive|define
name|chCr
value|0xD
end_define

begin_define
define|#
directive|define
name|chSo
value|0xE
end_define

begin_define
define|#
directive|define
name|chSi
value|0xF
end_define

begin_define
define|#
directive|define
name|chEtb
value|0x17
end_define

begin_define
define|#
directive|define
name|chCan
value|0x18
end_define

begin_define
define|#
directive|define
name|chSub
value|0x1A
end_define

begin_define
define|#
directive|define
name|chEsc
value|0x1B
end_define

begin_define
define|#
directive|define
name|chFs
value|0x1C
end_define

begin_define
define|#
directive|define
name|chGs
value|0x1D
end_define

begin_define
define|#
directive|define
name|chRs
value|0x1E
end_define

begin_define
define|#
directive|define
name|chUs
value|0x1F
end_define

begin_define
define|#
directive|define
name|chSp
value|0x20
end_define

begin_define
define|#
directive|define
name|chDel
value|0x7F
end_define

begin_comment
comment|/* Types of 4014 postion movement commands */
end_comment

begin_define
define|#
directive|define
name|tymoveNil
value|0
end_define

begin_define
define|#
directive|define
name|tymoveLeft
value|1
end_define

begin_define
define|#
directive|define
name|tymoveRt
value|2
end_define

begin_define
define|#
directive|define
name|tymoveUp
value|3
end_define

begin_define
define|#
directive|define
name|tymoveDown
value|4
end_define

begin_define
define|#
directive|define
name|tymoveGDown
value|5
end_define

begin_define
define|#
directive|define
name|tymoveXMarg
value|6
end_define

begin_define
define|#
directive|define
name|tymoveMax
value|7
end_define

begin_comment
comment|/* masks for extracting movement direction  from incremental point plot commands */
end_comment

begin_define
define|#
directive|define
name|mskDir
value|0xF
end_define

begin_define
define|#
directive|define
name|mskDirUp
value|4
end_define

begin_define
define|#
directive|define
name|mskDirRt
value|1
end_define

begin_define
define|#
directive|define
name|mskDirDown
value|8
end_define

begin_define
define|#
directive|define
name|mskDirLeft
value|2
end_define

begin_define
define|#
directive|define
name|dirNil
value|0
end_define

begin_comment
comment|/* Some x and y coordinates (in 4096ths) */
end_comment

begin_define
define|#
directive|define
name|xhHome
value|0
end_define

begin_define
define|#
directive|define
name|xhMarg1
value|0
end_define

begin_define
define|#
directive|define
name|xhMarg2
value|2048
end_define

begin_define
define|#
directive|define
name|yhHome
value|3071
end_define

begin_define
define|#
directive|define
name|xhMax
value|4096
end_define

begin_define
define|#
directive|define
name|yhMax
value|3120
end_define

begin_comment
comment|/* Constants and parser tables for 4110 parser */
end_comment

begin_comment
comment|/* parameter types */
end_comment

begin_define
define|#
directive|define
name|typrmNil
value|0
end_define

begin_define
define|#
directive|define
name|typrmLong
value|1
end_define

begin_comment
comment|/* 32-bit integer parameter */
end_comment

begin_define
define|#
directive|define
name|typrmAryLong
value|2
end_define

begin_comment
comment|/* array of 32-bit integers */
end_comment

begin_define
define|#
directive|define
name|typrmXhYh
value|3
end_define

begin_comment
comment|/* vector mode xy-coordinate */
end_comment

begin_define
define|#
directive|define
name|typrmString
value|4
end_define

begin_comment
comment|/* 4110 format string */
end_comment

begin_define
define|#
directive|define
name|typrmCh
value|5
end_define

begin_comment
comment|/* character */
end_comment

begin_define
define|#
directive|define
name|typrmReal4110
value|6
end_define

begin_comment
comment|/* 4110 format real number */
end_comment

begin_define
define|#
directive|define
name|typrmAryXhYh
value|7
end_define

begin_comment
comment|/* array of vector mode corrdinates */
end_comment

begin_define
define|#
directive|define
name|typrmMax
value|8
end_define

begin_comment
comment|/* number of valid parameter types */
end_comment

begin_define
define|#
directive|define
name|iprmMax
value|4
end_define

begin_comment
comment|/* maximum number of parameters to a 4110 				   command */
end_comment

begin_comment
comment|/* Identifiers for some, but not all, commonly used     parameter sequences for 4110 commands */
end_comment

begin_define
define|#
directive|define
name|ifmtNil
value|0
end_define

begin_define
define|#
directive|define
name|ifmtL
value|1
end_define

begin_define
define|#
directive|define
name|ifmtLL
value|2
end_define

begin_define
define|#
directive|define
name|ifmtLLL
value|3
end_define

begin_define
define|#
directive|define
name|ifmtLLLL
value|4
end_define

begin_define
define|#
directive|define
name|ifmtXhYh
value|9
end_define

begin_define
define|#
directive|define
name|ifmtMax
value|31
end_define

begin_comment
comment|/* total number of distinct parameter 				   seqeunces */
end_comment

begin_define
define|#
directive|define
name|cchEsc1
value|18
end_define

begin_comment
comment|/* number of valid 4110 command character 				   that can follow an<Esc> */
end_comment

begin_define
define|#
directive|define
name|chEsc1Fst
value|'I'
end_define

begin_comment
comment|/* first valid 4110 command character */
end_comment

begin_define
define|#
directive|define
name|chEsc1Lst
value|'Z'
end_define

begin_comment
comment|/* last valid 4110 command character */
end_comment

begin_define
define|#
directive|define
name|cchEsc2
value|26
end_define

begin_comment
comment|/* number of valid command characters for 				   the second character in two character 				   4110 command sequences */
end_comment

begin_define
define|#
directive|define
name|chEsc2Fst
value|'A'
end_define

begin_comment
comment|/* first valid character for second 				   character in a 4110 command sequence */
end_comment

begin_define
define|#
directive|define
name|chEsc2Lst
value|'Z'
end_define

begin_comment
comment|/* last valid character for second 				   character in a 4110 command sequence */
end_comment

begin_comment
comment|/* Parser table 1.  Indexed by ifmt, a parameter sequence id.  Yields    an array of four elements each of which identifies the type of    the i-th parameter in the sequence. */
end_comment

begin_decl_stmt
name|private
name|char
name|aryfmt
index|[
name|ifmtMax
index|]
index|[
name|iprmMax
index|]
init|=
block|{
block|{
name|typrmNil
block|,
name|typrmNil
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmLong
block|,
name|typrmNil
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmLong
block|,
name|typrmLong
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmLong
block|,
name|typrmLong
block|,
name|typrmLong
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmLong
block|,
name|typrmLong
block|,
name|typrmLong
block|,
name|typrmLong
block|}
block|,
comment|/*[5]*/
block|{
name|typrmAryLong
block|,
name|typrmNil
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmAryLong
block|,
name|typrmAryLong
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmLong
block|,
name|typrmAryLong
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmLong
block|,
name|typrmAryLong
block|,
name|typrmAryLong
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmXhYh
block|,
name|typrmNil
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
comment|/*[10]*/
block|{
name|typrmXhYh
block|,
name|typrmXhYh
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmLong
block|,
name|typrmXhYh
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmXhYh
block|,
name|typrmLong
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmLong
block|,
name|typrmLong
block|,
name|typrmXhYh
block|,
name|typrmXhYh
block|}
block|,
block|{
name|typrmXhYh
block|,
name|typrmXhYh
block|,
name|typrmLong
block|,
name|typrmNil
block|}
block|,
comment|/*[15]*/
block|{
name|typrmLong
block|,
name|typrmXhYh
block|,
name|typrmXhYh
block|,
name|typrmXhYh
block|}
block|,
block|{
name|typrmAryXhYh
block|,
name|typrmNil
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmString
block|,
name|typrmNil
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmString
block|,
name|typrmString
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmString
block|,
name|typrmString
block|,
name|typrmString
block|,
name|typrmNil
block|}
block|,
comment|/*[20]*/
block|{
name|typrmString
block|,
name|typrmLong
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmString
block|,
name|typrmString
block|,
name|typrmLong
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmString
block|,
name|typrmLong
block|,
name|typrmLong
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmString
block|,
name|typrmLong
block|,
name|typrmString
block|,
name|typrmLong
block|}
block|,
block|{
name|typrmCh
block|,
name|typrmNil
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
comment|/*[25]*/
block|{
name|typrmCh
block|,
name|typrmCh
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmLong
block|,
name|typrmString
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmReal4110
block|,
name|typrmNil
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmString
block|,
name|typrmLong
block|,
name|typrmString
block|,
name|typrmString
block|}
block|,
block|{
name|typrmString
block|,
name|typrmAryLong
block|,
name|typrmNil
block|,
name|typrmNil
block|}
block|,
block|{
name|typrmString
block|,
name|typrmLong
block|,
name|typrmLong
block|,
name|typrmLong
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parser table 2.  Indexed by the two characters of a 4110 command     sequence.  Yields a parameter sequence index, which can be used to    retreive the parameter types from aryfmt. */
end_comment

begin_decl_stmt
name|private
name|char
name|aryaryifmt
index|[
name|cchEsc1
index|]
index|[
name|cchEsc2
index|]
init|=
block|{
comment|/*['I']*/
block|{
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtLL
block|,
name|ifmtL
block|,
name|ifmtLL
block|,
name|ifmtLLL
block|,
name|ifmtLLL
block|,
name|ifmtL
block|,
name|ifmtLL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
literal|25
block|,
name|ifmtLL
block|,
name|ifmtLLL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
literal|13
block|,
literal|10
block|,
literal|11
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['J']*/
block|{
name|ifmtNil
block|,
literal|17
block|,
literal|19
block|,
literal|19
block|,
name|ifmtNil
block|,
literal|17
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|20
block|,
literal|17
block|,
literal|19
block|,
literal|19
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
literal|28
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['K']*/
block|{
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|7
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['L']*/
block|{
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtXhYh
block|,
name|ifmtXhYh
block|,
name|ifmtXhYh
block|,
name|ifmtLLL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|12
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
literal|17
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtXhYh
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['M']*/
block|{
literal|27
block|,
name|ifmtLL
block|,
name|ifmtLLL
block|,
name|ifmtLLLL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
literal|27
block|,
name|ifmtLLL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtLLL
block|}
block|,
comment|/*['N']*/
block|{
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtLL
block|,
name|ifmtL
block|,
literal|5
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtLL
block|,
literal|5
block|,
literal|5
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['O']*/
block|{
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtLL
block|,
name|ifmtL
block|,
name|ifmtLL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|6
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtLL
block|,
literal|6
block|,
name|ifmtNil
block|,
name|ifmtLLLL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtLL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['P']*/
block|{
literal|21
block|,
literal|22
block|,
literal|19
block|,
name|ifmtNil
block|,
literal|29
block|,
literal|30
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|22
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|18
block|,
literal|29
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|20
block|,
literal|17
block|,
literal|20
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['Q']*/
block|{
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtLLL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['R']*/
block|{
name|ifmtLLL
block|,
name|ifmtL
block|,
name|ifmtL
block|,
literal|5
block|,
name|ifmtL
block|,
name|ifmtL
block|,
literal|7
block|,
name|ifmtXhYh
block|,
literal|5
block|,
name|ifmtL
block|,
name|ifmtL
block|,
literal|5
block|,
name|ifmtNil
block|,
literal|5
block|,
name|ifmtNil
block|,
literal|26
block|,
literal|5
block|,
literal|14
block|,
literal|10
block|,
name|ifmtLLL
block|,
name|ifmtLLL
block|,
literal|10
block|,
literal|10
block|,
literal|15
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['S']*/
block|{
literal|8
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtLL
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtLLL
block|,
name|ifmtLL
block|,
literal|31
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
literal|6
block|,
name|ifmtLL
block|,
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtXhYh
block|,
literal|26
block|,
name|ifmtLL
block|,
name|ifmtLL
block|,
name|ifmtLL
block|,
name|ifmtNil
block|,
name|ifmtLL
block|,
name|ifmtNil
block|,
literal|11
block|,
name|ifmtNil
block|,
name|ifmtLL
block|}
block|,
comment|/*['T']*/
block|{
name|ifmtNil
block|,
name|ifmtLLL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|7
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtLLL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|,
comment|/*['U']*/
block|{
name|ifmtNil
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|16
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
name|ifmtNil
block|,
literal|10
block|,
name|ifmtL
block|,
name|ifmtNil
block|,
name|ifmtNil
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these strange numbers were arrived at by the following observations: */
end_comment

begin_comment
comment|/* Table 3-2 in spec gives the spacing values in mils */
end_comment

begin_comment
comment|/* Using "Point Spacing" section on page 3-26 we compute that there are */
end_comment

begin_comment
comment|/* approximately 286 points/inch on a 10.9 x 14.5 inch image area /* I rounded to "reasonable" 4096th's of an inch */
end_comment

begin_decl_stmt
name|private
name|int
name|rgdxhSpace
index|[
name|sycharMax
index|]
init|=
block|{
literal|56
block|,
literal|51
block|,
literal|34
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|rgdyhSpace
index|[
name|sycharMax
index|]
init|=
block|{
literal|90
block|,
literal|81
block|,
literal|53
block|,
literal|48
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|FILE
modifier|*
name|fpSrc
decl_stmt|,
modifier|*
name|fpPsDst
decl_stmt|,
modifier|*
name|fpDbg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|Params
name|params
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Outputs a conforming PostScript header to destination file */
end_comment

begin_function
name|private
name|CommentHeader
parameter_list|(
name|pparams
parameter_list|)
name|struct
name|Params
modifier|*
name|pparams
decl_stmt|;
block|{
name|long
name|clock
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pswd
decl_stmt|;
name|char
name|hostname
index|[
literal|40
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"%%!\n"
argument_list|)
expr_stmt|;
comment|/* no reversal */
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"%%%%Creator: "
argument_list|)
expr_stmt|;
name|pswd
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|VOIDC
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
name|hostname
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"%s:%s (%s)\n"
argument_list|,
name|hostname
argument_list|,
name|pswd
operator|->
name|pw_name
argument_list|,
name|pswd
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"%%%%Title: %s\n"
argument_list|,
operator|(
operator|(
name|pparams
operator|->
name|scSrcFile
operator|==
name|NULL
operator|)
condition|?
literal|"stdin"
else|:
name|pparams
operator|->
name|scSrcFile
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"%%%%CreationDate: %s"
argument_list|,
operator|(
name|VOIDC
name|time
argument_list|(
operator|&
name|clock
argument_list|)
operator|,
name|ctime
argument_list|(
operator|&
name|clock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Filter some input characters that are ignored under all(?) circumstances */
end_comment

begin_function
name|private
name|ChGet
parameter_list|(
name|psts
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|fpSrc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|chEsc
case|:
name|ch
operator|=
name|ChEscapeAction
argument_list|(
name|psts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|=
name|chDel
condition|)
return|return
operator|(
name|chDel
operator|)
return|;
else|else
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|chFs
case|:
name|FsAction
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|chGs
case|:
name|GsAction
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ch
operator|>=
name|chEsc
operator|)
operator|||
operator|(
name|ch
operator|==
name|EOF
operator|)
operator|||
operator|(
operator|(
name|ch
operator|>=
name|chBell
operator|)
operator|&&
operator|(
name|ch
operator|<
name|chSo
operator|)
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a 4110 31-bit integer parameter */
end_comment

begin_function
name|private
name|long
name|LongGet
parameter_list|(
name|psts
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
name|char
name|ch
decl_stmt|;
name|long
name|longT
decl_stmt|;
name|longT
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|ch
operator|=
name|ChGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintLongByte
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
name|chFstHiInt
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|chLstHiInt
operator|)
condition|)
name|longT
operator|=
name|longT
operator|*
literal|64
operator|+
operator|(
name|ch
operator|-
name|chFstHiInt
operator|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|(
name|ch
operator|>=
name|chFstLoPosInt
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|chLstLoPosInt
operator|)
condition|)
name|longT
operator|=
name|longT
operator|*
literal|16
operator|+
operator|(
name|ch
operator|-
name|chFstLoPosInt
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
name|chFstLoNegInt
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|chLstLoNegInt
operator|)
condition|)
name|longT
operator|=
operator|-
operator|(
name|longT
operator|*
literal|16
operator|+
operator|(
name|ch
operator|-
name|chFstLoNegInt
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error while parsing int, expecting low int char. ch = %d\n"
argument_list|,
name|prog
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|longT
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"long: %ld\n"
argument_list|,
name|longT
argument_list|)
expr_stmt|;
return|return
operator|(
name|longT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an array of 32-bit integers */
end_comment

begin_function
name|private
name|GetAryLong
parameter_list|(
name|psts
parameter_list|,
name|arylong
parameter_list|,
name|ilongMax
parameter_list|,
name|pilongMac
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|long
name|arylong
index|[]
decl_stmt|;
name|int
name|ilongMax
decl_stmt|,
decl|*
name|pilongMac
decl_stmt|;
end_function

begin_block
block|{
name|int
name|ilong
decl_stmt|,
name|ilongMac
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"AryLong - ilongMac = "
argument_list|)
expr_stmt|;
name|ilongMac
operator|=
name|LongGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
operator|*
name|pilongMac
operator|=
operator|(
name|ilongMac
operator|<
name|ilongMax
operator|)
condition|?
name|ilongMac
else|:
name|ilongMax
expr_stmt|;
for|for
control|(
name|ilong
operator|=
literal|0
init|;
name|ilong
operator|<
operator|*
name|pilongMac
condition|;
name|ilong
operator|++
control|)
name|arylong
index|[
name|ilong
index|]
operator|=
name|LongGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
for|for
control|(
name|ilong
operator|=
operator|*
name|pilongMac
init|;
name|ilong
operator|<
name|ilongMac
condition|;
name|ilong
operator|++
control|)
name|VOIDC
name|LongGet
parameter_list|(
name|psts
parameter_list|)
function_decl|;
block|}
end_block

begin_comment
comment|/* Parse a 4100-format string parameter */
end_comment

begin_function
name|private
name|GetString
parameter_list|(
name|psts
parameter_list|,
name|sc
parameter_list|,
name|ichMax
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|char
modifier|*
name|sc
decl_stmt|;
name|int
name|ichMax
decl_stmt|;
block|{
name|int
name|ich
decl_stmt|,
name|ichMac
decl_stmt|;
name|char
name|chT
decl_stmt|;
name|long
name|longT
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"String - length = "
argument_list|)
expr_stmt|;
name|longT
operator|=
name|LongGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|ichMac
operator|=
operator|(
name|longT
operator|<
name|ichMax
operator|-
literal|1
operator|)
condition|?
name|longT
else|:
name|ichMax
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ich
operator|=
literal|0
init|;
name|ich
operator|<
name|ichMac
condition|;
name|ich
operator|++
control|)
block|{
name|sc
index|[
name|ich
index|]
operator|=
name|ChGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|sc
index|[
name|ich
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
index|[
name|ichMac
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ich
operator|=
name|ichMac
init|;
name|ich
operator|<
name|longT
condition|;
name|ich
operator|++
control|)
block|{
name|chT
operator|=
name|ChGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|chT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* parse a 4110-format real parameter */
end_comment

begin_function
name|private
name|GetReal4110
parameter_list|(
name|psts
parameter_list|,
name|preal4110
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|struct
name|Real4110
modifier|*
name|preal4110
decl_stmt|;
block|{
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"Real4110: \n"
argument_list|)
expr_stmt|;
name|preal4110
operator|->
name|mantissa
operator|=
name|LongGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|preal4110
operator|->
name|exp
operator|=
name|LongGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* parse a 4014 xy-coordinate */
end_comment

begin_function
name|private
name|GetXhYh
parameter_list|(
name|ch
parameter_list|,
name|psts
parameter_list|,
name|pxh
parameter_list|,
name|pyh
parameter_list|)
name|char
name|ch
decl_stmt|;
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|int
modifier|*
name|pxh
decl_stmt|,
decl|*
name|pyh
decl_stmt|;
end_function

begin_block
block|{
name|char
name|chNxt
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
name|chFstCoord
operator|)
operator|&&
operator|(
name|ch
operator|<
name|chFstLoX
operator|)
condition|)
block|{
comment|/* it is a High Y */
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintAdrByte
argument_list|(
name|ch
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|psts
operator|->
name|chHiY
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|ChGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|>=
name|chFstLoY
condition|)
block|{
name|chNxt
operator|=
name|ChGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* psts->fHiRes&& */
operator|(
name|chNxt
operator|>=
name|chFstLoY
operator|)
condition|)
block|{
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintAdrByte
argument_list|(
name|ch
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|psts
operator|->
name|chExtra
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|chNxt
expr_stmt|;
name|chNxt
operator|=
name|ChGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintAdrByte
argument_list|(
name|ch
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|psts
operator|->
name|chLoY
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|chNxt
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|>=
name|chFstCoord
operator|)
operator|&&
operator|(
name|ch
operator|<
name|chFstLoX
operator|)
condition|)
block|{
comment|/* it is a High X */
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintAdrByte
argument_list|(
name|ch
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|psts
operator|->
name|chHiX
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|ChGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|<
name|chFstLoX
operator|)
operator|||
operator|(
name|ch
operator|>=
name|chFstLoY
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Expecting Lo X Coordinate.  ch = %d\n"
argument_list|,
name|prog
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"Error: Expecting Lo X Coordinate.  ch = %d\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|chFstLoX
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintAdrByte
argument_list|(
name|ch
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|pyh
operator|=
operator|(
operator|(
name|psts
operator|->
name|chHiY
operator|-
name|chFstCoord
operator|)
operator|<<
name|shiftHiByte
operator|)
operator||
operator|(
operator|(
name|psts
operator|->
name|chExtra
operator|>>
name|shiftYExtra
operator|)
operator|&
name|mskLoBits
operator|)
operator||
operator|(
operator|(
name|psts
operator|->
name|chLoY
operator|-
name|chFstLoY
operator|)
operator|<<
name|shiftLoByte
operator|)
expr_stmt|;
operator|*
name|pxh
operator|=
operator|(
operator|(
name|psts
operator|->
name|chHiX
operator|-
name|chFstCoord
operator|)
operator|<<
name|shiftHiByte
operator|)
operator||
operator|(
name|psts
operator|->
name|chExtra
operator|&
name|mskLoBits
operator|)
operator||
operator|(
operator|(
name|ch
operator|-
name|chFstLoX
operator|)
operator|<<
name|shiftLoByte
operator|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"*pxh: %d or 0X%x, *pyh: %d or 0X%x\n"
argument_list|,
operator|*
name|pxh
argument_list|,
operator|*
name|pxh
argument_list|,
operator|*
name|pyh
argument_list|,
operator|*
name|pyh
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* parse an array of xy-coordinates */
end_comment

begin_function
name|private
name|GetAryXhYh
parameter_list|(
name|psts
parameter_list|,
name|aryxh
parameter_list|,
name|aryyh
parameter_list|,
name|iMax
parameter_list|,
name|piMac
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|int
modifier|*
name|aryxh
decl_stmt|,
decl|*
name|aryyh
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|iMax
decl_stmt|,
modifier|*
name|piMac
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|iMac
decl_stmt|,
name|xhT
decl_stmt|,
name|yhT
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"AryXyYh - length = "
argument_list|)
expr_stmt|;
name|iMac
operator|=
name|LongGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
operator|*
name|piMac
operator|=
operator|(
name|iMac
operator|<
name|iMax
operator|)
condition|?
name|iMac
else|:
name|iMax
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|piMac
condition|;
name|i
operator|++
control|)
name|GetXhYh
argument_list|(
name|ChGet
argument_list|(
name|psts
argument_list|)
argument_list|,
name|psts
argument_list|,
operator|&
name|aryxh
index|[
name|i
index|]
argument_list|,
operator|&
name|aryyh
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|piMac
init|;
name|i
operator|<
name|iMac
condition|;
name|i
operator|++
control|)
name|GetXhYh
argument_list|(
name|ChGet
argument_list|(
name|psts
argument_list|)
argument_list|,
name|psts
argument_list|,
operator|&
name|xhT
argument_list|,
operator|&
name|yhT
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|scMoveTo
value|"%d %d m\n"
end_define

begin_comment
comment|/* char	*rgscMoveCmd[tymoveMax] = 	    { "", 	    "%d ml\n", 	    "%d mr\n", 	    "%d mu\n", 	    "%d md\n", 	    "%d md\n", 	    "" 	    }; */
end_comment

begin_comment
comment|/* Process a line-feed from the 4014 file:    Update the current position in the Sts - do NOT output any PostScript.    All PostScript marking commands move issue moveto commands     whenever necessary */
end_comment

begin_function
name|private
name|MoveDown
parameter_list|(
name|psts
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
name|int
name|xhLeftNew
decl_stmt|;
name|psts
operator|->
name|yh
operator|-=
name|rgdyhSpace
index|[
name|psts
operator|->
name|sychar
index|]
expr_stmt|;
if|if
condition|(
name|psts
operator|->
name|yh
operator|<
literal|0
condition|)
block|{
name|psts
operator|->
name|yh
operator|=
name|yhHome
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fMarg2
condition|)
block|{
name|xhLeftNew
operator|=
operator|(
name|psts
operator|->
name|xhLeftMarg
operator|==
name|xhMarg1
operator|)
condition|?
name|xhMarg2
else|:
name|xhMarg1
expr_stmt|;
name|psts
operator|->
name|xh
operator|=
name|xhLeftNew
operator|+
operator|(
name|psts
operator|->
name|xh
operator|-
name|psts
operator|->
name|xhLeftMarg
operator|)
expr_stmt|;
name|psts
operator|->
name|xhLeftMarg
operator|=
name|xhLeftNew
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Move the current position.  No PostScript move commands are emitted.    PostScript marking commands (i.e. stroke) issue moveto's when needed */
end_comment

begin_function
name|private
name|MovePos
parameter_list|(
name|psts
parameter_list|,
name|tymove
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|short
name|tymove
decl_stmt|;
block|{
comment|/* char *scMoveCmd; #define scXMarg1 "%d cr1\n" #define scXMarg2 "cr2\n"  if (psts->fMovePending)     fprintf(fpPsDst, scMoveTo, psts->xh, psts->yh); psts->fMovePending = FALSE; */
switch|switch
condition|(
name|tymove
condition|)
block|{
case|case
name|tymoveNil
case|:
return|return;
case|case
name|tymoveLeft
case|:
name|psts
operator|->
name|xh
operator|-=
name|rgdxhSpace
index|[
name|psts
operator|->
name|sychar
index|]
expr_stmt|;
if|if
condition|(
name|psts
operator|->
name|xh
operator|<
name|psts
operator|->
name|xhLeftMarg
condition|)
name|psts
operator|->
name|xh
operator|=
name|psts
operator|->
name|xhLeftMarg
expr_stmt|;
comment|/*        fprintf(fpPsDst, rgscMoveCmd[tymove], psts->sychar); */
break|break;
case|case
name|tymoveRt
case|:
name|psts
operator|->
name|xh
operator|+=
name|rgdxhSpace
index|[
name|psts
operator|->
name|sychar
index|]
expr_stmt|;
if|if
condition|(
name|psts
operator|->
name|xh
operator|>
name|xhMax
condition|)
block|{
name|MoveDown
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|xh
operator|=
name|psts
operator|->
name|xhLeftMarg
expr_stmt|;
block|}
comment|/*        fprintf(fpPsDst, rgscMoveCmd[tymove], psts->sychar); */
break|break;
case|case
name|tymoveUp
case|:
name|psts
operator|->
name|yh
operator|+=
name|rgdyhSpace
index|[
name|psts
operator|->
name|sychar
index|]
expr_stmt|;
comment|/*        fprintf(fpPsDst, rgscMoveCmd[tymove], psts->sychar); */
break|break;
case|case
name|tymoveGDown
case|:
case|case
name|tymoveDown
case|:
name|MoveDown
argument_list|(
name|psts
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fLfGenCr
condition|)
name|psts
operator|->
name|xh
operator|=
name|psts
operator|->
name|xhLeftMarg
expr_stmt|;
comment|/*         if (params.fLfGenCr)              { fprintf(fpPsDst, scXMarg1, psts->sychar);              psts->xh = xhLeftMarg; 	     }         else fprintf(fpPsDst, rgscMoveCmd[tymove], psts->sychar); */
break|break;
case|case
name|tymoveXMarg
case|:
if|if
condition|(
name|params
operator|.
name|fCrGenLf
condition|)
name|MoveDown
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|xh
operator|=
name|psts
operator|->
name|xhLeftMarg
expr_stmt|;
comment|/*         if (params.fCrGenLf)              { fprintf(fpPsDst, scXMarg1, psts->sychar);              psts->yh -= rgdyhSpace[psts->sychar]; 	     }         else fprintf(fpPsDst, scXMarg2); */
break|break;
block|}
name|psts
operator|->
name|fMovePending
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process form feed */
end_comment

begin_function
name|private
name|EraseAndHome
parameter_list|()
block|{
define|#
directive|define
name|scEraseAndHome
value|"erasepage\nxHome yHome m\n"
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
name|scEraseAndHome
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process Etb character */
end_comment

begin_function
name|private
name|MakeCopy
parameter_list|()
block|{
define|#
directive|define
name|scMakeCopy
value|"showpage\n"
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
name|scMakeCopy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a movement/drawing command in on of the graphics modes */
end_comment

begin_function
name|private
name|VectorGoTo
parameter_list|(
name|psts
parameter_list|,
name|xhNew
parameter_list|,
name|yhNew
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|int
name|xhNew
decl_stmt|,
name|yhNew
decl_stmt|;
block|{
define|#
directive|define
name|scLineTo
value|"%d %d rl\n"
if|if
condition|(
name|psts
operator|->
name|fPenDown
condition|)
block|{
if|if
condition|(
name|psts
operator|->
name|syline
operator|!=
name|psts
operator|->
name|sylinePrt
condition|)
block|{
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"%d SetLineStyle\n"
argument_list|,
name|psts
operator|->
name|syline
argument_list|)
expr_stmt|;
name|psts
operator|->
name|sylinePrt
operator|=
name|psts
operator|->
name|syline
expr_stmt|;
block|}
if|if
condition|(
name|psts
operator|->
name|md
operator|==
name|mdVector
condition|)
block|{
if|if
condition|(
name|psts
operator|->
name|fMovePending
condition|)
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
name|scMoveTo
argument_list|,
name|psts
operator|->
name|xh
argument_list|,
name|psts
operator|->
name|yh
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
name|scLineTo
argument_list|,
name|xhNew
operator|-
name|psts
operator|->
name|xh
argument_list|,
name|yhNew
operator|-
name|psts
operator|->
name|yh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* md = mdPtPlot */
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
name|scMoveTo
argument_list|,
name|xhNew
argument_list|,
name|yhNew
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
name|scLineTo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|psts
operator|->
name|fVectorDrawn
operator|=
name|TRUE
expr_stmt|;
block|}
name|psts
operator|->
name|fMovePending
operator|=
operator|(
operator|!
name|psts
operator|->
name|fPenDown
operator|)
expr_stmt|;
name|psts
operator|->
name|xh
operator|=
name|xhNew
expr_stmt|;
name|psts
operator|->
name|yh
operator|=
name|yhNew
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a stoke command if there are any vector's pending */
end_comment

begin_function
name|private
name|Stroke
parameter_list|(
name|psts
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
if|if
condition|(
name|psts
operator|->
name|fVectorDrawn
operator|&&
name|psts
operator|->
name|fPenDown
condition|)
block|{
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"s\n"
argument_list|)
expr_stmt|;
name|psts
operator|->
name|fVectorDrawn
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a show command */
end_comment

begin_function
name|private
name|EmitShow
parameter_list|(
name|psts
parameter_list|,
name|scShow
parameter_list|,
name|ichFst
parameter_list|,
name|ichLim
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|char
name|scShow
index|[]
decl_stmt|;
name|int
name|ichFst
decl_stmt|,
name|ichLim
decl_stmt|;
block|{
name|int
name|ich
decl_stmt|;
if|if
condition|(
name|psts
operator|->
name|fMovePending
condition|)
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
name|scMoveTo
argument_list|,
name|psts
operator|->
name|xh
argument_list|,
name|psts
operator|->
name|yh
argument_list|)
expr_stmt|;
name|psts
operator|->
name|fMovePending
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|psts
operator|->
name|sychar
operator|!=
name|psts
operator|->
name|sycharPrt
condition|)
block|{
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"%d SetCharStyle\n"
argument_list|,
name|psts
operator|->
name|sychar
argument_list|)
expr_stmt|;
name|psts
operator|->
name|sycharPrt
operator|=
name|psts
operator|->
name|sychar
expr_stmt|;
block|}
if|if
condition|(
name|ichFst
operator|<
name|ichLim
condition|)
block|{
name|putc
argument_list|(
literal|'\('
argument_list|,
name|fpPsDst
argument_list|)
expr_stmt|;
for|for
control|(
name|ich
operator|=
name|ichFst
init|;
name|ich
operator|<
name|ichLim
condition|;
name|ich
operator|++
control|)
name|putc
argument_list|(
name|scShow
index|[
name|ich
index|]
argument_list|,
name|fpPsDst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|")sh\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a string of characters to PostScript file.  Deal with    line overflow and special character '\' */
end_comment

begin_function
name|private
name|Show
parameter_list|(
name|psts
parameter_list|,
name|scShow
parameter_list|,
name|cchShow
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|char
name|scShow
index|[]
decl_stmt|;
name|int
name|cchShow
decl_stmt|;
block|{
name|int
name|ichFst
decl_stmt|,
name|ich
decl_stmt|;
name|int
name|xh
decl_stmt|,
name|dxhSpace
decl_stmt|;
name|scShow
index|[
name|cchShow
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dxhSpace
operator|=
name|rgdxhSpace
index|[
name|psts
operator|->
name|sychar
index|]
expr_stmt|;
name|ichFst
operator|=
name|ich
operator|=
literal|0
expr_stmt|;
name|xh
operator|=
name|psts
operator|->
name|xh
expr_stmt|;
while|while
condition|(
name|ich
operator|<
name|cchShow
condition|)
block|{
if|if
condition|(
name|scShow
index|[
name|ich
index|]
operator|==
literal|'\\'
condition|)
name|ich
operator|++
expr_stmt|;
name|xh
operator|+=
name|dxhSpace
expr_stmt|;
if|if
condition|(
name|xh
operator|>=
name|xhMax
condition|)
block|{
name|EmitShow
argument_list|(
name|psts
argument_list|,
name|scShow
argument_list|,
name|ichFst
argument_list|,
name|ich
argument_list|)
expr_stmt|;
name|ichFst
operator|=
name|ich
expr_stmt|;
name|MoveDown
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|xh
operator|=
name|psts
operator|->
name|xh
operator|=
name|psts
operator|->
name|xhLeftMarg
expr_stmt|;
name|psts
operator|->
name|fMovePending
operator|=
name|TRUE
expr_stmt|;
block|}
name|ich
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"Show(%s)\n"
argument_list|,
name|scShow
argument_list|)
expr_stmt|;
name|EmitShow
argument_list|(
name|psts
argument_list|,
name|scShow
argument_list|,
name|ichFst
argument_list|,
name|cchShow
argument_list|)
expr_stmt|;
name|psts
operator|->
name|xh
operator|=
name|xh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the<Fs> character */
end_comment

begin_function
name|private
name|FsAction
parameter_list|(
name|psts
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|chFs
argument_list|)
expr_stmt|;
name|Stroke
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdPtPlot
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the Graphic Shift character */
end_comment

begin_function
name|private
name|GsAction
parameter_list|(
name|psts
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|chGs
argument_list|)
expr_stmt|;
name|Stroke
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|fPenDown
operator|=
name|FALSE
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdVector
expr_stmt|;
name|psts
operator|->
name|syline
operator|=
name|sylineNormal
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a sequence beginning with an Escape character.  Return    the character following the Escape or the Del character if the    escape sequence is<Esc>? */
end_comment

begin_function
name|private
name|ChEscapeAction
parameter_list|(
name|psts
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|short
name|sylineT
decl_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|fpSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintEscCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|chEnq
case|:
name|Stroke
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdBypass
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chBell
case|:
name|psts
operator|->
name|fPenDown
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chBs
case|:
name|MovePos
argument_list|(
name|psts
argument_list|,
name|tymoveLeft
argument_list|)
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chTab
case|:
name|MovePos
argument_list|(
name|psts
argument_list|,
name|tymoveRt
argument_list|)
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chVTab
case|:
name|MovePos
argument_list|(
name|psts
argument_list|,
name|tymoveUp
argument_list|)
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chFf
case|:
name|EraseAndHome
argument_list|()
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chSo
case|:
name|psts
operator|->
name|charset
operator|=
name|charsetAlt
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chSi
case|:
name|psts
operator|->
name|charset
operator|=
name|charsetStd
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chEtb
case|:
name|Stroke
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|MakeCopy
argument_list|()
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chCan
case|:
name|Stroke
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdBypass
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chSub
case|:
name|Stroke
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdBypass
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chFs
case|:
name|Stroke
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdSpecPtPlot
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chGs
case|:
name|GsAction
argument_list|(
name|psts
argument_list|)
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chRs
case|:
name|Stroke
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdIncrPtPlot
expr_stmt|;
name|psts
operator|->
name|dir
operator|=
name|dirNil
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
name|chUs
case|:
name|Stroke
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdAlpha
expr_stmt|;
goto|goto
name|Done
goto|;
case|case
literal|'?'
case|:
name|ch
operator|=
name|chDel
expr_stmt|;
goto|goto
name|Done
goto|;
default|default:
if|if
condition|(
operator|(
name|ch
operator|>=
name|chFstSychar
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|chLstSychar
operator|)
condition|)
block|{
name|psts
operator|->
name|sychar
operator|=
operator|(
name|ch
operator|-
name|chFstSychar
operator|)
expr_stmt|;
goto|goto
name|Done
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
name|chFstSyline
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|chLstSyline
operator|)
condition|)
block|{
name|sylineT
operator|=
operator|(
operator|(
name|ch
operator|-
name|chFstSyline
operator|)
operator|&
name|mskSyline
operator|)
expr_stmt|;
if|if
condition|(
name|sylineT
operator|<
name|sylineMax
condition|)
name|psts
operator|->
name|syline
operator|=
name|sylineT
expr_stmt|;
else|else
name|psts
operator|->
name|syline
operator|=
name|sylineNormal
expr_stmt|;
comment|/* What about Defocused? */
goto|goto
name|Done
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|>=
name|chFst4110
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|chLst4110
operator|)
condition|)
block|{
name|Skip4110
argument_list|(
name|ch
argument_list|,
name|psts
argument_list|)
expr_stmt|;
goto|goto
name|Done
goto|;
block|}
break|break;
block|}
name|ch
operator|=
name|getc
argument_list|(
name|fpSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|Done
label|:
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCr
argument_list|()
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process some characters in one of the vector modes */
end_comment

begin_function
name|private
name|VectorAction
parameter_list|(
name|ch
parameter_list|,
name|psts
parameter_list|)
name|char
name|ch
decl_stmt|;
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
name|int
name|xhNew
decl_stmt|,
name|yhNew
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
name|chFstCoord
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|chLstCoord
operator|)
condition|)
block|{
if|if
condition|(
name|psts
operator|->
name|md
operator|==
name|mdIncrPtPlot
condition|)
name|IncrPtPlotAction
argument_list|(
name|ch
argument_list|,
name|psts
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|psts
operator|->
name|md
operator|!=
name|mdVector
operator|)
operator|&&
operator|(
name|psts
operator|->
name|md
operator|!=
name|mdPtPlot
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unimplemented vector mode: %d\n"
argument_list|,
name|prog
argument_list|,
name|psts
operator|->
name|md
argument_list|)
expr_stmt|;
name|GetXhYh
argument_list|(
name|ch
argument_list|,
name|psts
argument_list|,
operator|&
name|xhNew
argument_list|,
operator|&
name|yhNew
argument_list|)
expr_stmt|;
name|VectorGoTo
argument_list|(
name|psts
argument_list|,
name|xhNew
argument_list|,
name|yhNew
argument_list|)
expr_stmt|;
name|psts
operator|->
name|fPenDown
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|chLf
case|:
name|MovePos
argument_list|(
name|psts
argument_list|,
name|tymoveGDown
argument_list|)
expr_stmt|;
break|break;
case|case
name|chCr
case|:
if|if
condition|(
name|psts
operator|->
name|fVectorDrawn
condition|)
name|MovePos
argument_list|(
name|psts
argument_list|,
name|tymoveXMarg
argument_list|)
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdAlpha
expr_stmt|;
break|break;
case|case
name|chUs
case|:
name|psts
operator|->
name|md
operator|=
name|mdAlpha
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Finish processing a sequence of characters in Incremental    Point Plot Mode by issuing an appropriate VectorGoTo */
end_comment

begin_function
name|private
name|DoIncrPtPlot
parameter_list|(
name|psts
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
name|int
name|xhNew
decl_stmt|;
name|int
name|yhNew
decl_stmt|;
name|xhNew
operator|=
name|psts
operator|->
name|xh
expr_stmt|;
name|yhNew
operator|=
name|psts
operator|->
name|yh
expr_stmt|;
if|if
condition|(
name|psts
operator|->
name|dir
operator|&
name|mskDirUp
condition|)
name|yhNew
operator|+=
name|psts
operator|->
name|cincr
expr_stmt|;
elseif|else
if|if
condition|(
name|psts
operator|->
name|dir
operator|&
name|mskDirDown
condition|)
name|yhNew
operator|-=
name|psts
operator|->
name|cincr
expr_stmt|;
if|if
condition|(
name|psts
operator|->
name|dir
operator|&
name|mskDirLeft
condition|)
name|xhNew
operator|-=
name|psts
operator|->
name|cincr
expr_stmt|;
elseif|else
if|if
condition|(
name|psts
operator|->
name|dir
operator|&
name|mskDirRt
condition|)
name|xhNew
operator|+=
name|psts
operator|->
name|cincr
expr_stmt|;
name|VectorGoTo
argument_list|(
name|psts
argument_list|,
name|xhNew
argument_list|,
name|yhNew
argument_list|)
expr_stmt|;
name|psts
operator|->
name|cincr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a character in Incremental Point Plot Mode */
end_comment

begin_function
name|private
name|IncrPtPlotAction
parameter_list|(
name|ch
parameter_list|,
name|psts
parameter_list|)
name|char
name|ch
decl_stmt|;
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
name|short
name|fPenDown
decl_stmt|;
name|short
name|dir
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|fPenDown
operator|=
name|psts
operator|->
name|fPenDown
expr_stmt|;
name|dir
operator|=
name|psts
operator|->
name|dir
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|chSp
condition|)
name|fPenDown
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'P'
condition|)
name|fPenDown
operator|=
name|TRUE
expr_stmt|;
else|else
name|dir
operator|=
operator|(
name|ch
operator|&
name|mskDir
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|psts
operator|->
name|dir
operator|==
name|dir
operator|)
operator|&&
operator|(
name|psts
operator|->
name|fPenDown
operator|==
name|fPenDown
operator|)
operator|&&
operator|(
name|psts
operator|->
name|dir
operator|!=
name|dirNil
operator|)
condition|)
name|psts
operator|->
name|cincr
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|psts
operator|->
name|dir
operator|!=
name|dirNil
condition|)
name|DoIncrPtPlot
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|psts
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|psts
operator|->
name|cincr
operator|=
literal|1
expr_stmt|;
name|psts
operator|->
name|fPenDown
operator|=
name|fPenDown
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a character in bypass mode */
end_comment

begin_function
name|private
name|BypassAction
parameter_list|(
name|ch
parameter_list|,
name|psts
parameter_list|)
name|char
name|ch
decl_stmt|;
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
block|{
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|chLf
case|:
name|MovePos
argument_list|(
name|psts
argument_list|,
name|tymoveGDown
argument_list|)
expr_stmt|;
break|break;
case|case
name|chCr
case|:
name|MovePos
argument_list|(
name|psts
argument_list|,
name|tymoveXMarg
argument_list|)
expr_stmt|;
name|psts
operator|->
name|md
operator|=
name|mdAlpha
expr_stmt|;
break|break;
case|case
name|chUs
case|:
name|psts
operator|->
name|md
operator|=
name|mdAlpha
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Some debug print routines and data */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|rgsc
index|[
literal|0x21
index|]
init|=
block|{
literal|"<Null>"
block|,
literal|"<Soh>"
block|,
literal|"<Stx>"
block|,
literal|"<Etx>"
block|,
literal|"<Eot>"
block|,
literal|"<Enq>"
block|,
literal|"<Ack>"
block|,
literal|"<Bell>"
block|,
literal|"<Bs>"
block|,
literal|"<Tab>"
block|,
literal|"<Lf>"
block|,
literal|"<VTab>"
block|,
literal|"<Ff>"
block|,
literal|"<Cr>"
block|,
literal|"<So>"
block|,
literal|"<Si>"
block|,
literal|"<Dle>"
block|,
literal|"<Dcl>"
block|,
literal|"<Dc2>"
block|,
literal|"<Dc3>"
block|,
literal|"<Dc4>"
block|,
literal|"<Nak>"
block|,
literal|"<Syn>"
block|,
literal|"<Etb>"
block|,
literal|"<Can>"
block|,
literal|"<Em>"
block|,
literal|"<Sub>"
block|,
literal|"<Esc>"
block|,
literal|"<Fs>"
block|,
literal|"<Gs>"
block|,
literal|"<Rs>"
block|,
literal|"<Us>"
block|,
literal|"<Sp>"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Concatenate a human-readable form of a character code to    the supplied string */
end_comment

begin_function
name|private
name|CatChName
parameter_list|(
name|ch
parameter_list|,
name|scDst
parameter_list|)
name|char
name|ch
decl_stmt|;
name|char
name|scDst
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|sc
decl_stmt|;
name|char
name|scT
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0x21
condition|)
name|sc
operator|=
name|rgsc
index|[
name|ch
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|chDel
condition|)
name|sc
operator|=
literal|"<Del>"
expr_stmt|;
else|else
block|{
name|scT
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|scT
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sc
operator|=
name|scT
expr_stmt|;
block|}
name|VOIDC
name|strcat
argument_list|(
name|scDst
argument_list|,
name|sc
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/* Output a line of test output for the given command character */
end_comment

begin_function
name|private
name|PrintCmd
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
name|char
name|scPrint
index|[
literal|100
index|]
decl_stmt|;
name|scPrint
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|CatChName
argument_list|(
name|ch
argument_list|,
name|scPrint
argument_list|)
expr_stmt|;
name|VOIDC
name|strcat
argument_list|(
name|scPrint
argument_list|,
literal|"\n"
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
name|scPrint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a line of test output for and Escape command */
end_comment

begin_function
name|private
name|PrintEscCmd
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
name|char
name|scPrint
index|[
literal|100
index|]
decl_stmt|;
name|VOIDC
name|strcpy
argument_list|(
name|scPrint
argument_list|,
literal|"<Esc> "
argument_list|)
decl_stmt|;
name|CatChName
argument_list|(
name|ch
argument_list|,
name|scPrint
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
name|scPrint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print some diagnostic info on a vector-mode address byte */
end_comment

begin_function
name|private
name|PrintAdrByte
parameter_list|(
name|ch
parameter_list|,
name|fHiY
parameter_list|,
name|fExtra
parameter_list|)
name|char
name|ch
decl_stmt|;
name|char
name|fHiY
decl_stmt|,
name|fExtra
decl_stmt|;
block|{
if|if
condition|(
name|ch
operator|<
name|chFstCoord
condition|)
block|{
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"Bad Vector Command"
argument_list|)
expr_stmt|;
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
name|chFstLoX
condition|)
block|{
if|if
condition|(
name|fHiY
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"yHi: %x    "
argument_list|,
name|ch
operator|-
name|chFstCoord
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"xHi: %x    "
argument_list|,
name|ch
operator|-
name|chFstCoord
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
name|chFstLoY
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"xLo: %x\n"
argument_list|,
name|ch
operator|-
name|chFstLoX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|<=
name|chLstCoord
condition|)
block|{
if|if
condition|(
name|fExtra
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"x12: %x    y12: %x   margin bit: %s "
argument_list|,
name|ch
operator|&
name|mskLoBits
argument_list|,
operator|(
name|ch
operator|>>
name|shiftYExtra
operator|)
operator|&
name|mskLoBits
argument_list|,
operator|(
name|ch
operator|&
name|mskBit4
operator|)
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"yLo: %x    "
argument_list|,
name|ch
operator|-
name|chFstLoY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"Bad Vector Command"
argument_list|)
expr_stmt|;
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print some diagnostic info on a 32-bit integer parameter byte */
end_comment

begin_function
name|private
name|PrintLongByte
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|ch
operator|<
name|chFstLoNegInt
condition|)
block|{
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"Bad Integer Command"
argument_list|)
expr_stmt|;
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
name|chFstLoPosInt
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"iLoNeg: (-) %x, "
argument_list|,
name|ch
operator|-
name|chFstLoNegInt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|<
name|chFstHiInt
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"iLoPos: %x, "
argument_list|,
name|ch
operator|-
name|chFstLoPosInt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|<=
name|chLstHiInt
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"iHi: %x, "
argument_list|,
name|ch
operator|-
name|chFstHiInt
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"Bad Vector Command"
argument_list|)
expr_stmt|;
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|PrintCr
parameter_list|()
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fpDbg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 4110 Command Scanner */
end_comment

begin_function
name|private
name|Skip4110
parameter_list|(
name|ch
parameter_list|,
name|psts
parameter_list|)
name|struct
name|Sts
modifier|*
name|psts
decl_stmt|;
name|char
name|ch
decl_stmt|;
block|{
name|char
name|chNxt
decl_stmt|;
name|int
name|ifmt
decl_stmt|,
name|i
decl_stmt|,
name|iprm
decl_stmt|,
name|xh
decl_stmt|,
name|yh
decl_stmt|;
name|char
modifier|*
name|pfmt
decl_stmt|;
name|long
name|longT
decl_stmt|;
define|#
directive|define
name|ichScMax
value|32
name|char
name|sc
index|[
name|ichScMax
index|]
decl_stmt|;
name|struct
name|Real4110
name|realT
decl_stmt|;
name|chNxt
operator|=
name|ChGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
block|{
name|PrintCmd
argument_list|(
name|chNxt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|<
name|chFst4110
operator|)
operator|||
operator|(
name|ch
operator|>
name|chLst4110
operator|)
operator|||
operator|(
name|chNxt
operator|<
name|chFstEsc2
operator|)
operator|||
operator|(
name|chNxt
operator|>
name|chLstEsc2
operator|)
condition|)
block|{
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|fprintf
argument_list|(
name|fpDbg
argument_list|,
literal|"Bad 4110 command: %c%c\n"
argument_list|,
name|ch
argument_list|,
name|chNxt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Bad 4110 command: %c%c\n"
argument_list|,
name|prog
argument_list|,
name|ch
argument_list|,
name|chNxt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ch
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|chNxt
operator|==
literal|'I'
operator|)
condition|)
block|{
comment|/* this one command takes five parameters  				*/
name|longT
operator|=
name|LongGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
name|GetReal4110
argument_list|(
name|psts
argument_list|,
operator|&
name|realT
argument_list|)
expr_stmt|;
name|GetReal4110
argument_list|(
name|psts
argument_list|,
operator|&
name|realT
argument_list|)
expr_stmt|;
name|GetReal4110
argument_list|(
name|psts
argument_list|,
operator|&
name|realT
argument_list|)
expr_stmt|;
name|GetXhYh
argument_list|(
name|ChGet
argument_list|(
name|psts
argument_list|)
argument_list|,
name|psts
argument_list|,
operator|&
name|xh
argument_list|,
operator|&
name|yh
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmt
operator|=
name|aryaryifmt
index|[
name|ch
operator|-
name|chFst4110
index|]
index|[
name|chNxt
operator|-
name|chFstEsc2
index|]
expr_stmt|;
name|pfmt
operator|=
name|aryfmt
index|[
name|ifmt
index|]
expr_stmt|;
for|for
control|(
name|iprm
operator|=
literal|0
init|;
name|iprm
operator|<
name|iprmMax
condition|;
name|iprm
operator|++
control|)
block|{
switch|switch
condition|(
name|pfmt
index|[
name|iprm
index|]
condition|)
block|{
case|case
name|typrmNil
case|:
goto|goto
name|Exit
goto|;
case|case
name|typrmLong
case|:
name|longT
operator|=
name|LongGet
argument_list|(
name|psts
argument_list|)
expr_stmt|;
break|break;
case|case
name|typrmAryLong
case|:
name|GetAryLong
argument_list|(
name|psts
argument_list|,
operator|&
name|longT
argument_list|,
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|typrmXhYh
case|:
name|GetXhYh
argument_list|(
name|ChGet
argument_list|(
name|psts
argument_list|)
argument_list|,
name|psts
argument_list|,
operator|&
name|xh
argument_list|,
operator|&
name|yh
argument_list|)
expr_stmt|;
break|break;
case|case
name|typrmAryXhYh
case|:
name|GetAryXhYh
argument_list|(
name|psts
argument_list|,
operator|&
name|xh
argument_list|,
operator|&
name|yh
argument_list|,
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|typrmString
case|:
name|GetString
argument_list|(
name|psts
argument_list|,
name|sc
argument_list|,
name|ichScMax
argument_list|)
expr_stmt|;
break|break;
case|case
name|typrmReal4110
case|:
name|GetReal4110
argument_list|(
name|psts
argument_list|,
operator|&
name|realT
argument_list|)
expr_stmt|;
break|break;
case|case
name|typrmCh
case|:
name|VOIDC
name|ChGet
argument_list|(
name|psts
argument_list|)
decl_stmt|;
break|break;
block|}
block|}
name|Exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/* 4104 Parser */
end_comment

begin_function
name|private
name|Convert4014
parameter_list|()
block|{
name|struct
name|Sts
name|stsCur
decl_stmt|;
define|#
directive|define
name|chLim
value|0x80
name|short
name|rgtymove
index|[
name|chLim
index|]
decl_stmt|;
name|short
name|tymoveT
decl_stmt|;
name|int
name|ch
decl_stmt|;
define|#
directive|define
name|ichShowMax
value|500
name|char
name|scShow
index|[
name|ichShowMax
index|]
decl_stmt|;
name|int
name|ichShowCur
decl_stmt|;
name|int
name|chT
decl_stmt|;
name|ichShowCur
operator|=
literal|0
expr_stmt|;
name|stsCur
operator|.
name|md
operator|=
name|mdAlpha
expr_stmt|;
name|stsCur
operator|.
name|xh
operator|=
name|xhHome
expr_stmt|;
name|stsCur
operator|.
name|xhLeftMarg
operator|=
name|xhHome
expr_stmt|;
name|stsCur
operator|.
name|yh
operator|=
name|yhHome
expr_stmt|;
name|stsCur
operator|.
name|syline
operator|=
name|stsCur
operator|.
name|sylinePrt
operator|=
name|sylineNormal
expr_stmt|;
name|stsCur
operator|.
name|sychar
operator|=
name|stsCur
operator|.
name|sycharPrt
operator|=
name|sycharLarge
expr_stmt|;
name|stsCur
operator|.
name|charset
operator|=
name|stsCur
operator|.
name|charsetPrt
operator|=
name|charsetStd
expr_stmt|;
name|stsCur
operator|.
name|fPenDown
operator|=
name|FALSE
expr_stmt|;
name|stsCur
operator|.
name|fMovePending
operator|=
name|FALSE
expr_stmt|;
name|stsCur
operator|.
name|fVectorDrawn
operator|=
name|FALSE
expr_stmt|;
name|stsCur
operator|.
name|cincr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|chT
operator|=
literal|0
init|;
name|chT
operator|<
name|chLim
condition|;
name|chT
operator|++
control|)
name|rgtymove
index|[
name|chT
index|]
operator|=
name|tymoveNil
expr_stmt|;
name|rgtymove
index|[
name|chBs
index|]
operator|=
name|tymoveLeft
expr_stmt|;
name|rgtymove
index|[
name|chTab
index|]
operator|=
name|tymoveRt
expr_stmt|;
name|rgtymove
index|[
name|chLf
index|]
operator|=
name|tymoveDown
expr_stmt|;
name|rgtymove
index|[
name|chVTab
index|]
operator|=
name|tymoveUp
expr_stmt|;
name|rgtymove
index|[
name|chCr
index|]
operator|=
name|tymoveXMarg
expr_stmt|;
name|rgtymove
index|[
name|chSp
index|]
operator|=
name|tymoveRt
expr_stmt|;
name|VOIDC
name|setjmp
argument_list|(
name|env
argument_list|)
decl_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|fpSrc
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|stsCur
operator|.
name|md
operator|!=
name|mdIncrPtPlot
operator|)
operator|&&
operator|(
name|stsCur
operator|.
name|cincr
operator|!=
literal|0
operator|)
condition|)
name|DoIncrPtPlot
argument_list|(
operator|&
name|stsCur
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stsCur
operator|.
name|md
operator|==
name|mdAlpha
operator|)
operator|&&
operator|(
name|ch
operator|>=
name|chFstShow
operator|)
operator|&&
operator|(
name|ch
operator|<=
name|chLstShow
operator|)
condition|)
block|{
if|if
condition|(
name|ichShowCur
operator|>=
name|ichShowMax
operator|-
literal|2
condition|)
block|{
name|Show
argument_list|(
operator|&
name|stsCur
argument_list|,
name|scShow
argument_list|,
name|ichShowCur
argument_list|)
expr_stmt|;
name|ichShowCur
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|==
literal|'('
operator|)
operator|||
operator|(
name|ch
operator|==
literal|')'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\\'
operator|)
condition|)
name|scShow
index|[
name|ichShowCur
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|scShow
index|[
name|ichShowCur
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ichShowCur
operator|>
literal|0
condition|)
block|{
name|Show
argument_list|(
operator|&
name|stsCur
argument_list|,
name|scShow
argument_list|,
name|ichShowCur
argument_list|)
expr_stmt|;
name|ichShowCur
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|chEsc
case|:
name|ch
operator|=
name|ChEscapeAction
argument_list|(
operator|&
name|stsCur
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|chDel
condition|)
continue|continue;
break|break;
case|case
name|chBell
case|:
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|stsCur
operator|.
name|fPenDown
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|chFs
case|:
name|FsAction
argument_list|(
operator|&
name|stsCur
argument_list|)
expr_stmt|;
break|break;
case|case
name|chGs
case|:
name|GsAction
argument_list|(
operator|&
name|stsCur
argument_list|)
expr_stmt|;
break|break;
case|case
name|chRs
case|:
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|Stroke
argument_list|(
operator|&
name|stsCur
argument_list|)
expr_stmt|;
name|stsCur
operator|.
name|md
operator|=
name|mdIncrPtPlot
expr_stmt|;
name|stsCur
operator|.
name|dir
operator|=
name|dirNil
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|stsCur
operator|.
name|md
condition|)
block|{
case|case
name|mdAlpha
case|:
name|Stroke
argument_list|(
operator|&
name|stsCur
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tymoveT
operator|=
name|rgtymove
index|[
name|ch
index|]
operator|)
operator|!=
name|tymoveNil
condition|)
name|MovePos
argument_list|(
operator|&
name|stsCur
argument_list|,
name|tymoveT
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fDbg
condition|)
name|PrintCmd
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|mdVector
case|:
case|case
name|mdPtPlot
case|:
case|case
name|mdSpecPtPlot
case|:
case|case
name|mdIncrPtPlot
case|:
name|VectorAction
argument_list|(
name|ch
argument_list|,
operator|&
name|stsCur
argument_list|)
expr_stmt|;
break|break;
case|case
name|mdBypass
case|:
name|BypassAction
argument_list|(
name|ch
argument_list|,
operator|&
name|stsCur
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Illegal mode\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|ch
operator|=
name|getc
argument_list|(
name|fpSrc
argument_list|)
expr_stmt|;
block|}
name|MakeCopy
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ARGS
value|"RCNmp:d:l:s:S:"
end_define

begin_define
define|#
directive|define
name|USAGE
value|"ps4014 [-RCNm] [-p outfile] [-l left,bottom] [-s width,height] [-S width] [file]"
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|argp
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|char
modifier|*
name|libdir
decl_stmt|;
name|params
operator|.
name|scSrcFile
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|scDstFile
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|scDbgFile
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|fDbg
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|fLfGenCr
operator|=
name|TRUE
expr_stmt|;
name|params
operator|.
name|fCrGenLf
operator|=
name|TRUE
expr_stmt|;
name|params
operator|.
name|fMarg2
operator|=
name|FALSE
expr_stmt|;
comment|/* these numbers make the image occupy almost the whole page     with the correct proportions */
name|params
operator|.
name|xRtInch
operator|=
literal|0.38
expr_stmt|;
name|params
operator|.
name|yBotInch
operator|=
literal|0.35
expr_stmt|;
name|params
operator|.
name|dxWidInch
operator|=
literal|10.24
expr_stmt|;
name|params
operator|.
name|dyHtInch
operator|=
literal|7.8
expr_stmt|;
name|params
operator|.
name|fLandscape
operator|=
name|TRUE
expr_stmt|;
name|prog
operator|=
operator|*
name|argv
expr_stmt|;
while|while
condition|(
operator|(
name|argp
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|ARGS
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|argp
condition|)
block|{
case|case
literal|'R'
case|:
name|params
operator|.
name|fLandscape
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|params
operator|.
name|fCrGenLf
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|params
operator|.
name|fLfGenCr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|params
operator|.
name|fMarg2
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|params
operator|.
name|scDstFile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|params
operator|.
name|scDbgFile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|" %f,%f"
argument_list|,
operator|&
name|params
operator|.
name|xRtInch
argument_list|,
operator|&
name|params
operator|.
name|yBotInch
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad parameter -l%s\n"
argument_list|,
name|prog
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|" %f,%f"
argument_list|,
operator|&
name|params
operator|.
name|dxWidInch
argument_list|,
operator|&
name|params
operator|.
name|dyHtInch
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad parameter -s%s\n"
argument_list|,
name|prog
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|" %f"
argument_list|,
operator|&
name|params
operator|.
name|dxWidInch
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad parameter -S%s\n"
argument_list|,
name|prog
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|dyHtInch
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad option -%c\n"
argument_list|,
name|prog
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|optind
operator|+
literal|1
operator|)
operator|<
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|USAGE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|params
operator|.
name|scSrcFile
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fpSrc
operator|=
name|fopen
argument_list|(
name|params
operator|.
name|scSrcFile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s\n"
argument_list|,
name|prog
argument_list|,
name|params
operator|.
name|scSrcFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fpSrc
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|scDstFile
operator|==
name|NULL
condition|)
name|fpPsDst
operator|=
name|stdout
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|fpPsDst
operator|=
name|fopen
argument_list|(
name|params
operator|.
name|scDstFile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open output file %s\n"
argument_list|,
name|prog
argument_list|,
name|params
operator|.
name|scDstFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|params
operator|.
name|scDbgFile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fpDbg
operator|=
name|fopen
argument_list|(
name|params
operator|.
name|scDbgFile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open debug file %s\n"
argument_list|,
name|prog
argument_list|,
name|params
operator|.
name|scDbgFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|fDbg
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|libdir
operator|=
name|envget
argument_list|(
literal|"PSLIBDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|libdir
operator|=
name|LibDir
expr_stmt|;
name|VOIDC
name|mstrcat
argument_list|(
name|scProlog
argument_list|,
name|libdir
argument_list|,
name|PS4014PRO
argument_list|,
sizeof|sizeof
name|scProlog
argument_list|)
decl_stmt|;
name|CommentHeader
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fpPsDst
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyfile
argument_list|(
name|scProlog
argument_list|,
name|fpPsDst
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: trouble copying prolog file %s\n"
argument_list|,
name|prog
argument_list|,
name|scProlog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* rotate and translate before we scale */
if|if
condition|(
name|params
operator|.
name|fLandscape
condition|)
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"90 rotate 0 -8.5 inch translate\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"%g inch %g inch translate\n"
argument_list|,
name|params
operator|.
name|xRtInch
argument_list|,
name|params
operator|.
name|yBotInch
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|dyHtInch
operator|==
literal|0
condition|)
block|{
comment|/* we got a dxWidInch but not a dyHtInch */
comment|/* -> we are scaling y axis proportional to x axis */
name|params
operator|.
name|dyHtInch
operator|=
operator|(
name|params
operator|.
name|dxWidInch
operator|*
name|yhMax
operator|)
operator|/
name|xhMax
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"/dxWidInch %g def\n"
argument_list|,
name|params
operator|.
name|dxWidInch
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"/dyHtInch %g def\n"
argument_list|,
name|params
operator|.
name|dyHtInch
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"ScaleCoords\n0 SetCharStyle\n0 SetLineStyle\nxHome yHome moveto\n"
argument_list|)
expr_stmt|;
name|Convert4014
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"\n%%%%Trailer\ngrestore\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fpPsDst
argument_list|,
literal|"ps4014sav restore\n"
argument_list|)
expr_stmt|;
name|VOIDC
name|fclose
argument_list|(
name|fpPsDst
argument_list|)
decl_stmt|;
name|VOIDC
name|fclose
argument_list|(
name|fpSrc
argument_list|)
decl_stmt|;
if|if
condition|(
name|fpDbg
operator|!=
name|NULL
condition|)
name|VOIDC
name|fclose
argument_list|(
name|fpDbg
argument_list|)
decl_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

