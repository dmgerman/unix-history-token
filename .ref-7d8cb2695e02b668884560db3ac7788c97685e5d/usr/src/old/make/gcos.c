begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)gcos.c	4.4 (Berkeley) 87/12/04"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GCOS DEPENDENT PROCEDURES */
end_comment

begin_comment
comment|/* DEFAULT RULES FOR GCOS */
end_comment

begin_decl_stmt
name|char
modifier|*
name|builtin
index|[]
block|{
literal|".SUFFIXES : .d .c .y .lib"
operator|,
literal|".d.c:"
operator|,
literal|"\t./dtgen $<"
operator|,
literal|".y.c:"
operator|,
literal|"\t./yacc $<"
operator|,
literal|"\tcopy y.tab.c; /$@"
operator|,
literal|".y.lib:"
operator|,
literal|"\t./yacc $<"
operator|,
literal|"\t./cc y.tab.c r=$@"
operator|,
literal|".c.lib:"
operator|,
literal|"\t./cc $< r=$@"
operator|,
literal|0
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAXCSIZE
value|500
end_define

begin_define
define|#
directive|define
name|YZERO
value|60
end_define

begin_expr_stmt
name|int
name|gtcalled
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* all kinds of static declarations that must be used.. */
end_comment

begin_decl_stmt
specifier|static
name|double
name|day
block|{
literal|64
operator|*
literal|1000
operator|*
literal|60
operator|*
literal|60
operator|*
literal|24
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* length of day in clock ticks */
end_comment

begin_struct
struct|struct
block|{
name|int
name|lhs
range|:
literal|18
decl_stmt|,
name|rhs
range|:
literal|18
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|catb
block|{
name|int
name|words
index|[
literal|6
index|]
decl_stmt|,
name|name1
decl_stmt|,
name|name2
decl_stmt|,
name|passw1
decl_stmt|,
name|passw2
decl_stmt|,
name|word10
decl_stmt|,
name|word11
decl_stmt|,
name|datcreat
decl_stmt|,
name|datmod
decl_stmt|,
name|datused
decl_stmt|,
name|stuff
index|[
literal|6
index|]
decl_stmt|,
name|jjjj
range|:
literal|18
decl_stmt|,
name|tused
range|:
literal|18
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
label|:
literal|3
operator|,
name|slot
operator|:
literal|18
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* slot where time from cat. block fits */
end_comment

begin_struct
struct|struct
name|catdesc
block|{
name|int
name|cat1
decl_stmt|,
name|cat2
decl_stmt|,
name|cpass1
decl_stmt|,
name|cpass2
decl_stmt|,
name|file1
decl_stmt|,
name|file2
decl_stmt|,
name|filep1
decl_stmt|,
name|filep2
decl_stmt|,
name|endmark
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|_q_reg
decl_stmt|,
name|_a_reg
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|A10
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|10*x + y
end_define

begin_comment
comment|/*	interpret the mm/dd/yy format */
end_comment

begin_struct
struct|struct
name|d9
block|{
name|int
label|:
literal|5
operator|,
name|m1
operator|:
literal|4
operator|,
operator|:
literal|5
operator|,
name|m2
operator|:
literal|4
operator|,
operator|:
literal|9
operator|,
operator|:
literal|5
operator|,
name|d1
operator|:
literal|4
operator|,
operator|:
literal|5
operator|,
name|d2
operator|:
literal|4
operator|,
operator|:
literal|9
operator|,
operator|:
literal|5
operator|,
name|y1
operator|:
literal|4
operator|,
operator|:
literal|5
operator|,
name|y2
operator|:
literal|4
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|d6
block|{
name|int
label|:
literal|2
operator|,
name|m61
operator|:
literal|4
operator|,
operator|:
literal|2
operator|,
name|m62
operator|:
literal|4
operator|,
operator|:
literal|2
operator|,
name|d61
operator|:
literal|4
operator|,
operator|:
literal|2
operator|,
name|d62
operator|:
literal|4
operator|,
operator|:
literal|2
operator|,
name|y61
operator|:
literal|4
operator|,
operator|:
literal|2
operator|,
name|y62
operator|:
literal|4
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|day6
argument_list|(
argument|d6word
argument_list|)
block|{
comment|/* return the day number of a word in bci format */
name|int
name|m
block|,
name|y
block|,
name|d
block|;
name|y
operator|=
name|A10
argument_list|(
name|d6word
operator|.
name|y61
argument_list|,
name|d6word
operator|.
name|y62
argument_list|)
block|;
name|m
operator|=
name|A10
argument_list|(
name|d6word
operator|.
name|m61
argument_list|,
name|d6word
operator|.
name|m62
argument_list|)
block|;
name|d
operator|=
name|A10
argument_list|(
name|d6word
operator|.
name|d61
argument_list|,
name|d6word
operator|.
name|d62
argument_list|)
block|;
return|return
operator|(
name|d
operator|+
literal|31
operator|*
operator|(
name|m
operator|+
literal|12
operator|*
operator|(
name|y
operator|-
name|YZERO
operator|)
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|day9
argument_list|(
name|p
argument_list|)
specifier|register
name|int
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|m
decl_stmt|,
name|y
decl_stmt|,
name|d
decl_stmt|;
name|y
operator|=
name|A10
argument_list|(
name|p
operator|->
name|y1
argument_list|,
name|p
operator|->
name|y2
argument_list|)
expr_stmt|;
name|m
operator|=
name|A10
argument_list|(
name|p
operator|->
name|m1
argument_list|,
name|p
operator|->
name|m2
argument_list|)
expr_stmt|;
name|d
operator|=
name|A10
argument_list|(
name|p
operator|->
name|d1
argument_list|,
name|p
operator|->
name|d2
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|+
literal|31
operator|*
operator|(
name|m
operator|+
literal|12
operator|*
operator|(
name|y
operator|-
name|YZERO
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|dfold
parameter_list|(
name|dayno
parameter_list|,
name|timeno
parameter_list|)
block|{
name|int
name|kk
decl_stmt|;
name|kk
operator|=
operator|(
name|day
operator|*
name|dayno
operator|+
name|timeno
operator|)
operator|/
literal|32768.
expr_stmt|;
block|}
end_function

begin_function
name|int
name|prestime
parameter_list|()
block|{
name|int
name|date
index|[
literal|2
index|]
decl_stmt|;
name|drldrl
argument_list|(
literal|021
argument_list|,
name|date
argument_list|)
expr_stmt|;
return|return
operator|(
name|dfold
argument_list|(
name|day9
argument_list|(
name|date
argument_list|)
argument_list|,
name|_q_reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DODRL
value|ar[0] = status; ar[1] =&b.cat1; drldrl(30,sp1,sp2); p=ar[0]<<18;
end_define

begin_struct
specifier|static
struct|struct
block|{
name|int
name|fn1
decl_stmt|,
name|fn2
decl_stmt|;
name|int
name|ftm
decl_stmt|;
block|}
name|fbb
index|[
name|MAXCSIZE
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|catsiz
decl_stmt|;
end_decl_stmt

begin_macro
name|getcat
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
operator|*
name|p
operator|,
name|j
expr_stmt|;
name|int
name|asname
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|catdesc
name|b
decl_stmt|;
name|int
name|sp1
decl_stmt|,
name|sp2
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|ar
index|[
literal|2
index|]
decl_stmt|,
name|status
index|[
literal|2
index|]
decl_stmt|;
name|int
name|filbuf
index|[
literal|380
index|]
decl_stmt|;
name|gtcalled
operator|=
literal|1
expr_stmt|;
name|sp1
operator|=
name|ar
expr_stmt|;
name|sp1
operator|>>=
literal|18
expr_stmt|;
name|sp2
operator|=
name|filbuf
expr_stmt|;
name|sp2
operator|>>=
literal|18
expr_stmt|;
name|sp2
operator|.
name|lhs
operator|=
literal|19
expr_stmt|;
name|b
operator|.
name|cat1
operator|=
name|b
operator|.
name|cat2
operator|=
name|b
operator|.
name|file1
operator|=
operator|-
literal|1
expr_stmt|;
name|b
operator|.
name|cpass1
operator|=
name|b
operator|.
name|cpass2
operator|=
literal|0202020202020
expr_stmt|;
name|DODRL
name|sp2
operator|.
name|lhs
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
operator|!=
literal|0
operator|&&
name|i
operator|<
name|MAXCSIZE
condition|;
operator|++
name|i
control|)
block|{
name|fbb
index|[
name|i
index|]
operator|.
name|fn1
operator|=
name|b
operator|.
name|file1
operator|=
name|p
operator|->
name|name1
expr_stmt|;
name|fbb
index|[
name|i
index|]
operator|.
name|fn2
operator|=
name|b
operator|.
name|file2
operator|=
name|p
operator|->
name|name2
expr_stmt|;
name|b
operator|.
name|filep1
operator|=
name|p
operator|->
name|passw1
expr_stmt|;
name|b
operator|.
name|filep2
operator|=
name|p
operator|->
name|passw2
expr_stmt|;
name|b
operator|.
name|endmark
operator|=
operator|-
literal|1
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|slot
operator|=
name|p
operator|->
name|tused
expr_stmt|;
name|fbb
index|[
name|i
index|]
operator|.
name|ftm
operator|=
name|dfold
argument_list|(
name|day6
argument_list|(
name|p
operator|->
name|datmod
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|DODRL
block|}
name|catsiz
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_macro
name|exists
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nameblock
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
name|name
index|[
literal|13
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|bcd
index|[
literal|2
index|]
decl_stmt|;
comment|/*    cheat about names with slashes -- try opening;    if it is openable, it exists, and assume it was made    at t=1 (long time ago); otherwise, assume it    does not exist */
name|cp
operator|=
name|p
operator|->
name|namep
expr_stmt|;
for|for
control|(
name|s
operator|=
name|cp
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
if|if
condition|(
name|i
operator|=
name|copen
argument_list|(
name|cp
argument_list|,
literal|'r'
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
block|{
name|cclose
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|gtcalled
operator|==
literal|0
condition|)
name|getcat
argument_list|()
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
operator|++
name|i
control|)
name|name
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|12
condition|)
name|name
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|f9to6
argument_list|(
operator|*
name|p
argument_list|,
name|bcd
index|[
literal|0
index|]
argument_list|,
literal|12
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|catsiz
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fbb
index|[
name|i
index|]
operator|.
name|fn1
operator|==
name|bcd
index|[
literal|0
index|]
operator|&&
name|fbb
index|[
name|i
index|]
operator|.
name|fn2
operator|==
name|bcd
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|fbb
index|[
name|i
index|]
operator|.
name|ftm
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_include
include|#
directive|include
file|"defs"
end_include

begin_decl_stmt
specifier|static
name|char
name|n13
index|[
literal|13
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|n13end
modifier|&
name|n13
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|depblock
modifier|*
name|srchdir
parameter_list|(
name|pat
parameter_list|,
name|mkchain
parameter_list|,
name|nextdbl
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
comment|/* pattern to be matched in directory */
name|int
name|mkchain
decl_stmt|;
comment|/* nonzero if results to be remembered */
name|struct
name|depblock
modifier|*
name|nextdbl
decl_stmt|;
comment|/* final value for chain */
block|{
name|int
name|dirf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nread
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|dirpref
decl_stmt|,
modifier|*
name|endir
decl_stmt|,
modifier|*
name|filepat
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|temp
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|fullname
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|copys
argument_list|()
decl_stmt|;
name|struct
name|nameblock
modifier|*
name|q
decl_stmt|;
name|struct
name|depblock
modifier|*
name|thisdbl
decl_stmt|;
name|struct
name|pattern
modifier|*
name|patp
decl_stmt|;
name|int
modifier|*
name|intp1
decl_stmt|,
modifier|*
name|intp2
decl_stmt|;
if|if
condition|(
name|gtcalled
operator|==
literal|0
condition|)
name|getcat
argument_list|()
expr_stmt|;
name|thisdbl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mkchain
operator|==
literal|0
condition|)
for|for
control|(
name|patp
operator|=
name|firstpat
init|;
name|patp
operator|!=
literal|0
condition|;
name|patp
operator|=
name|patp
operator|->
name|nxtpattern
control|)
if|if
condition|(
operator|!
name|unequal
argument_list|(
name|pat
argument_list|,
name|patp
operator|->
name|patval
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|patp
operator|=
name|ALLOC
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|patp
operator|->
name|nxtpattern
operator|=
name|firstpat
expr_stmt|;
name|firstpat
operator|=
name|patp
expr_stmt|;
name|patp
operator|->
name|patval
operator|=
name|copys
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|endir
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pat
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|endir
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|endir
operator|==
literal|0
condition|)
block|{
name|dirname
operator|=
literal|""
expr_stmt|;
name|dirpref
operator|=
literal|""
expr_stmt|;
name|filepat
operator|=
name|pat
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"File name has an embedded slash"
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|pat
expr_stmt|;
operator|*
name|endir
operator|=
literal|'\0'
expr_stmt|;
name|dirpref
operator|=
name|concat
argument_list|(
name|dirname
argument_list|,
literal|"/"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|filepat
operator|=
name|endir
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|catsiz
condition|;
operator|++
name|i
control|)
block|{
name|intp1
operator|=
operator|&
name|fbb
index|[
name|i
index|]
operator|.
name|fn1
expr_stmt|;
name|intp2
operator|=
name|n13
expr_stmt|;
name|f6to9
argument_list|(
operator|*
name|intp1
argument_list|,
operator|*
name|intp2
argument_list|,
literal|12
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|n13
init|;
name|p1
operator|<
name|n13end
operator|&&
operator|*
name|p1
operator|!=
literal|' '
condition|;
operator|++
name|p1
control|)
if|if
condition|(
literal|'A'
operator|<=
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|<=
literal|'Z'
condition|)
operator|*
name|p1
operator|+=
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|amatch
argument_list|(
name|n13
argument_list|,
name|filepat
argument_list|)
condition|)
block|{
name|concat
argument_list|(
name|dirpref
argument_list|,
name|n13
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|srchname
argument_list|(
name|fullname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|q
operator|=
name|makename
argument_list|(
name|copys
argument_list|(
name|fullname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkchain
condition|)
block|{
name|thisdbl
operator|=
name|ALLOC
argument_list|(
name|depblock
argument_list|)
expr_stmt|;
name|thisdbl
operator|->
name|nextp
operator|=
name|nextdbl
expr_stmt|;
name|thisdbl
operator|->
name|depname
operator|=
name|q
expr_stmt|;
name|nextdbl
operator|=
name|thisdbl
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|endir
operator|!=
literal|0
condition|)
operator|*
name|endir
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|thisdbl
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* stolen from glob through find */
end_comment

begin_macro
name|amatch
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cc
decl_stmt|,
name|scc
decl_stmt|,
name|k
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lc
decl_stmt|;
name|scc
operator|=
operator|*
name|s
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
condition|)
block|{
case|case
literal|'['
case|:
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|']'
case|:
if|if
condition|(
name|k
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'-'
case|:
name|k
operator||=
name|lc
operator|<=
name|scc
operator|&
name|scc
operator|<=
operator|(
name|cc
operator|=
name|p
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|scc
operator|==
operator|(
name|lc
operator|=
name|cc
operator|)
condition|)
name|k
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'?'
case|:
name|caseq
label|:
if|if
condition|(
name|scc
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|umatch
argument_list|(
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
operator|!
name|scc
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|scc
condition|)
goto|goto
name|caseq
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|umatch
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|amatch
argument_list|(
name|s
operator|++
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|dosys
argument_list|(
argument|comstring
argument_list|,
argument|nohalt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|comstring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nohalt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|comstring
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|-
name|comstring
operator|>
literal|80
condition|)
name|fatal
argument_list|(
literal|"Command string longer than 80 characters"
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|comstring
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|touch
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"touch not yet implemented on GCOS\n"
argument_list|)
expr_stmt|;
name|cexit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

