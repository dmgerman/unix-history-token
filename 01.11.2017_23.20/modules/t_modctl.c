begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: t_modctl.c,v 1.12 2012/08/20 08:07:52 martin Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2008 The NetBSD Foundation, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__KERNEL_RCSID
argument_list|(
literal|0
argument_list|,
literal|"$NetBSD: t_modctl.c,v 1.12 2012/08/20 08:07:52 martin Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<prop/proplib.h>
end_include

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_enum
enum|enum
name|presence_check
block|{
name|both_checks
block|,
name|stat_check
block|,
name|sysctl_check
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|check_permission
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|get_modstat_info
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|modstat_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|get_sysctl
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
specifier|const
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|k_helper_is_present_stat
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|k_helper_is_present_sysctl
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|k_helper_is_present
parameter_list|(
name|enum
name|presence_check
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|load
parameter_list|(
name|prop_dictionary_t
parameter_list|,
name|bool
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unload
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unload_cleanup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Auxiliary functions                                                   */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * A function checking wether we are allowed to load modules currently  * (either the kernel is not modular, or securelevel may prevent it)  */
end_comment

begin_function
specifier|static
name|void
name|check_permission
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|modctl
argument_list|(
name|MODCTL_EXISTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|errno
operator|==
name|ENOSYS
condition|)
name|atf_tc_skip
argument_list|(
literal|"Kernel does not have 'options MODULAR'."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
name|atf_tc_skip
argument_list|(
literal|"Module loading administratively forbidden"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ_MSG
argument_list|(
name|errno
argument_list|,
literal|0
argument_list|,
literal|"unexpected error %d from "
literal|"modctl(MODCTL_EXISTS, 0)"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|get_modstat_info
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|modstat_t
modifier|*
name|msdest
parameter_list|)
block|{
name|bool
name|found
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|modstat_t
modifier|*
name|ms
decl_stmt|;
name|check_permission
argument_list|()
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|4096
init|;
condition|;
control|)
block|{
name|iov
operator|.
name|iov_base
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|modctl
argument_list|(
name|MODCTL_STAT
argument_list|,
operator|&
name|iov
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"modctl(MODCTL_STAT) failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|atf_tc_fail
argument_list|(
literal|"Failed to query module status"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
name|iov
operator|.
name|iov_len
condition|)
break|break;
name|free
argument_list|(
name|iov
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|len
operator|=
name|iov
operator|.
name|iov_len
expr_stmt|;
block|}
name|found
operator|=
name|false
expr_stmt|;
name|len
operator|=
name|iov
operator|.
name|iov_len
operator|/
sizeof|sizeof
argument_list|(
name|modstat_t
argument_list|)
expr_stmt|;
for|for
control|(
name|ms
operator|=
operator|(
name|modstat_t
operator|*
operator|)
name|iov
operator|.
name|iov_base
init|;
name|len
operator|!=
literal|0
operator|&&
operator|!
name|found
condition|;
name|ms
operator|++
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ms
operator|->
name|ms_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msdest
operator|!=
name|NULL
condition|)
operator|*
name|msdest
operator|=
operator|*
name|ms
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|iov
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Queries a sysctl property.  */
end_comment

begin_function
specifier|static
name|bool
name|get_sysctl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
specifier|const
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|len2
init|=
name|len
decl_stmt|;
name|printf
argument_list|(
literal|"Querying sysctl variable: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|sysctlbyname
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
operator|&
name|len2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysctlbyname(2) failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|atf_tc_fail
argument_list|(
literal|"Failed to query %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|!=
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a boolean indicating if the k_helper module was loaded  * successfully.  This implementation uses modctl(2)'s MODCTL_STAT  * subcommand to do the check.  */
end_comment

begin_function
specifier|static
name|bool
name|k_helper_is_present_stat
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|get_modstat_info
argument_list|(
literal|"k_helper"
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a boolean indicating if the k_helper module was loaded  * successfully.  This implementation uses the module's sysctl  * installed node to do the check.  */
end_comment

begin_function
specifier|static
name|bool
name|k_helper_is_present_sysctl
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|present
decl_stmt|;
return|return
name|get_sysctl
argument_list|(
literal|"vendor.k_helper.present"
argument_list|,
operator|&
name|present
argument_list|,
sizeof|sizeof
argument_list|(
name|present
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a boolean indicating if the k_helper module was loaded  * successfully.  The 'how' parameter specifies the implementation to  * use to do the check.  */
end_comment

begin_function
specifier|static
name|bool
name|k_helper_is_present
parameter_list|(
name|enum
name|presence_check
name|how
parameter_list|)
block|{
name|bool
name|found
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|both_checks
case|:
name|found
operator|=
name|k_helper_is_present_stat
argument_list|()
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|k_helper_is_present_sysctl
argument_list|()
operator|==
name|found
argument_list|)
expr_stmt|;
break|break;
case|case
name|stat_check
case|:
name|found
operator|=
name|k_helper_is_present_stat
argument_list|()
expr_stmt|;
break|break;
case|case
name|sysctl_check
case|:
name|found
operator|=
name|k_helper_is_present_sysctl
argument_list|()
expr_stmt|;
break|break;
default|default:
name|found
operator|=
name|false
expr_stmt|;
name|assert
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Loads the specified module from a file.  If fatal is set and an error  * occurs when loading the module, an error message is printed and the  * test case is aborted.  */
end_comment

begin_expr_stmt
specifier|static
name|__printflike
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|)
name|int
name|load
argument_list|(
argument|prop_dictionary_t props
argument_list|,
argument|bool fatal
argument_list|,
argument|const char *fmt
argument_list|,
argument|...
argument_list|)
block|{
name|int
name|err
block|;
name|va_list
name|ap
block|;
name|char
name|filename
index|[
name|MAXPATHLEN
index|]
block|,
operator|*
name|propsstr
block|;
name|modctl_load_t
name|ml
block|;
name|check_permission
argument_list|()
block|;
if|if
condition|(
name|props
operator|==
name|NULL
condition|)
block|{
name|props
operator|=
name|prop_dictionary_create
argument_list|()
expr_stmt|;
name|propsstr
operator|=
name|prop_dictionary_externalize
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|propsstr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|prop_object_release
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|propsstr
operator|=
name|prop_dictionary_externalize
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|propsstr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vsnprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ml
operator|.
name|ml_filename
operator|=
name|filename
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ml
operator|.
name|ml_flags
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ml
operator|.
name|ml_props
operator|=
name|propsstr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ml
operator|.
name|ml_propslen
operator|=
name|strlen
argument_list|(
name|propsstr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|"Loading module %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|errno
operator|=
name|err
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|modctl
argument_list|(
name|MODCTL_LOAD
argument_list|,
operator|&
name|ml
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"modctl(MODCTL_LOAD, %s), failed: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|atf_tc_fail
argument_list|(
literal|"Module load failed"
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|free
argument_list|(
name|propsstr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|err
return|;
end_return

begin_comment
unit|}
comment|/*  * Unloads the specified module.  If silent is true, nothing will be  * printed and no errors will be raised if the unload was unsuccessful.  */
end_comment

begin_function
unit|static
name|int
name|unload
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|fatal
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|check_permission
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Unloading module %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|modctl
argument_list|(
name|MODCTL_UNLOAD
argument_list|,
name|__UNCONST
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"modctl(MODCTL_UNLOAD, %s) failed: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|atf_tc_fail
argument_list|(
literal|"Module unload failed"
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * A silent version of unload, to be called as part of the cleanup  * process only.  */
end_comment

begin_function
specifier|static
name|void
name|unload_cleanup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
operator|(
name|void
operator|)
name|modctl
argument_list|(
name|MODCTL_UNLOAD
argument_list|,
name|__UNCONST
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Test cases                                                            */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_expr_stmt
name|ATF_TC_WITH_CLEANUP
argument_list|(
name|cmd_load
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|cmd_load
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests for the MODCTL_LOAD command"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"require.user"
argument_list|,
literal|"root"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|cmd_load
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|char
name|longname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|ATF_CHECK
argument_list|(
name|load
argument_list|(
name|NULL
argument_list|,
name|false
argument_list|,
literal|" "
argument_list|)
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|load
argument_list|(
name|NULL
argument_list|,
name|false
argument_list|,
literal|"non-existent.o"
argument_list|)
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPATHLEN
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|longname
index|[
name|i
index|]
operator|=
literal|'a'
expr_stmt|;
name|longname
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|load
argument_list|(
name|NULL
argument_list|,
name|false
argument_list|,
literal|"%s"
argument_list|,
name|longname
argument_list|)
operator|==
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|!
name|k_helper_is_present
argument_list|(
name|stat_check
argument_list|)
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|NULL
argument_list|,
name|true
argument_list|,
literal|"%s/k_helper/k_helper.kmod"
argument_list|,
name|atf_tc_get_config_var
argument_list|(
name|tc
argument_list|,
literal|"srcdir"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Checking if load was successful\n"
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|k_helper_is_present
argument_list|(
name|stat_check
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_CLEANUP
argument_list|(
argument|cmd_load
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|unload_cleanup
argument_list|(
literal|"k_helper"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC_WITH_CLEANUP
argument_list|(
name|cmd_load_props
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|cmd_load_props
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests for the MODCTL_LOAD command, "
literal|"providing extra load-time properties"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"require.user"
argument_list|,
literal|"root"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|cmd_load_props
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|prop_dictionary_t
name|props
decl_stmt|;
name|printf
argument_list|(
literal|"Loading module without properties\n"
argument_list|)
expr_stmt|;
name|props
operator|=
name|prop_dictionary_create
argument_list|()
expr_stmt|;
name|load
argument_list|(
name|props
argument_list|,
name|true
argument_list|,
literal|"%s/k_helper/k_helper.kmod"
argument_list|,
name|atf_tc_get_config_var
argument_list|(
name|tc
argument_list|,
literal|"srcdir"
argument_list|)
argument_list|)
expr_stmt|;
name|prop_object_release
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|{
name|int
name|ok
decl_stmt|;
name|ATF_CHECK
argument_list|(
name|get_sysctl
argument_list|(
literal|"vendor.k_helper.prop_str_ok"
argument_list|,
operator|&
name|ok
argument_list|,
sizeof|sizeof
argument_list|(
name|ok
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|!
name|ok
argument_list|)
expr_stmt|;
block|}
name|unload
argument_list|(
literal|"k_helper"
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Loading module with a string property\n"
argument_list|)
expr_stmt|;
name|props
operator|=
name|prop_dictionary_create
argument_list|()
expr_stmt|;
name|prop_dictionary_set
argument_list|(
name|props
argument_list|,
literal|"prop_str"
argument_list|,
name|prop_string_create_cstring
argument_list|(
literal|"1st string"
argument_list|)
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|props
argument_list|,
name|true
argument_list|,
literal|"%s/k_helper/k_helper.kmod"
argument_list|,
name|atf_tc_get_config_var
argument_list|(
name|tc
argument_list|,
literal|"srcdir"
argument_list|)
argument_list|)
expr_stmt|;
name|prop_object_release
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|{
name|int
name|ok
decl_stmt|;
name|ATF_CHECK
argument_list|(
name|get_sysctl
argument_list|(
literal|"vendor.k_helper.prop_str_ok"
argument_list|,
operator|&
name|ok
argument_list|,
sizeof|sizeof
argument_list|(
name|ok
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|char
name|val
index|[
literal|128
index|]
decl_stmt|;
name|ATF_CHECK
argument_list|(
name|get_sysctl
argument_list|(
literal|"vendor.k_helper.prop_str_val"
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"1st string"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|unload
argument_list|(
literal|"k_helper"
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Loading module with a different string property\n"
argument_list|)
expr_stmt|;
name|props
operator|=
name|prop_dictionary_create
argument_list|()
expr_stmt|;
name|prop_dictionary_set
argument_list|(
name|props
argument_list|,
literal|"prop_str"
argument_list|,
name|prop_string_create_cstring
argument_list|(
literal|"2nd string"
argument_list|)
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|props
argument_list|,
name|true
argument_list|,
literal|"%s/k_helper/k_helper.kmod"
argument_list|,
name|atf_tc_get_config_var
argument_list|(
name|tc
argument_list|,
literal|"srcdir"
argument_list|)
argument_list|)
expr_stmt|;
name|prop_object_release
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|{
name|int
name|ok
decl_stmt|;
name|ATF_CHECK
argument_list|(
name|get_sysctl
argument_list|(
literal|"vendor.k_helper.prop_str_ok"
argument_list|,
operator|&
name|ok
argument_list|,
sizeof|sizeof
argument_list|(
name|ok
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|char
name|val
index|[
literal|128
index|]
decl_stmt|;
name|ATF_CHECK
argument_list|(
name|get_sysctl
argument_list|(
literal|"vendor.k_helper.prop_str_val"
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"2nd string"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|unload
argument_list|(
literal|"k_helper"
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_CLEANUP
argument_list|(
argument|cmd_load_props
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|unload_cleanup
argument_list|(
literal|"k_helper"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC_WITH_CLEANUP
argument_list|(
name|cmd_load_recurse
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|cmd_load_recurse
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests for the MODCTL_LOAD command, "
literal|"with recursive module_load()"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"require.user"
argument_list|,
literal|"root"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|cmd_load_recurse
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|prop_dictionary_t
name|props
decl_stmt|;
name|char
name|filename
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"Loading module with request to load another module\n"
argument_list|)
expr_stmt|;
name|props
operator|=
name|prop_dictionary_create
argument_list|()
expr_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s/k_helper2/k_helper2.kmod"
argument_list|,
name|atf_tc_get_config_var
argument_list|(
name|tc
argument_list|,
literal|"srcdir"
argument_list|)
argument_list|)
expr_stmt|;
name|prop_dictionary_set
argument_list|(
name|props
argument_list|,
literal|"prop_recurse"
argument_list|,
name|prop_string_create_cstring
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|props
argument_list|,
name|true
argument_list|,
literal|"%s/k_helper/k_helper.kmod"
argument_list|,
name|atf_tc_get_config_var
argument_list|(
name|tc
argument_list|,
literal|"srcdir"
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|ok
decl_stmt|;
name|ATF_CHECK
argument_list|(
name|get_sysctl
argument_list|(
literal|"vendor.k_helper.prop_int_load"
argument_list|,
operator|&
name|ok
argument_list|,
sizeof|sizeof
argument_list|(
name|ok
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ok
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|get_sysctl
argument_list|(
literal|"vendor.k_helper2.present"
argument_list|,
operator|&
name|ok
argument_list|,
sizeof|sizeof
argument_list|(
name|ok
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
name|unload
argument_list|(
literal|"k_helper"
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|unload
argument_list|(
literal|"k_helper2"
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_CLEANUP
argument_list|(
argument|cmd_load_recurse
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|unload_cleanup
argument_list|(
literal|"k_helper"
argument_list|)
expr_stmt|;
name|unload_cleanup
argument_list|(
literal|"k_helper2"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC_WITH_CLEANUP
argument_list|(
name|cmd_stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|cmd_stat
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests for the MODCTL_STAT command"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"require.user"
argument_list|,
literal|"root"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|cmd_stat
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|ATF_CHECK
argument_list|(
operator|!
name|k_helper_is_present
argument_list|(
name|both_checks
argument_list|)
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|NULL
argument_list|,
name|true
argument_list|,
literal|"%s/k_helper/k_helper.kmod"
argument_list|,
name|atf_tc_get_config_var
argument_list|(
name|tc
argument_list|,
literal|"srcdir"
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|k_helper_is_present
argument_list|(
name|both_checks
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|modstat_t
name|ms
decl_stmt|;
name|ATF_CHECK
argument_list|(
name|get_modstat_info
argument_list|(
literal|"k_helper"
argument_list|,
operator|&
name|ms
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ms
operator|.
name|ms_class
operator|==
name|MODULE_CLASS_MISC
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ms
operator|.
name|ms_source
operator|==
name|MODULE_SOURCE_FILESYS
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ms
operator|.
name|ms_refcnt
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|unload
argument_list|(
literal|"k_helper"
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|!
name|k_helper_is_present
argument_list|(
name|both_checks
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_CLEANUP
argument_list|(
argument|cmd_stat
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|unload_cleanup
argument_list|(
literal|"k_helper"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ATF_TC_WITH_CLEANUP
argument_list|(
name|cmd_unload
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|cmd_unload
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Tests for the MODCTL_UNLOAD command"
argument_list|)
expr_stmt|;
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"require.user"
argument_list|,
literal|"root"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|cmd_unload
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|load
argument_list|(
name|NULL
argument_list|,
name|true
argument_list|,
literal|"%s/k_helper/k_helper.kmod"
argument_list|,
name|atf_tc_get_config_var
argument_list|(
name|tc
argument_list|,
literal|"srcdir"
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|unload
argument_list|(
literal|""
argument_list|,
name|false
argument_list|)
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|unload
argument_list|(
literal|"non-existent.kmod"
argument_list|,
name|false
argument_list|)
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|unload
argument_list|(
literal|"k_helper.kmod"
argument_list|,
name|false
argument_list|)
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|k_helper_is_present
argument_list|(
name|stat_check
argument_list|)
argument_list|)
expr_stmt|;
name|unload
argument_list|(
literal|"k_helper"
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Checking if unload was successful\n"
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|!
name|k_helper_is_present
argument_list|(
name|stat_check
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_CLEANUP
argument_list|(
argument|cmd_unload
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|unload_cleanup
argument_list|(
literal|"k_helper"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Main                                                                  */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_macro
name|ATF_TP_ADD_TCS
argument_list|(
argument|tp
argument_list|)
end_macro

begin_block
block|{
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|cmd_load
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|cmd_load_props
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|cmd_stat
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|cmd_load_recurse
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|cmd_unload
argument_list|)
expr_stmt|;
return|return
name|atf_no_error
argument_list|()
return|;
block|}
end_block

end_unit

