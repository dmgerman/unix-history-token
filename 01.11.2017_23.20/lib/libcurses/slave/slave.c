begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: slave.c,v 1.6 2011/09/15 11:46:19 blymn Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright 2009 Brett Lymn<blymn@NetBSD.org>  *  * All rights reserved.  *  * This code has been donated to The NetBSD Foundation by the Author.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|"returns.h"
end_include

begin_include
include|#
directive|include
file|"slave.h"
end_include

begin_decl_stmt
name|int
name|cmdpipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|slvpipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char *returns_enum_names[] = { 	"unused", "numeric", "string", "byte", "ERR", "OK", "NULL", "not NULL", 	"variable" };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Read the command pipe for the function to execute, gather the args  * and then process the command.  */
end_comment

begin_function
specifier|static
name|void
name|process_commands
parameter_list|(
name|WINDOW
modifier|*
name|mainscr
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|maxlen
decl_stmt|,
name|argslen
decl_stmt|,
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|type
decl_stmt|;
name|char
modifier|*
name|cmdbuf
decl_stmt|,
modifier|*
name|tmpbuf
decl_stmt|,
modifier|*
modifier|*
name|args
decl_stmt|,
modifier|*
modifier|*
name|tmpargs
decl_stmt|;
name|len
operator|=
name|maxlen
operator|=
literal|30
expr_stmt|;
if|if
condition|(
operator|(
name|cmdbuf
operator|=
name|malloc
argument_list|(
name|maxlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"slave cmdbuf malloc failed"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|cmdpipe
index|[
name|READ_PIPE
index|]
argument_list|,
operator|&
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"slave command type read failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ret_string
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unexpected type for command, got %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|cmdpipe
index|[
name|READ_PIPE
index|]
argument_list|,
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"slave command len read failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|>
name|maxlen
condition|)
block|{
name|maxlen
operator|=
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|tmpbuf
operator|=
name|realloc
argument_list|(
name|cmdbuf
argument_list|,
name|maxlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"slave cmdbuf realloc to %d "
literal|"bytes failed"
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|cmdbuf
operator|=
name|tmpbuf
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|cmdpipe
index|[
name|READ_PIPE
index|]
argument_list|,
name|cmdbuf
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"slave command read failed"
argument_list|)
expr_stmt|;
name|cmdbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|argslen
operator|=
literal|0
expr_stmt|;
name|args
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
name|read
argument_list|(
name|cmdpipe
index|[
name|READ_PIPE
index|]
argument_list|,
operator|&
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"slave arg type read failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|cmdpipe
index|[
name|READ_PIPE
index|]
argument_list|,
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"slave arg len read failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
block|{
name|tmpargs
operator|=
name|realloc
argument_list|(
name|args
argument_list|,
operator|(
name|argslen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpargs
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"slave realloc of args array "
literal|"failed"
argument_list|)
expr_stmt|;
name|args
operator|=
name|tmpargs
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ret_null
condition|)
block|{
name|args
index|[
name|argslen
index|]
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|argslen
index|]
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"slave alloc of %d bytes"
literal|" for args failed"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ret_null
condition|)
name|args
index|[
name|argslen
index|]
operator|=
name|NULL
expr_stmt|;
else|else
name|args
index|[
name|argslen
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|read
argument_list|(
name|cmdpipe
index|[
name|READ_PIPE
index|]
argument_list|,
name|args
index|[
name|argslen
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ret_byte
condition|)
name|args
index|[
name|argslen
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|6
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|args
index|[
name|argslen
index|]
argument_list|,
literal|"STDSCR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|tmpbuf
argument_list|,
literal|"%p"
argument_list|,
name|stdscr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"asprintf of stdscr failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
index|[
name|argslen
index|]
argument_list|)
expr_stmt|;
name|args
index|[
name|argslen
index|]
operator|=
name|tmpbuf
expr_stmt|;
block|}
block|}
block|}
name|argslen
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|len
operator|>=
literal|0
condition|)
do|;
name|command_execute
argument_list|(
name|cmdbuf
argument_list|,
name|argslen
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argslen
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|WINDOW
modifier|*
name|mainscr
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s<cmdin><cmdout><slvin> slvout>\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sscanf
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|cmdpipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|cmdpipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|slvpipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|slvpipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mainscr
operator|=
name|initscr
argument_list|()
expr_stmt|;
if|if
condition|(
name|mainscr
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"initscr failed"
argument_list|)
expr_stmt|;
name|process_commands
argument_list|(
name|mainscr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

