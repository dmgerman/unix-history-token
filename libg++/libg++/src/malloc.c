begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ---------- To make a malloc.h, start cutting here ------------ */
end_comment

begin_comment
comment|/*    A version of malloc/free/realloc written by Doug Lea and released to the    public domain.  Send questions/comments/complaints/performance data   to dl@cs.oswego.edu  * preliminary VERSION 2.6.2q Mon Jan  8 10:28:33 1996  Doug Lea  (dl at gee)       Note: There may be an updated version of this malloc obtainable at            ftp://g.oswego.edu/pub/misc/malloc.c          Check before installing!  * Synopsis of public routines    (Much fuller descriptions are contained in the program documentation below.)    malloc(size_t n);      Return a pointer to a newly allocated chunk of at least n bytes, or null      if no space is available.   free(Void_t* p);      Release the chunk of memory pointed to by p, or no effect if p is null.   realloc(Void_t* p, size_t n);      Return a pointer to a chunk of size n that contains the same data      as does chunk p up to the minimum of (n, p's size) bytes, or null      if no space is available. The returned pointer may or may not be      the same as p. If p is null, equivalent to malloc.  Unless the      #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a      size argument of zero (re)allocates a minimum-sized chunk.   memalign(size_t alignment, size_t n);      Return a pointer to a newly allocated chunk of n bytes, aligned      in accord with the alignment argument, which must be a power of      two.   valloc(size_t n);      Equivalent to memalign(pagesize, n), where pagesize is the page      size of the system (or as near to this as can be figured out from      all the includes/defines below.)   calloc(size_t unit, size_t quantity);      Returns a pointer to quantity * unit bytes, with all locations      set to zero.   cfree(Void_t* p);      Equivalent to free(p).   malloc_trim(size_t pad);      Release all but pad bytes of freed top-most memory back       to the system. Return 1 if successful, else 0.   malloc_usable_size(Void_t* p);      Report the number usable allocated bytes associated with allocated      chunk p. This may or may not report more bytes than were requested,      due to alignment and minimum size constraints.   malloc_stats();      Prints brief summary statistics on stderr.   mallinfo()      Returns (by copy) a struct containing various summary statistics.   mallopt(int parameter_number, int parameter_value)      Changes one of the tunable parameters described below. Returns      1 if successful in changing the parameter, else 0.  * Vital statistics:    Alignment:                            8-byte         8 byte alignment is currently hardwired into the design.  This        seems to suffice for all current machines and C compilers.    Assumed pointer representation:       4 bytes   Assumed size_t  representation:       4 bytes   Minimum overhead per allocated chunk: 4 bytes         Each malloced chunk has a hidden overhead of 4 bytes holding size        and status information.      Minimum allocated size:              16 bytes (12 bytes usable, 4 overhead)         When a chunk is freed, 12 additional bytes are needed; 4 for a        trailing size field and 8 bytes for free list pointers. Thus,        the minimum allocatable size is 16 bytes, of which 12 bytes are        usable. Even a request for zero bytes (i.e., malloc(0)) returns         a pointer to something of the minimum allocatable size.      Maximum allocated size:      2147483640 (2^31 - 8) bytes         It is assumed that (possibly signed) 32 bit values suffice to        represent chunk sizes. `Possibly signed' is due to the fact        that `size_t' may be defined on a system as either a signed or        an unsigned type. To be conservative, values that would appear        as negative numbers are avoided.  The maximum size chunk is        2^31 - 8 bytes.  Requests for negative sizes (when size_t is        signed) or those greater than (2^31 - 8) bytes will return a        minimum-sized chunk.    Maximum overhead wastage per allocated chunk: normally 15 bytes         Alignnment demands, plus the minimum allocatable size restriction        make the normal worst-case wastage 15 bytes (i.e., up to 15        more bytes will be allocated than were requested in malloc), with         two exceptions:          1. Because requests for zero bytes allocate non-zero space,             the worst case wastage for a request of zero bytes is 24 bytes.          2. For requests>= mmap_threshold that are serviced via             mmap(), the worst case wastage is 8 bytes plus the remainder             from a system page (the minimal mmap unit); typically 4096 bytes.   * Synopsis of compile-time options:      People have reported using previous versions of this malloc on all     versions of Unix, sometimes by tweaking some of the defines     below. It has been tested most extensively on Solaris and     Linux. People have also reported adapting this malloc for use in     stand-alone embedded systems.      The implementation is in straight, hand-tuned ANSI C.  Among other     consequences, it uses a lot of macros.  Because of this, to be at     all usable, this code should be compiled using an optimizing compiler     (for example gcc -O2) that can simplify expressions and control     paths.    __STD_C                  (default: derived from C compiler defines)      Nonzero if using ANSI-standard C compiler, a C++ compiler, or      a C compiler sufficiently close to ANSI to get away with it.   DEBUG                    (default: NOT defined)      Define to enable debugging. Adds fairly extensive assertion-based       checking to help track down memory errors, but noticeably slows down      execution.   REALLOC_ZERO_BYTES_FREES (default: NOT defined)       Define this if you think that realloc(p, 0) should be equivalent      to free(p). Otherwise, since malloc returns a unique pointer for      malloc(0), so does realloc(p, 0).   HAVE_MEMCPY               (default: defined)      Define if you are not otherwise using ANSI STD C, but still       have memcpy and memset in your C library and want to use them.      Otherwise, simple internal versions are supplied.   HAVE_MMAP                 (default: defined as 1)      Define to non-zero to optionally make malloc() use mmap() to      allocate very large blocks.     malloc_getpagesize        (default: derived from system #includes)      Either a constant or routine call returning the system page size.   HAVE_USR_INCLUDE_MALLOC_H (default: NOT defined)       Optionally define if you are on a system with a /usr/include/malloc.h      that declares struct mallinfo. It is not at all necessary to      define this even if you do, but will ensure consistency.   INTERNAL_LINUX_C_LIB      (default: NOT defined)      Defined only when compiled as part of Linux libc.      Also note that there is some odd internal name-magling via defines      (for example, internally, `malloc' is named `mALLOc') needed      when compiling in this case. These look funny but don't otherwise      affect anything.   MORECORE                  (default: sbrk)      The name of the routine to call to obtain more memory from the system.   MORECORE_FAILURE          (default: -1)      The value returned upon failure of MORECORE.   DEFAULT_TRIM_THRESHOLD   DEFAULT_TOP_PAD          DEFAULT_MMAP_THRESHOLD   DEFAULT_MMAP_MAX            Default values of tunable parameters (described in detail below)      controlling interaction with host system routines (sbrk, mmap, etc).      These values may also be changed dynamically via mallopt(). The      preset defaults are those that give best performance for typical      programs/systems.   */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Preliminaries */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__STD_C
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|__STD_C
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|__cplusplus
end_if

begin_define
define|#
directive|define
name|__STD_C
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__STD_C
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*__cplusplus*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*__STDC__*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*__STD_C*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|Void_t
end_ifndef

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_define
define|#
directive|define
name|Void_t
value|void
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Void_t
value|char
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*Void_t*/
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* for size_t */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
include|#
directive|include
file|<stdio.h>
comment|/* needed for malloc_stats */
comment|/*   Compile-time options */
comment|/*     Debugging:      Because freed chunks may be overwritten with link fields, this     malloc will often die when freed memory is overwritten by user     programs.  This can be very effective (albeit in an annoying way)     in helping track down dangling pointers.      If you compile with -DDEBUG, a number of assertion checks are     enabled that will catch more memory errors. You probably won't be     able to make much sense of the actual assertion errors, but they     should help you locate incorrectly overwritten memory.  The     checking is fairly extensive, and will slow down execution     noticeably. Calling malloc_stats or mallinfo with DEBUG set will     attempt to check every non-mmapped allocated and free chunk in the     course of computing the summmaries. (By nature, mmapped regions     cannot be checked very much automatically.)      Setting DEBUG may also be helpful if you are trying to modify      this code. The assertions in the check routines spell out in more      detail the assumptions and invariants underlying the algorithms.  */
if|#
directive|if
name|DEBUG
include|#
directive|include
file|<assert.h>
else|#
directive|else
define|#
directive|define
name|assert
parameter_list|(
name|x
parameter_list|)
value|((void)0)
endif|#
directive|endif
comment|/*   REALLOC_ZERO_BYTES_FREES should be set if a call to   realloc with zero bytes should be the same as a call to free.   Some people think it should. Otherwise, since this malloc   returns a unique pointer for malloc(0), so does realloc(p, 0).  */
comment|/*   #define REALLOC_ZERO_BYTES_FREES */
comment|/*   HAVE_MEMCPY should be defined if you are not otherwise using   ANSI STD C, but still have memcpy and memset in your C library   and want to use them in calloc and realloc. Otherwise simple   macro versions are defined here. */
define|#
directive|define
name|HAVE_MEMCPY
if|#
directive|if
name|__STD_C
operator|||
name|defined
argument_list|(
name|HAVE_MEMCPY
argument_list|)
name|void
modifier|*
name|memset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|void
modifier|*
name|memcpy
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
define|#
directive|define
name|MALLOC_ZERO
parameter_list|(
name|charp
parameter_list|,
name|nbytes
parameter_list|)
value|memset(charp, 0, nbytes)
define|#
directive|define
name|MALLOC_COPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|nbytes
parameter_list|)
value|memcpy((dest), (src), (nbytes))
else|#
directive|else
comment|/* We only invoke with multiples of size_t units, with size_t alignment */
define|#
directive|define
name|MALLOC_ZERO
parameter_list|(
name|charp
parameter_list|,
name|nbytes
parameter_list|)
define|\
value|{                                                                             \   size_t* mzp = (size_t*)(charp);                                             \   size_t mzn = (nbytes) / sizeof(size_t);                                     \   while (mzn--> 0) *mzp++ = 0;                                               \ }
define|#
directive|define
name|MALLOC_COPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|nbytes
parameter_list|)
define|\
value|{                                                                             \   size_t* mcsrc = (size_t*) src;                                              \   size_t* mcdst = (size_t*) dest;                                             \   long mcn = (nbytes) / sizeof(size_t);                                       \   while (mcn--> 0) *mcdst++ = *mcsrc++;                                      \ }
endif|#
directive|endif
comment|/*   Define HAVE_MMAP to optionally make malloc() use mmap() to   allocate very large blocks.  These will be returned to the   operating system immediately after a free(). */
ifndef|#
directive|ifndef
name|HAVE_MMAP
define|#
directive|define
name|HAVE_MMAP
value|1
endif|#
directive|endif
if|#
directive|if
name|HAVE_MMAP
include|#
directive|include
file|<unistd.h>
include|#
directive|include
file|<fcntl.h>
include|#
directive|include
file|<sys/mman.h>
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAVE_MMAP */
comment|/*   Access to system page size. To the extent possible, this malloc   manages memory from the system in page-size units.      The following mechanics for getpagesize were adapted from    bsd/gnu getpagesize.h  */
ifndef|#
directive|ifndef
name|malloc_getpagesize
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|DGUX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETPAGESIZE
argument_list|)
specifier|extern
name|size_t
name|getpagesize
parameter_list|()
function_decl|;
define|#
directive|define
name|malloc_getpagesize
value|getpagesize()
else|#
directive|else
include|#
directive|include
file|<sys/param.h>
ifdef|#
directive|ifdef
name|EXEC_PAGESIZE
define|#
directive|define
name|malloc_getpagesize
value|EXEC_PAGESIZE
else|#
directive|else
ifdef|#
directive|ifdef
name|NBPG
ifndef|#
directive|ifndef
name|CLSIZE
define|#
directive|define
name|malloc_getpagesize
value|NBPG
else|#
directive|else
define|#
directive|define
name|malloc_getpagesize
value|(NBPG * CLSIZE)
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|NBPC
define|#
directive|define
name|malloc_getpagesize
value|NBPC
else|#
directive|else
ifdef|#
directive|ifdef
name|PAGESIZE
define|#
directive|define
name|malloc_getpagesize
value|PAGESIZE
else|#
directive|else
define|#
directive|define
name|malloc_getpagesize
value|(4096)
comment|/* just guess */
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/*    This version of malloc supports the standard SVID/XPG mallinfo   routine that returns a struct containing the same kind of   information you can get from malloc_stats. It should work on   any SVID/XPG compliant system that has a /usr/include/malloc.h   defining struct mallinfo. (If you'd like to install such a thing   yourself, cut out the preliminary declarations as described above   and below and save them in a malloc.h file. But there's no   compelling reason to bother to do this.)    The main declaration needed is the mallinfo struct that is returned   (by-copy) by mallinfo().  The SVID/XPG malloinfo struct contains a   bunch of fields, most of which are not even meaningful in this   version of malloc. Some of these fields are are instead filled by   mallinfo() with other numbers that might possibly be of interest.    HAVE_USR_INCLUDE_MALLOC_H should be set if you have a   /usr/include/malloc.h file that includes a declaration of struct   mallinfo.  If so, it is included; else an SVID2/XPG2 compliant   version is declared below.  These must be precisely the same for   mallinfo() to work.  */
comment|/* #define HAVE_USR_INCLUDE_MALLOC_H */
if|#
directive|if
name|HAVE_USR_INCLUDE_MALLOC_H
include|#
directive|include
file|"/usr/include/malloc.h"
else|#
directive|else
comment|/* SVID2/XPG mallinfo structure */
struct|struct
name|mallinfo
block|{
name|int
name|arena
decl_stmt|;
comment|/* total space allocated from system */
name|int
name|ordblks
decl_stmt|;
comment|/* number of non-inuse chunks */
name|int
name|smblks
decl_stmt|;
comment|/* unused -- always zero */
name|int
name|hblks
decl_stmt|;
comment|/* number of mmapped regions */
name|int
name|hblkhd
decl_stmt|;
comment|/* total space in mmapped regions */
name|int
name|usmblks
decl_stmt|;
comment|/* unused -- always zero */
name|int
name|fsmblks
decl_stmt|;
comment|/* unused -- always zero */
name|int
name|uordblks
decl_stmt|;
comment|/* total allocated space */
name|int
name|fordblks
decl_stmt|;
comment|/* total non-inuse space */
name|int
name|keepcost
decl_stmt|;
comment|/* top-most, releasable (via malloc_trim) space */
block|}
struct|;
comment|/* SVID2/XPG mallopt options */
define|#
directive|define
name|M_MXFAST
value|1
comment|/* UNUSED in this malloc */
define|#
directive|define
name|M_NLBLKS
value|2
comment|/* UNUSED in this malloc */
define|#
directive|define
name|M_GRAIN
value|3
comment|/* UNUSED in this malloc */
define|#
directive|define
name|M_KEEP
value|4
comment|/* UNUSED in this malloc */
endif|#
directive|endif
comment|/* mallopt options that actually do something */
define|#
directive|define
name|M_TRIM_THRESHOLD
value|-1
define|#
directive|define
name|M_TOP_PAD
value|-2
define|#
directive|define
name|M_MMAP_THRESHOLD
value|-3
define|#
directive|define
name|M_MMAP_MAX
value|-4
ifndef|#
directive|ifndef
name|DEFAULT_TRIM_THRESHOLD
define|#
directive|define
name|DEFAULT_TRIM_THRESHOLD
value|(1024 * 1024)
endif|#
directive|endif
comment|/*     M_TRIM_THRESHOLD is the maximum amount of unused top-most memory        to keep before releasing via malloc_trim in free().        Automatic trimming is mainly useful in long-lived programs.       Because trimming via sbrk can be slow on some systems, and can       sometimes be wasteful (in cases where programs immediately       afterward allocate more large chunks) the value should be high       enough so that your overall system performance would improve by       releasing.          The trim threshold and the mmap control parameters (see below)       can be traded off with one another. Trimming and mmapping are       two different ways of releasing unused memory back to the       system. Between these two, it is often possible to keep       system-level demands of a long-lived program down to a bare       minimum. For example, in one test suite of sessions measuring       the XF86 X server on Linux, using a trim threshold of 128K and a       mmap threshold of 192K led to near-minimal long term resource       consumption.          If you are using this malloc in a long-lived program, it should       pay to experiment with these values.  As a rough guide, you       might set to a value close to the average size of a process       (program) running on your system.  Releasing this much memory       would allow such a process to run in memory.  Generally, it's       worth it to tune for trimming rather tham memory mapping when a       program undergoes phases where several large chunks are       allocated and released in ways that can reuse each other's       storage, perhaps mixed with phases where there are no such       chunks at all.  And in well-behaved long-lived programs,       controlling release of large blocks via trimming versus mapping       is usually faster.        However, in most programs, these parameters serve mainly as       protection against the system-level effects of carrying around       massive amounts of unneeded memory. Since frequent calls to       sbrk, mmap, and munmap otherwise degrade performance, the default       parameters are set to relatively high values that serve only as       safeguards.        The default trim value is high enough to cause trimming only in       fairly extreme (by current memory consumption standards) cases.       It must be greater than page size to have any useful effect.  To       disable trimming completely, you can set to (unsigned long)(-1);   */
ifndef|#
directive|ifndef
name|DEFAULT_TOP_PAD
define|#
directive|define
name|DEFAULT_TOP_PAD
value|(0)
endif|#
directive|endif
comment|/*     M_TOP_PAD is the amount of extra `padding' space to allocate or        retain whenever sbrk is called. It is used in two ways internally:        * When sbrk is called to extend the top of the arena to satisfy         a new malloc request, this much padding is added to the sbrk         request.        * When malloc_trim is called automatically from free(),         it is used as the `pad' argument.        In both cases, the actual amount of padding is rounded        so that the end of the arena is always a system page boundary.        The main reason for using padding is to avoid calling sbrk so       often. Having even a small pad greatly reduces the likelihood       that nearly every malloc request during program start-up (or       after trimming) will invoke sbrk, which needlessly wastes       time.         Automatic rounding-up to page-size units is normally sufficient       to avoid measurable overhead, so the default is 0.  However, in       systems where sbrk is relatively slow, it can pay to increase       this value, at the expense of carrying around more memory than        the program needs.  */
ifndef|#
directive|ifndef
name|DEFAULT_MMAP_THRESHOLD
define|#
directive|define
name|DEFAULT_MMAP_THRESHOLD
value|(128 * 1024)
endif|#
directive|endif
comment|/*      M_MMAP_THRESHOLD is the request size threshold for using mmap()        to service a request. Requests of at least this size that cannot        be allocated using already-existing space will be serviced via mmap.         (If enough normal freed space already exists it is used instead.)        Using mmap segregates relatively large chunks of memory so that       they can be individually obtained and released from the host       system. A request serviced through mmap is never reused by any       other request (at least not directly; the system may just so       happen to remap successive requests to the same locations).        Segregating space in this way has the benefit that mmapped space       can ALWAYS be individually released back to the system, which       helps keep the system level memory demands of a long-lived       program low. Mapped memory can never become `locked' between       other chunks, as can happen with normally allocated chunks, which       menas that even trimming via malloc_trim would not release them.        However, it has the disadvantages that:           1. The space cannot be reclaimed, consolidated, and then             used to service later requests, as happens with normal chunks.           2. It can lead to more wastage because of mmap page alignment             requirements          3. It causes malloc performance to be more dependent on host             system memory management support routines which may vary in             implementation quality and may impose arbitrary             limitations. Generally, servicing a request via normal             malloc steps is faster than going through a system's mmap.        All together, these considerations should lead you to use mmap       only for relatively large requests.     */
ifndef|#
directive|ifndef
name|DEFAULT_MMAP_MAX
if|#
directive|if
name|HAVE_MMAP
define|#
directive|define
name|DEFAULT_MMAP_MAX
value|(8)
else|#
directive|else
define|#
directive|define
name|DEFAULT_MMAP_MAX
value|(0)
endif|#
directive|endif
endif|#
directive|endif
comment|/*     M_MMAP_MAX is the maximum number of requests to simultaneously        service using mmap. This parameter exists because:           1. Some systems have a limited number of internal tables for             use by mmap.          2. In most systems, overreliance on mmap can degrade overall             performance.          3. If a program allocates many large regions, it is probably             better off using normal sbrk-based allocation routines that             can reclaim and reallocate normal heap memory. Using a             small value allows transition into this mode after the             first few allocations.        Setting to 0 disables all use of mmap.  If HAVE_MMAP is not set,       the default value is 0, and attempts to set it to non-zero values       in mallopt will fail. */
comment|/*     Special defines for linux libc    Except when compiled using these special defines for Linux libc   using weak aliases, this malloc is NOT designed to work in   multithreaded applications.  No semaphores or other concurrency   control are provided to ensure that multiple malloc or free calls   don't run at the same time, which could be disasterous. A single   semaphore could be used across malloc, realloc, and free (which is   essentially the effect of the linux weak alias approach). It would   be hard to obtain finer granularity.  */
ifdef|#
directive|ifdef
name|INTERNAL_LINUX_C_LIB
if|#
directive|if
name|__STD_C
name|Void_t
modifier|*
name|__default_morecore_init
parameter_list|(
name|ptrdiff_t
parameter_list|)
function_decl|;
name|Void_t
modifier|*
function_decl|(
modifier|*
name|__morecore
function_decl|)
parameter_list|(
name|ptrdiff_t
parameter_list|)
init|=
name|__default_morecore_init
function_decl|;
else|#
directive|else
name|Void_t
modifier|*
name|__default_morecore_init
parameter_list|()
function_decl|;
name|Void_t
modifier|*
function_decl|(
modifier|*
name|__morecore
function_decl|)
parameter_list|()
init|=
name|__default_morecore_init
function_decl|;
endif|#
directive|endif
define|#
directive|define
name|MORECORE
value|(*__morecore)
define|#
directive|define
name|MORECORE_FAILURE
value|0
else|#
directive|else
comment|/* INTERNAL_LINUX_C_LIB */
if|#
directive|if
name|__STD_C
specifier|extern
name|Void_t
modifier|*
name|sbrk
parameter_list|(
name|ptrdiff_t
parameter_list|)
function_decl|;
else|#
directive|else
specifier|extern
name|Void_t
modifier|*
name|sbrk
parameter_list|()
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MORECORE
define|#
directive|define
name|MORECORE
value|sbrk
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MORECORE_FAILURE
define|#
directive|define
name|MORECORE_FAILURE
value|-1
endif|#
directive|endif
endif|#
directive|endif
comment|/* INTERNAL_LINUX_C_LIB */
if|#
directive|if
name|defined
argument_list|(
name|INTERNAL_LINUX_C_LIB
argument_list|)
operator|&&
name|defined
argument_list|(
name|__ELF__
argument_list|)
define|#
directive|define
name|cALLOc
value|__libc_calloc
define|#
directive|define
name|fREe
value|__libc_free
define|#
directive|define
name|mALLOc
value|__libc_malloc
define|#
directive|define
name|mEMALIGn
value|__libc_memalign
define|#
directive|define
name|rEALLOc
value|__libc_realloc
define|#
directive|define
name|vALLOc
value|__libc_valloc
define|#
directive|define
name|mALLINFo
value|__libc_mallinfo
define|#
directive|define
name|mALLOPt
value|__libc_mallopt
pragma|#
directive|pragma
name|weak
name|calloc
name|=
name|__libc_calloc
pragma|#
directive|pragma
name|weak
name|free
name|=
name|__libc_free
pragma|#
directive|pragma
name|weak
name|cfree
name|=
name|__libc_free
pragma|#
directive|pragma
name|weak
name|malloc
name|=
name|__libc_malloc
pragma|#
directive|pragma
name|weak
name|memalign
name|=
name|__libc_memalign
pragma|#
directive|pragma
name|weak
name|realloc
name|=
name|__libc_realloc
pragma|#
directive|pragma
name|weak
name|valloc
name|=
name|__libc_valloc
pragma|#
directive|pragma
name|weak
name|mallinfo
name|=
name|__libc_mallinfo
pragma|#
directive|pragma
name|weak
name|mallopt
name|=
name|__libc_mallopt
else|#
directive|else
define|#
directive|define
name|cALLOc
value|calloc
define|#
directive|define
name|fREe
value|free
define|#
directive|define
name|mALLOc
value|malloc
define|#
directive|define
name|mEMALIGn
value|memalign
define|#
directive|define
name|rEALLOc
value|realloc
define|#
directive|define
name|vALLOc
value|valloc
define|#
directive|define
name|mALLINFo
value|mallinfo
define|#
directive|define
name|mALLOPt
value|mallopt
endif|#
directive|endif
comment|/* Public routines */
if|#
directive|if
name|__STD_C
name|Void_t
modifier|*
name|mALLOc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
name|void
name|fREe
parameter_list|(
name|Void_t
modifier|*
parameter_list|)
function_decl|;
name|Void_t
modifier|*
name|rEALLOc
parameter_list|(
name|Void_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|Void_t
modifier|*
name|mEMALIGn
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|Void_t
modifier|*
name|vALLOc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
name|Void_t
modifier|*
name|cALLOc
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|void
name|cfree
parameter_list|(
name|Void_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|malloc_trim
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
name|size_t
name|malloc_usable_size
parameter_list|(
name|Void_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|malloc_stats
parameter_list|()
function_decl|;
name|int
name|mALLOPt
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|struct
name|mallinfo
name|mALLINFo
parameter_list|(
name|void
parameter_list|)
function_decl|;
else|#
directive|else
name|Void_t
modifier|*
name|mALLOc
parameter_list|()
function_decl|;
name|void
name|fREe
parameter_list|()
function_decl|;
name|Void_t
modifier|*
name|rEALLOc
parameter_list|()
function_decl|;
name|Void_t
modifier|*
name|mEMALIGn
parameter_list|()
function_decl|;
name|Void_t
modifier|*
name|vALLOc
parameter_list|()
function_decl|;
name|Void_t
modifier|*
name|cALLOc
parameter_list|()
function_decl|;
name|void
name|cfree
parameter_list|()
function_decl|;
name|int
name|malloc_trim
parameter_list|()
function_decl|;
name|size_t
name|malloc_usable_size
parameter_list|()
function_decl|;
name|void
name|malloc_stats
parameter_list|()
function_decl|;
name|int
name|mALLOPt
parameter_list|()
function_decl|;
name|struct
name|mallinfo
name|mALLINFo
parameter_list|()
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* end of extern "C" */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ---------- To make a malloc.h, end cutting here ------------ */
end_comment

begin_escape
end_escape

begin_comment
comment|/*   Type declarations */
end_comment

begin_struct
struct|struct
name|malloc_chunk
block|{
name|size_t
name|size
decl_stmt|;
comment|/* Size in bytes, including overhead. */
name|struct
name|malloc_chunk
modifier|*
name|fd
decl_stmt|;
comment|/* double links -- used only if free. */
name|struct
name|malloc_chunk
modifier|*
name|bk
decl_stmt|;
name|size_t
name|unused
decl_stmt|;
comment|/* to pad decl to min chunk size */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|malloc_chunk
modifier|*
name|mchunkptr
typedef|;
end_typedef

begin_comment
comment|/*     malloc_chunk details:      (The following includes lightly edited explanations by Colin Plumb.)      Chunks of memory are maintained using a `boundary tag' method as     described in e.g., Knuth or Standish.  (See the paper by Paul     Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a     survey of such techniques.)  Sizes of free chunks are stored both     in the front of each chunk and at the end.  This makes     consolidating fragmented chunks into bigger chunks very fast.  The     size fields also hold bits representing whether chunks are free or     in use.      An allocated chunk looks like this:         chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of chunk, in bytes                         |P|       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             User data starts here...                          .             .                                                               .             .             (malloc_usable_space() bytes)                     .             .                                                               | nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of next chunk                              |1|             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       Where "chunk" is the front of the chunk for the purpose of most of     the malloc code, but "mem" is the pointer that is returned to the     user.  "Nextchunk" is the beginning of the next contiguous chunk.      Chunks always begin on odd-word boundries, so the mem portion     (which is returned to the user) is on an even word boundary, and     thus double-word aligned.      Free chunks are stored in circular doubly-linked lists, and look like this:      chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     `head:' |             Size of chunk, in bytes                         |P|       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Forward pointer to next chunk in list             |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Back pointer to previous chunk in list            |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Unused space (may be 0 bytes long)                .             .                                                               .             .                                                               |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     `foot:' |             Size of chunk, in bytes                           | nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of next chunk                              |0|             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      The P (PREV_INUSE) bit, stored in the unused low-order bit of the     chunk size (which is always a multiple of two words), is an in-use     bit for the *previous* chunk.  If that bit is *clear*, then the     word before the current chunk size contains the previous chunk     size, and can be used to find the front of the previous chunk.     (The very first chunk allocated always has this bit set,     preventing access to non-existent (or non-owned) memory.)      The two exceptions to all this are        1. The special chunk `top', which doesn't bother using the          trailing size field since there is no         next contiguous chunk that would have to index off it. (After         initialization, `top' is forced to always exist.  If it would         become less than MINSIZE bytes long, it is replenished via         malloc_extend_top.)       2. Chunks allocated via mmap, which have the second-lowest-order         bit (IS_MMAPPED) set in their size fields.  Because they are         never merged or traversed from any other chunk, they have no         foot size or inuse information.      Available chunks are kept in any of several places (all declared below):      * `av': An array of chunks serving as bin headers for consolidated        chunks. Each bin is doubly linked.  The bins are approximately        proportionally (log) spaced.  There are a lot of these bins        (128). This may look excessive, but works very well in        practice.  All procedures maintain the invariant that no        consolidated chunk physically borders another one. Chunks in        bins are kept in size order, with ties going to the        approximately least recently used chunk.         The chunks in each bin are maintained in decreasing sorted order by        size.  This is irrelevant for the small bins, which all contain        the same-sized chunks, but facilitates best-fit allocation for        larger chunks. (These lists are just sequential. Keeping them in        order almost never requires enough traversal to warrant using        fancier ordered data structures.)  Chunks of the same size are        linked with the most recently freed at the front, and allocations        are taken from the back.  This results in LRU or FIFO allocation        order, which tends to give each chunk an equal opportunity to be        consolidated with adjacent freed chunks, resulting in larger free        chunks and less fragmentation.       * `top': The top-most available chunk (i.e., the one bordering the        end of available memory) is treated specially. It is never        included in any bin, is used only if no other chunk is        available, and is released back to the system if it is very        large (see M_TRIM_THRESHOLD).      * `last_remainder': A bin holding only the remainder of the        most recently split (non-top) chunk. This bin is checked        before other non-fitting chunks, so as to provide better        locality for runs of sequentially allocated chunks.       *  Implicitly, through the host system's memory mapping tables.        If supported, requests greater than a threshold are usually         serviced via calls to mmap, and then later released via munmap.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  sizes, alignments */
end_comment

begin_define
define|#
directive|define
name|SIZE_SZ
value|(sizeof(size_t))
end_define

begin_define
define|#
directive|define
name|MALLOC_ALIGNMENT
value|(SIZE_SZ + SIZE_SZ)
end_define

begin_define
define|#
directive|define
name|MALLOC_ALIGN_MASK
value|(MALLOC_ALIGNMENT - 1)
end_define

begin_define
define|#
directive|define
name|MINSIZE
value|(sizeof(struct malloc_chunk))
end_define

begin_comment
comment|/* conversion from malloc headers to user pointers, and back */
end_comment

begin_define
define|#
directive|define
name|chunk2mem
parameter_list|(
name|p
parameter_list|)
value|((Void_t*)((char*)(p) + SIZE_SZ))
end_define

begin_define
define|#
directive|define
name|mem2chunk
parameter_list|(
name|mem
parameter_list|)
value|((mchunkptr)((char*)(mem) - SIZE_SZ))
end_define

begin_comment
comment|/* pad request bytes into a usable size */
end_comment

begin_define
define|#
directive|define
name|request2size
parameter_list|(
name|req
parameter_list|)
define|\
value|(((long)(req)< (long)(MINSIZE - SIZE_SZ)) ?  MINSIZE : \    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK)& ~(MALLOC_ALIGN_MASK)))
end_define

begin_comment
comment|/* Check if m has acceptable alignment */
end_comment

begin_define
define|#
directive|define
name|aligned_OK
parameter_list|(
name|m
parameter_list|)
value|(((size_t)((m))& (MALLOC_ALIGN_MASK)) == 0)
end_define

begin_escape
end_escape

begin_comment
comment|/*    Physical chunk operations   */
end_comment

begin_comment
comment|/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
end_comment

begin_define
define|#
directive|define
name|PREV_INUSE
value|0x1
end_define

begin_comment
comment|/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
end_comment

begin_define
define|#
directive|define
name|IS_MMAPPED
value|0x2
end_define

begin_comment
comment|/* Bits to mask off when extracting size */
end_comment

begin_define
define|#
directive|define
name|SIZE_BITS
value|(PREV_INUSE|IS_MMAPPED)
end_define

begin_comment
comment|/* Ptr to next physical malloc_chunk. */
end_comment

begin_define
define|#
directive|define
name|next_chunk
parameter_list|(
name|p
parameter_list|)
value|((mchunkptr)( ((char*)(p)) + ((p)->size& ~PREV_INUSE) ))
end_define

begin_comment
comment|/* Ptr to previous physical malloc_chunk */
end_comment

begin_define
define|#
directive|define
name|prev_chunk
parameter_list|(
name|p
parameter_list|)
define|\
value|((mchunkptr)( ((char*)(p)) - *((size_t*)((char*)(p) - SIZE_SZ))))
end_define

begin_comment
comment|/* Treat space at ptr + offset as a chunk */
end_comment

begin_define
define|#
directive|define
name|chunk_at_offset
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|((mchunkptr)(((char*)(p)) + (s)))
end_define

begin_escape
end_escape

begin_comment
comment|/*    Dealing with use bits  */
end_comment

begin_comment
comment|/* extract p's inuse bit */
end_comment

begin_define
define|#
directive|define
name|inuse
parameter_list|(
name|p
parameter_list|)
define|\
value|((((mchunkptr)(((char*)(p))+((p)->size& ~PREV_INUSE)))->size)& PREV_INUSE)
end_define

begin_comment
comment|/* extract inuse bit of previous chunk */
end_comment

begin_define
define|#
directive|define
name|prev_inuse
parameter_list|(
name|p
parameter_list|)
value|((p)->size& PREV_INUSE)
end_define

begin_comment
comment|/* check for mmap()'ed chunk */
end_comment

begin_define
define|#
directive|define
name|chunk_is_mmapped
parameter_list|(
name|p
parameter_list|)
value|((p)->size& IS_MMAPPED)
end_define

begin_comment
comment|/* set/clear chunk as in use without otherwise disturbing */
end_comment

begin_define
define|#
directive|define
name|set_inuse
parameter_list|(
name|p
parameter_list|)
define|\
value|((mchunkptr)(((char*)(p)) + ((p)->size& ~PREV_INUSE)))->size |= PREV_INUSE
end_define

begin_define
define|#
directive|define
name|clear_inuse
parameter_list|(
name|p
parameter_list|)
define|\
value|((mchunkptr)(((char*)(p)) + ((p)->size& ~PREV_INUSE)))->size&= ~(PREV_INUSE)
end_define

begin_comment
comment|/* check/set/clear inuse bits in known places */
end_comment

begin_define
define|#
directive|define
name|inuse_bit_at_offset
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|(((mchunkptr)(((char*)(p)) + (s)))->size& PREV_INUSE)
end_define

begin_define
define|#
directive|define
name|set_inuse_bit_at_offset
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|(((mchunkptr)(((char*)(p)) + (s)))->size |= PREV_INUSE)
end_define

begin_define
define|#
directive|define
name|clear_inuse_bit_at_offset
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|(((mchunkptr)(((char*)(p)) + (s)))->size&= ~(PREV_INUSE))
end_define

begin_escape
end_escape

begin_comment
comment|/*    Dealing with size fields  */
end_comment

begin_comment
comment|/* Get size, ignoring use bits */
end_comment

begin_define
define|#
directive|define
name|chunksize
parameter_list|(
name|p
parameter_list|)
value|((p)->size& ~(SIZE_BITS))
end_define

begin_comment
comment|/* Set size at head, without disturbing its use bit */
end_comment

begin_define
define|#
directive|define
name|set_head_size
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|((p)->size = (((p)->size& PREV_INUSE) | (s)))
end_define

begin_comment
comment|/* Set size/use ignoring previous bits in header */
end_comment

begin_define
define|#
directive|define
name|set_head
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|((p)->size = (s))
end_define

begin_comment
comment|/* Set size at footer (only when chunk is not in use) */
end_comment

begin_define
define|#
directive|define
name|set_foot
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|(*((size_t*)((char*)(p) + (s) - SIZE_SZ)) = (s))
end_define

begin_comment
comment|/* Get size of previous (but not inuse) chunk */
end_comment

begin_define
define|#
directive|define
name|prev_size
parameter_list|(
name|p
parameter_list|)
value|(*((size_t*)((char*)(p) - SIZE_SZ)))
end_define

begin_escape
end_escape

begin_comment
comment|/*    Bins      The bins, `av_' are an array of pairs of pointers serving as the     heads of (initially empty) doubly-linked lists of chunks, laid out     in a way so that each pair can be treated as if it were in a     malloc_chunk. (This way, the fd/bk offsets for linking bin heads     and chunks are the same).      Bins for sizes< 512 bytes contain chunks of all the same size, spaced     8 bytes apart. Larger bins are approximately logarithmically     spaced. (See the table below.) The `av_' array is never mentioned     directly in the code, but instead via bin access macros.      Bin layout:      64 bins of size       8     32 bins of size      64     16 bins of size     512      8 bins of size    4096      4 bins of size   32768      2 bins of size  262144      1 bin  of size what's left      There is actually a little bit of slop in the numbers in bin_index     for the sake of speed. This makes no difference elsewhere.      The special chunks `top' and `last_remainder' get their own bins,     (this is implemented via yet more trickery with the av_ array),     although `top' is never properly linked to its bin since it is     always handled specially.  */
end_comment

begin_define
define|#
directive|define
name|NAV
value|128
end_define

begin_comment
comment|/* number of bins */
end_comment

begin_typedef
typedef|typedef
name|struct
name|malloc_chunk
modifier|*
name|mbinptr
typedef|;
end_typedef

begin_comment
comment|/* access macros */
end_comment

begin_define
define|#
directive|define
name|bin_at
parameter_list|(
name|i
parameter_list|)
value|((mbinptr)(&(av_[2 * (i)])))
end_define

begin_define
define|#
directive|define
name|next_bin
parameter_list|(
name|b
parameter_list|)
value|((mbinptr)((char*)(b) + 2 * sizeof(mbinptr)))
end_define

begin_comment
comment|/*    The first 2 bins are never indexed. The corresponding av_ cells are instead    used for bookkeeping. This is not to save space, but to simplify    indexing, maintain locality, and avoid some initialization tests. */
end_comment

begin_define
define|#
directive|define
name|top
value|(bin_at(0)->fd)
end_define

begin_comment
comment|/* The topmost chunk */
end_comment

begin_define
define|#
directive|define
name|last_remainder
value|(bin_at(1))
end_define

begin_comment
comment|/* remainder from last split */
end_comment

begin_comment
comment|/*    Because top initially points to its own bin with initial    zero size, thus forcing extension on the first malloc request,     we avoid having any special code in malloc to check whether     it even exists yet. But we still need to in malloc_extend_top. */
end_comment

begin_define
define|#
directive|define
name|initial_top
value|((mchunkptr)(av_))
end_define

begin_comment
comment|/* Helper macro to initialize bins */
end_comment

begin_define
define|#
directive|define
name|IAV
parameter_list|(
name|i
parameter_list|)
value|(mbinptr)(av_ + 2 * i), (mbinptr)(av_ + 2 * i)
end_define

begin_decl_stmt
specifier|static
name|mbinptr
name|av_
index|[
name|NAV
operator|*
literal|2
operator|+
literal|2
index|]
init|=
block|{
literal|0
block|,
name|IAV
argument_list|(
literal|0
argument_list|)
block|,
name|IAV
argument_list|(
literal|1
argument_list|)
block|,
name|IAV
argument_list|(
literal|2
argument_list|)
block|,
name|IAV
argument_list|(
literal|3
argument_list|)
block|,
name|IAV
argument_list|(
literal|4
argument_list|)
block|,
name|IAV
argument_list|(
literal|5
argument_list|)
block|,
name|IAV
argument_list|(
literal|6
argument_list|)
block|,
name|IAV
argument_list|(
literal|7
argument_list|)
block|,
name|IAV
argument_list|(
literal|8
argument_list|)
block|,
name|IAV
argument_list|(
literal|9
argument_list|)
block|,
name|IAV
argument_list|(
literal|10
argument_list|)
block|,
name|IAV
argument_list|(
literal|11
argument_list|)
block|,
name|IAV
argument_list|(
literal|12
argument_list|)
block|,
name|IAV
argument_list|(
literal|13
argument_list|)
block|,
name|IAV
argument_list|(
literal|14
argument_list|)
block|,
name|IAV
argument_list|(
literal|15
argument_list|)
block|,
name|IAV
argument_list|(
literal|16
argument_list|)
block|,
name|IAV
argument_list|(
literal|17
argument_list|)
block|,
name|IAV
argument_list|(
literal|18
argument_list|)
block|,
name|IAV
argument_list|(
literal|19
argument_list|)
block|,
name|IAV
argument_list|(
literal|20
argument_list|)
block|,
name|IAV
argument_list|(
literal|21
argument_list|)
block|,
name|IAV
argument_list|(
literal|22
argument_list|)
block|,
name|IAV
argument_list|(
literal|23
argument_list|)
block|,
name|IAV
argument_list|(
literal|24
argument_list|)
block|,
name|IAV
argument_list|(
literal|25
argument_list|)
block|,
name|IAV
argument_list|(
literal|26
argument_list|)
block|,
name|IAV
argument_list|(
literal|27
argument_list|)
block|,
name|IAV
argument_list|(
literal|28
argument_list|)
block|,
name|IAV
argument_list|(
literal|29
argument_list|)
block|,
name|IAV
argument_list|(
literal|30
argument_list|)
block|,
name|IAV
argument_list|(
literal|31
argument_list|)
block|,
name|IAV
argument_list|(
literal|32
argument_list|)
block|,
name|IAV
argument_list|(
literal|33
argument_list|)
block|,
name|IAV
argument_list|(
literal|34
argument_list|)
block|,
name|IAV
argument_list|(
literal|35
argument_list|)
block|,
name|IAV
argument_list|(
literal|36
argument_list|)
block|,
name|IAV
argument_list|(
literal|37
argument_list|)
block|,
name|IAV
argument_list|(
literal|38
argument_list|)
block|,
name|IAV
argument_list|(
literal|39
argument_list|)
block|,
name|IAV
argument_list|(
literal|40
argument_list|)
block|,
name|IAV
argument_list|(
literal|41
argument_list|)
block|,
name|IAV
argument_list|(
literal|42
argument_list|)
block|,
name|IAV
argument_list|(
literal|43
argument_list|)
block|,
name|IAV
argument_list|(
literal|44
argument_list|)
block|,
name|IAV
argument_list|(
literal|45
argument_list|)
block|,
name|IAV
argument_list|(
literal|46
argument_list|)
block|,
name|IAV
argument_list|(
literal|47
argument_list|)
block|,
name|IAV
argument_list|(
literal|48
argument_list|)
block|,
name|IAV
argument_list|(
literal|49
argument_list|)
block|,
name|IAV
argument_list|(
literal|50
argument_list|)
block|,
name|IAV
argument_list|(
literal|51
argument_list|)
block|,
name|IAV
argument_list|(
literal|52
argument_list|)
block|,
name|IAV
argument_list|(
literal|53
argument_list|)
block|,
name|IAV
argument_list|(
literal|54
argument_list|)
block|,
name|IAV
argument_list|(
literal|55
argument_list|)
block|,
name|IAV
argument_list|(
literal|56
argument_list|)
block|,
name|IAV
argument_list|(
literal|57
argument_list|)
block|,
name|IAV
argument_list|(
literal|58
argument_list|)
block|,
name|IAV
argument_list|(
literal|59
argument_list|)
block|,
name|IAV
argument_list|(
literal|60
argument_list|)
block|,
name|IAV
argument_list|(
literal|61
argument_list|)
block|,
name|IAV
argument_list|(
literal|62
argument_list|)
block|,
name|IAV
argument_list|(
literal|63
argument_list|)
block|,
name|IAV
argument_list|(
literal|64
argument_list|)
block|,
name|IAV
argument_list|(
literal|65
argument_list|)
block|,
name|IAV
argument_list|(
literal|66
argument_list|)
block|,
name|IAV
argument_list|(
literal|67
argument_list|)
block|,
name|IAV
argument_list|(
literal|68
argument_list|)
block|,
name|IAV
argument_list|(
literal|69
argument_list|)
block|,
name|IAV
argument_list|(
literal|70
argument_list|)
block|,
name|IAV
argument_list|(
literal|71
argument_list|)
block|,
name|IAV
argument_list|(
literal|72
argument_list|)
block|,
name|IAV
argument_list|(
literal|73
argument_list|)
block|,
name|IAV
argument_list|(
literal|74
argument_list|)
block|,
name|IAV
argument_list|(
literal|75
argument_list|)
block|,
name|IAV
argument_list|(
literal|76
argument_list|)
block|,
name|IAV
argument_list|(
literal|77
argument_list|)
block|,
name|IAV
argument_list|(
literal|78
argument_list|)
block|,
name|IAV
argument_list|(
literal|79
argument_list|)
block|,
name|IAV
argument_list|(
literal|80
argument_list|)
block|,
name|IAV
argument_list|(
literal|81
argument_list|)
block|,
name|IAV
argument_list|(
literal|82
argument_list|)
block|,
name|IAV
argument_list|(
literal|83
argument_list|)
block|,
name|IAV
argument_list|(
literal|84
argument_list|)
block|,
name|IAV
argument_list|(
literal|85
argument_list|)
block|,
name|IAV
argument_list|(
literal|86
argument_list|)
block|,
name|IAV
argument_list|(
literal|87
argument_list|)
block|,
name|IAV
argument_list|(
literal|88
argument_list|)
block|,
name|IAV
argument_list|(
literal|89
argument_list|)
block|,
name|IAV
argument_list|(
literal|90
argument_list|)
block|,
name|IAV
argument_list|(
literal|91
argument_list|)
block|,
name|IAV
argument_list|(
literal|92
argument_list|)
block|,
name|IAV
argument_list|(
literal|93
argument_list|)
block|,
name|IAV
argument_list|(
literal|94
argument_list|)
block|,
name|IAV
argument_list|(
literal|95
argument_list|)
block|,
name|IAV
argument_list|(
literal|96
argument_list|)
block|,
name|IAV
argument_list|(
literal|97
argument_list|)
block|,
name|IAV
argument_list|(
literal|98
argument_list|)
block|,
name|IAV
argument_list|(
literal|99
argument_list|)
block|,
name|IAV
argument_list|(
literal|100
argument_list|)
block|,
name|IAV
argument_list|(
literal|101
argument_list|)
block|,
name|IAV
argument_list|(
literal|102
argument_list|)
block|,
name|IAV
argument_list|(
literal|103
argument_list|)
block|,
name|IAV
argument_list|(
literal|104
argument_list|)
block|,
name|IAV
argument_list|(
literal|105
argument_list|)
block|,
name|IAV
argument_list|(
literal|106
argument_list|)
block|,
name|IAV
argument_list|(
literal|107
argument_list|)
block|,
name|IAV
argument_list|(
literal|108
argument_list|)
block|,
name|IAV
argument_list|(
literal|109
argument_list|)
block|,
name|IAV
argument_list|(
literal|110
argument_list|)
block|,
name|IAV
argument_list|(
literal|111
argument_list|)
block|,
name|IAV
argument_list|(
literal|112
argument_list|)
block|,
name|IAV
argument_list|(
literal|113
argument_list|)
block|,
name|IAV
argument_list|(
literal|114
argument_list|)
block|,
name|IAV
argument_list|(
literal|115
argument_list|)
block|,
name|IAV
argument_list|(
literal|116
argument_list|)
block|,
name|IAV
argument_list|(
literal|117
argument_list|)
block|,
name|IAV
argument_list|(
literal|118
argument_list|)
block|,
name|IAV
argument_list|(
literal|119
argument_list|)
block|,
name|IAV
argument_list|(
literal|120
argument_list|)
block|,
name|IAV
argument_list|(
literal|121
argument_list|)
block|,
name|IAV
argument_list|(
literal|122
argument_list|)
block|,
name|IAV
argument_list|(
literal|123
argument_list|)
block|,
name|IAV
argument_list|(
literal|124
argument_list|)
block|,
name|IAV
argument_list|(
literal|125
argument_list|)
block|,
name|IAV
argument_list|(
literal|126
argument_list|)
block|,
name|IAV
argument_list|(
literal|127
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* field-extraction macros */
end_comment

begin_define
define|#
directive|define
name|first
parameter_list|(
name|b
parameter_list|)
value|((b)->fd)
end_define

begin_define
define|#
directive|define
name|last
parameter_list|(
name|b
parameter_list|)
value|((b)->bk)
end_define

begin_comment
comment|/*    Indexing into bins */
end_comment

begin_define
define|#
directive|define
name|bin_index
parameter_list|(
name|sz
parameter_list|)
define|\
value|(((((unsigned long)(sz))>> 9) ==    0) ?       (((unsigned long)(sz))>>  3): \  ((((unsigned long)(sz))>> 9)<=    4) ?  56 + (((unsigned long)(sz))>>  6): \  ((((unsigned long)(sz))>> 9)<=   20) ?  91 + (((unsigned long)(sz))>>  9): \  ((((unsigned long)(sz))>> 9)<=   84) ? 110 + (((unsigned long)(sz))>> 12): \  ((((unsigned long)(sz))>> 9)<=  340) ? 119 + (((unsigned long)(sz))>> 15): \  ((((unsigned long)(sz))>> 9)<= 1364) ? 124 + (((unsigned long)(sz))>> 18): \                                           126)
end_define

begin_comment
comment|/*    bins for chunks< 512 are all spaced 8 bytes apart, and hold   identically sized chunks. This is exploited in malloc. */
end_comment

begin_define
define|#
directive|define
name|MAX_SMALLBIN
value|63
end_define

begin_define
define|#
directive|define
name|MAX_SMALLBIN_SIZE
value|512
end_define

begin_define
define|#
directive|define
name|SMALLBIN_WIDTH
value|8
end_define

begin_define
define|#
directive|define
name|smallbin_index
parameter_list|(
name|sz
parameter_list|)
value|(((unsigned long)(sz))>> 3)
end_define

begin_comment
comment|/*     Requests are `small' if both the corresponding and the next bin are small */
end_comment

begin_define
define|#
directive|define
name|is_small_request
parameter_list|(
name|nb
parameter_list|)
value|(nb< MAX_SMALLBIN_SIZE - SMALLBIN_WIDTH)
end_define

begin_escape
end_escape

begin_comment
comment|/*     To help compensate for the large number of bins, a one-level index     structure is used for bin-by-bin searching.  `binblocks' is a     one-word bitvector recording whether groups of BINBLOCKWIDTH bins     have any (possibly) non-empty bins, so they can be skipped over     all at once during during traversals. The bits are NOT always     cleared as soon as all bins in a block are empty, but instead only     when all are noticed to be empty during traversal in malloc. */
end_comment

begin_define
define|#
directive|define
name|BINBLOCKWIDTH
value|4
end_define

begin_comment
comment|/* bins per block */
end_comment

begin_define
define|#
directive|define
name|binblocks
value|(bin_at(0)->size)
end_define

begin_comment
comment|/* bitvector of nonempty blocks */
end_comment

begin_comment
comment|/* bin<->block macros */
end_comment

begin_define
define|#
directive|define
name|idx2binblock
parameter_list|(
name|ix
parameter_list|)
value|(1<< (ix / BINBLOCKWIDTH))
end_define

begin_define
define|#
directive|define
name|mark_binblock
parameter_list|(
name|ii
parameter_list|)
value|(binblocks |= idx2binblock(ii))
end_define

begin_define
define|#
directive|define
name|clear_binblock
parameter_list|(
name|ii
parameter_list|)
value|(binblocks&= ~(idx2binblock(ii)))
end_define

begin_escape
end_escape

begin_comment
comment|/*  Other static bookkeeping data */
end_comment

begin_comment
comment|/* variables holding tunable values */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|trim_threshold
init|=
name|DEFAULT_TRIM_THRESHOLD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|top_pad
init|=
name|DEFAULT_TOP_PAD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_mmaps_max
init|=
name|DEFAULT_MMAP_MAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|mmap_threshold
init|=
name|DEFAULT_MMAP_THRESHOLD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first value returned from sbrk */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sbrk_base
init|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum memory obtained from system via sbrk */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|max_sbrked_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum via either sbrk or mmap */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|max_total_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal working copy of mallinfo */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mallinfo
name|current_mallinfo
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The total memory obtained from system via sbrk */
end_comment

begin_define
define|#
directive|define
name|sbrked_mem
value|(current_mallinfo.arena)
end_define

begin_comment
comment|/* Tracking mmaps */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_mmaps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_n_mmaps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|mmapped_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|max_mmapped_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*    Debugging support  */
end_comment

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_comment
comment|/*   These routines make a number of assertions about the states   of data structures that should be true at all times. If any   are not true, it's very likely that a user program has somehow   trashed memory. (It's also possible that there is a coding error   in malloc. In which case, please report it!) */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
specifier|static
name|void
name|do_check_chunk
parameter_list|(
name|mchunkptr
name|p
parameter_list|)
else|#
directive|else
function|static void do_check_chunk
parameter_list|(
name|p
parameter_list|)
name|mchunkptr
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|sz
init|=
name|p
operator|->
name|size
operator|&
operator|~
name|PREV_INUSE
decl_stmt|;
comment|/* No checkable chunk is mmapped */
name|assert
argument_list|(
operator|!
name|chunk_is_mmapped
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for legal address ... */
name|assert
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|>=
name|sbrk_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|top
condition|)
name|assert
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|sz
operator|<=
operator|(
name|char
operator|*
operator|)
name|top
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|sz
operator|<=
name|sbrk_base
operator|+
name|sbrked_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
specifier|static
name|void
name|do_check_free_chunk
parameter_list|(
name|mchunkptr
name|p
parameter_list|)
else|#
directive|else
function|static void do_check_free_chunk
parameter_list|(
name|p
parameter_list|)
name|mchunkptr
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|sz
init|=
name|p
operator|->
name|size
operator|&
operator|~
name|PREV_INUSE
decl_stmt|;
name|mchunkptr
name|next
init|=
name|chunk_at_offset
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
decl_stmt|;
name|do_check_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Check whether it claims to be free ... */
name|assert
argument_list|(
operator|!
name|inuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless a special marker, must have OK fields */
if|if
condition|(
operator|(
name|long
operator|)
name|sz
operator|>=
operator|(
name|long
operator|)
name|MINSIZE
condition|)
block|{
name|assert
argument_list|(
operator|(
name|sz
operator|&
name|MALLOC_ALIGN_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
call|(
name|size_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|SIZE_SZ
argument_list|)
operator|)
operator|&
name|MALLOC_ALIGN_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* ... matching footer field */
name|assert
argument_list|(
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|sz
operator|-
name|SIZE_SZ
operator|)
operator|)
operator|==
name|sz
argument_list|)
expr_stmt|;
comment|/* ... and is fully consolidated */
name|assert
argument_list|(
name|prev_inuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|next
operator|==
name|top
operator|||
name|inuse
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... and has minimally sane links */
name|assert
argument_list|(
name|p
operator|->
name|fd
operator|->
name|bk
operator|==
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|bk
operator|->
name|fd
operator|==
name|p
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* markers are always of size SIZE_SZ */
name|assert
argument_list|(
name|sz
operator|==
name|SIZE_SZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
specifier|static
name|void
name|do_check_inuse_chunk
parameter_list|(
name|mchunkptr
name|p
parameter_list|)
else|#
directive|else
function|static void do_check_inuse_chunk
parameter_list|(
name|p
parameter_list|)
name|mchunkptr
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|mchunkptr
name|next
init|=
name|next_chunk
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|do_check_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Check whether it claims to be in use ... */
name|assert
argument_list|(
name|inuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... and is surrounded by OK chunks.     Since more things can be checked with free chunks than inuse ones,     if an inuse chunk borders them and debug is on, it's worth doing them.   */
if|if
condition|(
operator|!
name|prev_inuse
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|mchunkptr
name|prv
init|=
name|prev_chunk
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|next_chunk
argument_list|(
name|prv
argument_list|)
operator|==
name|p
argument_list|)
expr_stmt|;
name|do_check_free_chunk
argument_list|(
name|prv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|==
name|top
condition|)
name|assert
argument_list|(
name|prev_inuse
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|inuse
argument_list|(
name|next
argument_list|)
condition|)
name|do_check_free_chunk
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
specifier|static
name|void
name|do_check_malloced_chunk
parameter_list|(
name|mchunkptr
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
else|#
directive|else
function|static void do_check_malloced_chunk
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|mchunkptr
name|p
decl_stmt|;
name|size_t
name|s
decl_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|sz
init|=
name|p
operator|->
name|size
operator|&
operator|~
name|PREV_INUSE
decl_stmt|;
name|long
name|room
init|=
name|sz
operator|-
name|s
decl_stmt|;
name|do_check_inuse_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Legal size ... */
name|assert
argument_list|(
operator|(
name|long
operator|)
name|sz
operator|>=
operator|(
name|long
operator|)
name|MINSIZE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|sz
operator|&
name|MALLOC_ALIGN_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|room
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|room
operator|<
operator|(
name|long
operator|)
name|MINSIZE
argument_list|)
expr_stmt|;
comment|/* ... and alignment */
name|assert
argument_list|(
operator|(
operator|(
call|(
name|size_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|SIZE_SZ
argument_list|)
operator|)
operator|&
name|MALLOC_ALIGN_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* ... and was allocated at front of an available chunk */
name|assert
argument_list|(
name|prev_inuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|check_free_chunk
parameter_list|(
name|P
parameter_list|)
value|do_check_free_chunk(P)
end_define

begin_define
define|#
directive|define
name|check_inuse_chunk
parameter_list|(
name|P
parameter_list|)
value|do_check_inuse_chunk(P)
end_define

begin_define
define|#
directive|define
name|check_chunk
parameter_list|(
name|P
parameter_list|)
value|do_check_chunk(P)
end_define

begin_define
define|#
directive|define
name|check_malloced_chunk
parameter_list|(
name|P
parameter_list|,
name|N
parameter_list|)
value|do_check_malloced_chunk(P,N)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|check_free_chunk
parameter_list|(
name|P
parameter_list|)
end_define

begin_define
define|#
directive|define
name|check_inuse_chunk
parameter_list|(
name|P
parameter_list|)
end_define

begin_define
define|#
directive|define
name|check_chunk
parameter_list|(
name|P
parameter_list|)
end_define

begin_define
define|#
directive|define
name|check_malloced_chunk
parameter_list|(
name|P
parameter_list|,
name|N
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*    Macro-based internal utilities */
end_comment

begin_comment
comment|/*     Linking chunks in bin lists.   Call these only with variables, not arbitrary expressions, as arguments. */
end_comment

begin_comment
comment|/*    Place chunk p of size s in its bin, in size order,   putting it ahead of others of same size. */
end_comment

begin_define
define|#
directive|define
name|frontlink
parameter_list|(
name|P
parameter_list|,
name|S
parameter_list|,
name|IDX
parameter_list|,
name|BK
parameter_list|,
name|FD
parameter_list|)
define|\
value|{                                                                             \   if (S< MAX_SMALLBIN_SIZE)                                                  \   {                                                                           \     IDX = smallbin_index(S);                                                  \     mark_binblock(IDX);                                                       \     BK = bin_at(IDX);                                                         \     FD = BK->fd;                                                              \     P->bk = BK;                                                               \     P->fd = FD;                                                               \     FD->bk = BK->fd = P;                                                      \   }                                                                           \   else                                                                        \   {                                                                           \     IDX = bin_index(S);                                                       \     BK = bin_at(IDX);                                                         \     FD = BK->fd;                                                              \     if (FD == BK) mark_binblock(IDX);                                         \     else                                                                      \     {                                                                         \       while (FD != BK&& S< chunksize(FD)) FD = FD->fd;                      \       BK = FD->bk;                                                            \     }                                                                         \     P->bk = BK;                                                               \     P->fd = FD;                                                               \     FD->bk = BK->fd = P;                                                      \   }                                                                           \ }
end_define

begin_comment
comment|/* take a chunk off a list */
end_comment

begin_define
define|#
directive|define
name|unlink
parameter_list|(
name|P
parameter_list|,
name|BK
parameter_list|,
name|FD
parameter_list|)
define|\
value|{                                                                             \   BK = P->bk;                                                                 \   FD = P->fd;                                                                 \   FD->bk = BK;                                                                \   BK->fd = FD;                                                                \ }
end_define

begin_comment
unit|\
comment|/* Place p as the last remainder */
end_comment

begin_define
define|#
directive|define
name|link_last_remainder
parameter_list|(
name|P
parameter_list|)
define|\
value|{                                                                             \   last_remainder->fd = last_remainder->bk =  P;                               \   P->fd = P->bk = last_remainder;                                             \ }
end_define

begin_comment
comment|/* Clear the last_remainder bin */
end_comment

begin_define
define|#
directive|define
name|clear_last_remainder
define|\
value|(last_remainder->fd = last_remainder->bk = last_remainder)
end_define

begin_escape
end_escape

begin_comment
comment|/* Routines dealing with mmap(). */
end_comment

begin_if
if|#
directive|if
name|HAVE_MMAP
end_if

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
specifier|static
name|mchunkptr
name|mmap_chunk
parameter_list|(
name|size_t
name|size
parameter_list|)
else|#
directive|else
function|static mchunkptr mmap_chunk
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|offset
init|=
operator|(
name|MALLOC_ALIGNMENT
operator|)
operator|-
name|SIZE_SZ
decl_stmt|;
name|size_t
name|page_mask
init|=
name|malloc_getpagesize
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|mchunkptr
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|MAP_ANONYMOUS
specifier|static
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n_mmaps
operator|>=
name|n_mmaps_max
condition|)
return|return
literal|0
return|;
comment|/* too many regions */
comment|/* The offset to the start of the mmapped region is stored    * in a size_t field immediately before the chunk.    */
name|size
operator|=
operator|(
name|size
operator|+
name|offset
operator|+
name|page_mask
operator|)
operator|&
operator|~
name|page_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|MAP_ANONYMOUS
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !MAP_ANONYMOUS */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|n_mmaps
operator|++
expr_stmt|;
if|if
condition|(
name|n_mmaps
operator|>
name|max_n_mmaps
condition|)
name|max_n_mmaps
operator|=
name|n_mmaps
expr_stmt|;
name|p
operator|=
call|(
name|mchunkptr
call|)
argument_list|(
name|cp
operator|+
name|offset
argument_list|)
expr_stmt|;
comment|/* We demand that eight bytes into a page must be 8-byte aligned. */
name|assert
argument_list|(
name|aligned_OK
argument_list|(
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|p
operator|-
literal|1
operator|)
operator|=
name|offset
expr_stmt|;
name|set_head
argument_list|(
name|p
argument_list|,
operator|(
name|size
operator|-
name|offset
operator|)
operator||
name|IS_MMAPPED
argument_list|)
expr_stmt|;
name|mmapped_mem
operator|+=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|mmapped_mem
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max_mmapped_mem
condition|)
name|max_mmapped_mem
operator|=
name|mmapped_mem
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|mmapped_mem
operator|+
name|sbrked_mem
argument_list|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max_total_mem
condition|)
name|max_total_mem
operator|=
name|mmapped_mem
operator|+
name|sbrked_mem
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
specifier|static
name|void
name|munmap_chunk
parameter_list|(
name|mchunkptr
name|p
parameter_list|)
else|#
directive|else
function|static void munmap_chunk
parameter_list|(
name|p
parameter_list|)
name|mchunkptr
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|offset
init|=
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|p
operator|-
literal|1
operator|)
decl_stmt|;
name|size_t
name|size
init|=
name|chunksize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|assert
argument_list|(
name|chunk_is_mmapped
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|>=
name|sbrk_base
operator|&&
operator|(
name|char
operator|*
operator|)
name|p
operator|<
name|sbrk_base
operator|+
name|sbrked_mem
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|n_mmaps
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|size
operator|+
name|offset
operator|)
operator|&
operator|(
name|malloc_getpagesize
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|munmap
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|-
name|offset
argument_list|,
name|size
operator|+
name|offset
argument_list|)
expr_stmt|;
comment|/* munmap returns non-zero on failure */
name|assert
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
name|n_mmaps
operator|--
expr_stmt|;
name|mmapped_mem
operator|-=
operator|(
name|size
operator|+
name|offset
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MMAP */
end_comment

begin_escape
end_escape

begin_comment
comment|/*    Extend the top-most chunk by obtaining memory from system.   Main interface to sbrk (but see also malloc_trim). */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
specifier|static
name|void
name|malloc_extend_top
parameter_list|(
name|size_t
name|nb
parameter_list|)
else|#
directive|else
function|static void malloc_extend_top
parameter_list|(
name|nb
parameter_list|)
name|size_t
name|nb
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|brk
decl_stmt|;
comment|/* return value from sbrk */
name|size_t
name|front_misalign
decl_stmt|;
comment|/* unusable bytes at front of sbrked space */
name|size_t
name|correction
decl_stmt|;
comment|/* bytes for 2nd sbrk call */
name|char
modifier|*
name|new_brk
decl_stmt|;
comment|/* return of 2nd sbrk call */
name|size_t
name|top_size
decl_stmt|;
comment|/* new size of top chunk */
name|mchunkptr
name|old_top
init|=
name|top
decl_stmt|;
comment|/* Record state of old top */
name|size_t
name|old_top_size
init|=
name|chunksize
argument_list|(
name|old_top
argument_list|)
decl_stmt|;
name|char
modifier|*
name|old_end
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|chunk_at_offset
argument_list|(
name|old_top
argument_list|,
name|old_top_size
argument_list|)
operator|)
decl_stmt|;
comment|/* Pad request with top_pad plus minimal overhead */
name|size_t
name|sbrk_size
init|=
name|nb
operator|+
name|top_pad
operator|+
name|MINSIZE
decl_stmt|;
name|unsigned
name|long
name|pagesz
init|=
name|malloc_getpagesize
decl_stmt|;
comment|/* If not the first time through, round to preserve page boundary */
comment|/* Otherwise, we need to correct to a page size below anyway. */
comment|/* (We also correct below if an intervening foreign sbrk call.) */
if|if
condition|(
name|sbrk_base
operator|!=
operator|(
name|char
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
condition|)
name|sbrk_size
operator|=
operator|(
name|sbrk_size
operator|+
operator|(
name|pagesz
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|pagesz
operator|-
literal|1
operator|)
expr_stmt|;
name|brk
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|MORECORE
argument_list|(
name|sbrk_size
argument_list|)
operator|)
expr_stmt|;
comment|/* Fail if sbrk failed or if a foreign sbrk call killed our space */
if|if
condition|(
name|brk
operator|==
operator|(
name|char
operator|*
operator|)
operator|(
name|MORECORE_FAILURE
operator|)
operator|||
operator|(
name|brk
operator|<
name|old_end
operator|&&
name|old_top
operator|!=
name|initial_top
operator|)
condition|)
return|return;
name|sbrked_mem
operator|+=
name|sbrk_size
expr_stmt|;
if|if
condition|(
name|brk
operator|==
name|old_end
condition|)
comment|/* can just add bytes to current top */
block|{
name|top_size
operator|=
name|sbrk_size
operator|+
name|old_top_size
expr_stmt|;
name|set_head
argument_list|(
name|top
argument_list|,
name|top_size
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sbrk_base
operator|==
operator|(
name|char
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
condition|)
comment|/* First time through. Record base */
name|sbrk_base
operator|=
name|brk
expr_stmt|;
else|else
comment|/* Someone else called sbrk().  Count those bytes as sbrked_mem. */
name|sbrked_mem
operator|+=
name|brk
operator|-
operator|(
name|char
operator|*
operator|)
name|old_end
expr_stmt|;
comment|/* Guarantee alignment of first new chunk made from this space */
name|front_misalign
operator|=
operator|(
name|size_t
operator|)
name|chunk2mem
argument_list|(
name|brk
argument_list|)
operator|&
name|MALLOC_ALIGN_MASK
expr_stmt|;
if|if
condition|(
name|front_misalign
operator|>
literal|0
condition|)
block|{
name|correction
operator|=
operator|(
name|MALLOC_ALIGNMENT
operator|)
operator|-
name|front_misalign
expr_stmt|;
name|brk
operator|+=
name|correction
expr_stmt|;
block|}
else|else
name|correction
operator|=
literal|0
expr_stmt|;
comment|/* Guarantee the next brk will be at a page boundary */
name|correction
operator|+=
name|pagesz
operator|-
operator|(
call|(
name|size_t
call|)
argument_list|(
name|brk
operator|+
name|sbrk_size
argument_list|)
operator|&
operator|(
name|pagesz
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Allocate correction */
name|new_brk
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|MORECORE
argument_list|(
name|correction
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_brk
operator|==
operator|(
name|char
operator|*
operator|)
operator|(
name|MORECORE_FAILURE
operator|)
condition|)
return|return;
name|sbrked_mem
operator|+=
name|correction
expr_stmt|;
name|top
operator|=
operator|(
name|mchunkptr
operator|)
name|brk
expr_stmt|;
name|top_size
operator|=
name|new_brk
operator|-
name|brk
operator|+
name|correction
expr_stmt|;
name|set_head
argument_list|(
name|top
argument_list|,
name|top_size
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_top
operator|!=
name|initial_top
condition|)
block|{
comment|/* There must have been an intervening foreign sbrk call. */
comment|/* A double fencepost is necessary to prevent consolidation */
name|chunk_at_offset
argument_list|(
name|old_top
argument_list|,
name|old_top_size
operator|-
literal|2
operator|*
name|SIZE_SZ
argument_list|)
operator|->
name|size
operator|=
name|SIZE_SZ
operator||
name|PREV_INUSE
expr_stmt|;
name|chunk_at_offset
argument_list|(
name|old_top
argument_list|,
name|old_top_size
operator|-
name|SIZE_SZ
argument_list|)
operator|->
name|size
operator|=
name|SIZE_SZ
operator||
name|PREV_INUSE
expr_stmt|;
comment|/* Also keep size a multiple of MINSIZE */
name|old_top_size
operator|=
operator|(
name|old_top_size
operator|-
literal|2
operator|*
name|SIZE_SZ
operator|)
operator|&
name|MALLOC_ALIGN_MASK
expr_stmt|;
name|chunk_at_offset
argument_list|(
name|old_top
argument_list|,
name|old_top_size
argument_list|)
operator|->
name|size
operator|=
name|SIZE_SZ
operator||
name|PREV_INUSE
expr_stmt|;
name|chunk_at_offset
argument_list|(
name|old_top
argument_list|,
name|old_top_size
operator|+
name|SIZE_SZ
argument_list|)
operator|->
name|size
operator|=
name|SIZE_SZ
operator||
name|PREV_INUSE
expr_stmt|;
name|set_head_size
argument_list|(
name|old_top
argument_list|,
name|old_top_size
argument_list|)
expr_stmt|;
comment|/* If possible, release the rest. */
if|if
condition|(
name|old_top_size
operator|>=
name|MINSIZE
condition|)
name|fREe
argument_list|(
name|chunk2mem
argument_list|(
name|old_top
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|sbrked_mem
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max_sbrked_mem
condition|)
name|max_sbrked_mem
operator|=
name|sbrked_mem
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|mmapped_mem
operator|+
name|sbrked_mem
argument_list|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|max_total_mem
condition|)
name|max_total_mem
operator|=
name|mmapped_mem
operator|+
name|sbrked_mem
expr_stmt|;
comment|/* We always land on a page boundary */
name|assert
argument_list|(
operator|(
call|(
name|size_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|top
operator|+
name|top_size
argument_list|)
operator|&
operator|(
name|pagesz
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main public routines */
end_comment

begin_comment
comment|/*   Malloc Algorthim:      The requested size is first converted into a usable form, `nb'.     This currently means to add 4 bytes overhead plus possibly more to     obtain 8-byte alignment and/or to obtain a size of at least     MINSIZE (currently 16 bytes), the smallest allocatable size.     (All fits are considered `exact' if they are within MINSIZE bytes.)      From there, the first successful of the following steps is taken:        1. The bin corresponding to the request size is scanned, and if          a chunk of exactly the right size is found, it is taken.        2. The most recently remaindered chunk is used if it is big          enough.  This is a form of (roving) first fit, used only in          the absence of exact fits. Runs of consecutive requests use          the remainder of the chunk used for the previous such request          whenever possible. This limited use of a first-fit style          allocation strategy tends to give contiguous chunks          coextensive lifetimes, which improves locality and can reduce          fragmentation in the long run.        3. Other bins are scanned in increasing size order, using a          chunk big enough to fulfill the request, and splitting off          any remainder.  This search is strictly by best-fit; i.e.,          the smallest (with ties going to approximately the least          recently used) chunk that fits is selected.        4. If large enough, the chunk bordering the end of memory          (`top') is split off. (This use of `top' is in accord with          the best-fit search rule.  In effect, `top' is treated as          larger (and thus less well fitting) than any other available          chunk since it can be extended to be as large as necessary          (up to system limitations).        5. If the request size meets the mmap threshold and the          system supports mmap, and there are few enough currently          allocated mmapped regions, and a call to mmap succeeds,          the request is allocated via direct memory mapping.        6. Otherwise, the top of memory is extended by          obtaining more space from the system (normally using sbrk,          but definable to anything else via the MORECORE macro).          Memory is gathered from the system (in system page-sized          units) in a way that allows chunks obtained across different          sbrk calls to be consolidated, but does not require          contiguous memory. Thus, it should be safe to intersperse          mallocs with other sbrk calls.         All allocations are made from the the `lowest' part of any found       chunk. (The implementation invariant is that prev_inuse is       always true of any allocated chunk; i.e., that each allocated       chunk borders either a previously allocated and still in-use chunk,       or the base of its memory arena.)  */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|Void_t
modifier|*
name|mALLOc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
else|#
directive|else
function|Void_t* mALLOc
parameter_list|(
name|bytes
parameter_list|)
name|size_t
name|bytes
decl_stmt|;
endif|#
directive|endif
block|{
name|mchunkptr
name|victim
decl_stmt|;
comment|/* inspected/selected chunk */
name|size_t
name|victim_size
decl_stmt|;
comment|/* its size */
name|int
name|idx
decl_stmt|;
comment|/* index for bin traversal */
name|mbinptr
name|bin
decl_stmt|;
comment|/* associated bin */
name|mchunkptr
name|remainder
decl_stmt|;
comment|/* remainder from a split */
name|long
name|remainder_size
decl_stmt|;
comment|/* its size */
name|int
name|remainder_index
decl_stmt|;
comment|/* its bin index */
name|unsigned
name|long
name|block
decl_stmt|;
comment|/* block traverser bit */
name|int
name|startidx
decl_stmt|;
comment|/* first bin of a traversed block */
name|mchunkptr
name|fwd
decl_stmt|;
comment|/* misc temp for linking */
name|mchunkptr
name|bck
decl_stmt|;
comment|/* misc temp for linking */
name|size_t
name|nb
init|=
name|request2size
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
comment|/* padded request size; */
comment|/* Check for exact match in a bin */
if|if
condition|(
name|is_small_request
argument_list|(
name|nb
argument_list|)
condition|)
comment|/* Faster version for small requests */
block|{
name|idx
operator|=
name|smallbin_index
argument_list|(
name|nb
argument_list|)
expr_stmt|;
comment|/* No traversal or size check necessary for small bins.  */
comment|/* Also scan the next one, since it would have a remainder< MINSIZE */
if|if
condition|(
operator|(
operator|(
name|victim
operator|=
name|last
argument_list|(
name|bin_at
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|)
operator|!=
name|bin_at
argument_list|(
name|idx
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|victim
operator|=
name|last
argument_list|(
name|bin_at
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|!=
name|bin_at
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|victim_size
operator|=
name|chunksize
argument_list|(
name|victim
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|victim
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|set_inuse_bit_at_offset
argument_list|(
name|victim
argument_list|,
name|victim_size
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|victim
argument_list|)
return|;
block|}
name|idx
operator|+=
literal|2
expr_stmt|;
comment|/* Set for bin scan below. We've already scanned 2 bins. */
block|}
else|else
block|{
name|idx
operator|=
name|bin_index
argument_list|(
name|nb
argument_list|)
expr_stmt|;
name|bin
operator|=
name|bin_at
argument_list|(
name|idx
argument_list|)
expr_stmt|;
for|for
control|(
name|victim
operator|=
name|last
argument_list|(
name|bin
argument_list|)
init|;
name|victim
operator|!=
name|bin
condition|;
name|victim
operator|=
name|victim
operator|->
name|bk
control|)
block|{
name|victim_size
operator|=
name|chunksize
argument_list|(
name|victim
argument_list|)
expr_stmt|;
name|remainder_size
operator|=
name|victim_size
operator|-
name|nb
expr_stmt|;
if|if
condition|(
name|remainder_size
operator|>=
operator|(
name|long
operator|)
name|MINSIZE
condition|)
comment|/* too big */
block|{
operator|--
name|idx
expr_stmt|;
comment|/* adjust to rescan below after checking last remainder */
break|break;
block|}
elseif|else
if|if
condition|(
name|remainder_size
operator|>=
literal|0
condition|)
comment|/* exact fit */
block|{
name|unlink
argument_list|(
name|victim
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|set_inuse_bit_at_offset
argument_list|(
name|victim
argument_list|,
name|victim_size
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|victim
argument_list|)
return|;
block|}
block|}
operator|++
name|idx
expr_stmt|;
block|}
comment|/* Try to use the last split-off remainder */
if|if
condition|(
operator|(
name|victim
operator|=
name|last_remainder
operator|->
name|fd
operator|)
operator|!=
name|last_remainder
condition|)
block|{
name|victim_size
operator|=
name|chunksize
argument_list|(
name|victim
argument_list|)
expr_stmt|;
name|remainder_size
operator|=
name|victim_size
operator|-
name|nb
expr_stmt|;
if|if
condition|(
name|remainder_size
operator|>=
operator|(
name|long
operator|)
name|MINSIZE
condition|)
comment|/* re-split */
block|{
name|remainder
operator|=
name|chunk_at_offset
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_head
argument_list|(
name|victim
argument_list|,
name|nb
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|link_last_remainder
argument_list|(
name|remainder
argument_list|)
expr_stmt|;
name|set_head
argument_list|(
name|remainder
argument_list|,
name|remainder_size
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|set_foot
argument_list|(
name|remainder
argument_list|,
name|remainder_size
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|victim
argument_list|)
return|;
block|}
name|clear_last_remainder
expr_stmt|;
if|if
condition|(
name|remainder_size
operator|>=
literal|0
condition|)
comment|/* exhaust */
block|{
name|set_inuse_bit_at_offset
argument_list|(
name|victim
argument_list|,
name|victim_size
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|victim
argument_list|)
return|;
block|}
comment|/* Else place in bin */
name|frontlink
argument_list|(
name|victim
argument_list|,
name|victim_size
argument_list|,
name|remainder_index
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
block|}
comment|/*       If there are any possibly nonempty big-enough blocks,       search for best fitting chunk by scanning bins in blockwidth units.   */
if|if
condition|(
operator|(
name|block
operator|=
name|idx2binblock
argument_list|(
name|idx
argument_list|)
operator|)
operator|<=
name|binblocks
condition|)
block|{
comment|/* Get to the first marked block */
if|if
condition|(
operator|(
name|block
operator|&
name|binblocks
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* force to an even block boundary */
name|idx
operator|=
operator|(
name|idx
operator|&
operator|~
operator|(
name|BINBLOCKWIDTH
operator|-
literal|1
operator|)
operator|)
operator|+
name|BINBLOCKWIDTH
expr_stmt|;
name|block
operator|<<=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|block
operator|&
name|binblocks
operator|)
operator|==
literal|0
condition|)
block|{
name|idx
operator|+=
name|BINBLOCKWIDTH
expr_stmt|;
name|block
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
comment|/* For each possibly nonempty block ... */
for|for
control|(
init|;
condition|;
control|)
block|{
name|startidx
operator|=
name|idx
expr_stmt|;
comment|/* (track incomplete blocks) */
comment|/* For each bin in this block ... */
do|do
block|{
name|bin
operator|=
name|bin_at
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|/* Find and use first big enough chunk ... */
for|for
control|(
name|victim
operator|=
name|last
argument_list|(
name|bin
argument_list|)
init|;
name|victim
operator|!=
name|bin
condition|;
name|victim
operator|=
name|victim
operator|->
name|bk
control|)
block|{
name|victim_size
operator|=
name|chunksize
argument_list|(
name|victim
argument_list|)
expr_stmt|;
name|remainder_size
operator|=
name|victim_size
operator|-
name|nb
expr_stmt|;
if|if
condition|(
name|remainder_size
operator|>=
operator|(
name|long
operator|)
name|MINSIZE
condition|)
comment|/* split */
block|{
name|remainder
operator|=
name|chunk_at_offset
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_head
argument_list|(
name|victim
argument_list|,
name|nb
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|victim
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|link_last_remainder
argument_list|(
name|remainder
argument_list|)
expr_stmt|;
name|set_head
argument_list|(
name|remainder
argument_list|,
name|remainder_size
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|set_foot
argument_list|(
name|remainder
argument_list|,
name|remainder_size
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|victim
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|remainder_size
operator|>=
literal|0
condition|)
comment|/* take */
block|{
name|set_inuse_bit_at_offset
argument_list|(
name|victim
argument_list|,
name|victim_size
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|victim
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|victim
argument_list|)
return|;
block|}
block|}
block|}
do|while
condition|(
operator|(
operator|++
name|idx
operator|&
operator|(
name|BINBLOCKWIDTH
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
do|;
comment|/* Clear out the block bit. */
do|do
comment|/* Possibly backtrack to try to clear a partial block */
block|{
if|if
condition|(
operator|(
name|startidx
operator|&
operator|(
name|BINBLOCKWIDTH
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|binblocks
operator|&=
operator|~
name|block
expr_stmt|;
break|break;
block|}
operator|--
name|startidx
expr_stmt|;
block|}
do|while
condition|(
name|first
argument_list|(
name|bin_at
argument_list|(
name|startidx
argument_list|)
argument_list|)
operator|==
name|bin_at
argument_list|(
name|startidx
argument_list|)
condition|)
do|;
comment|/* Get to the next possibly nonempty block */
if|if
condition|(
operator|(
name|block
operator|<<=
literal|1
operator|)
operator|<=
name|binblocks
operator|&&
operator|(
name|block
operator|!=
literal|0
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|block
operator|&
name|binblocks
operator|)
operator|==
literal|0
condition|)
block|{
name|idx
operator|+=
name|BINBLOCKWIDTH
expr_stmt|;
name|block
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
block|}
comment|/* Try to use top chunk */
comment|/* Require that there be a remainder, ensuring top always exists  */
if|if
condition|(
operator|(
name|remainder_size
operator|=
name|chunksize
argument_list|(
name|top
argument_list|)
operator|-
name|nb
operator|)
operator|<
operator|(
name|long
operator|)
name|MINSIZE
condition|)
block|{
if|#
directive|if
name|HAVE_MMAP
comment|/* If big and would otherwise need to extend, try to use mmap instead */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|nb
operator|>=
operator|(
name|unsigned
name|long
operator|)
name|mmap_threshold
operator|&&
operator|(
name|victim
operator|=
name|mmap_chunk
argument_list|(
name|nb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|chunk2mem
argument_list|(
name|victim
argument_list|)
return|;
endif|#
directive|endif
comment|/* Try to extend */
name|malloc_extend_top
argument_list|(
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|remainder_size
operator|=
name|chunksize
argument_list|(
name|top
argument_list|)
operator|-
name|nb
operator|)
operator|<
operator|(
name|long
operator|)
name|MINSIZE
condition|)
return|return
literal|0
return|;
comment|/* propagate failure */
block|}
name|victim
operator|=
name|top
expr_stmt|;
name|set_head
argument_list|(
name|victim
argument_list|,
name|nb
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|top
operator|=
name|chunk_at_offset
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_head
argument_list|(
name|top
argument_list|,
name|remainder_size
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|check_malloced_chunk
argument_list|(
name|victim
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|victim
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*    free() algorithm :      cases:         1. free(0) has no effect.           2. If the chunk was allocated via mmap, it is release via munmap().         3. If a returned chunk borders the current high end of memory,           it is consolidated into the top, and if the total unused           topmost memory exceeds the trim threshold, malloc_trim is           called.         4. Other chunks are consolidated as they arrive, and           placed in corresponding bins. (This includes the case of           consolidating with the current `last_remainder').  */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|void
name|fREe
parameter_list|(
name|Void_t
modifier|*
name|mem
parameter_list|)
else|#
directive|else
function|void fREe
parameter_list|(
name|mem
parameter_list|)
name|Void_t
modifier|*
name|mem
decl_stmt|;
endif|#
directive|endif
block|{
name|mchunkptr
name|p
decl_stmt|;
comment|/* chunk corresponding to mem */
name|size_t
name|hd
decl_stmt|;
comment|/* its head field */
name|size_t
name|sz
decl_stmt|;
comment|/* its size */
name|int
name|idx
decl_stmt|;
comment|/* its bin index */
name|mchunkptr
name|next
decl_stmt|;
comment|/* next contiguous chunk */
name|size_t
name|nextsz
decl_stmt|;
comment|/* its size */
name|size_t
name|prevsz
decl_stmt|;
comment|/* size of previous contiguous chunk */
name|mchunkptr
name|bck
decl_stmt|;
comment|/* misc temp for linking */
name|mchunkptr
name|fwd
decl_stmt|;
comment|/* misc temp for linking */
name|int
name|islr
decl_stmt|;
comment|/* track whther merging with last_remainder */
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
comment|/* free(0) has no effect */
return|return;
name|p
operator|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|hd
operator|=
name|p
operator|->
name|size
expr_stmt|;
if|#
directive|if
name|HAVE_MMAP
if|if
condition|(
name|hd
operator|&
name|IS_MMAPPED
condition|)
comment|/* release mmapped memory. */
block|{
name|munmap_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|check_inuse_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sz
operator|=
name|hd
operator|&
operator|~
name|PREV_INUSE
expr_stmt|;
name|next
operator|=
name|chunk_at_offset
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|nextsz
operator|=
name|chunksize
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|top
condition|)
comment|/* merge with top */
block|{
name|sz
operator|+=
name|nextsz
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hd
operator|&
name|PREV_INUSE
operator|)
condition|)
comment|/* consolidate backward */
block|{
name|prevsz
operator|=
name|prev_size
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|chunk_at_offset
argument_list|(
name|p
argument_list|,
operator|-
name|prevsz
argument_list|)
expr_stmt|;
name|sz
operator|+=
name|prevsz
expr_stmt|;
name|unlink
argument_list|(
name|p
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
block|}
name|set_head
argument_list|(
name|p
argument_list|,
name|sz
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|top
operator|=
name|p
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sz
argument_list|)
operator|>=
operator|(
name|unsigned
name|long
operator|)
name|trim_threshold
condition|)
name|malloc_trim
argument_list|(
name|top_pad
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_head
argument_list|(
name|next
argument_list|,
name|nextsz
argument_list|)
expr_stmt|;
comment|/* clear inuse bit */
name|islr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hd
operator|&
name|PREV_INUSE
operator|)
condition|)
comment|/* consolidate backward */
block|{
name|prevsz
operator|=
name|prev_size
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|chunk_at_offset
argument_list|(
name|p
argument_list|,
operator|-
name|prevsz
argument_list|)
expr_stmt|;
name|sz
operator|+=
name|prevsz
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fd
operator|==
name|last_remainder
condition|)
comment|/* keep as last_remainder */
name|islr
operator|=
literal|1
expr_stmt|;
else|else
name|unlink
argument_list|(
name|p
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|inuse_bit_at_offset
argument_list|(
name|next
argument_list|,
name|nextsz
argument_list|)
operator|)
condition|)
comment|/* consolidate forward */
block|{
name|sz
operator|+=
name|nextsz
expr_stmt|;
if|if
condition|(
operator|!
name|islr
operator|&&
name|next
operator|->
name|fd
operator|==
name|last_remainder
condition|)
comment|/* re-insert last_remainder */
block|{
name|islr
operator|=
literal|1
expr_stmt|;
name|link_last_remainder
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|unlink
argument_list|(
name|next
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
block|}
name|set_head
argument_list|(
name|p
argument_list|,
name|sz
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|set_foot
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|islr
condition|)
name|frontlink
argument_list|(
name|p
argument_list|,
name|sz
argument_list|,
name|idx
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*    Realloc algorithm:      If the reallocation is for additional space, and the chunk can be     extended, it is, else a malloc-copy-free sequence is taken.  There     are several different ways that a chunk could be extended. All are     tried:         * Extending forward into following adjacent free chunk.        * Shifting backwards, joining preceding adjacent space        * Both shifting backwards and extending forward.        * Extending into newly sbrked space       If the reallocation is for less space, the trailing space is     lopped off and freed.  Unless the #define REALLOC_ZERO_BYTES_FREES     is set, realloc with a size argument of zero (re)allocates a     minimum-sized chunk.      Chunks that were obtained via mmap cannot be extended or shrunk.     If their reallocation is for additional space, they are copied.     If for less, they are just left alone.      The old unix realloc convention of allowing the last-free'd chunk     to be used as an argument to realloc is no longer supported.     I don't know of any programs still relying on this feature,     and allowing it would also allow too many other incorrect      usages of realloc to be sensible.   */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|Void_t
modifier|*
name|rEALLOc
parameter_list|(
name|Void_t
modifier|*
name|oldmem
parameter_list|,
name|size_t
name|bytes
parameter_list|)
else|#
directive|else
function|Void_t* rEALLOc
parameter_list|(
name|oldmem
parameter_list|,
name|bytes
parameter_list|)
name|Void_t
modifier|*
name|oldmem
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|nb
decl_stmt|;
comment|/* padded request size */
name|mchunkptr
name|oldp
decl_stmt|;
comment|/* chunk corresponding to oldmem */
name|size_t
name|oldsize
decl_stmt|;
comment|/* its size */
name|mchunkptr
name|newp
decl_stmt|;
comment|/* chunk to return */
name|size_t
name|newsize
decl_stmt|;
comment|/* its size */
name|Void_t
modifier|*
name|newmem
decl_stmt|;
comment|/* corresponding user mem */
name|mchunkptr
name|next
decl_stmt|;
comment|/* next contiguous chunk after oldp */
name|size_t
name|nextsize
decl_stmt|;
comment|/* its size */
name|mchunkptr
name|prev
decl_stmt|;
comment|/* previous contiguous chunk before oldp */
name|size_t
name|prevsize
decl_stmt|;
comment|/* its size */
name|mchunkptr
name|remainder
decl_stmt|;
comment|/* holds split off extra space from newp */
name|size_t
name|remainder_size
decl_stmt|;
comment|/* its size */
name|mchunkptr
name|bck
decl_stmt|;
comment|/* misc temp for linking */
name|mchunkptr
name|fwd
decl_stmt|;
comment|/* misc temp for linking */
ifdef|#
directive|ifdef
name|REALLOC_ZERO_BYTES_FREES
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|fREe
argument_list|(
name|oldmem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* realloc of null is supposed to be same as malloc */
if|if
condition|(
name|oldmem
operator|==
literal|0
condition|)
return|return
name|mALLOc
argument_list|(
name|bytes
argument_list|)
return|;
name|newp
operator|=
name|oldp
operator|=
name|mem2chunk
argument_list|(
name|oldmem
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|oldsize
operator|=
name|chunksize
argument_list|(
name|oldp
argument_list|)
expr_stmt|;
name|nb
operator|=
name|request2size
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_MMAP
if|if
condition|(
name|chunk_is_mmapped
argument_list|(
name|oldp
argument_list|)
condition|)
block|{
if|if
condition|(
name|oldsize
operator|>=
name|nb
condition|)
return|return
name|oldmem
return|;
comment|/* do nothing */
comment|/* Must alloc, copy, free. */
name|newmem
operator|=
name|mALLOc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* propagate failure */
name|MALLOC_COPY
argument_list|(
name|newmem
argument_list|,
name|oldmem
argument_list|,
name|oldsize
operator|-
name|SIZE_SZ
argument_list|)
expr_stmt|;
name|munmap_chunk
argument_list|(
name|oldp
argument_list|)
expr_stmt|;
return|return
name|newmem
return|;
block|}
endif|#
directive|endif
name|check_inuse_chunk
argument_list|(
name|oldp
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|oldsize
argument_list|)
operator|<
call|(
name|long
call|)
argument_list|(
name|nb
argument_list|)
condition|)
block|{
comment|/* Try expanding forward */
name|next
operator|=
name|chunk_at_offset
argument_list|(
name|oldp
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|top
operator|||
operator|!
name|inuse
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|nextsize
operator|=
name|chunksize
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Forward into top only if a remainder */
if|if
condition|(
name|next
operator|==
name|top
condition|)
block|{
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|nextsize
operator|+
name|newsize
argument_list|)
operator|>=
call|(
name|long
call|)
argument_list|(
name|nb
operator|+
name|MINSIZE
argument_list|)
condition|)
block|{
name|newsize
operator|+=
name|nextsize
expr_stmt|;
name|top
operator|=
name|chunk_at_offset
argument_list|(
name|oldp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_head
argument_list|(
name|top
argument_list|,
operator|(
name|newsize
operator|-
name|nb
operator|)
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|set_head_size
argument_list|(
name|oldp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|oldp
argument_list|)
return|;
block|}
block|}
comment|/* Forward into next chunk */
elseif|else
if|if
condition|(
operator|(
call|(
name|long
call|)
argument_list|(
name|nextsize
operator|+
name|newsize
argument_list|)
operator|>=
call|(
name|long
call|)
argument_list|(
name|nb
argument_list|)
operator|)
condition|)
block|{
name|unlink
argument_list|(
name|next
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|newsize
operator|+=
name|nextsize
expr_stmt|;
goto|goto
name|split
goto|;
block|}
block|}
else|else
block|{
name|next
operator|=
literal|0
expr_stmt|;
name|nextsize
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Try shifting backwards. */
if|if
condition|(
operator|!
name|prev_inuse
argument_list|(
name|oldp
argument_list|)
condition|)
block|{
name|prev
operator|=
name|prev_chunk
argument_list|(
name|oldp
argument_list|)
expr_stmt|;
name|prevsize
operator|=
name|chunksize
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* try forward + backward first to save a later consolidation */
if|if
condition|(
name|next
operator|!=
literal|0
condition|)
block|{
comment|/* into top */
if|if
condition|(
name|next
operator|==
name|top
condition|)
block|{
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|nextsize
operator|+
name|prevsize
operator|+
name|newsize
argument_list|)
operator|>=
call|(
name|long
call|)
argument_list|(
name|nb
operator|+
name|MINSIZE
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|prev
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|newp
operator|=
name|prev
expr_stmt|;
name|newsize
operator|+=
name|prevsize
operator|+
name|nextsize
expr_stmt|;
name|newmem
operator|=
name|chunk2mem
argument_list|(
name|newp
argument_list|)
expr_stmt|;
name|MALLOC_COPY
argument_list|(
name|newmem
argument_list|,
name|oldmem
argument_list|,
name|oldsize
operator|-
name|SIZE_SZ
argument_list|)
expr_stmt|;
name|top
operator|=
name|chunk_at_offset
argument_list|(
name|newp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_head
argument_list|(
name|top
argument_list|,
operator|(
name|newsize
operator|-
name|nb
operator|)
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|set_head_size
argument_list|(
name|newp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|newp
argument_list|)
return|;
block|}
block|}
comment|/* into next chunk */
elseif|else
if|if
condition|(
operator|(
call|(
name|long
call|)
argument_list|(
name|nextsize
operator|+
name|prevsize
operator|+
name|newsize
argument_list|)
operator|>=
call|(
name|long
call|)
argument_list|(
name|nb
argument_list|)
operator|)
condition|)
block|{
name|unlink
argument_list|(
name|next
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|prev
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|newp
operator|=
name|prev
expr_stmt|;
name|newsize
operator|+=
name|nextsize
operator|+
name|prevsize
expr_stmt|;
name|newmem
operator|=
name|chunk2mem
argument_list|(
name|newp
argument_list|)
expr_stmt|;
name|MALLOC_COPY
argument_list|(
name|newmem
argument_list|,
name|oldmem
argument_list|,
name|oldsize
operator|-
name|SIZE_SZ
argument_list|)
expr_stmt|;
goto|goto
name|split
goto|;
block|}
block|}
comment|/* backward only */
if|if
condition|(
name|prev
operator|!=
literal|0
operator|&&
call|(
name|long
call|)
argument_list|(
name|prevsize
operator|+
name|newsize
argument_list|)
operator|>=
operator|(
name|long
operator|)
name|nb
condition|)
block|{
name|unlink
argument_list|(
name|prev
argument_list|,
name|bck
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|newp
operator|=
name|prev
expr_stmt|;
name|newsize
operator|+=
name|prevsize
expr_stmt|;
name|newmem
operator|=
name|chunk2mem
argument_list|(
name|newp
argument_list|)
expr_stmt|;
name|MALLOC_COPY
argument_list|(
name|newmem
argument_list|,
name|oldmem
argument_list|,
name|oldsize
operator|-
name|SIZE_SZ
argument_list|)
expr_stmt|;
goto|goto
name|split
goto|;
block|}
block|}
comment|/* Must allocate */
name|newmem
operator|=
name|mALLOc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmem
operator|==
literal|0
condition|)
comment|/* propagate failure */
return|return
literal|0
return|;
comment|/* Avoid copy if newp is next chunk after oldp. */
comment|/* (This can only happen when new chunk is sbrk'ed.) */
if|if
condition|(
operator|(
name|newp
operator|=
name|mem2chunk
argument_list|(
name|newmem
argument_list|)
operator|)
operator|==
name|next_chunk
argument_list|(
name|oldp
argument_list|)
condition|)
block|{
name|newsize
operator|+=
name|chunksize
argument_list|(
name|newp
argument_list|)
expr_stmt|;
name|newp
operator|=
name|oldp
expr_stmt|;
goto|goto
name|split
goto|;
block|}
comment|/* Otherwise copy, free, and exit */
name|MALLOC_COPY
argument_list|(
name|newmem
argument_list|,
name|oldmem
argument_list|,
name|oldsize
operator|-
name|SIZE_SZ
argument_list|)
expr_stmt|;
name|fREe
argument_list|(
name|oldmem
argument_list|)
expr_stmt|;
return|return
name|newmem
return|;
block|}
name|split
label|:
comment|/* split off extra room in old or expanded chunk */
if|if
condition|(
name|newsize
operator|-
name|nb
operator|>=
name|MINSIZE
condition|)
comment|/* split off remainder */
block|{
name|remainder
operator|=
name|chunk_at_offset
argument_list|(
name|newp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|remainder_size
operator|=
name|newsize
operator|-
name|nb
expr_stmt|;
name|set_head_size
argument_list|(
name|newp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_head
argument_list|(
name|remainder
argument_list|,
name|remainder_size
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|set_inuse_bit_at_offset
argument_list|(
name|remainder
argument_list|,
name|remainder_size
argument_list|)
expr_stmt|;
name|fREe
argument_list|(
name|chunk2mem
argument_list|(
name|remainder
argument_list|)
argument_list|)
expr_stmt|;
comment|/* let free() deal with it */
block|}
else|else
block|{
name|set_head_size
argument_list|(
name|newp
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|set_inuse_bit_at_offset
argument_list|(
name|newp
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|check_inuse_chunk
argument_list|(
name|newp
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|newp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*    memalign algorithm:      memalign requests more than enough space from malloc, finds a spot     within that chunk that meets the alignment request, and then     possibly frees the leading and trailing space.       The alignment argument must be a power of two. This property is not     checked by memalign, so misuse may result in random runtime errors.      8-byte alignment is guaranteed by normal malloc calls, so don't     bother calling memalign with an argument of 8 or less.      Overreliance on memalign is a sure way to fragment space.  */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|Void_t
modifier|*
name|mEMALIGn
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|bytes
parameter_list|)
else|#
directive|else
function|Void_t* mEMALIGn
parameter_list|(
name|alignment
parameter_list|,
name|bytes
parameter_list|)
name|size_t
name|alignment
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|nb
decl_stmt|;
comment|/* padded  request size */
name|char
modifier|*
name|m
decl_stmt|;
comment|/* memory returned by malloc call */
name|mchunkptr
name|p
decl_stmt|;
comment|/* corresponding chunk */
name|char
modifier|*
name|brk
decl_stmt|;
comment|/* alignment point within p */
name|mchunkptr
name|newp
decl_stmt|;
comment|/* chunk to return */
name|size_t
name|newsize
decl_stmt|;
comment|/* its size */
name|size_t
name|leadsize
decl_stmt|;
comment|/* leading space befor alignment point */
name|mchunkptr
name|remainder
decl_stmt|;
comment|/* spare room at end to split off */
name|long
name|remainder_size
decl_stmt|;
comment|/* its size */
comment|/* If need less alignment than we give anyway, just relay to malloc */
if|if
condition|(
name|alignment
operator|<=
name|MALLOC_ALIGNMENT
condition|)
return|return
name|mALLOc
argument_list|(
name|bytes
argument_list|)
return|;
comment|/* Otherwise, ensure that it is at least a minimum chunk size */
if|if
condition|(
name|alignment
operator|<
name|MINSIZE
condition|)
name|alignment
operator|=
name|MINSIZE
expr_stmt|;
comment|/* Call malloc with worst case padding to hit alignment. */
name|nb
operator|=
name|request2size
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|mALLOc
argument_list|(
name|nb
operator|+
name|alignment
operator|+
name|MINSIZE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* propagate failure */
name|p
operator|=
name|mem2chunk
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
call|(
name|size_t
call|)
argument_list|(
name|m
argument_list|)
operator|)
operator|%
name|alignment
operator|)
operator|==
literal|0
condition|)
comment|/* aligned */
block|{
if|#
directive|if
name|HAVE_MMAP
if|if
condition|(
name|chunk_is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|chunk2mem
argument_list|(
name|p
argument_list|)
return|;
comment|/* nothing more to do */
endif|#
directive|endif
block|}
else|else
comment|/* misaligned */
block|{
comment|/*        Find an aligned spot inside chunk.       Since we need to give back leading space in a chunk of at        least MINSIZE, if the first calculation places us at       a spot with less than MINSIZE leader, we can move to the       next aligned spot -- we've allocated enough total room so that       this is always possible.     */
name|brk
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
call|(
name|size_t
call|)
argument_list|(
name|m
operator|+
name|alignment
operator|-
literal|1
argument_list|)
operator|)
operator|&
operator|-
name|alignment
operator|)
operator|-
name|SIZE_SZ
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|brk
operator|-
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
argument_list|)
operator|<
name|MINSIZE
condition|)
name|brk
operator|=
name|brk
operator|+
name|alignment
expr_stmt|;
name|newp
operator|=
operator|(
name|mchunkptr
operator|)
name|brk
expr_stmt|;
name|leadsize
operator|=
name|brk
operator|-
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
expr_stmt|;
name|newsize
operator|=
name|chunksize
argument_list|(
name|p
argument_list|)
operator|-
name|leadsize
expr_stmt|;
if|#
directive|if
name|HAVE_MMAP
if|if
condition|(
name|chunk_is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
block|{
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|newp
operator|-
literal|1
operator|)
operator|=
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|p
operator|-
literal|1
operator|)
operator|+
name|leadsize
expr_stmt|;
name|set_head
argument_list|(
name|newp
argument_list|,
name|newsize
operator||
name|IS_MMAPPED
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|newp
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* give back leader, use the rest */
name|set_head
argument_list|(
name|newp
argument_list|,
name|newsize
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|set_inuse_bit_at_offset
argument_list|(
name|newp
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|set_head_size
argument_list|(
name|p
argument_list|,
name|leadsize
argument_list|)
expr_stmt|;
name|fREe
argument_list|(
name|chunk2mem
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|newp
expr_stmt|;
block|}
comment|/* Also give back spare room at the end */
name|remainder_size
operator|=
name|chunksize
argument_list|(
name|p
argument_list|)
operator|-
name|nb
expr_stmt|;
if|if
condition|(
name|remainder_size
operator|>=
operator|(
name|long
operator|)
name|MINSIZE
condition|)
block|{
name|remainder
operator|=
name|chunk_at_offset
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|set_head
argument_list|(
name|remainder
argument_list|,
name|remainder_size
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|set_head_size
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|fREe
argument_list|(
name|chunk2mem
argument_list|(
name|remainder
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|check_inuse_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|chunk2mem
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*     valloc just invokes memalign with alignment argument equal     to the page size of the system (or as near to this as can     be figured out from all the includes/defines above.) */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|Void_t
modifier|*
name|vALLOc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
else|#
directive|else
function|Void_t* vALLOc
parameter_list|(
name|bytes
parameter_list|)
name|size_t
name|bytes
decl_stmt|;
endif|#
directive|endif
block|{
return|return
name|mEMALIGn
argument_list|(
name|malloc_getpagesize
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    calloc calls malloc, then zeroes out the allocated chunk.  */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|Void_t
modifier|*
name|cALLOc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|elem_size
parameter_list|)
else|#
directive|else
function|Void_t* cALLOc
parameter_list|(
name|n
parameter_list|,
name|elem_size
parameter_list|)
name|size_t
name|n
decl_stmt|;
name|size_t
name|elem_size
decl_stmt|;
endif|#
directive|endif
block|{
name|mchunkptr
name|p
decl_stmt|;
name|size_t
name|csz
decl_stmt|;
name|size_t
name|sz
init|=
name|n
operator|*
name|elem_size
decl_stmt|;
name|Void_t
modifier|*
name|mem
init|=
name|mALLOc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|p
operator|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk_is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
comment|/* no clearing is necessary */
return|return
name|mem
return|;
name|csz
operator|=
name|chunksize
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|MALLOC_ZERO
argument_list|(
name|mem
argument_list|,
name|csz
operator|-
name|SIZE_SZ
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
block|}
end_function

begin_comment
comment|/*     cfree just calls free. It is needed/defined on some systems   that pair it with calloc, presumably for odd historical reasons.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INTERNAL_LINUX_C_LIB
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|__ELF__
argument_list|)
end_if

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|void
name|cfree
parameter_list|(
name|Void_t
modifier|*
name|mem
parameter_list|)
else|#
directive|else
function|void cfree
parameter_list|(
name|mem
parameter_list|)
name|Void_t
modifier|*
name|mem
decl_stmt|;
endif|#
directive|endif
block|{
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*      Malloc_trim gives memory back to the system (via negative     arguments to sbrk) if there is unused memory at the `high' end of     the malloc pool. You can call this after freeing large blocks of     memory to potentially reduce the system-level memory requirements     of a program. However, it cannot guarantee to reduce memory. Under     some allocation patterns, some large free blocks of memory will be     locked between two used chunks, so they cannot be given back to     the system.      The `pad' argument to malloc_trim represents the amount of free     trailing space to leave untrimmed. If this argument is zero,     only the minimum amount of memory to maintain internal data     structures will be left (one page or less). Non-zero arguments     can be supplied to maintain enough trailing space to service     future expected allocations without having to re-obtain memory     from the system.      Malloc_trim returns 1 if it actually released any memory, else 0.  */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|int
name|malloc_trim
parameter_list|(
name|size_t
name|pad
parameter_list|)
else|#
directive|else
function|int malloc_trim
parameter_list|(
name|pad
parameter_list|)
name|size_t
name|pad
decl_stmt|;
endif|#
directive|endif
block|{
name|long
name|top_size
decl_stmt|;
comment|/* Amount of top-most memory */
name|long
name|extra
decl_stmt|;
comment|/* Amount to release */
name|char
modifier|*
name|current_brk
decl_stmt|;
comment|/* address returned by pre-check sbrk call */
name|char
modifier|*
name|new_brk
decl_stmt|;
comment|/* address returned by negative sbrk call */
name|unsigned
name|long
name|pagesz
init|=
name|malloc_getpagesize
decl_stmt|;
name|top_size
operator|=
name|chunksize
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
operator|(
name|top_size
operator|-
name|pad
operator|-
name|MINSIZE
operator|+
operator|(
name|pagesz
operator|-
literal|1
operator|)
operator|)
operator|/
name|pagesz
operator|-
literal|1
operator|)
operator|*
name|pagesz
expr_stmt|;
if|if
condition|(
name|extra
operator|<
operator|(
name|long
operator|)
name|pagesz
condition|)
comment|/* Not enough memory to release */
return|return
literal|0
return|;
else|else
block|{
comment|/* Test to make sure no one else called sbrk */
name|current_brk
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|MORECORE
argument_list|(
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|current_brk
operator|!=
operator|(
name|char
operator|*
operator|)
operator|(
name|top
operator|)
operator|+
name|top_size
condition|)
return|return
literal|0
return|;
comment|/* Apparently we don't own memory; must fail */
else|else
block|{
name|new_brk
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|MORECORE
argument_list|(
operator|-
name|extra
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_brk
operator|==
operator|(
name|char
operator|*
operator|)
operator|(
name|MORECORE_FAILURE
operator|)
condition|)
comment|/* sbrk failed? */
block|{
comment|/* Try to figure out what we have */
name|current_brk
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|MORECORE
argument_list|(
literal|0
argument_list|)
operator|)
expr_stmt|;
name|top_size
operator|=
name|current_brk
operator|-
operator|(
name|char
operator|*
operator|)
name|top
expr_stmt|;
if|if
condition|(
name|top_size
operator|>=
operator|(
name|long
operator|)
name|MINSIZE
condition|)
comment|/* if not, we are very very dead! */
block|{
name|sbrked_mem
operator|=
name|current_brk
operator|-
name|sbrk_base
expr_stmt|;
name|set_head
argument_list|(
name|top
argument_list|,
name|top_size
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
block|}
name|check_chunk
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Success. Adjust top accordingly. */
name|set_head
argument_list|(
name|top
argument_list|,
operator|(
name|top_size
operator|-
name|extra
operator|)
operator||
name|PREV_INUSE
argument_list|)
expr_stmt|;
name|sbrked_mem
operator|-=
name|extra
expr_stmt|;
name|check_chunk
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*   malloc_usable_size:      This routine tells you how many bytes you can actually use in an     allocated chunk, which may be more than you requested (although     often not). You can use this many bytes without worrying about     overwriting other allocated objects. Not a particularly great     programming practice, but still sometimes useful.  */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|size_t
name|malloc_usable_size
parameter_list|(
name|Void_t
modifier|*
name|mem
parameter_list|)
else|#
directive|else
function|size_t malloc_usable_size
parameter_list|(
name|mem
parameter_list|)
name|Void_t
modifier|*
name|mem
decl_stmt|;
endif|#
directive|endif
block|{
name|mchunkptr
name|p
decl_stmt|;
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|p
operator|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chunk_is_mmapped
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inuse
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|check_inuse_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|chunksize
argument_list|(
name|p
argument_list|)
operator|-
name|SIZE_SZ
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utility to update current_mallinfo for malloc_stats and mallinfo() */
end_comment

begin_function
specifier|static
name|void
name|malloc_update_mallinfo
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|mbinptr
name|b
decl_stmt|;
name|mchunkptr
name|p
decl_stmt|;
if|#
directive|if
name|DEBUG
name|mchunkptr
name|q
decl_stmt|;
endif|#
directive|endif
name|size_t
name|avail
init|=
name|chunksize
argument_list|(
name|top
argument_list|)
decl_stmt|;
name|int
name|navail
init|=
operator|(
call|(
name|long
call|)
argument_list|(
name|avail
argument_list|)
operator|>=
operator|(
name|long
operator|)
name|MINSIZE
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NAV
condition|;
operator|++
name|i
control|)
block|{
name|b
operator|=
name|bin_at
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|last
argument_list|(
name|b
argument_list|)
init|;
name|p
operator|!=
name|b
condition|;
name|p
operator|=
name|p
operator|->
name|bk
control|)
block|{
if|#
directive|if
name|DEBUG
name|check_free_chunk
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|next_chunk
argument_list|(
name|p
argument_list|)
init|;
name|q
operator|<
name|top
operator|&&
name|inuse
argument_list|(
name|q
argument_list|)
operator|&&
call|(
name|long
call|)
argument_list|(
name|chunksize
argument_list|(
name|q
argument_list|)
argument_list|)
operator|>=
operator|(
name|long
operator|)
name|MINSIZE
condition|;
name|q
operator|=
name|next_chunk
argument_list|(
name|q
argument_list|)
control|)
name|check_inuse_chunk
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|avail
operator|+=
name|chunksize
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|navail
operator|++
expr_stmt|;
block|}
block|}
name|current_mallinfo
operator|.
name|ordblks
operator|=
name|navail
expr_stmt|;
name|current_mallinfo
operator|.
name|uordblks
operator|=
name|sbrked_mem
operator|-
name|avail
expr_stmt|;
name|current_mallinfo
operator|.
name|fordblks
operator|=
name|avail
expr_stmt|;
name|current_mallinfo
operator|.
name|hblks
operator|=
name|n_mmaps
expr_stmt|;
name|current_mallinfo
operator|.
name|hblkhd
operator|=
name|mmapped_mem
expr_stmt|;
name|current_mallinfo
operator|.
name|keepcost
operator|=
name|chunksize
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*    malloc_stats:      Prints on stderr the amount of space obtain from the system (both     via sbrk and mmap), the maximum amount (which may be more than     current if malloc_trim and/or munmap got called), the maximum     number of simultaneous mmap regions used, and the current number     of bytes allocated via malloc (or realloc, etc) but not yet     freed. (Note that this is the number of bytes allocated, not the     number requested. It will be larger than the number requested     because of alignment and bookkeeping overhead.)  */
end_comment

begin_function
name|void
name|malloc_stats
parameter_list|()
block|{
name|malloc_update_mallinfo
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max system bytes = %10u\n"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|max_total_mem
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"system bytes     = %10u\n"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|sbrked_mem
operator|+
name|mmapped_mem
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in use bytes     = %10u\n"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|current_mallinfo
operator|.
name|uordblks
operator|+
name|mmapped_mem
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_MMAP
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max mmap regions = %10u\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|max_n_mmaps
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*   mallinfo returns a copy of updated current mallinfo. */
end_comment

begin_function
name|struct
name|mallinfo
name|mALLINFo
parameter_list|()
block|{
name|malloc_update_mallinfo
argument_list|()
expr_stmt|;
return|return
name|current_mallinfo
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*   mallopt:      mallopt is the general SVID/XPG interface to tunable parameters.     The format is to provide a (parameter-number, parameter-value) pair.     mallopt then sets the corresponding parameter to the argument     value if it can (i.e., so long as the value is meaningful),     and returns 1 if successful else 0.      See descriptions of tunable parameters above.  */
end_comment

begin_if
if|#
directive|if
name|__STD_C
end_if

begin_function
name|int
name|mALLOPt
parameter_list|(
name|int
name|param_number
parameter_list|,
name|int
name|value
parameter_list|)
else|#
directive|else
function|int mALLOPt
parameter_list|(
name|param_number
parameter_list|,
name|value
parameter_list|)
name|int
name|param_number
decl_stmt|;
name|int
name|value
decl_stmt|;
endif|#
directive|endif
block|{
switch|switch
condition|(
name|param_number
condition|)
block|{
case|case
name|M_TRIM_THRESHOLD
case|:
name|trim_threshold
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
case|case
name|M_TOP_PAD
case|:
name|top_pad
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
case|case
name|M_MMAP_THRESHOLD
case|:
name|mmap_threshold
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
case|case
name|M_MMAP_MAX
case|:
if|#
directive|if
name|HAVE_MMAP
name|n_mmaps_max
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
else|else
name|n_mmaps_max
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  History:      V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)       * Integrated most documentation with the code.       * Add support for mmap, with help from          Wolfram Gloger (Gloger@lrz.uni-muenchen.de).       * Use last_remainder in more cases.       * Pack bins using idea from  colin@nyx10.cs.du.edu       * Use ordered bins instead of best-fit threshhold       * Eliminate block-local decls to simplify tracing and debugging.       * Support another case of realloc via move into top       * Fix error occuring when initial sbrk_base not word-aligned.         * Rely on page size for units instead of SBRK_UNIT to         avoid surprises about sbrk alignment conventions.       * Add mallinfo, mallopt. Thanks to Raymond Nijssen         (raymond@es.ele.tue.nl) for the suggestion.        * Add `pad' argument to malloc_trim and top_pad mallopt parameter.       * More precautions for cases where other routines call sbrk,         courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).       * Added macros etc., allowing use in linux libc from         H.J. Lu (hjl@gnu.ai.mit.edu)       * Inverted this history list      V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)       * Re-tuned and fixed to behave more nicely with V2.6.0 changes.       * Removed all preallocation code since under current scheme         the work required to undo bad preallocations exceeds         the work saved in good cases for most test programs.       * No longer use return list or unconsolidated bins since         no scheme using them consistently outperforms those that don't         given above changes.       * Use best fit for very large chunks to prevent some worst-cases.       * Added some support for debugging      V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)       * Removed footers when chunks are in use. Thanks to         Paul Wilson (wilson@cs.texas.edu) for the suggestion.      V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)       * Added malloc_trim, with help from Wolfram Gloger          (wmglo@Dent.MED.Uni-Muenchen.DE).      V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)      V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)       * realloc: try to expand in both directions       * malloc: swap order of clean-bin strategy;       * realloc: only conditionally expand backwards       * Try not to scavenge used bins       * Use bin counts as a guide to preallocation       * Occasionally bin return list chunks in first scan       * Add a few optimizations from colin@nyx10.cs.du.edu      V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)       * faster bin computation& slightly different binning       * merged all consolidations to one part of malloc proper          (eliminating old malloc_find_space& malloc_clean_bin)       * Scan 2 returns chunks (not just 1)       * Propagate failure in realloc if malloc returns 0       * Add stuff to allow compilation on non-ANSI compilers            from kpv@research.att.com           V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)       * removed potential for odd address access in prev_chunk       * removed dependency on getpagesize.h       * misc cosmetics and a bit more internal documentation       * anticosmetics: mangled names in macros to evade debugger strangeness       * tested on sparc, hp-700, dec-mips, rs6000            with gcc& native cc (hp, dec only) allowing           Detlefs& Zorn comparison study (in SIGPLAN Notices.)      Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)       * Based loosely on libg++-1.2X malloc. (It retains some of the overall           structure of old version,  but most details differ.)  */
end_comment

end_unit

