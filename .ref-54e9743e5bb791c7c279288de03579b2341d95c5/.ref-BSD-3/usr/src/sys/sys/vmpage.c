begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	vmpage.c	2.2	2/10/80	*/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/proc.h"
end_include

begin_include
include|#
directive|include
file|"../h/reg.h"
end_include

begin_include
include|#
directive|include
file|"../h/pte.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/text.h"
end_include

begin_include
include|#
directive|include
file|"../h/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../h/cmap.h"
end_include

begin_include
include|#
directive|include
file|"../h/vm.h"
end_include

begin_include
include|#
directive|include
file|"../h/vmmon.h"
end_include

begin_include
include|#
directive|include
file|"../h/file.h"
end_include

begin_comment
comment|/*  * Handle a page fault.  */
end_comment

begin_macro
name|pagein
argument_list|(
argument|virtaddr
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|virtaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
specifier|register
name|unsigned
name|v
decl_stmt|;
name|unsigned
name|pf
decl_stmt|;
name|int
name|type
decl_stmt|,
name|fileno
decl_stmt|,
name|prot
decl_stmt|;
name|struct
name|pte
name|opte
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ERNIE
name|int
name|otime
decl_stmt|,
name|olbolt
decl_stmt|,
name|oicr
decl_stmt|,
name|a
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
name|otime
operator|=
name|time
operator|,
name|olbolt
operator|=
name|lbolt
operator|,
name|oicr
operator|=
name|mfpr
argument_list|(
name|ICR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_faults
operator|++
expr_stmt|;
name|v
operator|=
name|clbase
argument_list|(
name|btop
argument_list|(
name|virtaddr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
if|if
condition|(
name|isatsv
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
condition|)
name|type
operator|=
name|MTEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|isassv
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
condition|)
name|type
operator|=
name|MSTACK
expr_stmt|;
else|else
name|type
operator|=
name|MDATA
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
name|panic
argument_list|(
literal|"pagein"
argument_list|)
expr_stmt|;
comment|/* 	if (pte->pg_v || (pte+1)->pg_v) 		panic("pagein pg_v"); 	if (pte->pg_fod) { 		if ((pte+1)->pg_fod == 0) 			panic("pagein pg_fod"); 		if (((struct fpte *)pte)->pg_blkno != ((struct fpte *)(pte+1))->pg_blkno) 			panic("pagein pg_blkno"); 	} else { 		if ((pte+1)->pg_fod) 			panic("pagein v+fod"); 		if (pte->pg_pfnum) { 			if (pte->pg_pfnum+1 != (pte+1)->pg_pfnum) 				panic("pagein<> pfnum"); 		} else if ((pte+1)->pg_pfnum) 			panic("pagein +1pfnum<> 0"); 	} */
comment|/* 	 * If page is reclaimable, reclaim it. 	 * If page is text and intransit, sleep while it is intransit, 	 * If it is valid after the sleep, we are done. 	 * Otherwise we have to start checking again, since page could 	 * even be reclaimable now (we may have swapped for a long time). 	 */
name|restart
label|:
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|==
literal|0
operator|&&
name|pte
operator|->
name|pg_pfnum
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|MTEXT
operator|&&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
operator|.
name|c_intrans
condition|)
block|{
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_textp
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
block|{
name|valid
label|:
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SDLYU
condition|)
name|mlock
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
name|tbiscl
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_intrans
operator|++
expr_stmt|;
return|return;
block|}
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
operator|.
name|c_flag
operator|&
name|MFREE
condition|)
block|{
name|munlink
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_pgfrec
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|MTEXT
condition|)
name|p
operator|->
name|p_textp
operator|->
name|x_rssize
operator|+=
name|CLSIZE
expr_stmt|;
else|else
name|p
operator|->
name|p_rssize
operator|+=
name|CLSIZE
expr_stmt|;
block|}
name|pte
operator|->
name|pg_v
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|anycl
argument_list|(
name|pte
argument_list|,
name|pg_m
argument_list|)
condition|)
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|MTEXT
condition|)
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_minorflt
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_pgrec
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SDLYU
condition|)
name|mlock
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
name|tbiscl
argument_list|(
name|v
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ERNIE
name|a
operator|=
name|vmtime
argument_list|(
name|otime
argument_list|,
name|olbolt
argument_list|,
name|oicr
argument_list|)
expr_stmt|;
name|rectime
operator|+=
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|)
name|vmfltmon
argument_list|(
name|rmon
argument_list|,
name|a
argument_list|,
name|rmonmin
argument_list|,
name|rres
argument_list|,
name|NRMON
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|ERNIE
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now prepare to bring the page in. 	 * We allocate the page before locking so we will 	 * be swappable if there is no free memory. 	 */
if|if
condition|(
name|freemem
operator|<
name|CLSIZE
condition|)
block|{
while|while
condition|(
name|freemem
operator|<
name|CLSIZE
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|freemem
argument_list|,
name|PSWP
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
goto|goto
name|valid
goto|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Now committed to bringing in the page. 	 * Lock this process, get a page, 	 * construct the new pte, and increment 	 * the (process or text) resident set size. 	 */
name|p
operator|->
name|p_flag
operator||=
name|SPAGE
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
name|VOID
name|memall
parameter_list|(
name|pte
parameter_list|,
name|CLSIZE
parameter_list|,
name|p
parameter_list|,
name|type
parameter_list|)
function_decl|;
name|pte
operator|->
name|pg_prot
operator|=
name|opte
operator|.
name|pg_prot
expr_stmt|;
name|pf
operator|=
name|pte
operator|->
name|pg_pfnum
expr_stmt|;
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
operator|.
name|c_intrans
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|MTEXT
condition|)
block|{
name|p
operator|->
name|p_textp
operator|->
name|x_rssize
operator|+=
name|CLSIZE
expr_stmt|;
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|p_rssize
operator|+=
name|CLSIZE
expr_stmt|;
if|if
condition|(
name|opte
operator|.
name|pg_fod
condition|)
block|{
name|pte
operator|->
name|pg_swapm
operator|=
literal|1
expr_stmt|;
name|fileno
operator|=
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
operator|&
name|opte
operator|)
operator|->
name|pg_fileno
expr_stmt|;
if|if
condition|(
name|fileno
operator|>
name|PG_FMAX
condition|)
name|panic
argument_list|(
literal|"pagein pg_fileno"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileno
operator|==
name|PG_FZERO
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLSIZE
condition|;
name|i
operator|++
control|)
name|clearseg
argument_list|(
name|pf
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|MTEXT
condition|)
name|cnt
operator|.
name|v_zfod
operator|+=
name|CLSIZE
expr_stmt|;
name|pte
operator|->
name|pg_v
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fileno
operator|==
name|PG_FTEXT
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_textp
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pagein PG_FTEXT"
argument_list|)
expr_stmt|;
name|dev
operator|=
name|p
operator|->
name|p_textp
operator|->
name|x_iptr
operator|->
name|i_dev
expr_stmt|;
name|cnt
operator|.
name|v_exfod
operator|+=
name|CLSIZE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|u
operator|.
name|u_ofile
index|[
name|fileno
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pagein u.u_ofile"
argument_list|)
expr_stmt|;
name|ip
operator|=
name|u
operator|.
name|u_ofile
index|[
name|fileno
index|]
operator|->
name|f_inode
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|.
name|u_vrpages
index|[
name|fileno
index|]
operator|-=
name|CLSIZE
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|u
operator|.
name|u_vrpages
index|[
name|fileno
index|]
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"pagein u.u_vrpages"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ip
operator|->
name|i_vfdcnt
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"pagein i_vfdcnt"
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|ip
operator|->
name|i_dev
expr_stmt|;
name|cnt
operator|.
name|v_vrfod
operator|+=
name|CLSIZE
expr_stmt|;
block|}
name|daddr
operator|=
name|fsbtodb
argument_list|(
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
operator|&
name|opte
operator|)
operator|->
name|pg_blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|=
name|baddr
argument_list|(
name|dev
argument_list|,
name|dbtofsb
argument_list|(
name|daddr
argument_list|)
argument_list|)
condition|)
block|{
name|pte
operator|->
name|pg_v
operator|=
literal|1
expr_stmt|;
name|prot
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|&
name|PG_PROT
expr_stmt|;
name|pte
operator|->
name|pg_prot
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator||=
name|PG_UW
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|tbiscl
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* THIS ASSUMES THAT CLSIZE*NBPG==BSIZE */
name|bcopy
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|ptob
argument_list|(
name|v
argument_list|)
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|pte
operator|->
name|pg_prot
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator||=
name|prot
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|MTEXT
condition|)
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|opte
operator|.
name|pg_pfnum
condition|)
name|panic
argument_list|(
literal|"pagein pfnum"
argument_list|)
expr_stmt|;
name|daddr
operator|=
name|vtod
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|)
expr_stmt|;
name|dev
operator|=
name|swapdev
expr_stmt|;
name|pte
operator|->
name|pg_vreadm
operator|=
name|opte
operator|.
name|pg_vreadm
expr_stmt|;
block|}
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|p
argument_list|,
name|daddr
argument_list|,
name|ptob
argument_list|(
name|v
argument_list|)
argument_list|,
name|ctob
argument_list|(
name|CLSIZE
argument_list|)
argument_list|,
name|B_READ
argument_list|,
name|B_PGIN
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Fix page table entries. 	 */
name|pte
operator|->
name|pg_v
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|MTEXT
condition|)
block|{
name|distpte
argument_list|(
name|p
operator|->
name|p_textp
argument_list|,
name|vtotp
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|opte
operator|.
name|pg_fod
condition|)
name|p
operator|->
name|p_textp
operator|->
name|x_flag
operator||=
name|XWRIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_textp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Instrumentation. 	 */
name|p
operator|->
name|p_faults
operator|++
expr_stmt|;
name|u
operator|.
name|u_majorflt
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_pgin
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|ERNIE
name|a
operator|=
name|vmtime
argument_list|(
name|otime
argument_list|,
name|olbolt
argument_list|,
name|oicr
argument_list|)
operator|/
literal|100
expr_stmt|;
name|pgintime
operator|+=
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|)
name|vmfltmon
argument_list|(
name|pmon
argument_list|,
name|a
argument_list|,
name|pmonmin
argument_list|,
name|pres
argument_list|,
name|NPMON
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
comment|/* 	 * Memall returned page locked.  Unless 	 * this page is to be used in a raw transfer, 	 * we should unlock the page. 	 */
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
operator|.
name|c_intrans
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SDLYU
operator|)
operator|==
literal|0
condition|)
name|munlock
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
comment|/* 	 * All done. 	 */
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SPAGE
expr_stmt|;
name|tbiscl
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* conservative */
block|}
end_block

begin_comment
comment|/*  * The page out daemon, which runs as process 2.  *  * As long as there are at least lotsfree pages,  * this process is not run.  When the number of free  * pages stays in the range desfree to lotsfree,  * this daemon runs through the pages in the loop  * at a rate determined in vmsched(), simulating the missing  * hardware reference bit, and cleaning pages and transferring  * them to the free list.  */
end_comment

begin_macro
name|pageout
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|int
name|count
decl_stmt|,
name|pushes
decl_stmt|;
name|swblk_t
name|daddr
decl_stmt|;
name|unsigned
name|v
decl_stmt|;
name|int
name|maxhand
init|=
name|pgtocm
argument_list|(
name|maxfree
argument_list|)
decl_stmt|;
name|loop
label|:
comment|/* 	 * Before sleeping, look to see if there are any swap I/O headers 	 * in the ``cleaned'' list that correspond to dirty 	 * pages that have been pushed asynchronously. If so, 	 * empty the list by calling cleanup(). 	 * 	 * N.B.: We guarantee never to block while the cleaned list is nonempty. 	 */
name|VOID
name|spl6
parameter_list|()
function_decl|;
if|if
condition|(
name|bclnlist
operator|!=
name|NULL
condition|)
name|cleanup
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc
index|[
literal|2
index|]
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VOID
name|spl0
parameter_list|()
function_decl|;
name|count
operator|=
literal|0
expr_stmt|;
name|pushes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nscan
operator|<
name|desscan
operator|&&
name|freemem
operator|<
name|lotsfree
condition|)
block|{
name|top
label|:
comment|/* 		 * An iteration of the clock pointer (hand) around the loop. 		 * Look at the page at hand.  If it is a 		 * locked (for physical i/o e.g.), system (u., page table) 		 * or free, then leave it alone. 		 * Otherwise, find a process and text pointer for the 		 * page, and a virtual page number in either the 		 * process or the text image. 		 */
name|c
operator|=
operator|&
name|cmap
index|[
name|hand
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
operator|(
name|MLOCK
operator||
name|MSYS
operator||
name|MFREE
operator|)
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
block|{
name|xp
operator|=
operator|&
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
name|rp
operator|=
name|xp
operator|->
name|x_caddr
expr_stmt|;
name|v
operator|=
name|tptov
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
name|pte
operator|=
name|tptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|=
operator|&
name|proc
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
while|while
condition|(
name|rp
operator|->
name|p_flag
operator|&
name|SNOVM
condition|)
name|rp
operator|=
name|rp
operator|->
name|p_xlink
expr_stmt|;
name|xp
operator|=
name|rp
operator|->
name|p_textp
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MDATA
condition|)
block|{
name|v
operator|=
name|dptov
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
name|pte
operator|=
name|dptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|sptov
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
name|pte
operator|=
name|sptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
operator|!=
name|cmtopg
argument_list|(
name|hand
argument_list|)
condition|)
name|panic
argument_list|(
literal|"bad c_page"
argument_list|)
expr_stmt|;
comment|/* 		 * If page is valid; now it is invalid, but reclaimable. 		 * If this pte is not valid, then it must be reclaimable 		 * and we can add it to the free list. 		 */
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
block|{
name|pte
operator|->
name|pg_v
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|anycl
argument_list|(
name|pte
argument_list|,
name|pg_m
argument_list|)
condition|)
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
name|distpte
argument_list|(
name|xp
argument_list|,
name|vtotp
argument_list|(
name|rp
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This check guarantees a minimal investment in 			 * swapped in processes, by protecting about small 			 * amount of data space from replacement.  This 			 * prevents very large jobs from dragging everything 			 * into the ground when they are exhibiting atypical 			 * behaviour (e.g. LISP garbage collections.) 			 *  			 * Note that this is a rather flimsy replacement 			 * for working set size estimation.  We expect 			 * most systems to have a reasonable amount of main 			 * memory, and thus this check will rarely have 			 * any effect. 			 * 			 * SHOULD DO SOMETHING SIMILAR FOR TEXT SEGMENTS. 			 */
if|if
condition|(
operator|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|p_rssize
operator|<
name|saferss
operator|-
name|rp
operator|->
name|p_slptime
condition|)
goto|goto
name|skip
goto|;
block|}
comment|/* 			 * If the page is currently dirty, we 			 * have to arrange to have it cleaned before it 			 * can be freed.  We mark it clean immediately. 			 * If it is reclaimed while being pushed, then modified 			 * again, we are assured of the correct order of  			 * writes because we lock the page during the write.   			 * This guarantees that a swap() of this process (and 			 * thus this page), initiated in parallel, will, 			 * in fact, push the page after us. 			 * 			 * The most general worst case here would be for 			 * a reclaim, a modify and a swapout to occur 			 * all before the single page transfer completes. 			 */
if|if
condition|(
name|dirtycl
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|pushes
operator|>
name|MAXPGIO
operator|/
literal|2
condition|)
goto|goto
name|skip
goto|;
name|pushes
operator|++
expr_stmt|;
comment|/* 		 		 * If the process is being swapped out 				 * or about to exit, do not bother with its 				 * dirty pages 		 		 */
if|if
condition|(
name|rp
operator|->
name|p_flag
operator|&
operator|(
name|SLOCK
operator||
name|SWEXIT
operator|)
condition|)
goto|goto
name|skip
goto|;
comment|/* 				 * Now carefully make sure that there will 				 * be a header available for the push so that 				 * we will not block waiting for a header in 				 * swap().  The reason this is important is 				 * that we (proc[2]) are the one who cleans 				 * dirty swap headers and we could otherwise 				 * deadlock waiting for ourselves to clean 				 * swap headers.  The sleep here on&proc[2] 				 * is actually (effectively) a sleep on both 				 * ourselves and&bswlist, and this is known 				 * to iodone and swap in bio.c.  That is, 				 *&proc[2] will be awakened both when dirty 				 * headers show up and also to get the pageout 				 * daemon moving. 				 */
name|VOID
name|spl6
parameter_list|()
function_decl|;
if|if
condition|(
name|bclnlist
operator|!=
name|NULL
condition|)
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|bswlist
operator|.
name|av_forw
operator|==
name|NULL
condition|)
block|{
name|bswlist
operator|.
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc
index|[
literal|2
index|]
argument_list|,
name|PSWP
operator|+
literal|2
argument_list|)
expr_stmt|;
name|VOID
name|spl0
parameter_list|()
function_decl|;
comment|/* 					 * Page disposition may have changed 					 * since process may have exec'ed, 					 * forked, exited or just about 					 * anything else... try this page 					 * frame again, from the top. 					 */
goto|goto
name|top
goto|;
block|}
name|VOID
name|spl0
parameter_list|()
function_decl|;
name|uaccess
argument_list|(
name|rp
argument_list|,
name|Pushmap
argument_list|,
operator|&
name|pushutl
argument_list|)
expr_stmt|;
if|if
condition|(
name|swpexpand
argument_list|(
name|rp
operator|->
name|p_dsize
argument_list|,
name|rp
operator|->
name|p_ssize
argument_list|,
operator|&
name|pushutl
operator|.
name|u_dmap
argument_list|,
operator|&
name|pushutl
operator|.
name|u_smap
argument_list|)
operator|==
literal|0
condition|)
block|{
name|swkill
argument_list|(
name|rp
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|daddr
operator|=
name|vtod
argument_list|(
name|rp
argument_list|,
name|v
argument_list|,
operator|&
name|pushutl
operator|.
name|u_dmap
argument_list|,
operator|&
name|pushutl
operator|.
name|u_smap
argument_list|)
expr_stmt|;
comment|/* 				 * Now committed to pushing the page... 				 */
name|mlock
argument_list|(
operator|(
name|unsigned
operator|)
name|cmtopg
argument_list|(
name|hand
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|anycl
argument_list|(
name|pte
argument_list|,
name|pg_m
argument_list|)
condition|)
block|{
name|pte
operator|->
name|pg_vreadm
operator|=
literal|1
expr_stmt|;
name|pte
operator|->
name|pg_m
operator|=
literal|0
expr_stmt|;
block|}
name|pte
operator|->
name|pg_swapm
operator|=
literal|0
expr_stmt|;
name|distcl
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
block|{
name|xp
operator|->
name|x_poip
operator|++
expr_stmt|;
name|distpte
argument_list|(
name|xp
argument_list|,
name|vtotp
argument_list|(
name|rp
argument_list|,
name|v
argument_list|)
argument_list|,
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
name|rp
operator|->
name|p_poip
operator|++
expr_stmt|;
name|swap
argument_list|(
name|rp
argument_list|,
name|daddr
argument_list|,
name|ptob
argument_list|(
name|v
argument_list|)
argument_list|,
name|ctob
argument_list|(
name|CLSIZE
argument_list|)
argument_list|,
name|B_WRITE
argument_list|,
name|B_DIRTY
argument_list|,
name|swapdev
argument_list|)
expr_stmt|;
comment|/* 				 * The cleaning of this page will be 				 * completed later, in cleanup() called 				 * (synchronously) by us (proc[2]).  In 				 * the meantime, the page frame is locked 				 * so no havoc can result. 				 */
goto|goto
name|skip
goto|;
block|}
comment|/* 			 * Decrement the resident set size of the current 			 * text object/process, and put the page in the 			 * free list. Note that we don't give memfree the 			 * pte as its argument, since we don't want to destroy 			 * the pte.  If it hasn't already been discarded 			 * it may yet have a chance to be reclaimed from 			 * the free list. 			 */
if|if
condition|(
operator|(
name|c
operator|->
name|c_flag
operator|&
name|MGONE
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
name|xp
operator|->
name|x_rssize
operator|-=
name|CLSIZE
expr_stmt|;
else|else
name|rp
operator|->
name|p_rssize
operator|-=
name|CLSIZE
expr_stmt|;
name|memfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_dfree
operator|+=
name|CLSIZE
expr_stmt|;
comment|/* 			 * We managed to add a page to the free list, 			 * so we give ourselves another couple of trips 			 * around the loop. 			 */
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|skip
label|:
name|cnt
operator|.
name|v_scan
operator|++
expr_stmt|;
name|nscan
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|hand
operator|>=
name|maxhand
condition|)
block|{
name|hand
operator|=
literal|0
expr_stmt|;
name|cnt
operator|.
name|v_rev
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|2
condition|)
block|{
comment|/* 				 * Extremely unlikely, but we went around 				 * the loop twice and didn't get anywhere. 				 * Don't cycle, stop till the next clock tick. 				 */
goto|goto
name|loop
goto|;
block|}
name|count
operator|++
expr_stmt|;
block|}
block|}
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * Process the ``cleaned'' list.  *  * Scan through the linked list of swap I/O headers  * and free the corresponding pages that have been  * cleaned by being written back to the paging area.  * If the page has been reclaimed during this time,  * we do not free the page.  As they are processed,  * the swap I/O headers are removed from the cleaned  * list and inserted into the free list.  */
end_comment

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|unsigned
name|pf
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|=
name|bclnlist
condition|)
block|{
name|bclnlist
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|pte
operator|=
name|dptopte
argument_list|(
operator|&
name|proc
index|[
literal|2
index|]
argument_list|,
name|btop
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
argument_list|)
expr_stmt|;
name|pf
operator|=
name|pte
operator|->
name|pg_pfnum
expr_stmt|;
name|munlock
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
block|{
name|xp
operator|=
operator|&
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
name|xp
operator|->
name|x_poip
operator|--
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|x_poip
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|xp
operator|->
name|x_poip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|=
operator|&
name|proc
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
while|while
condition|(
name|rp
operator|->
name|p_flag
operator|&
name|SNOVM
condition|)
name|rp
operator|=
name|rp
operator|->
name|p_xlink
expr_stmt|;
name|rp
operator|->
name|p_poip
operator|--
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|p_poip
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rp
operator|->
name|p_poip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|->
name|c_flag
operator|&
name|MGONE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
name|pte
operator|=
name|tptopte
argument_list|(
name|xp
operator|->
name|x_caddr
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MDATA
condition|)
name|pte
operator|=
name|dptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
else|else
name|pte
operator|=
name|sptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
name|xp
operator|->
name|x_rssize
operator|-=
name|CLSIZE
expr_stmt|;
else|else
name|rp
operator|->
name|p_rssize
operator|-=
name|CLSIZE
expr_stmt|;
block|}
name|memfree
argument_list|(
name|pte
argument_list|,
name|CLSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_dfree
operator|+=
name|CLSIZE
expr_stmt|;
name|skip
label|:
name|bp
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|bswlist
operator|.
name|av_forw
expr_stmt|;
name|bswlist
operator|.
name|av_forw
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|bswlist
operator|.
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bswlist
operator|.
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|bswlist
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

