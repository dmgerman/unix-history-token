begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* must be setuid root */
end_comment

begin_comment
comment|/* 	net - -b -c cmd -f -i file -l name -mmach -n -o file -p passwd 		-r file -s file -u uid -w -x -y -z command 		 	-	take from standard input 	-b	never send anything back 	-c cmd	think of this as a "cmd" * 	-f	force prompting of user name and password 	-i file	remote stdin * 	-l name remote login name 	-m Mach	remote machine 	-n	do not write back anything, always mail them back 	-o file	remote stdout& stderr * 	-p pass remote password 	-q 	quiet option, send back only if rcode !=0 or if there is stdout 	-r file	local response file 	-s file	local stdin file * 	 	(super users only, always skip login/passwd check:) 	-u uid	net queue files should be owned by uid (16 bits) 	-w	this is a write/mail response cmd * 	-x	this is being forwarded through us to another machine * 	-y	skip login/password check * 	-z	this is a response file being returned *  	* = not documented in net(NEW) 	 */
end_comment

begin_comment
comment|/* 	code	option	reason 	q		normal request 	w	-w	message to be written back 	 	-x	being forwarded through us 	y	-y	simply skips login check (used by netlpr) 	s	-z	normal response */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dfname
index|[]
init|=
name|DFNAME
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|outerror
argument_list|()
decl_stmt|,
name|uid
decl_stmt|;
name|char
modifier|*
name|genparmlist
parameter_list|()
function_decl|;
name|char
name|resp
index|[
name|FNS
index|]
decl_stmt|,
name|infile
index|[
name|FNS
index|]
decl_stmt|,
name|outfile
index|[
name|FNS
index|]
decl_stmt|,
name|localin
index|[
name|FNS
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|suid
index|[
literal|10
index|]
decl_stmt|;
name|char
name|sin
init|=
literal|0
decl_stmt|,
name|code
decl_stmt|,
name|zopt
init|=
literal|0
decl_stmt|,
name|wopt
init|=
literal|0
decl_stmt|,
name|yopt
init|=
literal|0
decl_stmt|,
name|xopt
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|sn
decl_stmt|;
name|char
name|sTtyname
index|[
literal|20
index|]
decl_stmt|,
name|sCmdAct
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|sCmdVirt
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|long
name|cnt
init|=
literal|0L
decl_stmt|,
name|maxfile
init|=
name|MAXFILE
decl_stmt|,
name|lTtytime
decl_stmt|;
name|char
name|cflag
init|=
literal|'a'
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|rfile
decl_stmt|;
name|struct
name|utmp
name|utmpstr
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|debugflg
operator|=
name|DBV
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|sCmdAct
index|[
literal|0
index|]
operator|=
name|resp
index|[
literal|0
index|]
operator|=
name|outfile
index|[
literal|0
index|]
operator|=
name|infile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sCmdVirt
index|[
literal|0
index|]
operator|=
name|localin
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sTtyname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|suid
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|strcat
argument_list|(
name|sTtyname
argument_list|,
name|ttyname
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
literal|2
argument_list|)
condition|)
name|strcat
argument_list|(
name|sTtyname
argument_list|,
name|ttyname
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|remote
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|outerror
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|outerror
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|outerror
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTRM
argument_list|,
name|outerror
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0
case|:
name|sin
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|status
operator|.
name|nonotify
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|harg
argument_list|(
name|sCmdVirt
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|status
operator|.
name|force
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|harg
argument_list|(
name|infile
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|harg
argument_list|(
name|status
operator|.
name|login
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|harg
argument_list|(
name|buf
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|remote
operator|=
name|lookup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|status
operator|.
name|nowrite
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|harg
argument_list|(
name|outfile
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|harg
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|status
operator|.
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|harg
argument_list|(
name|buf
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|addir
argument_list|(
name|resp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|harg
argument_list|(
name|localin
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|harg
argument_list|(
name|suid
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wopt
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xopt
operator|++
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|yopt
operator|++
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|zopt
operator|++
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown option %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|strcat
argument_list|(
name|sCmdAct
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|sCmdAct
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|code
operator|=
literal|'q'
expr_stmt|;
if|if
condition|(
name|zopt
operator|||
name|wopt
operator|||
name|yopt
operator|||
name|xopt
operator|||
name|suid
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* check z or w or y or x option permission */
ifndef|#
directive|ifndef
name|TESTING
if|if
condition|(
name|uid
operator|!=
name|SUPERUSER
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Not super-user"
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
name|zopt
condition|?
literal|'s'
else|:
literal|'w'
expr_stmt|;
name|code
operator|=
name|yopt
condition|?
literal|'y'
else|:
name|code
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* no passwd required */
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|status
operator|.
name|jobno
operator|=
literal|32767
expr_stmt|;
comment|/* default (invalid) job number */
if|if
condition|(
name|code
operator|==
literal|'q'
operator|&&
operator|!
name|xopt
condition|)
block|{
if|if
condition|(
operator|(
name|sn
operator|=
name|SnCurrent
argument_list|()
operator|)
operator|==
name|NULL
comment|/* || machtype[local-'a'] == M_CC */
condition|)
comment|/* turns out we never use jobno, except in netlpr */
comment|/* read passwd file, get status.localname& jobno */
name|passwdent
argument_list|()
expr_stmt|;
else|else
comment|/* don't bother reading passwd file, don't need jobno */
name|strcpy
argument_list|(
name|status
operator|.
name|localname
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
comment|/* sets remote,status.login,status.force,status.mpasswd, 		status.nonotify, status.nowrite */
comment|/* may read passwd file if getenv(HOME) reads it */
name|commandfile
argument_list|()
expr_stmt|;
if|if
condition|(
name|remote
operator|==
literal|0
condition|)
name|remote
operator|=
name|getremote
argument_list|(
name|local
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TESTING
if|if
condition|(
name|remote
operator|==
name|local
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Request sent to local machine - doesn't make sense\n"
argument_list|)
expr_stmt|;
comment|/* outerror(); */
block|}
endif|#
directive|endif
name|strcat
argument_list|(
name|status
operator|.
name|defcmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|sCmdAct
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|sCmdAct
argument_list|,
name|status
operator|.
name|defcmd
argument_list|)
expr_stmt|;
name|sCmdAct
index|[
name|strlen
argument_list|(
name|sCmdAct
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mktemp
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
comment|/* determine through machine */
name|i
operator|=
name|gothru
argument_list|(
name|local
argument_list|,
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|longname
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No path to %s machine.\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown machine\n"
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
name|dfname
index|[
name|strlen
argument_list|(
name|dfname
argument_list|)
operator|-
literal|11
index|]
operator|=
name|i
expr_stmt|;
comment|/* set directory */
name|dfname
index|[
name|strlen
argument_list|(
name|dfname
argument_list|)
operator|-
literal|7
index|]
operator|=
name|i
expr_stmt|;
comment|/* set file (unused) */
comment|/* check to see if data files are directories */
if|if
condition|(
name|isdirectory
argument_list|(
name|resp
argument_list|)
operator|||
name|isdirectory
argument_list|(
name|infile
argument_list|)
operator|||
name|isdirectory
argument_list|(
name|outfile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is a directory, must be a file\n"
argument_list|,
name|isdirectory
argument_list|(
name|resp
argument_list|)
condition|?
name|resp
else|:
name|isdirectory
argument_list|(
name|infile
argument_list|)
condition|?
name|infile
else|:
name|outfile
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|suid
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|uid
operator|=
name|atoi
argument_list|(
name|suid
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|resp
argument_list|,
literal|"/dev/tty"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't have /dev/tty as response file.\n"
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|resp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|s
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'/'
operator|&&
name|s
operator|>
operator|&
operator|(
name|buf
index|[
literal|0
index|]
operator|)
condition|)
name|s
operator|--
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
literal|"chkdir %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rfile
operator|=
name|fopen
argument_list|(
name|resp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
name|chmod
argument_list|(
name|resp
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rfile
argument_list|)
expr_stmt|;
name|mchown
argument_list|(
name|resp
argument_list|,
name|uid
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|access
argument_list|(
name|resp
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* go ahead and prompt for login name and passwd, if neccessary, 	   as long as the X option has not been specified */
if|if
condition|(
name|code
operator|==
literal|'q'
operator|&&
operator|!
name|xopt
condition|)
name|promptlogin
argument_list|(
name|remote
argument_list|)
expr_stmt|;
comment|/* at this point, we create the dfa... file */
name|file
operator|=
name|fopen
argument_list|(
name|dfname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
name|chmod
argument_list|(
name|dfname
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|mchown
argument_list|(
name|dfname
argument_list|,
name|uid
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|xopt
condition|)
goto|goto
name|stickit
goto|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|NEWPROT
if|if
condition|(
name|machtype
index|[
name|local
operator|-
literal|'a'
index|]
operator|==
name|M_CC
operator|&&
name|machtype
index|[
name|remote
operator|-
literal|'a'
index|]
operator|==
name|M_CC
operator|&&
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|s
operator|=
name|crypt
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|code
operator|==
literal|'q'
operator|&&
name|strcmp
argument_list|(
name|status
operator|.
name|login
argument_list|,
literal|"network"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Zero-length password not allowed\n"
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
literal|'q'
operator|&&
operator|(
name|streql
argument_list|(
name|status
operator|.
name|login
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
operator|||
name|streql
argument_list|(
name|status
operator|.
name|login
argument_list|,
literal|"ruut"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't login as root through the network\n"
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SPACCT
comment|/* handle special accounts */
comment|/* give a value for mgid and muid */
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
name|handlesp
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|status
operator|.
name|mpasswd
argument_list|,
name|status
operator|.
name|localname
argument_list|,
name|status
operator|.
name|muid
argument_list|,
name|status
operator|.
name|mgid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|enmask
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|)
expr_stmt|;
name|lTtytime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sTtyname
index|[
literal|0
index|]
operator|&&
name|status
operator|.
name|nowrite
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|fopen
argument_list|(
literal|"/etc/utmp"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"/etc/utmp"
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|fread
argument_list|(
operator|&
name|utmpstr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|utmpstr
argument_list|,
name|temp
argument_list|)
operator|==
sizeof|sizeof
name|utmpstr
condition|)
ifdef|#
directive|ifdef
name|OLDTTY
if|if
condition|(
name|utmpstr
operator|.
name|ut_tty
operator|==
name|sTtyname
index|[
literal|8
index|]
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|strcmp
argument_list|(
name|utmpstr
operator|.
name|ut_line
argument_list|,
name|sTtyname
operator|+
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|lTtytime
operator|=
name|utmpstr
operator|.
name|ut_time
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	debug("p:%s:\n",status.mpasswd); */
comment|/* cflag is initially 'a'. Add the flags as needed. */
if|if
condition|(
name|status
operator|.
name|nonotify
condition|)
name|cflag
operator|+=
name|F_NONOTIFY
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|quiet
condition|)
name|cflag
operator|+=
name|F_QUIET
expr_stmt|;
comment|/* 	protocol: 	code, remote mach, local mach, version stamp (2), remote login name, 	password, -i, -o, -r files, 	local login name, terminal, flag, utmp tty login time, 	cc jobno(variable parameter list), current time, 	command '\n' real command '\n' 	any data 	 	changes: 	1) remove header 	3) use ascii length instead of 4 bytes 	4) encrypt the login name, command, and part of data as well */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c :%c :%c :%c :%c :%s :%s :%s :%s :%s :%s :%s :%c :%lo :%d%s :%ld :"
argument_list|,
name|code
argument_list|,
name|remote
argument_list|,
name|local
argument_list|,
name|VMAJOR
operator|+
literal|'a'
argument_list|,
name|VMINOR
operator|+
literal|'a'
argument_list|,
name|status
operator|.
name|login
argument_list|,
name|status
operator|.
name|mpasswd
argument_list|,
name|infile
argument_list|,
name|outfile
argument_list|,
name|resp
argument_list|,
name|status
operator|.
name|localname
argument_list|,
name|sTtyname
argument_list|,
name|cflag
argument_list|,
name|lTtytime
argument_list|,
name|status
operator|.
name|jobno
argument_list|,
name|genparmlist
argument_list|()
argument_list|,
name|gettime
argument_list|()
operator|-
name|TIMEBASE
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|sCmdAct
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|sCmdVirt
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|stickit
label|:
comment|/* between ingres machines, allow long files */
comment|/* this should be parametrized on a per machine pair basis */
if|if
condition|(
name|machtype
index|[
name|local
operator|-
literal|'a'
index|]
operator|==
name|M_INGRES
operator|&&
name|machtype
index|[
name|remote
operator|-
literal|'a'
index|]
operator|==
name|M_INGRES
condition|)
name|maxfile
operator|=
name|MAXFILELARGE
expr_stmt|;
if|if
condition|(
name|sin
condition|)
while|while
condition|(
operator|(
name|i
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|file
argument_list|)
operator|!=
name|i
condition|)
block|{
name|perror
argument_list|(
literal|"net queue file"
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cnt
operator|+=
name|i
operator|)
operator|>
name|maxfile
condition|)
goto|goto
name|toobig
goto|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|localin
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|localin
argument_list|,
literal|4
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|localin
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
name|temp
operator|=
name|fopen
argument_list|(
name|localin
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|localin
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|temp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cnt
operator|+=
name|i
operator|)
operator|>
name|maxfile
condition|)
goto|goto
name|toobig
goto|;
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|file
argument_list|)
operator|!=
name|i
condition|)
block|{
name|perror
argument_list|(
literal|"net queue file"
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|dfname
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
name|dfname
index|[
name|strlen
argument_list|(
name|dfname
argument_list|)
operator|-
literal|9
index|]
operator|=
literal|'c'
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|dfname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|dfname
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|mchown
argument_list|(
name|dfname
argument_list|,
name|uid
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|toobig
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No more than %ld bytes can be sent\n"
argument_list|,
name|maxfile
argument_list|)
expr_stmt|;
name|outerror
argument_list|()
expr_stmt|;
comment|/* no return */
block|}
comment|/*     called if there is an error, makes sure that the files created    are deleted and the terminal is reset to echo */
name|outerror
argument_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|sgttyb
name|stt
decl_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|dfname
argument_list|)
operator|-
literal|9
expr_stmt|;
name|dfname
index|[
name|i
index|]
operator|=
operator|(
name|dfname
index|[
name|i
index|]
operator|==
literal|'c'
condition|?
literal|'d'
else|:
literal|'c'
operator|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|stt
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|stt
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
name|stty
argument_list|(
literal|0
argument_list|,
operator|&
name|stt
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|enmask
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|NEWPROT
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|nbsencrypt
argument_list|(
name|s
argument_list|,
name|THEKEY
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|s
operator|&=
literal|0177
expr_stmt|;
comment|/* strip quote bites */
operator|*
name|s
operator|++
operator|^=
literal|040
expr_stmt|;
comment|/* invert upper-lower */
block|}
endif|#
directive|endif
block|}
name|addir
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|t
expr_stmt|;
block|{
if|if
condition|(
name|t
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|gwd
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* returns pass if not special, otherwise returns funny passwd */
comment|/* list of special accounts must be consistent - with netdaemon.c */
name|char
modifier|*
name|handlesp
parameter_list|(
name|log
parameter_list|,
name|pass
parameter_list|,
name|localname
parameter_list|,
name|luid
parameter_list|,
name|lgid
parameter_list|)
name|char
modifier|*
name|log
decl_stmt|,
decl|*
name|pass
decl_stmt|,
modifier|*
name|localname
decl_stmt|;
block|{
comment|/* experimental */
ifdef|#
directive|ifdef
name|SPACCT
name|long
name|lt
decl_stmt|;
name|char
name|str
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|log
argument_list|,
name|localname
argument_list|)
operator|==
literal|0
operator|&&
name|luid
operator|!=
literal|0
operator|&&
name|lgid
operator|==
literal|0
operator|&&
operator|(
name|strcmp
argument_list|(
name|log
argument_list|,
literal|"source"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|log
argument_list|,
literal|"daemon"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|lt
operator|=
name|lgid
expr_stmt|;
name|lt
operator|=
operator|(
name|lt
operator|<<
literal|16
operator|)
operator||
name|luid
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%ld"
argument_list|,
name|lt
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|pass
operator|)
return|;
block|}
specifier|static
name|struct
name|stat
name|x
decl_stmt|;
specifier|static
name|struct
name|direct
name|y
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|static
name|int
name|off
init|=
operator|-
literal|1
decl_stmt|;
comment|/* these three routines gwd, cat, ckroot and     data structures x, y, off, do a pwd to string name */
name|gwd
argument_list|(
name|name
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
block|{
operator|*
name|name
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
literal|".."
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|y
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|y
argument_list|,
name|file
argument_list|)
operator|!=
sizeof|sizeof
name|y
condition|)
break|break;
block|}
do|while
condition|(
name|y
operator|.
name|d_ino
operator|!=
name|x
operator|.
name|st_ino
condition|)
do|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|.
name|d_ino
operator|==
name|ROOTINO
condition|)
block|{
name|ckroot
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cat
argument_list|(
name|name
argument_list|)
condition|)
break|break;
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
block|}
name|chdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|cat
argument_list|(
name|name
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
block|{
comment|/* return 1 to exit */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|y
operator|.
name|d_name
index|[
operator|++
name|i
index|]
operator|!=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|off
operator|+
name|i
operator|+
literal|2
operator|)
operator|>
literal|511
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|j
operator|=
name|off
operator|+
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|name
index|[
name|j
operator|+
name|i
operator|+
literal|1
index|]
operator|=
name|name
index|[
name|j
index|]
expr_stmt|;
name|off
operator|=
name|i
operator|+
name|off
operator|+
literal|1
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|name
index|[
name|i
index|]
operator|=
name|y
operator|.
name|d_name
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ckroot
argument_list|(
argument|name
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|y
operator|.
name|d_name
argument_list|,
operator|&
name|x
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|i
operator|=
name|x
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
literal|"/"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|y
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|y
argument_list|,
name|file
argument_list|)
operator|!=
sizeof|sizeof
name|y
condition|)
return|return;
if|if
condition|(
name|y
operator|.
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|stat
argument_list|(
name|y
operator|.
name|d_name
argument_list|,
operator|&
name|x
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
do|while
condition|(
name|x
operator|.
name|st_dev
operator|!=
name|i
operator|||
operator|(
name|x
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
do|;
if|if
condition|(
name|strcmp
argument_list|(
name|y
operator|.
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|y
operator|.
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|cat
argument_list|(
name|name
argument_list|)
condition|)
return|return;
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|name
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|name
index|[
name|i
index|]
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
return|return;
block|}
comment|/* 	this function takes a file name and tells whether it is a  	directory or on. Returns 1 if so, 0 otherwise. 	null strings etc. return 0. */
name|isdirectory
argument_list|(
argument|fn
argument_list|)
name|char
modifier|*
name|fn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
operator|||
operator|*
name|fn
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|=
name|strlen
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fn
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fn
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fn
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fn
argument_list|,
literal|"/."
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fn
operator|+
name|i
operator|-
literal|2
argument_list|,
literal|"/."
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fn
operator|+
name|i
operator|-
literal|3
argument_list|,
literal|"/.."
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	generate a variable parameter list 	the format is: 		(name value, name value, ..., name value) 	where names are unquoted single words and values 	are unquoted if a single alphanumeric word, and are 	surrounded by {} otherwise. \ quotes { and }. 	the values are escape-processed, e.g. \n becomes 012. 	this function returns such a list. 	Returns the null parm list if nothing to give, i.e. "()"   	Should also default so single keywords can have on/off 	states, and so do not require a value.  	Things this variable protocol should specify: 		EPASSWD 	encrypted passwd 		FILEMODE 	file mode 		FROMUID  	from users' uid 		FROMGID  	from users' gid 		COMPRESS 	use colin's compression 		SPACCT	 	handle special accounts. 		MESSAGEID	unique number identifying this request. 		VTOUSERNAME	name netq should display as being "To:" 		FILENAME	when omitted by netcp, will use FILENAME ext. 		MACHINE2	a second machine (e.g. 3way netcp) 		LOGIN2		a second login name 		PASSWD2		a second passwd 		REPLYTO		the person the response should be sent to  */
name|char
modifier|*
name|genparmlist
parameter_list|()
block|{
specifier|static
name|char
name|returnstr
index|[
name|PARMLIST
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|returnstr
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
return|return
operator|(
name|returnstr
operator|)
return|;
block|}
end_function

end_unit

