begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Peter McIlroy.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)append.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"sort.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|OUTPUT
value|{							\ 	if ((n = cpos - ppos)> 1) {					\ 		for (; ppos< cpos; ++ppos)				\ 			*ppos -= odepth;				\ 		ppos -= n;						\ 		radixsort(ppos, n, wts1, REC_D);			\ 		for (; ppos< cpos; ppos++) {				\ 			prec = (RECHEADER *) (*ppos - sizeof(TRECHEADER));\ 			put(prec, fd);					\ 		}							\ 	} else put(prec, fd);						\ }
end_define

begin_comment
comment|/*  * copy sorted lines to output; check for uniqueness  */
end_comment

begin_decl_stmt
name|void
name|append
argument_list|(
name|keylist
argument_list|,
name|nelem
argument_list|,
name|depth
argument_list|,
name|fd
argument_list|,
name|put
argument_list|,
name|ftbl
argument_list|)
name|u_char
modifier|*
modifier|*
name|keylist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nelem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|put
function_decl|)
parameter_list|(
name|RECHEADER
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|field
modifier|*
name|ftbl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|wts
decl_stmt|,
modifier|*
name|wts1
decl_stmt|;
specifier|register
name|n
operator|,
name|odepth
expr_stmt|;
specifier|register
name|u_char
modifier|*
modifier|*
name|cpos
decl_stmt|,
modifier|*
modifier|*
name|ppos
decl_stmt|,
modifier|*
modifier|*
name|lastkey
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cend
decl_stmt|,
modifier|*
name|pend
decl_stmt|,
modifier|*
name|start
decl_stmt|;
specifier|register
name|struct
name|recheader
modifier|*
name|crec
decl_stmt|,
modifier|*
name|prec
decl_stmt|;
if|if
condition|(
operator|*
name|keylist
operator|==
literal|'\0'
operator|&&
name|UNIQUE
condition|)
return|return;
name|wts1
operator|=
name|wts
operator|=
name|ftbl
index|[
literal|0
index|]
operator|.
name|weights
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|UNIQUE
operator|)
operator|&&
name|SINGL_FLD
condition|)
block|{
if|if
condition|(
name|ftbl
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|F
operator|&&
name|ftbl
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|R
condition|)
name|wts1
operator|=
name|Rascii
expr_stmt|;
elseif|else
if|if
condition|(
name|ftbl
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|F
condition|)
name|wts1
operator|=
name|ascii
expr_stmt|;
name|odepth
operator|=
name|depth
expr_stmt|;
block|}
name|lastkey
operator|=
name|keylist
operator|+
name|nelem
expr_stmt|;
name|depth
operator|+=
sizeof|sizeof
argument_list|(
name|TRECHEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|SINGL_FLD
operator|&&
operator|(
name|UNIQUE
operator|||
name|wts1
operator|!=
name|wts
operator|)
condition|)
block|{
name|ppos
operator|=
name|keylist
expr_stmt|;
name|prec
operator|=
operator|(
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|ppos
operator|-
name|depth
operator|)
expr_stmt|;
if|if
condition|(
name|UNIQUE
condition|)
name|put
argument_list|(
name|prec
argument_list|,
name|fd
argument_list|)
expr_stmt|;
for|for
control|(
name|cpos
operator|=
name|keylist
operator|+
literal|1
init|;
name|cpos
operator|<
name|lastkey
condition|;
name|cpos
operator|++
control|)
block|{
name|crec
operator|=
operator|(
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|cpos
operator|-
name|depth
operator|)
expr_stmt|;
if|if
condition|(
name|crec
operator|->
name|length
operator|==
name|prec
operator|->
name|length
condition|)
block|{
name|pend
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|prec
operator|->
name|offset
operator|+
name|prec
operator|->
name|length
expr_stmt|;
name|cend
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|crec
operator|->
name|offset
operator|+
name|crec
operator|->
name|length
expr_stmt|;
for|for
control|(
name|start
operator|=
operator|*
name|cpos
init|;
name|cend
operator|>=
name|start
condition|;
name|cend
operator|--
control|)
block|{
if|if
condition|(
name|wts
index|[
operator|*
name|cend
index|]
operator|!=
name|wts
index|[
operator|*
name|pend
index|]
condition|)
break|break;
name|pend
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pend
operator|+
literal|1
operator|!=
operator|*
name|ppos
condition|)
block|{
if|if
condition|(
operator|!
name|UNIQUE
condition|)
block|{
name|OUTPUT
expr_stmt|;
block|}
else|else
name|put
argument_list|(
name|crec
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ppos
operator|=
name|cpos
expr_stmt|;
name|prec
operator|=
name|crec
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|UNIQUE
condition|)
block|{
name|OUTPUT
expr_stmt|;
block|}
else|else
name|put
argument_list|(
name|crec
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ppos
operator|=
name|cpos
expr_stmt|;
name|prec
operator|=
name|crec
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|UNIQUE
condition|)
block|{
name|OUTPUT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|UNIQUE
condition|)
block|{
name|ppos
operator|=
name|keylist
expr_stmt|;
name|prec
operator|=
operator|(
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|ppos
operator|-
name|depth
operator|)
expr_stmt|;
name|put
argument_list|(
name|prec
argument_list|,
name|fd
argument_list|)
expr_stmt|;
for|for
control|(
name|cpos
operator|=
name|keylist
operator|+
literal|1
init|;
name|cpos
operator|<
name|lastkey
condition|;
name|cpos
operator|++
control|)
block|{
name|crec
operator|=
operator|(
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|cpos
operator|-
name|depth
operator|)
expr_stmt|;
if|if
condition|(
name|crec
operator|->
name|offset
operator|==
name|prec
operator|->
name|offset
condition|)
block|{
name|pend
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|prec
operator|->
name|offset
operator|+
name|prec
operator|->
name|offset
expr_stmt|;
name|cend
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|crec
operator|->
name|offset
operator|+
name|crec
operator|->
name|offset
expr_stmt|;
for|for
control|(
name|start
operator|=
operator|*
name|cpos
init|;
name|cend
operator|>=
name|start
condition|;
name|cend
operator|--
control|)
block|{
if|if
condition|(
name|wts
index|[
operator|*
name|cend
index|]
operator|!=
name|wts
index|[
operator|*
name|pend
index|]
condition|)
break|break;
name|pend
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pend
operator|+
literal|1
operator|!=
operator|*
name|ppos
condition|)
block|{
name|ppos
operator|=
name|cpos
expr_stmt|;
name|prec
operator|=
name|crec
expr_stmt|;
name|put
argument_list|(
name|prec
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ppos
operator|=
name|cpos
expr_stmt|;
name|prec
operator|=
name|crec
expr_stmt|;
name|put
argument_list|(
name|prec
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|cpos
operator|=
name|keylist
init|;
name|cpos
operator|<
name|lastkey
condition|;
name|cpos
operator|++
control|)
block|{
name|crec
operator|=
operator|(
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|cpos
operator|-
name|depth
operator|)
expr_stmt|;
name|put
argument_list|(
name|crec
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * output the already sorted eol bin.  */
end_comment

begin_function
name|void
name|rd_append
parameter_list|(
name|binno
parameter_list|,
name|infl0
parameter_list|,
name|nfiles
parameter_list|,
name|outfd
parameter_list|,
name|buffer
parameter_list|,
name|bufend
parameter_list|)
name|u_char
modifier|*
name|buffer
decl_stmt|,
decl|*
name|bufend
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|binno
decl_stmt|,
name|nfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|f_handle
name|infl0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|outfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|recheader
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
operator|(
name|RECHEADER
operator|*
operator|)
name|buffer
expr_stmt|;
if|if
condition|(
operator|!
name|getnext
argument_list|(
name|binno
argument_list|,
name|infl0
argument_list|,
name|nfiles
argument_list|,
operator|(
name|RECHEADER
operator|*
operator|)
name|buffer
argument_list|,
name|bufend
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|putline
argument_list|(
name|rec
argument_list|,
name|outfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|getnext
argument_list|(
name|binno
argument_list|,
name|infl0
argument_list|,
name|nfiles
argument_list|,
operator|(
name|RECHEADER
operator|*
operator|)
name|buffer
argument_list|,
name|bufend
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|UNIQUE
condition|)
name|putline
argument_list|(
name|rec
argument_list|,
name|outfd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * append plain text--used after sorting the biggest bin.  */
end_comment

begin_function
name|void
name|concat
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|FILE
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|nread
decl_stmt|;
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|rewind
argument_list|(
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nread
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
literal|4096
argument_list|,
name|b
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|EWRITE
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|nread
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

