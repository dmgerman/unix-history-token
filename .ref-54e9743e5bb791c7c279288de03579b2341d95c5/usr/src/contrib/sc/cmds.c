begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	SC	A Spreadsheet Calculator  *		Command routines  *  *		original by James Gosling, September 1982  *		modifications by Mark Weiser and Bruce Israel,  *			University of Maryland  *  *              More mods Robert Bond, 12/86  *  *		$Revision: 6.8 $  */
end_comment

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD43
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sc.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|SYSIII
end_ifndef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV3
end_ifdef

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFCOLDELIM
value|':'
end_define

begin_function
name|void
name|duprow
parameter_list|()
block|{
if|if
condition|(
name|currow
operator|>=
name|maxrows
operator|-
literal|1
operator|||
name|maxrow
operator|>=
name|maxrows
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|growtbl
argument_list|(
name|GROWROW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
name|modflg
operator|++
expr_stmt|;
name|currow
operator|++
expr_stmt|;
name|openrow
argument_list|(
name|currow
argument_list|)
expr_stmt|;
for|for
control|(
name|curcol
operator|=
literal|0
init|;
name|curcol
operator|<=
name|maxcol
condition|;
name|curcol
operator|++
control|)
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
init|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|currow
operator|-
literal|1
argument_list|,
name|curcol
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
specifier|register
name|struct
name|ent
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|lookat
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|copyent
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|curcol
operator|=
literal|0
init|;
name|curcol
operator|<=
name|maxcol
condition|;
name|curcol
operator|++
control|)
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
init|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|&&
operator|!
name|p
operator|->
name|expr
condition|)
break|break;
block|}
if|if
condition|(
name|curcol
operator|>
name|maxcol
condition|)
name|curcol
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dupcol
parameter_list|()
block|{
if|if
condition|(
name|curcol
operator|>=
name|maxcols
operator|-
literal|1
operator|||
name|maxcol
operator|>=
name|maxcols
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|growtbl
argument_list|(
name|GROWCOL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
name|modflg
operator|++
expr_stmt|;
name|curcol
operator|++
expr_stmt|;
name|opencol
argument_list|(
name|curcol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|currow
operator|=
literal|0
init|;
name|currow
operator|<=
name|maxrow
condition|;
name|currow
operator|++
control|)
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
init|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|currow
argument_list|,
name|curcol
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
specifier|register
name|struct
name|ent
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|lookat
argument_list|(
name|currow
argument_list|,
name|curcol
argument_list|)
expr_stmt|;
name|copyent
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|currow
operator|=
literal|0
init|;
name|currow
operator|<=
name|maxrow
condition|;
name|currow
operator|++
control|)
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
init|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|&&
operator|!
name|p
operator|->
name|expr
condition|)
break|break;
block|}
if|if
condition|(
name|currow
operator|>
name|maxrow
condition|)
name|currow
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insertrow
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|int
name|arg
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|arg
operator|>=
literal|0
condition|)
name|openrow
argument_list|(
name|currow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deleterow
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|int
name|arg
decl_stmt|;
block|{
name|flush_saved
argument_list|()
expr_stmt|;
name|erase_area
argument_list|(
name|currow
argument_list|,
literal|0
argument_list|,
name|currow
operator|+
name|arg
operator|-
literal|1
argument_list|,
name|maxcol
argument_list|)
expr_stmt|;
name|currow
operator|+=
name|arg
expr_stmt|;
while|while
condition|(
operator|--
name|arg
operator|>=
literal|0
condition|)
name|closerow
argument_list|(
operator|--
name|currow
argument_list|)
expr_stmt|;
name|sync_refs
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rowvalueize
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|int
name|arg
decl_stmt|;
block|{
name|valueize_area
argument_list|(
name|currow
argument_list|,
literal|0
argument_list|,
name|currow
operator|+
name|arg
operator|-
literal|1
argument_list|,
name|maxcol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|colvalueize
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|int
name|arg
decl_stmt|;
block|{
name|valueize_area
argument_list|(
literal|0
argument_list|,
name|curcol
argument_list|,
name|maxrow
argument_list|,
name|curcol
operator|+
name|arg
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|erase_area
parameter_list|(
name|sr
parameter_list|,
name|sc
parameter_list|,
name|er
parameter_list|,
name|ec
parameter_list|)
name|int
name|sr
decl_stmt|,
name|sc
decl_stmt|,
name|er
decl_stmt|,
name|ec
decl_stmt|;
block|{
specifier|register
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|sr
operator|>
name|er
condition|)
block|{
name|r
operator|=
name|sr
expr_stmt|;
name|sr
operator|=
name|er
expr_stmt|;
name|er
operator|=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|>
name|ec
condition|)
block|{
name|c
operator|=
name|sc
expr_stmt|;
name|sc
operator|=
name|ec
expr_stmt|;
name|ec
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|sr
operator|<
literal|0
condition|)
name|sr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|<
literal|0
condition|)
name|sc
operator|=
literal|0
expr_stmt|;
name|checkbounds
argument_list|(
operator|&
name|er
argument_list|,
operator|&
name|ec
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|sr
init|;
name|r
operator|<=
name|er
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
name|sc
init|;
name|c
operator|<=
name|ec
condition|;
name|c
operator|++
control|)
block|{
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
block|{
name|free_ent
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|valueize_area
parameter_list|(
name|sr
parameter_list|,
name|sc
parameter_list|,
name|er
parameter_list|,
name|ec
parameter_list|)
name|int
name|sr
decl_stmt|,
name|sc
decl_stmt|,
name|er
decl_stmt|,
name|ec
decl_stmt|;
block|{
specifier|register
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sr
operator|>
name|er
condition|)
block|{
name|r
operator|=
name|sr
expr_stmt|;
name|sr
operator|=
name|er
expr_stmt|;
name|er
operator|=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|>
name|ec
condition|)
block|{
name|c
operator|=
name|sc
expr_stmt|;
name|sc
operator|=
name|ec
expr_stmt|;
name|ec
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|sr
operator|<
literal|0
condition|)
name|sr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|<
literal|0
condition|)
name|sc
operator|=
literal|0
expr_stmt|;
name|checkbounds
argument_list|(
operator|&
name|er
argument_list|,
operator|&
name|ec
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|sr
init|;
name|r
operator|<=
name|er
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
name|sc
init|;
name|c
operator|<=
name|ec
condition|;
name|c
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|expr
condition|)
block|{
name|efree
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|expr
argument_list|)
expr_stmt|;
name|p
operator|->
name|expr
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
name|is_strexpr
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|pullcells
parameter_list|(
name|to_insert
parameter_list|)
name|int
name|to_insert
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|register
name|int
name|deltar
decl_stmt|,
name|deltac
decl_stmt|;
name|int
name|minrow
decl_stmt|,
name|mincol
decl_stmt|;
name|int
name|mxrow
decl_stmt|,
name|mxcol
decl_stmt|;
name|int
name|numrows
decl_stmt|,
name|numcols
decl_stmt|;
if|if
condition|(
operator|!
name|to_fix
condition|)
block|{
name|error
argument_list|(
literal|"No data to pull"
argument_list|)
expr_stmt|;
return|return;
block|}
name|minrow
operator|=
name|maxrows
expr_stmt|;
name|mincol
operator|=
name|maxcols
expr_stmt|;
name|mxrow
operator|=
literal|0
expr_stmt|;
name|mxcol
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|to_fix
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|row
operator|<
name|minrow
condition|)
name|minrow
operator|=
name|p
operator|->
name|row
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|row
operator|>
name|mxrow
condition|)
name|mxrow
operator|=
name|p
operator|->
name|row
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|col
operator|<
name|mincol
condition|)
name|mincol
operator|=
name|p
operator|->
name|col
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|col
operator|>
name|mxcol
condition|)
name|mxcol
operator|=
name|p
operator|->
name|col
expr_stmt|;
block|}
name|numrows
operator|=
name|mxrow
operator|-
name|minrow
operator|+
literal|1
expr_stmt|;
name|numcols
operator|=
name|mxcol
operator|-
name|mincol
operator|+
literal|1
expr_stmt|;
name|deltar
operator|=
name|currow
operator|-
name|minrow
expr_stmt|;
name|deltac
operator|=
name|curcol
operator|-
name|mincol
expr_stmt|;
if|if
condition|(
name|to_insert
operator|==
literal|'r'
condition|)
block|{
name|insertrow
argument_list|(
name|numrows
argument_list|)
expr_stmt|;
name|deltac
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|to_insert
operator|==
literal|'c'
condition|)
block|{
name|opencol
argument_list|(
name|curcol
argument_list|,
name|numcols
argument_list|)
expr_stmt|;
name|deltar
operator|=
literal|0
expr_stmt|;
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|to_fix
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|n
operator|=
name|lookat
argument_list|(
name|p
operator|->
name|row
operator|+
name|deltar
argument_list|,
name|p
operator|->
name|col
operator|+
name|deltac
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clearent
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|copyent
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
name|deltar
argument_list|,
name|deltac
argument_list|)
expr_stmt|;
name|n
operator|->
name|flags
operator|=
name|p
operator|->
name|flags
operator|&
operator|~
name|is_deleted
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|colshow_op
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxcols
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|col_hidden
index|[
name|i
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|maxcols
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|col_hidden
index|[
name|j
index|]
condition|)
break|break;
name|j
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|maxcols
condition|)
name|error
argument_list|(
literal|"No hidden columns to show"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"show %s:"
argument_list|,
name|coltoa
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|coltoa
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rowshow_op
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxrows
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|row_hidden
index|[
name|i
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|maxrows
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|row_hidden
index|[
name|j
index|]
condition|)
block|{
break|break;
block|}
name|j
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|maxrows
condition|)
name|error
argument_list|(
literal|"No hidden rows to show"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"show %d:%d"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given a row/column command letter, emit a small menu, then read a qualifier  * character for a row/column command and convert it to 'r' (row), 'c'  * (column), or 0 (unknown).  If ch is 'p', an extra qualifier 'm' is allowed.  */
end_comment

begin_function
name|int
name|get_rcqual
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|error
argument_list|(
literal|"%sow/column:  r: row  c: column%s"
argument_list|,
operator|(
name|ch
operator|==
literal|'i'
operator|)
condition|?
literal|"Insert r"
else|:
operator|(
name|ch
operator|==
literal|'a'
operator|)
condition|?
literal|"Append r"
else|:
operator|(
name|ch
operator|==
literal|'d'
operator|)
condition|?
literal|"Delete r"
else|:
operator|(
name|ch
operator|==
literal|'p'
operator|)
condition|?
literal|"Pull r"
else|:
operator|(
name|ch
operator|==
literal|'v'
operator|)
condition|?
literal|"Values r"
else|:
operator|(
name|ch
operator|==
literal|'z'
operator|)
condition|?
literal|"Zap r"
else|:
operator|(
name|ch
operator|==
literal|'s'
operator|)
condition|?
literal|"Show r"
else|:
literal|"R"
argument_list|,
operator|(
name|ch
operator|==
literal|'p'
operator|)
condition|?
literal|"  m: merge"
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|nmgetch
argument_list|()
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'l'
case|:
case|case
literal|'h'
case|:
case|case
name|ctl
argument_list|(
literal|'f'
argument_list|)
case|:
case|case
name|ctl
argument_list|(
literal|'b'
argument_list|)
case|:
return|return
operator|(
literal|'r'
operator|)
return|;
case|case
literal|'c'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
name|ctl
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
name|ctl
argument_list|(
literal|'n'
argument_list|)
case|:
return|return
operator|(
literal|'c'
operator|)
return|;
case|case
literal|'m'
case|:
return|return
operator|(
operator|(
name|ch
operator|==
literal|'p'
operator|)
condition|?
literal|'m'
else|:
literal|0
operator|)
return|;
case|case
name|ESC
case|:
case|case
name|ctl
argument_list|(
literal|'g'
argument_list|)
case|:
return|return
operator|(
name|ESC
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|void
name|openrow
parameter_list|(
name|rs
parameter_list|)
name|int
name|rs
decl_stmt|;
block|{
specifier|register
name|r
operator|,
name|c
expr_stmt|;
name|struct
name|ent
modifier|*
modifier|*
name|tmprow
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|rs
operator|>
name|maxrow
condition|)
name|maxrow
operator|=
name|rs
expr_stmt|;
if|if
condition|(
name|maxrow
operator|>=
name|maxrows
operator|-
literal|1
operator|||
name|rs
operator|>
name|maxrows
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|growtbl
argument_list|(
name|GROWROW
argument_list|,
name|rs
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
comment|/* 	 * save the last active row+1, shift the rows downward, put the last 	 * row in place of the first 	 */
name|tmprow
operator|=
name|tbl
index|[
operator|++
name|maxrow
index|]
expr_stmt|;
for|for
control|(
name|r
operator|=
name|maxrow
init|;
name|r
operator|>
name|rs
condition|;
name|r
operator|--
control|)
block|{
name|row_hidden
index|[
name|r
index|]
operator|=
name|row_hidden
index|[
name|r
operator|-
literal|1
index|]
expr_stmt|;
name|tbl
index|[
name|r
index|]
operator|=
name|tbl
index|[
name|r
operator|-
literal|1
index|]
expr_stmt|;
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|maxcols
condition|;
name|c
operator|++
operator|,
name|pp
operator|++
control|)
if|if
condition|(
operator|*
name|pp
condition|)
operator|(
operator|*
name|pp
operator|)
operator|->
name|row
operator|=
name|r
expr_stmt|;
block|}
name|tbl
index|[
name|r
index|]
operator|=
name|tmprow
expr_stmt|;
comment|/* the last row was never used.... */
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|closerow
argument_list|(
name|r
argument_list|)
decl|register
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|struct
name|ent
modifier|*
modifier|*
name|tmprow
decl_stmt|;
if|if
condition|(
name|r
operator|>
name|maxrow
condition|)
return|return;
comment|/* save the row and empty it out */
name|tmprow
operator|=
name|tbl
index|[
name|r
index|]
expr_stmt|;
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|maxcol
operator|+
literal|1
init|;
operator|--
name|c
operator|>=
literal|0
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pp
condition|)
block|{
name|free_ent
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* move the rows, put the deleted row at the end */
for|for
control|(
init|;
name|r
operator|<
name|maxrows
operator|-
literal|1
condition|;
name|r
operator|++
control|)
block|{
name|row_hidden
index|[
name|r
index|]
operator|=
name|row_hidden
index|[
name|r
operator|+
literal|1
index|]
expr_stmt|;
name|tbl
index|[
name|r
index|]
operator|=
name|tbl
index|[
name|r
operator|+
literal|1
index|]
expr_stmt|;
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|maxcols
condition|;
name|c
operator|++
operator|,
name|pp
operator|++
control|)
if|if
condition|(
operator|*
name|pp
condition|)
operator|(
operator|*
name|pp
operator|)
operator|->
name|row
operator|=
name|r
expr_stmt|;
block|}
name|tbl
index|[
name|r
index|]
operator|=
name|tmprow
expr_stmt|;
name|maxrow
operator|--
expr_stmt|;
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|void
name|opencol
parameter_list|(
name|cs
parameter_list|,
name|numcol
parameter_list|)
name|int
name|cs
decl_stmt|;
name|int
name|numcol
decl_stmt|;
block|{
specifier|register
name|r
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|register
name|lim
operator|=
name|maxcol
operator|-
name|cs
operator|+
literal|1
expr_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cs
operator|>
name|maxcol
condition|)
name|maxcol
operator|=
name|cs
expr_stmt|;
name|maxcol
operator|+=
name|numcol
expr_stmt|;
if|if
condition|(
operator|(
name|maxcol
operator|>=
name|maxcols
operator|-
literal|1
operator|)
operator|&&
operator|!
name|growtbl
argument_list|(
name|GROWCOL
argument_list|,
literal|0
argument_list|,
name|maxcol
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|maxcol
init|;
name|i
operator|>
name|cs
condition|;
name|i
operator|--
control|)
block|{
name|fwidth
index|[
name|i
index|]
operator|=
name|fwidth
index|[
name|i
operator|-
name|numcol
index|]
expr_stmt|;
name|precision
index|[
name|i
index|]
operator|=
name|precision
index|[
name|i
operator|-
name|numcol
index|]
expr_stmt|;
name|col_hidden
index|[
name|i
index|]
operator|=
name|col_hidden
index|[
name|i
operator|-
name|numcol
index|]
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|cs
init|;
name|c
operator|-
name|cs
operator|<
name|numcol
condition|;
name|c
operator|++
control|)
block|{
name|fwidth
index|[
name|c
index|]
operator|=
name|DEFWIDTH
expr_stmt|;
name|precision
index|[
name|c
index|]
operator|=
name|DEFPREC
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|maxrow
condition|;
name|r
operator|++
control|)
block|{
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|maxcol
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|lim
init|;
operator|--
name|c
operator|>=
literal|0
condition|;
name|pp
operator|--
control|)
if|if
condition|(
name|pp
index|[
literal|0
index|]
operator|=
name|pp
index|[
operator|-
name|numcol
index|]
condition|)
name|pp
index|[
literal|0
index|]
operator|->
name|col
operator|+=
name|numcol
expr_stmt|;
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|cs
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|cs
init|;
name|c
operator|-
name|cs
operator|<
name|numcol
condition|;
name|c
operator|++
operator|,
name|pp
operator|++
control|)
operator|*
name|pp
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|closecol
parameter_list|(
name|cs
parameter_list|,
name|numcol
parameter_list|)
name|int
name|cs
decl_stmt|;
name|int
name|numcol
decl_stmt|;
block|{
specifier|register
name|r
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|q
decl_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|register
name|lim
operator|=
name|maxcol
operator|-
name|cs
expr_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
name|lim
operator|-
name|numcol
operator|<
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Can't delete %d column%s %d columns left"
argument_list|,
name|numcol
argument_list|,
operator|(
name|numcol
operator|>
literal|1
condition|?
literal|"s,"
else|:
literal|","
operator|)
argument_list|,
name|lim
operator|+
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|flush_saved
argument_list|()
expr_stmt|;
name|erase_area
argument_list|(
literal|0
argument_list|,
name|curcol
argument_list|,
name|maxrow
argument_list|,
name|curcol
operator|+
name|numcol
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sync_refs
argument_list|()
expr_stmt|;
comment|/* clear then copy the block left */
name|lim
operator|=
name|maxcols
operator|-
name|numcol
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|maxrow
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
name|cs
init|;
name|c
operator|-
name|cs
operator|<
name|numcol
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|q
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
condition|)
name|free_ent
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|cs
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|cs
init|;
name|c
operator|<=
name|lim
condition|;
name|c
operator|++
operator|,
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|>
name|lim
condition|)
operator|*
name|pp
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
index|[
literal|0
index|]
operator|=
name|pp
index|[
name|numcol
index|]
condition|)
name|pp
index|[
literal|0
index|]
operator|->
name|col
operator|-=
name|numcol
expr_stmt|;
block|}
name|c
operator|=
name|numcol
expr_stmt|;
for|for
control|(
init|;
operator|--
name|c
operator|>=
literal|0
condition|;
name|pp
operator|++
control|)
operator|*
name|pp
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|cs
init|;
name|i
operator|<
name|maxcols
operator|-
name|numcol
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|fwidth
index|[
name|i
index|]
operator|=
name|fwidth
index|[
name|i
operator|+
name|numcol
index|]
expr_stmt|;
name|precision
index|[
name|i
index|]
operator|=
name|precision
index|[
name|i
operator|+
name|numcol
index|]
expr_stmt|;
name|col_hidden
index|[
name|i
index|]
operator|=
name|col_hidden
index|[
name|i
operator|+
name|numcol
index|]
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|maxcols
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|fwidth
index|[
name|i
index|]
operator|=
name|DEFWIDTH
expr_stmt|;
name|precision
index|[
name|i
index|]
operator|=
name|DEFPREC
expr_stmt|;
name|col_hidden
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|maxcol
operator|-=
name|numcol
expr_stmt|;
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|doend
parameter_list|(
name|rowinc
parameter_list|,
name|colinc
parameter_list|)
name|int
name|rowinc
decl_stmt|,
name|colinc
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
condition|)
block|{
name|r
operator|=
name|currow
operator|+
name|rowinc
expr_stmt|;
name|c
operator|=
name|curcol
operator|+
name|colinc
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|&&
name|r
operator|<
name|maxrows
operator|&&
name|c
operator|>=
literal|0
operator|&&
name|c
operator|<
name|maxcols
operator|&&
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|currow
operator|=
name|r
expr_stmt|;
name|curcol
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|rowinc
condition|)
block|{
case|case
operator|-
literal|1
case|:
while|while
condition|(
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|currow
operator|>
literal|0
condition|)
name|currow
operator|--
expr_stmt|;
break|break;
case|case
literal|1
case|:
while|while
condition|(
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|currow
operator|<
name|maxrows
operator|-
literal|1
condition|)
name|currow
operator|++
expr_stmt|;
break|break;
case|case
literal|0
case|:
switch|switch
condition|(
name|colinc
condition|)
block|{
case|case
operator|-
literal|1
case|:
while|while
condition|(
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|curcol
operator|>
literal|0
condition|)
name|curcol
operator|--
expr_stmt|;
break|break;
case|case
literal|1
case|:
while|while
condition|(
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|curcol
operator|<
name|maxcols
operator|-
literal|1
condition|)
name|curcol
operator|++
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|error
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* clear line */
return|return;
block|}
switch|switch
condition|(
name|rowinc
condition|)
block|{
case|case
operator|-
literal|1
case|:
while|while
condition|(
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|currow
operator|>
literal|0
condition|)
name|currow
operator|--
expr_stmt|;
break|break;
case|case
literal|1
case|:
while|while
condition|(
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|currow
operator|<
name|maxrows
operator|-
literal|1
condition|)
name|currow
operator|++
expr_stmt|;
break|break;
case|case
literal|0
case|:
switch|switch
condition|(
name|colinc
condition|)
block|{
case|case
operator|-
literal|1
case|:
while|while
condition|(
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|curcol
operator|>
literal|0
condition|)
name|curcol
operator|--
expr_stmt|;
break|break;
case|case
literal|1
case|:
while|while
condition|(
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
operator|&&
name|curcol
operator|<
name|maxcols
operator|-
literal|1
condition|)
name|curcol
operator|++
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|VALID_CELL
argument_list|(
name|p
argument_list|,
name|currow
argument_list|,
name|curcol
argument_list|)
condition|)
block|{
name|currow
operator|-=
name|rowinc
expr_stmt|;
name|curcol
operator|-=
name|colinc
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|doformat
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|,
name|w
parameter_list|,
name|p
parameter_list|)
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|w
decl_stmt|,
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|w
operator|>
name|COLS
operator|-
name|RESCOL
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Format too large - Maximum = %d"
argument_list|,
name|COLS
operator|-
name|RESCOL
operator|-
literal|2
argument_list|)
expr_stmt|;
name|w
operator|=
name|COLS
operator|-
name|RESCOL
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>
name|w
condition|)
block|{
name|error
argument_list|(
literal|"Precision too large"
argument_list|)
expr_stmt|;
name|p
operator|=
name|w
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|c1
init|;
name|i
operator|<=
name|c2
condition|;
name|i
operator|++
control|)
name|fwidth
index|[
name|i
index|]
operator|=
name|w
operator|,
name|precision
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_options
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|autocalc
operator|&&
name|propagation
operator|==
literal|10
operator|&&
name|calc_order
operator|==
name|BYROWS
operator|&&
operator|!
name|numeric
operator|&&
name|prescale
operator|==
literal|1.0
operator|&&
operator|!
name|extfunc
operator|&&
name|showcell
operator|&&
name|showtop
operator|&&
name|tbl_style
operator|==
literal|0
condition|)
return|return;
comment|/* No reason to do this */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"set"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|autocalc
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" !autocalc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|propagation
operator|!=
literal|10
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" iterations = %d"
argument_list|,
name|propagation
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc_order
operator|!=
name|BYROWS
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" bycols"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" numeric"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prescale
operator|!=
literal|1.0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" prescale"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extfunc
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" extfun"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|showcell
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" !cellcur"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|showtop
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" !toprow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbl_style
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" tblstyle = %s"
argument_list|,
name|tbl_style
operator|==
name|TBL
condition|?
literal|"tbl"
else|:
name|tbl_style
operator|==
name|LATEX
condition|?
literal|"latex"
else|:
name|tbl_style
operator|==
name|TEX
condition|?
literal|"tex"
else|:
literal|"0"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printfile
parameter_list|(
name|fname
parameter_list|,
name|r0
parameter_list|,
name|c0
parameter_list|,
name|rn
parameter_list|,
name|cn
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|r0
decl_stmt|,
name|c0
decl_stmt|,
name|rn
decl_stmt|,
name|cn
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|pline
index|[
name|FBUFLEN
index|]
decl_stmt|;
name|int
name|plinelim
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|fieldlen
decl_stmt|,
name|nextcol
decl_stmt|;
specifier|register
name|row
operator|,
name|col
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|curfile
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|yn_ask
argument_list|(
literal|"Confirm that you want to destroy the data base: (y,n)"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|f
operator|=
name|openout
argument_list|(
name|fname
argument_list|,
operator|&
name|pid
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't create file \"%s\""
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|row
operator|=
name|r0
init|;
name|row
operator|<=
name|rn
condition|;
name|row
operator|++
control|)
block|{
specifier|register
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|row_hidden
index|[
name|row
index|]
condition|)
continue|continue;
name|pline
index|[
name|plinelim
operator|=
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|row
argument_list|,
name|col
operator|=
name|c0
argument_list|)
init|;
name|col
operator|<=
name|cn
condition|;
name|pp
operator|+=
name|nextcol
operator|-
name|col
operator|,
name|col
operator|=
name|nextcol
operator|,
name|c
operator|+=
name|fieldlen
control|)
block|{
name|nextcol
operator|=
name|col
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|col_hidden
index|[
name|col
index|]
condition|)
block|{
name|fieldlen
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|fieldlen
operator|=
name|fwidth
index|[
name|col
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
name|plinelim
operator|<
name|c
condition|)
name|pline
index|[
name|plinelim
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|plinelim
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pline
operator|+
name|plinelim
argument_list|,
literal|"%*.*f"
argument_list|,
name|fwidth
index|[
name|col
index|]
argument_list|,
name|precision
index|[
name|col
index|]
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|v
argument_list|)
expr_stmt|;
name|plinelim
operator|+=
name|strlen
argument_list|(
name|pline
operator|+
name|plinelim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|=
operator|(
operator|*
name|pp
operator|)
operator|->
name|label
condition|)
block|{
name|int
name|slen
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|register
name|char
modifier|*
name|fp
decl_stmt|;
name|struct
name|ent
modifier|*
name|nc
decl_stmt|;
comment|/* Figure out if the label slops over to a blank field */
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|slen
operator|>
name|fieldlen
operator|&&
name|nextcol
operator|<=
name|cn
operator|&&
operator|!
operator|(
operator|(
name|nc
operator|=
name|lookat
argument_list|(
name|row
argument_list|,
name|nextcol
argument_list|)
operator|)
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|&&
operator|!
operator|(
name|nc
operator|->
name|label
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|col_hidden
index|[
name|nextcol
index|]
condition|)
name|fieldlen
operator|+=
name|fwidth
index|[
name|nextcol
index|]
expr_stmt|;
name|nextcol
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|slen
operator|>
name|fieldlen
condition|)
name|slen
operator|=
name|fieldlen
expr_stmt|;
comment|/* Now justify and print */
name|start
operator|=
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_leftflush
condition|?
name|pline
operator|+
name|c
else|:
name|pline
operator|+
name|c
operator|+
name|fieldlen
operator|-
name|slen
expr_stmt|;
name|last
operator|=
name|pline
operator|+
name|c
operator|+
name|fieldlen
expr_stmt|;
name|fp
operator|=
name|plinelim
operator|<
name|c
condition|?
name|pline
operator|+
name|plinelim
else|:
name|pline
operator|+
name|c
expr_stmt|;
while|while
condition|(
name|fp
operator|<
name|start
condition|)
operator|*
name|fp
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|slen
operator|--
condition|)
operator|*
name|fp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|||
name|fieldlen
operator|!=
name|fwidth
index|[
name|col
index|]
condition|)
while|while
condition|(
name|fp
operator|<
name|last
condition|)
operator|*
name|fp
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|plinelim
operator|<
name|fp
operator|-
name|pline
condition|)
name|plinelim
operator|=
name|fp
operator|-
name|pline
expr_stmt|;
block|}
block|}
block|}
name|pline
index|[
name|plinelim
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|pline
index|[
name|plinelim
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|pline
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|closeout
argument_list|(
name|f
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tblprintfile
parameter_list|(
name|fname
parameter_list|,
name|r0
parameter_list|,
name|c0
parameter_list|,
name|rn
parameter_list|,
name|cn
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|r0
decl_stmt|,
name|c0
decl_stmt|,
name|rn
decl_stmt|,
name|cn
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|pid
decl_stmt|;
specifier|register
name|row
operator|,
name|col
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
name|coldelim
init|=
name|DEFCOLDELIM
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|curfile
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|yn_ask
argument_list|(
literal|"Confirm that you want to destroy the data base: (y,n)"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|f
operator|=
name|openout
argument_list|(
name|fname
argument_list|,
operator|&
name|pid
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't create file \"%s\""
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tbl_style
operator|==
name|TBL
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|".\\\" ** %s spreadsheet output \n.TS\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"tab(%c);\n"
argument_list|,
name|coldelim
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
name|c0
init|;
name|col
operator|<=
name|cn
condition|;
name|col
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tbl_style
operator|==
name|LATEX
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%% ** %s spreadsheet output\n\\begin{tabular}{"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
name|c0
init|;
name|col
operator|<=
name|cn
condition|;
name|col
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"c"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|coldelim
operator|=
literal|'&'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tbl_style
operator|==
name|TEX
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"{\t%% ** %s spreadsheet output\n\\settabs %d \\columns\n"
argument_list|,
name|progname
argument_list|,
name|cn
operator|-
name|c0
operator|+
literal|1
argument_list|)
expr_stmt|;
name|coldelim
operator|=
literal|'&'
expr_stmt|;
block|}
for|for
control|(
name|row
operator|=
name|r0
init|;
name|row
operator|<=
name|rn
condition|;
name|row
operator|++
control|)
block|{
if|if
condition|(
name|tbl_style
operator|==
name|TEX
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\\+"
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|row
argument_list|,
name|col
operator|=
name|c0
argument_list|)
init|;
name|col
operator|<=
name|cn
condition|;
name|col
operator|++
operator|,
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pp
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%.*f"
argument_list|,
name|precision
index|[
name|col
index|]
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|=
operator|(
operator|*
name|pp
operator|)
operator|->
name|label
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|col
operator|<
name|cn
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%c"
argument_list|,
name|coldelim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbl_style
operator|==
name|LATEX
condition|)
block|{
if|if
condition|(
name|row
operator|<
name|rn
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tbl_style
operator|==
name|TEX
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\\cr"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbl_style
operator|==
name|TBL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|".TE\n.\\\" ** end of %s spreadsheet output\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tbl_style
operator|==
name|LATEX
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\\end{tabular}\n%% ** end of %s spreadsheet output\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tbl_style
operator|==
name|TEX
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n%% ** end of %s spreadsheet output\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|closeout
argument_list|(
name|f
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|enode
modifier|*
name|copye
parameter_list|(
name|e
parameter_list|,
name|Rdelta
parameter_list|,
name|Cdelta
parameter_list|)
specifier|register
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
name|int
name|Rdelta
decl_stmt|,
name|Cdelta
decl_stmt|;
block|{
specifier|register
name|struct
name|enode
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|e
operator|==
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
condition|)
block|{
name|ret
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|op
operator|&
name|REDUCE
condition|)
block|{
name|int
name|newrow
decl_stmt|,
name|newcol
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|enode
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|op
operator|=
name|e
operator|->
name|op
expr_stmt|;
name|newrow
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vf
operator|&
name|FIX_ROW
condition|?
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|row
else|:
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|row
operator|+
name|Rdelta
expr_stmt|;
name|newcol
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vf
operator|&
name|FIX_COL
condition|?
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|col
else|:
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|col
operator|+
name|Cdelta
expr_stmt|;
name|ret
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|=
name|lookat
argument_list|(
name|newrow
argument_list|,
name|newcol
argument_list|)
expr_stmt|;
name|ret
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vf
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vf
expr_stmt|;
name|newrow
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vf
operator|&
name|FIX_ROW
condition|?
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|row
else|:
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|row
operator|+
name|Rdelta
expr_stmt|;
name|newcol
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vf
operator|&
name|FIX_COL
condition|?
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|col
else|:
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|col
operator|+
name|Cdelta
expr_stmt|;
name|ret
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|=
name|lookat
argument_list|(
name|newrow
argument_list|,
name|newcol
argument_list|)
expr_stmt|;
name|ret
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vf
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vf
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|enode
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|op
operator|=
name|e
operator|->
name|op
expr_stmt|;
switch|switch
condition|(
name|ret
operator|->
name|op
condition|)
block|{
case|case
literal|'v'
case|:
block|{
name|int
name|newrow
decl_stmt|,
name|newcol
decl_stmt|;
name|newrow
operator|=
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vf
operator|&
name|FIX_ROW
condition|?
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vp
operator|->
name|row
else|:
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vp
operator|->
name|row
operator|+
name|Rdelta
expr_stmt|;
name|newcol
operator|=
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vf
operator|&
name|FIX_COL
condition|?
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vp
operator|->
name|col
else|:
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vp
operator|->
name|col
operator|+
name|Cdelta
expr_stmt|;
name|ret
operator|->
name|e
operator|.
name|v
operator|.
name|vp
operator|=
name|lookat
argument_list|(
name|newrow
argument_list|,
name|newcol
argument_list|)
expr_stmt|;
name|ret
operator|->
name|e
operator|.
name|v
operator|.
name|vf
operator|=
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vf
expr_stmt|;
break|break;
block|}
case|case
literal|'k'
case|:
name|ret
operator|->
name|e
operator|.
name|k
operator|=
name|e
operator|->
name|e
operator|.
name|k
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ret
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|=
name|copye
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|->
name|e
operator|.
name|o
operator|.
name|left
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|ret
operator|->
name|e
operator|.
name|s
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|e
operator|->
name|e
operator|.
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ret
operator|->
name|e
operator|.
name|s
argument_list|,
name|e
operator|->
name|e
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|=
name|copye
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
name|Rdelta
argument_list|,
name|Cdelta
argument_list|)
expr_stmt|;
name|ret
operator|->
name|e
operator|.
name|o
operator|.
name|left
operator|=
name|copye
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
name|Rdelta
argument_list|,
name|Cdelta
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * sync_refs and syncref are used to remove references to  * deleted struct ents.  Note that the deleted structure must still  * be hanging around before the call, but not referenced by an entry  * in tbl.  Thus the free_ent, fix_ent calls in sc.c  */
end_comment

begin_function
name|void
name|sync_refs
parameter_list|()
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|sync_ranges
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxrow
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|maxcol
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|expr
condition|)
name|syncref
argument_list|(
name|p
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|syncref
parameter_list|(
name|e
parameter_list|)
specifier|register
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|e
operator|==
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|e
operator|->
name|op
operator|&
name|REDUCE
condition|)
block|{
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|=
name|lookat
argument_list|(
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|row
argument_list|,
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|col
argument_list|)
expr_stmt|;
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|=
name|lookat
argument_list|(
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|row
argument_list|,
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|col
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|e
operator|->
name|op
condition|)
block|{
case|case
literal|'v'
case|:
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vp
operator|=
name|lookat
argument_list|(
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vp
operator|->
name|row
argument_list|,
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vp
operator|->
name|col
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
break|break;
case|case
literal|'$'
case|:
break|break;
default|default:
name|syncref
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
expr_stmt|;
name|syncref
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|hiderow
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
specifier|register
name|int
name|r1
decl_stmt|;
specifier|register
name|int
name|r2
decl_stmt|;
name|r1
operator|=
name|currow
expr_stmt|;
name|r2
operator|=
name|r1
operator|+
name|arg
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
operator|||
name|r1
operator|>
name|r2
condition|)
block|{
name|error
argument_list|(
literal|"Invalid range"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r2
operator|>=
name|maxrows
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|growtbl
argument_list|(
name|GROWROW
argument_list|,
name|arg
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"You can't hide the last row"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
while|while
condition|(
name|r1
operator|<=
name|r2
condition|)
name|row_hidden
index|[
name|r1
operator|++
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hidecol
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
specifier|register
name|int
name|c1
decl_stmt|;
specifier|register
name|int
name|c2
decl_stmt|;
name|c1
operator|=
name|curcol
expr_stmt|;
name|c2
operator|=
name|c1
operator|+
name|arg
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c1
operator|<
literal|0
operator|||
name|c1
operator|>
name|c2
condition|)
block|{
name|error
argument_list|(
literal|"Invalid range"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c2
operator|>=
name|maxcols
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|arg
operator|>=
name|ABSMAXCOLS
operator|-
literal|1
operator|)
operator|||
operator|!
name|growtbl
argument_list|(
name|GROWCOL
argument_list|,
literal|0
argument_list|,
name|arg
operator|+
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"You can't hide the last col"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|<=
name|c2
condition|)
name|col_hidden
index|[
name|c1
operator|++
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|showrow
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
block|{
if|if
condition|(
name|r1
operator|<
literal|0
operator|||
name|r1
operator|>
name|r2
condition|)
block|{
name|error
argument_list|(
literal|"Invalid range"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r2
operator|>
name|maxrows
operator|-
literal|1
condition|)
block|{
name|r2
operator|=
name|maxrows
operator|-
literal|1
expr_stmt|;
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
while|while
condition|(
name|r1
operator|<=
name|r2
condition|)
name|row_hidden
index|[
name|r1
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|showcol
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
block|{
if|if
condition|(
name|c1
operator|<
literal|0
operator|||
name|c1
operator|>
name|c2
condition|)
block|{
name|error
argument_list|(
literal|"Invalid range"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c2
operator|>
name|maxcols
operator|-
literal|1
condition|)
block|{
name|c2
operator|=
name|maxcols
operator|-
literal|1
expr_stmt|;
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|<=
name|c2
condition|)
name|col_hidden
index|[
name|c1
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open the output file, setting up a pipe if needed */
end_comment

begin_function
name|FILE
modifier|*
name|openout
parameter_list|(
name|fname
parameter_list|,
name|rpid
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
modifier|*
name|rpid
decl_stmt|;
block|{
name|int
name|pipefd
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|efname
decl_stmt|;
while|while
condition|(
operator|*
name|fname
operator|&&
operator|(
operator|*
name|fname
operator|==
literal|' '
operator|)
condition|)
comment|/* Skip leading blanks */
name|fname
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fname
operator|!=
literal|'|'
condition|)
block|{
comment|/* Open file if not pipe */
operator|*
name|rpid
operator|=
literal|0
expr_stmt|;
name|efname
operator|=
name|findhome
argument_list|(
name|fname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOBACKUPS
if|if
condition|(
operator|!
name|backup_file
argument_list|(
name|efname
argument_list|)
operator|&&
operator|(
name|yn_ask
argument_list|(
literal|"Could not create backup copy, Save anyhow?: (y,n)"
argument_list|)
operator|!=
literal|1
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|fopen
argument_list|(
name|efname
argument_list|,
literal|"w"
argument_list|)
operator|)
return|;
block|}
name|fname
operator|++
expr_stmt|;
comment|/* Skip | */
if|if
condition|(
name|pipe
argument_list|(
name|pipefd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't make pipe to child"
argument_list|)
expr_stmt|;
operator|*
name|rpid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|deraw
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No son tasks available yet under VMS--sorry\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
comment|/* if child  */
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* close stdin */
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* connect to pipe input */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* reset */
operator|(
name|void
operator|)
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|127
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* else parent */
block|{
operator|*
name|rpid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fdopen
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|kill
argument_list|(
name|pid
argument_list|,
operator|-
literal|9
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Can't fdopen output"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|rpid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* VMS */
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
name|void
name|closeout
parameter_list|(
name|f
parameter_list|,
name|pid
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|pid
decl_stmt|;
block|{
name|int
name|temp
decl_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
while|while
condition|(
name|pid
operator|!=
name|wait
argument_list|(
operator|&
name|temp
argument_list|)
condition|)
comment|/**/
empty_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Press RETURN to continue "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nmgetch
argument_list|()
expr_stmt|;
name|goraw
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|copyent
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|,
name|dr
parameter_list|,
name|dc
parameter_list|)
specifier|register
name|struct
name|ent
modifier|*
name|n
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|dr
decl_stmt|,
name|dc
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|n
operator|||
operator|!
name|p
condition|)
block|{
name|error
argument_list|(
literal|"internal error"
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|->
name|v
operator|=
name|p
operator|->
name|v
expr_stmt|;
name|n
operator|->
name|flags
operator|=
name|p
operator|->
name|flags
expr_stmt|;
name|n
operator|->
name|expr
operator|=
name|copye
argument_list|(
name|p
operator|->
name|expr
argument_list|,
name|dr
argument_list|,
name|dc
argument_list|)
expr_stmt|;
name|n
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|label
condition|)
block|{
name|n
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|label
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|n
operator|->
name|label
argument_list|,
name|p
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|write_fd
parameter_list|(
name|f
parameter_list|,
name|r0
parameter_list|,
name|c0
parameter_list|,
name|rn
parameter_list|,
name|cn
parameter_list|)
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|r0
decl_stmt|,
name|c0
decl_stmt|,
name|rn
decl_stmt|,
name|cn
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|r
operator|,
name|c
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"# This data file was generated by the Spreadsheet "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Calculator.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"# You almost certainly shouldn't edit it.\n\n"
argument_list|)
expr_stmt|;
name|print_options
argument_list|(
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|maxcols
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|fwidth
index|[
name|c
index|]
operator|!=
name|DEFWIDTH
operator|||
name|precision
index|[
name|c
index|]
operator|!=
name|DEFPREC
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"format %s %d %d\n"
argument_list|,
name|coltoa
argument_list|(
name|c
argument_list|)
argument_list|,
name|fwidth
index|[
name|c
index|]
argument_list|,
name|precision
index|[
name|c
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|c0
init|;
name|c
operator|<
name|cn
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|col_hidden
index|[
name|c
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"hide %s\n"
argument_list|,
name|coltoa
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|r
operator|=
name|r0
init|;
name|r
operator|<=
name|rn
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|row_hidden
index|[
name|r
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"hide %d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|write_range
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdir
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"mdir \"%s\"\n"
argument_list|,
name|mdir
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|r0
init|;
name|r
operator|<=
name|rn
condition|;
name|r
operator|++
control|)
block|{
name|pp
operator|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|c0
init|;
name|c
operator|<=
name|cn
condition|;
name|c
operator|++
operator|,
name|pp
operator|++
control|)
if|if
condition|(
operator|*
name|pp
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|label
condition|)
block|{
name|edits
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
name|editv
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|writefile
parameter_list|(
name|fname
parameter_list|,
name|r0
parameter_list|,
name|c0
parameter_list|,
name|rn
parameter_list|,
name|cn
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|r0
decl_stmt|,
name|c0
decl_stmt|,
name|rn
decl_stmt|,
name|cn
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|save
index|[
name|PATHLEN
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|Crypt
condition|)
block|{
return|return
operator|(
name|cwritefile
argument_list|(
name|fname
argument_list|,
name|r0
argument_list|,
name|c0
argument_list|,
name|rn
argument_list|,
name|cn
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
operator|*
name|fname
operator|==
literal|'\0'
condition|)
name|fname
operator|=
name|curfile
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|save
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|openout
argument_list|(
name|fname
argument_list|,
operator|&
name|pid
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't create file \"%s\""
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|write_fd
argument_list|(
name|f
argument_list|,
name|r0
argument_list|,
name|c0
argument_list|,
name|rn
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|closeout
argument_list|(
name|f
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pid
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|curfile
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|modflg
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"File \"%s\" written."
argument_list|,
name|curfile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|readfile
parameter_list|(
name|fname
parameter_list|,
name|eraseflg
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|eraseflg
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|save
index|[
name|PATHLEN
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|fname
operator|==
literal|'*'
operator|&&
name|mdir
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|save
argument_list|,
name|mdir
argument_list|)
expr_stmt|;
operator|*
name|fname
operator|=
literal|'/'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|save
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|fname
operator|==
literal|'\0'
condition|)
name|fname
operator|=
name|curfile
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|save
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|Crypt
condition|)
block|{
name|creadfile
argument_list|(
name|save
argument_list|,
name|eraseflg
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|eraseflg
operator|&&
name|strcmp
argument_list|(
name|fname
argument_list|,
name|curfile
argument_list|)
operator|&&
name|modcheck
argument_list|(
literal|" first"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|findhome
argument_list|(
name|save
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't read file \"%s\""
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eraseflg
condition|)
name|erasedb
argument_list|()
expr_stmt|;
name|loading
operator|++
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|linelim
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
operator|(
name|void
operator|)
name|yyparse
argument_list|()
expr_stmt|;
block|}
operator|--
name|loading
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|linelim
operator|=
operator|-
literal|1
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
if|if
condition|(
name|eraseflg
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|curfile
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|modflg
operator|=
literal|0
expr_stmt|;
block|}
name|EvalAll
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|erasedb
parameter_list|()
block|{
specifier|register
name|r
operator|,
name|c
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<=
name|maxcol
condition|;
name|c
operator|++
control|)
block|{
name|fwidth
index|[
name|c
index|]
operator|=
name|DEFWIDTH
expr_stmt|;
name|precision
index|[
name|c
index|]
operator|=
name|DEFPREC
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|maxrow
condition|;
name|r
operator|++
control|)
block|{
specifier|register
name|struct
name|ent
modifier|*
modifier|*
name|pp
init|=
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|++
operator|<=
name|maxcol
condition|;
name|pp
operator|++
control|)
if|if
condition|(
operator|*
name|pp
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|expr
condition|)
name|efree
argument_list|(
operator|*
name|pp
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|label
condition|)
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|label
operator|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|pp
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
name|maxrow
operator|=
literal|0
expr_stmt|;
name|maxcol
operator|=
literal|0
expr_stmt|;
name|clean_range
argument_list|()
expr_stmt|;
name|FullUpdate
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|backcol
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|arg
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|curcol
condition|)
name|curcol
operator|--
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"At column A"
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|col_hidden
index|[
name|curcol
index|]
operator|&&
name|curcol
condition|)
name|curcol
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|forwcol
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|arg
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|curcol
operator|<
name|maxcols
operator|-
literal|1
condition|)
name|curcol
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|growtbl
argument_list|(
name|GROWCOL
argument_list|,
literal|0
argument_list|,
name|arg
argument_list|)
condition|)
comment|/* get as much as needed */
break|break;
while|while
condition|(
name|col_hidden
index|[
name|curcol
index|]
operator|&&
operator|(
name|curcol
operator|<
name|maxcols
operator|-
literal|1
operator|)
condition|)
name|curcol
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|forwrow
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|arg
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|currow
operator|<
name|maxrows
operator|-
literal|1
condition|)
name|currow
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|growtbl
argument_list|(
name|GROWROW
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* get as much as needed */
break|break;
while|while
condition|(
name|row_hidden
index|[
name|currow
index|]
operator|&&
operator|(
name|currow
operator|<
name|maxrows
operator|-
literal|1
operator|)
condition|)
name|currow
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|backrow
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|arg
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|currow
condition|)
name|currow
operator|--
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"At row zero"
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|row_hidden
index|[
name|currow
index|]
operator|&&
name|currow
condition|)
name|currow
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Show a cell's label string or expression value.  May overwrite value if  * there is one already displayed in the cell.  Created from old code in  * update(), copied with minimal changes.  */
end_comment

begin_function
name|void
name|showstring
parameter_list|(
name|string
parameter_list|,
name|leftflush
parameter_list|,
name|hasvalue
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|,
name|nextcolp
parameter_list|,
name|mxcol
parameter_list|,
name|fieldlenp
parameter_list|,
name|r
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* to display */
name|int
name|leftflush
decl_stmt|;
comment|/* or rightflush */
name|int
name|hasvalue
decl_stmt|;
comment|/* is there a numeric value? */
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
comment|/* spreadsheet location */
name|int
modifier|*
name|nextcolp
decl_stmt|;
comment|/* value returned through it */
name|int
name|mxcol
decl_stmt|;
comment|/* last column displayed? */
name|int
modifier|*
name|fieldlenp
decl_stmt|;
comment|/* value returned through it */
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
comment|/* screen row and column */
block|{
specifier|register
name|int
name|nextcol
init|=
operator|*
name|nextcolp
decl_stmt|;
specifier|register
name|int
name|fieldlen
init|=
operator|*
name|fieldlenp
decl_stmt|;
name|char
name|field
index|[
name|FBUFLEN
index|]
decl_stmt|;
name|int
name|slen
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|register
name|char
modifier|*
name|fp
decl_stmt|;
name|struct
name|ent
modifier|*
name|nc
decl_stmt|;
comment|/* This figures out if the label is allowed to        slop over into the next blank field */
name|slen
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|slen
operator|>
name|fieldlen
operator|)
operator|&&
operator|(
name|nextcol
operator|<=
name|mxcol
operator|)
operator|&&
operator|!
operator|(
operator|(
name|nc
operator|=
name|lookat
argument_list|(
name|row
argument_list|,
name|nextcol
argument_list|)
operator|)
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|&&
operator|!
operator|(
name|nc
operator|->
name|label
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|col_hidden
index|[
name|nextcol
index|]
condition|)
name|fieldlen
operator|+=
name|fwidth
index|[
name|nextcol
index|]
expr_stmt|;
name|nextcol
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|slen
operator|>
name|fieldlen
condition|)
name|slen
operator|=
name|fieldlen
expr_stmt|;
comment|/* Now justify and print */
name|start
operator|=
name|leftflush
condition|?
name|field
else|:
name|field
operator|+
name|fieldlen
operator|-
name|slen
expr_stmt|;
name|last
operator|=
name|field
operator|+
name|fieldlen
expr_stmt|;
name|fp
operator|=
name|field
expr_stmt|;
while|while
condition|(
name|fp
operator|<
name|start
condition|)
operator|*
name|fp
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|slen
operator|--
condition|)
operator|*
name|fp
operator|++
operator|=
operator|*
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|hasvalue
operator|)
operator|||
name|fieldlen
operator|!=
name|fwidth
index|[
name|col
index|]
condition|)
while|while
condition|(
name|fp
operator|<
name|last
condition|)
operator|*
name|fp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|fp
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|mvaddstr
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* this is a macro */
else|#
directive|else
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|field
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|nextcolp
operator|=
name|nextcol
expr_stmt|;
operator|*
name|fieldlenp
operator|=
name|fieldlen
expr_stmt|;
block|}
end_function

begin_function
name|int
name|etype
parameter_list|(
name|e
parameter_list|)
specifier|register
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|e
operator|==
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
condition|)
return|return
name|NUM
return|;
switch|switch
condition|(
name|e
operator|->
name|op
condition|)
block|{
case|case
name|O_SCONST
case|:
case|case
literal|'#'
case|:
case|case
name|DATE
case|:
case|case
name|FMT
case|:
case|case
name|STINDEX
case|:
case|case
name|EXT
case|:
case|case
name|SVAL
case|:
case|case
name|SUBSTR
case|:
return|return
operator|(
name|STR
operator|)
return|;
case|case
literal|'?'
case|:
case|case
name|IF
case|:
return|return
operator|(
name|etype
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|)
return|;
case|case
literal|'f'
case|:
return|return
operator|(
name|etype
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|O_VAR
case|:
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vp
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|expr
condition|)
return|return
operator|(
name|p
operator|->
name|flags
operator|&
name|is_strexpr
condition|?
name|STR
else|:
name|NUM
operator|)
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|label
condition|)
return|return
operator|(
name|STR
operator|)
return|;
else|else
return|return
operator|(
name|NUM
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|NUM
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* return 1 if yes given, 0 otherwise */
end_comment

begin_function
name|int
name|yn_ask
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|char
name|ch
decl_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
name|ch
operator|=
name|nmgetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'y'
operator|&&
name|ch
operator|!=
literal|'Y'
operator|&&
name|ch
operator|!=
literal|'n'
operator|&&
name|ch
operator|!=
literal|'N'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
name|ctl
argument_list|(
literal|'g'
argument_list|)
operator|||
name|ch
operator|==
name|ESC
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|error
argument_list|(
literal|"y or n response required"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'y'
operator|||
name|ch
operator|==
literal|'Y'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_function
name|char
modifier|*
name|findhome
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|HomeDir
init|=
name|NULL
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
if|if
condition|(
operator|*
name|path
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|pathptr
decl_stmt|;
name|char
name|tmppath
index|[
name|PATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|HomeDir
operator|==
name|NULL
condition|)
block|{
name|HomeDir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HomeDir
operator|==
name|NULL
condition|)
name|HomeDir
operator|=
literal|"/"
expr_stmt|;
block|}
name|pathptr
operator|=
name|path
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pathptr
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
name|pathptr
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|tmppath
argument_list|,
name|HomeDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|char
modifier|*
name|namep
decl_stmt|;
name|char
name|name
index|[
literal|50
index|]
decl_stmt|;
name|namep
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pathptr
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|pathptr
operator|!=
literal|'/'
operator|)
condition|)
operator|*
operator|(
name|namep
operator|++
operator|)
operator|=
operator|*
operator|(
name|pathptr
operator|++
operator|)
expr_stmt|;
operator|*
name|namep
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|pwent
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"Can't find user %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|tmppath
argument_list|,
name|pwent
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|tmppath
argument_list|,
name|pathptr
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|tmppath
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DOBACKUPS
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*  * make a backup copy of a file, use the same mode and name in the format  * [path/]#file~  * return 1 if we were successful, 0 otherwise  */
end_comment

begin_function
name|int
name|backup_file
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
name|fname
index|[
name|PATHLEN
index|]
decl_stmt|;
name|char
name|tpath
index|[
name|PATHLEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|sequent
name|char
modifier|*
name|buf
decl_stmt|;
else|#
directive|else
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|tpp
decl_stmt|;
name|int
name|infd
decl_stmt|,
name|outfd
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* tpath will be the [path/]file ---> [path/]#file~ */
name|strcpy
argument_list|(
name|tpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tpp
operator|=
name|strrchr
argument_list|(
name|tpath
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tpp
operator|=
name|tpath
expr_stmt|;
else|else
name|tpp
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|tpp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tpp
argument_list|,
literal|"#%s~"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|sequent
if|if
condition|(
operator|(
name|buf
operator|=
name|xmalloc
argument_list|(
name|statbuf
operator|.
name|st_blksize
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|infd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|sequent
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|outfd
operator|=
name|open
argument_list|(
name|tpath
argument_list|,
name|O_TRUNC
operator||
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|sequent
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|sequent
while|while
condition|(
operator|(
name|count
operator|=
name|read
argument_list|(
name|infd
argument_list|,
name|buf
argument_list|,
name|statbuf
operator|.
name|st_blksize
argument_list|)
operator|)
operator|>
literal|0
condition|)
else|#
directive|else
while|while
condition|(
operator|(
name|count
operator|=
name|read
argument_list|(
name|infd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|write
argument_list|(
name|outfd
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
block|{
name|count
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|close
argument_list|(
name|infd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|outfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sequent
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|count
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

