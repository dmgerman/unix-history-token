begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1985 Regents of the University of California.  *   * Use and reproduction of this software are granted  in  accordance  with  * the terms and conditions specified in  the  Berkeley  Software  License  * Agreement (in particular, this entails acknowledgement of the programs'  * source, and inclusion of this notice) with the additional understanding  * that  all  recipients  should regard themselves as participants  in  an  * ongoing  research  project and hence should  feel  obligated  to report  * their  experiences (good or bad) with these elementary function  codes,  * using "sendbug 4bsd-bugs@BERKELEY", to the authors.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)trig.c	1.2 (Berkeley) 8/22/85; 1.7 (ucb.elefunt) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* SIN(X), COS(X), TAN(X)  * RETURN THE SINE, COSINE, AND TANGENT OF X RESPECTIVELY  * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)  * CODED IN C BY K.C. NG, 1/8/85;   * REVISED BY W. Kahan and K.C. NG, 8/17/85.  *  * Required system supported functions:  *      copysign(x,y)  *      finite(x)  *      drem(x,p)  *  * Static kernel functions:  *      sin__S(z)       ....sin__S(x*x) return (sin(x)-x)/x  *      cos__C(z)       ....cos__C(x*x) return cos(x)-1-x*x/2  *  * Method.  *      Let S and C denote the polynomial approximations to sin and cos   *      respectively on [-PI/4, +PI/4].  *  *      SIN and COS:  *      1. Reduce the argument into [-PI , +PI] by the remainder function.    *      2. For x in (-PI,+PI), there are three cases:  *			case 1:	|x|< PI/4  *			case 2:	PI/4<= |x|< 3PI/4  *			case 3:	3PI/4<= |x|.  *	   SIN and COS of x are computed by:  *  *                   sin(x)      cos(x)       remark  *     ----------------------------------------------------------  *        case 1     S(x)         C(x)         *        case 2 sign(x)*C(y)     S(y)      y=PI/2-|x|  *        case 3     S(y)        -C(y)      y=sign(x)*(PI-|x|)  *     ----------------------------------------------------------  *  *      TAN:  *      1. Reduce the argument into [-PI/2 , +PI/2] by the remainder function.    *      2. For x in (-PI/2,+PI/2), there are two cases:  *			case 1:	|x|< PI/4  *			case 2:	PI/4<= |x|< PI/2  *         TAN of x is computed by:  *  *                   tan (x)            remark  *     ----------------------------------------------------------  *        case 1     S(x)/C(x)  *        case 2     C(y)/S(y)     y=sign(x)*(PI/2-|x|)  *     ----------------------------------------------------------  *  *   Notes:  *      1. S(y) and C(y) were computed by:  *              S(y) = y+y*sin__S(y*y)   *              C(y) = 1-(y*y/2-cos__C(x*x))          ... if y*y/2<  thresh,  *                   = 0.5-((y*y/2-0.5)-cos__C(x*x))  ... if y*y/2>= thresh.  *         where  *              thresh = 0.5*(acos(3/4)**2)  *  *      2. For better accuracy, we use the following formula for S/C for tan  *         (k=0): let ss=sin__S(y*y), and cc=cos__C(y*y), then  *  *                            y+y*ss             (y*y/2-cc)+ss  *             S(y)/C(y)   = -------- = y + y * ---------------.  *                               C                     C   *  *  * Special cases:  *      Let trig be any of sin, cos, or tan.  *      trig(+-INF)  is NaN, with signals;  *      trig(NaN)    is that NaN;  *      trig(n*PI/2) is exact for any integer n, provided n*PI is   *      representable; otherwise, trig(x) is inexact.   *  * Accuracy:  *      trig(x) returns the exact trig(x*pi/PI) nearly rounded, where  *  *      Decimal:  *              pi = 3.141592653589793 23846264338327 .....   *    53 bits   PI = 3.141592653589793 115997963 ..... ,  *    56 bits   PI = 3.141592653589793 227020265 ..... ,    *  *      Hexadecimal:  *              pi = 3.243F6A8885A308D313198A2E....  *    53 bits   PI = 3.243F6A8885A30  =  2 * 1.921FB54442D18    error=.276ulps  *    56 bits   PI = 3.243F6A8885A308 =  4 * .C90FDAA22168C2    error=.206ulps  *  *      In a test run with 1,024,000 random arguments on a VAX, the maximum  *      observed errors (compared with the exact trig(x*pi/PI)) were  *                      tan(x) : 2.09 ulps (around 4.716340404662354)  *                      sin(x) : .861 ulps  *                      cos(x) : .857 ulps  *  * Constants:  * The hexadecimal values are the intended ones for the following constants.  * The decimal values may be used, provided that the compiler will convert  * from decimal to binary accurately enough to produce the hexadecimal values  * shown.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|_0x
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|0x
comment|/**/
value|A
comment|/**/
value|B
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* vax */
end_comment

begin_define
define|#
directive|define
name|_0x
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|0x
comment|/**/
value|B
comment|/**/
value|A
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* vax */
end_comment

begin_comment
comment|/*thresh =  2.6117239648121182150E-1    , Hex  2^ -1   *  .85B8636B026EA0 */
end_comment

begin_comment
comment|/*PIo4   =  7.8539816339744830676E-1    , Hex  2^  0   *  .C90FDAA22168C2 */
end_comment

begin_comment
comment|/*PIo2   =  1.5707963267948966135E0     , Hex  2^  1   *  .C90FDAA22168C2 */
end_comment

begin_comment
comment|/*PI3o4  =  2.3561944901923449203E0     , Hex  2^  2   *  .96CBE3F9990E92 */
end_comment

begin_comment
comment|/*PI     =  3.1415926535897932270E0     , Hex  2^  2   *  .C90FDAA22168C2 */
end_comment

begin_comment
comment|/*PI2    =  6.2831853071795864540E0     ; Hex  2^  3   *  .C90FDAA22168C2 */
end_comment

begin_decl_stmt
specifier|static
name|long
name|threshx
index|[]
init|=
block|{
name|_0x
argument_list|(
name|b863
argument_list|,
literal|3f85
argument_list|)
block|,
name|_0x
argument_list|(
literal|6ea0
argument_list|,
literal|6b02
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|thresh
value|(*(double*)threshx)
end_define

begin_decl_stmt
specifier|static
name|long
name|PIo4x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0fda
argument_list|,
literal|4049
argument_list|)
block|,
name|_0x
argument_list|(
literal|68c2
argument_list|,
argument|a221
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PIo4
value|(*(double*)PIo4x)
end_define

begin_decl_stmt
specifier|static
name|long
name|PIo2x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0fda
argument_list|,
literal|40c9
argument_list|)
block|,
name|_0x
argument_list|(
literal|68c2
argument_list|,
argument|a221
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PIo2
value|(*(double*)PIo2x)
end_define

begin_decl_stmt
specifier|static
name|long
name|PI3o4x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|cbe3
argument_list|,
literal|4116
argument_list|)
block|,
name|_0x
argument_list|(
literal|0e92
argument_list|,
argument|f999
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PI3o4
value|(*(double*)PI3o4x)
end_define

begin_decl_stmt
specifier|static
name|long
name|PIx
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0fda
argument_list|,
literal|4149
argument_list|)
block|,
name|_0x
argument_list|(
literal|68c2
argument_list|,
argument|a221
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PI
value|(*(double*)PIx)
end_define

begin_decl_stmt
specifier|static
name|long
name|PI2x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0fda
argument_list|,
literal|41c9
argument_list|)
block|,
name|_0x
argument_list|(
literal|68c2
argument_list|,
argument|a221
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PI2
value|(*(double*)PI2x)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(vax)||defined(tahoe) */
end_comment

begin_decl_stmt
specifier|static
name|double
name|thresh
init|=
literal|2.6117239648121182150E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -2   *  1.0B70C6D604DD4 */
name|PIo4
init|=
literal|7.8539816339744827900E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -1   *  1.921FB54442D18 */
name|PIo2
init|=
literal|1.5707963267948965580E0
decl_stmt|,
comment|/*Hex  2^  0   *  1.921FB54442D18 */
name|PI3o4
init|=
literal|2.3561944901923448370E0
decl_stmt|,
comment|/*Hex  2^  1   *  1.2D97C7F3321D2 */
name|PI
init|=
literal|3.1415926535897931160E0
decl_stmt|,
comment|/*Hex  2^  1   *  1.921FB54442D18 */
name|PI2
init|=
literal|6.2831853071795862320E0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Hex  2^  2   *  1.921FB54442D18 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|national
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|fmaxx
index|[]
init|=
block|{
literal|0xffffffff
block|,
literal|0x7fefffff
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|fmax
value|(*(double*)fmaxx)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* national */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(vax)||defined(tahoe) */
end_comment

begin_decl_stmt
specifier|static
name|double
name|zero
init|=
literal|0
decl_stmt|,
name|one
init|=
literal|1
decl_stmt|,
name|negone
init|=
operator|-
literal|1
decl_stmt|,
name|half
init|=
literal|1.0
operator|/
literal|2.0
decl_stmt|,
name|small
init|=
literal|1E
operator|-
literal|10
decl_stmt|,
comment|/* 1+small**2==1; better values for small: 					small = 1.5E-9 for VAX D 					      = 1.2E-8 for IEEE Double 					      = 2.8E-10 for IEEE Extended */
name|big
init|=
literal|1E20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* big = 1/(small**2) */
end_comment

begin_function
name|double
name|tan
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|copysign
argument_list|()
decl_stmt|,
name|drem
argument_list|()
decl_stmt|,
name|cos__C
argument_list|()
decl_stmt|,
name|sin__S
argument_list|()
decl_stmt|,
name|a
decl_stmt|,
name|z
decl_stmt|,
name|ss
decl_stmt|,
name|cc
decl_stmt|,
name|c
decl_stmt|;
name|int
name|finite
argument_list|()
decl_stmt|,
name|k
decl_stmt|;
comment|/* tan(NaN) and tan(INF) must be NaN */
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|-
name|x
operator|)
return|;
name|x
operator|=
name|drem
argument_list|(
name|x
argument_list|,
name|PI
argument_list|)
expr_stmt|;
comment|/* reduce x into [-PI/2, PI/2] */
name|a
operator|=
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
expr_stmt|;
comment|/* ... = abs(x) */
if|if
condition|(
name|a
operator|>=
name|PIo4
condition|)
block|{
name|k
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|copysign
argument_list|(
name|PIo2
operator|-
name|a
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|small
condition|)
block|{
name|big
operator|+
name|a
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
name|z
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|cc
operator|=
name|cos__C
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|ss
operator|=
name|sin__S
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|z
operator|=
name|z
operator|*
name|half
expr_stmt|;
comment|/* Next get c = cos(x) accurately */
name|c
operator|=
operator|(
name|z
operator|>=
name|thresh
operator|)
condition|?
name|half
operator|-
operator|(
operator|(
name|z
operator|-
name|half
operator|)
operator|-
name|cc
operator|)
else|:
name|one
operator|-
operator|(
name|z
operator|-
name|cc
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
operator|(
name|x
operator|+
operator|(
name|x
operator|*
operator|(
name|z
operator|-
operator|(
name|cc
operator|-
name|ss
operator|)
operator|)
operator|)
operator|/
name|c
operator|)
return|;
comment|/* sin/cos */
ifdef|#
directive|ifdef
name|national
elseif|else
if|if
condition|(
name|x
operator|==
literal|0.0
condition|)
return|return
name|copysign
argument_list|(
name|fmax
argument_list|,
name|x
argument_list|)
return|;
comment|/* no inf on 32k */
endif|#
directive|endif
comment|/* national */
else|else
return|return
operator|(
name|c
operator|/
operator|(
name|x
operator|+
name|x
operator|*
name|ss
operator|)
operator|)
return|;
comment|/*          ... cos/sin */
block|}
end_function

begin_function
name|double
name|sin
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|copysign
argument_list|()
decl_stmt|,
name|drem
argument_list|()
decl_stmt|,
name|sin__S
argument_list|()
decl_stmt|,
name|cos__C
argument_list|()
decl_stmt|,
name|a
decl_stmt|,
name|c
decl_stmt|,
name|z
decl_stmt|;
name|int
name|finite
parameter_list|()
function_decl|;
comment|/* sin(NaN) and sin(INF) must be NaN */
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|-
name|x
operator|)
return|;
name|x
operator|=
name|drem
argument_list|(
name|x
argument_list|,
name|PI2
argument_list|)
expr_stmt|;
comment|/*    reduce x into [-PI, PI] */
name|a
operator|=
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|>=
name|PIo4
condition|)
block|{
if|if
condition|(
name|a
operator|>=
name|PI3o4
condition|)
comment|/* 	.. in [3PI/4,  PI ]  */
name|x
operator|=
name|copysign
argument_list|(
operator|(
name|a
operator|=
name|PI
operator|-
name|a
operator|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 	.. in [PI/4, 3PI/4]  */
name|a
operator|=
name|PIo2
operator|-
name|a
expr_stmt|;
comment|/* return sign(x)*C(PI/2-|x|) */
name|z
operator|=
name|a
operator|*
name|a
expr_stmt|;
name|c
operator|=
name|cos__C
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|z
operator|=
name|z
operator|*
name|half
expr_stmt|;
name|a
operator|=
operator|(
name|z
operator|>=
name|thresh
operator|)
condition|?
name|half
operator|-
operator|(
operator|(
name|z
operator|-
name|half
operator|)
operator|-
name|c
operator|)
else|:
name|one
operator|-
operator|(
name|z
operator|-
name|c
operator|)
expr_stmt|;
return|return
operator|(
name|copysign
argument_list|(
name|a
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* return S(x) */
if|if
condition|(
name|a
operator|<
name|small
condition|)
block|{
name|big
operator|+
name|a
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
return|return
operator|(
name|x
operator|+
name|x
operator|*
name|sin__S
argument_list|(
name|x
operator|*
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|double
name|cos
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|copysign
argument_list|()
decl_stmt|,
name|drem
argument_list|()
decl_stmt|,
name|sin__S
argument_list|()
decl_stmt|,
name|cos__C
argument_list|()
decl_stmt|,
name|a
decl_stmt|,
name|c
decl_stmt|,
name|z
decl_stmt|,
name|s
init|=
literal|1.0
decl_stmt|;
name|int
name|finite
parameter_list|()
function_decl|;
comment|/* cos(NaN) and cos(INF) must be NaN */
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|-
name|x
operator|)
return|;
name|x
operator|=
name|drem
argument_list|(
name|x
argument_list|,
name|PI2
argument_list|)
expr_stmt|;
comment|/*    reduce x into [-PI, PI] */
name|a
operator|=
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|>=
name|PIo4
condition|)
block|{
if|if
condition|(
name|a
operator|>=
name|PI3o4
condition|)
comment|/* 	.. in [3PI/4,  PI ]  */
block|{
name|a
operator|=
name|PI
operator|-
name|a
expr_stmt|;
name|s
operator|=
name|negone
expr_stmt|;
block|}
else|else
comment|/* 	.. in [PI/4, 3PI/4]  */
comment|/*        return  S(PI/2-|x|) */
block|{
name|a
operator|=
name|PIo2
operator|-
name|a
expr_stmt|;
return|return
operator|(
name|a
operator|+
name|a
operator|*
name|sin__S
argument_list|(
name|a
operator|*
name|a
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* return s*C(a) */
if|if
condition|(
name|a
operator|<
name|small
condition|)
block|{
name|big
operator|+
name|a
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
name|z
operator|=
name|a
operator|*
name|a
expr_stmt|;
name|c
operator|=
name|cos__C
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|z
operator|=
name|z
operator|*
name|half
expr_stmt|;
name|a
operator|=
operator|(
name|z
operator|>=
name|thresh
operator|)
condition|?
name|half
operator|-
operator|(
operator|(
name|z
operator|-
name|half
operator|)
operator|-
name|c
operator|)
else|:
name|one
operator|-
operator|(
name|z
operator|-
name|c
operator|)
expr_stmt|;
return|return
operator|(
name|copysign
argument_list|(
name|a
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sin__S(x*x)  * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)  * STATIC KERNEL FUNCTION OF SIN(X), COS(X), AND TAN(X)   * CODED IN C BY K.C. NG, 1/21/85;   * REVISED BY K.C. NG on 8/13/85.  *  *	    sin(x*k) - x  * RETURN  --------------- on [-PI/4,PI/4] , where k=pi/PI, PI is the rounded  *	            x	  * value of pi in machine precision:  *  *	Decimal:  *		pi = 3.141592653589793 23846264338327 .....   *    53 bits   PI = 3.141592653589793 115997963 ..... ,  *    56 bits   PI = 3.141592653589793 227020265 ..... ,    *  *	Hexadecimal:  *		pi = 3.243F6A8885A308D313198A2E....  *    53 bits   PI = 3.243F6A8885A30  =  2 * 1.921FB54442D18  *    56 bits   PI = 3.243F6A8885A308 =  4 * .C90FDAA22168C2      *  * Method:  *	1. Let z=x*x. Create a polynomial approximation to   *	    (sin(k*x)-x)/x  =  z*(S0 + S1*z^1 + ... + S5*z^5).  *	Then  *      sin__S(x*x) = z*(S0 + S1*z^1 + ... + S5*z^5)  *  *	The coefficient S's are obtained by a special Remez algorithm.  *  * Accuracy:  *	In the absence of rounding error, the approximation has absolute error   *	less than 2**(-61.11) for VAX D FORMAT, 2**(-57.45) for IEEE DOUBLE.   *  * Constants:  * The hexadecimal values are the intended ones for the following constants.  * The decimal values may be used, provided that the compiler will convert  * from decimal to binary accurately enough to produce the hexadecimal values  * shown.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_comment
comment|/*S0     = -1.6666666666666646660E-1    , Hex  2^ -2   * -.AAAAAAAAAAAA71 */
end_comment

begin_comment
comment|/*S1     =  8.3333333333297230413E-3    , Hex  2^ -6   *  .8888888888477F */
end_comment

begin_comment
comment|/*S2     = -1.9841269838362403710E-4    , Hex  2^-12   * -.D00D00CF8A1057 */
end_comment

begin_comment
comment|/*S3     =  2.7557318019967078930E-6    , Hex  2^-18   *  .B8EF1CA326BEDC */
end_comment

begin_comment
comment|/*S4     = -2.5051841873876551398E-8    , Hex  2^-25   * -.D73195374CE1D3 */
end_comment

begin_comment
comment|/*S5     =  1.6028995389845827653E-10   , Hex  2^-32   *  .B03D9C6D26CCCC */
end_comment

begin_comment
comment|/*S6     = -6.2723499671769283121E-13   ; Hex  2^-40   * -.B08D0B7561EA82 */
end_comment

begin_decl_stmt
specifier|static
name|long
name|S0x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|aaaa
argument_list|,
name|bf2a
argument_list|)
block|,
name|_0x
argument_list|(
argument|aa71
argument_list|,
argument|aaaa
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S0
value|(*(double*)S0x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S1x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|8888
argument_list|,
literal|3d08
argument_list|)
block|,
name|_0x
argument_list|(
literal|477f
argument_list|,
literal|8888
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S1
value|(*(double*)S1x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S2x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0d00
argument_list|,
name|ba50
argument_list|)
block|,
name|_0x
argument_list|(
literal|1057
argument_list|,
argument|cf8a
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S2
value|(*(double*)S2x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S3x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|ef1c
argument_list|,
literal|3738
argument_list|)
block|,
name|_0x
argument_list|(
argument|bedc
argument_list|,
argument|a326
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S3
value|(*(double*)S3x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S4x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|3195
argument_list|,
name|b3d7
argument_list|)
block|,
name|_0x
argument_list|(
argument|e1d3
argument_list|,
literal|374c
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S4
value|(*(double*)S4x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S5x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|3d9c
argument_list|,
literal|3030
argument_list|)
block|,
name|_0x
argument_list|(
argument|cccc
argument_list|,
literal|6d26
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S5
value|(*(double*)S5x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S6x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|8d0b
argument_list|,
name|ac30
argument_list|)
block|,
name|_0x
argument_list|(
argument|ea82
argument_list|,
literal|7561
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S6
value|(*(double*)S6x)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IEEE double  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|S0
init|=
operator|-
literal|1.6666666666666463126E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -3   * -1.555555555550C */
name|S1
init|=
literal|8.3333333332992771264E
operator|-
literal|3
decl_stmt|,
comment|/*Hex  2^ -7   *  1.111111110C461 */
name|S2
init|=
operator|-
literal|1.9841269816180999116E
operator|-
literal|4
decl_stmt|,
comment|/*Hex  2^-13   * -1.A01A019746345 */
name|S3
init|=
literal|2.7557309793219876880E
operator|-
literal|6
decl_stmt|,
comment|/*Hex  2^-19   *  1.71DE3209CDCD9 */
name|S4
init|=
operator|-
literal|2.5050225177523807003E
operator|-
literal|8
decl_stmt|,
comment|/*Hex  2^-26   * -1.AE5C0E319A4EF */
name|S5
init|=
literal|1.5868926979889205164E
operator|-
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Hex  2^-33   *  1.5CF61DF672B13 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|double
name|sin__S
parameter_list|(
name|z
parameter_list|)
name|double
name|z
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
return|return
operator|(
name|z
operator|*
operator|(
name|S0
operator|+
name|z
operator|*
operator|(
name|S1
operator|+
name|z
operator|*
operator|(
name|S2
operator|+
name|z
operator|*
operator|(
name|S3
operator|+
name|z
operator|*
operator|(
name|S4
operator|+
name|z
operator|*
operator|(
name|S5
operator|+
name|z
operator|*
name|S6
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
else|#
directive|else
comment|/* defined(vax)||defined(tahoe) */
return|return
operator|(
name|z
operator|*
operator|(
name|S0
operator|+
name|z
operator|*
operator|(
name|S1
operator|+
name|z
operator|*
operator|(
name|S2
operator|+
name|z
operator|*
operator|(
name|S3
operator|+
name|z
operator|*
operator|(
name|S4
operator|+
name|z
operator|*
name|S5
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* defined(vax)||defined(tahoe) */
block|}
end_function

begin_comment
comment|/* cos__C(x*x)  * DOUBLE PRECISION (VAX D FORMAT 56 BITS, IEEE DOUBLE 53 BITS)  * STATIC KERNEL FUNCTION OF SIN(X), COS(X), AND TAN(X)   * CODED IN C BY K.C. NG, 1/21/85;   * REVISED BY K.C. NG on 8/13/85.  *  *	   		    x*x	  * RETURN   cos(k*x) - 1 + ----- on [-PI/4,PI/4],  where k = pi/PI,  *	  		     2	  * PI is the rounded value of pi in machine precision :  *  *	Decimal:  *		pi = 3.141592653589793 23846264338327 .....   *    53 bits   PI = 3.141592653589793 115997963 ..... ,  *    56 bits   PI = 3.141592653589793 227020265 ..... ,    *  *	Hexadecimal:  *		pi = 3.243F6A8885A308D313198A2E....  *    53 bits   PI = 3.243F6A8885A30  =  2 * 1.921FB54442D18  *    56 bits   PI = 3.243F6A8885A308 =  4 * .C90FDAA22168C2      *  *  * Method:  *	1. Let z=x*x. Create a polynomial approximation to   *	    cos(k*x)-1+z/2  =  z*z*(C0 + C1*z^1 + ... + C5*z^5)  *	then  *      cos__C(z) =  z*z*(C0 + C1*z^1 + ... + C5*z^5)  *  *	The coefficient C's are obtained by a special Remez algorithm.  *  * Accuracy:  *	In the absence of rounding error, the approximation has absolute error   *	less than 2**(-64) for VAX D FORMAT, 2**(-58.3) for IEEE DOUBLE.   *	  *  * Constants:  * The hexadecimal values are the intended ones for the following constants.  * The decimal values may be used, provided that the compiler will convert  * from decimal to binary accurately enough to produce the hexadecimal values  * shown.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_comment
comment|/*C0     =  4.1666666666666504759E-2    , Hex  2^ -4   *  .AAAAAAAAAAA9F0 */
end_comment

begin_comment
comment|/*C1     = -1.3888888888865302059E-3    , Hex  2^ -9   * -.B60B60B60A0CCA */
end_comment

begin_comment
comment|/*C2     =  2.4801587285601038265E-5    , Hex  2^-15   *  .D00D00CDCD098F */
end_comment

begin_comment
comment|/*C3     = -2.7557313470902390219E-7    , Hex  2^-21   * -.93F27BB593E805 */
end_comment

begin_comment
comment|/*C4     =  2.0875623401082232009E-9    , Hex  2^-28   *  .8F74C8FA1E3FF0 */
end_comment

begin_comment
comment|/*C5     = -1.1355178117642986178E-11   ; Hex  2^-36   * -.C7C32D0A5C5A63 */
end_comment

begin_decl_stmt
specifier|static
name|long
name|C0x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|aaaa
argument_list|,
literal|3e2a
argument_list|)
block|,
name|_0x
argument_list|(
argument|a9f0
argument_list|,
argument|aaaa
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C0
value|(*(double*)C0x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C1x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0b60
argument_list|,
name|bbb6
argument_list|)
block|,
name|_0x
argument_list|(
literal|0cca
argument_list|,
argument|b60a
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C1
value|(*(double*)C1x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C2x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|0d00
argument_list|,
literal|38d0
argument_list|)
block|,
name|_0x
argument_list|(
literal|098f
argument_list|,
argument|cdcd
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C2
value|(*(double*)C2x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C3x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|f27b
argument_list|,
name|b593
argument_list|)
block|,
name|_0x
argument_list|(
argument|e805
argument_list|,
argument|b593
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C3
value|(*(double*)C3x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C4x
index|[]
init|=
block|{
name|_0x
argument_list|(
literal|74c8
argument_list|,
literal|320f
argument_list|)
block|,
name|_0x
argument_list|(
literal|3ff0
argument_list|,
argument|fa1e
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C4
value|(*(double*)C4x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C5x
index|[]
init|=
block|{
name|_0x
argument_list|(
name|c32d
argument_list|,
name|ae47
argument_list|)
block|,
name|_0x
argument_list|(
literal|5a63
argument_list|,
literal|0a5c
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C5
value|(*(double*)C5x)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(vax)||defined(tahoe) */
end_comment

begin_decl_stmt
specifier|static
name|double
name|C0
init|=
literal|4.1666666666666504759E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -5   *  1.555555555553E */
name|C1
init|=
operator|-
literal|1.3888888888865301516E
operator|-
literal|3
decl_stmt|,
comment|/*Hex  2^-10   * -1.6C16C16C14199 */
name|C2
init|=
literal|2.4801587269650015769E
operator|-
literal|5
decl_stmt|,
comment|/*Hex  2^-16   *  1.A01A01971CAEB */
name|C3
init|=
operator|-
literal|2.7557304623183959811E
operator|-
literal|7
decl_stmt|,
comment|/*Hex  2^-22   * -1.27E4F1314AD1A */
name|C4
init|=
literal|2.0873958177697780076E
operator|-
literal|9
decl_stmt|,
comment|/*Hex  2^-29   *  1.1EE3B60DDDC8C */
name|C5
init|=
operator|-
literal|1.1250289076471311557E
operator|-
literal|11
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Hex  2^-37   * -1.8BD5986B2A52E */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(vax)||defined(tahoe) */
end_comment

begin_function
specifier|static
name|double
name|cos__C
parameter_list|(
name|z
parameter_list|)
name|double
name|z
decl_stmt|;
block|{
return|return
operator|(
name|z
operator|*
name|z
operator|*
operator|(
name|C0
operator|+
name|z
operator|*
operator|(
name|C1
operator|+
name|z
operator|*
operator|(
name|C2
operator|+
name|z
operator|*
operator|(
name|C3
operator|+
name|z
operator|*
operator|(
name|C4
operator|+
name|z
operator|*
name|C5
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

end_unit

