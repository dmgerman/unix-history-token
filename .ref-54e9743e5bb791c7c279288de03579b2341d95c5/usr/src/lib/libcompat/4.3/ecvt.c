begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.proprietary.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ecvt.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IEEE
argument_list|)
end_if

begin_define
define|#
directive|define
name|IEEE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	ecvt converts to decimal  *	the number of digits is specified by ndigit  *	decpt is set to the position of the decimal point  *	sign is set to 0 for positive, 1 for negative  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|cvt
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|NDIG
value|512
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NDIG
value|80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|ecvt
parameter_list|(
name|arg
parameter_list|,
name|ndigits
parameter_list|,
name|decpt
parameter_list|,
name|sign
parameter_list|)
name|double
name|arg
decl_stmt|;
name|int
name|ndigits
decl_stmt|,
decl|*
name|decpt
decl_stmt|,
modifier|*
name|sign
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|cvt
argument_list|(
name|arg
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|fcvt
parameter_list|(
name|arg
parameter_list|,
name|ndigits
parameter_list|,
name|decpt
parameter_list|,
name|sign
parameter_list|)
name|double
name|arg
decl_stmt|;
name|int
name|ndigits
decl_stmt|,
decl|*
name|decpt
decl_stmt|,
modifier|*
name|sign
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|cvt
argument_list|(
name|arg
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|cvt
parameter_list|(
name|arg
parameter_list|,
name|ndigits
parameter_list|,
name|decpt
parameter_list|,
name|sign
parameter_list|,
name|eflag
parameter_list|)
name|double
name|arg
decl_stmt|;
name|int
name|ndigits
decl_stmt|,
decl|*
name|decpt
decl_stmt|,
modifier|*
name|sign
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|r2
decl_stmt|;
name|double
name|fi
decl_stmt|,
name|fj
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|NDIG
index|]
decl_stmt|;
name|double
name|modf
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|IEEE
comment|/* XXX */
if|if
condition|(
name|isspecial
argument_list|(
name|arg
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
name|buf
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|ndigits
operator|<
literal|0
condition|)
name|ndigits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ndigits
operator|>=
name|NDIG
operator|-
literal|1
condition|)
name|ndigits
operator|=
name|NDIG
operator|-
literal|2
expr_stmt|;
name|r2
operator|=
literal|0
expr_stmt|;
operator|*
name|sign
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
block|{
operator|*
name|sign
operator|=
literal|1
expr_stmt|;
name|arg
operator|=
operator|-
name|arg
expr_stmt|;
block|}
name|arg
operator|=
name|modf
argument_list|(
name|arg
argument_list|,
operator|&
name|fi
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|&
name|buf
index|[
name|NDIG
index|]
expr_stmt|;
comment|/* 	 * Do integer part 	 */
if|if
condition|(
name|fi
operator|!=
literal|0
condition|)
block|{
name|p1
operator|=
operator|&
name|buf
index|[
name|NDIG
index|]
expr_stmt|;
while|while
condition|(
name|fi
operator|!=
literal|0
condition|)
block|{
name|fj
operator|=
name|modf
argument_list|(
name|fi
operator|/
literal|10
argument_list|,
operator|&
name|fi
argument_list|)
expr_stmt|;
operator|*
operator|--
name|p1
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|fj
operator|+
literal|.03
operator|)
operator|*
literal|10
argument_list|)
operator|+
literal|'0'
expr_stmt|;
name|r2
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|p1
operator|<
operator|&
name|buf
index|[
name|NDIG
index|]
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|fj
operator|=
name|arg
operator|*
literal|10
operator|)
operator|<
literal|1
condition|)
block|{
name|arg
operator|=
name|fj
expr_stmt|;
name|r2
operator|--
expr_stmt|;
block|}
block|}
name|p1
operator|=
operator|&
name|buf
index|[
name|ndigits
index|]
expr_stmt|;
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
name|p1
operator|+=
name|r2
expr_stmt|;
operator|*
name|decpt
operator|=
name|r2
expr_stmt|;
if|if
condition|(
name|p1
operator|<
operator|&
name|buf
index|[
literal|0
index|]
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
while|while
condition|(
name|p
operator|<=
name|p1
operator|&&
name|p
operator|<
operator|&
name|buf
index|[
name|NDIG
index|]
condition|)
block|{
name|arg
operator|*=
literal|10
expr_stmt|;
name|arg
operator|=
name|modf
argument_list|(
name|arg
argument_list|,
operator|&
name|fj
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|int
operator|)
name|fj
operator|+
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|>=
operator|&
name|buf
index|[
name|NDIG
index|]
condition|)
block|{
name|buf
index|[
name|NDIG
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
name|p
operator|=
name|p1
expr_stmt|;
operator|*
name|p1
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>
literal|'9'
condition|)
block|{
operator|*
name|p1
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|p1
operator|>
name|buf
condition|)
operator|++
operator|*
operator|--
name|p1
expr_stmt|;
else|else
block|{
operator|*
name|p1
operator|=
literal|'1'
expr_stmt|;
operator|(
operator|*
name|decpt
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|buf
condition|)
operator|*
name|p
operator|=
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE
end_ifdef

begin_struct
struct|struct
name|IEEEdp
block|{
name|unsigned
name|sign
range|:
literal|1
decl_stmt|,
name|exp
range|:
literal|11
decl_stmt|,
name|manh
range|:
literal|20
decl_stmt|,
name|manl
range|:
literal|32
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|isspecial
argument_list|(
argument|f
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|double
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|IEEEdp
modifier|*
name|ip
init|=
operator|(
expr|struct
name|IEEEdp
operator|*
operator|)
operator|&
name|f
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|exp
operator|!=
literal|0x7ff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ip
operator|->
name|manh
operator|||
name|ip
operator|->
name|manl
condition|)
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|"NaN"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|sign
condition|)
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|"-Infinity"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|"Infinity"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

