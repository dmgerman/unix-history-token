begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1985, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)networkdelta.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_empty
empty|#ident "$Revision: 1.4 $"
end_empty

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_decl_stmt
specifier|static
name|long
name|median
name|__P
argument_list|(
operator|(
name|float
operator|,
name|float
operator|*
operator|,
name|long
operator|*
operator|,
name|long
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Compute a corrected date.  *	Compute the median of the reasonable differences.  First compute  *	the median of all authorized differences, and then compute the  *	median of all differences that are reasonably close to the first  *	median.  *  * This differs from the original BSD implementation, which looked for  *	the largest group of machines with essentially the same date.  *	That assumed that machines with bad clocks would be uniformly  *	distributed.  Unfortunately, in real life networks, the distribution  *	of machines is not uniform among models of machines, and the  *	distribution of errors in clocks tends to be quite consistent  *	for a given model.  In other words, all model VI Supre Servres  *	from GoFast Inc. tend to have about the same error.  *	The original BSD implementation would chose the clock of the  *	most common model, and discard all others.  *  *	Therefore, get best we can do is to try to average over all  *	of the machines in the network, while discarding "obviously"  *	bad values.  */
end_comment

begin_function
name|long
name|networkdelta
parameter_list|()
block|{
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
name|long
name|med
decl_stmt|;
name|long
name|lodelta
decl_stmt|,
name|hidelta
decl_stmt|;
name|long
name|logood
decl_stmt|,
name|higood
decl_stmt|;
name|long
name|x
index|[
name|NHOSTS
index|]
decl_stmt|;
name|long
modifier|*
name|xp
decl_stmt|;
name|int
name|numdelta
decl_stmt|;
name|float
name|eps
decl_stmt|;
comment|/* 	 * compute the median of the good values 	 */
name|med
operator|=
literal|0
expr_stmt|;
name|numdelta
operator|=
literal|1
expr_stmt|;
name|xp
operator|=
operator|&
name|x
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|xp
operator|=
literal|0
expr_stmt|;
comment|/* account for ourself */
for|for
control|(
name|htp
operator|=
name|self
operator|.
name|l_fwd
init|;
name|htp
operator|!=
operator|&
name|self
condition|;
name|htp
operator|=
name|htp
operator|->
name|l_fwd
control|)
block|{
if|if
condition|(
name|htp
operator|->
name|good
operator|&&
name|htp
operator|->
name|noanswer
operator|==
literal|0
operator|&&
name|htp
operator|->
name|delta
operator|!=
name|HOSTDOWN
condition|)
block|{
name|med
operator|+=
name|htp
operator|->
name|delta
expr_stmt|;
name|numdelta
operator|++
expr_stmt|;
operator|*
operator|++
name|xp
operator|=
name|htp
operator|->
name|delta
expr_stmt|;
block|}
block|}
comment|/* 	 * If we are the only trusted time keeper, then do not change our 	 * clock.  There may be another time keeping service active. 	 */
if|if
condition|(
name|numdelta
operator|==
literal|1
condition|)
return|return
literal|0
return|;
name|med
operator|/=
name|numdelta
expr_stmt|;
name|eps
operator|=
name|med
operator|-
name|x
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"median of %d values starting at %ld is about "
argument_list|,
name|numdelta
argument_list|,
name|med
argument_list|)
expr_stmt|;
name|med
operator|=
name|median
argument_list|(
name|med
argument_list|,
operator|&
name|eps
argument_list|,
operator|&
name|x
index|[
literal|0
index|]
argument_list|,
name|xp
operator|+
literal|1
argument_list|,
name|VALID_RANGE
argument_list|)
expr_stmt|;
comment|/* 	 * compute the median of all values near the good median 	 */
name|hidelta
operator|=
name|med
operator|+
name|GOOD_RANGE
expr_stmt|;
name|lodelta
operator|=
name|med
operator|-
name|GOOD_RANGE
expr_stmt|;
name|higood
operator|=
name|med
operator|+
name|VGOOD_RANGE
expr_stmt|;
name|logood
operator|=
name|med
operator|-
name|VGOOD_RANGE
expr_stmt|;
name|xp
operator|=
operator|&
name|x
index|[
literal|0
index|]
expr_stmt|;
name|htp
operator|=
operator|&
name|self
expr_stmt|;
do|do
block|{
if|if
condition|(
name|htp
operator|->
name|noanswer
operator|==
literal|0
operator|&&
name|htp
operator|->
name|delta
operator|>=
name|lodelta
operator|&&
name|htp
operator|->
name|delta
operator|<=
name|hidelta
operator|&&
operator|(
name|htp
operator|->
name|good
operator|||
operator|(
name|htp
operator|->
name|delta
operator|>=
name|logood
operator|&&
name|htp
operator|->
name|delta
operator|<=
name|higood
operator|)
operator|)
condition|)
block|{
operator|*
name|xp
operator|++
operator|=
name|htp
operator|->
name|delta
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|&
name|self
operator|!=
operator|(
name|htp
operator|=
name|htp
operator|->
name|l_fwd
operator|)
condition|)
do|;
if|if
condition|(
name|xp
operator|==
operator|&
name|x
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"nothing close to median %ld\n"
argument_list|,
name|med
argument_list|)
expr_stmt|;
return|return
name|med
return|;
block|}
if|if
condition|(
name|xp
operator|==
operator|&
name|x
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"only value near median is %ld\n"
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|x
index|[
literal|0
index|]
return|;
block|}
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"median of %d values starting at %ld is "
argument_list|,
name|xp
operator|-
operator|&
name|x
index|[
literal|0
index|]
argument_list|,
name|med
argument_list|)
expr_stmt|;
return|return
name|median
argument_list|(
name|med
argument_list|,
operator|&
name|eps
argument_list|,
operator|&
name|x
index|[
literal|0
index|]
argument_list|,
name|xp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * compute the median of an array of signed integers, using the idea  *	in<<Numerical Recipes>>.  */
end_comment

begin_function
specifier|static
name|long
name|median
parameter_list|(
name|a
parameter_list|,
name|eps_ptr
parameter_list|,
name|x
parameter_list|,
name|xlim
parameter_list|,
name|gnuf
parameter_list|)
name|float
name|a
decl_stmt|;
comment|/* initial guess for the median */
name|float
modifier|*
name|eps_ptr
decl_stmt|;
comment|/* spacing near the median */
name|long
modifier|*
name|x
decl_stmt|,
decl|*
name|xlim
decl_stmt|;
end_function

begin_comment
comment|/* the data */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|gnuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* good enough estimate */
end_comment

begin_block
block|{
name|long
modifier|*
name|xptr
decl_stmt|;
name|float
name|ap
init|=
name|LONG_MAX
decl_stmt|;
comment|/* bounds on the median */
name|float
name|am
init|=
operator|-
name|LONG_MAX
decl_stmt|;
name|float
name|aa
decl_stmt|;
name|int
name|npts
decl_stmt|;
comment|/* # of points above& below guess */
name|float
name|xp
decl_stmt|;
comment|/* closet point above the guess */
name|float
name|xm
decl_stmt|;
comment|/* closet point below the guess */
name|float
name|eps
decl_stmt|;
name|float
name|dum
decl_stmt|,
name|sum
decl_stmt|,
name|sumx
decl_stmt|;
name|int
name|pass
decl_stmt|;
define|#
directive|define
name|AMP
value|1.5
comment|/* smoothing constants */
define|#
directive|define
name|AFAC
value|1.5
name|eps
operator|=
operator|*
name|eps_ptr
expr_stmt|;
if|if
condition|(
name|eps
operator|<
literal|1.0
condition|)
block|{
name|eps
operator|=
operator|-
name|eps
expr_stmt|;
if|if
condition|(
name|eps
operator|<
literal|1.0
condition|)
name|eps
operator|=
literal|1.0
expr_stmt|;
block|}
for|for
control|(
name|pass
operator|=
literal|1
init|;
condition|;
name|pass
operator|++
control|)
block|{
comment|/* loop over the data */
name|sum
operator|=
literal|0.0
expr_stmt|;
name|sumx
operator|=
literal|0.0
expr_stmt|;
name|npts
operator|=
literal|0
expr_stmt|;
name|xp
operator|=
name|LONG_MAX
expr_stmt|;
name|xm
operator|=
operator|-
name|LONG_MAX
expr_stmt|;
for|for
control|(
name|xptr
operator|=
name|x
init|;
name|xptr
operator|!=
name|xlim
condition|;
name|xptr
operator|++
control|)
block|{
name|float
name|xx
init|=
operator|*
name|xptr
decl_stmt|;
name|dum
operator|=
name|xx
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|dum
operator|!=
literal|0.0
condition|)
block|{
comment|/* avoid dividing by 0 */
if|if
condition|(
name|dum
operator|>
literal|0.0
condition|)
block|{
name|npts
operator|++
expr_stmt|;
if|if
condition|(
name|xx
operator|<
name|xp
condition|)
name|xp
operator|=
name|xx
expr_stmt|;
block|}
else|else
block|{
name|npts
operator|--
expr_stmt|;
if|if
condition|(
name|xx
operator|>
name|xm
condition|)
name|xm
operator|=
name|xx
expr_stmt|;
name|dum
operator|=
operator|-
name|dum
expr_stmt|;
block|}
name|dum
operator|=
literal|1.0
operator|/
operator|(
name|eps
operator|+
name|dum
operator|)
expr_stmt|;
name|sum
operator|+=
name|dum
expr_stmt|;
name|sumx
operator|+=
name|xx
operator|*
name|dum
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ap
operator|-
name|am
operator|<
name|gnuf
operator|||
name|sum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%ld in %d passes; early out balance=%d\n"
argument_list|,
operator|(
name|long
operator|)
name|a
argument_list|,
name|pass
argument_list|,
name|npts
argument_list|)
expr_stmt|;
return|return
name|a
return|;
comment|/* guess was good enough */
block|}
name|aa
operator|=
operator|(
name|sumx
operator|/
name|sum
operator|-
name|a
operator|)
operator|*
name|AMP
expr_stmt|;
if|if
condition|(
name|npts
operator|>=
literal|2
condition|)
block|{
comment|/* guess was too low */
name|am
operator|=
name|a
expr_stmt|;
name|aa
operator|=
name|xp
operator|+
name|max
argument_list|(
literal|0.0
argument_list|,
name|aa
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|aa
operator|>
name|ap
condition|)
name|aa
operator|=
operator|(
name|a
operator|+
name|ap
operator|)
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|npts
operator|<=
operator|-
literal|2
condition|)
block|{
comment|/* guess was two high */
name|ap
operator|=
name|a
expr_stmt|;
name|aa
operator|=
name|xm
operator|+
name|min
argument_list|(
literal|0.0
argument_list|,
name|aa
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|aa
operator|<
name|am
condition|)
name|aa
operator|=
operator|(
name|a
operator|+
name|am
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|/* got it */
block|}
if|if
condition|(
name|a
operator|==
name|aa
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%ld in %d passes; force out balance=%d\n"
argument_list|,
operator|(
name|long
operator|)
name|a
argument_list|,
name|pass
argument_list|,
name|npts
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
name|eps
operator|=
name|AFAC
operator|*
name|abs
argument_list|(
name|aa
operator|-
name|a
argument_list|)
expr_stmt|;
operator|*
name|eps_ptr
operator|=
name|eps
expr_stmt|;
name|a
operator|=
name|aa
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|x
operator|-
name|xlim
operator|)
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* even number of points? */
if|if
condition|(
name|npts
operator|==
literal|0
condition|)
comment|/* yes, return an average */
name|a
operator|=
operator|(
name|xp
operator|+
name|xm
operator|)
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|npts
operator|>
literal|0
condition|)
name|a
operator|=
operator|(
name|a
operator|+
name|xp
operator|)
operator|/
literal|2
expr_stmt|;
else|else
name|a
operator|=
operator|(
name|xm
operator|+
name|a
operator|)
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|npts
operator|!=
literal|0
condition|)
block|{
comment|/* odd number of points */
if|if
condition|(
name|npts
operator|>
literal|0
condition|)
name|a
operator|=
name|xp
expr_stmt|;
else|else
name|a
operator|=
name|xm
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%ld in %d passes\n"
argument_list|,
operator|(
name|long
operator|)
name|a
argument_list|,
name|pass
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_block

end_unit

