begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Computer Consoles Inc.  *  * %sccs.include.redist.c%  *  *  *	@(#)cy.c	7.8 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"yc.h"
end_include

begin_if
if|#
directive|if
name|NCY
operator|>
literal|0
end_if

begin_comment
comment|/*  * Cipher Tapemaster driver.  */
end_comment

begin_define
define|#
directive|define
name|CYDEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CYDEBUG
end_ifdef

begin_decl_stmt
name|int
name|cydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|dlog
parameter_list|(
name|params
parameter_list|)
value|if (cydebug) log params
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dlog
parameter_list|(
name|params
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"sys/systm.h"
end_include

begin_include
include|#
directive|include
file|"sys/vm.h"
end_include

begin_include
include|#
directive|include
file|"sys/buf.h"
end_include

begin_include
include|#
directive|include
file|"sys/file.h"
end_include

begin_include
include|#
directive|include
file|"sys/signal.h"
end_include

begin_include
include|#
directive|include
file|"sys/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"sys/mtio.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"sys/cmap.h"
end_include

begin_include
include|#
directive|include
file|"sys/time.h"
end_include

begin_include
include|#
directive|include
file|"sys/kernel.h"
end_include

begin_include
include|#
directive|include
file|"sys/syslog.h"
end_include

begin_include
include|#
directive|include
file|"sys/tprintf.h"
end_include

begin_include
include|#
directive|include
file|"../include/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../include/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../include/pte.h"
end_include

begin_include
include|#
directive|include
file|"../vba/vbavar.h"
end_include

begin_define
define|#
directive|define
name|CYERROR
end_define

begin_include
include|#
directive|include
file|"../vba/cyreg.h"
end_include

begin_comment
comment|/*  * There is a ccybuf per tape controller.  * It is used as the token to pass to the internal routines  * to execute tape ioctls, and also acts as a lock on the slaves  * on the controller, since there is only one per controller.  * In particular, when the tape is rewinding on close we release  * the user process but any further attempts to use the tape drive  * before the rewind completes will hang waiting for ccybuf.  */
end_comment

begin_decl_stmt
name|struct
name|buf
name|ccybuf
index|[
name|NCY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cyprobe
argument_list|()
decl_stmt|,
name|cyslave
argument_list|()
decl_stmt|,
name|cyattach
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|ycutab
index|[
name|NYC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yctocy
index|[
name|NYC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|cyminfo
index|[
name|NCY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|ycdinfo
index|[
name|NYC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cystd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|cydriver
init|=
block|{
name|cyprobe
block|,
name|cyslave
block|,
name|cyattach
block|,
literal|0
block|,
name|cystd
block|,
literal|"yc"
block|,
name|ycdinfo
block|,
literal|"cy"
block|,
name|cyminfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bits in minor device */
end_comment

begin_define
define|#
directive|define
name|YCUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)&03)
end_define

begin_define
define|#
directive|define
name|CYUNIT
parameter_list|(
name|dev
parameter_list|)
value|(yctocy[YCUNIT(dev)])
end_define

begin_define
define|#
directive|define
name|T_NOREWIND
value|0x04
end_define

begin_define
define|#
directive|define
name|T_1600BPI
value|0x00
end_define

begin_comment
comment|/* pseudo */
end_comment

begin_define
define|#
directive|define
name|T_3200BPI
value|0x08
end_define

begin_comment
comment|/* unused */
end_comment

begin_define
define|#
directive|define
name|INF
value|1000000L
end_define

begin_comment
comment|/* close to infinity */
end_comment

begin_comment
comment|/*  * Software state and shared command areas per controller.  *  * The i/o intermediate buffer must be allocated in startup()  * so its address will fit in 20-bits (YECH!!!!!!!!!!!!!!).  */
end_comment

begin_struct
struct|struct
name|cy_softc
block|{
name|int
name|cy_bs
decl_stmt|;
comment|/* controller's buffer size */
name|struct
name|cyscp
modifier|*
name|cy_scp
decl_stmt|;
comment|/* system configuration block address */
name|struct
name|cyccb
name|cy_ccb
decl_stmt|;
comment|/* channel control block */
name|struct
name|cyscb
name|cy_scb
decl_stmt|;
comment|/* system configuration block */
name|struct
name|cytpb
name|cy_tpb
decl_stmt|;
comment|/* tape parameter block */
name|struct
name|cytpb
name|cy_nop
decl_stmt|;
comment|/* nop parameter block for cyintr */
name|struct
name|vb_buf
name|cy_rbuf
decl_stmt|;
comment|/* vba resources */
block|}
name|cy_softc
index|[
name|NCY
index|]
struct|;
end_struct

begin_comment
comment|/*  * Software state per tape transport.  */
end_comment

begin_struct
struct|struct
name|yc_softc
block|{
name|char
name|yc_openf
decl_stmt|;
comment|/* lock against multiple opens */
name|char
name|yc_lastiow
decl_stmt|;
comment|/* last operation was a write */
name|short
name|yc_tact
decl_stmt|;
comment|/* timeout is active */
name|long
name|yc_timo
decl_stmt|;
comment|/* time until timeout expires */
name|u_short
name|yc_control
decl_stmt|;
comment|/* copy of last tpcb.tpcontrol */
name|u_short
name|yc_status
decl_stmt|;
comment|/* copy of last tpcb.tpstatus */
name|u_short
name|yc_resid
decl_stmt|;
comment|/* copy of last bc */
name|u_short
name|yc_dens
decl_stmt|;
comment|/* prototype control word with density info */
name|tpr_t
name|yc_tpr
decl_stmt|;
comment|/* handle for tprintf */
name|daddr_t
name|yc_blkno
decl_stmt|;
comment|/* block number, for block device tape */
name|daddr_t
name|yc_nxrec
decl_stmt|;
comment|/* position of end of tape, if known */
name|int
name|yc_blksize
decl_stmt|;
comment|/* current tape blocksize estimate */
name|int
name|yc_blks
decl_stmt|;
comment|/* number of I/O operations since open */
name|int
name|yc_softerrs
decl_stmt|;
comment|/* number of soft I/O errors since open */
block|}
name|yc_softc
index|[
name|NYC
index|]
struct|;
end_struct

begin_comment
comment|/*  * States for vm->um_tab.b_active, the per controller state flag.  * This is used to sequence control in the driver.  */
end_comment

begin_define
define|#
directive|define
name|SSEEK
value|1
end_define

begin_comment
comment|/* seeking */
end_comment

begin_define
define|#
directive|define
name|SIO
value|2
end_define

begin_comment
comment|/* doing seq i/o */
end_comment

begin_define
define|#
directive|define
name|SCOM
value|3
end_define

begin_comment
comment|/* sending control command */
end_comment

begin_define
define|#
directive|define
name|SREW
value|4
end_define

begin_comment
comment|/* sending a rewind */
end_comment

begin_define
define|#
directive|define
name|SERASE
value|5
end_define

begin_comment
comment|/* erase inter-record gap */
end_comment

begin_define
define|#
directive|define
name|SERASED
value|6
end_define

begin_comment
comment|/* erased inter-record gap */
end_comment

begin_comment
comment|/* there's no way to figure these out dynamically? -- yech */
end_comment

begin_decl_stmt
name|struct
name|cyscp
modifier|*
name|cyscp
index|[]
init|=
block|{
operator|(
expr|struct
name|cyscp
operator|*
operator|)
literal|0xc0000c06
block|,
operator|(
expr|struct
name|cyscp
operator|*
operator|)
literal|0xc0000c16
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NCYSCP
value|(sizeof (cyscp) / sizeof (cyscp[0]))
end_define

begin_macro
name|cyprobe
argument_list|(
argument|reg
argument_list|,
argument|vm
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|br
operator|,
name|cvec
expr_stmt|;
comment|/* must be r12, r11 */
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
name|int
name|ctlr
init|=
name|vm
operator|->
name|um_ctlr
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|cyintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|badcyaddr
argument_list|(
name|reg
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ctlr
operator|>
name|NCYSCP
operator|||
name|cyscp
index|[
name|ctlr
index|]
operator|==
literal|0
condition|)
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|ctlr
index|]
expr_stmt|;
name|cy
operator|->
name|cy_scp
operator|=
name|cyscp
index|[
name|ctlr
index|]
expr_stmt|;
comment|/* XXX */
comment|/* 	 * Tapemaster controller must have interrupt handler 	 * disable interrupt, so we'll just kludge things 	 * (stupid multibus non-vectored interrupt crud). 	 */
if|if
condition|(
name|cyinit
argument_list|(
name|ctlr
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|uncache
argument_list|(
operator|&
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_bs
operator|=
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
argument_list|)
expr_stmt|;
comment|/* 		 * Setup nop parameter block for clearing interrupts. 		 */
name|cy
operator|->
name|cy_nop
operator|.
name|tpcmd
operator|=
name|CY_NOP
expr_stmt|;
name|cy
operator|->
name|cy_nop
operator|.
name|tpcontrol
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Allocate page tables. 		 */
if|if
condition|(
name|cybuf
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"no cy buffer!!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cy
operator|->
name|cy_rbuf
operator|.
name|vb_rawbuf
operator|=
name|cybuf
operator|+
name|ctlr
operator|*
name|CYMAXIO
expr_stmt|;
if|if
condition|(
name|vbainit
argument_list|(
operator|&
name|cy
operator|->
name|cy_rbuf
argument_list|,
name|CYMAXIO
argument_list|,
name|VB_20BIT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: vbainit failed\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|br
operator|=
literal|0x13
operator|,
name|cvec
operator|=
literal|0x80
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|cyccb
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Check to see if a drive is attached to a controller.  * Since we can only tell that a drive is there if a tape is loaded and  * the drive is placed online, we always indicate the slave is present.  */
end_comment

begin_macro
name|cyslave
argument_list|(
argument|vi
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|lint
name|vi
operator|=
name|vi
expr_stmt|;
name|addr
operator|=
name|addr
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|cyattach
argument_list|(
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
name|int
name|ctlr
init|=
name|vi
operator|->
name|ui_mi
operator|->
name|um_ctlr
decl_stmt|;
name|yctocy
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|=
name|ctlr
expr_stmt|;
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|ctlr
index|]
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|ui_slave
operator|==
literal|0
operator|&&
name|cy
operator|->
name|cy_bs
condition|)
name|printf
argument_list|(
literal|"; %dkb buffer"
argument_list|,
name|cy
operator|->
name|cy_bs
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize the controller after a controller reset or  * during autoconfigure.  All of the system control blocks  * are initialized and the controller is asked to configure  * itself for later use.  */
end_comment

begin_macro
name|cyinit
argument_list|(
argument|ctlr
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
init|=
operator|&
name|cy_softc
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|int
modifier|*
name|pte
decl_stmt|;
comment|/* 	 * Initialize the system configuration pointer. 	 */
comment|/* make kernel writable */
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|Sysmap
index|[
name|btop
argument_list|(
operator|(
name|int
operator|)
name|cy
operator|->
name|cy_scp
operator|&
operator|~
name|KERNBASE
argument_list|)
index|]
expr_stmt|;
operator|*
name|pte
operator|&=
operator|~
name|PG_PROT
expr_stmt|;
operator|*
name|pte
operator||=
name|PG_KW
expr_stmt|;
name|mtpr
argument_list|(
name|TBIS
argument_list|,
name|cy
operator|->
name|cy_scp
argument_list|)
expr_stmt|;
comment|/* load the correct values in the scp */
name|cy
operator|->
name|cy_scp
operator|->
name|csp_buswidth
operator|=
name|CSP_16BITS
expr_stmt|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_scp
operator|->
name|csp_scb
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cy
operator|->
name|cy_scb
argument_list|)
expr_stmt|;
comment|/* put it back to read-only */
operator|*
name|pte
operator|&=
operator|~
name|PG_PROT
expr_stmt|;
operator|*
name|pte
operator||=
name|PG_KR
expr_stmt|;
name|mtpr
argument_list|(
name|TBIS
argument_list|,
name|cy
operator|->
name|cy_scp
argument_list|)
expr_stmt|;
comment|/* 	 * Init system configuration block. 	 */
name|cy
operator|->
name|cy_scb
operator|.
name|csb_fixed
operator|=
name|CSB_FIXED
expr_stmt|;
comment|/* set pointer to the channel control block */
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_scb
operator|.
name|csb_ccb
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cy
operator|->
name|cy_ccb
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the chanel control block. 	 */
name|cy
operator|->
name|cy_ccb
operator|.
name|cbcw
operator|=
name|CBCW_CLRINT
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|=
name|GATE_OPEN
expr_stmt|;
comment|/* set pointer to the tape parameter block */
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_ccb
operator|.
name|cbtpb
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cy
operator|->
name|cy_tpb
argument_list|)
expr_stmt|;
comment|/* 	 * Issue a nop cmd and get the internal buffer size for buffered i/o. 	 */
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|=
name|CY_NOP
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|=
name|CYCW_16BITS
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_GO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|cy
operator|->
name|cy_ccb
argument_list|)
operator|||
operator|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|&
name|CYS_ERR
operator|)
condition|)
block|{
name|uncache
argument_list|(
operator|&
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cy%d: timeout or err during init, status=%b\n"
argument_list|,
name|ctlr
argument_list|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
argument_list|,
name|CYS_BITS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|=
name|CY_CONFIG
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|=
name|CYCW_16BITS
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_GO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|cy
operator|->
name|cy_ccb
argument_list|)
operator|||
operator|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|&
name|CYS_ERR
operator|)
condition|)
block|{
name|uncache
argument_list|(
operator|&
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cy%d: configuration failure, status=%b\n"
argument_list|,
name|ctlr
argument_list|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
argument_list|,
name|CYS_BITS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function_decl
name|int
name|cytimer
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Open the device.  Tapes are unique open  * devices, so we refuse if it is already open.  * We also check that a tape is available, and  * don't block waiting here; if you want to wait  * for a tape you should timeout in user code.  */
end_comment

begin_macro
name|cyopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ycunit
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|yc_softc
modifier|*
name|yc
decl_stmt|;
name|ycunit
operator|=
name|YCUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ycunit
operator|>=
name|NYC
operator|||
operator|(
name|vi
operator|=
name|ycdinfo
index|[
name|ycunit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|yc
operator|=
operator|&
name|yc_softc
index|[
name|ycunit
index|]
operator|)
operator|->
name|yc_openf
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|yc
operator|->
name|yc_openf
operator|=
literal|1
expr_stmt|;
define|#
directive|define
name|PACKUNIT
parameter_list|(
name|vi
parameter_list|)
define|\
value|(((vi->ui_slave&1)<<11)|((vi->ui_slave&2)<<9)|((vi->ui_slave&4)>>2))
comment|/* no way to select density */
name|yc
operator|->
name|yc_dens
operator|=
name|PACKUNIT
argument_list|(
name|vi
argument_list|)
operator||
name|CYCW_IE
operator||
name|CYCW_16BITS
expr_stmt|;
if|if
condition|(
name|yc
operator|->
name|yc_tact
operator|==
literal|0
condition|)
block|{
name|yc
operator|->
name|yc_timo
operator|=
name|INF
expr_stmt|;
name|yc
operator|->
name|yc_tact
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|cytimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|dev
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|cycommand
argument_list|(
name|dev
argument_list|,
name|CY_SENSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yc
operator|->
name|yc_status
operator|&
name|CYS_OL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* not on-line */
name|uprintf
argument_list|(
literal|"cy%d: not online\n"
argument_list|,
name|ycunit
argument_list|)
expr_stmt|;
name|yc
operator|->
name|yc_openf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|yc
operator|->
name|yc_status
operator|&
name|CYS_WP
operator|)
condition|)
block|{
name|uprintf
argument_list|(
literal|"cy%d: no write ring\n"
argument_list|,
name|ycunit
argument_list|)
expr_stmt|;
name|yc
operator|->
name|yc_openf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|yc
operator|->
name|yc_blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
name|yc
operator|->
name|yc_nxrec
operator|=
name|INF
expr_stmt|;
name|yc
operator|->
name|yc_lastiow
operator|=
literal|0
expr_stmt|;
name|yc
operator|->
name|yc_blksize
operator|=
name|CYMAXIO
expr_stmt|;
comment|/* guess> 0 */
name|yc
operator|->
name|yc_blks
operator|=
literal|0
expr_stmt|;
name|yc
operator|->
name|yc_softerrs
operator|=
literal|0
expr_stmt|;
name|yc
operator|->
name|yc_tpr
operator|=
name|tprintf_open
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Close tape device.  *  * If tape was open for writing or last operation was a write,  * then write two EOF's and backspace over the last one.  * Unless this is a non-rewinding special file, rewind the tape.  * Make the tape available to others.  */
end_comment

begin_macro
name|cyclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|yc_softc
modifier|*
name|yc
init|=
operator|&
name|yc_softc
index|[
name|YCUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|FWRITE
operator|||
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
name|yc
operator|->
name|yc_lastiow
condition|)
block|{
name|cycommand
argument_list|(
name|dev
argument_list|,
name|CY_WEOF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* can't use count with WEOF */
name|cycommand
argument_list|(
name|dev
argument_list|,
name|CY_WEOF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cycommand
argument_list|(
name|dev
argument_list|,
name|CY_SREV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
operator|)
operator|==
literal|0
condition|)
comment|/* 		 * 0 count means don't hang waiting for rewind complete 		 * rather ccybuf stays busy until the operation completes 		 * preventing further opens from completing by preventing 		 * a CY_SENSE from completing. 		 */
name|cycommand
argument_list|(
name|dev
argument_list|,
name|CY_REW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yc
operator|->
name|yc_blks
operator|>
literal|10
operator|&&
name|yc
operator|->
name|yc_softerrs
operator|>
name|yc
operator|->
name|yc_blks
operator|/
literal|10
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"yc%d: %d soft errors in %d blocks\n"
argument_list|,
name|YCUNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|yc
operator|->
name|yc_softerrs
argument_list|,
name|yc
operator|->
name|yc_blks
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"%d soft errors in %d blocks\n"
operator|,
name|yc
operator|->
name|yc_softerrs
operator|,
name|yc
operator|->
name|yc_blks
operator|)
argument_list|)
expr_stmt|;
name|tprintf_close
argument_list|(
name|yc
operator|->
name|yc_tpr
argument_list|)
expr_stmt|;
name|yc
operator|->
name|yc_openf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Execute a command on the tape drive a specified number of times.  */
end_comment

begin_macro
name|cycommand
argument_list|(
argument|dev
argument_list|,
argument|com
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|com
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bp
operator|=
operator|&
name|ccybuf
index|[
name|CYUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|spl3
argument_list|()
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"cycommand(%o, %x, %d), b_flags %x\n"
operator|,
name|dev
operator|,
name|com
operator|,
name|count
operator|,
name|bp
operator|->
name|b_flags
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
comment|/* 		 * This special check is because B_BUSY never 		 * gets cleared in the non-waiting rewind case. 		 */
if|if
condition|(
name|bp
operator|->
name|b_repcnt
operator|==
literal|0
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
condition|)
break|break;
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_repcnt
operator|=
name|count
expr_stmt|;
name|bp
operator|->
name|b_command
operator|=
name|com
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|cystrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * In case of rewind from close; don't wait. 	 * This is the only case where count can be 0. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
name|B_ERROR
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cystrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|ycunit
init|=
name|YCUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Put transfer at end of unit queue. 	 */
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"cystrategy(%o, %x)\n"
operator|,
name|bp
operator|->
name|b_dev
operator|,
name|bp
operator|->
name|b_command
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|&
name|ycutab
index|[
name|ycunit
index|]
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|NULL
expr_stmt|;
name|vm
operator|=
name|ycdinfo
index|[
name|ycunit
index|]
operator|->
name|ui_mi
expr_stmt|;
comment|/* BEGIN GROT */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_RAW
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>=
name|CYMAXIO
condition|)
block|{
name|uprintf
argument_list|(
literal|"cy%d: i/o size too large\n"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* END GROT */
name|s
operator|=
name|spl3
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
comment|/* 		 * Transport not already active... 		 * put at end of controller queue. 		 */
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
block|}
else|else
name|dp
operator|->
name|b_actl
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
comment|/* 	 * If the controller is not busy, get it going. 	 */
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|==
literal|0
condition|)
name|cystart
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start activity on a cy controller.  */
end_comment

begin_expr_stmt
name|cystart
argument_list|(
name|vm
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|yc_softc
modifier|*
name|yc
decl_stmt|;
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
name|int
name|ycunit
decl_stmt|;
name|daddr_t
name|blkno
decl_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"cystart()\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Look for an idle transport on the controller. 	 */
name|loop
label|:
if|if
condition|(
operator|(
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|ycunit
operator|=
name|YCUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|yc
operator|=
operator|&
name|yc_softc
index|[
name|ycunit
index|]
expr_stmt|;
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Default is that last command was NOT a write command; 	 * if we do a write command we will notice this in cyintr(). 	 */
name|yc
operator|->
name|yc_lastiow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yc
operator|->
name|yc_openf
operator|<
literal|0
operator|||
operator|(
name|bp
operator|->
name|b_command
operator|!=
name|CY_SENSE
operator|&&
operator|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|&
name|CYS_OL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Have had a hard error on a non-raw tape 		 * or the tape unit is now unavailable (e.g. 		 * taken off line). 		 */
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"openf %d command %x status %b\n"
operator|,
name|yc
operator|->
name|yc_openf
operator|,
name|bp
operator|->
name|b_command
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|,
name|CYS_BITS
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|bp
operator|==
operator|&
name|ccybuf
index|[
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
condition|)
block|{
comment|/* 		 * Execute control operation with the specified count. 		 * 		 * Set next state; give 5 minutes to complete 		 * rewind or file mark search, or 10 seconds per 		 * iteration (minimum 60 seconds and max 5 minutes) 		 * to complete other ops. 		 */
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|CY_REW
condition|)
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SREW
expr_stmt|;
name|yc
operator|->
name|yc_timo
operator|=
literal|5
operator|*
literal|60
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|CY_FSF
operator|||
name|bp
operator|->
name|b_command
operator|==
name|CY_BSF
condition|)
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SCOM
expr_stmt|;
name|yc
operator|->
name|yc_timo
operator|=
literal|5
operator|*
literal|60
expr_stmt|;
block|}
else|else
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SCOM
expr_stmt|;
name|yc
operator|->
name|yc_timo
operator|=
name|imin
argument_list|(
name|imax
argument_list|(
literal|10
operator|*
operator|(
name|int
operator|)
name|bp
operator|->
name|b_repcnt
argument_list|,
literal|60
argument_list|)
argument_list|,
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
block|}
name|cy
operator|->
name|cy_tpb
operator|.
name|tprec
operator|=
name|htoms
argument_list|(
name|bp
operator|->
name|b_repcnt
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"bpcmd "
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|dobpcmd
goto|;
block|}
comment|/* 	 * For raw I/O, save the current block 	 * number in case we have to retry. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_RAW
condition|)
block|{
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|==
literal|0
condition|)
block|{
name|yc
operator|->
name|yc_blkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|yc
operator|->
name|yc_nxrec
operator|=
name|yc
operator|->
name|yc_blkno
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Handle boundary cases for operation 		 * on non-raw tapes. 		 */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|>
name|yc
operator|->
name|yc_nxrec
condition|)
block|{
comment|/* 			 * Can't read past known end-of-file. 			 */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|yc
operator|->
name|yc_nxrec
operator|&&
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* 			 * Reading at end of file returns 0 bytes. 			 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
comment|/* 			 * Writing sets EOF. 			 */
name|yc
operator|->
name|yc_nxrec
operator|=
name|bp
operator|->
name|b_blkno
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|blkno
operator|=
name|yc
operator|->
name|yc_blkno
operator|)
operator|==
name|bp
operator|->
name|b_blkno
condition|)
block|{
name|caddr_t
name|addr
decl_stmt|;
name|int
name|cmd
decl_stmt|;
comment|/* 		 * Choose the appropriate i/o command based on the 		 * transfer size, the estimated block size, 		 * and the controller's internal buffer size. 		 * If the request length is longer than the tape 		 * block length, a buffered read will fail, 		 * thus, we request at most the size that we expect. 		 * We then check for larger records when the read completes. 		 * If we're retrying a read on a raw device because 		 * the original try was a buffer request which failed 		 * due to a record length error, then we force the use 		 * of the raw controller read (YECH!!!!). 		 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
if|if
condition|(
name|yc
operator|->
name|yc_blksize
operator|<=
name|cy
operator|->
name|cy_bs
operator|&&
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|==
literal|0
condition|)
name|cmd
operator|=
name|CY_BRCOM
expr_stmt|;
else|else
name|cmd
operator|=
name|CY_RCOM
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * On write error retries erase the 			 * inter-record gap before rewriting. 			 */
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|&&
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|!=
name|SERASED
condition|)
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SERASE
expr_stmt|;
name|bp
operator|->
name|b_command
operator|=
name|CY_ERASE
expr_stmt|;
name|yc
operator|->
name|yc_timo
operator|=
literal|60
expr_stmt|;
goto|goto
name|dobpcmd
goto|;
block|}
name|cmd
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|>
name|cy
operator|->
name|cy_bs
operator|)
condition|?
name|CY_WCOM
else|:
name|CY_BWCOM
expr_stmt|;
block|}
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SIO
expr_stmt|;
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|vbasetup
argument_list|(
name|bp
argument_list|,
operator|&
name|cy
operator|->
name|cy_rbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|=
name|cmd
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|=
name|yc
operator|->
name|yc_dens
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CY_RCOM
operator|||
name|cmd
operator|==
name|CY_WCOM
condition|)
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator||=
name|CYCW_LOCK
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|=
literal|0
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
operator|=
literal|0
expr_stmt|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpdata
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tprec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CY_BRCOM
condition|)
name|cy
operator|->
name|cy_tpb
operator|.
name|tpsize
operator|=
name|htoms
argument_list|(
name|imin
argument_list|(
name|yc
operator|->
name|yc_blksize
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_bcount
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cy
operator|->
name|cy_tpb
operator|.
name|tpsize
operator|=
name|htoms
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tplink
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
do|do
name|uncache
argument_list|(
operator|&
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
argument_list|)
expr_stmt|;
do|while
condition|(
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|==
name|GATE_CLOSED
condition|)
do|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_ccb
operator|.
name|cbtpb
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cy
operator|->
name|cy_tpb
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbcw
operator|=
name|CBCW_IE
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"CY_GO(%x) cmd %x control %x size %d\n"
operator|,
name|vm
operator|->
name|um_addr
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|,
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpsize
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CY_GO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Tape positioned incorrectly; set to seek forwards 	 * or backwards to the correct spot.  This happens  	 * for raw tapes only on error retries. 	 */
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SSEEK
expr_stmt|;
if|if
condition|(
name|blkno
operator|<
name|bp
operator|->
name|b_blkno
condition|)
block|{
name|bp
operator|->
name|b_command
operator|=
name|CY_SFORW
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tprec
operator|=
name|htoms
argument_list|(
name|bp
operator|->
name|b_blkno
operator|-
name|blkno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_command
operator|=
name|CY_SREV
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tprec
operator|=
name|htoms
argument_list|(
name|blkno
operator|-
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
block|}
name|yc
operator|->
name|yc_timo
operator|=
name|imin
argument_list|(
name|imax
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|10
operator|*
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tprec
argument_list|)
argument_list|)
argument_list|,
literal|60
argument_list|)
argument_list|,
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
name|dobpcmd
label|:
comment|/* 	 * Do the command in bp.  Reverse direction commands 	 * are indicated by having CYCW_REV or'd into their 	 * value.  For these we must set the appropriate bit 	 * in the control field. 	 */
if|if
condition|(
name|bp
operator|->
name|b_command
operator|&
name|CYCW_REV
condition|)
block|{
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|=
name|bp
operator|->
name|b_command
operator|&
operator|~
name|CYCW_REV
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|=
name|yc
operator|->
name|yc_dens
operator||
name|CYCW_REV
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"cmd %x control %x\n"
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|=
name|bp
operator|->
name|b_command
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|=
name|yc
operator|->
name|yc_dens
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"cmd %x control %x\n"
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|)
argument_list|)
expr_stmt|;
block|}
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|=
literal|0
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
operator|=
literal|0
expr_stmt|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tplink
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
do|do
name|uncache
argument_list|(
operator|&
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
argument_list|)
expr_stmt|;
do|while
condition|(
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|==
name|GATE_CLOSED
condition|)
do|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_ccb
operator|.
name|cbtpb
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cy
operator|->
name|cy_tpb
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbcw
operator|=
name|CBCW_IE
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"CY_GO(%x) cmd %x control %x rec %d\n"
operator|,
name|vm
operator|->
name|um_addr
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|,
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tprec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|CY_GO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|)
expr_stmt|;
return|return;
name|next
label|:
comment|/* 	 * Done with this operation due to error or the 	 * fact that it doesn't do anything. 	 * Dequeue the transfer and continue 	 * processing this slave. 	 */
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * Cy interrupt routine.  */
end_comment

begin_macro
name|cyintr
argument_list|(
argument|cyunit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cyunit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|cyminfo
index|[
name|cyunit
index|]
decl_stmt|;
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
specifier|register
name|struct
name|yc_softc
modifier|*
name|yc
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|register
name|state
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"cyintr(%d)\n"
operator|,
name|cyunit
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * First, turn off the interrupt from the controller 	 * (device uses Multibus non-vectored interrupts...yech). 	 */
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbcw
operator|=
name|CBCW_CLRINT
expr_stmt|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_ccb
operator|.
name|cbtpb
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cy
operator|->
name|cy_nop
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_GO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|dlog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"cy%d: stray interrupt"
operator|,
name|vm
operator|->
name|um_ctlr
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|cyunit
index|]
expr_stmt|;
name|cyuncachetpb
argument_list|(
name|cy
argument_list|)
expr_stmt|;
name|yc
operator|=
operator|&
name|yc_softc
index|[
name|YCUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * If last command was a rewind and tape is 	 * still moving, wait for the operation to complete. 	 */
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|==
name|SREW
condition|)
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SCOM
expr_stmt|;
if|if
condition|(
operator|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|&
name|CYS_RDY
operator|)
operator|==
literal|0
condition|)
block|{
name|yc
operator|->
name|yc_timo
operator|=
literal|5
operator|*
literal|60
expr_stmt|;
comment|/* 5 minutes */
return|return;
block|}
block|}
comment|/* 	 * An operation completed...record status. 	 */
name|yc
operator|->
name|yc_timo
operator|=
name|INF
expr_stmt|;
name|yc
operator|->
name|yc_control
operator|=
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
expr_stmt|;
name|yc
operator|->
name|yc_status
operator|=
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
expr_stmt|;
name|yc
operator|->
name|yc_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"cmd %x control %b status %b resid %d\n"
operator|,
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|,
name|yc
operator|->
name|yc_control
operator|,
name|CYCW_BITS
operator|,
name|yc
operator|->
name|yc_status
operator|,
name|CYS_BITS
operator|,
name|yc
operator|->
name|yc_resid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|yc
operator|->
name|yc_lastiow
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_active
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check for errors. 	 */
if|if
condition|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|&
name|CYS_ERR
condition|)
block|{
name|err
operator|=
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|&
name|CYS_ERR
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"error %d\n"
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If we hit the end of tape file, update our position. 		 */
if|if
condition|(
name|err
operator|==
name|CYER_FM
condition|)
block|{
name|yc
operator|->
name|yc_status
operator||=
name|CYS_FM
expr_stmt|;
name|state
operator|=
name|SCOM
expr_stmt|;
comment|/* force completion */
name|cyseteof
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* set blkno and nxrec */
goto|goto
name|opdone
goto|;
block|}
comment|/* 		 * Fix up errors which occur due to backspacing over 		 * the beginning of the tape. 		 */
if|if
condition|(
name|err
operator|==
name|CYER_BOT
operator|&&
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|&
name|CYCW_REV
condition|)
block|{
name|yc
operator|->
name|yc_status
operator||=
name|CYS_BOT
expr_stmt|;
goto|goto
name|ignoreerr
goto|;
block|}
comment|/* 		 * If we were reading raw tape and the only error was that the 		 * record was too long, then we don't consider this an error. 		 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_READ
operator||
name|B_RAW
operator|)
operator|)
operator|==
operator|(
name|B_READ
operator||
name|B_RAW
operator|)
operator|&&
name|err
operator|==
name|CYER_STROBE
condition|)
block|{
comment|/* 			 * Retry reads with the command changed to 			 * a raw read if necessary.  Setting b_errcnt 			 * here causes cystart (above) to force a CY_RCOM. 			 */
if|if
condition|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|==
name|CY_BRCOM
operator|&&
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|++
operator|==
literal|0
condition|)
block|{
name|yc
operator|->
name|yc_blkno
operator|++
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
else|else
goto|goto
name|ignoreerr
goto|;
block|}
comment|/* 		 * If error is not hard, and this was an i/o operation 		 * retry up to 8 times. 		 */
if|if
condition|(
name|state
operator|==
name|SIO
operator|&&
operator|(
name|CYMASK
argument_list|(
name|err
argument_list|)
operator|&
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|CYER_RSOFT
else|:
name|CYER_WSOFT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|<
literal|7
condition|)
block|{
name|yc
operator|->
name|yc_blkno
operator|++
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
block|}
elseif|else
comment|/* 			 * Hard or non-i/o errors on non-raw tape 			 * cause it to close. 			 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_RAW
operator|)
operator|==
literal|0
operator|&&
name|yc
operator|->
name|yc_openf
operator|>
literal|0
condition|)
name|yc
operator|->
name|yc_openf
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Couldn't recover from error. 		 */
name|tprintf
argument_list|(
name|yc
operator|->
name|yc_tpr
argument_list|,
literal|"yc%d: hard error bn%d status=%b, %s\n"
argument_list|,
name|YCUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|yc
operator|->
name|yc_status
argument_list|,
name|CYS_BITS
argument_list|,
operator|(
name|err
operator|<
name|NCYERROR
operator|)
condition|?
name|cyerror
index|[
name|err
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|opdone
goto|;
block|}
elseif|else
if|if
condition|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|==
name|CY_BRCOM
condition|)
block|{
name|int
name|reclen
init|=
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tprec
argument_list|)
decl_stmt|;
comment|/* 		 * If we did a buffered read, check whether the read 		 * was long enough.  If we asked the controller for less 		 * than the user asked for because the previous record 		 * was shorter, update our notion of record size 		 * and retry.  If the record is longer than the buffer, 		 * bump the errcnt so the retry will use direct read. 		 */
if|if
condition|(
name|reclen
operator|>
name|yc
operator|->
name|yc_blksize
operator|&&
name|bp
operator|->
name|b_bcount
operator|>
name|yc
operator|->
name|yc_blksize
condition|)
block|{
name|yc
operator|->
name|yc_blksize
operator|=
name|reclen
expr_stmt|;
if|if
condition|(
name|reclen
operator|>
name|cy
operator|->
name|cy_bs
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|++
expr_stmt|;
name|yc
operator|->
name|yc_blkno
operator|++
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
block|}
comment|/* 	 * Advance tape control FSM. 	 */
name|ignoreerr
label|:
comment|/* 	 * If we hit a tape mark update our position. 	 */
if|if
condition|(
name|yc
operator|->
name|yc_status
operator|&
name|CYS_FM
operator|&&
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|cyseteof
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|opdone
goto|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SIO
case|:
comment|/* 		 * Read/write increments tape block number. 		 */
name|yc
operator|->
name|yc_blkno
operator|++
expr_stmt|;
name|yc
operator|->
name|yc_blks
operator|++
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|||
name|yc
operator|->
name|yc_status
operator|&
name|CYS_CR
condition|)
name|yc
operator|->
name|yc_softerrs
operator|++
expr_stmt|;
name|yc
operator|->
name|yc_blksize
operator|=
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"blocksize %d"
operator|,
name|yc
operator|->
name|yc_blksize
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|opdone
goto|;
case|case
name|SCOM
case|:
comment|/* 		 * For forward/backward space record update current position. 		 */
if|if
condition|(
name|bp
operator|==
operator|&
name|ccybuf
index|[
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
condition|)
switch|switch
condition|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_command
condition|)
block|{
case|case
name|CY_SFORW
case|:
name|yc
operator|->
name|yc_blkno
operator|-=
name|bp
operator|->
name|b_repcnt
expr_stmt|;
break|break;
case|case
name|CY_SREV
case|:
name|yc
operator|->
name|yc_blkno
operator|+=
name|bp
operator|->
name|b_repcnt
expr_stmt|;
break|break;
block|}
goto|goto
name|opdone
goto|;
case|case
name|SSEEK
case|:
name|yc
operator|->
name|yc_blkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
goto|goto
name|opcont
goto|;
case|case
name|SERASE
case|:
comment|/* 		 * Completed erase of the inter-record gap due to a 		 * write error; now retry the write operation. 		 */
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SERASED
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
name|opdone
label|:
comment|/* 	 * Reset error count and remove from device queue. 	 */
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
comment|/* 	 * Save resid and release resources. 	 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
operator|&
name|ccybuf
index|[
name|cyunit
index|]
condition|)
name|vbadone
argument_list|(
name|bp
argument_list|,
operator|&
name|cy
operator|->
name|cy_rbuf
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Circulate slave to end of controller 	 * queue to give other slaves a chance. 	 */
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
block|{
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
literal|0
condition|)
return|return;
name|opcont
label|:
name|cystart
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cytimer
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|yc_softc
modifier|*
name|yc
init|=
operator|&
name|yc_softc
index|[
name|YCUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|yc
operator|->
name|yc_openf
operator|==
literal|0
operator|&&
name|yc
operator|->
name|yc_timo
operator|==
name|INF
condition|)
block|{
name|yc
operator|->
name|yc_tact
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|yc
operator|->
name|yc_timo
operator|!=
name|INF
operator|&&
operator|(
name|yc
operator|->
name|yc_timo
operator|-=
literal|5
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"yc%d: lost interrupt\n"
argument_list|,
name|YCUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|yc
operator|->
name|yc_timo
operator|=
name|INF
expr_stmt|;
name|s
operator|=
name|spl3
argument_list|()
expr_stmt|;
name|cyintr
argument_list|(
name|CYUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|cytimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|dev
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cyseteof
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|cyunit
init|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
init|=
operator|&
name|cy_softc
index|[
name|cyunit
index|]
decl_stmt|;
specifier|register
name|struct
name|yc_softc
modifier|*
name|yc
init|=
operator|&
name|yc_softc
index|[
name|YCUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|bp
operator|==
operator|&
name|ccybuf
index|[
name|cyunit
index|]
condition|)
block|{
if|if
condition|(
name|yc
operator|->
name|yc_blkno
operator|>
name|bp
operator|->
name|b_blkno
condition|)
block|{
comment|/* reversing */
name|yc
operator|->
name|yc_nxrec
operator|=
name|bp
operator|->
name|b_blkno
operator|-
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
argument_list|)
expr_stmt|;
name|yc
operator|->
name|yc_blkno
operator|=
name|yc
operator|->
name|yc_nxrec
expr_stmt|;
block|}
else|else
block|{
name|yc
operator|->
name|yc_blkno
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|htoms
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
argument_list|)
expr_stmt|;
name|yc
operator|->
name|yc_nxrec
operator|=
name|yc
operator|->
name|yc_blkno
operator|-
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* eof on read */
name|yc
operator|->
name|yc_nxrec
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cyioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ycunit
init|=
name|YCUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|yc_softc
modifier|*
name|yc
init|=
operator|&
name|yc_softc
index|[
name|ycunit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
operator|&
name|ccybuf
index|[
name|CYUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|callcount
expr_stmt|;
name|int
name|fcount
decl_stmt|,
name|op
decl_stmt|;
name|struct
name|mtop
modifier|*
name|mtop
decl_stmt|;
name|struct
name|mtget
modifier|*
name|mtget
decl_stmt|;
comment|/* we depend of the values and order of the MT codes here */
specifier|static
name|cyops
index|[]
operator|=
block|{
name|CY_WEOF
block|,
name|CY_FSF
block|,
name|CY_BSF
block|,
name|CY_SFORW
block|,
name|CY_SREV
block|,
name|CY_REW
block|,
name|CY_OFFL
block|,
name|CY_SENSE
block|}
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCTOP
case|:
comment|/* tape operation */
name|mtop
operator|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|op
operator|=
name|mtop
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTWEOF
case|:
name|callcount
operator|=
name|mtop
operator|->
name|mt_count
expr_stmt|;
name|fcount
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MTFSR
case|:
case|case
name|MTBSR
case|:
name|callcount
operator|=
literal|1
expr_stmt|;
name|fcount
operator|=
name|mtop
operator|->
name|mt_count
expr_stmt|;
break|break;
case|case
name|MTFSF
case|:
case|case
name|MTBSF
case|:
name|callcount
operator|=
name|mtop
operator|->
name|mt_count
expr_stmt|;
name|fcount
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
case|case
name|MTOFFL
case|:
case|case
name|MTNOP
case|:
name|callcount
operator|=
literal|1
expr_stmt|;
name|fcount
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|callcount
operator|<=
literal|0
operator|||
name|fcount
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
while|while
condition|(
operator|--
name|callcount
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* 			 * Gagh, this controller is the pits... 			 */
if|if
condition|(
name|op
operator|==
name|MTFSF
operator|||
name|op
operator|==
name|MTBSF
condition|)
block|{
do|do
name|cycommand
argument_list|(
name|dev
argument_list|,
name|cyops
index|[
name|op
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|yc
operator|->
name|yc_status
operator|&
operator|(
name|CYS_EOT
operator||
name|CYS_BOT
operator||
name|CYS_FM
operator|)
operator|)
operator|==
literal|0
condition|)
do|;
block|}
else|else
endif|#
directive|endif
name|cycommand
argument_list|(
name|dev
argument_list|,
name|cyops
index|[
name|op
index|]
argument_list|,
name|fcount
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"cyioctl: status %x, b_flags %x, resid %d\n"
operator|,
name|yc
operator|->
name|yc_status
operator|,
name|bp
operator|->
name|b_flags
operator|,
name|bp
operator|->
name|b_resid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|||
operator|(
name|yc
operator|->
name|yc_status
operator|&
operator|(
name|CYS_BOT
operator||
name|CYS_EOT
operator|)
operator|)
condition|)
break|break;
block|}
name|bp
operator|->
name|b_resid
operator|=
name|callcount
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Pick up the device's error number and pass it 		 * to the user; if there is an error but the number 		 * is 0 set a generalized code. 		 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bp
operator|->
name|b_error
condition|)
return|return
operator|(
name|bp
operator|->
name|b_error
operator|)
return|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
name|MTIOCGET
case|:
name|cycommand
argument_list|(
name|dev
argument_list|,
name|CY_SENSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtget
operator|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|data
expr_stmt|;
name|mtget
operator|->
name|mt_dsreg
operator|=
name|yc
operator|->
name|yc_status
expr_stmt|;
name|mtget
operator|->
name|mt_erreg
operator|=
name|yc
operator|->
name|yc_control
expr_stmt|;
name|mtget
operator|->
name|mt_resid
operator|=
name|yc
operator|->
name|yc_resid
expr_stmt|;
name|mtget
operator|->
name|mt_type
operator|=
name|MT_ISCY
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Poll until the controller is ready.  */
end_comment

begin_expr_stmt
name|cywait
argument_list|(
name|cp
argument_list|)
specifier|register
expr|struct
name|cyccb
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|5000
decl_stmt|;
name|uncache
argument_list|(
operator|&
name|cp
operator|->
name|cbgate
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
operator|&&
name|cp
operator|->
name|cbgate
operator|==
name|GATE_CLOSED
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|cp
operator|->
name|cbgate
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|<=
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Load a 20 bit pointer into a Tapemaster pointer.  */
end_comment

begin_expr_stmt
name|cyldmba
argument_list|(
name|reg
argument_list|,
name|value
argument_list|)
specifier|register
name|u_char
operator|*
name|reg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|v
init|=
operator|(
name|int
operator|)
name|value
decl_stmt|;
operator|*
name|reg
operator|++
operator|=
name|v
expr_stmt|;
operator|*
name|reg
operator|++
operator|=
name|v
operator|>>
literal|8
expr_stmt|;
operator|*
name|reg
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|reg
operator|=
operator|(
name|v
operator|&
literal|0xf0000
operator|)
operator|>>
literal|12
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unconditionally reset all controllers to their initial state.  */
end_comment

begin_macro
name|cyreset
argument_list|(
argument|vba
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vba
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|;
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|NCY
condition|;
name|ctlr
operator|++
control|)
if|if
condition|(
name|cyminfo
index|[
name|ctlr
index|]
operator|&&
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_vbanum
operator|==
name|vba
condition|)
block|{
name|addr
operator|=
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
expr_stmt|;
name|CY_RESET
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cyinit
argument_list|(
name|ctlr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: reset failed\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
name|cyminfo
index|[
name|ctlr
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|cyuncachetpb
argument_list|(
argument|cy
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
modifier|*
name|lp
init|=
operator|(
name|long
operator|*
operator|)
operator|&
name|cy
operator|->
name|cy_tpb
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|howmany
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cytpb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|uncache
argument_list|(
name|lp
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Dump routine.  */
end_comment

begin_define
define|#
directive|define
name|DUMPREC
value|(32*1024)
end_define

begin_macro
name|cydump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
specifier|register
name|int
name|bs
decl_stmt|,
name|num
decl_stmt|,
name|start
decl_stmt|;
specifier|register
name|caddr_t
name|addr
decl_stmt|;
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NCY
operator|||
name|cyminfo
index|[
name|unit
index|]
operator|==
literal|0
operator|||
operator|(
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|unit
index|]
operator|)
operator|->
name|cy_bs
operator|==
literal|0
operator|||
name|YCUNIT
argument_list|(
name|dev
argument_list|)
operator|>=
name|NYC
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|cy
operator|->
name|cy_ccb
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
define|#
directive|define
name|phys
parameter_list|(
name|a
parameter_list|)
value|((caddr_t)((int)(a)&~0xc0000000))
name|addr
operator|=
name|phys
argument_list|(
name|cyminfo
index|[
name|unit
index|]
operator|->
name|um_addr
argument_list|)
expr_stmt|;
name|num
operator|=
name|maxfree
operator|,
name|start
operator|=
name|NBPG
operator|*
literal|2
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|bs
operator|=
name|num
operator|>
name|btoc
argument_list|(
name|DUMPREC
argument_list|)
condition|?
name|btoc
argument_list|(
name|DUMPREC
argument_list|)
else|:
name|num
expr_stmt|;
name|error
operator|=
name|cydwrite
argument_list|(
name|cy
argument_list|,
name|start
argument_list|,
name|bs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|start
operator|+=
name|bs
operator|,
name|num
operator|-=
name|bs
expr_stmt|;
block|}
name|cyweof
argument_list|(
name|cy
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|cyweof
argument_list|(
name|cy
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|cy
operator|->
name|cy_tpb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|&
name|CYS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|cyrewind
argument_list|(
name|cy
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|cydwrite
argument_list|(
name|cy
argument_list|,
name|pf
argument_list|,
name|npf
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|cy_softc
operator|*
name|cy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|pf
decl_stmt|,
name|npf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|=
name|CY_WCOM
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcontrol
operator|=
name|CYCW_LOCK
operator||
name|CYCW_25IPS
operator||
name|CYCW_16BITS
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|=
literal|0
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpsize
operator|=
name|htoms
argument_list|(
name|npf
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tplink
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpdata
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|pf
operator|*
name|NBPG
argument_list|)
argument_list|)
expr_stmt|;
name|cyldmba
argument_list|(
name|cy
operator|->
name|cy_ccb
operator|.
name|cbtpb
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cy
operator|->
name|cy_tpb
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_GO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|cy
operator|->
name|cy_ccb
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|uncache
argument_list|(
operator|&
name|cy
operator|->
name|cy_tpb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
operator|->
name|cy_tpb
operator|.
name|tpstatus
operator|&
name|CYS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|cyweof
argument_list|(
name|cy
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|cy_softc
operator|*
name|cy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|=
name|CY_WEOF
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
operator|=
name|htoms
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_GO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cywait
argument_list|(
operator|&
name|cy
operator|->
name|cy_ccb
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cyrewind
argument_list|(
name|cy
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|cy_softc
operator|*
name|cy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcmd
operator|=
name|CY_REW
expr_stmt|;
name|cy
operator|->
name|cy_tpb
operator|.
name|tpcount
operator|=
name|htoms
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_ccb
operator|.
name|cbgate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_GO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cywait
argument_list|(
operator|&
name|cy
operator|->
name|cy_ccb
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

