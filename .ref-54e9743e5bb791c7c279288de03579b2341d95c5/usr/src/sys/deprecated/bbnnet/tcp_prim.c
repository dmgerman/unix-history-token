begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: tcp_prim.c,v 1.23 85/07/31 09:34:04 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/fsm.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/tcp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/seq.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/macros.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/sws.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|inpcb
name|tcp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TCP finite state machine primitives  *  * These routines are called from the procedures in tcp_procs.c to do low  * level protocol functions.  */
end_comment

begin_comment
comment|/*  * The hope is that a bcopy will fill in most tcp/ip header fields quicker  * than a step by step stuffing of each individually when we have to send  * some info.  */
end_comment

begin_function
name|struct
name|th
modifier|*
name|tcp_template
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|m
operator|=
name|m_getclr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
expr|struct
name|th
operator|*
operator|)
name|NULL
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
expr_stmt|;
name|t
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|th
operator|*
argument_list|)
expr_stmt|;
name|inp
operator|=
name|tp
operator|->
name|t_in_pcb
expr_stmt|;
name|t
operator|->
name|t_pr
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|t
operator|->
name|t_s
operator|=
name|inp
operator|->
name|inp_laddr
expr_stmt|;
name|t
operator|->
name|t_d
operator|=
name|inp
operator|->
name|inp_faddr
expr_stmt|;
name|t
operator|->
name|t_src
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|t
operator|->
name|t_dst
operator|=
name|inp
operator|->
name|inp_fport
expr_stmt|;
name|t
operator|->
name|t_off
operator|=
name|TCPSIZE
operator|>>
name|TCP_OFFSHIFT
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_decl_stmt
name|long
name|tcp_pkt_size
index|[
literal|2
operator|*
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Send a tcp segment  */
end_comment

begin_expr_stmt
name|send_pkt
argument_list|(
name|tp
argument_list|,
name|flags
argument_list|,
name|len
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in sequence units: includes SYN, FIN */
end_comment

begin_block
block|{
specifier|register
name|struct
name|th
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|dat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sorcv
decl_stmt|;
name|short
modifier|*
name|p
decl_stmt|;
name|struct
name|th
modifier|*
name|tmpt
decl_stmt|;
name|inp
operator|=
name|tp
operator|->
name|t_in_pcb
expr_stmt|;
comment|/*      * Adjust data length for SYN and FIN.      */
if|if
condition|(
name|flags
operator|&
name|T_FIN
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|T_SYN
condition|)
name|len
operator|--
expr_stmt|;
comment|/*      * and get a copy of the data for this transmission      */
name|dat
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|off
decl_stmt|;
name|off
operator|=
name|tp
operator|->
name|snd_nxt
operator|-
name|tp
operator|->
name|snd_una
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|syn_acked
condition|)
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|T_SYN
operator|)
condition|)
name|off
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|dat
operator|=
name|m_copy
argument_list|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_snd
operator|.
name|sb_mb
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MBUF_DEBUG
name|m
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
else|#
directive|else
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/*      * Build tcp leader at bottom of new buffer to leave room for lower      * level leaders.  Leave an extra four bytes for TCP max segment size      * option, which is sent in SYN packets.      * Align header for memory access speed in checksumming...      */
name|m
operator|->
name|m_off
operator|=
operator|(
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
operator|-
name|TCP_MAXSEG_OPTLEN
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|dat
expr_stmt|;
name|t
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|th
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_template
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"send_pkt"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tp
operator|->
name|t_template
argument_list|,
operator|(
name|caddr_t
operator|)
name|t
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOTCPOPTS
comment|/*      * Insert maximum segment size option for SYN.      */
if|if
condition|(
name|flags
operator|&
name|T_SYN
condition|)
block|{
comment|/* 	 * may not have a route yet. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
block|{
name|m
operator|->
name|m_len
operator|+=
name|TCP_MAXSEG_OPTLEN
expr_stmt|;
comment|/* SYN occupies seq space */
name|len
operator|+=
name|TCP_MAXSEG_OPTLEN
expr_stmt|;
name|t
operator|->
name|t_off
operator|=
operator|(
name|TCPSIZE
operator|+
name|TCP_MAXSEG_OPTLEN
operator|)
operator|>>
name|TCP_OFFSHIFT
expr_stmt|;
name|p
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|t
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|TCP_MAXSEG_OPTHDR
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
operator|-
name|TCPIPMAX
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|t
operator|->
name|t_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|len
operator|+
name|TCPSIZE
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_seq
operator|=
name|htonl
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_ackno
operator|=
name|htonl
argument_list|(
name|tp
operator|->
name|rcv_nxt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GPROF
if|if
condition|(
name|len
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|tcp_pkt_size
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tcp_pkt_size
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
name|TCPSIZE
condition|)
name|tcp_pkt_size
index|[
name|len
operator|+
name|TCPSIZE
index|]
operator|++
expr_stmt|;
else|else
name|tcp_pkt_size
index|[
literal|0
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|snd_rst
condition|)
block|{
name|flags
operator||=
name|T_RST
expr_stmt|;
name|flags
operator|&=
operator|~
name|T_SYN
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|snd_urg
condition|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_urp
argument_list|,
name|tp
operator|->
name|snd_nxt
argument_list|)
condition|)
block|{
name|short
name|up
decl_stmt|;
comment|/* 	     * SEQ_LEQ(tp->snd_urp, tp->snd_nxt+len) 	     * Strictly speaking, we should be able to have the 	     * urgent pointer point into the stream beyond the 	     * current end of packet, but this is just in case 	     * some implementation is not ready for that. 	     */
name|flags
operator||=
name|T_URG
expr_stmt|;
name|up
operator|=
name|MIN
argument_list|(
name|len
operator|-
literal|1
argument_list|,
name|tp
operator|->
name|snd_urp
operator|-
name|tp
operator|->
name|snd_nxt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_urp
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|up
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|syn_rcvd
condition|)
block|{
if|#
directive|if
name|T_DELACK
operator|>
literal|0
name|tp
operator|->
name|lastack
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
endif|#
directive|endif
name|flags
operator||=
name|T_ACK
expr_stmt|;
block|}
name|t
operator|->
name|t_flags
operator|=
name|flags
expr_stmt|;
comment|/* Calculate the window we should advertise */
name|sorcv
operator|=
operator|&
name|inp
operator|->
name|inp_socket
operator|->
name|so_rcv
expr_stmt|;
comment|/*      * Count bytes left in user rcv queue, and reduce by sequencing queue      * Counting the sequencing q contracts the window when packets are      * lost (== when the network is over-loaded).      */
name|i
operator|=
name|sbspace
argument_list|(
name|sorcv
argument_list|)
operator|-
name|tp
operator|->
name|t_rcv_len
expr_stmt|;
comment|/*       * apply receiver's solution to SWS in case sender does not have such      * an algorithm.  One 8th was determined by benchmarks writing 2k      * buffers on an Ethernet connection.  It has a slightly negative      * influence on IMP networks when writing 1k buffers.      *      * (sorcv->sb_hiwat>> 3) limited by 256 == 2k / 8, since application      * may adjust its buffering to large amounts via ioctl call.  An eighth      * of a large number may be a reasonable sized packet to send.      *      * Only apply this algorithm if are getting packets in order,      * so that advertisement of 0 window does not prevent retransmission      * of dropped packet.      */
name|tmpt
operator|=
name|tp
operator|->
name|t_rcv_next
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
name|MIN
argument_list|(
literal|256
argument_list|,
operator|(
name|sorcv
operator|->
name|sb_hiwat
operator|>>
literal|3
operator|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|tmpt
operator|==
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
operator|)
operator|||
name|SEQ_LEQ
argument_list|(
name|tmpt
operator|->
name|t_seq
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
operator|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 	 * if this connection gets fragmented, constrain the windowsize 	 */
if|if
condition|(
name|tp
operator|->
name|t_maxfrag
condition|)
name|i
operator|=
name|MIN
argument_list|(
name|i
argument_list|,
name|tp
operator|->
name|t_maxfrag
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|T_DELACK
operator|>
literal|0
name|tp
operator|->
name|rcv_wnd
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
name|t
operator|->
name|t_win
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/*      * If we sent a zero window, we should try to send a non-zero ACK ASAP.      */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|tp
operator|->
name|sent_zero
operator|=
name|TRUE
expr_stmt|;
else|else
name|tp
operator|->
name|sent_zero
operator|=
name|FALSE
expr_stmt|;
name|t
operator|->
name|t_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
block|{
name|struct
name|work
name|w
decl_stmt|;
name|w
operator|.
name|w_type
operator|=
name|INRECV
expr_stmt|;
comment|/* not really. use -1 newstate */
name|w
operator|.
name|w_tcb
operator|=
name|tp
expr_stmt|;
name|w
operator|.
name|w_dat
operator|=
operator|(
name|char
operator|*
operator|)
name|t
expr_stmt|;
name|tcp_debug
argument_list|(
name|tp
argument_list|,
operator|&
name|w
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * and ship packet off via IP.  Remember that since this protocol      * involves retransmissions, errors can occur asynchronous to a      * (write) system call, and that therefore we can not send the      * error all the way back up through subroutine return values.  We      * must also post it back via advise_user() at some point, and this      * looks like a good point to try it.      */
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ip_send
argument_list|(
name|inp
argument_list|,
name|m
argument_list|,
name|len
operator|+
name|TCPSIZE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
comment|/* 	     * Since we use retransmissions, don't need to tell user 	     * process about this.  (Can be as simple as interface 	     * or host structure queues are too long due to current 	     * heavy traffic.  Backing off will take care of that.) 	     */
if|if
condition|(
name|error
operator|!=
name|ENOBUFS
condition|)
name|advise_user
argument_list|(
name|inp
operator|->
name|inp_socket
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * Find the first empty spot in rcv buffer  */
end_comment

begin_function
name|sequence
name|firstempty
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
block|{
name|sequence
name|retval
decl_stmt|;
name|FIRSTEMPTY
argument_list|(
name|tp
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TCP timer update routine  */
end_comment

begin_macro
name|tcp_timeo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|s
expr_stmt|;
specifier|extern
name|sequence
name|tcp_iss
decl_stmt|;
comment|/* tcp initial send seq # */
specifier|static
name|int
name|tcpmins
decl_stmt|;
comment|/* tcp minute timer */
comment|/* search through tcb and update active timers */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|inp
operator|=
name|tcp
operator|.
name|inp_next
expr_stmt|;
while|while
condition|(
name|inp
operator|!=
operator|&
name|tcp
condition|)
block|{
name|next
operator|=
name|inp
operator|->
name|inp_next
expr_stmt|;
if|if
condition|(
name|tp
operator|=
name|inptotcpcb
argument_list|(
name|inp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|sws_qff
operator|<
name|SWS_QFF_DEF
condition|)
name|tp
operator|->
name|sws_qff
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TINIT
init|;
name|i
operator|<=
name|TDELACK
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tp
operator|->
name|t_timers
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|--
name|tp
operator|->
name|t_timers
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|struct
name|work
name|w
decl_stmt|;
name|w
operator|.
name|w_type
operator|=
name|ISTIMER
expr_stmt|;
name|w
operator|.
name|w_stype
operator|=
name|i
expr_stmt|;
name|w
operator|.
name|w_tcb
operator|=
name|tp
expr_stmt|;
name|w
operator|.
name|w_dat
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|action
argument_list|(
operator|&
name|w
argument_list|)
operator|==
name|CLOSED
condition|)
goto|goto
name|next_tcb
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_timers
index|[
name|TXMT
index|]
operator|<
name|MAX_TCPTIMERVAL
operator|-
literal|1
condition|)
name|tp
operator|->
name|t_timers
index|[
name|TXMT
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|tcpmins
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_timers
index|[
name|TNOACT
index|]
operator|!=
literal|0
operator|&&
operator|--
name|tp
operator|->
name|t_timers
index|[
name|TNOACT
index|]
operator|==
literal|0
condition|)
name|w_alloc
argument_list|(
name|ISTIMER
argument_list|,
name|TNOACT
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|next_tcb
label|:
name|inp
operator|=
name|next
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|tcpmins
operator|<
literal|0
condition|)
name|tcpmins
operator|=
literal|120
operator|-
literal|1
expr_stmt|;
comment|/* zero-origin strikes again */
name|tcp_iss
operator|+=
name|ISSINCR
expr_stmt|;
comment|/* increment iss */
block|}
end_block

begin_comment
comment|/*  * Do TCP option processing  */
end_comment

begin_expr_stmt
name|tcp_opt
argument_list|(
name|tp
argument_list|,
name|t
argument_list|,
name|hlen
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|th
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
operator|,
name|j
operator|,
name|len
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|t
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
operator|)
expr_stmt|;
comment|/* -> at options */
if|if
condition|(
operator|(
name|i
operator|=
name|hlen
operator|-
name|TCPSIZE
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* any options */
while|while
condition|(
name|i
operator|>
literal|0
condition|)
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
name|TCP_END_OPT
case|:
default|default:
comment|/* garbage: throw away rest */
return|return;
case|case
name|TCP_NOP_OPT
case|:
name|i
operator|--
expr_stmt|;
break|break;
case|case
name|TCP_MAXSEG_OPT
case|:
comment|/* max segment size */
if|if
condition|(
name|t
operator|->
name|t_flags
operator|&
name|T_SYN
operator|&&
operator|!
name|tp
operator|->
name|syn_rcvd
condition|)
block|{
name|len
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|p
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * may not have a route yet 		 */
if|if
condition|(
operator|!
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
comment|/* in LISTEN state */
name|tp
operator|->
name|t_maxseg
operator|=
name|len
expr_stmt|;
else|else
comment|/* connecting to server */
name|tp
operator|->
name|t_maxseg
operator|=
name|MIN
argument_list|(
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
operator|-
name|TCPIPMAX
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|-=
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_optlen
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|j
operator|=
operator|*
name|p
operator|)
operator|==
literal|0
condition|)
break|break;
name|i
operator|-=
name|j
expr_stmt|;
name|p
operator|+=
name|j
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Called at splimp from uipc_mbuf.c  * Network needs some space freed!  Remove unprocessed packets.  */
end_comment

begin_macro
name|tcp_drain
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|inp
operator|=
name|tcp
operator|.
name|inp_next
init|;
name|inp
operator|!=
operator|&
name|tcp
condition|;
name|inp
operator|=
name|inp
operator|->
name|inp_next
control|)
block|{
name|tp
operator|=
operator|(
expr|struct
name|tcpcb
operator|*
operator|)
name|inp
operator|->
name|inp_ppcb
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
continue|continue;
while|while
condition|(
name|m
operator|=
name|tp
operator|->
name|t_rcv_unack
condition|)
block|{
name|tp
operator|->
name|t_rcv_unack
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

