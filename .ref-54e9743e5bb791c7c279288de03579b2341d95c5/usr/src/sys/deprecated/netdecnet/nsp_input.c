begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	nsp_input.c	1.3	82/10/09	*/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../netdecnet/dn_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netdecnet/nsp.h"
end_include

begin_include
include|#
directive|include
file|"../netdecnet/nsp_var.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
name|int
name|nspidebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|printd
value|if(nspidebug)printf
end_define

begin_comment
comment|/*  * NSP input routine: decode incoming packet and dispatch  * to appropriate socket.  Called from the software interrupt  * at splnet.  *  * TODO:  *	count occurances of various error conditions.  */
end_comment

begin_macro
name|nspintr
argument_list|()
end_macro

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|tprh
modifier|*
name|t
decl_stmt|;
name|int
name|s
decl_stmt|,
name|bom
decl_stmt|,
name|eom
decl_stmt|;
name|u_short
name|srcnode
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|nspcb
modifier|*
name|np
decl_stmt|;
comment|/* 	 * Loop pulling packets off the interrupt queue. 	 */
name|next
label|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|nspintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printd
argument_list|(
literal|"nsp_input: m 0x%x"
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|t
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tprh
operator|*
argument_list|)
expr_stmt|;
name|srcnode
operator|=
name|t
operator|->
name|tprh_srcnode
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tprh
argument_list|)
expr_stmt|;
comment|/* use m_adj??? */
name|m
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|tprh
argument_list|)
expr_stmt|;
name|printd
argument_list|(
literal|", srcnode %d, len %d"
argument_list|,
name|srcnode
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 	 * Switch on the type of the message. 	 */
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
comment|/* 	 * Got a Data message, possibly with EOM and 	 * BOM flags set.  Call nsp_chkaddr to do ack 	 * and flow controll processing, then pass the 	 * data to the user. 	 */
case|case
name|NSP_DATA
operator||
name|NSP_EOM
operator||
name|NSP_BOM
case|:
name|eom
operator|=
name|bom
operator|=
literal|1
expr_stmt|;
goto|goto
name|data
goto|;
case|case
name|NSP_DATA
operator||
name|NSP_EOM
case|:
name|eom
operator|=
literal|1
expr_stmt|;
goto|goto
name|data
goto|;
case|case
name|NSP_DATA
operator||
name|NSP_BOM
case|:
name|bom
operator|=
literal|1
expr_stmt|;
case|case
name|NSP_DATA
case|:
name|data
label|:
name|printd
argument_list|(
literal|", DATA (%d,%d)"
argument_list|,
name|bom
argument_list|,
name|eom
argument_list|)
expr_stmt|;
name|np
operator|=
name|nsp_chkaddr
argument_list|(
name|m
argument_list|,
name|srcnode
argument_list|,
name|NSP_DATA
argument_list|,
operator|&
name|segnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 		 * Data messages only valid in Run state 		 */
if|if
condition|(
name|np
operator|->
name|n_state
operator|!=
name|NS_RUN
condition|)
block|{
name|printf
argument_list|(
literal|", !RUN (%d)\n"
argument_list|,
name|np
operator|->
name|n_state
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|SEQ_GTR
argument_list|(
name|segnum
argument_list|,
name|np
operator|->
name|na_xmtdat
argument_list|)
condition|)
block|{
comment|/* SHOULD DO SEGMENT RECONSTRUCTION HERE */
name|printd
argument_list|(
literal|", got data!"
argument_list|)
expr_stmt|;
name|sbpappend
argument_list|(
name|m
argument_list|,
operator|&
name|np
operator|->
name|n_socket
operator|->
name|sb_rcv
argument_list|)
expr_stmt|;
block|}
else|else
name|np
operator|->
name|n_flags
operator||=
name|NF_DATACK
expr_stmt|;
break|break;
comment|/* 	 * Got an interrupt message.  Call nsp_chkaddr 	 * (as usual).  Save the interrupt data for the 	 * user. 	 * GENERATE A SIGNAL OF SOME SORT??? 	 */
case|case
name|NSP_INTR
case|:
name|printd
argument_list|(
literal|", INTR"
argument_list|)
expr_stmt|;
name|np
operator|=
name|nsp_chkaddr
argument_list|(
name|m
argument_list|,
name|srcnode
argument_list|,
name|NSP_INTR
argument_list|,
operator|&
name|segnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 		 * If we are in the Connect Confirm state then 		 * this Interrupt packet causes the transition 		 * to the Run state.  Otherwise we better be in 		 * the Run state already. 		 */
if|if
condition|(
name|np
operator|->
name|n_state
operator|==
name|NS_CC
condition|)
name|np
operator|->
name|n_state
operator|=
name|NS_RUN
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|n_state
operator|!=
name|NS_RUN
condition|)
block|{
name|printf
argument_list|(
literal|", !RUN %d\n"
argument_list|,
name|np
operator|->
name|n_state
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 		 * If this segment is the one after the last 		 * other data segment we acked, and there is 		 * no waiting interrupt message, then queue 		 * this one up. 		 */
if|if
condition|(
name|segnum
operator|==
name|SEQ_ADD
argument_list|(
name|np
operator|->
name|na_xmtoth
argument_list|,
literal|1
argument_list|)
operator|&&
name|np
operator|->
name|nf_locint
operator|==
name|NFL_EMPTY
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|nb_rcv
condition|)
block|{
name|printd
argument_list|(
literal|", flush old intr data"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|np
operator|->
name|nb_rcv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
literal|16
condition|)
block|{
name|printd
argument_list|(
literal|", intr data too long\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|np
operator|->
name|nb_rcv
operator|=
name|m
expr_stmt|;
name|np
operator|->
name|nf_locint
operator|=
name|NFL_INTR
expr_stmt|;
name|np
operator|->
name|na_xmtoth
operator|=
name|segnum
expr_stmt|;
comment|/* really += 1 */
name|np
operator|->
name|n_flags
operator||=
name|NF_OTHACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|segnum
argument_list|,
name|np
operator|->
name|na_xmtoth
argument_list|)
condition|)
name|np
operator|->
name|n_flags
operator||=
name|NF_OTHACK
expr_stmt|;
break|break;
comment|/* 	 * Got a Link Service message.  Process options 	 * to modify flow control values. 	 */
case|case
name|NSP_LS
case|:
name|printd
argument_list|(
literal|", LS"
argument_list|)
expr_stmt|;
name|np
operator|=
name|nsp_chkaddr
argument_list|(
name|m
argument_list|,
name|srcnode
argument_list|,
name|NSP_LS
argument_list|,
operator|&
name|segnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 		 * If we are in the Connect Confirm state then 		 * this Link Service packet causes the transition 		 * to the Run state.  Otherwise we better be in 		 * the Run state already. 		 */
if|if
condition|(
name|np
operator|->
name|n_state
operator|==
name|NS_CC
condition|)
name|np
operator|->
name|n_state
operator|=
name|NS_RUN
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|n_state
operator|!=
name|NS_RUN
condition|)
block|{
name|printd
argument_list|(
literal|", !RUN %d\n"
argument_list|,
name|np
operator|->
name|n_state
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|lsf
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|fcval
operator|=
operator|*
name|p
expr_stmt|;
name|printd
argument_list|(
literal|", lsf 0x%x, fcval %d"
argument_list|,
name|lsf
argument_list|,
name|fcval
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lsf
operator|&
name|NSPLS_FCVALINT
condition|)
block|{
case|case
name|NSPLS_DATREQ
case|:
if|if
condition|(
name|seqnum
operator|==
name|SEQ_ADD
argument_list|(
name|np
operator|->
name|na_xmtoth
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|nf_remdat
operator|+
name|fcval
operator|>=
operator|-
literal|128
operator|&&
name|np
operator|->
name|nf_remdat
operator|+
name|fcval
operator|<=
literal|127
condition|)
block|{
name|np
operator|->
name|nf_remdat
operator|+=
name|fcval
expr_stmt|;
name|np
operator|->
name|na_xmtoth
operator|=
name|segnum
expr_stmt|;
name|np
operator|->
name|n_flags
operator||=
name|NF_OTHACK
expr_stmt|;
switch|switch
condition|(
name|lsf
operator|&
name|NSPLS_FCMOD
condition|)
block|{
case|case
name|NSPLS_NOCHANGE
case|:
break|break;
case|case
name|NSPLS_ON
case|:
name|np
operator|->
name|n_flags
operator|&=
operator|~
name|NF_DATOFF
expr_stmt|;
break|break;
case|case
name|NSPLS_OFF
case|:
name|np
operator|->
name|n_flags
operator||=
name|NF_DATOFF
expr_stmt|;
break|break;
default|default:
name|printd
argument_list|(
literal|", bad fcmod"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|segnum
argument_list|,
name|np
operator|->
name|na_xmtoth
argument_list|)
condition|)
name|np
operator|->
name|n_flags
operator||=
name|NF_OTHACK
expr_stmt|;
break|break;
case|case
name|NSPLS_INTREQ
case|:
if|if
condition|(
name|seqnum
operator|==
name|SEQ_ADD
argument_list|(
name|np
operator|->
name|na_xmtoth
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|fcval
operator|>=
literal|0
operator|&&
name|np
operator|->
name|nf_remint
operator|+
name|fcval
operator|<=
literal|127
condition|)
block|{
name|np
operator|->
name|nf_remint
operator|+=
name|fcval
expr_stmt|;
name|np
operator|->
name|na_xmtoth
operator|=
name|segnum
expr_stmt|;
name|np
operator|->
name|n_flags
operator||=
name|NF_OTHACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|segnum
argument_list|,
name|np
operator|->
name|na_xmtoth
argument_list|)
condition|)
name|np
operator|->
name|n_flags
operator||=
name|NF_OTHACK
expr_stmt|;
break|break;
default|default:
name|printd
argument_list|(
literal|", bad fcvalint"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Got an acknowledgement for a Data message. 	 * Nsp_chkaddr processes the ack, nothing else 	 * to do. 	 */
case|case
name|NSP_DATACK
case|:
name|printd
argument_list|(
literal|", DATACK"
argument_list|)
expr_stmt|;
name|np
operator|=
name|nsp_chkaddr
argument_list|(
name|m
argument_list|,
name|srcnode
argument_list|,
name|NSP_DATACK
argument_list|,
operator|&
name|segnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
break|break;
comment|/* 	 * Got an acknowledgement for an Other Data message. 	 * Nsp_chkaddr processes the ack, nothing else to do. 	 */
case|case
name|NSP_OTHACK
case|:
name|printd
argument_list|(
literal|", OTHACK"
argument_list|)
expr_stmt|;
name|np
operator|=
name|nsp_chkaddr
argument_list|(
name|m
argument_list|,
name|srcnode
argument_list|,
name|NSP_OTHACK
argument_list|,
operator|&
name|segnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
break|break;
comment|/* 	 * Got a Connect Acknowledgement.  Just verify 	 * the address and perform the state transition. 	 */
case|case
name|NSP_CONACK
case|:
name|DOIT
break|break;
comment|/* 	 * Got an unknown message, count it and flush it. 	 */
default|default:
name|printd
argument_list|(
literal|", UNKNOWN!!!"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|printd
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
end_block

end_unit

