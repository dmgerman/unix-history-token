begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)ct.c	8.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"ct.h"
end_include

begin_if
if|#
directive|if
name|NCT
operator|>
literal|0
end_if

begin_comment
comment|/*  * CS80 cartridge tape driver (9144, 88140, 9145)  *  * Reminder:  *	C_CC bit (character count option) when used in the CS/80 command  *	'set options' will cause the tape not to stream.  *  * TODO:  *	make filesystem compatible  *	make block mode work according to mtio(4) spec. (if possible)  *	merge with cs80 disk driver  *	finish support of 9145  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/tprintf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/ctreg.h>
end_include

begin_comment
comment|/* number of eof marks to remember */
end_comment

begin_define
define|#
directive|define
name|EOFS
value|128
end_define

begin_decl_stmt
name|int
name|ctinit
argument_list|()
decl_stmt|,
name|ctstart
argument_list|()
decl_stmt|,
name|ctgo
argument_list|()
decl_stmt|,
name|ctintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|ctdriver
init|=
block|{
name|ctinit
block|,
literal|"ct"
block|,
name|ctstart
block|,
name|ctgo
block|,
name|ctintr
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ct_softc
block|{
name|struct
name|hp_device
modifier|*
name|sc_hd
decl_stmt|;
name|struct
name|ct_iocmd
name|sc_ioc
decl_stmt|;
name|struct
name|ct_rscmd
name|sc_rsc
decl_stmt|;
name|struct
name|ct_stat
name|sc_stat
decl_stmt|;
name|struct
name|ct_ssmcmd
name|sc_ssmc
decl_stmt|;
name|struct
name|ct_srcmd
name|sc_src
decl_stmt|;
name|struct
name|ct_soptcmd
name|sc_soptc
decl_stmt|;
name|struct
name|ct_ulcmd
name|sc_ul
decl_stmt|;
name|struct
name|ct_wfmcmd
name|sc_wfm
decl_stmt|;
name|struct
name|ct_clearcmd
name|sc_clear
decl_stmt|;
name|struct
name|buf
modifier|*
name|sc_bp
decl_stmt|;
name|int
name|sc_blkno
decl_stmt|;
name|int
name|sc_cmd
decl_stmt|;
name|int
name|sc_resid
decl_stmt|;
name|char
modifier|*
name|sc_addr
decl_stmt|;
name|int
name|sc_flags
decl_stmt|;
name|short
name|sc_type
decl_stmt|;
name|short
name|sc_punit
decl_stmt|;
name|tpr_t
name|sc_tpr
decl_stmt|;
name|struct
name|devqueue
name|sc_dq
decl_stmt|;
name|int
name|sc_eofp
decl_stmt|;
name|int
name|sc_eofs
index|[
name|EOFS
index|]
decl_stmt|;
block|}
name|ct_softc
index|[
name|NCT
index|]
struct|;
end_struct

begin_comment
comment|/* flags */
end_comment

begin_define
define|#
directive|define
name|CTF_OPEN
value|0x01
end_define

begin_define
define|#
directive|define
name|CTF_ALIVE
value|0x02
end_define

begin_define
define|#
directive|define
name|CTF_WRT
value|0x04
end_define

begin_define
define|#
directive|define
name|CTF_CMD
value|0x08
end_define

begin_define
define|#
directive|define
name|CTF_IO
value|0x10
end_define

begin_define
define|#
directive|define
name|CTF_BEOF
value|0x20
end_define

begin_define
define|#
directive|define
name|CTF_AEOF
value|0x40
end_define

begin_define
define|#
directive|define
name|CTF_EOT
value|0x80
end_define

begin_define
define|#
directive|define
name|CTF_STATWAIT
value|0x100
end_define

begin_define
define|#
directive|define
name|CTF_CANSTREAM
value|0x200
end_define

begin_define
define|#
directive|define
name|CTF_WRTTN
value|0x400
end_define

begin_struct
struct|struct
name|ctinfo
block|{
name|short
name|hwid
decl_stmt|;
name|short
name|punit
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|ctinfo
index|[]
init|=
block|{
name|CT7946ID
block|,
literal|1
block|,
literal|"7946A"
block|,
name|CT7912PID
block|,
literal|1
block|,
literal|"7912P"
block|,
name|CT7914PID
block|,
literal|1
block|,
literal|"7914P"
block|,
name|CT9144ID
block|,
literal|0
block|,
literal|"9144"
block|,
name|CT9145ID
block|,
literal|0
block|,
literal|"9145"
block|, }
struct|;
end_struct

begin_decl_stmt
name|int
name|nctinfo
init|=
sizeof|sizeof
argument_list|(
name|ctinfo
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ctinfo
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|cttab
index|[
name|NCT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|ctbuf
index|[
name|NCT
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CT_NOREW
value|4
end_define

begin_define
define|#
directive|define
name|CT_STREAM
value|8
end_define

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& 3)
end_define

begin_define
define|#
directive|define
name|ctpunit
parameter_list|(
name|x
parameter_list|)
value|((x)& 7)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|ctdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDB_FILES
value|0x01
end_define

begin_define
define|#
directive|define
name|CT_BSF
value|0x02
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ctinit
argument_list|(
name|hd
argument_list|)
specifier|register
expr|struct
name|hp_device
operator|*
name|hd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ct_softc
modifier|*
name|sc
init|=
operator|&
name|ct_softc
index|[
name|hd
operator|->
name|hp_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|cttab
init|;
name|bp
operator|<
operator|&
name|cttab
index|[
name|NCT
index|]
condition|;
name|bp
operator|++
control|)
name|bp
operator|->
name|b_actb
operator|=
operator|&
name|bp
operator|->
name|b_actf
expr_stmt|;
name|sc
operator|->
name|sc_hd
operator|=
name|hd
expr_stmt|;
name|sc
operator|->
name|sc_punit
operator|=
name|ctpunit
argument_list|(
name|hd
operator|->
name|hp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctident
argument_list|(
name|sc
argument_list|,
name|hd
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ctreset
argument_list|(
name|sc
argument_list|,
name|hd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_unit
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_driver
operator|=
operator|&
name|ctdriver
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_ALIVE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ctident
argument_list|(
name|sc
argument_list|,
name|hd
argument_list|)
specifier|register
expr|struct
name|ct_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ct_describe
name|desc
decl_stmt|;
name|u_char
name|stat
decl_stmt|,
name|cmd
index|[
literal|3
index|]
decl_stmt|;
name|char
name|name
index|[
literal|7
index|]
decl_stmt|;
name|int
name|id
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Read device id and verify that: 	 * 1. It is a CS80 device 	 * 2. It is one of our recognized tape devices 	 * 3. It has the proper physical unit number 	 */
name|id
operator|=
name|hpibid
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|&
literal|0x200
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nctinfo
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|id
operator|==
name|ctinfo
index|[
name|i
index|]
operator|.
name|hwid
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nctinfo
operator|||
name|sc
operator|->
name|sc_punit
operator|!=
name|ctinfo
index|[
name|i
index|]
operator|.
name|punit
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|id
operator|=
name|i
expr_stmt|;
comment|/* 	 * Collect device description. 	 * Right now we only need this to differentiate 7945 from 7946. 	 * Note that we always issue the describe command to unit 0. 	 */
name|cmd
index|[
literal|0
index|]
operator|=
name|C_SUNIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|1
index|]
operator|=
name|C_SVOL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|C_DESC
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_EXEC
argument_list|,
operator|&
name|desc
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
condition|)
block|{
specifier|register
name|int
name|n
init|=
name|desc
operator|.
name|d_name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|name
index|[
name|i
index|]
operator|=
operator|(
name|n
operator|&
literal|0xf
operator|)
operator|+
literal|'0'
expr_stmt|;
name|n
operator|>>=
literal|4
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ctinfo
index|[
name|id
index|]
operator|.
name|hwid
condition|)
block|{
case|case
name|CT7946ID
case|:
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
literal|"079450"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* not really a 7946 */
comment|/* fall into... */
case|case
name|CT9144ID
case|:
case|case
name|CT9145ID
case|:
name|sc
operator|->
name|sc_type
operator|=
name|CT9144
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_CANSTREAM
expr_stmt|;
break|break;
case|case
name|CT7912PID
case|:
case|case
name|CT7914PID
case|:
name|sc
operator|->
name|sc_type
operator|=
name|CT88140
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"ct%d: %s %stape\n"
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|,
name|ctinfo
index|[
name|id
index|]
operator|.
name|desc
argument_list|,
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_CANSTREAM
operator|)
condition|?
literal|"streaming "
else|:
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ctreset
argument_list|(
name|sc
argument_list|,
name|hd
argument_list|)
specifier|register
expr|struct
name|ct_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
name|stat
decl_stmt|;
name|sc
operator|->
name|sc_clear
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|sc
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_clear
operator|.
name|cmd
operator|=
name|C_CLEAR
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_TCMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_clear
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_clear
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_src
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|CTCTLR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_src
operator|.
name|nop
operator|=
name|C_NOP
expr_stmt|;
name|sc
operator|->
name|sc_src
operator|.
name|cmd
operator|=
name|C_SREL
expr_stmt|;
name|sc
operator|->
name|sc_src
operator|.
name|param
operator|=
name|C_REL
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_src
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_src
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ssmc
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|sc
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ssmc
operator|.
name|cmd
operator|=
name|C_SSM
expr_stmt|;
name|sc
operator|->
name|sc_ssmc
operator|.
name|refm
operator|=
name|REF_MASK
expr_stmt|;
name|sc
operator|->
name|sc_ssmc
operator|.
name|fefm
operator|=
name|FEF_MASK
expr_stmt|;
name|sc
operator|->
name|sc_ssmc
operator|.
name|aefm
operator|=
name|AEF_MASK
expr_stmt|;
name|sc
operator|->
name|sc_ssmc
operator|.
name|iefm
operator|=
name|IEF_MASK
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_ssmc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ssmc
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_soptc
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|sc
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_soptc
operator|.
name|nop
operator|=
name|C_NOP
expr_stmt|;
name|sc
operator|->
name|sc_soptc
operator|.
name|cmd
operator|=
name|C_SOPT
expr_stmt|;
name|sc
operator|->
name|sc_soptc
operator|.
name|opt
operator|=
name|C_SPAR
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_soptc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_soptc
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|ctopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|type
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ct_softc
modifier|*
name|sc
init|=
operator|&
name|ct_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|u_char
name|stat
decl_stmt|;
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|UNIT
argument_list|(
name|dev
argument_list|)
operator|>=
name|NCT
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_soptc
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|sc
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_soptc
operator|.
name|nop
operator|=
name|C_NOP
expr_stmt|;
name|sc
operator|->
name|sc_soptc
operator|.
name|cmd
operator|=
name|C_SOPT
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|&
name|CT_STREAM
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_CANSTREAM
operator|)
condition|)
name|sc
operator|->
name|sc_soptc
operator|.
name|opt
operator|=
name|C_SPAR
operator||
name|C_IMRPT
expr_stmt|;
else|else
name|sc
operator|->
name|sc_soptc
operator|.
name|opt
operator|=
name|C_SPAR
expr_stmt|;
comment|/*  	 * Check the return of hpibsend() and hpibswait(). 	 * Drive could be loading/unloading a tape. If not checked, 	 * driver hangs.  	 */
name|cc
operator|=
name|hpibsend
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_soptc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_soptc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_soptc
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|hpibswait
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|cc
operator|=
name|hpibrecv
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_tpr
operator|=
name|tprintf_open
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|ctclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ct_softc
modifier|*
name|sc
init|=
operator|&
name|ct_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|CTF_WRT
operator||
name|CTF_WRTTN
operator|)
operator|)
operator|==
operator|(
name|CTF_WRT
operator||
name|CTF_WRTTN
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_EOT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX return error if EOT ?? */
name|ctcommand
argument_list|(
name|dev
argument_list|,
name|MTWEOF
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ctcommand
argument_list|(
name|dev
argument_list|,
name|MTBSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_eofp
operator|==
name|EOFS
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_eofs
index|[
name|EOFS
operator|-
literal|1
index|]
operator|--
expr_stmt|;
else|else
name|sc
operator|->
name|sc_eofp
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CT_BSF
condition|)
name|printf
argument_list|(
literal|"ct%d: ctclose backup eofs prt %d blk %d\n"
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_eofp
argument_list|,
name|sc
operator|->
name|sc_eofs
index|[
name|sc
operator|->
name|sc_eofp
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|CT_NOREW
operator|)
operator|==
literal|0
condition|)
name|ctcommand
argument_list|(
name|dev
argument_list|,
name|MTREW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|CTF_OPEN
operator||
name|CTF_WRT
operator||
name|CTF_WRTTN
operator|)
expr_stmt|;
name|tprintf_close
argument_list|(
name|sc
operator|->
name|sc_tpr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CDB_FILES
condition|)
name|printf
argument_list|(
literal|"ctclose: flags %x\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX */
block|}
end_block

begin_macro
name|ctcommand
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ct_softc
modifier|*
name|sc
init|=
operator|&
name|ct_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
operator|&
name|ctbuf
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|nbp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MTBSF
operator|&&
name|sc
operator|->
name|sc_eofp
operator|==
name|EOFS
operator|-
literal|1
condition|)
block|{
name|cnt
operator|=
name|sc
operator|->
name|sc_eofs
index|[
name|EOFS
operator|-
literal|1
index|]
operator|-
name|cnt
expr_stmt|;
name|ctcommand
argument_list|(
name|dev
argument_list|,
name|MTREW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctcommand
argument_list|(
name|dev
argument_list|,
name|MTFSF
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|2
expr_stmt|;
name|cmd
operator|=
name|MTBSR
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|MTBSF
operator|&&
name|sc
operator|->
name|sc_eofp
operator|-
name|cnt
operator|<
literal|0
condition|)
block|{
name|cnt
operator|=
literal|1
expr_stmt|;
name|cmd
operator|=
name|MTREW
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_CMD
expr_stmt|;
name|sc
operator|->
name|sc_bp
operator|=
name|bp
expr_stmt|;
name|sc
operator|->
name|sc_cmd
operator|=
name|cmd
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MTFSF
condition|)
block|{
name|nbp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|geteblk
argument_list|(
name|MAXBSIZE
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|nbp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|MAXBSIZE
expr_stmt|;
block|}
name|again
label|:
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MTBSF
condition|)
block|{
name|sc
operator|->
name|sc_blkno
operator|=
name|sc
operator|->
name|sc_eofs
index|[
name|sc
operator|->
name|sc_eofp
index|]
expr_stmt|;
name|sc
operator|->
name|sc_eofp
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CT_BSF
condition|)
name|printf
argument_list|(
literal|"ct%d: backup eof pos %d blk %d\n"
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_eofp
argument_list|,
name|sc
operator|->
name|sc_eofs
index|[
name|sc
operator|->
name|sc_eofp
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ctstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|cnt
operator|>
literal|0
condition|)
goto|goto
name|again
goto|;
name|bp
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_CMD
expr_stmt|;
if|if
condition|(
name|nbp
condition|)
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ctstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|&
name|cttab
index|[
name|unit
index|]
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bp
operator|->
name|b_actb
operator|=
name|dp
operator|->
name|b_actb
expr_stmt|;
operator|*
name|dp
operator|->
name|b_actb
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actb
operator|=
operator|&
name|bp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|ctustart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ctustart
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ct_softc
modifier|*
name|sc
init|=
operator|&
name|ct_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|cttab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
name|sc
operator|->
name|sc_addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|hpibreq
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
condition|)
name|ctstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ctstart
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ct_softc
modifier|*
name|sc
init|=
operator|&
name|ct_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|bp
operator|=
name|cttab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_CMD
operator|)
operator|&&
name|sc
operator|->
name|sc_bp
operator|==
name|bp
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|sc_cmd
condition|)
block|{
case|case
name|MTFSF
case|:
name|bp
operator|->
name|b_flags
operator||=
name|B_READ
expr_stmt|;
goto|goto
name|mustio
goto|;
case|case
name|MTBSF
case|:
goto|goto
name|gotaddr
goto|;
case|case
name|MTOFFL
case|:
name|sc
operator|->
name|sc_blkno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ul
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|sc
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ul
operator|.
name|cmd
operator|=
name|C_UNLOAD
expr_stmt|;
name|hpibsend
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_ul
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ul
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTWEOF
case|:
name|sc
operator|->
name|sc_blkno
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_WRT
expr_stmt|;
name|sc
operator|->
name|sc_wfm
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|sc
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_wfm
operator|.
name|cmd
operator|=
name|C_WFM
expr_stmt|;
name|hpibsend
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_wfm
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_wfm
argument_list|)
argument_list|)
expr_stmt|;
name|ctaddeof
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSR
case|:
name|sc
operator|->
name|sc_blkno
operator|--
expr_stmt|;
goto|goto
name|gotaddr
goto|;
case|case
name|MTFSR
case|:
name|sc
operator|->
name|sc_blkno
operator|++
expr_stmt|;
goto|goto
name|gotaddr
goto|;
case|case
name|MTREW
case|:
name|sc
operator|->
name|sc_blkno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CT_BSF
condition|)
name|printf
argument_list|(
literal|"ct%d: clearing eofs\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EOFS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_eofs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_eofp
operator|=
literal|0
expr_stmt|;
name|gotaddr
label|:
name|sc
operator|->
name|sc_ioc
operator|.
name|saddr
operator|=
name|C_SADDR
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|addr0
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|addr
operator|=
name|sc
operator|->
name|sc_blkno
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|sc
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|nop2
operator|=
name|C_NOP
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|slen
operator|=
name|C_SLEN
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|nop3
operator|=
name|C_NOP
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|cmd
operator|=
name|C_READ
expr_stmt|;
name|hpibsend
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_ioc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ioc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|mustio
label|:
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|&&
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|CTF_BEOF
operator||
name|CTF_EOT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CDB_FILES
condition|)
name|printf
argument_list|(
literal|"ctstart: before flags %x\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_BEOF
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_BEOF
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_AEOF
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CDB_FILES
condition|)
name|printf
argument_list|(
literal|"ctstart: after flags %x\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|hpibfree
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|=
name|bp
operator|->
name|b_actf
condition|)
name|dp
operator|->
name|b_actb
operator|=
name|bp
operator|->
name|b_actb
expr_stmt|;
else|else
name|cttab
index|[
name|unit
index|]
operator|.
name|b_actb
operator|=
name|bp
operator|->
name|b_actb
expr_stmt|;
operator|*
name|bp
operator|->
name|b_actb
operator|=
name|dp
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|)
operator|==
name|NULL
condition|)
block|{
name|cttab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|sc
operator|->
name|sc_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|hpibreq
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
condition|)
goto|goto
name|again
goto|;
return|return;
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_IO
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|sc
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|saddr
operator|=
name|C_SADDR
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|addr0
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|addr
operator|=
name|sc
operator|->
name|sc_blkno
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|nop2
operator|=
name|C_NOP
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|slen
operator|=
name|C_SLEN
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|len
operator|=
name|sc
operator|->
name|sc_resid
expr_stmt|;
name|sc
operator|->
name|sc_ioc
operator|.
name|nop3
operator|=
name|C_NOP
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|sc
operator|->
name|sc_ioc
operator|.
name|cmd
operator|=
name|C_READ
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_ioc
operator|.
name|cmd
operator|=
name|C_WRITE
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
operator|(
name|CTF_WRT
operator||
name|CTF_WRTTN
operator|)
expr_stmt|;
block|}
name|hpibsend
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_ioc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ioc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hpibawait
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ctgo
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ct_softc
modifier|*
name|sc
init|=
operator|&
name|ct_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|cttab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
name|hpibgo
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_EXEC
argument_list|,
name|sc
operator|->
name|sc_addr
argument_list|,
name|sc
operator|->
name|sc_resid
argument_list|,
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Hideous grue to handle EOF/EOT (mostly for reads)  */
end_comment

begin_expr_stmt
name|cteof
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
specifier|register
expr|struct
name|ct_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|blks
decl_stmt|;
comment|/* 	 * EOT on a write is an error. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENOSPC
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_EOT
expr_stmt|;
return|return;
block|}
comment|/* 	 * Use returned block position to determine how many blocks 	 * we really read and update b_resid. 	 */
name|blks
operator|=
name|sc
operator|->
name|sc_stat
operator|.
name|c_blk
operator|-
name|sc
operator|->
name|sc_blkno
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CDB_FILES
condition|)
name|printf
argument_list|(
literal|"cteof: bc %d oblk %d nblk %d read %d, resid %d\n"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|sc
operator|->
name|sc_blkno
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_blk
argument_list|,
name|blks
argument_list|,
name|bp
operator|->
name|b_bcount
operator|-
name|CTKTOB
argument_list|(
name|blks
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|blks
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 9145 on EOF does not change sc_stat.c_blk */
name|blks
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_blkno
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_blkno
operator|=
name|sc
operator|->
name|sc_stat
operator|.
name|c_blk
expr_stmt|;
block|}
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|CTKTOB
argument_list|(
name|blks
argument_list|)
expr_stmt|;
comment|/* 	 * If we are at physical EOV or were after an EOF, 	 * we are now at logical EOT. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_stat
operator|.
name|c_aef
operator|&
name|AEF_EOV
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_AEOF
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_EOT
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|CTF_AEOF
operator||
name|CTF_BEOF
operator|)
expr_stmt|;
block|}
comment|/* 	 * If we were before an EOF or we have just completed a FSF, 	 * we are now after EOF. 	 */
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_BEOF
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_CMD
operator|)
operator|&&
name|sc
operator|->
name|sc_cmd
operator|==
name|MTFSF
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_AEOF
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_BEOF
expr_stmt|;
block|}
comment|/* 	 * Otherwise if we read something we are now before EOF 	 * (and no longer after EOF). 	 */
elseif|else
if|if
condition|(
name|blks
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_BEOF
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_AEOF
expr_stmt|;
block|}
comment|/* 	 * Finally, if we didn't read anything we just passed an EOF 	 */
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_AEOF
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CDB_FILES
condition|)
name|printf
argument_list|(
literal|"cteof: leaving flags %x\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ctintr
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ct_softc
modifier|*
name|sc
init|=
operator|&
name|ct_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|u_char
name|stat
decl_stmt|;
name|bp
operator|=
name|cttab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: bp == NULL\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_IO
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_IO
expr_stmt|;
if|if
condition|(
name|hpibustart
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|)
condition|)
name|ctgo
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_STATWAIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hpibpptest
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_STATWAIT
expr_stmt|;
name|hpibawait
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_STATWAIT
expr_stmt|;
name|hpibrecv
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CDB_FILES
condition|)
name|printf
argument_list|(
literal|"ctintr: before flags %x\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
condition|)
block|{
name|sc
operator|->
name|sc_rsc
operator|.
name|unit
operator|=
name|C_SUNIT
argument_list|(
name|sc
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rsc
operator|.
name|cmd
operator|=
name|C_STATUS
expr_stmt|;
name|hpibsend
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|sc
operator|->
name|sc_rsc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rsc
argument_list|)
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_EXEC
argument_list|,
operator|&
name|sc
operator|->
name|sc_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stat
argument_list|)
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CDB_FILES
condition|)
name|printf
argument_list|(
literal|"ctintr: return stat 0x%x, A%x F%x blk %d\n"
argument_list|,
name|stat
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_aef
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_fef
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_blk
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_stat
operator|.
name|c_aef
operator|&
operator|(
name|AEF_EOF
operator||
name|AEF_EOV
operator|)
condition|)
block|{
name|cteof
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ctaddeof
argument_list|(
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_stat
operator|.
name|c_fef
operator|&
name|FEF_PF
condition|)
block|{
name|ctreset
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hd
argument_list|)
expr_stmt|;
name|ctstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_stat
operator|.
name|c_fef
operator|&
name|FEF_REXMT
condition|)
block|{
name|ctstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_stat
operator|.
name|c_aef
operator|&
literal|0x5800
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_stat
operator|.
name|c_aef
operator|&
literal|0x4000
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_tpr
argument_list|,
literal|"ct%d: uninitialized media\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stat
operator|.
name|c_aef
operator|&
literal|0x1000
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_tpr
argument_list|,
literal|"ct%d: not ready\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stat
operator|.
name|c_aef
operator|&
literal|0x0800
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_tpr
argument_list|,
literal|"ct%d: write protect\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ct%d err: v%d u%d ru%d bn%d, "
argument_list|,
name|unit
argument_list|,
operator|(
name|sc
operator|->
name|sc_stat
operator|.
name|c_vu
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_vu
operator|&
literal|0xF
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_pend
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_blk
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"R0x%x F0x%x A0x%x I0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_ref
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_fef
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_aef
argument_list|,
name|sc
operator|->
name|sc_stat
operator|.
name|c_ief
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"ct%d: request status failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_CMD
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|sc_cmd
condition|)
block|{
case|case
name|MTFSF
case|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|CTF_BEOF
operator||
name|CTF_AEOF
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_blkno
operator|+=
name|CTBTOK
argument_list|(
name|sc
operator|->
name|sc_resid
argument_list|)
expr_stmt|;
name|ctstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
case|case
name|MTBSF
case|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|CTF_AEOF
operator||
name|CTF_BEOF
operator||
name|CTF_EOT
operator|)
expr_stmt|;
break|break;
case|case
name|MTBSR
case|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_BEOF
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_EOT
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_AEOF
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_EOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|CTF_AEOF
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_BEOF
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_AEOF
expr_stmt|;
block|}
break|break;
case|case
name|MTWEOF
case|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_BEOF
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|CTF_AEOF
operator||
name|CTF_EOT
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_EOT
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_AEOF
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|CTF_AEOF
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
case|case
name|MTOFFL
case|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|CTF_BEOF
operator||
name|CTF_AEOF
operator||
name|CTF_EOT
operator|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CTF_AEOF
expr_stmt|;
name|sc
operator|->
name|sc_blkno
operator|+=
name|CTBTOK
argument_list|(
name|sc
operator|->
name|sc_resid
argument_list|)
expr_stmt|;
block|}
name|done
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CDB_FILES
condition|)
name|printf
argument_list|(
literal|"ctintr: after flags %x\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|=
name|bp
operator|->
name|b_actf
condition|)
name|dp
operator|->
name|b_actb
operator|=
name|bp
operator|->
name|b_actb
expr_stmt|;
else|else
name|cttab
index|[
name|unit
index|]
operator|.
name|b_actb
operator|=
name|bp
operator|->
name|b_actb
expr_stmt|;
operator|*
name|bp
operator|->
name|b_actb
operator|=
name|dp
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|hpibfree
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cttab
index|[
name|unit
index|]
operator|.
name|b_actf
operator|==
name|NULL
condition|)
block|{
name|cttab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ctustart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ctread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|ctstrategy
argument_list|,
operator|&
name|ctbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|ctwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|ctstrategy
argument_list|,
operator|&
name|ctbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|ctioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mtop
modifier|*
name|op
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCTOP
case|:
name|op
operator|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTWEOF
case|:
case|case
name|MTFSF
case|:
case|case
name|MTBSR
case|:
case|case
name|MTBSF
case|:
case|case
name|MTFSR
case|:
name|cnt
operator|=
name|op
operator|->
name|mt_count
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
case|case
name|MTOFFL
case|:
name|cnt
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ctcommand
argument_list|(
name|dev
argument_list|,
name|op
operator|->
name|mt_op
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTIOCGET
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|ctdump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_macro
name|ctaddeof
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ct_softc
modifier|*
name|sc
init|=
operator|&
name|ct_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_eofp
operator|==
name|EOFS
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_eofs
index|[
name|EOFS
operator|-
literal|1
index|]
operator|++
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_eofp
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_eofp
operator|==
name|EOFS
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_eofs
index|[
name|EOFS
operator|-
literal|1
index|]
operator|=
name|EOFS
expr_stmt|;
else|else
comment|/* save blkno */
name|sc
operator|->
name|sc_eofs
index|[
name|sc
operator|->
name|sc_eofp
index|]
operator|=
name|sc
operator|->
name|sc_blkno
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ctdebug
operator|&
name|CT_BSF
condition|)
name|printf
argument_list|(
literal|"ct%d: add eof pos %d blk %d\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_eofp
argument_list|,
name|sc
operator|->
name|sc_eofs
index|[
name|sc
operator|->
name|sc_eofp
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

