begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  *	@(#)pmap.c	8.5 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * HP9000/300 series physical map management code.  *  * Supports:  *	68020 with HP MMU	models 320, 350  *	68020 with 68551 MMU	models 318, 319, 330 (all untested)  *	68030 with on-chip MMU	models 340, 360, 370, 345, 375, 400  *	68040 with on-chip MMU	models 380, 425, 433  *  * Notes:  *	Don't even pay lip service to multiprocessor support.  *  *	We assume TLB entries don't have process tags (except for the  *	supervisor/user distinction) so we only invalidate TLB entries  *	when changing mappings for the current (or kernel) pmap.  This is  *	technically not true for the 68551 but we flush the TLB on every  *	context switch, so it effectively winds up that way.  *  *	Bitwise and/or operations are significantly faster than bitfield  *	references so we use them when accessing STE/PTEs in the pmap_pte_*  *	macros.  Note also that the two are not always equivalent; e.g.:  *		(*(int *)pte& PG_PROT) [4] != pte->pg_prot [1]  *	and a couple of routines that deal with protection and wiring take  *	some shortcuts that assume the and/or definitions.  *  *	This implementation will only work for PAGE_SIZE == NBPG  *	(i.e. 4096 bytes).  */
end_comment

begin_comment
comment|/*  *	Manages physical address maps.  *  *	In addition to hardware address maps, this  *	module is called upon to provide software-use-only  *	maps which may or may not be stored in the same  *	form as hardware maps.  These pseudo-maps are  *	used to store intermediate results from copy  *	operations to and from address spaces.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<hp300/hp300/pte.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PMAPSTATS
end_ifdef

begin_struct
struct|struct
block|{
name|int
name|collectscans
decl_stmt|;
name|int
name|collectpages
decl_stmt|;
name|int
name|kpttotal
decl_stmt|;
name|int
name|kptinuse
decl_stmt|;
name|int
name|kptmaxuse
decl_stmt|;
block|}
name|kpt_stats
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
name|kernel
decl_stmt|;
comment|/* entering kernel mapping */
name|int
name|user
decl_stmt|;
comment|/* entering user mapping */
name|int
name|ptpneeded
decl_stmt|;
comment|/* needed to allocate a PT page */
name|int
name|nochange
decl_stmt|;
comment|/* no change at all */
name|int
name|pwchange
decl_stmt|;
comment|/* no mapping change, just wiring or protection */
name|int
name|wchange
decl_stmt|;
comment|/* no mapping change, just wiring */
name|int
name|pchange
decl_stmt|;
comment|/* no mapping change, just protection */
name|int
name|mchange
decl_stmt|;
comment|/* was mapped but mapping to different page */
name|int
name|managed
decl_stmt|;
comment|/* a managed page */
name|int
name|firstpv
decl_stmt|;
comment|/* first mapping for this PA */
name|int
name|secondpv
decl_stmt|;
comment|/* second mapping for this PA */
name|int
name|ci
decl_stmt|;
comment|/* cache inhibited */
name|int
name|unmanaged
decl_stmt|;
comment|/* not a managed page */
name|int
name|flushes
decl_stmt|;
comment|/* cache flushes */
block|}
name|enter_stats
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
name|calls
decl_stmt|;
name|int
name|removes
decl_stmt|;
name|int
name|pvfirst
decl_stmt|;
name|int
name|pvsearch
decl_stmt|;
name|int
name|ptinvalid
decl_stmt|;
name|int
name|uflushes
decl_stmt|;
name|int
name|sflushes
decl_stmt|;
block|}
name|remove_stats
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
name|calls
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|int
name|alreadyro
decl_stmt|;
name|int
name|alreadyrw
decl_stmt|;
block|}
name|protect_stats
struct|;
end_struct

begin_struct
struct|struct
name|chgstats
block|{
name|int
name|setcalls
decl_stmt|;
name|int
name|sethits
decl_stmt|;
name|int
name|setmiss
decl_stmt|;
name|int
name|clrcalls
decl_stmt|;
name|int
name|clrhits
decl_stmt|;
name|int
name|clrmiss
decl_stmt|;
block|}
name|changebit_stats
index|[
literal|16
index|]
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|debugmap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmapdebug
init|=
literal|0x2000
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PDB_FOLLOW
value|0x0001
end_define

begin_define
define|#
directive|define
name|PDB_INIT
value|0x0002
end_define

begin_define
define|#
directive|define
name|PDB_ENTER
value|0x0004
end_define

begin_define
define|#
directive|define
name|PDB_REMOVE
value|0x0008
end_define

begin_define
define|#
directive|define
name|PDB_CREATE
value|0x0010
end_define

begin_define
define|#
directive|define
name|PDB_PTPAGE
value|0x0020
end_define

begin_define
define|#
directive|define
name|PDB_CACHE
value|0x0040
end_define

begin_define
define|#
directive|define
name|PDB_BITS
value|0x0080
end_define

begin_define
define|#
directive|define
name|PDB_COLLECT
value|0x0100
end_define

begin_define
define|#
directive|define
name|PDB_PROTECT
value|0x0200
end_define

begin_define
define|#
directive|define
name|PDB_SEGTAB
value|0x0400
end_define

begin_define
define|#
directive|define
name|PDB_MULTIMAP
value|0x0800
end_define

begin_define
define|#
directive|define
name|PDB_PARANOIA
value|0x2000
end_define

begin_define
define|#
directive|define
name|PDB_WIRING
value|0x4000
end_define

begin_define
define|#
directive|define
name|PDB_PVDUMP
value|0x8000
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVEVAC
end_ifdef

begin_decl_stmt
name|int
name|pmapvacflush
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PVF_ENTER
value|0x01
end_define

begin_define
define|#
directive|define
name|PVF_REMOVE
value|0x02
end_define

begin_define
define|#
directive|define
name|PVF_PROTECT
value|0x04
end_define

begin_define
define|#
directive|define
name|PVF_TOTAL
value|0x80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
end_if

begin_decl_stmt
name|int
name|dowriteback
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 68040: enable writeback caching */
end_comment

begin_decl_stmt
name|int
name|dokwriteback
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 68040: enable writeback caching of kernel AS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|vm_offset_t
name|pager_sva
decl_stmt|,
name|pager_eva
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get STEs and PTEs for user/kernel address space  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
end_if

begin_define
define|#
directive|define
name|pmap_ste1
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
define|\
value|(&((m)->pm_stab[(vm_offset_t)(v)>> SG4_SHIFT1]))
end_define

begin_comment
comment|/* XXX assumes physically contiguous ST pages (if more than one) */
end_comment

begin_define
define|#
directive|define
name|pmap_ste2
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
define|\
value|(&((m)->pm_stab[(st_entry_t *)(*(u_int *)pmap_ste1(m, v)& SG4_ADDR1) \ 			- (m)->pm_stpa + (((v)& SG4_MASK2)>> SG4_SHIFT2)]))
end_define

begin_define
define|#
directive|define
name|pmap_ste
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
define|\
value|(&((m)->pm_stab[(vm_offset_t)(v) \>> (mmutype == MMU_68040 ? SG4_SHIFT1 : SG_ISHIFT)]))
end_define

begin_define
define|#
directive|define
name|pmap_ste_v
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
define|\
value|(mmutype == MMU_68040 \ 	 ? ((*(int *)pmap_ste1(m, v)& SG_V)&& \ 	    (*(int *)pmap_ste2(m, v)& SG_V)) \ 	 : (*(int *)pmap_ste(m, v)& SG_V))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|pmap_ste
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
value|(&((m)->pm_stab[(vm_offset_t)(v)>> SG_ISHIFT]))
end_define

begin_define
define|#
directive|define
name|pmap_ste_v
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
value|(*(int *)pmap_ste(m, v)& SG_V)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pmap_pte
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
value|(&((m)->pm_ptab[(vm_offset_t)(v)>> PG_SHIFT]))
end_define

begin_define
define|#
directive|define
name|pmap_pte_pa
parameter_list|(
name|pte
parameter_list|)
value|(*(int *)(pte)& PG_FRAME)
end_define

begin_define
define|#
directive|define
name|pmap_pte_w
parameter_list|(
name|pte
parameter_list|)
value|(*(int *)(pte)& PG_W)
end_define

begin_define
define|#
directive|define
name|pmap_pte_ci
parameter_list|(
name|pte
parameter_list|)
value|(*(int *)(pte)& PG_CI)
end_define

begin_define
define|#
directive|define
name|pmap_pte_m
parameter_list|(
name|pte
parameter_list|)
value|(*(int *)(pte)& PG_M)
end_define

begin_define
define|#
directive|define
name|pmap_pte_u
parameter_list|(
name|pte
parameter_list|)
value|(*(int *)(pte)& PG_U)
end_define

begin_define
define|#
directive|define
name|pmap_pte_prot
parameter_list|(
name|pte
parameter_list|)
value|(*(int *)(pte)& PG_PROT)
end_define

begin_define
define|#
directive|define
name|pmap_pte_v
parameter_list|(
name|pte
parameter_list|)
value|(*(int *)(pte)& PG_V)
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_w
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
define|\
value|if (v) *(int *)(pte) |= PG_W; else *(int *)(pte)&= ~PG_W
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_prot
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
define|\
value|if (v) *(int *)(pte) |= PG_PROT; else *(int *)(pte)&= ~PG_PROT
end_define

begin_define
define|#
directive|define
name|pmap_pte_w_chg
parameter_list|(
name|pte
parameter_list|,
name|nw
parameter_list|)
value|((nw) ^ pmap_pte_w(pte))
end_define

begin_define
define|#
directive|define
name|pmap_pte_prot_chg
parameter_list|(
name|pte
parameter_list|,
name|np
parameter_list|)
value|((np) ^ pmap_pte_prot(pte))
end_define

begin_comment
comment|/*  * Given a map and a machine independent protection code,  * convert to an hp300 protection code.  */
end_comment

begin_define
define|#
directive|define
name|pte_prot
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
value|(protection_codes[p])
end_define

begin_decl_stmt
name|int
name|protection_codes
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kernel page table page management.  */
end_comment

begin_struct
struct|struct
name|kpt_page
block|{
name|struct
name|kpt_page
modifier|*
name|kpt_next
decl_stmt|;
comment|/* link on either used or free list */
name|vm_offset_t
name|kpt_va
decl_stmt|;
comment|/* always valid kernel VA */
name|vm_offset_t
name|kpt_pa
decl_stmt|;
comment|/* PA of this page (for speed) */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|kpt_page
modifier|*
name|kpt_free_list
decl_stmt|,
modifier|*
name|kpt_used_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kpt_page
modifier|*
name|kpt_pages
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kernel segment/page table and page table map.  * The page table map gives us a level of indirection we need to dynamically  * expand the page table.  It is essentially a copy of the segment table  * with PTEs instead of STEs.  All are initialized in locore at boot time.  * Sysmap will initially contain VM_KERNEL_PT_PAGES pages of PTEs.  * Segtabzero is an empty segment table which all processes share til they  * reference something.  */
end_comment

begin_decl_stmt
name|st_entry_t
modifier|*
name|Sysseg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
modifier|*
name|Sysmap
decl_stmt|,
modifier|*
name|Sysptmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|st_entry_t
modifier|*
name|Segtabzero
decl_stmt|,
modifier|*
name|Segtabzeropa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_size_t
name|Sysptsize
init|=
name|VM_KERNEL_PT_PAGES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_map_t
name|st_map
decl_stmt|,
name|pt_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of first available physical page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of last available physical page */
end_comment

begin_decl_stmt
name|vm_size_t
name|mem_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* memory size in bytes */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss)*/
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|vm_first_phys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of first managed page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|vm_last_phys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA just past last managed page */
end_comment

begin_decl_stmt
name|boolean_t
name|pmap_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Has pmap_init completed? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pmap_attributes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference and modify bits */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVEVAC
end_ifdef

begin_decl_stmt
name|int
name|pmap_aliasmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seperation at which VA aliasing ok */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
end_if

begin_decl_stmt
name|int
name|protostfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prototype (default) free ST map */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Internal routines  */
end_comment

begin_decl_stmt
name|void
name|pmap_remove_mapping
name|__P
argument_list|(
operator|(
name|pmap_t
operator|,
name|vm_offset_t
operator|,
name|pt_entry_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|pmap_testbit
name|__P
argument_list|(
operator|(
name|vm_offset_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pmap_changebit
name|__P
argument_list|(
operator|(
name|vm_offset_t
operator|,
name|int
operator|,
name|boolean_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pmap_enter_ptpage
name|__P
argument_list|(
operator|(
name|pmap_t
operator|,
name|vm_offset_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|void
name|pmap_pvdump
name|__P
argument_list|(
operator|(
name|vm_offset_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pmap_check_wiring
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|vm_offset_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pmap_remove_mapping flags */
end_comment

begin_define
define|#
directive|define
name|PRM_TFLUSH
value|1
end_define

begin_define
define|#
directive|define
name|PRM_CFLUSH
value|2
end_define

begin_comment
comment|/*  * Bootstrap memory allocator. This function allows for early dynamic  * memory allocation until the virtual memory system has been bootstrapped.  * After that point, either kmem_alloc or malloc should be used. This  * function works by stealing pages from the (to be) managed page pool,  * stealing virtual address space, then mapping the pages and zeroing them.  *  * It should be used from pmap_bootstrap till vm_page_startup, afterwards  * it cannot be used, and will generate a panic if tried. Note that this  * memory will never be freed, and in essence it is wired down.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_bootstrap_alloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|boolean_t
name|vm_page_startup_initialized
decl_stmt|;
name|vm_offset_t
name|val
decl_stmt|;
if|if
condition|(
name|vm_page_startup_initialized
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap_alloc: called after startup initialized"
argument_list|)
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|val
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|=
name|pmap_map
argument_list|(
name|virtual_avail
argument_list|,
name|avail_start
argument_list|,
name|avail_start
operator|+
name|size
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|avail_start
operator|+=
name|size
expr_stmt|;
name|blkclr
argument_list|(
operator|(
name|caddr_t
operator|)
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|phys_start
parameter_list|,
name|phys_end
parameter_list|)
name|vm_offset_t
name|phys_start
decl_stmt|,
name|phys_end
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|,
name|addr2
decl_stmt|;
name|vm_size_t
name|npg
decl_stmt|,
name|s
decl_stmt|;
name|int
name|rv
decl_stmt|;
specifier|extern
name|char
name|kstack
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_init(%x, %x)\n"
argument_list|,
name|phys_start
argument_list|,
name|phys_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now that kernel map has been allocated, we can mark as 	 * unavailable regions which we have mapped in locore. 	 */
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|intiobase
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|NULL
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
name|hp300_ptob
argument_list|(
name|IIOMAPSIZE
operator|+
name|EIOMAPSIZE
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
operator|(
name|vm_offset_t
operator|)
name|intiobase
condition|)
goto|goto
name|bogons
goto|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|Sysmap
expr_stmt|;
name|vm_object_reference
argument_list|(
name|kernel_object
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|kernel_object
argument_list|,
name|addr
argument_list|,
operator|&
name|addr
argument_list|,
name|HP_MAX_PTSIZE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * If this fails it is probably because the static portion of 	 * the kernel page table isn't big enough and we overran the 	 * page table map.   Need to adjust pmap_size() in hp300_init.c. 	 */
if|if
condition|(
name|addr
operator|!=
operator|(
name|vm_offset_t
operator|)
name|Sysmap
condition|)
goto|goto
name|bogons
goto|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|kstack
expr_stmt|;
name|vm_object_reference
argument_list|(
name|kernel_object
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|kernel_object
argument_list|,
name|addr
argument_list|,
operator|&
name|addr
argument_list|,
name|hp300_ptob
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
operator|(
name|vm_offset_t
operator|)
name|kstack
condition|)
name|bogons
label|:
name|panic
argument_list|(
literal|"pmap_init: bogons in the VM system!\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_INIT
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_init: Sysseg %x, Sysmap %x, Sysptmap %x\n"
argument_list|,
name|Sysseg
argument_list|,
name|Sysmap
argument_list|,
name|Sysptmap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  pstart %x, pend %x, vstart %x, vend %x\n"
argument_list|,
name|avail_start
argument_list|,
name|avail_end
argument_list|,
name|virtual_avail
argument_list|,
name|virtual_end
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Allocate memory for random pmap data structures.  Includes the 	 * initial segment table, pv_head_table and pmap_attributes. 	 */
name|npg
operator|=
name|atop
argument_list|(
name|phys_end
operator|-
name|phys_start
argument_list|)
expr_stmt|;
name|s
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
name|HP_STSIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
operator|*
name|npg
operator|+
name|npg
argument_list|)
expr_stmt|;
name|s
operator|=
name|round_page
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Segtabzero
operator|=
operator|(
name|st_entry_t
operator|*
operator|)
name|addr
expr_stmt|;
name|Segtabzeropa
operator|=
operator|(
name|st_entry_t
operator|*
operator|)
name|pmap_extract
argument_list|(
name|kernel_pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|HP_STSIZE
expr_stmt|;
name|pv_table
operator|=
operator|(
name|pv_entry_t
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
operator|*
name|npg
expr_stmt|;
name|pmap_attributes
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_INIT
condition|)
name|printf
argument_list|(
literal|"pmap_init: %x bytes: npg %x s0 %x(%x) tbl %x atr %x\n"
argument_list|,
name|s
argument_list|,
name|npg
argument_list|,
name|Segtabzero
argument_list|,
name|Segtabzeropa
argument_list|,
name|pv_table
argument_list|,
name|pmap_attributes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate physical memory for kernel PT pages and their management. 	 * We need 1 PT page per possible task plus some slop. 	 */
name|npg
operator|=
name|min
argument_list|(
name|atop
argument_list|(
name|HP_MAX_KPTSIZE
argument_list|)
argument_list|,
name|maxproc
operator|+
literal|16
argument_list|)
expr_stmt|;
name|s
operator|=
name|ptoa
argument_list|(
name|npg
argument_list|)
operator|+
name|round_page
argument_list|(
name|npg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kpt_page
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that space will be allocated in region for which 	 * we already have kernel PT pages. 	 */
name|addr
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
operator|||
name|addr
operator|+
name|s
operator|>=
operator|(
name|vm_offset_t
operator|)
name|Sysmap
condition|)
name|panic
argument_list|(
literal|"pmap_init: kernel PT too small"
argument_list|)
expr_stmt|;
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Now allocate the space and link the pages together to 	 * form the KPT free list. 	 */
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ptoa
argument_list|(
name|npg
argument_list|)
expr_stmt|;
name|addr2
operator|=
name|addr
operator|+
name|s
expr_stmt|;
name|kpt_pages
operator|=
operator|&
operator|(
operator|(
expr|struct
name|kpt_page
operator|*
operator|)
name|addr2
operator|)
index|[
name|npg
index|]
expr_stmt|;
name|kpt_free_list
operator|=
operator|(
expr|struct
name|kpt_page
operator|*
operator|)
literal|0
expr_stmt|;
do|do
block|{
name|addr2
operator|-=
name|HP_PAGE_SIZE
expr_stmt|;
operator|(
operator|--
name|kpt_pages
operator|)
operator|->
name|kpt_next
operator|=
name|kpt_free_list
expr_stmt|;
name|kpt_free_list
operator|=
name|kpt_pages
expr_stmt|;
name|kpt_pages
operator|->
name|kpt_va
operator|=
name|addr2
expr_stmt|;
name|kpt_pages
operator|->
name|kpt_pa
operator|=
name|pmap_extract
argument_list|(
name|kernel_pmap
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|addr
operator|!=
name|addr2
condition|)
do|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|kpt_stats
operator|.
name|kpttotal
operator|=
name|atop
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_INIT
condition|)
name|printf
argument_list|(
literal|"pmap_init: KPT: %d pages from %x to %x\n"
argument_list|,
name|atop
argument_list|(
name|s
argument_list|)
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate the segment table map 	 */
name|s
operator|=
name|maxproc
operator|*
name|HP_STSIZE
expr_stmt|;
name|st_map
operator|=
name|kmem_suballoc
argument_list|(
name|kernel_map
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addr2
argument_list|,
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Slightly modified version of kmem_suballoc() to get page table 	 * map where we want it. 	 */
name|addr
operator|=
name|HP_PTBASE
expr_stmt|;
name|s
operator|=
name|min
argument_list|(
name|HP_PTMAXSIZE
argument_list|,
name|maxproc
operator|*
name|HP_MAX_PTSIZE
argument_list|)
expr_stmt|;
name|addr2
operator|=
name|addr
operator|+
name|s
expr_stmt|;
name|rv
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
name|panic
argument_list|(
literal|"pmap_init: cannot allocate space for PT map"
argument_list|)
expr_stmt|;
name|pmap_reference
argument_list|(
name|vm_map_pmap
argument_list|(
name|kernel_map
argument_list|)
argument_list|)
expr_stmt|;
name|pt_map
operator|=
name|vm_map_create
argument_list|(
name|vm_map_pmap
argument_list|(
name|kernel_map
argument_list|)
argument_list|,
name|addr
argument_list|,
name|addr2
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt_map
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_init: cannot create pt_map"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_submap
argument_list|(
name|kernel_map
argument_list|,
name|addr
argument_list|,
name|addr2
argument_list|,
name|pt_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
name|panic
argument_list|(
literal|"pmap_init: cannot map range to pt_map"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_INIT
condition|)
name|printf
argument_list|(
literal|"pmap_init: pt_map [%x - %x)\n"
argument_list|,
name|addr
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
block|{
name|protostfree
operator|=
operator|~
name|l2tobm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|rv
operator|=
name|MAXUL2SIZE
init|;
name|rv
operator|<
sizeof|sizeof
argument_list|(
name|protostfree
argument_list|)
operator|*
name|NBBY
condition|;
name|rv
operator|++
control|)
name|protostfree
operator|&=
operator|~
name|l2tobm
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Now it is safe to enable pv_table recording. 	 */
name|vm_first_phys
operator|=
name|phys_start
expr_stmt|;
name|vm_last_phys
operator|=
name|phys_end
expr_stmt|;
name|pmap_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	For now, VM is already on, we only need to map the  *	specified memory.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|virt
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|prot
parameter_list|)
name|vm_offset_t
name|virt
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|;
name|int
name|prot
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_map(%x, %x, %x, %x)\n"
argument_list|,
name|virt
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|virt
argument_list|,
name|start
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|virt
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
name|virt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Create and return a physical map.  *  *	If the size specified for the map  *	is zero, the map is an actual physical  *	map, and may be referenced by the  *	hardware.  *  *	If the size specified is non-zero,  *	the map will be used in software only, and  *	is bounded by that size.  */
end_comment

begin_function
name|pmap_t
name|pmap_create
parameter_list|(
name|size
parameter_list|)
name|vm_size_t
name|size
decl_stmt|;
block|{
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_create(%x)\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Software use map does not need a pmap 	 */
if|if
condition|(
name|size
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* XXX: is it ok to wait here? */
name|pmap
operator|=
operator|(
name|pmap_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pmap
argument_list|,
name|M_VMPMAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notifwewait
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_create: cannot allocate a pmap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|pmap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_pinit
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_pinit(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * No need to allocate page table space yet but we do need a 	 * valid segment table.  Initially, we point everyone at the 	 * "null" segment table.  On the first pmap_enter, a real 	 * segment table will be allocated. 	 */
name|pmap
operator|->
name|pm_stab
operator|=
name|Segtabzero
expr_stmt|;
name|pmap
operator|->
name|pm_stpa
operator|=
name|Segtabzeropa
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
name|pmap
operator|->
name|pm_stfree
operator|=
name|protostfree
expr_stmt|;
endif|#
directive|endif
name|pmap
operator|->
name|pm_stchanged
operator|=
name|TRUE
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Retire the given physical map from service.  *	Should only be called if the map contains  *	no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_destroy
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_destroy(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|count
operator|=
operator|--
name|pmap
operator|->
name|pm_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|pmap_release
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pmap
argument_list|,
name|M_VMPMAP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_release(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notdef
comment|/* DIAGNOSTIC */
comment|/* count would be 0 from pmap_destroy... */
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_count
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_release count"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|->
name|pm_ptab
condition|)
name|kmem_free_wakeup
argument_list|(
name|pt_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_ptab
argument_list|,
name|HP_MAX_PTSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_stab
operator|!=
name|Segtabzero
condition|)
name|kmem_free_wakeup
argument_list|(
name|st_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_stab
argument_list|,
name|HP_STSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Add a reference to the specified pmap.  */
end_comment

begin_function
name|void
name|pmap_reference
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_reference(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|++
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
specifier|register
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|nssva
decl_stmt|;
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|firstpage
decl_stmt|,
name|needcflush
decl_stmt|;
name|int
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_REMOVE
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_remove(%x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|calls
operator|++
expr_stmt|;
endif|#
directive|endif
name|firstpage
operator|=
name|TRUE
expr_stmt|;
name|needcflush
operator|=
name|FALSE
expr_stmt|;
name|flags
operator|=
name|active_pmap
argument_list|(
name|pmap
argument_list|)
condition|?
name|PRM_TFLUSH
else|:
literal|0
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|nssva
operator|=
name|hp300_trunc_seg
argument_list|(
name|sva
argument_list|)
operator|+
name|HP_SEG_SIZE
expr_stmt|;
if|if
condition|(
name|nssva
operator|==
literal|0
operator|||
name|nssva
operator|>
name|eva
condition|)
name|nssva
operator|=
name|eva
expr_stmt|;
comment|/* 		 * If VA belongs to an unallocated segment, 		 * skip to the next segment boundary. 		 */
if|if
condition|(
operator|!
name|pmap_ste_v
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
condition|)
block|{
name|sva
operator|=
name|nssva
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Invalidate every valid mapping within this segment. 		 */
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|nssva
condition|)
block|{
if|if
condition|(
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVEVAC
if|if
condition|(
name|pmap_aliasmask
condition|)
block|{
comment|/* 					 * Purge kernel side of VAC to ensure 					 * we get the correct state of any 					 * hardware maintained bits. 					 */
if|if
condition|(
name|firstpage
condition|)
block|{
name|DCIS
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|sflushes
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 					 * Remember if we may need to 					 * flush the VAC due to a non-CI 					 * mapping. 					 */
if|if
condition|(
operator|!
name|needcflush
operator|&&
operator|!
name|pmap_pte_ci
argument_list|(
name|pte
argument_list|)
condition|)
name|needcflush
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
name|pmap_remove_mapping
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|pte
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|firstpage
operator|=
name|FALSE
expr_stmt|;
block|}
name|pte
operator|++
expr_stmt|;
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
comment|/* 	 * Didn't do anything, no need for cache flushes 	 */
if|if
condition|(
name|firstpage
condition|)
return|return;
ifdef|#
directive|ifdef
name|HAVEVAC
comment|/* 	 * In a couple of cases, we don't need to worry about flushing 	 * the VAC: 	 * 	1. if this is a kernel mapping, 	 *	   we have already done it 	 *	2. if it is a user mapping not for the current process, 	 *	   it won't be there 	 */
if|if
condition|(
name|pmap_aliasmask
operator|&&
operator|(
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pmap
operator|!=
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
operator|.
name|pmap
operator|)
condition|)
name|needcflush
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmap_aliasmask
operator|&&
operator|(
name|pmapvacflush
operator|&
name|PVF_REMOVE
operator|)
condition|)
block|{
if|if
condition|(
name|pmapvacflush
operator|&
name|PVF_TOTAL
condition|)
name|DCIA
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|DCIS
argument_list|()
expr_stmt|;
else|else
name|DCIU
argument_list|()
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|needcflush
condition|)
block|{
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
block|{
name|DCIS
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|sflushes
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|DCIU
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|uflushes
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	pmap_page_protect:  *  *	Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|pa
parameter_list|,
name|prot
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PROTECT
operator|)
operator|)
operator|||
name|prot
operator|==
name|VM_PROT_NONE
operator|&&
operator|(
name|pmapdebug
operator|&
name|PDB_REMOVE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_page_protect(%x, %x)\n"
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
return|return;
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
case|:
case|case
name|VM_PROT_ALL
case|:
return|return;
comment|/* copy_on_write */
case|case
name|VM_PROT_READ
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
case|:
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|PG_RO
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
comment|/* remove_all */
default|default:
break|break;
block|}
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|pmap_ste_v
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
operator|||
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
operator|!=
name|pa
condition|)
name|panic
argument_list|(
literal|"pmap_page_protect: bad mapping"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap_remove_mapping
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pte
argument_list|,
name|PRM_TFLUSH
operator||
name|PRM_CFLUSH
argument_list|)
expr_stmt|;
else|else
block|{
name|pv
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_PARANOIA
condition|)
name|printf
argument_list|(
literal|"%s wired mapping for %x not removed\n"
argument_list|,
literal|"pmap_page_protect:"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|,
name|prot
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
specifier|register
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|nssva
decl_stmt|;
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|firstpage
decl_stmt|,
name|needtflush
decl_stmt|;
name|int
name|isro
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_protect(%x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|protect_stats
operator|.
name|calls
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
return|return;
name|isro
operator|=
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|needtflush
operator|=
name|active_pmap
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|firstpage
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|nssva
operator|=
name|hp300_trunc_seg
argument_list|(
name|sva
argument_list|)
operator|+
name|HP_SEG_SIZE
expr_stmt|;
if|if
condition|(
name|nssva
operator|==
literal|0
operator|||
name|nssva
operator|>
name|eva
condition|)
name|nssva
operator|=
name|eva
expr_stmt|;
comment|/* 		 * If VA belongs to an unallocated segment, 		 * skip to the next segment boundary. 		 */
if|if
condition|(
operator|!
name|pmap_ste_v
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
condition|)
block|{
name|sva
operator|=
name|nssva
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Change protection on mapping if it is valid and doesn't 		 * already have the correct protection. 		 */
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|nssva
condition|)
block|{
if|if
condition|(
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
operator|&&
name|pmap_pte_prot_chg
argument_list|(
name|pte
argument_list|,
name|isro
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVEVAC
comment|/* 				 * Purge kernel side of VAC to ensure we 				 * get the correct state of any hardware 				 * maintained bits. 				 * 				 * XXX do we need to clear the VAC in 				 * general to reflect the new protection? 				 */
if|if
condition|(
name|firstpage
operator|&&
name|pmap_aliasmask
condition|)
name|DCIS
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
comment|/* 				 * Clear caches if making RO (see section 				 * "7.3 Cache Coherency" in the manual). 				 */
if|if
condition|(
name|isro
operator|&&
name|mmutype
operator|==
name|MMU_68040
condition|)
block|{
name|vm_offset_t
name|pa
init|=
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
decl_stmt|;
name|DCFP
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|ICPP
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pmap_pte_set_prot
argument_list|(
name|pte
argument_list|,
name|isro
argument_list|)
expr_stmt|;
if|if
condition|(
name|needtflush
condition|)
name|TBIS
argument_list|(
name|sva
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|protect_stats
operator|.
name|changed
operator|++
expr_stmt|;
endif|#
directive|endif
name|firstpage
operator|=
name|FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PMAPSTATS
elseif|else
if|if
condition|(
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|isro
condition|)
name|protect_stats
operator|.
name|alreadyro
operator|++
expr_stmt|;
else|else
name|protect_stats
operator|.
name|alreadyrw
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|pte
operator|++
expr_stmt|;
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVEVAC
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUG
argument_list|)
if|if
condition|(
name|pmap_aliasmask
operator|&&
operator|(
name|pmapvacflush
operator|&
name|PVF_PROTECT
operator|)
condition|)
block|{
if|if
condition|(
name|pmapvacflush
operator|&
name|PVF_TOTAL
condition|)
name|DCIA
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|DCIS
argument_list|()
expr_stmt|;
else|else
name|DCIU
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|pa
parameter_list|,
name|prot
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|npte
decl_stmt|;
name|vm_offset_t
name|opa
decl_stmt|;
name|boolean_t
name|cacheable
init|=
name|TRUE
decl_stmt|;
name|boolean_t
name|checkpv
init|=
name|TRUE
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_ENTER
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_enter(%x, %x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PMAPSTATS
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|enter_stats
operator|.
name|kernel
operator|++
expr_stmt|;
else|else
name|enter_stats
operator|.
name|user
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * For user mapping, allocate kernel VM resources if necessary. 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_ptab
operator|==
name|NULL
condition|)
name|pmap
operator|->
name|pm_ptab
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kmem_alloc_wait
argument_list|(
name|pt_map
argument_list|,
name|HP_MAX_PTSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Segment table entry not valid, we need a new PT page 	 */
if|if
condition|(
operator|!
name|pmap_ste_v
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
name|pmap_enter_ptpage
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pa
operator|=
name|hp300_trunc_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|opa
operator|=
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"enter: pte %x, *pte %x\n"
argument_list|,
name|pte
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Mapping has not changed, must be protection or wiring change. 	 */
if|if
condition|(
name|opa
operator|==
name|pa
condition|)
block|{
ifdef|#
directive|ifdef
name|PMAPSTATS
name|enter_stats
operator|.
name|pwchange
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Wiring change, just update stats. 		 * We don't worry about wiring PT pages as they remain 		 * resident as long as there are valid mappings in them. 		 * Hence, if a user page is wired, the PT page will be also. 		 */
if|if
condition|(
name|pmap_pte_w_chg
argument_list|(
name|pte
argument_list|,
name|wired
condition|?
name|PG_W
else|:
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"enter: wiring change -> %x\n"
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
else|else
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
if|if
condition|(
name|pmap_pte_prot
argument_list|(
name|pte
argument_list|)
operator|==
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
condition|)
name|enter_stats
operator|.
name|wchange
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|PMAPSTATS
elseif|else
if|if
condition|(
name|pmap_pte_prot
argument_list|(
name|pte
argument_list|)
operator|!=
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
condition|)
name|enter_stats
operator|.
name|pchange
operator|++
expr_stmt|;
else|else
name|enter_stats
operator|.
name|nochange
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Retain cache inhibition status 		 */
name|checkpv
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pmap_pte_ci
argument_list|(
name|pte
argument_list|)
condition|)
name|cacheable
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|validate
goto|;
block|}
comment|/* 	 * Mapping has changed, invalidate old range and fall through to 	 * handle validating new mapping. 	 */
if|if
condition|(
name|opa
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"enter: removing old mapping %x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_remove_mapping
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pte
argument_list|,
name|PRM_TFLUSH
operator||
name|PRM_CFLUSH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|enter_stats
operator|.
name|mchange
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * If this is a new user mapping, increment the wiring count 	 * on this PT page.  PT pages are wired down as long as there 	 * is a valid mapping in the page. 	 */
if|if
condition|(
name|pmap
operator|!=
name|kernel_pmap
condition|)
operator|(
name|void
operator|)
name|vm_map_pageable
argument_list|(
name|pt_map
argument_list|,
name|trunc_page
argument_list|(
name|pte
argument_list|)
argument_list|,
name|round_page
argument_list|(
name|pte
operator|+
literal|1
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * Enter on the PV list if part of our managed memory 	 * Note that we raise IPL while manipulating pv_table 	 * since pmap_enter can be called at interrupt time. 	 */
if|if
condition|(
name|pa
operator|>=
name|vm_first_phys
operator|&&
name|pa
operator|<
name|vm_last_phys
condition|)
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|enter_stats
operator|.
name|managed
operator|++
expr_stmt|;
endif|#
directive|endif
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"enter: pv at %x: %x/%x/%x\n"
argument_list|,
name|pv
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_next
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * No entries yet, use header as the first entry 		 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PMAPSTATS
name|enter_stats
operator|.
name|firstpv
operator|++
expr_stmt|;
endif|#
directive|endif
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|NULL
expr_stmt|;
name|pv
operator|->
name|pv_ptste
operator|=
name|NULL
expr_stmt|;
name|pv
operator|->
name|pv_ptpmap
operator|=
name|NULL
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * There is at least one other VA mapping this page. 		 * Place this entry after the header. 		 */
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|npv
operator|=
name|pv
init|;
name|npv
condition|;
name|npv
operator|=
name|npv
operator|->
name|pv_next
control|)
if|if
condition|(
name|pmap
operator|==
name|npv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|npv
operator|->
name|pv_va
condition|)
name|panic
argument_list|(
literal|"pmap_enter: already in pv_tab"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|npv
operator|=
operator|(
name|pv_entry_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|npv
argument_list|,
name|M_VMPVENT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|npv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|npv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|npv
operator|->
name|pv_next
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
name|npv
operator|->
name|pv_ptste
operator|=
name|NULL
expr_stmt|;
name|npv
operator|->
name|pv_ptpmap
operator|=
name|NULL
expr_stmt|;
name|npv
operator|->
name|pv_flags
operator|=
literal|0
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|npv
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
if|if
condition|(
operator|!
name|npv
operator|->
name|pv_next
condition|)
name|enter_stats
operator|.
name|secondpv
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVEVAC
comment|/* 			 * Since there is another logical mapping for the 			 * same page we may need to cache-inhibit the 			 * descriptors on those CPUs with external VACs. 			 * We don't need to CI if: 			 * 			 * - No two mappings belong to the same user pmaps. 			 *   Since the cache is flushed on context switches 			 *   there is no problem between user processes. 			 * 			 * - Mappings within a single pmap are a certain 			 *   magic distance apart.  VAs at these appropriate 			 *   boundaries map to the same cache entries or 			 *   otherwise don't conflict. 			 * 			 * To keep it simple, we only check for these special 			 * cases if there are only two mappings, otherwise we 			 * punt and always CI. 			 * 			 * Note that there are no aliasing problems with the 			 * on-chip data-cache when the WA bit is set. 			 */
if|if
condition|(
name|pmap_aliasmask
condition|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_flags
operator|&
name|PV_CI
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_CACHE
condition|)
name|printf
argument_list|(
literal|"enter: pa %x already CI'ed\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|checkpv
operator|=
name|cacheable
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|npv
operator|->
name|pv_next
operator|||
operator|(
operator|(
name|pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|||
name|pmap
operator|==
name|kernel_pmap
operator|||
name|pv
operator|->
name|pv_pmap
operator|==
name|kernel_pmap
operator|)
operator|&&
operator|(
operator|(
name|pv
operator|->
name|pv_va
operator|&
name|pmap_aliasmask
operator|)
operator|!=
operator|(
name|va
operator|&
name|pmap_aliasmask
operator|)
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_CACHE
condition|)
name|printf
argument_list|(
literal|"enter: pa %x CI'ing all\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cacheable
operator|=
name|FALSE
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator||=
name|PV_CI
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|enter_stats
operator|.
name|ci
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Assumption: if it is not part of our managed memory 	 * then it must be device memory which may be volitile. 	 */
elseif|else
if|if
condition|(
name|pmap_initialized
condition|)
block|{
name|checkpv
operator|=
name|cacheable
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|enter_stats
operator|.
name|unmanaged
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|validate
label|:
ifdef|#
directive|ifdef
name|HAVEVAC
comment|/* 	 * Purge kernel side of VAC to ensure we get correct state 	 * of HW bits so we don't clobber them. 	 */
if|if
condition|(
name|pmap_aliasmask
condition|)
name|DCIS
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Build the new PTE. 	 */
name|npte
operator|=
name|pa
operator||
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
operator||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|&
operator|(
name|PG_M
operator||
name|PG_U
operator|)
operator|)
operator||
name|PG_V
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|npte
operator||=
name|PG_W
expr_stmt|;
if|if
condition|(
operator|!
name|checkpv
operator|&&
operator|!
name|cacheable
condition|)
name|npte
operator||=
name|PG_CI
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
operator|&&
operator|(
name|npte
operator|&
operator|(
name|PG_PROT
operator||
name|PG_CI
operator|)
operator|)
operator|==
name|PG_RW
condition|)
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dowriteback
operator|&&
operator|(
name|dokwriteback
operator|||
name|pmap
operator|!=
name|kernel_pmap
operator|)
condition|)
endif|#
directive|endif
name|npte
operator||=
name|PG_CCB
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"enter: new pte value %x\n"
argument_list|,
name|npte
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Remember if this was a wiring-only change. 	 * If so, we need not flush the TLB and caches. 	 */
name|wired
operator|=
operator|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|^
name|npte
operator|)
operator|==
name|PG_W
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
operator|&&
operator|!
name|wired
condition|)
block|{
name|DCFP
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|ICPP
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|npte
expr_stmt|;
if|if
condition|(
operator|!
name|wired
operator|&&
name|active_pmap
argument_list|(
name|pmap
argument_list|)
condition|)
name|TBIS
argument_list|(
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVEVAC
comment|/* 	 * The following is executed if we are entering a second 	 * (or greater) mapping for a physical page and the mappings 	 * may create an aliasing problem.  In this case we must 	 * cache inhibit the descriptors involved and flush any 	 * external VAC. 	 */
if|if
condition|(
name|checkpv
operator|&&
operator|!
name|cacheable
condition|)
block|{
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|PG_CI
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|DCIA
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|enter_stats
operator|.
name|flushes
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|pmapdebug
operator|&
operator|(
name|PDB_CACHE
operator||
name|PDB_PVDUMP
operator|)
operator|)
operator|==
operator|(
name|PDB_CACHE
operator||
name|PDB_PVDUMP
operator|)
condition|)
name|pmap_pvdump
argument_list|(
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|pmapvacflush
operator|&
name|PVF_ENTER
condition|)
block|{
if|if
condition|(
name|pmapvacflush
operator|&
name|PVF_TOTAL
condition|)
name|DCIA
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|DCIS
argument_list|()
expr_stmt|;
else|else
name|DCIU
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|pmapdebug
operator|&
name|PDB_WIRING
operator|)
operator|&&
name|pmap
operator|!=
name|kernel_pmap
condition|)
name|pmap_check_wiring
argument_list|(
literal|"enter"
argument_list|,
name|trunc_page
argument_list|(
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_change_wiring(%x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 	 * Page table page is not allocated. 	 * Should this ever happen?  Ignore it for now, 	 * we don't want to force allocation of unnecessary PTE pages. 	 */
if|if
condition|(
operator|!
name|pmap_ste_v
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_PARANOIA
condition|)
name|printf
argument_list|(
literal|"pmap_change_wiring: invalid STE for %x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Page not valid.  Should this ever happen? 	 * Just continue and change wiring anyway. 	 */
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_PARANOIA
condition|)
name|printf
argument_list|(
literal|"pmap_change_wiring: invalid PTE for %x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If wiring actually changed (always?) set the wire bit and 	 * update the wire count.  Note that wiring is not a hardware 	 * characteristic so there is no need to invalidate the TLB. 	 */
if|if
condition|(
name|pmap_pte_w_chg
argument_list|(
name|pte
argument_list|,
name|wired
condition|?
name|PG_W
else|:
literal|0
argument_list|)
condition|)
block|{
name|pmap_pte_set_w
argument_list|(
name|pte
argument_list|,
name|wired
argument_list|)
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
else|else
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_extract
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_extract(%x, %x) -> "
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pa
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pmap
operator|&&
name|pmap_ste_v
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
name|pa
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
condition|)
name|pa
operator|=
operator|(
name|pa
operator|&
name|PG_FRAME
operator|)
operator||
operator|(
name|va
operator|&
operator|~
name|PG_FRAME
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"%x\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|dst_pmap
parameter_list|,
name|src_pmap
parameter_list|,
name|dst_addr
parameter_list|,
name|len
parameter_list|,
name|src_addr
parameter_list|)
name|pmap_t
name|dst_pmap
decl_stmt|;
name|pmap_t
name|src_pmap
decl_stmt|;
name|vm_offset_t
name|dst_addr
decl_stmt|;
name|vm_size_t
name|len
decl_stmt|;
name|vm_offset_t
name|src_addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_copy(%x, %x, %x, %x, %x)\n"
argument_list|,
name|dst_pmap
argument_list|,
name|src_pmap
argument_list|,
name|dst_addr
argument_list|,
name|len
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Require that all active physical maps contain no  *	incorrect entries NOW.  [This update includes  *	forcing updates of any address map caching.]  *  *	Generally used to insure that a thread about  *	to run will see a semantically correct world.  */
end_comment

begin_function
name|void
name|pmap_update
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_update()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TBIA
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_collect  *	Function:  *		Garbage collects the physical map system for  *		pages which are no longer used.  *		Success need not be guaranteed -- that is, there  *		may well be pages which are not referenced, but  *		others may be collected.  *	Usage:  *		Called by the pageout daemon when pages are scarce.  */
end_comment

begin_function
name|void
name|pmap_collect
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|int
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|kpa
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
modifier|*
name|ste
decl_stmt|;
name|int
name|opmapdebug
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|!=
name|kernel_pmap
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_collect(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PMAPSTATS
name|kpt_stats
operator|.
name|collectscans
operator|++
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|pa
operator|=
name|vm_first_phys
init|;
name|pa
operator|<
name|vm_last_phys
condition|;
name|pa
operator|+=
name|PAGE_SIZE
control|)
block|{
specifier|register
name|struct
name|kpt_page
modifier|*
name|kpt
decl_stmt|,
modifier|*
modifier|*
name|pkpt
decl_stmt|;
comment|/* 		 * Locate physical pages which are being used as kernel 		 * page table pages. 		 */
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|kernel_pmap
operator|||
operator|!
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PV_PTPAGE
operator|)
condition|)
continue|continue;
do|do
block|{
if|if
condition|(
name|pv
operator|->
name|pv_ptste
operator|&&
name|pv
operator|->
name|pv_ptpmap
operator|==
name|kernel_pmap
condition|)
break|break;
block|}
do|while
condition|(
name|pv
operator|=
name|pv
operator|->
name|pv_next
condition|)
do|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pv
operator|->
name|pv_va
operator|<
operator|(
name|vm_offset_t
operator|)
name|Sysmap
operator|||
name|pv
operator|->
name|pv_va
operator|>=
operator|(
name|vm_offset_t
operator|)
name|Sysmap
operator|+
name|HP_MAX_PTSIZE
condition|)
name|printf
argument_list|(
literal|"collect: kernel PT VA out of range\n"
argument_list|)
expr_stmt|;
else|else
goto|goto
name|ok
goto|;
name|pmap_pvdump
argument_list|(
name|pa
argument_list|)
expr_stmt|;
continue|continue;
name|ok
label|:
endif|#
directive|endif
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|pv
operator|->
name|pv_va
operator|+
name|HP_PAGE_SIZE
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|pte
operator|>=
operator|(
name|int
operator|*
operator|)
name|pv
operator|->
name|pv_va
operator|&&
operator|*
name|pte
operator|==
name|PG_NV
condition|)
empty_stmt|;
if|if
condition|(
name|pte
operator|>=
operator|(
name|int
operator|*
operator|)
name|pv
operator|->
name|pv_va
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_PTPAGE
operator||
name|PDB_COLLECT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"collect: freeing KPT page at %x (ste %x@%x)\n"
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|pv
operator|->
name|pv_ptste
argument_list|,
name|pv
operator|->
name|pv_ptste
argument_list|)
expr_stmt|;
name|opmapdebug
operator|=
name|pmapdebug
expr_stmt|;
name|pmapdebug
operator||=
name|PDB_PTPAGE
expr_stmt|;
block|}
name|ste
operator|=
operator|(
name|int
operator|*
operator|)
name|pv
operator|->
name|pv_ptste
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If all entries were invalid we can remove the page. 		 * We call pmap_remove_entry to take care of invalidating 		 * ST and Sysptmap entries. 		 */
name|kpa
operator|=
name|pmap_extract
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pmap_remove_mapping
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PT_ENTRY_NULL
argument_list|,
name|PRM_TFLUSH
operator||
name|PRM_CFLUSH
argument_list|)
expr_stmt|;
comment|/* 		 * Use the physical address to locate the original 		 * (kmem_alloc assigned) address for the page and put 		 * that page back on the free list. 		 */
for|for
control|(
name|pkpt
operator|=
operator|&
name|kpt_used_list
operator|,
name|kpt
operator|=
operator|*
name|pkpt
init|;
name|kpt
operator|!=
operator|(
expr|struct
name|kpt_page
operator|*
operator|)
literal|0
condition|;
name|pkpt
operator|=
operator|&
name|kpt
operator|->
name|kpt_next
operator|,
name|kpt
operator|=
operator|*
name|pkpt
control|)
if|if
condition|(
name|kpt
operator|->
name|kpt_pa
operator|==
name|kpa
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kpt
operator|==
operator|(
expr|struct
name|kpt_page
operator|*
operator|)
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_collect: lost a KPT page"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_PTPAGE
operator||
name|PDB_COLLECT
operator|)
condition|)
name|printf
argument_list|(
literal|"collect: %x (%x) to free list\n"
argument_list|,
name|kpt
operator|->
name|kpt_va
argument_list|,
name|kpa
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|pkpt
operator|=
name|kpt
operator|->
name|kpt_next
expr_stmt|;
name|kpt
operator|->
name|kpt_next
operator|=
name|kpt_free_list
expr_stmt|;
name|kpt_free_list
operator|=
name|kpt
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|kpt_stats
operator|.
name|kptinuse
operator|--
expr_stmt|;
name|kpt_stats
operator|.
name|collectpages
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_PTPAGE
operator||
name|PDB_COLLECT
operator|)
condition|)
name|pmapdebug
operator|=
name|opmapdebug
expr_stmt|;
if|if
condition|(
operator|*
name|ste
condition|)
name|printf
argument_list|(
literal|"collect: kernel STE at %x still valid (%x)\n"
argument_list|,
name|ste
argument_list|,
operator|*
name|ste
argument_list|)
expr_stmt|;
name|ste
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|Sysptmap
index|[
operator|(
name|st_entry_t
operator|*
operator|)
name|ste
operator|-
name|pmap_ste
argument_list|(
name|kernel_pmap
argument_list|,
literal|0
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|ste
condition|)
name|printf
argument_list|(
literal|"collect: kernel PTmap at %x still valid (%x)\n"
argument_list|,
name|ste
argument_list|,
operator|*
name|ste
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|pmap
parameter_list|,
name|pcbp
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|struct
name|pcb
modifier|*
name|pcbp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_SEGTAB
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_activate(%x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|pcbp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PMAP_ACTIVATE
argument_list|(
name|pmap
argument_list|,
name|pcbp
argument_list|,
name|pmap
operator|==
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
operator|.
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bzero to clear its contents, one machine dependent page  *	at a time.  *  *	XXX this is a bad implementation for virtual cache machines  *	(320/350) because pmap_enter doesn't cache-inhibit the temporary  *	kernel mapping and we wind up with data cached for that KVA.  *	It is probably a win for physical cache machines (370/380)  *	as the cache loading is not wasted.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|phys
parameter_list|)
name|vm_offset_t
name|phys
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|kva
decl_stmt|;
specifier|extern
name|caddr_t
name|CADDR1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_zero_page(%x)\n"
argument_list|,
name|phys
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kva
operator|=
operator|(
name|vm_offset_t
operator|)
name|CADDR1
expr_stmt|;
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|kva
argument_list|,
name|phys
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|kva
argument_list|,
name|HP_PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_remove_mapping
argument_list|(
name|kernel_pmap
argument_list|,
name|kva
argument_list|,
name|PT_ENTRY_NULL
argument_list|,
name|PRM_TFLUSH
operator||
name|PRM_CFLUSH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  *  *  *	XXX this is a bad implementation for virtual cache machines  *	(320/350) because pmap_enter doesn't cache-inhibit the temporary  *	kernel mapping and we wind up with data cached for that KVA.  *	It is probably a win for physical cache machines (370/380)  *	as the cache loading is not wasted.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|vm_offset_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|skva
decl_stmt|,
name|dkva
decl_stmt|;
specifier|extern
name|caddr_t
name|CADDR1
decl_stmt|,
name|CADDR2
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_copy_page(%x, %x)\n"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|skva
operator|=
operator|(
name|vm_offset_t
operator|)
name|CADDR1
expr_stmt|;
name|dkva
operator|=
operator|(
name|vm_offset_t
operator|)
name|CADDR2
expr_stmt|;
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|skva
argument_list|,
name|src
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|dkva
argument_list|,
name|dst
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|copypage
argument_list|(
operator|(
name|caddr_t
operator|)
name|skva
argument_list|,
operator|(
name|caddr_t
operator|)
name|dkva
argument_list|)
expr_stmt|;
comment|/* CADDR1 and CADDR2 are virtually contiguous */
name|pmap_remove
argument_list|(
name|kernel_pmap
argument_list|,
name|skva
argument_list|,
name|skva
operator|+
literal|2
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_pageable  *	Function:  *		Make the specified pages (by pmap, offset)  *		pageable (or not) as requested.  *  *		A page which is not pageable may not take  *		a fault; therefore, its page table entry  *		must remain valid for the duration.  *  *		This routine is merely advisory; pmap_enter  *		will specify that these pages are to be wired  *		down (or not) as appropriate.  */
end_comment

begin_function
name|void
name|pmap_pageable
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|,
name|pageable
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
name|boolean_t
name|pageable
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_pageable(%x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|pageable
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we are making a PT page pageable then all valid 	 * mappings must be gone from that page.  Hence it should 	 * be all zeros and there is no need to clean it. 	 * Assumptions: 	 *	- we are called with only one page at a time 	 *	- PT pages have only one pv_table entry 	 */
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
operator|&&
name|pageable
operator|&&
name|sva
operator|+
name|PAGE_SIZE
operator|==
name|eva
condition|)
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PTPAGE
operator|)
operator|)
operator|==
name|PDB_PTPAGE
condition|)
name|printf
argument_list|(
literal|"pmap_pageable(%x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|pageable
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pmap_ste_v
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
condition|)
return|return;
name|pa
operator|=
name|pmap_pte_pa
argument_list|(
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
return|return;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_ptste
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pv
operator|->
name|pv_va
operator|!=
name|sva
operator|||
name|pv
operator|->
name|pv_next
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_pageable: bad PT page va %x next %x\n"
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_next
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 		 * Mark it unmodified to avoid pageout 		 */
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|PG_M
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|flags
operator|&
name|PG_CLEAN
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pa %x: flags=%x: not clean\n"
argument_list|,
name|pa
argument_list|,
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|flags
argument_list|)
expr_stmt|;
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|->
name|flags
operator||=
name|PG_CLEAN
expr_stmt|;
block|}
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_PTPAGE
condition|)
name|printf
argument_list|(
literal|"pmap_pageable: PT page %x(%x) unmodified\n"
argument_list|,
name|sva
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_WIRING
condition|)
name|pmap_check_wiring
argument_list|(
literal|"pageable"
argument_list|,
name|sva
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_clear_modify(%x)\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|PG_M
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_clear_reference(%x)\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|PG_U
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page is referenced  *	by any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
block|{
name|boolean_t
name|rv
init|=
name|pmap_testbit
argument_list|(
name|pa
argument_list|,
name|PG_U
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"pmap_is_referenced(%x) -> %c\n"
argument_list|,
name|pa
argument_list|,
literal|"FT"
index|[
name|rv
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|pmap_testbit
argument_list|(
name|pa
argument_list|,
name|PG_U
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page is modified  *	by any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
block|{
name|boolean_t
name|rv
init|=
name|pmap_testbit
argument_list|(
name|pa
argument_list|,
name|PG_M
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"pmap_is_modified(%x) -> %c\n"
argument_list|,
name|pa
argument_list|,
literal|"FT"
index|[
name|rv
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|pmap_testbit
argument_list|(
name|pa
argument_list|,
name|PG_M
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_phys_address
parameter_list|(
name|ppn
parameter_list|)
name|int
name|ppn
decl_stmt|;
block|{
return|return
operator|(
name|hp300_ptob
argument_list|(
name|ppn
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_comment
comment|/*  * 'PUX hack for dealing with the so called multi-mapped address space.  * The first 256mb is mapped in at every 256mb region from 0x10000000  * up to 0xF0000000.  This allows for 15 bits of tag information.  *  * We implement this at the segment table level, the machine independent  * VM knows nothing about it.  */
end_comment

begin_macro
name|pmap_mapmulti
argument_list|(
argument|pmap
argument_list|,
argument|va
argument_list|)
end_macro

begin_decl_stmt
name|pmap_t
name|pmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|va
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|ste
decl_stmt|,
modifier|*
name|bste
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_MULTIMAP
condition|)
block|{
name|ste
operator|=
operator|(
name|int
operator|*
operator|)
name|pmap_ste
argument_list|(
name|pmap
argument_list|,
name|HPMMBASEADDR
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pmap_mapmulti(%x, %x): bste %x(%x)"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|ste
argument_list|,
operator|*
name|ste
argument_list|)
expr_stmt|;
name|ste
operator|=
operator|(
name|int
operator|*
operator|)
name|pmap_ste
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ste %x(%x)\n"
argument_list|,
name|ste
argument_list|,
operator|*
name|ste
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bste
operator|=
operator|(
name|int
operator|*
operator|)
name|pmap_ste
argument_list|(
name|pmap
argument_list|,
name|HPMMBASEADDR
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
name|ste
operator|=
operator|(
name|int
operator|*
operator|)
name|pmap_ste
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ste
operator|==
name|SG_NV
operator|&&
operator|(
operator|*
name|bste
operator|&
name|SG_V
operator|)
condition|)
block|{
operator|*
name|ste
operator|=
operator|*
name|bste
expr_stmt|;
name|TBIAU
argument_list|()
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Miscellaneous support routines follow  */
end_comment

begin_comment
comment|/*  * Invalidate a single page denoted by pmap/va.  * If (pte != NULL), it is the already computed PTE for the page.  * If (flags& PRM_TFLUSH), we must invalidate any TLB information.  * If (flags& PRM_CFLUSH), we must flush/invalidate any cache information.  */
end_comment

begin_comment
comment|/* static */
end_comment

begin_function
name|void
name|pmap_remove_mapping
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|pte
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
specifier|register
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|pmap_t
name|ptpmap
decl_stmt|;
name|int
modifier|*
name|ste
decl_stmt|,
name|s
decl_stmt|,
name|bits
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|pt_entry_t
name|opte
decl_stmt|;
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_REMOVE
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_remove_mapping(%x, %x, %x, %x)\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pte
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * PTE not provided, compute it from pmap and va. 	 */
if|if
condition|(
name|pte
operator|==
name|PT_ENTRY_NULL
condition|)
block|{
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|==
name|PG_NV
condition|)
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVEVAC
if|if
condition|(
name|pmap_aliasmask
operator|&&
operator|(
name|flags
operator|&
name|PRM_CFLUSH
operator|)
condition|)
block|{
comment|/* 		 * Purge kernel side of VAC to ensure we get the correct 		 * state of any hardware maintained bits. 		 */
name|DCIS
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|sflushes
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If this is a non-CI user mapping for the current process, 		 * flush the VAC.  Note that the kernel side was flushed 		 * above so we don't worry about non-CI kernel mappings. 		 */
if|if
condition|(
name|pmap
operator|==
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
operator|.
name|pmap
operator|&&
operator|!
name|pmap_pte_ci
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|DCIU
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|uflushes
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
name|pa
operator|=
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|removes
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Update statistics 	 */
if|if
condition|(
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
comment|/* 	 * Invalidate the PTE after saving the reference modify info. 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_REMOVE
condition|)
name|printf
argument_list|(
literal|"remove: invalidating pte at %x\n"
argument_list|,
name|pte
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bits
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|&
operator|(
name|PG_U
operator||
name|PG_M
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|PG_NV
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PRM_TFLUSH
operator|)
operator|&&
name|active_pmap
argument_list|(
name|pmap
argument_list|)
condition|)
name|TBIS
argument_list|(
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * For user mappings decrement the wiring count on 	 * the PT page.  We do this after the PTE has been 	 * invalidated because vm_map_pageable winds up in 	 * pmap_pageable which clears the modify bit for the 	 * PT page. 	 */
if|if
condition|(
name|pmap
operator|!=
name|kernel_pmap
condition|)
block|{
operator|(
name|void
operator|)
name|vm_map_pageable
argument_list|(
name|pt_map
argument_list|,
name|trunc_page
argument_list|(
name|pte
argument_list|)
argument_list|,
name|round_page
argument_list|(
name|pte
operator|+
literal|1
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_WIRING
condition|)
name|pmap_check_wiring
argument_list|(
literal|"remove"
argument_list|,
name|trunc_page
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * If this isn't a managed page, we are all done. 	 */
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
return|return;
comment|/* 	 * Otherwise remove it from the PV table 	 * (raise IPL since we may be called at interrupt time). 	 */
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|ste
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * If it is the first entry on the list, it is actually 	 * in the header and we must copy the following entry up 	 * to the header.  Otherwise we must search the list for 	 * the entry.  In either case we free the now unused entry. 	 */
if|if
condition|(
name|pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
block|{
name|ste
operator|=
operator|(
name|int
operator|*
operator|)
name|pv
operator|->
name|pv_ptste
expr_stmt|;
name|ptpmap
operator|=
name|pv
operator|->
name|pv_ptpmap
expr_stmt|;
name|npv
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
if|if
condition|(
name|npv
condition|)
block|{
name|npv
operator|->
name|pv_flags
operator|=
name|pv
operator|->
name|pv_flags
expr_stmt|;
operator|*
name|pv
operator|=
operator|*
name|npv
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|npv
argument_list|,
name|M_VMPVENT
argument_list|)
expr_stmt|;
block|}
else|else
name|pv
operator|->
name|pv_pmap
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|pvfirst
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
for|for
control|(
name|npv
operator|=
name|pv
operator|->
name|pv_next
init|;
name|npv
condition|;
name|npv
operator|=
name|npv
operator|->
name|pv_next
control|)
block|{
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|pvsearch
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|npv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|npv
operator|->
name|pv_va
condition|)
break|break;
name|pv
operator|=
name|npv
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|npv
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_remove: PA not in pv_tab"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ste
operator|=
operator|(
name|int
operator|*
operator|)
name|npv
operator|->
name|pv_ptste
expr_stmt|;
name|ptpmap
operator|=
name|npv
operator|->
name|pv_ptpmap
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|npv
operator|->
name|pv_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|npv
argument_list|,
name|M_VMPVENT
argument_list|)
expr_stmt|;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVEVAC
comment|/* 	 * If only one mapping left we no longer need to cache inhibit 	 */
if|if
condition|(
name|pmap_aliasmask
operator|&&
name|pv
operator|->
name|pv_pmap
operator|&&
name|pv
operator|->
name|pv_next
operator|==
name|NULL
operator|&&
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PV_CI
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_CACHE
condition|)
name|printf
argument_list|(
literal|"remove: clearing CI for pa %x\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pv
operator|->
name|pv_flags
operator|&=
operator|~
name|PV_CI
expr_stmt|;
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|PG_CI
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|pmapdebug
operator|&
operator|(
name|PDB_CACHE
operator||
name|PDB_PVDUMP
operator|)
operator|)
operator|==
operator|(
name|PDB_CACHE
operator||
name|PDB_PVDUMP
operator|)
condition|)
name|pmap_pvdump
argument_list|(
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* 	 * If this was a PT page we must also remove the 	 * mapping from the associated segment table. 	 */
if|if
condition|(
name|ste
condition|)
block|{
ifdef|#
directive|ifdef
name|PMAPSTATS
name|remove_stats
operator|.
name|ptinvalid
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_REMOVE
operator||
name|PDB_PTPAGE
operator|)
condition|)
name|printf
argument_list|(
literal|"remove: ste was %x@%x pte was %x@%x\n"
argument_list|,
operator|*
name|ste
argument_list|,
name|ste
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|opte
argument_list|,
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
block|{
name|int
modifier|*
name|este
init|=
operator|&
name|ste
index|[
name|NPTEPG
operator|/
name|SG4_LEV3SIZE
index|]
decl_stmt|;
while|while
condition|(
name|ste
operator|<
name|este
condition|)
operator|*
name|ste
operator|++
operator|=
name|SG_NV
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ste
operator|-=
name|NPTEPG
operator|/
name|SG4_LEV3SIZE
expr_stmt|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
operator|*
name|ste
operator|=
name|SG_NV
expr_stmt|;
comment|/* 		 * If it was a user PT page, we decrement the 		 * reference count on the segment table as well, 		 * freeing it if it is now empty. 		 */
if|if
condition|(
name|ptpmap
operator|!=
name|kernel_pmap
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_REMOVE
operator||
name|PDB_SEGTAB
operator|)
condition|)
name|printf
argument_list|(
literal|"remove: stab %x, refcnt %d\n"
argument_list|,
name|ptpmap
operator|->
name|pm_stab
argument_list|,
name|ptpmap
operator|->
name|pm_sref
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmapdebug
operator|&
name|PDB_PARANOIA
operator|)
operator|&&
name|ptpmap
operator|->
name|pm_stab
operator|!=
operator|(
name|st_entry_t
operator|*
operator|)
name|trunc_page
argument_list|(
name|ste
argument_list|)
condition|)
name|panic
argument_list|(
literal|"remove: bogus ste"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
operator|(
name|ptpmap
operator|->
name|pm_sref
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_REMOVE
operator||
name|PDB_SEGTAB
operator|)
condition|)
name|printf
argument_list|(
literal|"remove: free stab %x\n"
argument_list|,
name|ptpmap
operator|->
name|pm_stab
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free_wakeup
argument_list|(
name|st_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ptpmap
operator|->
name|pm_stab
argument_list|,
name|HP_STSIZE
argument_list|)
expr_stmt|;
name|ptpmap
operator|->
name|pm_stab
operator|=
name|Segtabzero
expr_stmt|;
name|ptpmap
operator|->
name|pm_stpa
operator|=
name|Segtabzeropa
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
name|ptpmap
operator|->
name|pm_stfree
operator|=
name|protostfree
expr_stmt|;
endif|#
directive|endif
name|ptpmap
operator|->
name|pm_stchanged
operator|=
name|TRUE
expr_stmt|;
comment|/* 				 * XXX may have changed segment table 				 * pointer for current process so 				 * update now to reload hardware. 				 */
if|if
condition|(
name|ptpmap
operator|==
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
operator|.
name|pmap
condition|)
name|PMAP_ACTIVATE
argument_list|(
name|ptpmap
argument_list|,
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|curproc
operator|->
name|p_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|ptpmap
operator|->
name|pm_sref
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"remove: sref< 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
comment|/* 		 * XXX this should be unnecessary as we have been 		 * flushing individual mappings as we go. 		 */
block|if (ptpmap == kernel_pmap) 			TBIAS(); 		else 			TBIAU();
endif|#
directive|endif
name|pv
operator|->
name|pv_flags
operator|&=
operator|~
name|PV_PTPAGE
expr_stmt|;
name|ptpmap
operator|->
name|pm_ptpages
operator|--
expr_stmt|;
block|}
comment|/* 	 * Update saved attributes for managed page 	 */
name|pmap_attributes
index|[
name|pa_index
argument_list|(
name|pa
argument_list|)
index|]
operator||=
name|bits
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static */
end_comment

begin_function
name|boolean_t
name|pmap_testbit
parameter_list|(
name|pa
parameter_list|,
name|bit
parameter_list|)
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|int
modifier|*
name|pte
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Check saved info first 	 */
if|if
condition|(
name|pmap_attributes
index|[
name|pa_index
argument_list|(
name|pa
argument_list|)
index|]
operator|&
name|bit
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVEVAC
comment|/* 	 * Flush VAC to get correct state of any hardware maintained bits. 	 */
if|if
condition|(
name|pmap_aliasmask
operator|&&
operator|(
name|bit
operator|&
operator|(
name|PG_U
operator||
name|PG_M
operator|)
operator|)
condition|)
name|DCIS
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Not found, check current mappings returning 	 * immediately if found. 	 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
block|{
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
name|pmap_pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
operator|&
name|bit
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* static */
end_comment

begin_function
name|void
name|pmap_changebit
parameter_list|(
name|pa
parameter_list|,
name|bit
parameter_list|,
name|setem
parameter_list|)
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|boolean_t
name|setem
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|int
modifier|*
name|pte
decl_stmt|,
name|npte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|s
decl_stmt|;
name|boolean_t
name|firstpage
init|=
name|TRUE
decl_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|struct
name|chgstats
modifier|*
name|chgp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_BITS
condition|)
name|printf
argument_list|(
literal|"pmap_changebit(%x, %x, %s)\n"
argument_list|,
name|pa
argument_list|,
name|bit
argument_list|,
name|setem
condition|?
literal|"set"
else|:
literal|"clear"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
return|return;
ifdef|#
directive|ifdef
name|PMAPSTATS
name|chgp
operator|=
operator|&
name|changebit_stats
index|[
operator|(
name|bit
operator|>>
literal|2
operator|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|setem
condition|)
name|chgp
operator|->
name|setcalls
operator|++
expr_stmt|;
else|else
name|chgp
operator|->
name|clrcalls
operator|++
expr_stmt|;
endif|#
directive|endif
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Clear saved attributes (modify, reference) 	 */
if|if
condition|(
operator|!
name|setem
condition|)
name|pmap_attributes
index|[
name|pa_index
argument_list|(
name|pa
argument_list|)
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
comment|/* 	 * Loop over all current mappings setting/clearing as appropos 	 * If setting RO do we need to clear the VAC? 	 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|toflush
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|toflush
operator||=
operator|(
name|pv
operator|->
name|pv_pmap
operator|==
name|kernel_pmap
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
endif|#
directive|endif
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
comment|/* 			 * XXX don't write protect pager mappings 			 */
if|if
condition|(
name|bit
operator|==
name|PG_RO
condition|)
block|{
specifier|extern
name|vm_offset_t
name|pager_sva
decl_stmt|,
name|pager_eva
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|pager_sva
operator|&&
name|va
operator|<
name|pager_eva
condition|)
continue|continue;
block|}
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
name|pmap_pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVEVAC
comment|/* 			 * Flush VAC to ensure we get correct state of HW bits 			 * so we don't clobber them. 			 */
if|if
condition|(
name|firstpage
operator|&&
name|pmap_aliasmask
condition|)
block|{
name|firstpage
operator|=
name|FALSE
expr_stmt|;
name|DCIS
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|setem
condition|)
name|npte
operator|=
operator|*
name|pte
operator||
name|bit
expr_stmt|;
else|else
name|npte
operator|=
operator|*
name|pte
operator|&
operator|~
name|bit
expr_stmt|;
if|if
condition|(
operator|*
name|pte
operator|!=
name|npte
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
comment|/* 				 * If we are changing caching status or 				 * protection make sure the caches are 				 * flushed (but only once). 				 */
if|if
condition|(
name|firstpage
operator|&&
name|mmutype
operator|==
name|MMU_68040
operator|&&
operator|(
name|bit
operator|==
name|PG_RO
operator|&&
name|setem
operator|||
operator|(
name|bit
operator|&
name|PG_CMASK
operator|)
operator|)
condition|)
block|{
name|firstpage
operator|=
name|FALSE
expr_stmt|;
name|DCFP
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|ICPP
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
if|if
condition|(
name|active_pmap
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
condition|)
name|TBIS
argument_list|(
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAPSTATS
if|if
condition|(
name|setem
condition|)
name|chgp
operator|->
name|sethits
operator|++
expr_stmt|;
else|else
name|chgp
operator|->
name|clrhits
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|PMAPSTATS
else|else
block|{
if|if
condition|(
name|setem
condition|)
name|chgp
operator|->
name|setmiss
operator|++
expr_stmt|;
else|else
name|chgp
operator|->
name|clrmiss
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVEVAC
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUG
argument_list|)
if|if
condition|(
name|setem
operator|&&
name|bit
operator|==
name|PG_RO
operator|&&
operator|(
name|pmapvacflush
operator|&
name|PVF_PROTECT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pmapvacflush
operator|&
name|PVF_TOTAL
operator|)
operator|||
name|toflush
operator|==
literal|3
condition|)
name|DCIA
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|toflush
operator|==
literal|2
condition|)
name|DCIS
argument_list|()
expr_stmt|;
else|else
name|DCIU
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static */
end_comment

begin_function
name|void
name|pmap_enter_ptpage
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|ptpa
decl_stmt|;
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|st_entry_t
modifier|*
name|ste
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_ENTER
operator||
name|PDB_PTPAGE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_enter_ptpage: pmap %x, va %x\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PMAPSTATS
name|enter_stats
operator|.
name|ptpneeded
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate a segment table if necessary.  Note that it is allocated 	 * from a private map and not pt_map.  This keeps user page tables 	 * aligned on segment boundaries in the kernel address space. 	 * The segment table is wired down.  It will be freed whenever the 	 * reference count drops to zero. 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_stab
operator|==
name|Segtabzero
condition|)
block|{
name|pmap
operator|->
name|pm_stab
operator|=
operator|(
name|st_entry_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|st_map
argument_list|,
name|HP_STSIZE
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stpa
operator|=
operator|(
name|st_entry_t
operator|*
operator|)
name|pmap_extract
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_stab
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dowriteback
operator|&&
name|dokwriteback
condition|)
endif|#
directive|endif
name|pmap_changebit
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_stab
argument_list|,
name|PG_CCB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stfree
operator|=
name|protostfree
expr_stmt|;
block|}
endif|#
directive|endif
name|pmap
operator|->
name|pm_stchanged
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 * XXX may have changed segment table pointer for current 		 * process so update now to reload hardware. 		 */
if|if
condition|(
name|pmap
operator|==
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_map
operator|.
name|pmap
condition|)
name|PMAP_ACTIVATE
argument_list|(
name|pmap
argument_list|,
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|curproc
operator|->
name|p_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_ENTER
operator||
name|PDB_PTPAGE
operator||
name|PDB_SEGTAB
operator|)
condition|)
name|printf
argument_list|(
literal|"enter: pmap %x stab %x(%x)\n"
argument_list|,
name|pmap
argument_list|,
name|pmap
operator|->
name|pm_stab
argument_list|,
name|pmap
operator|->
name|pm_stpa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ste
operator|=
name|pmap_ste
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
comment|/* 	 * Allocate level 2 descriptor block if necessary 	 */
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
block|{
if|if
condition|(
operator|!
name|ste
operator|->
name|sg_v
condition|)
block|{
name|int
name|ix
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|ix
operator|=
name|bmtol2
argument_list|(
name|pmap
operator|->
name|pm_stfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"enter: out of address space"
argument_list|)
expr_stmt|;
comment|/* XXX */
name|pmap
operator|->
name|pm_stfree
operator|&=
operator|~
name|l2tobm
argument_list|(
name|ix
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pmap
operator|->
name|pm_stab
index|[
name|ix
operator|*
name|SG4_LEV2SIZE
index|]
expr_stmt|;
name|bzero
argument_list|(
name|addr
argument_list|,
name|SG4_LEV2SIZE
operator|*
sizeof|sizeof
argument_list|(
name|st_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pmap
operator|->
name|pm_stpa
index|[
name|ix
operator|*
name|SG4_LEV2SIZE
index|]
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|ste
operator|=
operator|(
name|u_int
operator|)
name|addr
operator||
name|SG_RW
operator||
name|SG_U
operator||
name|SG_V
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_ENTER
operator||
name|PDB_PTPAGE
operator||
name|PDB_SEGTAB
operator|)
condition|)
name|printf
argument_list|(
literal|"enter: alloc ste2 %d(%x)\n"
argument_list|,
name|ix
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ste
operator|=
name|pmap_ste2
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 		 * Since a level 2 descriptor maps a block of SG4_LEV3SIZE 		 * level 3 descriptors, we need a chunk of NPTEPG/SG4_LEV3SIZE 		 * (16) such descriptors (NBPG/SG4_LEV3SIZE bytes) to map a 		 * PT page--the unit of allocation.  We set `ste' to point 		 * to the first entry of that chunk which is validated in its 		 * entirety below. 		 */
name|ste
operator|=
operator|(
name|st_entry_t
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|ste
operator|&
operator|~
operator|(
name|NBPG
operator|/
name|SG4_LEV3SIZE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_ENTER
operator||
name|PDB_PTPAGE
operator||
name|PDB_SEGTAB
operator|)
condition|)
name|printf
argument_list|(
literal|"enter: ste2 %x (%x)\n"
argument_list|,
name|pmap_ste2
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|,
name|ste
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * In the kernel we allocate a page from the kernel PT page 	 * free list and map it into the kernel page table map (via 	 * pmap_enter). 	 */
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
block|{
specifier|register
name|struct
name|kpt_page
modifier|*
name|kpt
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|kpt
operator|=
name|kpt_free_list
operator|)
operator|==
operator|(
expr|struct
name|kpt_page
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* 			 * No PT pages available. 			 * Try once to free up unused ones. 			 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_COLLECT
condition|)
name|printf
argument_list|(
literal|"enter: no KPT pages, collecting...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_collect
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kpt
operator|=
name|kpt_free_list
operator|)
operator|==
operator|(
expr|struct
name|kpt_page
operator|*
operator|)
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_enter_ptpage: can't get KPT page"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PMAPSTATS
if|if
condition|(
operator|++
name|kpt_stats
operator|.
name|kptinuse
operator|>
name|kpt_stats
operator|.
name|kptmaxuse
condition|)
name|kpt_stats
operator|.
name|kptmaxuse
operator|=
name|kpt_stats
operator|.
name|kptinuse
expr_stmt|;
endif|#
directive|endif
name|kpt_free_list
operator|=
name|kpt
operator|->
name|kpt_next
expr_stmt|;
name|kpt
operator|->
name|kpt_next
operator|=
name|kpt_used_list
expr_stmt|;
name|kpt_used_list
operator|=
name|kpt
expr_stmt|;
name|ptpa
operator|=
name|kpt
operator|->
name|kpt_pa
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|kpt
operator|->
name|kpt_va
argument_list|,
name|HP_PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_enter
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|ptpa
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_ENTER
operator||
name|PDB_PTPAGE
operator|)
condition|)
block|{
name|int
name|ix
init|=
name|pmap_ste
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|-
name|pmap_ste
argument_list|(
name|pmap
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"enter: add&Sysptmap[%d]: %x (KPT page %x)\n"
argument_list|,
name|ix
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|Sysptmap
index|[
name|ix
index|]
argument_list|,
name|kpt
operator|->
name|kpt_va
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For user processes we just simulate a fault on that location 	 * letting the VM system allocate a zero-filled page. 	 */
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_ENTER
operator||
name|PDB_PTPAGE
operator|)
condition|)
name|printf
argument_list|(
literal|"enter: about to fault UPT pg at %x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|vm_fault
argument_list|(
name|pt_map
argument_list|,
name|va
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"vm_fault(pt_map, %x, RW, 0) -> %d\n"
argument_list|,
name|va
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"pmap_enter: vm_fault failed"
argument_list|)
expr_stmt|;
block|}
name|ptpa
operator|=
name|pmap_extract
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 		 * Mark the page clean now to avoid its pageout (and 		 * hence creation of a pager) between now and when it 		 * is wired; i.e. while it is on a paging queue. 		 */
name|PHYS_TO_VM_PAGE
argument_list|(
name|ptpa
argument_list|)
operator|->
name|flags
operator||=
name|PG_CLEAN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|PHYS_TO_VM_PAGE
argument_list|(
name|ptpa
argument_list|)
operator|->
name|flags
operator||=
name|PG_PTPAGE
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
comment|/* 	 * Turn off copyback caching of page table pages, 	 * could get ugly otherwise. 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dowriteback
operator|&&
name|dokwriteback
condition|)
endif|#
directive|endif
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
block|{
name|int
modifier|*
name|pte
init|=
operator|(
name|int
operator|*
operator|)
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|pmapdebug
operator|&
name|PDB_PARANOIA
operator|)
operator|&&
operator|(
operator|*
name|pte
operator|&
name|PG_CCB
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s PT no CCB: kva=%x ptpa=%x pte@%x=%x\n"
argument_list|,
name|pmap
operator|==
name|kernel_pmap
condition|?
literal|"Kernel"
else|:
literal|"User"
argument_list|,
name|va
argument_list|,
name|ptpa
argument_list|,
name|pte
argument_list|,
operator|*
name|pte
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_changebit
argument_list|(
name|ptpa
argument_list|,
name|PG_CCB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Locate the PV entry in the kernel for this PT page and 	 * record the STE address.  This is so that we can invalidate 	 * the STE when we remove the mapping for the page. 	 */
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|ptpa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|pv
condition|)
block|{
name|pv
operator|->
name|pv_flags
operator||=
name|PV_PTPAGE
expr_stmt|;
do|do
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|kernel_pmap
operator|&&
name|pv
operator|->
name|pv_va
operator|==
name|va
condition|)
break|break;
block|}
do|while
condition|(
name|pv
operator|=
name|pv
operator|->
name|pv_next
condition|)
do|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_enter_ptpage: PT page not entered"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pv
operator|->
name|pv_ptste
operator|=
name|ste
expr_stmt|;
name|pv
operator|->
name|pv_ptpmap
operator|=
name|pmap
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_ENTER
operator||
name|PDB_PTPAGE
operator|)
condition|)
name|printf
argument_list|(
literal|"enter: new PT page at PA %x, ste at %x\n"
argument_list|,
name|ptpa
argument_list|,
name|ste
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Map the new PT page into the segment table. 	 * Also increment the reference count on the segment table if this 	 * was a user page table page.  Note that we don't use vm_map_pageable 	 * to keep the count like we do for PT pages, this is mostly because 	 * it would be difficult to identify ST pages in pmap_pageable to 	 * release them.  We also avoid the overhead of vm_map_pageable. 	 */
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
block|{
name|st_entry_t
modifier|*
name|este
decl_stmt|;
for|for
control|(
name|este
operator|=
operator|&
name|ste
index|[
name|NPTEPG
operator|/
name|SG4_LEV3SIZE
index|]
init|;
name|ste
operator|<
name|este
condition|;
name|ste
operator|++
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|ste
operator|=
name|ptpa
operator||
name|SG_U
operator||
name|SG_RW
operator||
name|SG_V
expr_stmt|;
name|ptpa
operator|+=
name|SG4_LEV3SIZE
operator|*
sizeof|sizeof
argument_list|(
name|st_entry_t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
operator|*
operator|(
name|int
operator|*
operator|)
name|ste
operator|=
operator|(
name|ptpa
operator|&
name|SG_FRAME
operator|)
operator||
name|SG_RW
operator||
name|SG_V
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|kernel_pmap
condition|)
block|{
name|pmap
operator|->
name|pm_sref
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_ENTER
operator||
name|PDB_PTPAGE
operator||
name|PDB_SEGTAB
operator|)
condition|)
name|printf
argument_list|(
literal|"enter: stab %x refcnt %d\n"
argument_list|,
name|pmap
operator|->
name|pm_stab
argument_list|,
name|pmap
operator|->
name|pm_sref
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
comment|/* 	 * Flush stale TLB info. 	 */
block|if (pmap == kernel_pmap) 		TBIAS(); 	else 		TBIAU();
endif|#
directive|endif
name|pmap
operator|->
name|pm_ptpages
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* static */
end_comment

begin_function
name|void
name|pmap_pvdump
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|printf
argument_list|(
literal|"pa %x"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
name|printf
argument_list|(
literal|" -> pmap %x, va %x, ptste %x, ptpmap %x, flags %x"
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_ptste
argument_list|,
name|pv
operator|->
name|pv_ptpmap
argument_list|,
name|pv
operator|->
name|pv_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static */
end_comment

begin_function
name|void
name|pmap_check_wiring
parameter_list|(
name|str
parameter_list|,
name|va
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|,
modifier|*
name|pte
decl_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_ste_v
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
operator|||
operator|!
name|pmap_pte_v
argument_list|(
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|pt_map
argument_list|,
name|va
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"wired_check: entry for %x not found\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return;
block|}
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
name|va
init|;
name|pte
operator|<
operator|(
name|int
operator|*
operator|)
operator|(
name|va
operator|+
name|PAGE_SIZE
operator|)
condition|;
name|pte
operator|++
control|)
if|if
condition|(
operator|*
name|pte
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
name|count
condition|)
name|printf
argument_list|(
literal|"*%s*: %x: w%d/a%d\n"
argument_list|,
name|str
argument_list|,
name|va
argument_list|,
name|entry
operator|->
name|wired_count
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

