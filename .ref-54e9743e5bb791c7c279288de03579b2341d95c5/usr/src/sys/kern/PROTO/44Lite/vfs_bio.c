begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * %sccs.include.redist.c%  *  *	from: @(#)vfs_bio.c	8.6 (Berkeley) 1/11/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/trace.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_comment
comment|/*  * Definitions for the buffer hash lists.  */
end_comment

begin_define
define|#
directive|define
name|BUFHASH
parameter_list|(
name|dvp
parameter_list|,
name|lbn
parameter_list|)
define|\
value|(&bufhashtbl[((int)(dvp) / sizeof(*(dvp)) + (int)(lbn))& bufhash])
end_define

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|bufhashhdr
argument_list|,
name|buf
argument_list|)
operator|*
name|bufhashtbl
operator|,
name|invalhash
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|bufhash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Insq/Remq for the buffer hash lists.  */
end_comment

begin_define
define|#
directive|define
name|binshash
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|)
value|LIST_INSERT_HEAD(dp, bp, b_hash)
end_define

begin_define
define|#
directive|define
name|bremhash
parameter_list|(
name|bp
parameter_list|)
value|LIST_REMOVE(bp, b_hash)
end_define

begin_comment
comment|/*  * Definitions for the buffer free lists.  */
end_comment

begin_define
define|#
directive|define
name|BQUEUES
value|4
end_define

begin_comment
comment|/* number of free buffer queues */
end_comment

begin_define
define|#
directive|define
name|BQ_LOCKED
value|0
end_define

begin_comment
comment|/* super-blocks&c */
end_comment

begin_define
define|#
directive|define
name|BQ_LRU
value|1
end_define

begin_comment
comment|/* lru, useful buffers */
end_comment

begin_define
define|#
directive|define
name|BQ_AGE
value|2
end_define

begin_comment
comment|/* rubbish */
end_comment

begin_define
define|#
directive|define
name|BQ_EMPTY
value|3
end_define

begin_comment
comment|/* buffer headers with no memory */
end_comment

begin_macro
name|TAILQ_HEAD
argument_list|(
argument|bqueues
argument_list|,
argument|buf
argument_list|)
end_macro

begin_expr_stmt
name|bufqueues
index|[
name|BQUEUES
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|needbuffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Insq/Remq for the buffer free lists.  */
end_comment

begin_define
define|#
directive|define
name|binsheadfree
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|)
value|TAILQ_INSERT_HEAD(dp, bp, b_freelist)
end_define

begin_define
define|#
directive|define
name|binstailfree
parameter_list|(
name|bp
parameter_list|,
name|dp
parameter_list|)
value|TAILQ_INSERT_TAIL(dp, bp, b_freelist)
end_define

begin_function
name|void
name|bremfree
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|bqueues
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
comment|/* 	 * We only calculate the head of the freelist when removing 	 * the last element of the list as that is the only time that 	 * it is needed (e.g. to reset the tail pointer). 	 * 	 * NB: This makes an assumption about how tailq's are implemented. 	 */
if|if
condition|(
name|bp
operator|->
name|b_freelist
operator|.
name|tqe_next
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|dp
operator|=
name|bufqueues
init|;
name|dp
operator|<
operator|&
name|bufqueues
index|[
name|BQUEUES
index|]
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|tqh_last
operator|==
operator|&
name|bp
operator|->
name|b_freelist
operator|.
name|tqe_next
condition|)
break|break;
if|if
condition|(
name|dp
operator|==
operator|&
name|bufqueues
index|[
name|BQUEUES
index|]
condition|)
name|panic
argument_list|(
literal|"bremfree: lost tail"
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize buffers and hash links for buffers.  */
end_comment

begin_function
name|void
name|bufinit
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|bqueues
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|base
decl_stmt|,
name|residual
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|bufqueues
init|;
name|dp
operator|<
operator|&
name|bufqueues
index|[
name|BQUEUES
index|]
condition|;
name|dp
operator|++
control|)
name|TAILQ_INIT
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|bufhashtbl
operator|=
name|hashinit
argument_list|(
name|nbuf
argument_list|,
name|M_CACHE
argument_list|,
operator|&
name|bufhash
argument_list|)
expr_stmt|;
name|base
operator|=
name|bufpages
operator|/
name|nbuf
expr_stmt|;
name|residual
operator|=
name|bufpages
operator|%
name|nbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
sizeof|sizeof
expr|*
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|NOCRED
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|NOCRED
expr_stmt|;
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
operator|=
name|NOLIST
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|buffers
operator|+
name|i
operator|*
name|MAXBSIZE
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|residual
condition|)
name|bp
operator|->
name|b_bufsize
operator|=
operator|(
name|base
operator|+
literal|1
operator|)
operator|*
name|CLBYTES
expr_stmt|;
else|else
name|bp
operator|->
name|b_bufsize
operator|=
name|base
operator|*
name|CLBYTES
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_INVAL
expr_stmt|;
name|dp
operator|=
name|bp
operator|->
name|b_bufsize
condition|?
operator|&
name|bufqueues
index|[
name|BQ_AGE
index|]
else|:
operator|&
name|bufqueues
index|[
name|BQ_EMPTY
index|]
expr_stmt|;
name|binsheadfree
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|binshash
argument_list|(
name|bp
argument_list|,
operator|&
name|invalhash
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|bread
argument_list|(
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|a2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|a4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
modifier|*
name|a5
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_block

begin_macro
name|breadn
argument_list|(
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|,
argument|a8
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|a2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|a4
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a5
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|a7
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
modifier|*
name|a8
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_block

begin_macro
name|bwrite
argument_list|(
argument|a1
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_block

begin_function
name|int
name|vn_bwrite
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bwrite_args
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|bwrite
argument_list|(
name|ap
operator|->
name|a_bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|bdwrite
argument_list|(
argument|a1
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Body deleted. 	 */
return|return;
block|}
end_block

begin_macro
name|bawrite
argument_list|(
argument|a1
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Body deleted. 	 */
return|return;
block|}
end_block

begin_macro
name|brelse
argument_list|(
argument|a1
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Body deleted. 	 */
return|return;
block|}
end_block

begin_function
name|struct
name|buf
modifier|*
name|incore
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
name|struct
name|vnode
modifier|*
name|a1
decl_stmt|;
name|daddr_t
name|a2
decl_stmt|;
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|buf
modifier|*
name|getblk
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|,
name|a5
parameter_list|)
name|struct
name|vnode
modifier|*
name|a1
decl_stmt|;
name|daddr_t
name|a2
decl_stmt|;
name|int
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|;
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|buf
modifier|*
name|geteblk
parameter_list|(
name|a1
parameter_list|)
name|int
name|a1
decl_stmt|;
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|allocbuf
argument_list|(
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|buf
modifier|*
name|getnewbuf
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|;
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|biowait
argument_list|(
argument|a1
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_block

begin_function
name|void
name|biodone
parameter_list|(
name|a1
parameter_list|)
name|struct
name|buf
modifier|*
name|a1
decl_stmt|;
block|{
comment|/* 	 * Body deleted. 	 */
return|return;
block|}
end_function

begin_function
name|int
name|count_lock_queue
parameter_list|()
block|{
comment|/* 	 * Body deleted. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_comment
comment|/*  * Print out statistics on the current allocation of the buffer pool.  * Can be enabled to print out on every ``sync'' by setting "syncprt"  * in vfs_syscalls.c using sysctl.  */
end_comment

begin_function
name|void
name|vfs_bufstats
parameter_list|()
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|count
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|bqueues
modifier|*
name|dp
decl_stmt|;
name|int
name|counts
index|[
name|MAXBSIZE
operator|/
name|CLBYTES
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|bname
index|[
name|BQUEUES
index|]
init|=
block|{
literal|"LOCKED"
block|,
literal|"LRU"
block|,
literal|"AGE"
block|,
literal|"EMPTY"
block|}
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|bufqueues
operator|,
name|i
operator|=
literal|0
init|;
name|dp
operator|<
operator|&
name|bufqueues
index|[
name|BQUEUES
index|]
condition|;
name|dp
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|MAXBSIZE
operator|/
name|CLBYTES
condition|;
name|j
operator|++
control|)
name|counts
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|dp
operator|->
name|tqh_first
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_freelist
operator|.
name|tqe_next
control|)
block|{
name|counts
index|[
name|bp
operator|->
name|b_bufsize
operator|/
name|CLBYTES
index|]
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: total-%d"
argument_list|,
name|bname
index|[
name|i
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|MAXBSIZE
operator|/
name|CLBYTES
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|counts
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", %d-%d"
argument_list|,
name|j
operator|*
name|CLBYTES
argument_list|,
name|counts
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DIAGNOSTIC */
end_comment

end_unit

