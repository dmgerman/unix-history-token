begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * %sccs.include.redist.c%  *  *	@(#)qvcons.c	7.8 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  *	derived from: @(#)qvcons.c	4.1 11/23/87  */
end_comment

begin_comment
comment|/************************************************************************  *									*  *			Copyright (c) 1985 by				*  *		Digital Equipment Corporation, Maynard, MA		*  *			All rights reserved.				*  *									*  *   This software is furnished under a license and may be used and	*  *   copied  only  in accordance with the terms of such license and	*  *   with the  inclusion  of  the  above  copyright  notice.   This	*  *   software  or  any  other copies thereof may not be provided or	*  *   otherwise made available to any other person.  No title to and	*  *   ownership of the software is hereby transferred.			*  *									*  *   This software is  derived  from  software  received  from  the	*  *   University    of   California,   Berkeley,   and   from   Bell	*  *   Laboratories.  Use, duplication, or disclosure is  subject  to	*  *   restrictions  under  license  agreements  with  University  of	*  *   California and with AT&T.						*  *									*  *   The information in this software is subject to change  without	*  *   notice  and should not be construed as a commitment by Digital	*  *   Equipment Corporation.						*  *									*  *   Digital assumes no responsibility for the use  or  reliability	*  *   of its software on equipment which is not supplied by Digital.	*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------  * Modification History - moved to sccs log  *  *  7 Jul 84 --  rjl  *	Initial version to support the qvss as the system console  *	during the boot process.  *  * ---------------------------------------------------------------------  */
end_comment

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_include
include|#
directive|include
file|"../uba/qvioctl.h"
end_include

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_include
include|#
directive|include
file|"../include/cpu.h"
end_include

begin_comment
comment|/*  * MicroVAX-II q-bus memory base  */
end_comment

begin_define
define|#
directive|define
name|QMEMBASE
value|0x30000000
end_define

begin_define
define|#
directive|define
name|QVMAXEVQ
value|64
end_define

begin_define
define|#
directive|define
name|QVSSCSR
value|0x20001e80
end_define

begin_comment
comment|/*  * Screen initialization tables. qv_def_scn is used as an index into the  * table to select the proper initialization parameters.  */
end_comment

begin_decl_stmt
name|int
name|qv_def_scn
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Screen initialization flag	*/
end_comment

begin_decl_stmt
name|char
name|qv_scrn_15
index|[]
init|=
block|{
literal|31
block|,
literal|25
block|,
literal|27
block|,
literal|0142
block|,
literal|31
block|,
literal|13
block|,
literal|30
block|,
literal|31
block|,
literal|4
block|,
literal|15
block|,
literal|040
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|qv_scrn_19s
index|[]
init|=
block|{
literal|39
block|,
literal|30
block|,
literal|31
block|,
literal|0264
block|,
literal|55
block|,
literal|5
block|,
literal|54
block|,
literal|54
block|,
literal|4
block|,
literal|15
block|,
literal|040
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|qv_init_tbl
index|[]
init|=
block|{
name|qv_scrn_15
block|,
name|qv_scrn_19s
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|qv_info
name|qv_scn_defaults
index|[]
init|=
block|{
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|30
block|,
literal|80
block|,
literal|768
block|,
literal|480
block|,
literal|768
operator|-
literal|16
block|,
literal|480
operator|-
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|QVMAXEVQ
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|55
block|,
literal|120
block|,
literal|960
block|,
literal|864
block|,
literal|960
operator|-
literal|16
block|,
literal|864
operator|-
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|QVMAXEVQ
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|56
block|,
literal|120
block|,
literal|1024
block|,
literal|864
block|,
literal|1024
operator|-
literal|16
block|,
literal|864
operator|-
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|QVMAXEVQ
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|2
block|,
literal|4
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|qv_info
name|qv_scn
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|qv_keyboard
block|{
name|int
name|shift
decl_stmt|;
comment|/* state variables	*/
name|int
name|cntrl
decl_stmt|;
name|int
name|lock
decl_stmt|;
name|char
name|last
decl_stmt|;
comment|/* last character	*/
block|}
name|qv_keyboard
struct|;
end_struct

begin_decl_stmt
name|int
name|qvputc
argument_list|()
decl_stmt|,
name|qvgetc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keyboard translation and font tables  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_key
index|[]
decl_stmt|,
name|q_shift_key
index|[]
decl_stmt|,
modifier|*
name|q_special
index|[]
decl_stmt|,
name|q_font
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|q_cursor
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
type|(
modifier|*
name|v_putc
decl_stmt|)(
end_decl_stmt

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
call|(
modifier|*
name|v_getc
call|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Routine called to init a qvss.  */
end_comment

begin_macro
name|qv_init
argument_list|()
end_macro

begin_block
block|{
name|struct
name|qvdevice
modifier|*
name|qvaddr
init|=
operator|(
expr|struct
name|qvdevice
operator|*
operator|)
name|QVSSCSR
decl_stmt|;
name|char
modifier|*
name|qvssmem
decl_stmt|;
name|short
modifier|*
name|scanline
decl_stmt|;
name|int
name|i
decl_stmt|;
name|short
name|scan
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|extern
name|int
name|cpu
decl_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
name|qvaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|qvaddr
operator|->
name|qv_csr
operator|&
name|QV_19INCH
condition|)
name|qv_def_scn
operator|=
literal|1
expr_stmt|;
else|else
name|qv_def_scn
operator|=
literal|0
expr_stmt|;
name|qv_scn
operator|=
name|qv_scn_defaults
index|[
name|qv_def_scn
index|]
expr_stmt|;
name|qv_scn
operator|.
name|qvaddr
operator|=
name|qvaddr
expr_stmt|;
comment|/* 	 * Initialize the screen. 	 */
name|ptr
operator|=
name|qv_init_tbl
index|[
name|qv_def_scn
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|qvaddr
operator|->
name|qv_crtaddr
operator|=
name|i
expr_stmt|;
name|qvaddr
operator|->
name|qv_crtdata
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* 	 * Turn on the keyboard.  	 */
name|qvaddr
operator|->
name|qv_uartcmd
operator|=
literal|0x15
expr_stmt|;
comment|/* set mode pntr/enable rx/tx	*/
name|qvaddr
operator|->
name|qv_uartmode
operator|=
literal|0x17
expr_stmt|;
comment|/* noparity, 8-bit		*/
name|qvaddr
operator|->
name|qv_uartmode
operator|=
literal|0x07
expr_stmt|;
comment|/* 1 stop bit			*/
name|qvaddr
operator|->
name|qv_uartstatus
operator|=
literal|0x99
expr_stmt|;
comment|/* 4800 baud xmit/recv 		*/
name|qvssmem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|qvaddr
operator|->
name|qv_csr
operator|&
name|QV_MEM_BANK
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|cpu
operator|==
name|VAX_630
condition|)
name|qvssmem
operator|+=
name|QMEMBASE
expr_stmt|;
name|qv_scn
operator|.
name|bitmap
operator|=
name|qvssmem
expr_stmt|;
name|qv_scn
operator|.
name|scanmap
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|qvssmem
operator|+
operator|(
literal|254
operator|*
literal|1024
operator|)
operator|)
expr_stmt|;
name|qv_scn
operator|.
name|cursorbits
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|qvssmem
operator|+
operator|(
literal|256
operator|*
literal|1024
operator|)
operator|-
literal|32
operator|)
expr_stmt|;
comment|/* 	 * Setup the cursor. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|qv_scn
operator|.
name|cursorbits
index|[
name|i
index|]
operator|=
name|q_cursor
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Clear the bit map 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ptr
operator|=
name|qv_scn
operator|.
name|bitmap
init|;
name|i
operator|<
literal|254
condition|;
name|i
operator|+=
literal|2
operator|,
name|ptr
operator|+=
literal|2048
control|)
name|bzero
argument_list|(
name|ptr
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
comment|/* 	 * Reinitialize the scanmap 	 */
name|scan
operator|=
name|qv_scn
operator|.
name|qvaddr
operator|->
name|qv_csr
operator|&
name|QV_MEM_BANK
expr_stmt|;
name|scanline
operator|=
name|qv_scn
operator|.
name|scanmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qv_scn
operator|.
name|max_y
condition|;
name|i
operator|++
control|)
operator|*
name|scanline
operator|++
operator|=
name|scan
operator|++
expr_stmt|;
comment|/* 	 * Home the cursor 	 */
name|qv_scn
operator|.
name|row
operator|=
name|qv_scn
operator|.
name|col
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Turn it on. 	 */
name|v_getc
operator|=
name|qvgetc
expr_stmt|;
name|v_putc
operator|=
name|qvputc
expr_stmt|;
name|qvaddr
operator|->
name|qv_csr
operator||=
name|QV_CUR_MODE
operator||
name|QV_VIDEO_ENA
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Routine to display a character on the screen.  The model used is a   * glass tty.  It is assummed that the user will only use this emulation  * during system boot and that the screen will be eventually controlled  * by a window manager.  */
end_comment

begin_macro
name|qvputc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|b_row
decl_stmt|,
modifier|*
name|f_row
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|short
modifier|*
name|scanline
decl_stmt|;
name|c
operator|&=
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
comment|/* tab		*/
for|for
control|(
name|j
operator|=
literal|8
operator|-
operator|(
name|qv_scn
operator|.
name|col
operator|&
literal|0x7
operator|)
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|qvputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* return	*/
name|qv_scn
operator|.
name|col
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\010'
case|:
comment|/* backspace	*/
if|if
condition|(
operator|--
name|qv_scn
operator|.
name|col
operator|<
literal|0
condition|)
name|qv_scn
operator|.
name|col
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* linefeed	*/
if|if
condition|(
name|qv_scn
operator|.
name|row
operator|+
literal|1
operator|>=
name|qv_scn
operator|.
name|max_row
condition|)
name|qvscroll
argument_list|()
expr_stmt|;
else|else
name|qv_scn
operator|.
name|row
operator|++
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
comment|/* bell		*/
if|if
condition|(
name|qv_scn
operator|.
name|qvaddr
condition|)
name|qv_key_out
argument_list|(
name|LK_BELL_ENABLE
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
condition|)
block|{
name|scanline
operator|=
name|qv_scn
operator|.
name|scanmap
expr_stmt|;
name|b_row
operator|=
name|qv_scn
operator|.
name|bitmap
operator|+
operator|(
name|scanline
index|[
name|qv_scn
operator|.
name|row
operator|*
literal|15
index|]
operator|&
literal|0x3ff
operator|)
operator|*
literal|128
operator|+
name|qv_scn
operator|.
name|col
expr_stmt|;
name|i
operator|=
name|c
operator|-
literal|' '
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|95
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|*=
literal|15
expr_stmt|;
name|f_row
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|q_font
operator|+
name|i
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
operator|,
name|b_row
operator|+=
literal|128
operator|,
name|f_row
operator|++
control|)
operator|*
name|b_row
operator|=
operator|*
name|f_row
expr_stmt|;
if|if
condition|(
operator|++
name|qv_scn
operator|.
name|col
operator|>=
name|qv_scn
operator|.
name|max_col
condition|)
block|{
name|qv_scn
operator|.
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qv_scn
operator|.
name|row
operator|+
literal|1
operator|>=
name|qv_scn
operator|.
name|max_row
condition|)
name|qvscroll
argument_list|()
expr_stmt|;
else|else
name|qv_scn
operator|.
name|row
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* 	 * Position the cursor to the next character location. 	 */
name|qv_pos_cur
argument_list|(
name|qv_scn
operator|.
name|col
operator|*
literal|8
argument_list|,
name|qv_scn
operator|.
name|row
operator|*
literal|15
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Position the cursor to a particular spot.  */
end_comment

begin_macro
name|qv_pos_cur
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|qvdevice
modifier|*
name|qvaddr
decl_stmt|;
if|if
condition|(
name|qvaddr
operator|=
name|qv_scn
operator|.
name|qvaddr
condition|)
block|{
if|if
condition|(
name|y
operator|<
literal|0
operator|||
name|y
operator|>
name|qv_scn
operator|.
name|max_cur_y
condition|)
name|y
operator|=
name|qv_scn
operator|.
name|max_cur_y
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
name|qv_scn
operator|.
name|max_cur_x
condition|)
name|x
operator|=
name|qv_scn
operator|.
name|max_cur_x
expr_stmt|;
name|qvaddr
operator|->
name|qv_crtaddr
operator|=
literal|10
expr_stmt|;
comment|/* select cursor start reg */
name|qvaddr
operator|->
name|qv_crtdata
operator|=
name|y
operator|&
literal|0xf
expr_stmt|;
name|qvaddr
operator|->
name|qv_crtaddr
operator|=
literal|11
expr_stmt|;
comment|/* select cursor end reg */
name|qvaddr
operator|->
name|qv_crtdata
operator|=
name|y
operator|&
literal|0xf
expr_stmt|;
name|qvaddr
operator|->
name|qv_crtaddr
operator|=
literal|14
expr_stmt|;
comment|/* select cursor y pos. */
name|qvaddr
operator|->
name|qv_crtdata
operator|=
name|y
operator|>>
literal|4
expr_stmt|;
name|qvaddr
operator|->
name|qv_xcur
operator|=
name|x
expr_stmt|;
comment|/* pos x axis	*/
block|}
block|}
end_block

begin_comment
comment|/*  * Scroll the bitmap by moving the scanline map words. This could  * be done by moving the bitmap but it's much too slow for a full screen.  * The only drawback is that the scanline map must be reset when the user   * wants to do graphics.  */
end_comment

begin_macro
name|qvscroll
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|short
name|tmpscanlines
index|[
literal|15
index|]
decl_stmt|;
name|char
modifier|*
name|b_row
decl_stmt|;
name|short
modifier|*
name|scanline
decl_stmt|;
comment|/* 	 * Save the first 15 scanlines so that we can put them at 	 * the bottom when done. 	 */
name|bcopy
argument_list|(
name|qv_scn
operator|.
name|scanmap
argument_list|,
name|tmpscanlines
argument_list|,
sizeof|sizeof
name|tmpscanlines
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the wrapping line so that it won't flash on the bottom 	 * of the screen. 	 */
name|scanline
operator|=
name|qv_scn
operator|.
name|scanmap
expr_stmt|;
name|b_row
operator|=
name|qv_scn
operator|.
name|bitmap
operator|+
operator|(
operator|*
name|scanline
operator|&
literal|0x3ff
operator|)
operator|*
literal|128
expr_stmt|;
name|bzero
argument_list|(
name|b_row
argument_list|,
literal|1920
argument_list|)
expr_stmt|;
comment|/* 	 * Now move the scanlines down  	 */
name|bcopy
argument_list|(
name|qv_scn
operator|.
name|scanmap
operator|+
literal|15
argument_list|,
name|qv_scn
operator|.
name|scanmap
argument_list|,
operator|(
name|qv_scn
operator|.
name|row
operator|*
literal|15
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now put the other lines back 	 */
name|bcopy
argument_list|(
name|tmpscanlines
argument_list|,
name|qv_scn
operator|.
name|scanmap
operator|+
operator|(
name|qv_scn
operator|.
name|row
operator|*
literal|15
operator|)
argument_list|,
sizeof|sizeof
name|tmpscanlines
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * QVSS keyboard interrupt.  */
end_comment

begin_macro
name|qvgetc
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
name|struct
name|qvdevice
modifier|*
name|qvaddr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|j
decl_stmt|;
name|qvaddr
operator|=
name|qv_scn
operator|.
name|qvaddr
expr_stmt|;
comment|/* 	 * Get a character from the keyboard. 	 */
name|loop
label|:
while|while
condition|(
operator|(
name|qvaddr
operator|->
name|qv_uartstatus
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|j
operator|=
name|qvaddr
operator|->
name|qv_uartdata
operator|&
literal|0xff
expr_stmt|;
comment|/* 	 * See if its a state change key 	 */
switch|switch
condition|(
name|j
condition|)
block|{
case|case
name|LOCK
case|:
name|qv_keyboard
operator|.
name|lock
operator|^=
literal|0xffff
expr_stmt|;
comment|/* toggle */
if|if
condition|(
name|qv_keyboard
operator|.
name|lock
condition|)
name|qv_key_out
argument_list|(
name|LK_LED_ENABLE
argument_list|)
expr_stmt|;
else|else
name|qv_key_out
argument_list|(
name|LK_LED_DISABLE
argument_list|)
expr_stmt|;
name|qv_key_out
argument_list|(
name|LED_3
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|SHIFT
case|:
name|qv_keyboard
operator|.
name|shift
operator|^=
literal|0xffff
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|CNTRL
case|:
name|qv_keyboard
operator|.
name|cntrl
operator|^=
literal|0xffff
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|ALLUP
case|:
name|qv_keyboard
operator|.
name|cntrl
operator|=
name|qv_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|REPEAT
case|:
name|c
operator|=
name|qv_keyboard
operator|.
name|last
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Test for control characters. If set, see if the character 		 * is elligible to become a control character. 		 */
if|if
condition|(
name|qv_keyboard
operator|.
name|cntrl
condition|)
block|{
name|c
operator|=
name|q_key
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
condition|)
name|c
operator|&=
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qv_keyboard
operator|.
name|lock
operator|||
name|qv_keyboard
operator|.
name|shift
condition|)
name|c
operator|=
name|q_shift_key
index|[
name|j
index|]
expr_stmt|;
else|else
name|c
operator|=
name|q_key
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
name|qv_keyboard
operator|.
name|last
operator|=
name|c
expr_stmt|;
comment|/* 	 * Check for special function keys 	 */
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
return|return
literal|0
return|;
else|else
return|return
name|c
return|;
block|}
end_block

begin_comment
comment|/*  * Output to the keyboard. This routine status polls the transmitter on the  * keyboard to output a code. The timer is to avoid hanging on a bad device.  */
end_comment

begin_macro
name|qv_key_out
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|timer
init|=
literal|30000
decl_stmt|;
if|if
condition|(
name|qv_scn
operator|.
name|qvaddr
condition|)
block|{
while|while
condition|(
operator|(
name|qv_scn
operator|.
name|qvaddr
operator|->
name|qv_uartstatus
operator|&
literal|0x4
operator|)
operator|==
literal|0
operator|&&
name|timer
operator|--
condition|)
empty_stmt|;
name|qv_scn
operator|.
name|qvaddr
operator|->
name|qv_uartdata
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

end_unit

