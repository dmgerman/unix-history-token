begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * %sccs.include.redist.c%  *  *	@(#)tmscp.c	7.17 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * sccsid = "@(#)tmscp.c	1.24	(ULTRIX)	1/21/86";  */
end_comment

begin_comment
comment|/************************************************************************  *									*  *        Licensed from Digital Equipment Corporation 			*  *                       Copyright (c) 					*  *               Digital Equipment Corporation				*  *                   Maynard, Massachusetts 				*  *                         1985, 1986 					*  *                    All rights reserved. 				*  *									*  *        The Information in this software is subject to change 	*  *   without notice and should not be construed as a commitment 	*  *   by  Digital  Equipment  Corporation.   Digital   makes  no 	*  *   representations about the suitability of this software for 	*  *   any purpose.  It is supplied "As Is" without expressed  or 	*  *   implied  warranty. 						*  *									*  *        If the Regents of the University of California or its 	*  *   licensees modify the software in a manner creating  		*  *   diriviative copyright rights, appropriate copyright  		*  *   legends may be placed on  the drivative work in addition  		*  *   to that set forth above. 						*  *									*  ************************************************************************  *   * tmscp.c - TMSCP (TK50/TU81) tape device driver  *   * Modification History:  *  * 06-Jan-86 - afd  *	Changed the probe routine to use DELAY (not TODR).  This now  *	works for MicroVAXen as well.  This eliminates the busy-wait  *	for MicroVAXen so a dead TK50 controller will not hang autoconf.  *  * 06-Dec-85 - afd  *	Fixed a bug in density selection.  The "set unit characteristics"  *	command to select density, was clearing the "unit flags" field  *	where the CACHE bit was for TU81-E.  Now the unit's "format" and  *	"unitflgs" are saved in tms_info struct.  And are used on STUNT  *	commands.  *  * 19-Oct-85 - afd  *	Added support to the open routine to allow drives to be opened  *	for low density (800 or 1600 bpi) use.  When the slave routine  *	initiates a "get-unit-char" cmd, the format menu for the unit  *	is saved in the tms_info structure. The format menu is used in the  *	start routine to select the proper low density.  *  * 02-Oct-85 - afd  *	When a tmscp-type controller is initializing, it is possible for  *	the sa reg to become 0 between states.  Thus the init code in  *	the interrupt routine had to be modified to reflect this.  *  * 21-Sep-85 - afd  *	The TK50 declares a serious exception when a tape mark is encountered.  *	This causes problems to dd (& other UN*X utilities).  So a flag  *	is set in the rsp() routine when a tape mark is encountered.  If  *	this flag is set, the start() routine appends the Clear Serious  *	Exception modifier to the next command.  *  * 03-Sep-85 -- jaw  *	messed up previous edit..  *  * 29-Aug-85 - jaw  *	fixed bugs in 8200 and 750 buffered datapath handling.  *  * 06-Aug-85 - afd  *   1. When repositioning records or files, the count of items skipped  *	does NOT HAVE to be returned by controllers (& the TU81 doesn't).  *	So tmscprsp() had to be modified to stop reporting  *	residual count errors on reposition commands.  *  *   2. Fixed bug in the open routine which allowed multiple opens.  *  * 18-Jul-85 - afd  *   1. Need to return status when mt status (or corresponding ioctl) is done.  *	Save resid, flags, endcode& status in tmscprsp() routine (except on  *	clear serious exception no-op).  Return these fields when status  *	ioctl is done (in tmscpcommand()).  How they are returned:  *		mt_resid = resid  *		mt_dsreg = flags|endcode  *		mt_erreg = status  *  *   2. Added latent support for enabling/disabling caching.  This is  *	handled along with all other ioctl commands.  *  *   3. Need to issue a no-op on unrecognized ioctl in tmscpstart(), since  *	we have already commited to issuing a command at that point.  *  *   4. In tmscprsp() routine if encode is 0200 (invalid command issued);  *	We need to: Unlink the buffer from the I/O wait queue,  *	and signal iodone, so the higher level command can exit!  *	Just as if it were a valid command.  *  * 11-jul-85 -- jaw  *	fix bua/bda map registers.  *  * 19-Jun-85 -- jaw  *	VAX8200 name change.  *  * 06-Jun-85 - jaw  *	fixes for 8200.  *  * 9-Apr-85 - afd  *	Added timeout code to the probe routine, so if the controller  *	fails to init in 10 seconds we return failed status.  *  * 13-Mar-85 -jaw  *	Changes for support of the VAX8200 were merged in.  *  * 27-Feb-85 -tresvik  *	Changes for support of the VAX8600 were merged in.  *  */
end_comment

begin_include
include|#
directive|include
file|"tms.h"
end_include

begin_if
if|#
directive|if
name|NTMSCP
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"sys/systm.h"
end_include

begin_include
include|#
directive|include
file|"sys/buf.h"
end_include

begin_include
include|#
directive|include
file|"sys/conf.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"sys/file.h"
end_include

begin_include
include|#
directive|include
file|"sys/map.h"
end_include

begin_include
include|#
directive|include
file|"sys/vm.h"
end_include

begin_include
include|#
directive|include
file|"sys/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"sys/syslog.h"
end_include

begin_include
include|#
directive|include
file|"sys/mtio.h"
end_include

begin_include
include|#
directive|include
file|"sys/cmap.h"
end_include

begin_include
include|#
directive|include
file|"sys/uio.h"
end_include

begin_include
include|#
directive|include
file|"sys/tprintf.h"
end_include

begin_include
include|#
directive|include
file|"../include/pte.h"
end_include

begin_include
include|#
directive|include
file|"../include/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../include/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"ubareg.h"
end_include

begin_include
include|#
directive|include
file|"ubavar.h"
end_include

begin_define
define|#
directive|define
name|TENSEC
value|(1000)
end_define

begin_define
define|#
directive|define
name|TMS_PRI
value|LOG_INFO
end_define

begin_define
define|#
directive|define
name|NRSPL2
value|3
end_define

begin_comment
comment|/* log2 number of response packets */
end_comment

begin_define
define|#
directive|define
name|NCMDL2
value|3
end_define

begin_comment
comment|/* log2 number of command packets */
end_comment

begin_define
define|#
directive|define
name|NRSP
value|(1<<NRSPL2)
end_define

begin_define
define|#
directive|define
name|NCMD
value|(1<<NCMDL2)
end_define

begin_include
include|#
directive|include
file|"tmscpreg.h"
end_include

begin_include
include|#
directive|include
file|"../vax/tmscp.h"
end_include

begin_comment
comment|/* Software state per controller */
end_comment

begin_struct
struct|struct
name|tmscp_softc
block|{
name|short
name|sc_state
decl_stmt|;
comment|/* state of controller */
name|short
name|sc_mapped
decl_stmt|;
comment|/* Unibus map allocated for tmscp struct? */
name|int
name|sc_ubainfo
decl_stmt|;
comment|/* Unibus mapping info */
name|struct
name|tmscp
modifier|*
name|sc_tmscp
decl_stmt|;
comment|/* Unibus address of tmscp struct */
name|int
name|sc_ivec
decl_stmt|;
comment|/* interrupt vector address */
name|short
name|sc_credits
decl_stmt|;
comment|/* transfer credits */
name|short
name|sc_lastcmd
decl_stmt|;
comment|/* pointer into command ring */
name|short
name|sc_lastrsp
decl_stmt|;
comment|/* pointer into response ring */
name|short
name|sc_ipl
decl_stmt|;
comment|/* interrupt priority (Q-bus) */
block|}
name|tmscp_softc
index|[
name|NTMSCP
index|]
struct|;
end_struct

begin_struct
struct|struct
name|tmscp
block|{
name|struct
name|tmscpca
name|tmscp_ca
decl_stmt|;
comment|/* communications area */
name|struct
name|mscp
name|tmscp_rsp
index|[
name|NRSP
index|]
decl_stmt|;
comment|/* response packets */
name|struct
name|mscp
name|tmscp_cmd
index|[
name|NCMD
index|]
decl_stmt|;
comment|/* command packets */
block|}
name|tmscp
index|[
name|NTMSCP
index|]
struct|;
end_struct

begin_comment
comment|/*  * Per drive-unit info  */
end_comment

begin_struct
struct|struct
name|tms_info
block|{
name|daddr_t
name|tms_dsize
decl_stmt|;
comment|/* Max user size from online pkt */
name|unsigned
name|tms_type
decl_stmt|;
comment|/* Drive type int field  */
name|int
name|tms_resid
decl_stmt|;
comment|/* residual from last xfer */
name|u_char
name|tms_endcode
decl_stmt|;
comment|/* last command endcode */
name|u_char
name|tms_flags
decl_stmt|;
comment|/* last command end flags */
name|unsigned
name|tms_status
decl_stmt|;
comment|/* Command status from last command */
name|char
name|tms_openf
decl_stmt|;
comment|/* lock against multiple opens */
name|char
name|tms_lastiow
decl_stmt|;
comment|/* last op was a write */
name|char
name|tms_serex
decl_stmt|;
comment|/* set when serious exception occurs */
name|char
name|tms_clserex
decl_stmt|;
comment|/* set when serex being cleared by no-op */
name|short
name|tms_fmtmenu
decl_stmt|;
comment|/* the unit's format (density) menu */
name|short
name|tms_unitflgs
decl_stmt|;
comment|/* unit flag parameters */
name|short
name|tms_format
decl_stmt|;
comment|/* the unit's current format (density) */
name|tpr_t
name|tms_tpr
decl_stmt|;
comment|/* tprintf handle */
block|}
name|tms_info
index|[
name|NTMS
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|uba_ctlr
modifier|*
name|tmscpminfo
index|[
name|NTMSCP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|tmsdinfo
index|[
name|NTMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * ifdef other tmscp devices here if they allow more than 1 unit/controller  */
end_comment

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|tmscpip
index|[
name|NTMSCP
index|]
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|ctmscpbuf
index|[
name|NTMSCP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal cmd buffer (for ioctls) */
end_comment

begin_decl_stmt
name|struct
name|buf
name|tmsutab
index|[
name|NTMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Drive queue */
end_comment

begin_decl_stmt
name|struct
name|buf
name|tmscpwtab
index|[
name|NTMSCP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O wait queue, per controller */
end_comment

begin_decl_stmt
name|int
name|tmscpmicro
index|[
name|NTMSCP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to store microcode level */
end_comment

begin_decl_stmt
name|short
name|utoctlr
index|[
name|NTMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Slave unit to controller mapping */
end_comment

begin_comment
comment|/* filled in by the slave routine */
end_comment

begin_comment
comment|/* Bits in minor device */
end_comment

begin_define
define|#
directive|define
name|TMSUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)&03)
end_define

begin_define
define|#
directive|define
name|T_NOREWIND
value|04
end_define

begin_define
define|#
directive|define
name|T_HIDENSITY
value|010
end_define

begin_comment
comment|/* Slave unit to controller mapping */
end_comment

begin_define
define|#
directive|define
name|TMSCPCTLR
parameter_list|(
name|dev
parameter_list|)
value|(utoctlr[TMSUNIT(dev)])
end_define

begin_comment
comment|/*  * Internal (ioctl) command codes (these must also be declared in the  * tmscpioctl routine).  These correspond to ioctls in mtio.h  */
end_comment

begin_define
define|#
directive|define
name|TMS_WRITM
value|0
end_define

begin_comment
comment|/* write tape mark */
end_comment

begin_define
define|#
directive|define
name|TMS_FSF
value|1
end_define

begin_comment
comment|/* forward space file */
end_comment

begin_define
define|#
directive|define
name|TMS_BSF
value|2
end_define

begin_comment
comment|/* backward space file */
end_comment

begin_define
define|#
directive|define
name|TMS_FSR
value|3
end_define

begin_comment
comment|/* forward space record */
end_comment

begin_define
define|#
directive|define
name|TMS_BSR
value|4
end_define

begin_comment
comment|/* backward space record */
end_comment

begin_define
define|#
directive|define
name|TMS_REW
value|5
end_define

begin_comment
comment|/* rewind tape */
end_comment

begin_define
define|#
directive|define
name|TMS_OFFL
value|6
end_define

begin_comment
comment|/* rewind tape& mark unit offline */
end_comment

begin_define
define|#
directive|define
name|TMS_SENSE
value|7
end_define

begin_comment
comment|/* noop - do a get unit status */
end_comment

begin_define
define|#
directive|define
name|TMS_CACHE
value|8
end_define

begin_comment
comment|/* enable cache */
end_comment

begin_define
define|#
directive|define
name|TMS_NOCACHE
value|9
end_define

begin_comment
comment|/* disable cache */
end_comment

begin_comment
comment|/* These go last: after all real mt cmds, just bump the numbers up */
end_comment

begin_define
define|#
directive|define
name|TMS_CSE
value|10
end_define

begin_comment
comment|/* clear serious exception */
end_comment

begin_define
define|#
directive|define
name|TMS_LOWDENSITY
value|11
end_define

begin_comment
comment|/* set unit to low density */
end_comment

begin_define
define|#
directive|define
name|TMS_HIDENSITY
value|12
end_define

begin_comment
comment|/* set unit to high density */
end_comment

begin_comment
comment|/*  * Controller states  */
end_comment

begin_define
define|#
directive|define
name|S_IDLE
value|0
end_define

begin_comment
comment|/* hasn't been initialized */
end_comment

begin_define
define|#
directive|define
name|S_STEP1
value|1
end_define

begin_comment
comment|/* doing step 1 init */
end_comment

begin_define
define|#
directive|define
name|S_STEP2
value|2
end_define

begin_comment
comment|/* doing step 2 init */
end_comment

begin_define
define|#
directive|define
name|S_STEP3
value|3
end_define

begin_comment
comment|/* doing step 3 init */
end_comment

begin_define
define|#
directive|define
name|S_SCHAR
value|4
end_define

begin_comment
comment|/* doing "set controller characteristics" */
end_comment

begin_define
define|#
directive|define
name|S_RUN
value|5
end_define

begin_comment
comment|/* running */
end_comment

begin_decl_stmt
name|int
name|tmscperror
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* causes hex dump of packets */
end_comment

begin_decl_stmt
name|int
name|tmscp_cp_wait
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Something to wait on for command */
end_comment

begin_comment
comment|/* packets and or credits. */
end_comment

begin_function_decl
name|int
name|wakeup
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should find the right include */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|printd
value|if (tmscpdebug) printf
end_define

begin_decl_stmt
name|int
name|tmscpdebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|printd10
value|if(tmscpdebug>= 10) printf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|tmscpprobe
argument_list|()
decl_stmt|,
name|tmscpslave
argument_list|()
decl_stmt|,
name|tmscpattach
argument_list|()
decl_stmt|,
name|tmscpintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|mscp
modifier|*
name|tmscpgetcp
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DRVNAME
value|"tms"
end_define

begin_define
define|#
directive|define
name|CTRLNAME
value|"tmscp"
end_define

begin_decl_stmt
name|u_short
name|tmscpstd
index|[]
init|=
block|{
literal|0174500
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|tmscpdriver
init|=
block|{
name|tmscpprobe
block|,
name|tmscpslave
block|,
name|tmscpattach
block|,
literal|0
block|,
name|tmscpstd
block|,
name|DRVNAME
block|,
name|tmsdinfo
block|,
name|CTRLNAME
block|,
name|tmscpminfo
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|b_qsize
value|b_resid
end_define

begin_comment
comment|/* queue size per drive, in tmsutab */
end_comment

begin_define
define|#
directive|define
name|b_ubinfo
value|b_resid
end_define

begin_comment
comment|/* Unibus mapping info, per buffer */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_define
define|#
directive|define
name|DELAYTEN
value|1000
end_define

begin_comment
comment|/*  * Unfortunately qbgetpri can't be used because the TK50 doesn't flip the  * TMSCP_STEP2 flag in the tmscpsa register until after the pending interrupt  * has been acknowledged by the cpu. If you are at spl6(), the TMSCP_STEP2  * flag never gets set and you return (0).  */
end_comment

begin_macro
name|tmscpprobe
argument_list|(
argument|reg
argument_list|,
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of the IP register */
end_comment

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of controller in the tmscp_softc array */
end_comment

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* MUST be 1st (r11& r10): IPL and intr vec */
specifier|register
name|struct
name|tmscp_softc
modifier|*
name|sc
init|=
operator|&
name|tmscp_softc
index|[
name|ctlr
index|]
decl_stmt|;
comment|/* ptr to software controller structure */
name|struct
name|tmscpdevice
modifier|*
name|tmscpaddr
decl_stmt|;
comment|/* ptr to tmscpdevice struct (IP& SA) */
name|int
name|count
decl_stmt|;
comment|/* for probe delay time out */
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|reg
operator|=
name|reg
expr_stmt|;
name|tmscpreset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tmscpintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmscpaddr
operator|=
operator|(
expr|struct
name|tmscpdevice
operator|*
operator|)
name|reg
expr_stmt|;
comment|/*  	 * Set host-settable interrupt vector. 	 * Assign 0 to the ip register to start the tmscp-device initialization. 	 * The device is not really initialized at this point, this is just to 	 * find out if the device exists. 	 */
name|sc
operator|->
name|sc_ivec
operator|=
operator|(
name|uba_hd
index|[
name|numuba
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|)
expr_stmt|;
name|tmscpaddr
operator|->
name|tmscpip
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|DELAYTEN
condition|)
block|{
comment|/* wait for at most 10 secs */
if|if
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_STEP1
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|DELAYTEN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
name|TMSCP_ERR
operator||
operator|(
name|NCMDL2
operator|<<
literal|11
operator|)
operator||
operator|(
name|NRSPL2
operator|<<
literal|8
operator|)
operator||
name|TMSCP_IE
operator||
operator|(
name|sc
operator|->
name|sc_ivec
operator|/
literal|4
operator|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|DELAYTEN
condition|)
block|{
if|if
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_STEP2
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|DELAYTEN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|QBA
name|sc
operator|->
name|sc_ipl
operator|=
name|br
operator|=
literal|0x15
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tmscpdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Try to find a slave (a drive) on the controller.  * If the controller is not in the run state, call init to initialize it.  */
end_comment

begin_macro
name|tmscpslave
argument_list|(
argument|ui
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to the uba device structure */
end_comment

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* addr of the device controller */
end_comment

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|tmscpminfo
index|[
name|ui
operator|->
name|ui_ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|tmscp_softc
modifier|*
name|sc
init|=
operator|&
name|tmscp_softc
index|[
name|ui
operator|->
name|ui_ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|tms_info
modifier|*
name|tms
init|=
operator|&
name|tms_info
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|struct
name|tmscpdevice
modifier|*
name|tmscpaddr
decl_stmt|;
comment|/* ptr to IP& SA */
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Something to write into to start */
comment|/* the tmscp polling */
ifdef|#
directive|ifdef
name|lint
name|reg
operator|=
name|reg
expr_stmt|;
endif|#
directive|endif
name|tmscpaddr
operator|=
operator|(
expr|struct
name|tmscpdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
comment|/*  	 * If its not in the run state, start the initialization process 	 * (tmscpintr will complete it);  if the initialization doesn't start; 	 * then return. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|S_RUN
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpslave: ctlr not running: calling init \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|tmscpinit
argument_list|(
name|ui
operator|->
name|ui_ctlr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Wait for the controller to come into the run state or go idle. 	 * If it goes idle return. 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|i
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|S_RUN
operator|&&
name|sc
operator|->
name|sc_state
operator|!=
name|S_IDLE
condition|)
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
operator|&&
name|i
condition|)
block|{
name|printd
argument_list|(
literal|"tmscp-device: fatal error (%o)\n"
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
empty_stmt|;
comment|/* wait */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_IDLE
condition|)
block|{
comment|/* The tmscp device failed to initialize */
name|printf
argument_list|(
literal|"tmscp controller failed to init\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* The controller is up so see if the drive is there */
if|if
condition|(
literal|0
operator|==
operator|(
name|mp
operator|=
name|tmscpgetcp
argument_list|(
name|um
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"tmscp can't get command packet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Need to determine the drive type for generic driver */
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_GTUNT
expr_stmt|;
comment|/* This should give us the device type */
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|mp
operator|->
name|mscp_cmdref
operator|=
operator|(
name|long
operator|)
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|tms
operator|->
name|tms_status
operator|=
literal|0
expr_stmt|;
comment|/* set to zero */
name|tmscpip
index|[
name|ui
operator|->
name|ui_ctlr
index|]
index|[
name|ui
operator|->
name|ui_slave
index|]
operator|=
name|ui
expr_stmt|;
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|mp
operator|->
name|mscp_dscptr
operator|)
operator||=
name|TMSCP_OWN
operator||
name|TMSCP_INT
expr_stmt|;
comment|/* maybe we should poll*/
name|i
operator|=
name|tmscpaddr
operator|->
name|tmscpip
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|i
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|tms
operator|->
name|tms_status
condition|)
empty_stmt|;
comment|/* Wait for some status */
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpslave: status = %o\n"
argument_list|,
name|tms
operator|->
name|tms_status
operator|&
name|M_ST_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmscpip
index|[
name|ui
operator|->
name|ui_ctlr
index|]
index|[
name|ui
operator|->
name|ui_slave
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|tms
operator|->
name|tms_type
condition|)
comment|/* packet from a GTUNT */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Failed No such drive */
else|else
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Got it and it is there */
block|}
end_block

begin_comment
comment|/*   * Set ui flags to zero to show device is not online& set tmscpip.  * Unit to Controller mapping is set up here.  * Open routine will issue the online command, later.  */
end_comment

begin_expr_stmt
name|tmscpattach
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ptr to unibus dev struct */
end_comment

begin_block
block|{
name|ui
operator|->
name|ui_flags
operator|=
literal|0
expr_stmt|;
name|tmscpip
index|[
name|ui
operator|->
name|ui_ctlr
index|]
index|[
name|ui
operator|->
name|ui_slave
index|]
operator|=
name|ui
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*  	 * Check to see if the drive is available. 	 * If not then just print debug. 	 */
if|if
condition|(
name|tms_info
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|tms_status
operator|!=
name|M_ST_AVLBL
condition|)
name|printd
argument_list|(
literal|"tmscpattach: unavailable \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|utoctlr
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|=
name|ui
operator|->
name|ui_ctlr
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * TMSCP interrupt routine.  */
end_comment

begin_macro
name|tmscpintr
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index to the controller */
end_comment

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
init|=
name|tmscpminfo
index|[
name|d
index|]
decl_stmt|;
specifier|register
name|struct
name|tmscpdevice
modifier|*
name|tmscpaddr
init|=
operator|(
expr|struct
name|tmscpdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|tmscp_softc
modifier|*
name|sc
init|=
operator|&
name|tmscp_softc
index|[
name|d
index|]
decl_stmt|;
specifier|register
name|struct
name|tmscp
modifier|*
name|tm
init|=
operator|&
name|tmscp
index|[
name|d
index|]
decl_stmt|;
name|struct
name|tmscp
modifier|*
name|ttm
decl_stmt|;
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd10
argument_list|(
literal|"tmscpintr: state %d, tmscpsa %o\n"
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QBA
name|splx
argument_list|(
name|sc
operator|->
name|sc_ipl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * How the interrupt is handled depends on the state of the controller. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|S_IDLE
case|:
name|printf
argument_list|(
literal|"tmscp%d: random interrupt ignored\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return;
comment|/* Controller was in step 1 last, see if its gone to step 2 */
case|case
name|S_STEP1
case|:
define|#
directive|define
name|STEP1MASK
value|0174377
define|#
directive|define
name|STEP1GOOD
value|(TMSCP_STEP2|TMSCP_IE|(NCMDL2<<3)|NRSPL2)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|150
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|STEP1MASK
operator|)
operator|!=
name|STEP1GOOD
condition|)
block|{
comment|/* still in step 1 (wait 1/100 sec) */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"still in step 1, delaying\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|149
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
name|printf
argument_list|(
literal|"failed to initialize, in step1: sa 0x%x"
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|um
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
operator|(
operator|(
name|int
operator|)
operator|&
name|sc
operator|->
name|sc_tmscp
operator|->
name|tmscp_ca
operator|.
name|ca_ringbase
operator|)
operator||
operator|(
operator|(
name|cpu
operator|==
name|VAX_780
operator|||
name|cpu
operator|==
name|VAX_8600
operator|)
condition|?
name|TMSCP_PI
else|:
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_STEP2
expr_stmt|;
return|return;
comment|/* Controller was in step 2 last, see if its gone to step 3 */
case|case
name|S_STEP2
case|:
define|#
directive|define
name|STEP2MASK
value|0174377
define|#
directive|define
name|STEP2GOOD
value|(TMSCP_STEP3|TMSCP_IE|(sc->sc_ivec/4))
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|150
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|STEP2MASK
operator|)
operator|!=
name|STEP2GOOD
condition|)
block|{
comment|/* still in step 2 (wait 1/100 sec) */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"still in step 2, delaying\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|149
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
name|printf
argument_list|(
literal|"failed to initialize, in step2: sa 0x%x"
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|um
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
operator|(
operator|(
name|int
operator|)
operator|&
name|sc
operator|->
name|sc_tmscp
operator|->
name|tmscp_ca
operator|.
name|ca_ringbase
operator|)
operator|>>
literal|16
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_STEP3
expr_stmt|;
return|return;
comment|/* Controller was in step 3 last, see if its gone to step 4 */
case|case
name|S_STEP3
case|:
define|#
directive|define
name|STEP3MASK
value|0174000
define|#
directive|define
name|STEP3GOOD
value|TMSCP_STEP4
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|150
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|STEP3MASK
operator|)
operator|!=
name|STEP3GOOD
condition|)
block|{
comment|/* still in step 3 (wait 1/100 sec) */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"still in step 3, delaying\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|149
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
name|printf
argument_list|(
literal|"failed to initialize, in step3: sa 0x%x"
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|um
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Get microcode version and model number of controller; 		 * Signal initialization complete (_GO) (to the controller); 		 *    ask for Last Fail response if tmscperror is set; 		 * Set state to "set controller characteristics". 		 */
name|tmscpmicro
index|[
name|d
index|]
operator|=
name|tmscpaddr
operator|->
name|tmscpsa
expr_stmt|;
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
name|TMSCP_GO
operator||
operator|(
name|tmscperror
condition|?
name|TMSCP_LF
else|:
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|S_SCHAR
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpintr: completed state %d \n"
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
name|printd
argument_list|(
literal|"tmscp%d Version %d model %d\n"
argument_list|,
name|d
argument_list|,
name|tmscpmicro
index|[
name|d
index|]
operator|&
literal|0xF
argument_list|,
operator|(
name|tmscpmicro
index|[
name|d
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	     * Initialize the data structures (response and command queues). 	     */
name|ttm
operator|=
name|sc
operator|->
name|sc_tmscp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRSP
condition|;
name|i
operator|++
control|)
block|{
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
operator|=
name|TMSCP_OWN
operator||
name|TMSCP_INT
operator||
operator|(
name|long
operator|)
operator|&
name|ttm
operator|->
name|tmscp_rsp
index|[
name|i
index|]
operator|.
name|mscp_cmdref
expr_stmt|;
name|tm
operator|->
name|tmscp_rsp
index|[
name|i
index|]
operator|.
name|mscp_dscptr
operator|=
operator|&
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
expr_stmt|;
name|tm
operator|->
name|tmscp_rsp
index|[
name|i
index|]
operator|.
name|mscp_header
operator|.
name|tmscp_msglen
operator|=
name|mscp_msglen
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCMD
condition|;
name|i
operator|++
control|)
block|{
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_cmddsc
index|[
name|i
index|]
operator|=
name|TMSCP_INT
operator||
operator|(
name|long
operator|)
operator|&
name|ttm
operator|->
name|tmscp_cmd
index|[
name|i
index|]
operator|.
name|mscp_cmdref
expr_stmt|;
name|tm
operator|->
name|tmscp_cmd
index|[
name|i
index|]
operator|.
name|mscp_dscptr
operator|=
operator|&
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_cmddsc
index|[
name|i
index|]
expr_stmt|;
name|tm
operator|->
name|tmscp_cmd
index|[
name|i
index|]
operator|.
name|mscp_header
operator|.
name|tmscp_msglen
operator|=
name|mscp_msglen
expr_stmt|;
name|tm
operator|->
name|tmscp_cmd
index|[
name|i
index|]
operator|.
name|mscp_header
operator|.
name|tmscp_vcid
operator|=
literal|1
expr_stmt|;
block|}
name|bp
operator|=
operator|&
name|tmscpwtab
index|[
name|d
index|]
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|bp
operator|->
name|av_back
operator|=
name|bp
expr_stmt|;
name|sc
operator|->
name|sc_lastcmd
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_lastrsp
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|tmscp
index|[
name|um
operator|->
name|um_ctlr
index|]
operator|.
name|tmscp_cmd
index|[
literal|0
index|]
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|mp
operator|->
name|mscp_modifier
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_flags
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_version
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_cntflgs
operator|=
name|M_CF_ATTN
operator||
name|M_CF_MISC
operator||
name|M_CF_THIS
expr_stmt|;
comment|/* 	     * A host time out value of 0 means that the controller will not 	     * time out.  This is ok for the TK50. 	     */
name|mp
operator|->
name|mscp_hsttmo
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_time
operator|.
name|val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_time
operator|.
name|val
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_cntdep
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_STCON
expr_stmt|;
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|mp
operator|->
name|mscp_dscptr
operator|)
operator||=
name|TMSCP_OWN
operator||
name|TMSCP_INT
expr_stmt|;
name|i
operator|=
name|tmscpaddr
operator|->
name|tmscpip
expr_stmt|;
comment|/* initiate polling */
return|return;
case|case
name|S_SCHAR
case|:
case|case
name|S_RUN
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"tmscp%d: interrupt in unknown state %d ignored\n"
argument_list|,
name|d
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* end switch */
comment|/* 	 * The controller state is S_SCHAR or S_RUN 	 */
comment|/* 	 * If the error bit is set in the SA register then print an error 	 * message and reinitialize the controller. 	 */
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"tmscp%d: fatal error (%o)\n"
argument_list|,
name|d
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|tmscpaddr
operator|->
name|tmscpip
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|um
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for a buffer purge request. (Won't happen w/ TK50 on Q22 bus) 	 */
if|if
condition|(
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_bdp
condition|)
block|{
name|UBAPURGE
argument_list|(
name|um
operator|->
name|um_hd
operator|->
name|uh_uba
argument_list|,
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_bdp
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_bdp
operator|=
literal|0
expr_stmt|;
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
literal|0
expr_stmt|;
comment|/* signal purge complete */
block|}
comment|/* 	 * Check for response ring transition. 	 */
if|if
condition|(
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_rspint
condition|)
block|{
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_rspint
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|sc_lastrsp
init|;
condition|;
name|i
operator|++
control|)
block|{
name|i
operator|%=
name|NRSP
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
operator|&
name|TMSCP_OWN
condition|)
break|break;
name|tmscprsp
argument_list|(
name|um
argument_list|,
name|tm
argument_list|,
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
operator||=
name|TMSCP_OWN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_lastrsp
operator|=
name|i
expr_stmt|;
block|}
comment|/* 	 * Check for command ring transition. 	 */
if|if
condition|(
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_cmdint
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpintr: command ring transition\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_cmdint
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tmscp_cp_wait
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tmscp_cp_wait
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tmscpstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Open a tmscp device and set the unit online.  If the controller is not   * in the run state, call init to initialize the tmscp controller first.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|tmscpopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|tmscp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|tms_info
modifier|*
name|tms
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
name|struct
name|tmscpdevice
modifier|*
name|tmscpaddr
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|unit
operator|=
name|TMSUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpopen unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmscpdebug
condition|)
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unit
operator|>=
name|NTMS
operator|||
operator|(
name|ui
operator|=
name|tmsdinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tms
operator|=
operator|&
name|tms_info
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
if|if
condition|(
name|tms
operator|->
name|tms_openf
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|=
operator|&
name|tmscp_softc
index|[
name|ui
operator|->
name|ui_ctlr
index|]
expr_stmt|;
name|tms
operator|->
name|tms_openf
operator|=
literal|1
expr_stmt|;
name|tms
operator|->
name|tms_tpr
operator|=
name|tprintf_open
argument_list|()
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|S_RUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|S_IDLE
condition|)
if|if
condition|(
operator|!
name|tmscpinit
argument_list|(
name|ui
operator|->
name|ui_ctlr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tmscp controller failed to init\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tms
operator|->
name|tms_openf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*  		 * Wait for initialization to complete 		 */
name|timeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
name|ui
operator|->
name|ui_mi
argument_list|,
literal|11
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* to be sure*/
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ui
operator|->
name|ui_mi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|S_RUN
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tms
operator|->
name|tms_openf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
comment|/* 	 * Check to see if the device is really there. 	 * this code was taken from Fred Canters 11 driver 	 */
name|um
operator|=
name|ui
operator|->
name|ui_mi
expr_stmt|;
name|tmscpaddr
operator|=
operator|(
expr|struct
name|tmscpdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_flags
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
while|while
condition|(
literal|0
operator|==
operator|(
name|mp
operator|=
name|tmscpgetcp
argument_list|(
name|um
argument_list|)
operator|)
condition|)
block|{
name|tmscp_cp_wait
operator|++
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tmscp_cp_wait
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmscp_cp_wait
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_ONLIN
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|mp
operator|->
name|mscp_cmdref
operator|=
operator|(
name|long
operator|)
operator|&
name|tms
operator|->
name|tms_type
expr_stmt|;
comment|/* need to sleep on something */
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpopen: bring unit %d online\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|mp
operator|->
name|mscp_dscptr
operator|)
operator||=
name|TMSCP_OWN
operator||
name|TMSCP_INT
expr_stmt|;
name|i
operator|=
name|tmscpaddr
operator|->
name|tmscpip
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|i
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/*  		 * To make sure we wake up, timeout in 240 seconds. 		 * Wakeup in tmscprsp routine. 		 * 240 seconds (4 minutes) is necessary since a rewind 		 * can take a few minutes. 		 */
name|timeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mscp_cmdref
argument_list|,
literal|240
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mscp_cmdref
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ui
operator|->
name|ui_flags
operator|==
literal|0
condition|)
block|{
name|tms
operator|->
name|tms_openf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Didn't go online */
block|}
name|tms
operator|->
name|tms_lastiow
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the high density device is not specified, set unit to low 	 * density.  This is done as an "internal" ioctl command so 	 * that the command setup and response handling 	 * is done thru "regular" command routines. 	 */
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_HIDENSITY
operator|)
operator|==
literal|0
condition|)
name|tmscpcommand
argument_list|(
name|dev
argument_list|,
name|TMS_LOWDENSITY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|tmscpcommand
argument_list|(
name|dev
argument_list|,
name|TMS_HIDENSITY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Close tape device.  *  * If tape was open for writing or last operation was  * a write, then write two EOF's and backspace over the last one.  * Unless this is a non-rewinding special file, rewind the tape.  *  * NOTE:  *	We want to be sure that any serious exception is cleared on the  *	close. A Clear Serious Exception (CSE) modifier is always done on  *	the rewind command.  For the non-rewind case we check to see if the  *	"serex" field is set in the softc struct; if it is then issue a noop  *	command with the CSE modifier.  * Make the tape available to others, by clearing openf flag.  */
end_comment

begin_expr_stmt
name|tmscpclose
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|flag
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tms_info
modifier|*
name|tms
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|ui
operator|=
name|tmsdinfo
index|[
name|TMSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpclose: ctlr =  %d\n"
argument_list|,
name|TMSCPCTLR
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|printd
argument_list|(
literal|"tmscpclose: unit = %d\n"
argument_list|,
name|TMSUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmscpdebug
condition|)
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tms
operator|=
operator|&
name|tms_info
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|FWRITE
operator|||
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
name|tms
operator|->
name|tms_lastiow
condition|)
block|{
comment|/*	   device, command, count */
name|tmscpcommand
argument_list|(
name|dev
argument_list|,
name|TMS_WRITM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmscpcommand
argument_list|(
name|dev
argument_list|,
name|TMS_WRITM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmscpcommand
argument_list|(
name|dev
argument_list|,
name|TMS_BSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
operator|)
operator|==
literal|0
condition|)
comment|/* 		 * Don't hang waiting for rewind complete. 		 */
name|tmscpcommand
argument_list|(
name|dev
argument_list|,
name|TMS_REW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tms
operator|->
name|tms_serex
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpclose: clearing serex\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmscpdebug
condition|)
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmscpcommand
argument_list|(
name|dev
argument_list|,
name|TMS_CSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|tprintf_close
argument_list|(
name|tms
operator|->
name|tms_tpr
argument_list|)
expr_stmt|;
name|tms
operator|->
name|tms_openf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Execute a command on the tape drive a specified number of times.  * This routine sets up a buffer and calls the strategy routine which  * links the buffer onto the drive's buffer queue.  * The start routine will take care of creating a tmscp command packet  * with the command.  The start routine is called by the strategy or the  * interrupt routine.  */
end_comment

begin_expr_stmt
name|tmscpcommand
argument_list|(
name|dev
argument_list|,
name|com
argument_list|,
name|count
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|com
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|unit
init|=
name|TMSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ui
operator|=
name|tmsdinfo
index|[
name|unit
index|]
expr_stmt|;
name|bp
operator|=
operator|&
name|ctmscpbuf
index|[
name|ui
operator|->
name|ui_ctlr
index|]
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
comment|/* 		 * This special check is because B_BUSY never 		 * gets cleared in the non-waiting rewind case. 		 */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
condition|)
break|break;
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Load the buffer.  The b_count field gets used to hold the command 	 * count.  the b_resid field gets used to hold the command mneumonic. 	 * These 2 fields are "known" to be "safe" to use for this purpose. 	 * (Most other drivers also use these fields in this way.) 	 */
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|count
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|com
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|tmscpstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * In case of rewind from close, don't wait. 	 * This is the only case where count can be 0. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
name|B_ERROR
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Find an unused command packet  */
end_comment

begin_function
name|struct
name|mscp
modifier|*
name|tmscpgetcp
parameter_list|(
name|um
parameter_list|)
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
block|{
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|tmscpca
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|tmscp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|tmscp
index|[
name|um
operator|->
name|um_ctlr
index|]
operator|.
name|tmscp_ca
expr_stmt|;
name|sc
operator|=
operator|&
name|tmscp_softc
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
comment|/* 	 * If no credits, can't issue any commands 	 * until some outstanding commands complete. 	 */
name|i
operator|=
name|sc
operator|->
name|sc_lastcmd
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd10
argument_list|(
literal|"tmscpgetcp: %d credits remain\n"
argument_list|,
name|sc
operator|->
name|sc_credits
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|cp
operator|->
name|ca_cmddsc
index|[
name|i
index|]
operator|&
operator|(
name|TMSCP_OWN
operator||
name|TMSCP_INT
operator|)
operator|)
operator|==
name|TMSCP_INT
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_credits
operator|>=
literal|2
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_credits
operator|--
expr_stmt|;
comment|/* This commits to issuing a command */
name|cp
operator|->
name|ca_cmddsc
index|[
name|i
index|]
operator|&=
operator|~
name|TMSCP_INT
expr_stmt|;
name|mp
operator|=
operator|&
name|tmscp
index|[
name|um
operator|->
name|um_ctlr
index|]
operator|.
name|tmscp_cmd
index|[
name|i
index|]
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|mp
operator|->
name|mscp_modifier
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_opcode
operator|=
name|mp
operator|->
name|mscp_flags
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_bytecnt
operator|=
name|mp
operator|->
name|mscp_buffer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_lastcmd
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|NCMD
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mp
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a TMSCP device.  Set up UBA mapping registers,  * initialize data structures, and start hardware  * initialization sequence.  */
end_comment

begin_macro
name|tmscpinit
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index to the controller */
end_comment

begin_block
block|{
specifier|register
name|struct
name|tmscp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|tmscp
modifier|*
name|t
decl_stmt|;
comment|/* communications area; cmd& resp packets */
name|struct
name|tmscpdevice
modifier|*
name|tmscpaddr
decl_stmt|;
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
name|sc
operator|=
operator|&
name|tmscp_softc
index|[
name|d
index|]
expr_stmt|;
name|um
operator|=
name|tmscpminfo
index|[
name|d
index|]
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|++
expr_stmt|;
name|t
operator|=
operator|&
name|tmscp
index|[
name|d
index|]
expr_stmt|;
name|tmscpaddr
operator|=
operator|(
expr|struct
name|tmscpdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mapped
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Map the communications area and command 		 * and response packets into Unibus address 		 * space. 		 */
name|sc
operator|->
name|sc_ubainfo
operator|=
name|uballoc
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
name|t
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tmscp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tmscp
operator|=
operator|(
expr|struct
name|tmscp
operator|*
operator|)
operator|(
name|UBAI_ADDR
argument_list|(
name|sc
operator|->
name|sc_ubainfo
argument_list|)
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_mapped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Start the hardware initialization sequence. 	 */
name|tmscpaddr
operator|->
name|tmscpip
operator|=
literal|0
expr_stmt|;
comment|/* start initialization */
while|while
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_STEP1
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpinit: tmscpsa = 0%o\n"
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* CHECK */
block|}
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
name|TMSCP_ERR
operator||
operator|(
name|NCMDL2
operator|<<
literal|11
operator|)
operator||
operator|(
name|NRSPL2
operator|<<
literal|8
operator|)
operator||
name|TMSCP_IE
operator||
operator|(
name|sc
operator|->
name|sc_ivec
operator|/
literal|4
operator|)
expr_stmt|;
comment|/* 	 * Initialization continues in the interrupt routine. 	 */
name|sc
operator|->
name|sc_state
operator|=
name|S_STEP1
expr_stmt|;
name|sc
operator|->
name|sc_credits
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Start I/O operation  * This code is convoluted.  The majority of it was copied from the uda driver.  */
end_comment

begin_expr_stmt
name|tmscpstart
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|tmscp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|tms_info
modifier|*
name|tms
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|tmscpdevice
modifier|*
name|tmscpaddr
decl_stmt|;
name|struct
name|tmscp
modifier|*
name|tm
init|=
operator|&
name|tmscp
index|[
name|um
operator|->
name|um_ctlr
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tempi
decl_stmt|;
name|char
name|ioctl
decl_stmt|;
comment|/* flag: set true if its an IOCTL command */
name|sc
operator|=
operator|&
name|tmscp_softc
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Release unneeded UBA resources and return 		 * (drive was inactive) 		 */
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No more requests for this drive, remove 		 * from controller queue and look at next drive. 		 * We know we're at the head of the controller queue. 		 */
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
continue|continue;
comment|/* Need to check for loop */
block|}
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|++
expr_stmt|;
name|tmscpaddr
operator|=
operator|(
expr|struct
name|tmscpdevice
operator|*
operator|)
name|um
operator|->
name|um_addr
expr_stmt|;
name|ui
operator|=
name|tmsdinfo
index|[
operator|(
name|TMSUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|)
index|]
expr_stmt|;
name|tms
operator|=
operator|&
name|tms_info
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
operator|)
operator|||
name|sc
operator|->
name|sc_state
operator|!=
name|S_RUN
condition|)
block|{
name|tprintf
argument_list|(
name|tms
operator|->
name|tms_tpr
argument_list|,
literal|"tms%d: hard error bn%d\n"
argument_list|,
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
literal|03
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"tmscp%d: sa 0%o, state %d\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
literal|0xffff
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tmscpinit
argument_list|(
name|um
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
comment|/* SHOULD REQUEUE OUTSTANDING REQUESTS, LIKE TMSCPRESET */
break|break;
block|}
comment|/* 	 * Default is that last command was NOT a write command; 	 * if a write command is done it will be detected in tmscprsp. 	 */
name|tms
operator|->
name|tms_lastiow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_flags
operator|==
literal|0
condition|)
block|{
comment|/* not online */
if|if
condition|(
operator|(
name|mp
operator|=
name|tmscpgetcp
argument_list|(
name|um
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_ONLIN
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|2
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
comment|/* remove from controller q */
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|mp
operator|->
name|mscp_dscptr
operator|)
operator||=
name|TMSCP_OWN
operator||
name|TMSCP_INT
expr_stmt|;
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
name|printf
argument_list|(
literal|"tmscp%d fatal error (0%o)\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|i
operator|=
name|tmscpaddr
operator|->
name|tmscpip
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|cpu
condition|)
block|{
case|case
name|VAX_8600
case|:
case|case
name|VAX_780
case|:
name|i
operator|=
name|UBA_NEEDBDP
operator||
name|UBA_CANTWAIT
expr_stmt|;
break|break;
case|case
name|VAX_750
case|:
name|i
operator|=
name|um
operator|->
name|um_ubinfo
operator||
name|UBA_HAVEBDP
operator||
name|UBA_CANTWAIT
expr_stmt|;
break|break;
case|case
name|VAX_730
case|:
case|case
name|VAX_630
case|:
name|i
operator|=
name|UBA_CANTWAIT
expr_stmt|;
break|break;
block|}
comment|/* end switch (cpu) */
comment|/* 	 * If command is an ioctl command then set the ioctl flag for later use. 	 * If not (i.e. it is a read or write) then attempt 	 * to set up a buffer pointer. 	 */
name|ioctl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|==
operator|&
name|ctmscpbuf
index|[
name|um
operator|->
name|um_ctlr
index|]
condition|)
name|ioctl
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|ubasetup
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|,
name|bp
argument_list|,
name|i
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|b_qsize
operator|!=
literal|0
condition|)
break|break;
comment|/* When a command completes and */
comment|/* frees a bdp tmscpstart will be called */
if|if
condition|(
operator|(
name|mp
operator|=
name|tmscpgetcp
argument_list|(
name|um
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpstart: GTUNT %d ubasetup = %d\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmscpdebug
condition|)
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_GTUNT
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|mp
operator|->
name|mscp_dscptr
operator|)
operator||=
name|TMSCP_OWN
operator||
name|TMSCP_INT
expr_stmt|;
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
name|printf
argument_list|(
literal|"tmscp%d: fatal error (0%o)\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|i
operator|=
name|tmscpaddr
operator|->
name|tmscpip
expr_stmt|;
comment|/* initiate polling */
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VAX750
argument_list|)
if|if
condition|(
name|cpu
operator|==
name|VAX_750
condition|)
name|tempi
operator|=
name|i
operator|&
literal|0xfffffff
expr_stmt|;
comment|/* mask off bdp */
else|else
endif|#
directive|endif
name|tempi
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|=
name|tmscpgetcp
argument_list|(
name|um
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ioctl
condition|)
comment|/* only need to release if NOT ioctl */
name|ubarelse
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|,
operator|&
name|tempi
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|mscp_cmdref
operator|=
operator|(
name|long
operator|)
name|bp
expr_stmt|;
comment|/* pointer to get back */
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
comment|/* 	 * If its an ioctl-type command then set up the appropriate 	 * tmscp command;  by doing a switch on the "b_resid" field where 	 * the command mneumonic is stored. 	 */
if|if
condition|(
name|ioctl
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpstart: doing ioctl cmd %d\n"
argument_list|,
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * The reccnt and tmkcnt fields are set to zero by the getcp 		 * routine (as bytecnt and buffer fields).  Thus reccnt and 		 * tmkcnt are only modified here if they need to be set to 		 * a non-zero value. 		 */
switch|switch
condition|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_resid
condition|)
block|{
case|case
name|TMS_WRITM
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_WRITM
expr_stmt|;
break|break;
case|case
name|TMS_FSF
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_REPOS
expr_stmt|;
name|mp
operator|->
name|mscp_tmkcnt
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
break|break;
case|case
name|TMS_BSF
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_REPOS
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
name|M_MD_REVRS
expr_stmt|;
name|mp
operator|->
name|mscp_tmkcnt
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
break|break;
case|case
name|TMS_FSR
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_REPOS
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
name|M_MD_OBJCT
expr_stmt|;
name|mp
operator|->
name|mscp_reccnt
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
break|break;
case|case
name|TMS_BSR
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_REPOS
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
name|M_MD_REVRS
operator||
name|M_MD_OBJCT
expr_stmt|;
name|mp
operator|->
name|mscp_reccnt
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
break|break;
comment|/* 		 * Clear serious exception is done for Rewind& Available cmds 		 */
case|case
name|TMS_REW
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_REPOS
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
name|M_MD_REWND
operator||
name|M_MD_CLSEX
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
name|mp
operator|->
name|mscp_modifier
operator||=
name|M_MD_IMMED
expr_stmt|;
name|tms
operator|->
name|tms_serex
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TMS_OFFL
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_AVAIL
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
name|M_MD_UNLOD
operator||
name|M_MD_CLSEX
expr_stmt|;
name|tms
operator|->
name|tms_serex
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TMS_SENSE
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_GTUNT
expr_stmt|;
break|break;
case|case
name|TMS_CACHE
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_STUNT
expr_stmt|;
name|tms
operator|->
name|tms_unitflgs
operator||=
name|M_UF_WBKNV
expr_stmt|;
name|mp
operator|->
name|mscp_unitflgs
operator|=
name|tms
operator|->
name|tms_unitflgs
expr_stmt|;
name|mp
operator|->
name|mscp_format
operator|=
name|tms
operator|->
name|tms_format
expr_stmt|;
comment|/* default device dependant parameters */
name|mp
operator|->
name|mscp_mediaid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TMS_NOCACHE
case|:
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_STUNT
expr_stmt|;
name|tms
operator|->
name|tms_unitflgs
operator|&=
operator|~
operator|(
name|M_UF_WBKNV
operator|)
expr_stmt|;
name|mp
operator|->
name|mscp_unitflgs
operator|=
name|tms
operator|->
name|tms_unitflgs
expr_stmt|;
name|mp
operator|->
name|mscp_format
operator|=
name|tms
operator|->
name|tms_format
expr_stmt|;
comment|/* default device dependant parameters */
name|mp
operator|->
name|mscp_mediaid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TMS_CSE
case|:
comment|/* 			 * This is a no-op command. It performs a  			 * clear serious exception only.  (Done on a 			 * non-rewinding close after a serious exception.) 			 */
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_REPOS
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
name|M_MD_CLSEX
expr_stmt|;
name|tms
operator|->
name|tms_serex
operator|=
literal|0
expr_stmt|;
name|tms
operator|->
name|tms_clserex
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TMS_LOWDENSITY
case|:
comment|/* 			 * Set the unit to low density 			 */
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_STUNT
expr_stmt|;
name|mp
operator|->
name|mscp_unitflgs
operator|=
name|tms
operator|->
name|tms_unitflgs
expr_stmt|;
name|mp
operator|->
name|mscp_mediaid
operator|=
literal|0
expr_stmt|;
comment|/* default device dependant parameters */
if|if
condition|(
operator|(
name|tms
operator|->
name|tms_fmtmenu
operator|&
name|M_TF_800
operator|)
operator|!=
literal|0
condition|)
name|mp
operator|->
name|mscp_format
operator|=
name|M_TF_800
expr_stmt|;
else|else
name|mp
operator|->
name|mscp_format
operator|=
name|M_TF_PE
operator|&
name|tms
operator|->
name|tms_fmtmenu
expr_stmt|;
name|tms
operator|->
name|tms_format
operator|=
name|mp
operator|->
name|mscp_format
expr_stmt|;
break|break;
case|case
name|TMS_HIDENSITY
case|:
comment|/* 			 * Set the unit to high density (format == 0) 			 */
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_STUNT
expr_stmt|;
name|mp
operator|->
name|mscp_unitflgs
operator|=
name|tms
operator|->
name|tms_unitflgs
expr_stmt|;
name|mp
operator|->
name|mscp_mediaid
operator|=
literal|0
expr_stmt|;
comment|/* default device dependant parameters */
name|mp
operator|->
name|mscp_format
operator|=
literal|0
expr_stmt|;
name|tms
operator|->
name|tms_format
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad ioctl on tms unit %d\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
comment|/* Need a no-op. Reposition no amount */
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_REPOS
expr_stmt|;
break|break;
block|}
comment|/* end switch (bp->b_resid) */
block|}
else|else
comment|/* Its a read/write command (not an ioctl) */
block|{
name|mp
operator|->
name|mscp_opcode
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|M_OP_READ
else|:
name|M_OP_WRITE
expr_stmt|;
name|mp
operator|->
name|mscp_bytecnt
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|mp
operator|->
name|mscp_buffer
operator|=
name|UBAI_ADDR
argument_list|(
name|i
argument_list|)
operator||
operator|(
name|UBAI_BDP
argument_list|(
name|i
argument_list|)
operator|<<
literal|24
operator|)
expr_stmt|;
name|bp
operator|->
name|b_ubinfo
operator|=
name|tempi
expr_stmt|;
comment|/* save mapping info */
block|}
if|if
condition|(
name|tms
operator|->
name|tms_serex
operator|==
literal|2
condition|)
comment|/* if tape mark read */
block|{
name|mp
operator|->
name|mscp_modifier
operator||=
name|M_MD_CLSEX
expr_stmt|;
comment|/*  clear serious exc */
name|tms
operator|->
name|tms_serex
operator|=
literal|0
expr_stmt|;
block|}
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|mp
operator|->
name|mscp_dscptr
operator|)
operator||=
name|TMSCP_OWN
operator||
name|TMSCP_INT
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpstart: opcode 0%o mod %o unit %d cnt %d\n"
argument_list|,
name|mp
operator|->
name|mscp_opcode
argument_list|,
name|mp
operator|->
name|mscp_modifier
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|mp
operator|->
name|mscp_bytecnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmscpdebug
condition|)
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|tmscpaddr
operator|->
name|tmscpip
expr_stmt|;
comment|/* initiate polling */
name|dp
operator|->
name|b_qsize
operator|++
expr_stmt|;
comment|/* 	 * Move drive to the end of the controller queue 	 */
if|if
condition|(
name|dp
operator|->
name|b_forw
operator|!=
name|NULL
condition|)
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Move buffer to I/O wait queue 	 */
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|dp
operator|=
operator|&
name|tmscpwtab
index|[
name|um
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|dp
expr_stmt|;
name|bp
operator|->
name|av_back
operator|=
name|dp
operator|->
name|av_back
expr_stmt|;
name|dp
operator|->
name|av_back
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|av_back
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"tmscp%d: fatal error (0%o)\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tmscpinit
argument_list|(
name|um
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* end for */
comment|/*      * Check for response ring transitions lost in the      * Race condition      */
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|sc_lastrsp
init|;
condition|;
name|i
operator|++
control|)
block|{
name|i
operator|%=
name|NRSP
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
operator|&
name|TMSCP_OWN
condition|)
break|break;
name|tmscprsp
argument_list|(
name|um
argument_list|,
name|tm
argument_list|,
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tmscp_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
operator||=
name|TMSCP_OWN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_lastrsp
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Process a response packet  */
end_comment

begin_expr_stmt
name|tmscprsp
argument_list|(
name|um
argument_list|,
name|tm
argument_list|,
name|sc
argument_list|,
name|i
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tmscp
modifier|*
name|tm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|tmscp_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|tms_info
modifier|*
name|tms
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|st
decl_stmt|;
name|mp
operator|=
operator|&
name|tm
operator|->
name|tmscp_rsp
index|[
name|i
index|]
expr_stmt|;
name|mp
operator|->
name|mscp_header
operator|.
name|tmscp_msglen
operator|=
name|mscp_msglen
expr_stmt|;
name|sc
operator|->
name|sc_credits
operator|+=
name|mp
operator|->
name|mscp_header
operator|.
name|tmscp_credits
operator|&
literal|0xf
expr_stmt|;
comment|/* low 4 bits */
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_header
operator|.
name|tmscp_credits
operator|&
literal|0xf0
operator|)
operator|>
literal|0x10
condition|)
comment|/* Check */
return|return;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscprsp, opcode 0%o status 0%o\n"
argument_list|,
name|mp
operator|->
name|mscp_opcode
argument_list|,
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If it's an error log message (datagram), 	 * pass it on for more extensive processing. 	 */
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_header
operator|.
name|tmscp_credits
operator|&
literal|0xf0
operator|)
operator|==
literal|0x10
condition|)
block|{
comment|/* check */
name|tmserror
argument_list|(
name|um
argument_list|,
operator|(
expr|struct
name|mslg
operator|*
operator|)
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|st
operator|=
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
expr_stmt|;
comment|/* 	 * The controller interrupts as drive 0. 	 * This means that you must check for controller interrupts 	 * before you check to see if there is a drive 0. 	 */
if|if
condition|(
operator|(
name|M_OP_STCON
operator||
name|M_OP_END
operator|)
operator|==
name|mp
operator|->
name|mscp_opcode
condition|)
block|{
if|if
condition|(
name|st
operator|==
name|M_ST_SUCC
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"ctlr has %d credits\n"
argument_list|,
name|mp
operator|->
name|mscp_header
operator|.
name|tmscp_credits
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|printd
argument_list|(
literal|"ctlr timeout = %d\n"
argument_list|,
name|mp
operator|->
name|mscp_cnttmo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_state
operator|=
name|S_RUN
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|um
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mp
operator|->
name|mscp_unit
operator|>=
name|NTMS
condition|)
return|return;
if|if
condition|(
operator|(
name|ui
operator|=
name|tmscpip
index|[
name|um
operator|->
name|um_ctlr
index|]
index|[
name|mp
operator|->
name|mscp_unit
index|]
operator|)
operator|==
literal|0
condition|)
return|return;
name|tms
operator|=
operator|&
name|tms_info
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
comment|/* 	 * Save endcode, endflags, and status for mtioctl get unit status. 	 * NOTE: Don't do this on Clear serious exception (reposition no-op); 	 *    which is done on close since this would 	 *    overwrite the real status we want. 	 */
if|if
condition|(
name|tms
operator|->
name|tms_clserex
operator|!=
literal|1
condition|)
block|{
name|tms
operator|->
name|tms_endcode
operator|=
name|mp
operator|->
name|mscp_opcode
expr_stmt|;
name|tms
operator|->
name|tms_flags
operator|=
name|mp
operator|->
name|mscp_flags
expr_stmt|;
name|tms
operator|->
name|tms_status
operator|=
name|st
expr_stmt|;
block|}
else|else
name|tms
operator|->
name|tms_clserex
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mp
operator|->
name|mscp_opcode
condition|)
block|{
case|case
name|M_OP_ONLIN
operator||
name|M_OP_END
case|:
name|tms
operator|->
name|tms_type
operator|=
name|mp
operator|->
name|mscp_mediaid
expr_stmt|;
name|dp
operator|=
operator|&
name|tmsutab
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|M_ST_SUCC
condition|)
block|{
comment|/* 			 * Link the drive onto the controller queue 			 */
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|ui
operator|->
name|ui_flags
operator|=
literal|1
expr_stmt|;
comment|/* mark it online */
name|tms
operator|->
name|tms_dsize
operator|=
operator|(
name|daddr_t
operator|)
name|mp
operator|->
name|mscp_maxwrt
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscprsp: unit %d online\n"
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  			 * This define decodes the Media type identifier 			 */
define|#
directive|define
name|F_to_C
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|)
value|( ((x)->mscp_mediaid)>> (i*5+7)& 0x1f ? ( ( (((x)->mscp_mediaid)>>( i*5 + 7))& 0x1f) + 'A' - 1): ' ')
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscprsp: unit %d online %x %c%c %c%c%c%d\n"
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|mp
operator|->
name|mscp_mediaid
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|4
argument_list|)
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|3
argument_list|)
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mp
operator|->
name|mscp_mediaid
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
block|}
comment|/* end if st == M_ST_SUCC */
else|else
block|{
if|if
condition|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
condition|)
name|tprintf
argument_list|(
name|tms
operator|->
name|tms_tpr
argument_list|,
literal|"tms%d: hard error bn%d: OFFLINE\n"
argument_list|,
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
literal|03
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
else|else
name|tprintf
argument_list|(
name|tms
operator|->
name|tms_tpr
argument_list|,
literal|"tms%d: hard error: OFFLINE\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
condition|)
block|{
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mp
operator|->
name|mscp_cmdref
operator|!=
name|NULL
condition|)
comment|/* Seems to get lost sometimes in uda */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mscp_cmdref
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * The AVAILABLE ATTENTION message occurs when the 	 * unit becomes available after loading, 	 * marking the unit offline (ui_flags = 0) will force an 	 * online command prior to using the unit. 	 */
case|case
name|M_OP_AVATN
case|:
name|ui
operator|->
name|ui_flags
operator|=
literal|0
expr_stmt|;
name|tms
operator|->
name|tms_type
operator|=
name|mp
operator|->
name|mscp_mediaid
expr_stmt|;
break|break;
case|case
name|M_OP_END
case|:
comment|/* 		 * An endcode without an opcode (0200) is an invalid command. 		 * The mscp specification states that this would be a protocol 		 * type error, such as illegal opcodes. The mscp spec. also 		 * states that parameter error type of invalid commands should 		 * return the normal end message for the command. This does not appear 		 * to be the case. An invalid logical block number returned an endcode 		 * of 0200 instead of the 0241 (read) that was expected. 		 */
name|printf
argument_list|(
literal|"tmscp%d: invalid cmd, endcode = %o, status=%o\n"
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|mp
operator|->
name|mscp_opcode
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|mp
operator|->
name|mscp_cmdref
expr_stmt|;
comment|/* 		 * Unlink buffer from I/O wait queue. 		 * And signal iodone, so the higher level command can exit! 		 * 		 */
name|bp
operator|->
name|av_back
operator|->
name|av_forw
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|->
name|av_back
operator|=
name|bp
operator|->
name|av_back
expr_stmt|;
name|dp
operator|=
operator|&
name|tmsutab
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
name|dp
operator|->
name|b_qsize
operator|--
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_OP_WRITE
operator||
name|M_OP_END
case|:
comment|/* mark the last io op as a write */
name|tms
operator|->
name|tms_lastiow
operator|=
literal|1
expr_stmt|;
case|case
name|M_OP_READ
operator||
name|M_OP_END
case|:
case|case
name|M_OP_WRITM
operator||
name|M_OP_END
case|:
case|case
name|M_OP_REPOS
operator||
name|M_OP_END
case|:
case|case
name|M_OP_STUNT
operator||
name|M_OP_END
case|:
comment|/* 	 * The AVAILABLE message occurs when the mt ioctl "rewoffl" is 	 * issued.  For the ioctl, "rewoffl", a tmscp AVAILABLE command is 	 * done with the UNLOAD modifier.  This performs a rewind, followed 	 * by marking the unit offline.  So mark the unit offline 	 * software wise as well (ui_flags = 0 and  	 * tms->tms_openf = 0). 	 */
case|case
name|M_OP_AVAIL
operator||
name|M_OP_END
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscprsp: position = %d\n"
argument_list|,
name|mp
operator|->
name|mscp_lbn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|mp
operator|->
name|mscp_cmdref
expr_stmt|;
comment|/* 		 * Only need to release buffer if the command was read or write. 		 * No ubasetup was done in "tmscpstart" if it was an ioctl cmd. 		 */
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|==
operator|(
name|M_OP_READ
operator||
name|M_OP_END
operator|)
operator|||
name|mp
operator|->
name|mscp_opcode
operator|==
operator|(
name|M_OP_WRITE
operator||
name|M_OP_END
operator|)
condition|)
name|ubarelse
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|bp
operator|->
name|b_ubinfo
argument_list|)
expr_stmt|;
comment|/* 		 * Unlink buffer from I/O wait queue. 		 */
name|bp
operator|->
name|av_back
operator|->
name|av_forw
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|->
name|av_back
operator|=
name|bp
operator|->
name|av_back
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VAX750
argument_list|)
if|if
condition|(
name|cpu
operator|==
name|VAX_750
condition|)
block|{
if|if
condition|(
operator|(
name|tmscpwtab
index|[
name|um
operator|->
name|um_ctlr
index|]
operator|.
name|av_forw
operator|==
operator|&
name|tmscpwtab
index|[
name|um
operator|->
name|um_ctlr
index|]
operator|)
operator|&&
operator|(
name|um
operator|->
name|um_ubinfo
operator|!=
literal|0
operator|)
condition|)
block|{
name|ubarelse
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|,
operator|&
name|um
operator|->
name|um_ubinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|==
operator|(
name|M_OP_READ
operator||
name|M_OP_END
operator|)
operator|||
name|mp
operator|->
name|mscp_opcode
operator|==
operator|(
name|M_OP_WRITE
operator||
name|M_OP_END
operator|)
condition|)
name|UBAPURGE
argument_list|(
name|uba_hd
index|[
name|um
operator|->
name|um_ubanum
index|]
operator|.
name|uh_uba
argument_list|,
operator|(
name|um
operator|->
name|um_ubinfo
operator|>>
literal|28
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|dp
operator|=
operator|&
name|tmsutab
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
name|dp
operator|->
name|b_qsize
operator|--
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|M_ST_OFFLN
operator|||
name|st
operator|==
name|M_ST_AVLBL
condition|)
block|{
name|ui
operator|->
name|ui_flags
operator|=
literal|0
expr_stmt|;
comment|/* mark unit offline */
name|tms
operator|->
name|tms_openf
operator|=
literal|0
expr_stmt|;
name|tms
operator|->
name|tms_type
operator|=
name|mp
operator|->
name|mscp_mediaid
expr_stmt|;
comment|/* 			 * Link the buffer onto the front of the drive queue 			 */
if|if
condition|(
operator|(
name|bp
operator|->
name|av_forw
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
literal|0
condition|)
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
comment|/* 			 * Link the drive onto the controller queue 			 */
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VAX750
argument_list|)
if|if
condition|(
name|cpu
operator|==
name|VAX_750
operator|&&
name|um
operator|->
name|um_ubinfo
operator|==
literal|0
condition|)
name|um
operator|->
name|um_ubinfo
operator|=
name|uballoc
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|UBA_NEEDBDP
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|st
operator|!=
name|M_ST_SUCC
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|mscp_flags
operator|&
name|M_EF_SEREX
condition|)
name|tms
operator|->
name|tms_serex
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|st
operator|!=
name|M_ST_TAPEM
condition|)
block|{
name|tprintf
argument_list|(
name|tms
operator|->
name|tms_tpr
argument_list|,
literal|"tms%d: hard error bn%d\n"
argument_list|,
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
literal|03
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|errinfo
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* produces more info */
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscprsp: error; status sub-code = 0%o, flags = 0%o\n"
argument_list|,
operator|(
name|mp
operator|->
name|mscp_status
operator|&
literal|177740
operator|)
operator|>>
literal|5
argument_list|,
name|mp
operator|->
name|mscp_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
comment|/* Hit a tape mark - Set serex flag to 				 * a special value so we can clear the 				 * serious exception on the next command. 				 */
name|tms
operator|->
name|tms_serex
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 		 * The tmscp spec states that controllers do not have to 		 * report the number of records or files skipped.  So on 		 * reposition commands we go strictly by cmd status. 		 */
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|!=
operator|(
name|M_OP_REPOS
operator||
name|M_OP_END
operator|)
condition|)
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|mp
operator|->
name|mscp_bytecnt
expr_stmt|;
else|else
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|tms
operator|->
name|tms_resid
operator|=
name|bp
operator|->
name|b_resid
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_OP_GTUNT
operator||
name|M_OP_END
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscprsp: GTUNT end packet status = 0%o\n"
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|printd
argument_list|(
literal|"tmscprsp: unit %d mediaid %x %c%c %c%c%c%d %x %x t=%d\n"
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|mp
operator|->
name|mscp_mediaid
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|4
argument_list|)
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|3
argument_list|)
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|F_to_C
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mp
operator|->
name|mscp_mediaid
operator|&
literal|0x7f
argument_list|,
name|mp
operator|->
name|mscp_unitid
operator|.
name|val
index|[
literal|0
index|]
argument_list|,
name|mp
operator|->
name|mscp_unitid
operator|.
name|val
index|[
literal|1
index|]
argument_list|,
name|mp
operator|->
name|mscp_format
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tms
operator|->
name|tms_type
operator|=
name|mp
operator|->
name|mscp_mediaid
expr_stmt|;
name|tms
operator|->
name|tms_fmtmenu
operator|=
name|mp
operator|->
name|mscp_fmtmenu
expr_stmt|;
name|tms
operator|->
name|tms_unitflgs
operator|=
name|mp
operator|->
name|mscp_unitflgs
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"tmscp unknown packet\n"
argument_list|)
expr_stmt|;
name|tmserror
argument_list|(
name|um
argument_list|,
operator|(
expr|struct
name|mslg
operator|*
operator|)
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/* end switch mp->mscp_opcode */
block|}
end_block

begin_comment
comment|/*   * Give a meaningful error when the mscp_status field returns an error code.  */
end_comment

begin_macro
name|errinfo
argument_list|(
argument|st
argument_list|)
end_macro

begin_decl_stmt
name|int
name|st
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the status code */
end_comment

begin_block
block|{
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|M_ST_ICMD
case|:
name|printf
argument_list|(
literal|"invalid command\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_ABRTD
case|:
name|printf
argument_list|(
literal|"command aborted\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_OFFLN
case|:
name|printf
argument_list|(
literal|"unit offline\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_WRTPR
case|:
name|printf
argument_list|(
literal|"unit write protected\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_COMP
case|:
name|printf
argument_list|(
literal|"compare error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_DATA
case|:
name|printf
argument_list|(
literal|"data error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_HSTBF
case|:
name|printf
argument_list|(
literal|"host buffer access error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_CNTLR
case|:
name|printf
argument_list|(
literal|"controller error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_DRIVE
case|:
name|printf
argument_list|(
literal|"drive error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_FMTER
case|:
name|printf
argument_list|(
literal|"formatter error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_BOT
case|:
name|printf
argument_list|(
literal|"BOT encountered\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_TAPEM
case|:
name|printf
argument_list|(
literal|"tape mark encountered\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_RDTRN
case|:
name|printf
argument_list|(
literal|"record data truncated\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_PLOST
case|:
name|printf
argument_list|(
literal|"position lost\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_SEX
case|:
name|printf
argument_list|(
literal|"serious exception\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ST_LED
case|:
name|printf
argument_list|(
literal|"LEOT detected\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Manage buffers and perform block mode read and write operations.  */
end_comment

begin_expr_stmt
name|tmscpstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|TMSUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NTMS
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmscpstrategy: bad unit # %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ui
operator|=
name|tmsdinfo
index|[
name|unit
index|]
expr_stmt|;
name|um
operator|=
name|ui
operator|->
name|ui_mi
expr_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
comment|/* 	 * Link the buffer onto the drive queue 	 */
name|dp
operator|=
operator|&
name|tmsutab
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
literal|0
condition|)
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
else|else
name|dp
operator|->
name|b_actl
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Link the drive onto the controller queue 	 */
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If the controller is not active, start it. 	 */
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VAX750
argument_list|)
if|if
condition|(
name|cpu
operator|==
name|VAX_750
operator|&&
name|tmscpwtab
index|[
name|um
operator|->
name|um_ctlr
index|]
operator|.
name|av_forw
operator|==
operator|&
name|tmscpwtab
index|[
name|um
operator|->
name|um_ctlr
index|]
condition|)
block|{
if|if
condition|(
name|um
operator|->
name|um_ubinfo
operator|!=
literal|0
condition|)
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"tmscpstrategy: ubinfo 0x%x\n"
argument_list|,
name|um
operator|->
name|um_ubinfo
argument_list|)
expr_stmt|;
else|else
name|um
operator|->
name|um_ubinfo
operator|=
name|uballoc
argument_list|(
name|um
operator|->
name|um_ubanum
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|UBA_NEEDBDP
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|printd10
argument_list|(
literal|"tmscpstrategy: Controller not active, starting it\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|tmscpstart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_define
define|#
directive|define
name|DBSIZE
value|32
end_define

begin_define
define|#
directive|define
name|ca_Rspdsc
value|ca_rspdsc[0]
end_define

begin_define
define|#
directive|define
name|ca_Cmddsc
value|ca_rspdsc[1]
end_define

begin_define
define|#
directive|define
name|tmscp_Rsp
value|tmscp_rsp[0]
end_define

begin_define
define|#
directive|define
name|tmscp_Cmd
value|tmscp_cmd[0]
end_define

begin_decl_stmt
name|struct
name|tmscp
name|tmscpd
index|[
name|NTMSCP
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|tmscpdump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tmscpdevice
modifier|*
name|tmscpaddr
decl_stmt|;
name|struct
name|tmscp
modifier|*
name|tmscp_ubaddr
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|num
decl_stmt|,
name|blk
decl_stmt|,
name|unit
decl_stmt|;
specifier|register
name|struct
name|uba_regs
modifier|*
name|uba
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|tmscp
modifier|*
name|tmscpp
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|io
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|03
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NTMS
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
define|#
directive|define
name|phys
parameter_list|(
name|cast
parameter_list|,
name|addr
parameter_list|)
value|((cast)((int)addr& 0x7fffffff))
name|ui
operator|=
name|phys
argument_list|(
expr|struct
name|uba_device
operator|*
argument_list|,
name|tmsdinfo
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|uba
operator|=
name|phys
argument_list|(
expr|struct
name|uba_hd
operator|*
argument_list|,
name|ui
operator|->
name|ui_hd
argument_list|)
operator|->
name|uh_physuba
expr_stmt|;
name|ubainit
argument_list|(
name|uba
argument_list|)
expr_stmt|;
name|tmscpaddr
operator|=
operator|(
expr|struct
name|tmscpdevice
operator|*
operator|)
name|ui
operator|->
name|ui_physaddr
expr_stmt|;
name|DELAY
argument_list|(
literal|2000000
argument_list|)
expr_stmt|;
name|tmscpp
operator|=
name|phys
argument_list|(
expr|struct
name|tmscp
operator|*
argument_list|,
operator|&
name|tmscpd
index|[
name|ui
operator|->
name|ui_ctlr
index|]
argument_list|)
expr_stmt|;
name|num
operator|=
name|btoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tmscp
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|io
operator|=
operator|&
name|uba
operator|->
name|uba_map
index|[
name|NUBMREG
operator|-
name|num
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|++
operator|=
name|UBAMR_MRV
operator||
operator|(
name|btop
argument_list|(
name|tmscpp
argument_list|)
operator|+
name|i
operator|)
expr_stmt|;
name|tmscp_ubaddr
operator|=
operator|(
expr|struct
name|tmscp
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|tmscpp
operator|&
name|PGOFSET
operator|)
operator||
operator|(
operator|(
name|NUBMREG
operator|-
name|num
operator|)
operator|<<
literal|9
operator|)
operator|)
expr_stmt|;
name|tmscpaddr
operator|->
name|tmscpip
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_STEP1
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
name|TMSCP_ERR
expr_stmt|;
while|while
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_STEP2
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
operator|(
name|short
operator|)
operator|&
name|tmscp_ubaddr
operator|->
name|tmscp_ca
operator|.
name|ca_ringbase
expr_stmt|;
while|while
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_STEP3
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|&
name|tmscp_ubaddr
operator|->
name|tmscp_ca
operator|.
name|ca_ringbase
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_STEP4
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|tmscpaddr
operator|->
name|tmscpsa
operator|=
name|TMSCP_GO
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_ca
operator|.
name|ca_Rspdsc
operator|=
operator|(
name|long
operator|)
operator|&
name|tmscp_ubaddr
operator|->
name|tmscp_Rsp
operator|.
name|mscp_cmdref
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_ca
operator|.
name|ca_Cmddsc
operator|=
operator|(
name|long
operator|)
operator|&
name|tmscp_ubaddr
operator|->
name|tmscp_Cmd
operator|.
name|mscp_cmdref
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_header
operator|.
name|tmscp_vcid
operator|=
literal|1
expr_stmt|;
comment|/* for tape */
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_cntflgs
operator|=
literal|0
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_version
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmscpcmd
argument_list|(
name|M_OP_STCON
argument_list|,
name|tmscpp
argument_list|,
name|tmscpaddr
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
if|if
condition|(
name|tmscpcmd
argument_list|(
name|M_OP_ONLIN
argument_list|,
name|tmscpp
argument_list|,
name|tmscpaddr
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|num
operator|=
name|maxfree
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|blk
operator|=
name|num
operator|>
name|DBSIZE
condition|?
name|DBSIZE
else|:
name|num
expr_stmt|;
name|io
operator|=
name|uba
operator|->
name|uba_map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blk
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|++
operator|=
operator|(
name|btop
argument_list|(
name|start
argument_list|)
operator|+
name|i
operator|)
operator||
name|UBAMR_MRV
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|io
operator|=
literal|0
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_lbn
operator|=
name|btop
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_bytecnt
operator|=
name|blk
operator|*
name|NBPG
expr_stmt|;
ifdef|#
directive|ifdef
name|MVAX
if|if
condition|(
name|cpu
operator|==
name|MVAX_I
condition|)
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_buffer
operator|=
operator|(
name|long
operator|)
name|start
expr_stmt|;
else|else
endif|#
directive|endif
endif|MVAX
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_buffer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmscpcmd
argument_list|(
name|M_OP_WRITE
argument_list|,
name|tmscpp
argument_list|,
name|tmscpaddr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|start
operator|+=
name|blk
operator|*
name|NBPG
expr_stmt|;
name|num
operator|-=
name|blk
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform a standalone tmscp command.  This routine is only used by tmscpdump.  */
end_comment

begin_macro
name|tmscpcmd
argument_list|(
argument|op
argument_list|,
argument|tmscpp
argument_list|,
argument|tmscpaddr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|tmscp
modifier|*
name|tmscpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tmscpdevice
modifier|*
name|tmscpaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_opcode
operator|=
name|op
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_Rsp
operator|.
name|mscp_header
operator|.
name|tmscp_msglen
operator|=
name|mscp_msglen
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_Cmd
operator|.
name|mscp_header
operator|.
name|tmscp_msglen
operator|=
name|mscp_msglen
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_ca
operator|.
name|ca_Rspdsc
operator||=
name|TMSCP_OWN
operator||
name|TMSCP_INT
expr_stmt|;
name|tmscpp
operator|->
name|tmscp_ca
operator|.
name|ca_Cmddsc
operator||=
name|TMSCP_OWN
operator||
name|TMSCP_INT
expr_stmt|;
if|if
condition|(
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
name|TMSCP_ERR
condition|)
name|printf
argument_list|(
literal|"tmscp fatal error (0%o)\n"
argument_list|,
name|tmscpaddr
operator|->
name|tmscpsa
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|i
operator|=
name|tmscpaddr
operator|->
name|tmscpip
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|i
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|tmscpp
operator|->
name|tmscp_ca
operator|.
name|ca_cmdint
condition|)
name|tmscpp
operator|->
name|tmscp_ca
operator|.
name|ca_cmdint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmscpp
operator|->
name|tmscp_ca
operator|.
name|ca_rspint
condition|)
break|break;
block|}
name|tmscpp
operator|->
name|tmscp_ca
operator|.
name|ca_rspint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmscpp
operator|->
name|tmscp_Rsp
operator|.
name|mscp_opcode
operator|!=
operator|(
name|op
operator||
name|M_OP_END
operator|)
operator|||
operator|(
name|tmscpp
operator|->
name|tmscp_Rsp
operator|.
name|mscp_status
operator|&
name|M_ST_MASK
operator|)
operator|!=
name|M_ST_SUCC
condition|)
block|{
name|printf
argument_list|(
literal|"error: com %d opc 0x%x stat 0x%x\ndump "
argument_list|,
name|op
argument_list|,
name|tmscpp
operator|->
name|tmscp_Rsp
operator|.
name|mscp_opcode
argument_list|,
name|tmscpp
operator|->
name|tmscp_Rsp
operator|.
name|mscp_status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Catch ioctl commands, and call the "command" routine to do them.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|tmscpioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
operator|&
name|ctmscpbuf
index|[
name|TMSCPCTLR
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|callcount
expr_stmt|;
comment|/* number of times to call cmd routine */
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|tms_info
modifier|*
name|tms
decl_stmt|;
name|int
name|fcount
decl_stmt|;
comment|/* number of files (or records) to space */
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|mtop
modifier|*
name|mtop
decl_stmt|;
comment|/* mag tape cmd op to perform */
specifier|register
name|struct
name|mtget
modifier|*
name|mtget
decl_stmt|;
comment|/* mag tape struct to get info in */
comment|/* we depend of the values and order of the TMS ioctl codes here */
specifier|static
name|tmsops
index|[]
operator|=
block|{
name|TMS_WRITM
block|,
name|TMS_FSF
block|,
name|TMS_BSF
block|,
name|TMS_FSR
block|,
name|TMS_BSR
block|,
name|TMS_REW
block|,
name|TMS_OFFL
block|,
name|TMS_SENSE
block|,
name|TMS_CACHE
block|,
name|TMS_NOCACHE
block|}
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCTOP
case|:
comment|/* tape operation */
name|mtop
operator|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|mtop
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTWEOF
case|:
name|callcount
operator|=
name|mtop
operator|->
name|mt_count
expr_stmt|;
name|fcount
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MTFSF
case|:
case|case
name|MTBSF
case|:
case|case
name|MTFSR
case|:
case|case
name|MTBSR
case|:
name|callcount
operator|=
literal|1
expr_stmt|;
name|fcount
operator|=
name|mtop
operator|->
name|mt_count
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
case|case
name|MTOFFL
case|:
case|case
name|MTNOP
case|:
case|case
name|MTCACHE
case|:
case|case
name|MTNOCACHE
case|:
name|callcount
operator|=
literal|1
expr_stmt|;
name|fcount
operator|=
literal|1
expr_stmt|;
comment|/* wait for this rewind */
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* end switch mtop->mt_op */
if|if
condition|(
name|callcount
operator|<=
literal|0
operator|||
name|fcount
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
while|while
condition|(
operator|--
name|callcount
operator|>=
literal|0
condition|)
block|{
name|tmscpcommand
argument_list|(
name|dev
argument_list|,
name|tmsops
index|[
name|mtop
operator|->
name|mt_op
index|]
argument_list|,
name|fcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mtop
operator|->
name|mt_op
operator|==
name|MTFSR
operator|||
name|mtop
operator|->
name|mt_op
operator|==
name|MTBSR
operator|)
operator|&&
name|bp
operator|->
name|b_resid
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
comment|/* like hitting BOT */
break|break;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|bp
operator|->
name|b_error
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
case|case
name|MTIOCGET
case|:
comment|/* 		 * Return status info associated with the particular UNIT. 		 */
name|ui
operator|=
name|tmsdinfo
index|[
name|TMSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|tms
operator|=
operator|&
name|tms_info
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
name|mtget
operator|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|data
expr_stmt|;
name|mtget
operator|->
name|mt_type
operator|=
name|MT_ISTMSCP
expr_stmt|;
name|mtget
operator|->
name|mt_dsreg
operator|=
name|tms
operator|->
name|tms_flags
operator|<<
literal|8
expr_stmt|;
name|mtget
operator|->
name|mt_dsreg
operator||=
name|tms
operator|->
name|tms_endcode
expr_stmt|;
name|mtget
operator|->
name|mt_erreg
operator|=
name|tms
operator|->
name|tms_status
expr_stmt|;
name|mtget
operator|->
name|mt_resid
operator|=
name|tms
operator|->
name|tms_resid
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Reset (for raw mode use only).  */
end_comment

begin_macro
name|tmscpreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|int
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|NTMSCP
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|um
operator|=
name|tmscpminfo
index|[
name|d
index|]
operator|)
operator|==
literal|0
operator|||
name|um
operator|->
name|um_ubanum
operator|!=
name|uban
operator|||
name|um
operator|->
name|um_alive
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|" tmscp%d"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
literal|0
expr_stmt|;
name|tmscp_softc
index|[
name|d
index|]
operator|.
name|sc_state
operator|=
name|S_IDLE
expr_stmt|;
name|tmscp_softc
index|[
name|d
index|]
operator|.
name|sc_mapped
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NTMS
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ui
operator|=
name|tmsdinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_mi
operator|!=
name|um
condition|)
continue|continue;
name|tmsutab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|tmsutab
index|[
name|unit
index|]
operator|.
name|b_qsize
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|bp
operator|=
name|tmscpwtab
index|[
name|d
index|]
operator|.
name|av_forw
init|;
name|bp
operator|!=
operator|&
name|tmscpwtab
index|[
name|d
index|]
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|bp
operator|->
name|b_ubinfo
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Link the buffer onto the drive queue 			 */
name|dp
operator|=
operator|&
name|tmsutab
index|[
name|TMSUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
literal|0
condition|)
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
else|else
name|dp
operator|->
name|b_actl
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Link the drive onto the controller queue 			 */
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|tmscpinit
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Process an error log message  *  * Only minimal decoding is done, only "useful"  * information is printed.  Eventually should  * send message to an error logger.  */
end_comment

begin_expr_stmt
name|tmserror
argument_list|(
name|um
argument_list|,
name|mp
argument_list|)
specifier|register
expr|struct
name|uba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mslg
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printd
argument_list|(
literal|"tmserror:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|mslg_flags
operator|&
operator|(
name|M_LF_SUCC
operator||
name|M_LF_CONT
operator|)
operator|)
condition|)
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"tmscp%d: %s error, "
argument_list|,
name|um
operator|->
name|um_ctlr
argument_list|,
name|mp
operator|->
name|mslg_flags
operator|&
operator|(
name|M_LF_SUCC
operator||
name|M_LF_CONT
operator|)
condition|?
literal|"soft"
else|:
literal|"hard"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mp
operator|->
name|mslg_format
condition|)
block|{
case|case
name|M_FM_CNTERR
case|:
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"controller error, event 0%o\n"
argument_list|,
name|mp
operator|->
name|mslg_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_FM_BUSADDR
case|:
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"host memory access error, event 0%o, addr 0%o\n"
argument_list|,
name|mp
operator|->
name|mslg_event
argument_list|,
name|mp
operator|->
name|mslg_busaddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_FM_TAPETRN
case|:
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"tape transfer error, unit %d, grp 0x%x, event 0%o\n"
argument_list|,
name|mp
operator|->
name|mslg_unit
argument_list|,
name|mp
operator|->
name|mslg_group
argument_list|,
name|mp
operator|->
name|mslg_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_FM_STIERR
case|:
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"STI error, unit %d, event 0%o\n"
argument_list|,
name|mp
operator|->
name|mslg_unit
argument_list|,
name|mp
operator|->
name|mslg_event
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* too painful to do with log() */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|62
condition|;
name|i
operator|++
control|)
name|mprintf
argument_list|(
literal|"\t0x%x"
argument_list|,
name|mp
operator|->
name|mslg_stiunsucc
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|M_FM_STIDEL
case|:
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"STI Drive Error Log, unit %d, event 0%o\n"
argument_list|,
name|mp
operator|->
name|mslg_unit
argument_list|,
name|mp
operator|->
name|mslg_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_FM_STIFEL
case|:
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"STI Formatter Error Log, unit %d, event 0%o\n"
argument_list|,
name|mp
operator|->
name|mslg_unit
argument_list|,
name|mp
operator|->
name|mslg_event
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|TMS_PRI
argument_list|,
literal|"unknown error, unit %d, format 0%o, event 0%o\n"
argument_list|,
name|mp
operator|->
name|mslg_unit
argument_list|,
name|mp
operator|->
name|mslg_format
argument_list|,
name|mp
operator|->
name|mslg_event
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmscperror
condition|)
block|{
specifier|register
name|long
modifier|*
name|p
init|=
operator|(
name|long
operator|*
operator|)
name|mp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|mslg_header
operator|.
name|tmscp_msglen
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

