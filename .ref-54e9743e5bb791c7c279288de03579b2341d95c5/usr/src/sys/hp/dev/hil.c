begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: hil.c 1.38 92/01/21$  *  *	@(#)hil.c	8.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/hilreg.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/hilioctl.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/hilvar.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/kbdmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|hp300
end_ifdef

begin_define
define|#
directive|define
name|NHIL
value|1
end_define

begin_comment
comment|/* XXX */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"hil.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|hilloop
name|hilloop
index|[
name|NHIL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|_hilbell
name|default_bell
init|=
block|{
name|BELLDUR
block|,
name|BELLFREQ
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|hp800
end_ifdef

begin_decl_stmt
name|int
name|hilspl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|hildebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HDB_FOLLOW
value|0x01
end_define

begin_define
define|#
directive|define
name|HDB_MMAP
value|0x02
end_define

begin_define
define|#
directive|define
name|HDB_MASK
value|0x04
end_define

begin_define
define|#
directive|define
name|HDB_CONFIG
value|0x08
end_define

begin_define
define|#
directive|define
name|HDB_KEYBOARD
value|0x10
end_define

begin_define
define|#
directive|define
name|HDB_IDMODULE
value|0x20
end_define

begin_define
define|#
directive|define
name|HDB_EVENTS
value|0x80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* symbolic sleep message strings */
end_comment

begin_decl_stmt
name|char
name|hilin
index|[]
init|=
literal|"hilin"
decl_stmt|;
end_decl_stmt

begin_macro
name|hilsoftinit
argument_list|(
argument|unit
argument_list|,
argument|hilbase
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hil_dev
modifier|*
name|hilbase
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilsoftinit(%d, %x)\n"
argument_list|,
name|unit
argument_list|,
name|hilbase
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize loop information 	 */
name|hilp
operator|->
name|hl_addr
operator|=
name|hilbase
expr_stmt|;
name|hilp
operator|->
name|hl_cmdending
operator|=
name|FALSE
expr_stmt|;
name|hilp
operator|->
name|hl_actdev
operator|=
name|hilp
operator|->
name|hl_cmddev
operator|=
literal|0
expr_stmt|;
name|hilp
operator|->
name|hl_cmddone
operator|=
name|FALSE
expr_stmt|;
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_pollbp
operator|=
name|hilp
operator|->
name|hl_pollbuf
expr_stmt|;
name|hilp
operator|->
name|hl_kbddev
operator|=
literal|0
expr_stmt|;
name|hilp
operator|->
name|hl_kbdlang
operator|=
name|KBD_DEFAULT
expr_stmt|;
name|hilp
operator|->
name|hl_kbdflags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Clear all queues and device associations with queues 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NHILQ
condition|;
name|i
operator|++
control|)
block|{
name|hilp
operator|->
name|hl_queue
index|[
name|i
index|]
operator|.
name|hq_eventqueue
operator|=
name|NULL
expr_stmt|;
name|hilp
operator|->
name|hl_queue
index|[
name|i
index|]
operator|.
name|hq_procp
operator|=
name|NULL
expr_stmt|;
name|hilp
operator|->
name|hl_queue
index|[
name|i
index|]
operator|.
name|hq_devmask
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NHILD
condition|;
name|i
operator|++
control|)
name|hilp
operator|->
name|hl_device
index|[
name|i
index|]
operator|.
name|hd_qmask
operator|=
literal|0
expr_stmt|;
name|hilp
operator|->
name|hl_device
index|[
name|HILLOOPDEV
index|]
operator|.
name|hd_flags
operator|=
operator|(
name|HIL_ALIVE
operator||
name|HIL_PSEUDO
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|hilinit
argument_list|(
argument|unit
argument_list|,
argument|hilbase
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hil_dev
modifier|*
name|hilbase
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilinit(%d, %x)\n"
argument_list|,
name|unit
argument_list|,
name|hilbase
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize software (if not already done). 	 */
if|if
condition|(
operator|(
name|hilp
operator|->
name|hl_device
index|[
name|HILLOOPDEV
index|]
operator|.
name|hd_flags
operator|&
name|HIL_ALIVE
operator|)
operator|==
literal|0
condition|)
name|hilsoftinit
argument_list|(
name|unit
argument_list|,
name|hilbase
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize hardware. 	 * Reset the loop hardware, and collect keyboard/id info 	 */
name|hilreset
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
name|hilinfo
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|kbdenable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|hilopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|HILLOOP
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|hilloopdev
modifier|*
name|dptr
decl_stmt|;
name|u_char
name|device
init|=
name|HILUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilopen(%d): loop %x device %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|HILLOOP
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|hilp
operator|->
name|hl_device
index|[
name|HILLOOPDEV
index|]
operator|.
name|hd_flags
operator|&
name|HIL_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dptr
operator|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Pseudo-devices cannot be read, nothing more to do. 	 */
if|if
condition|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_PSEUDO
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Open semantics: 	 * 1.	Open devices have only one of HIL_READIN/HIL_QUEUEIN. 	 * 2.	HPUX processes always get read syscall interface and 	 *	must have exclusive use of the device. 	 * 3.	BSD processes default to shared queue interface. 	 *	Multiple processes can open the device. 	 */
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
block|{
if|if
condition|(
name|dptr
operator|->
name|hd_flags
operator|&
operator|(
name|HIL_READIN
operator||
name|HIL_QUEUEIN
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|dptr
operator|->
name|hd_flags
operator||=
name|HIL_READIN
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_READIN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|dptr
operator|->
name|hd_flags
operator||=
name|HIL_QUEUEIN
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|FNONBLOCK
condition|)
name|dptr
operator|->
name|hd_flags
operator||=
name|HIL_NOBLOCK
expr_stmt|;
comment|/* 	 * It is safe to flush the read buffer as we are guarenteed 	 * that no one else is using it. 	 */
name|ndflush
argument_list|(
operator|&
name|dptr
operator|->
name|hd_queue
argument_list|,
name|dptr
operator|->
name|hd_queue
operator|.
name|c_cc
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_INTON
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Opened the keyboard, put in raw mode. 	 */
operator|(
name|void
operator|)
name|splhil
argument_list|()
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|hilp
operator|->
name|hl_kbddev
condition|)
block|{
name|u_char
name|mask
init|=
literal|0
decl_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_WRITEKBDSADR
argument_list|,
operator|&
name|mask
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_kbdflags
operator||=
name|KBD_RAW
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_KEYBOARD
condition|)
name|printf
argument_list|(
literal|"hilopen: keyboard %d raw\n"
argument_list|,
name|hilp
operator|->
name|hl_kbddev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|hilclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|HILLOOP
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|hilloopdev
modifier|*
name|dptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|u_char
name|device
init|=
name|HILUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|char
name|mask
decl_stmt|,
name|lpctrl
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilclose(%d): device %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dptr
operator|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
expr_stmt|;
if|if
condition|(
name|device
operator|&&
operator|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_PSEUDO
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|&&
operator|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If this is the loop device, 		 * free up all queues belonging to this process. 		 */
if|if
condition|(
name|device
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NHILQ
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hilp
operator|->
name|hl_queue
index|[
name|i
index|]
operator|.
name|hq_procp
operator|==
name|p
condition|)
operator|(
name|void
operator|)
name|hilqfree
argument_list|(
name|hilp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
operator|~
name|hildevmask
argument_list|(
name|device
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splhil
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NHILQ
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hilp
operator|->
name|hl_queue
index|[
name|i
index|]
operator|.
name|hq_procp
operator|==
name|p
condition|)
block|{
name|dptr
operator|->
name|hd_qmask
operator|&=
operator|~
name|hilqmask
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_queue
index|[
name|i
index|]
operator|.
name|hq_devmask
operator|&=
name|mask
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * Always flush the read buffer 	 */
name|dptr
operator|->
name|hd_flags
operator|&=
operator|~
operator|(
name|HIL_QUEUEIN
operator||
name|HIL_READIN
operator||
name|HIL_NOBLOCK
operator|)
expr_stmt|;
name|ndflush
argument_list|(
operator|&
name|dptr
operator|->
name|hd_queue
argument_list|,
name|dptr
operator|->
name|hd_queue
operator|.
name|c_cc
argument_list|)
expr_stmt|;
comment|/* 	 * Set keyboard back to cooked mode when closed. 	 */
operator|(
name|void
operator|)
name|splhil
argument_list|()
expr_stmt|;
if|if
condition|(
name|device
operator|&&
name|device
operator|==
name|hilp
operator|->
name|hl_kbddev
condition|)
block|{
name|mask
operator|=
literal|1
operator|<<
operator|(
name|hilp
operator|->
name|hl_kbddev
operator|-
literal|1
operator|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_WRITEKBDSADR
argument_list|,
operator|&
name|mask
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_kbdflags
operator|&=
operator|~
operator|(
name|KBD_RAW
operator||
name|KBD_AR1
operator||
name|KBD_AR2
operator|)
expr_stmt|;
comment|/* 		 * XXX: We have had trouble with keyboards remaining raw 		 * after close due to the LPC_KBDCOOK bit getting cleared 		 * somewhere along the line.  Hence we check and reset 		 * LPCTRL if necessary. 		 */
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_READLPCTRL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|lpctrl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lpctrl
operator|&
name|LPC_KBDCOOK
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hilclose: bad LPCTRL %x, reset to %x\n"
argument_list|,
name|lpctrl
argument_list|,
name|lpctrl
operator||
name|LPC_KBDCOOK
argument_list|)
expr_stmt|;
name|lpctrl
operator||=
name|LPC_KBDCOOK
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_WRITELPCTRL
argument_list|,
operator|&
name|lpctrl
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_KEYBOARD
condition|)
name|printf
argument_list|(
literal|"hilclose: keyboard %d cooked\n"
argument_list|,
name|hilp
operator|->
name|hl_kbddev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kbdenable
argument_list|(
name|HILLOOP
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read interface to HIL device.  */
end_comment

begin_macro
name|hilread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|HILLOOP
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|hilloopdev
modifier|*
name|dptr
decl_stmt|;
specifier|register
name|int
name|cc
decl_stmt|;
name|u_char
name|device
init|=
name|HILUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|HILBUFSIZE
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * XXX: Don't do this since HP-UX doesn't. 	 * 	 * Check device number. 	 * This check is necessary since loop can reconfigure. 	 */
block|if (device> hilp->hl_maxdev) 		return(ENODEV);
endif|#
directive|endif
name|dptr
operator|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_READIN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
operator|(
name|void
operator|)
name|splhil
argument_list|()
expr_stmt|;
while|while
condition|(
name|dptr
operator|->
name|hd_queue
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_NOBLOCK
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|dptr
operator|->
name|hd_flags
operator||=
name|HIL_ASLEEP
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dptr
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|hilin
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|cc
operator|=
name|hilq_to_b
argument_list|(
operator|&
name|dptr
operator|->
name|hd_queue
argument_list|,
name|buf
argument_list|,
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|HILBUFSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
break|break;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|cc
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|hilioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|HILLOOP
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|char
name|device
init|=
name|HILUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hilloopdev
modifier|*
name|dptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|u_char
name|hold
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilioctl(%d): dev %x cmd %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|device
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dptr
operator|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Don't allow hardware ioctls on virtual devices. 	 * Note that though these are the BSD names, they have the same 	 * values as the HP-UX equivalents so we catch them as well. 	 */
if|if
condition|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_PSEUDO
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|HILIOCSC
case|:
case|case
name|HILIOCID
case|:
case|case
name|OHILIOCID
case|:
case|case
name|HILIOCRN
case|:
case|case
name|HILIOCRS
case|:
case|case
name|HILIOCED
case|:
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 		 * XXX: should also return ENODEV but HP-UX compat 		 * breaks if we do.  They work ok right now because 		 * we only recognize one keyboard on the loop.  This 		 * will have to change if we remove that restriction. 		 */
case|case
name|HILIOCAROFF
case|:
case|case
name|HILIOCAR1
case|:
case|case
name|HILIOCAR2
case|:
break|break;
default|default:
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
return|return
operator|(
name|hpuxhilioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
return|;
endif|#
directive|endif
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|hilp
operator|->
name|hl_cmdbuf
argument_list|,
name|HILBUFSIZE
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
name|device
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|HILIOCSBP
case|:
comment|/* Send four data bytes to the tone gererator. */
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_STARTCMD
argument_list|,
name|data
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Send the trigger beeper command to the 8042. */
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OHILIOCRRT
case|:
case|case
name|HILIOCRRT
case|:
comment|/* Transfer the real time to the 8042 data buffer */
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Read each byte of the real time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_READTIME
operator|+
name|i
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|hold
argument_list|)
expr_stmt|;
name|data
index|[
literal|4
operator|-
name|i
index|]
operator|=
name|hold
expr_stmt|;
block|}
break|break;
case|case
name|HILIOCRT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
operator|+
name|i
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|hold
argument_list|)
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
name|hold
expr_stmt|;
block|}
break|break;
case|case
name|HILIOCID
case|:
case|case
name|OHILIOCID
case|:
case|case
name|HILIOCSC
case|:
case|case
name|HILIOCRN
case|:
case|case
name|HILIOCRS
case|:
case|case
name|HILIOCED
case|:
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|device
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hilp
operator|->
name|hl_cmdbuf
argument_list|,
name|data
argument_list|,
name|hilp
operator|->
name|hl_cmdbp
operator|-
name|hilp
operator|->
name|hl_cmdbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|HILIOCAROFF
case|:
case|case
name|HILIOCAR1
case|:
case|case
name|HILIOCAR2
case|:
if|if
condition|(
name|hilp
operator|->
name|hl_kbddev
condition|)
block|{
name|hilp
operator|->
name|hl_cmddev
operator|=
name|hilp
operator|->
name|hl_kbddev
expr_stmt|;
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|hilp
operator|->
name|hl_kbddev
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_kbdflags
operator|&=
operator|~
operator|(
name|KBD_AR1
operator||
name|KBD_AR2
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|HILIOCAR1
condition|)
name|hilp
operator|->
name|hl_kbdflags
operator||=
name|KBD_AR1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|HILIOCAR2
condition|)
name|hilp
operator|->
name|hl_kbdflags
operator||=
name|KBD_AR2
expr_stmt|;
block|}
break|break;
case|case
name|HILIOCBEEP
case|:
name|hilbeep
argument_list|(
name|hilp
argument_list|,
operator|(
expr|struct
name|_hilbell
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIONBIO
case|:
name|dptr
operator|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|dptr
operator|->
name|hd_flags
operator||=
name|HIL_NOBLOCK
expr_stmt|;
else|else
name|dptr
operator|->
name|hd_flags
operator|&=
operator|~
name|HIL_NOBLOCK
expr_stmt|;
break|break;
comment|/* 	 * FIOASYNC must be present for FIONBIO above to work! 	 * (See fcntl in kern_descrip.c). 	 */
case|case
name|FIOASYNC
case|:
break|break;
case|case
name|HILIOCALLOCQ
case|:
name|error
operator|=
name|hilqalloc
argument_list|(
name|hilp
argument_list|,
operator|(
expr|struct
name|hilqinfo
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|HILIOCFREEQ
case|:
name|error
operator|=
name|hilqfree
argument_list|(
name|hilp
argument_list|,
operator|(
operator|(
expr|struct
name|hilqinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|qid
argument_list|)
expr_stmt|;
break|break;
case|case
name|HILIOCMAPQ
case|:
name|error
operator|=
name|hilqmap
argument_list|(
name|hilp
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|device
argument_list|)
expr_stmt|;
break|break;
case|case
name|HILIOCUNMAPQ
case|:
name|error
operator|=
name|hilqunmap
argument_list|(
name|hilp
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|device
argument_list|)
expr_stmt|;
break|break;
case|case
name|HILIOCHPUX
case|:
name|dptr
operator|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
expr_stmt|;
name|dptr
operator|->
name|hd_flags
operator||=
name|HIL_READIN
expr_stmt|;
name|dptr
operator|->
name|hd_flags
operator|&=
operator|~
name|HIL_QUEUEIN
expr_stmt|;
break|break;
case|case
name|HILIOCRESET
case|:
name|hilreset
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|HILIOCTEST
case|:
name|hildebug
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|hilp
operator|->
name|hl_cmddev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|hpuxhilioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|HILLOOP
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|char
name|device
init|=
name|HILUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hilloopdev
modifier|*
name|dptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|u_char
name|hold
decl_stmt|;
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|hilp
operator|->
name|hl_cmdbuf
argument_list|,
name|HILBUFSIZE
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
name|device
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|HILSC
case|:
case|case
name|HILID
case|:
case|case
name|HILRN
case|:
case|case
name|HILRS
case|:
case|case
name|HILED
case|:
case|case
name|HILP1
case|:
case|case
name|HILP2
case|:
case|case
name|HILP3
case|:
case|case
name|HILP4
case|:
case|case
name|HILP5
case|:
case|case
name|HILP6
case|:
case|case
name|HILP7
case|:
case|case
name|HILP
case|:
case|case
name|HILA1
case|:
case|case
name|HILA2
case|:
case|case
name|HILA3
case|:
case|case
name|HILA4
case|:
case|case
name|HILA5
case|:
case|case
name|HILA6
case|:
case|case
name|HILA7
case|:
case|case
name|HILA
case|:
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|device
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hilp
operator|->
name|hl_cmdbuf
argument_list|,
name|data
argument_list|,
name|hilp
operator|->
name|hl_cmdbp
operator|-
name|hilp
operator|->
name|hl_cmdbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|HILDKR
case|:
case|case
name|HILER1
case|:
case|case
name|HILER2
case|:
if|if
condition|(
name|hilp
operator|->
name|hl_kbddev
condition|)
block|{
name|hilp
operator|->
name|hl_cmddev
operator|=
name|hilp
operator|->
name|hl_kbddev
expr_stmt|;
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|hilp
operator|->
name|hl_kbddev
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_kbdflags
operator|&=
operator|~
operator|(
name|KBD_AR1
operator||
name|KBD_AR2
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|HILIOCAR1
condition|)
name|hilp
operator|->
name|hl_kbdflags
operator||=
name|KBD_AR1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|HILIOCAR2
condition|)
name|hilp
operator|->
name|hl_kbdflags
operator||=
name|KBD_AR2
expr_stmt|;
block|}
break|break;
case|case
name|EFTSBP
case|:
comment|/* Send four data bytes to the tone gererator. */
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_STARTCMD
argument_list|,
name|data
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Send the trigger beeper command to the 8042. */
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFTRRT
case|:
comment|/* Transfer the real time to the 8042 data buffer */
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Read each byte of the real time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_READTIME
operator|+
name|i
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|hold
argument_list|)
expr_stmt|;
name|data
index|[
literal|4
operator|-
name|i
index|]
operator|=
name|hold
expr_stmt|;
block|}
break|break;
case|case
name|EFTRT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
operator|+
name|i
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|hold
argument_list|)
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
name|hold
expr_stmt|;
block|}
break|break;
case|case
name|EFTRLC
case|:
case|case
name|EFTRCC
case|:
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|hold
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|hold
expr_stmt|;
break|break;
case|case
name|EFTSRPG
case|:
case|case
name|EFTSRD
case|:
case|case
name|EFTSRR
case|:
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
operator|(
name|cmd
operator|&
literal|0xFF
operator|)
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFTSBI
case|:
ifdef|#
directive|ifdef
name|hp800
comment|/* XXX big magic */
name|hold
operator|=
literal|7
operator|-
operator|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|data
operator|>>
literal|5
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0x84069008
operator||
operator|(
name|hold
operator|<<
literal|8
operator|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_STARTCMD
argument_list|,
name|data
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
literal|0xC4
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|hilbeep
argument_list|(
name|hilp
argument_list|,
operator|(
expr|struct
name|_hilbell
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|FIONBIO
case|:
name|dptr
operator|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|dptr
operator|->
name|hd_flags
operator||=
name|HIL_NOBLOCK
expr_stmt|;
else|else
name|dptr
operator|->
name|hd_flags
operator|&=
operator|~
name|HIL_NOBLOCK
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
break|break;
default|default:
name|hilp
operator|->
name|hl_cmddev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|hilp
operator|->
name|hl_cmddev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|hilmap
argument_list|(
argument|dev
argument_list|,
argument|off
argument_list|,
argument|prot
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|off
decl_stmt|,
name|prot
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|hilselect
argument_list|(
argument|dev
argument_list|,
argument|rw
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|HILLOOP
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|hilloopdev
modifier|*
name|dptr
decl_stmt|;
specifier|register
name|struct
name|hiliqueue
modifier|*
name|qp
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|;
name|int
name|s
decl_stmt|,
name|device
decl_stmt|;
if|if
condition|(
name|rw
operator|==
name|FWRITE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|device
operator|=
name|HILUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Read interface. 	 * Return 1 if there is something in the queue, 0 ow. 	 */
name|dptr
operator|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
expr_stmt|;
if|if
condition|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_READIN
condition|)
block|{
name|s
operator|=
name|splhil
argument_list|()
expr_stmt|;
if|if
condition|(
name|dptr
operator|->
name|hd_queue
operator|.
name|c_cc
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|dptr
operator|->
name|hd_selr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make sure device is alive and real (or the loop device). 	 * Note that we do not do this for the read interface. 	 * This is primarily to be consistant with HP-UX. 	 */
if|if
condition|(
name|device
operator|&&
operator|(
name|dptr
operator|->
name|hd_flags
operator|&
operator|(
name|HIL_ALIVE
operator||
name|HIL_PSEUDO
operator|)
operator|)
operator|!=
name|HIL_ALIVE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Select on loop device is special. 	 * Check to see if there are any data for any loop device 	 * provided it is associated with a queue belonging to this user. 	 */
if|if
condition|(
name|device
operator|==
literal|0
condition|)
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
name|hildevmask
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * Must check everybody with interrupts blocked to prevent races. 	 */
name|s
operator|=
name|splhil
argument_list|()
expr_stmt|;
for|for
control|(
name|qp
operator|=
name|hilp
operator|->
name|hl_queue
init|;
name|qp
operator|<
operator|&
name|hilp
operator|->
name|hl_queue
index|[
name|NHILQ
index|]
condition|;
name|qp
operator|++
control|)
if|if
condition|(
name|qp
operator|->
name|hq_procp
operator|==
name|p
operator|&&
operator|(
name|mask
operator|&
name|qp
operator|->
name|hq_devmask
operator|)
operator|&&
name|qp
operator|->
name|hq_eventqueue
operator|->
name|hil_evqueue
operator|.
name|head
operator|!=
name|qp
operator|->
name|hq_eventqueue
operator|->
name|hil_evqueue
operator|.
name|tail
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|dptr
operator|->
name|hd_selr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|hilint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|hp300
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
literal|0
index|]
decl_stmt|;
comment|/* XXX how do we know on 300? */
else|#
directive|else
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|unit
index|]
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|hil_dev
modifier|*
name|hildevice
init|=
name|hilp
operator|->
name|hl_addr
decl_stmt|;
name|u_char
name|c
decl_stmt|,
name|stat
decl_stmt|;
name|stat
operator|=
name|READHILSTAT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|c
operator|=
name|READHILDATA
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
comment|/* clears interrupt */
name|hil_process_int
argument_list|(
name|hilp
argument_list|,
name|stat
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|"ite.h"
end_include

begin_expr_stmt
name|hil_process_int
argument_list|(
name|hilp
argument_list|,
name|stat
argument_list|,
name|c
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|u_char
name|stat
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_EVENTS
condition|)
name|printf
argument_list|(
literal|"hilint: %x %x\n"
argument_list|,
name|stat
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* the shift enables the compiler to generate a jump table */
switch|switch
condition|(
operator|(
name|stat
operator|>>
name|HIL_SSHIFT
operator|)
operator|&
name|HIL_SMASK
condition|)
block|{
if|#
directive|if
name|NITE
operator|>
literal|0
case|case
name|HIL_KEY
case|:
case|case
name|HIL_SHIFT
case|:
case|case
name|HIL_CTRL
case|:
case|case
name|HIL_CTRLSHIFT
case|:
name|itefilter
argument_list|(
name|stat
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|HIL_STATUS
case|:
comment|/* The status info. */
if|if
condition|(
name|c
operator|&
name|HIL_ERROR
condition|)
block|{
name|hilp
operator|->
name|hl_cmddone
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|HIL_RECONFIG
condition|)
name|hilconfig
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|&
name|HIL_COMMAND
condition|)
block|{
if|if
condition|(
name|c
operator|&
name|HIL_POLLDATA
condition|)
comment|/* End of data */
name|hilevent
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
else|else
comment|/* End of command */
name|hilp
operator|->
name|hl_cmdending
operator|=
name|TRUE
expr_stmt|;
name|hilp
operator|->
name|hl_actdev
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|&
name|HIL_POLLDATA
condition|)
block|{
comment|/* Start of polled data */
if|if
condition|(
name|hilp
operator|->
name|hl_actdev
operator|!=
literal|0
condition|)
name|hilevent
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_actdev
operator|=
operator|(
name|c
operator|&
name|HIL_DEVMASK
operator|)
expr_stmt|;
name|hilp
operator|->
name|hl_pollbp
operator|=
name|hilp
operator|->
name|hl_pollbuf
expr_stmt|;
block|}
else|else
block|{
comment|/* Start of command */
if|if
condition|(
name|hilp
operator|->
name|hl_cmddev
operator|==
operator|(
name|c
operator|&
name|HIL_DEVMASK
operator|)
condition|)
block|{
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_actdev
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return;
case|case
name|HIL_DATA
case|:
if|if
condition|(
name|hilp
operator|->
name|hl_actdev
operator|!=
literal|0
condition|)
comment|/* Collecting poll data */
operator|*
name|hilp
operator|->
name|hl_pollbp
operator|++
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|hilp
operator|->
name|hl_cmddev
operator|!=
literal|0
condition|)
comment|/* Collecting cmd data */
if|if
condition|(
name|hilp
operator|->
name|hl_cmdending
condition|)
block|{
name|hilp
operator|->
name|hl_cmddone
operator|=
name|TRUE
expr_stmt|;
name|hilp
operator|->
name|hl_cmdending
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
operator|*
name|hilp
operator|->
name|hl_cmdbp
operator|++
operator|=
name|c
expr_stmt|;
return|return;
case|case
literal|0
case|:
comment|/* force full jump table */
default|default:
return|return;
block|}
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PANICBUTTON
argument_list|)
end_if

begin_define
define|#
directive|define
name|PANICBUTTON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Optimized macro to compute:  *	eq->head == (eq->tail + 1) % eq->size  * i.e. has tail caught up with head.  We do this because 32 bit long  * remaidering is expensive (a function call with our compiler).  */
end_comment

begin_define
define|#
directive|define
name|HQFULL
parameter_list|(
name|eq
parameter_list|)
value|(((eq)->head?(eq)->head:(eq)->size) == (eq)->tail+1)
end_define

begin_define
define|#
directive|define
name|HQVALID
parameter_list|(
name|eq
parameter_list|)
define|\
value|((eq)->size == HEVQSIZE&& (eq)->tail>= 0&& (eq)->tail< HEVQSIZE)
end_define

begin_macro
name|hilevent
argument_list|(
argument|hilp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hilloop
modifier|*
name|hilp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hilloopdev
modifier|*
name|dptr
init|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|hilp
operator|->
name|hl_actdev
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|mask
decl_stmt|,
name|qnum
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
specifier|register
name|HILQ
modifier|*
name|hq
decl_stmt|;
name|struct
name|timeval
name|ourtime
decl_stmt|;
name|hil_packet
modifier|*
name|proto
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len0
decl_stmt|;
name|long
name|tenths
decl_stmt|;
ifdef|#
directive|ifdef
name|PANICBUTTON
specifier|static
name|int
name|first
decl_stmt|;
specifier|extern
name|int
name|panicbutton
decl_stmt|;
name|cp
operator|=
name|hilp
operator|->
name|hl_pollbuf
expr_stmt|;
if|if
condition|(
name|panicbutton
operator|&&
operator|(
operator|*
name|cp
operator|&
name|HIL_KBDDATA
operator|)
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|==
literal|0x4E
condition|)
name|first
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|first
operator|&&
operator|*
name|cp
operator|==
literal|0x46
operator|&&
operator|!
name|panicstr
condition|)
name|panic
argument_list|(
literal|"are we having fun yet?"
argument_list|)
expr_stmt|;
else|else
name|first
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_EVENTS
condition|)
block|{
name|printf
argument_list|(
literal|"hilevent: dev %d pollbuf: "
argument_list|,
name|hilp
operator|->
name|hl_actdev
argument_list|)
expr_stmt|;
name|printhilpollbuf
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Note that HIL_READIN effectively "shuts off" any queues 	 * that may have been in use at the time of an HILIOCHPUX call. 	 */
if|if
condition|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_READIN
condition|)
block|{
name|hpuxhilevent
argument_list|(
name|hilp
argument_list|,
name|dptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this device isn't on any queue or there are no data 	 * in the packet (can this happen?) do nothing. 	 */
if|if
condition|(
name|dptr
operator|->
name|hd_qmask
operator|==
literal|0
operator|||
operator|(
name|len0
operator|=
name|hilp
operator|->
name|hl_pollbp
operator|-
name|hilp
operator|->
name|hl_pollbuf
operator|)
operator|<=
literal|0
condition|)
return|return;
comment|/* 	 * Everybody gets the same time stamp 	 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|ourtime
operator|=
name|time
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tenths
operator|=
operator|(
name|ourtime
operator|.
name|tv_sec
operator|*
literal|100
operator|)
operator|+
operator|(
name|ourtime
operator|.
name|tv_usec
operator|/
literal|10000
operator|)
expr_stmt|;
name|proto
operator|=
name|NULL
expr_stmt|;
name|mask
operator|=
name|dptr
operator|->
name|hd_qmask
expr_stmt|;
for|for
control|(
name|qnum
operator|=
literal|0
init|;
name|mask
condition|;
name|qnum
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
name|hilqmask
argument_list|(
name|qnum
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|mask
operator|&=
operator|~
name|hilqmask
argument_list|(
name|qnum
argument_list|)
expr_stmt|;
name|hq
operator|=
name|hilp
operator|->
name|hl_queue
index|[
name|qnum
index|]
operator|.
name|hq_eventqueue
expr_stmt|;
comment|/* 		 * Ensure that queue fields that we rely on are valid 		 * and that there is space in the queue.  If either 		 * test fails, we just skip this queue. 		 */
if|if
condition|(
operator|!
name|HQVALID
argument_list|(
operator|&
name|hq
operator|->
name|hil_evqueue
argument_list|)
operator|||
name|HQFULL
argument_list|(
operator|&
name|hq
operator|->
name|hil_evqueue
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Copy data to queue. 		 * If this is the first queue we construct the packet 		 * with length, timestamp and poll buffer data. 		 * For second and sucessive packets we just duplicate 		 * the first packet. 		 */
name|pp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|hq
operator|->
name|hil_event
index|[
name|hq
operator|->
name|hil_evqueue
operator|.
name|tail
index|]
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|NULL
condition|)
block|{
name|proto
operator|=
operator|(
name|hil_packet
operator|*
operator|)
name|pp
expr_stmt|;
name|cp
operator|=
name|hilp
operator|->
name|hl_pollbuf
expr_stmt|;
name|len
operator|=
name|len0
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|len
operator|+
literal|6
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|hilp
operator|->
name|hl_actdev
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|pp
operator|=
name|tenths
expr_stmt|;
name|pp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
do|do
operator|*
name|pp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|len
condition|)
do|;
block|}
else|else
operator|*
operator|(
name|hil_packet
operator|*
operator|)
name|pp
operator|=
operator|*
name|proto
expr_stmt|;
if|if
condition|(
operator|++
name|hq
operator|->
name|hil_evqueue
operator|.
name|tail
operator|==
name|hq
operator|->
name|hil_evqueue
operator|.
name|size
condition|)
name|hq
operator|->
name|hil_evqueue
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Wake up anyone selecting on this device or the loop itself 	 */
name|selwakeup
argument_list|(
operator|&
name|dptr
operator|->
name|hd_selr
argument_list|)
expr_stmt|;
name|dptr
operator|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|HILLOOPDEV
index|]
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|dptr
operator|->
name|hd_selr
argument_list|)
expr_stmt|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|HQFULL
end_undef

begin_expr_stmt
name|hpuxhilevent
argument_list|(
name|hilp
argument_list|,
name|dptr
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hilloopdev
modifier|*
name|dptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|timeval
name|ourtime
decl_stmt|;
name|long
name|tstamp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Everybody gets the same time stamp 	 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|ourtime
operator|=
name|time
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tstamp
operator|=
operator|(
name|ourtime
operator|.
name|tv_sec
operator|*
literal|100
operator|)
operator|+
operator|(
name|ourtime
operator|.
name|tv_usec
operator|/
literal|10000
operator|)
expr_stmt|;
comment|/* 	 * Each packet that goes into the buffer must be preceded by the 	 * number of bytes in the packet, and the timestamp of the packet. 	 * This adds 5 bytes to the packet size. Make sure there is enough 	 * room in the buffer for it, and if not, toss the packet. 	 */
name|len
operator|=
name|hilp
operator|->
name|hl_pollbp
operator|-
name|hilp
operator|->
name|hl_pollbuf
expr_stmt|;
if|if
condition|(
name|dptr
operator|->
name|hd_queue
operator|.
name|c_cc
operator|<=
operator|(
name|HILMAXCLIST
operator|-
operator|(
name|len
operator|+
literal|5
operator|)
operator|)
condition|)
block|{
name|putc
argument_list|(
name|len
operator|+
literal|5
argument_list|,
operator|&
name|dptr
operator|->
name|hd_queue
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tstamp
argument_list|,
sizeof|sizeof
name|tstamp
argument_list|,
operator|&
name|dptr
operator|->
name|hd_queue
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hilp
operator|->
name|hl_pollbuf
argument_list|,
name|len
argument_list|,
operator|&
name|dptr
operator|->
name|hd_queue
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wake up any one blocked on a read or select 	 */
if|if
condition|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_ASLEEP
condition|)
block|{
name|dptr
operator|->
name|hd_flags
operator|&=
operator|~
name|HIL_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dptr
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|dptr
operator|->
name|hd_selr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Shared queue manipulation routines  */
end_comment

begin_expr_stmt
name|hilqalloc
argument_list|(
name|hilp
argument_list|,
name|qip
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hilqinfo
modifier|*
name|qip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilqalloc(%d): addr %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|qip
operator|->
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|hilqfree
argument_list|(
name|hilp
argument_list|,
name|qnum
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|qnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilqfree(%d): qnum %d\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|hilqmap
argument_list|(
name|hilp
argument_list|,
name|qnum
argument_list|,
name|device
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|qnum
decl_stmt|,
name|device
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|hilloopdev
modifier|*
name|dptr
init|=
operator|&
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilqmap(%d): qnum %d device %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|qnum
argument_list|,
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qnum
operator|>=
name|NHILQ
operator|||
name|hilp
operator|->
name|hl_queue
index|[
name|qnum
index|]
operator|.
name|hq_procp
operator|!=
name|p
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|dptr
operator|->
name|hd_flags
operator|&
name|HIL_QUEUEIN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|dptr
operator|->
name|hd_qmask
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
name|dptr
operator|->
name|hd_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|hilp
operator|->
name|hl_queue
index|[
name|qnum
index|]
operator|.
name|hq_devmask
operator||=
name|hildevmask
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|->
name|hd_qmask
operator|==
literal|0
condition|)
name|dptr
operator|->
name|hd_uid
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
expr_stmt|;
name|s
operator|=
name|splhil
argument_list|()
expr_stmt|;
name|dptr
operator|->
name|hd_qmask
operator||=
name|hilqmask
argument_list|(
name|qnum
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_MASK
condition|)
name|printf
argument_list|(
literal|"hilqmap(%d): devmask %x qmask %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|hilp
operator|->
name|hl_queue
index|[
name|qnum
index|]
operator|.
name|hq_devmask
argument_list|,
name|dptr
operator|->
name|hd_qmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|hilqunmap
argument_list|(
name|hilp
argument_list|,
name|qnum
argument_list|,
name|device
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|qnum
decl_stmt|,
name|device
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilqunmap(%d): qnum %d device %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|qnum
argument_list|,
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qnum
operator|>=
name|NHILQ
operator|||
name|hilp
operator|->
name|hl_queue
index|[
name|qnum
index|]
operator|.
name|hq_procp
operator|!=
name|p
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hilp
operator|->
name|hl_queue
index|[
name|qnum
index|]
operator|.
name|hq_devmask
operator|&=
operator|~
name|hildevmask
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhil
argument_list|()
expr_stmt|;
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
operator|.
name|hd_qmask
operator|&=
operator|~
name|hilqmask
argument_list|(
name|qnum
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_MASK
condition|)
name|printf
argument_list|(
literal|"hilqunmap(%d): devmask %x qmask %x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|hilp
operator|->
name|hl_queue
index|[
name|qnum
index|]
operator|.
name|hq_devmask
argument_list|,
name|hilp
operator|->
name|hl_device
index|[
name|device
index|]
operator|.
name|hd_qmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Cooked keyboard functions for ite driver.  * There is only one "cooked" ITE keyboard (the first keyboard found)  * per loop.  There may be other keyboards, but they will always be "raw".  */
end_comment

begin_macro
name|kbdbell
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|unit
index|]
decl_stmt|;
name|hilbeep
argument_list|(
name|hilp
argument_list|,
operator|&
name|default_bell
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|kbdenable
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hil_dev
modifier|*
name|hildevice
init|=
name|hilp
operator|->
name|hl_addr
decl_stmt|;
name|char
name|db
decl_stmt|;
comment|/* Set the autorepeat rate register */
name|db
operator|=
name|ar_format
argument_list|(
name|KBD_ARR
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hildevice
argument_list|,
name|HIL_SETARR
argument_list|,
operator|&
name|db
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set the autorepeat delay register */
name|db
operator|=
name|ar_format
argument_list|(
name|KBD_ARD
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hildevice
argument_list|,
name|HIL_SETARD
argument_list|,
operator|&
name|db
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
name|send_hil_cmd
argument_list|(
name|hildevice
argument_list|,
name|HIL_INTON
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|kbddisable
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/*  * XXX: read keyboard directly and return code.  * Used by console getchar routine.  Could really screw up anybody  * reading from the keyboard in the normal, interrupt driven fashion.  */
end_comment

begin_macro
name|kbdgetc
argument_list|(
argument|unit
argument_list|,
argument|statp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
modifier|*
name|statp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hil_dev
modifier|*
name|hildevice
init|=
name|hilp
operator|->
name|hl_addr
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|stat
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhil
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|stat
operator|=
name|READHILSTAT
argument_list|(
name|hildevice
argument_list|)
operator|)
operator|&
name|HIL_DATA_RDY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|c
operator|=
name|READHILDATA
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|statp
operator|=
name|stat
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Recoginize and clear keyboard generated NMIs.  * Returns 1 if it was ours, 0 otherwise.  Note that we cannot use  * send_hil_cmd() to issue the clear NMI command as that would actually  * lower the priority to splimp() and it doesn't wait for the completion  * of the command.  Either of these conditions could result in the  * interrupt reoccuring.  Note that we issue the CNMT command twice.  * This seems to be needed, once is not always enough!?!  */
end_comment

begin_macro
name|kbdnmi
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|hp300
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
literal|0
index|]
decl_stmt|;
comment|/* XXX how do we know on 300? */
else|#
directive|else
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|unit
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
if|if
condition|(
operator|(
operator|*
name|KBDNMISTAT
operator|&
name|KBDNMI
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|HILWAIT
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_CNMT
argument_list|)
expr_stmt|;
name|HILWAIT
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_CNMT
argument_list|)
expr_stmt|;
name|HILWAIT
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|HILSECURITY
value|0x33
end_define

begin_define
define|#
directive|define
name|HILIDENTIFY
value|0x03
end_define

begin_define
define|#
directive|define
name|HILSCBIT
value|0x04
end_define

begin_comment
comment|/*  * Called at boot time to print out info about interesting devices  */
end_comment

begin_macro
name|hilinfo
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hilloop
modifier|*
name|hilp
init|=
operator|&
name|hilloop
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|id
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|struct
name|kbdmap
modifier|*
name|km
decl_stmt|;
comment|/* 	 * Keyboard info. 	 */
if|if
condition|(
name|hilp
operator|->
name|hl_kbddev
condition|)
block|{
name|printf
argument_list|(
literal|"hil%d: "
argument_list|,
name|hilp
operator|->
name|hl_kbddev
argument_list|)
expr_stmt|;
for|for
control|(
name|km
operator|=
name|kbd_map
init|;
name|km
operator|->
name|kbd_code
condition|;
name|km
operator|++
control|)
if|if
condition|(
name|km
operator|->
name|kbd_code
operator|==
name|hilp
operator|->
name|hl_kbdlang
condition|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|km
operator|->
name|kbd_desc
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"keyboard\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * ID module. 	 * Attempt to locate the first ID module and print out its 	 * security code.  Is this a good idea?? 	 */
name|id
operator|=
name|hiliddev
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
name|id
expr_stmt|;
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|id
argument_list|,
name|HILSECURITY
argument_list|)
expr_stmt|;
name|len
operator|=
name|hilp
operator|->
name|hl_cmdbp
operator|-
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"hil%d: security code"
argument_list|,
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|len
condition|;
name|id
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|hilp
operator|->
name|hl_cmdbuf
index|[
name|id
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|id
operator|++
operator|<
literal|16
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|HILAR1
value|0x3E
end_define

begin_define
define|#
directive|define
name|HILAR2
value|0x3F
end_define

begin_comment
comment|/*  * Called after the loop has reconfigured.  Here we need to:  *	- determine how many devices are on the loop  *	  (some may have been added or removed)  *	- locate the ITE keyboard (if any) and ensure  *	  that it is in the proper state (raw or cooked)  *	  and is set to use the proper language mapping table  *	- ensure all other keyboards are raw  * Note that our device state is now potentially invalid as  * devices may no longer be where they were.  What we should  * do here is either track where the devices went and move  * state around accordingly or, more simply, just mark all  * devices as HIL_DERROR and don't allow any further use until  * they are closed.  This is a little too brutal for my tastes,  * we prefer to just assume people won't move things around.  */
end_comment

begin_expr_stmt
name|hilconfig
argument_list|(
name|hilp
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|u_char
name|db
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhil
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_CONFIG
condition|)
block|{
name|printf
argument_list|(
literal|"hilconfig: reconfigured: "
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_READLPSTAT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LPSTAT %x, "
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_READLPCTRL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LPCTRL %x, "
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_READKBDSADR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"KBDSADR %x\n"
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|hilreport
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Determine how many devices are on the loop. 	 * Mark those as alive and real, all others as dead. 	 */
name|db
operator|=
literal|0
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_READLPSTAT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_maxdev
operator|=
name|db
operator|&
name|LPS_DEVMASK
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_CONFIG
condition|)
name|printf
argument_list|(
literal|"hilconfig: %d devices found\n"
argument_list|,
name|hilp
operator|->
name|hl_maxdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|db
operator|=
literal|1
init|;
name|db
operator|<
name|NHILD
condition|;
name|db
operator|++
control|)
block|{
if|if
condition|(
name|db
operator|<=
name|hilp
operator|->
name|hl_maxdev
condition|)
name|hilp
operator|->
name|hl_device
index|[
name|db
index|]
operator|.
name|hd_flags
operator||=
name|HIL_ALIVE
expr_stmt|;
else|else
name|hilp
operator|->
name|hl_device
index|[
name|db
index|]
operator|.
name|hd_flags
operator|&=
operator|~
name|HIL_ALIVE
expr_stmt|;
name|hilp
operator|->
name|hl_device
index|[
name|db
index|]
operator|.
name|hd_flags
operator|&=
operator|~
name|HIL_PSEUDO
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
operator|(
name|HDB_CONFIG
operator||
name|HDB_KEYBOARD
operator|)
condition|)
name|printf
argument_list|(
literal|"hilconfig: max device %d\n"
argument_list|,
name|hilp
operator|->
name|hl_maxdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hilp
operator|->
name|hl_maxdev
operator|==
literal|0
condition|)
block|{
name|hilp
operator|->
name|hl_kbddev
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Find out where the keyboards are and record the ITE keyboard 	 * (first one found).  If no keyboards found, we are all done. 	 */
name|db
operator|=
literal|0
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_READKBDSADR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_KEYBOARD
condition|)
name|printf
argument_list|(
literal|"hilconfig: keyboard: KBDSADR %x, old %d, new %d\n"
argument_list|,
name|db
argument_list|,
name|hilp
operator|->
name|hl_kbddev
argument_list|,
name|ffs
argument_list|(
operator|(
name|int
operator|)
name|db
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hilp
operator|->
name|hl_kbddev
operator|=
name|ffs
argument_list|(
operator|(
name|int
operator|)
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|hilp
operator|->
name|hl_kbddev
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Determine if the keyboard should be cooked or raw and configure it. 	 */
name|db
operator|=
operator|(
name|hilp
operator|->
name|hl_kbdflags
operator|&
name|KBD_RAW
operator|)
condition|?
literal|0
else|:
literal|1
operator|<<
operator|(
name|hilp
operator|->
name|hl_kbddev
operator|-
literal|1
operator|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_WRITEKBDSADR
argument_list|,
operator|&
name|db
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Re-enable autorepeat in raw mode, cooked mode AR is not affected. 	 */
if|if
condition|(
name|hilp
operator|->
name|hl_kbdflags
operator|&
operator|(
name|KBD_AR1
operator||
name|KBD_AR2
operator|)
condition|)
block|{
name|db
operator|=
operator|(
name|hilp
operator|->
name|hl_kbdflags
operator|&
name|KBD_AR1
operator|)
condition|?
name|HILAR1
else|:
name|HILAR2
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
name|hilp
operator|->
name|hl_kbddev
expr_stmt|;
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|hilp
operator|->
name|hl_kbddev
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Determine the keyboard language configuration, but don't 	 * override a user-specified setting. 	 */
name|db
operator|=
literal|0
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_READKBDLANG
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_KEYBOARD
condition|)
name|printf
argument_list|(
literal|"hilconfig: language: old %x new %x\n"
argument_list|,
name|hilp
operator|->
name|hl_kbdlang
argument_list|,
name|db
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hilp
operator|->
name|hl_kbdlang
operator|!=
name|KBD_SPECIAL
condition|)
block|{
name|struct
name|kbdmap
modifier|*
name|km
decl_stmt|;
for|for
control|(
name|km
operator|=
name|kbd_map
init|;
name|km
operator|->
name|kbd_code
condition|;
name|km
operator|++
control|)
if|if
condition|(
name|km
operator|->
name|kbd_code
operator|==
name|db
condition|)
block|{
name|hilp
operator|->
name|hl_kbdlang
operator|=
name|db
expr_stmt|;
comment|/* XXX */
name|kbd_keymap
operator|=
name|km
operator|->
name|kbd_keymap
expr_stmt|;
name|kbd_shiftmap
operator|=
name|km
operator|->
name|kbd_shiftmap
expr_stmt|;
name|kbd_ctrlmap
operator|=
name|km
operator|->
name|kbd_ctrlmap
expr_stmt|;
name|kbd_ctrlshiftmap
operator|=
name|km
operator|->
name|kbd_ctrlshiftmap
expr_stmt|;
name|kbd_stringmap
operator|=
name|km
operator|->
name|kbd_stringmap
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hilreset
argument_list|(
argument|hilp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hilloop
modifier|*
name|hilp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hil_dev
modifier|*
name|hildevice
init|=
name|hilp
operator|->
name|hl_addr
decl_stmt|;
name|u_char
name|db
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"hilreset(%x)\n"
argument_list|,
name|hilp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize the loop: reconfigure, don't report errors, 	 * cook keyboards, and enable autopolling. 	 */
name|db
operator|=
name|LPC_RECONF
operator||
name|LPC_KBDCOOK
operator||
name|LPC_NOERROR
operator||
name|LPC_AUTOPOLL
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hildevice
argument_list|,
name|HIL_WRITELPCTRL
argument_list|,
operator|&
name|db
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Delay one second for reconfiguration and then read the the 	 * data register to clear the interrupt (if the loop reconfigured). 	 */
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|READHILSTAT
argument_list|(
name|hildevice
argument_list|)
operator|&
name|HIL_DATA_RDY
condition|)
name|db
operator|=
name|READHILDATA
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
comment|/* 	 * The HIL loop may have reconfigured.  If so we proceed on, 	 * if not we loop until a successful reconfiguration is reported 	 * back to us.  The HIL loop will continue to attempt forever. 	 * Probably not very smart. 	 */
do|do
block|{
name|send_hil_cmd
argument_list|(
name|hildevice
argument_list|,
name|HIL_READLPSTAT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|db
operator|&
operator|(
name|LPS_CONFFAIL
operator||
name|LPS_CONFGOOD
operator|)
operator|)
operator|==
literal|0
condition|)
do|;
comment|/* 	 * At this point, the loop should have reconfigured. 	 * The reconfiguration interrupt has already called hilconfig() 	 * so the keyboard has been determined. 	 */
name|send_hil_cmd
argument_list|(
name|hildevice
argument_list|,
name|HIL_INTON
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hilbeep
argument_list|(
argument|hilp
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hilloop
modifier|*
name|hilp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|_hilbell
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|~
operator|(
operator|(
name|bp
operator|->
name|duration
operator|-
literal|10
operator|)
operator|/
literal|10
operator|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|bp
operator|->
name|frequency
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|hilp
operator|->
name|hl_addr
argument_list|,
name|HIL_SETTONE
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Locate and return the address of the first ID module, 0 if none present.  */
end_comment

begin_expr_stmt
name|hiliddev
argument_list|(
name|hilp
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_IDMODULE
condition|)
name|printf
argument_list|(
literal|"hiliddev(%x): max %d, looking for idmodule..."
argument_list|,
name|hilp
argument_list|,
name|hilp
operator|->
name|hl_maxdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|hilp
operator|->
name|hl_maxdev
condition|;
name|i
operator|++
control|)
block|{
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
name|i
expr_stmt|;
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|i
argument_list|,
name|HILIDENTIFY
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: the final condition checks to ensure that the 		 * device ID byte is in the range of the ID module (0x30-0x3F) 		 */
name|len
operator|=
name|hilp
operator|->
name|hl_cmdbp
operator|-
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
operator|(
name|hilp
operator|->
name|hl_cmdbuf
index|[
literal|1
index|]
operator|&
name|HILSCBIT
operator|)
operator|&&
operator|(
name|hilp
operator|->
name|hl_cmdbuf
index|[
literal|0
index|]
operator|&
literal|0xF0
operator|)
operator|==
literal|0x30
condition|)
block|{
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
name|i
expr_stmt|;
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|i
argument_list|,
name|HILSECURITY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hildebug
operator|&
name|HDB_IDMODULE
condition|)
if|if
condition|(
name|i
operator|<=
name|hilp
operator|->
name|hl_maxdev
condition|)
name|printf
argument_list|(
literal|"found at %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"not found\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|i
operator|<=
name|hilp
operator|->
name|hl_maxdev
condition|?
name|i
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_comment
comment|/*  * XXX map devno as expected by HP-UX  */
end_comment

begin_macro
name|hildevno
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|newdev
decl_stmt|;
name|newdev
operator|=
literal|24
operator|<<
literal|24
expr_stmt|;
ifdef|#
directive|ifdef
name|HILCOMPAT
comment|/* 	 * XXX compat check 	 * Don't convert old style specfiles already in correct format 	 */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dev
operator|&
literal|0xF
operator|)
operator|==
literal|0
condition|)
name|newdev
operator||=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|newdev
operator||=
operator|(
name|HILLOOP
argument_list|(
name|dev
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|HILUNIT
argument_list|(
name|dev
argument_list|)
operator|<<
literal|4
operator|)
expr_stmt|;
return|return
operator|(
name|newdev
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Low level routines which actually talk to the 8042 chip.  */
end_comment

begin_comment
comment|/*  * Send a command to the 8042 with zero or more bytes of data.  * If rdata is non-null, wait for and return a byte of data.  * We run at splimp() to make the transaction as atomic as  * possible without blocking the clock (is this necessary?)  */
end_comment

begin_expr_stmt
name|send_hil_cmd
argument_list|(
name|hildevice
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|,
name|rdata
argument_list|)
specifier|register
expr|struct
name|hil_dev
operator|*
name|hildevice
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_char
name|cmd
decl_stmt|,
modifier|*
name|data
decl_stmt|,
name|dlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|rdata
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
name|status
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
while|while
condition|(
name|dlen
operator|--
condition|)
block|{
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILDATA
argument_list|(
name|hildevice
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdata
condition|)
block|{
do|do
block|{
name|HILDATAWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|status
operator|=
name|READHILSTAT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
operator|*
name|rdata
operator|=
name|READHILDATA
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
name|status
operator|>>
name|HIL_SSHIFT
operator|)
operator|&
name|HIL_SMASK
operator|)
operator|!=
name|HIL_68K
condition|)
do|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Send a command to a device on the loop.  * Since only one command can be active on the loop at any time,  * we must ensure that we are not interrupted during this process.  * Hence we mask interrupts to prevent potential access from most  * interrupt routines and turn off auto-polling to disable the  * internally generated poll commands.  *  * splhigh is extremely conservative but insures atomic operation,  * splimp (clock only interrupts) seems to be good enough in practice.  */
end_comment

begin_expr_stmt
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|device
argument_list|,
name|cmd
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|device
decl_stmt|,
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hil_dev
modifier|*
name|hildevice
init|=
name|hilp
operator|->
name|hl_addr
decl_stmt|;
name|u_char
name|status
decl_stmt|,
name|c
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|polloff
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the command and device info to the chip 	 */
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|HIL_STARTCMD
argument_list|)
expr_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILDATA
argument_list|(
name|hildevice
argument_list|,
literal|8
operator|+
name|device
argument_list|)
expr_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILDATA
argument_list|(
name|hildevice
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILDATA
argument_list|(
name|hildevice
argument_list|,
name|HIL_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* 	 * Trigger the command and wait for completion 	 */
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|HIL_TRIGGER
argument_list|)
expr_stmt|;
name|hilp
operator|->
name|hl_cmddone
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
name|HILDATAWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|status
operator|=
name|READHILSTAT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|c
operator|=
name|READHILDATA
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|hil_process_int
argument_list|(
name|hilp
argument_list|,
name|status
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hilp
operator|->
name|hl_cmddone
condition|)
do|;
name|pollon
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Turn auto-polling off and on.  * Also disables and enable auto-repeat.  Why?  */
end_comment

begin_expr_stmt
name|polloff
argument_list|(
name|hildevice
argument_list|)
specifier|register
expr|struct
name|hil_dev
operator|*
name|hildevice
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|db
decl_stmt|;
comment|/* 	 * Turn off auto repeat 	 */
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|HIL_SETARR
argument_list|)
expr_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILDATA
argument_list|(
name|hildevice
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off auto-polling 	 */
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|HIL_READLPCTRL
argument_list|)
expr_stmt|;
name|HILDATAWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|db
operator|=
name|READHILDATA
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|db
operator|&=
operator|~
name|LPC_AUTOPOLL
expr_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|HIL_WRITELPCTRL
argument_list|)
expr_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILDATA
argument_list|(
name|hildevice
argument_list|,
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * Must wait til polling is really stopped 	 */
do|do
block|{
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|HIL_READBUSY
argument_list|)
expr_stmt|;
name|HILDATAWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|db
operator|=
name|READHILDATA
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|db
operator|&
name|BSY_LOOPBUSY
condition|)
do|;
block|}
end_block

begin_expr_stmt
name|pollon
argument_list|(
name|hildevice
argument_list|)
specifier|register
expr|struct
name|hil_dev
operator|*
name|hildevice
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|db
decl_stmt|;
comment|/* 	 * Turn on auto polling 	 */
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|HIL_READLPCTRL
argument_list|)
expr_stmt|;
name|HILDATAWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|db
operator|=
name|READHILDATA
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|db
operator||=
name|LPC_AUTOPOLL
expr_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|HIL_WRITELPCTRL
argument_list|)
expr_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILDATA
argument_list|(
name|hildevice
argument_list|,
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * Turn on auto repeat 	 */
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILCMD
argument_list|(
name|hildevice
argument_list|,
name|HIL_SETARR
argument_list|)
expr_stmt|;
name|HILWAIT
argument_list|(
name|hildevice
argument_list|)
expr_stmt|;
name|WRITEHILDATA
argument_list|(
name|hildevice
argument_list|,
name|ar_format
argument_list|(
name|KBD_ARR
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
name|printhilpollbuf
argument_list|(
name|hilp
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|cp
operator|=
name|hilp
operator|->
name|hl_pollbuf
expr_stmt|;
name|len
operator|=
name|hilp
operator|->
name|hl_pollbp
operator|-
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|hilp
operator|->
name|hl_pollbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|printhilcmdbuf
argument_list|(
name|hilp
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|cp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|len
operator|=
name|hilp
operator|->
name|hl_cmdbp
operator|-
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|hilp
operator|->
name|hl_cmdbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hilreport
argument_list|(
name|hilp
argument_list|)
specifier|register
expr|struct
name|hilloop
operator|*
name|hilp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|s
init|=
name|splhil
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|hilp
operator|->
name|hl_maxdev
condition|;
name|i
operator|++
control|)
block|{
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
name|i
expr_stmt|;
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|i
argument_list|,
name|HILIDENTIFY
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"hil%d: id: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printhilcmdbuf
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
name|len
operator|=
name|hilp
operator|->
name|hl_cmdbp
operator|-
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
operator|(
name|hilp
operator|->
name|hl_cmdbuf
index|[
literal|1
index|]
operator|&
name|HILSCBIT
operator|)
condition|)
block|{
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
name|i
expr_stmt|;
name|send_hildev_cmd
argument_list|(
name|hilp
argument_list|,
name|i
argument_list|,
name|HILSECURITY
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"hil%d: sc: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printhilcmdbuf
argument_list|(
name|hilp
argument_list|)
expr_stmt|;
block|}
block|}
name|hilp
operator|->
name|hl_cmdbp
operator|=
name|hilp
operator|->
name|hl_cmdbuf
expr_stmt|;
name|hilp
operator|->
name|hl_cmddev
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

