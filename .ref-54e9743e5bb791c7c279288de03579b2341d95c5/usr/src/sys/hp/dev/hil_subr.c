begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1982, 1986, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.proprietary.c%  *  * from: Utah $Hdr: hil_subr.c 1.1 91/11/19$  *  *	@(#)hil_subr.c	8.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/clist.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/hilreg.h>
end_include

begin_comment
comment|/*  * XXX this file only exists to separate out the AT&T tainted code.  */
end_comment

begin_comment
comment|/*  * This is just a copy of the virgin q_to_b routine with minor  * optimizations for HIL use.  It is used because we don't have  * to raise the priority to spltty() for most of the clist manipulations.  */
end_comment

begin_expr_stmt
name|hilq_to_b
argument_list|(
name|q
argument_list|,
name|cp
argument_list|,
name|cc
argument_list|)
specifier|register
expr|struct
name|clist
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cblock
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|nc
decl_stmt|;
name|char
modifier|*
name|acp
decl_stmt|;
name|int
name|s
decl_stmt|;
specifier|extern
name|char
name|cwaiting
decl_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|splhil
argument_list|()
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|c_cc
operator|<=
literal|0
condition|)
block|{
name|q
operator|->
name|c_cc
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|c_cf
operator|=
name|q
operator|->
name|c_cl
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|acp
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|cc
condition|)
block|{
name|nc
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cblock
argument_list|)
operator|-
operator|(
operator|(
name|int
operator|)
name|q
operator|->
name|c_cf
operator|&
name|CROUND
operator|)
expr_stmt|;
name|nc
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|nc
operator|=
name|min
argument_list|(
name|nc
argument_list|,
name|q
operator|->
name|c_cc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|q
operator|->
name|c_cf
argument_list|,
name|cp
argument_list|,
operator|(
name|unsigned
operator|)
name|nc
argument_list|)
expr_stmt|;
name|q
operator|->
name|c_cf
operator|+=
name|nc
expr_stmt|;
name|q
operator|->
name|c_cc
operator|-=
name|nc
expr_stmt|;
name|cc
operator|-=
name|nc
expr_stmt|;
name|cp
operator|+=
name|nc
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|c_cc
operator|<=
literal|0
condition|)
block|{
name|bp
operator|=
operator|(
expr|struct
name|cblock
operator|*
operator|)
operator|(
name|q
operator|->
name|c_cf
operator|-
literal|1
operator|)
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|cblock
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|&
operator|~
name|CROUND
operator|)
expr_stmt|;
name|q
operator|->
name|c_cf
operator|=
name|q
operator|->
name|c_cl
operator|=
name|NULL
expr_stmt|;
name|spltty
argument_list|()
expr_stmt|;
name|bp
operator|->
name|c_next
operator|=
name|cfreelist
expr_stmt|;
name|cfreelist
operator|=
name|bp
expr_stmt|;
name|cfreecount
operator|+=
name|CBSIZE
expr_stmt|;
if|if
condition|(
name|cwaiting
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|cwaiting
argument_list|)
expr_stmt|;
name|cwaiting
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|q
operator|->
name|c_cf
operator|&
name|CROUND
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|=
operator|(
expr|struct
name|cblock
operator|*
operator|)
operator|(
name|q
operator|->
name|c_cf
operator|)
expr_stmt|;
name|bp
operator|--
expr_stmt|;
name|q
operator|->
name|c_cf
operator|=
name|bp
operator|->
name|c_next
operator|->
name|c_info
expr_stmt|;
name|spltty
argument_list|()
expr_stmt|;
name|bp
operator|->
name|c_next
operator|=
name|cfreelist
expr_stmt|;
name|cfreelist
operator|=
name|bp
expr_stmt|;
name|cfreecount
operator|+=
name|CBSIZE
expr_stmt|;
if|if
condition|(
name|cwaiting
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|cwaiting
argument_list|)
expr_stmt|;
name|cwaiting
operator|=
literal|0
expr_stmt|;
block|}
name|splhil
argument_list|()
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|acp
operator|)
return|;
block|}
end_block

end_unit

