begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)io.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * AT&T Bell Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|BSD
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_4_2
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD_4_2 */
end_comment

begin_define
define|#
directive|define
name|CAST
value|(char*)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|VENIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|CAST
value|(char*)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_define
define|#
directive|define
name|CAST
value|(unsigned char*)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VENIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|F_DUPFD
end_ifndef

begin_define
define|#
directive|define
name|F_DUPFD
value|0
end_define

begin_define
define|#
directive|define
name|NO_FCNTL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* F_DUPFD */
end_comment

begin_comment
comment|/* This module defines the following routines */
end_comment

begin_function_decl
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|create
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|chkrdwr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ispipe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sync_io
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|settemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|swap_iodoc_nm
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|initf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|restore
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|estabf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|chkpipe
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* This module references the following externals */
end_comment

begin_decl_stmt
specifier|extern
name|STKPTR
name|locstak
argument_list|()
decl_stmt|,
name|cpystak
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|chkpr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|heap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qtrim
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|serial
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_suffix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filesave
name|fdmap
index|[
name|MAXFILES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ======== input output and file copying ======== */
end_comment

begin_comment
comment|/*  * initialize temp file names  */
end_comment

begin_function
name|void
name|settemp
parameter_list|(
name|pid
parameter_list|)
name|char
modifier|*
name|pid
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
init|=
name|movstr
argument_list|(
name|pid
argument_list|,
name|tmpout
operator|+
literal|7
argument_list|)
decl_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|'.'
expr_stmt|;
name|temp_suffix
operator|=
name|sp
expr_stmt|;
name|serial
operator|=
literal|0
expr_stmt|;
name|states
operator|&=
operator|~
name|NO_TMP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set up a fileblk associated with the stream fd  */
end_comment

begin_function
name|void
name|initf
parameter_list|(
name|fd
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
specifier|register
name|SHFILE
name|f
init|=
name|standin
decl_stmt|;
name|f
operator|->
name|fdes
operator|=
name|fd
expr_stmt|;
name|f
operator|->
name|feval
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|flin
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set up an I/O stream that will cause reading from a string  */
end_comment

begin_function
name|int
name|estabf
parameter_list|(
name|s
parameter_list|,
name|fd
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|SHFILE
name|f
decl_stmt|;
operator|(
name|f
operator|=
name|standin
operator|)
operator|->
name|fdes
operator|=
name|fd
expr_stmt|;
name|fd
operator|->
name|_flag
operator|=
name|_IOREAD
expr_stmt|;
name|fd
operator|->
name|_base
operator|=
name|fd
operator|->
name|_ptr
operator|=
name|CAST
name|s
expr_stmt|;
name|fd
operator|->
name|_file
operator|=
name|F_STRING
expr_stmt|;
name|fd
operator|->
name|_cnt
operator|=
name|F_INFINITE
expr_stmt|;
name|f
operator|->
name|flin
operator|=
literal|1
expr_stmt|;
name|fd
operator|->
name|_flag
operator||=
operator|(
name|s
operator|==
literal|0
condition|?
name|_IOEOF
else|:
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|feof
argument_list|(
name|fd
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|push
argument_list|(
argument|af
argument_list|)
end_macro

begin_decl_stmt
name|SHFILE
name|af
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SHFILE
name|f
decl_stmt|;
operator|(
name|f
operator|=
name|af
operator|)
operator|->
name|fstak
operator|=
name|standin
expr_stmt|;
name|f
operator|->
name|feval
operator|=
literal|0
expr_stmt|;
name|standin
operator|=
name|f
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pop
argument_list|(
name|flag
argument_list|)
specifier|register
name|int
name|flag
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|SHFILE
name|f
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|int
name|fno
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|standin
operator|)
operator|->
name|fstak
condition|)
block|{
name|fd
operator|=
name|f
operator|->
name|fdes
expr_stmt|;
name|fno
operator|=
name|fileno
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
operator|&&
name|fno
operator|>
literal|0
operator|&&
name|fno
operator|!=
name|F_STRING
operator|&&
name|fno
operator|!=
name|INIO
operator|&&
name|fd
operator|!=
name|cpipe
index|[
name|INPIPE
index|]
condition|)
name|closefd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|standin
operator|=
name|f
operator|->
name|fstak
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * sync_io - flushes output buffer and positions stdin if necessary  */
end_comment

begin_function
name|void
name|sync_io
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|stdin
decl_stmt|;
name|p_flush
argument_list|()
expr_stmt|;
comment|/* position back the read-ahead characters */
if|if
condition|(
name|fp
operator|->
name|_cnt
condition|)
block|{
name|lseek
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|-
operator|(
call|(
name|long
call|)
argument_list|(
name|fp
operator|->
name|_cnt
argument_list|)
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|_base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This non-standard version of fdopen makes stream numbers  * correspond to file unit numbers  */
end_comment

begin_function
name|FILE
modifier|*
name|fdopen
parameter_list|(
name|fd
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|mode
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|iop
operator|=
name|file_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|iop
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|_file
operator|=
name|fd
expr_stmt|;
name|iop
operator|->
name|_base
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
operator|*
name|mode
condition|)
block|{
case|case
literal|'r'
case|:
name|iop
operator|->
name|_flag
operator||=
name|_IOREAD
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* No break */
case|case
literal|'w'
case|:
name|iop
operator|->
name|_flag
operator||=
name|_IOWRT
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|mode
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
name|iop
operator|->
name|_flag
operator|&=
operator|~
operator|(
name|_IOREAD
operator||
name|_IOWRT
operator|)
expr_stmt|;
name|iop
operator|->
name|_flag
operator||=
name|_IORW
expr_stmt|;
block|}
return|return
operator|(
name|iop
operator|)
return|;
block|}
end_function

begin_function
name|void
name|chkpipe
parameter_list|(
name|pv
parameter_list|)
name|FILE
modifier|*
name|pv
index|[]
decl_stmt|;
block|{
name|int
name|ipv
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|ipv
argument_list|)
operator|<
literal|0
operator|||
name|ipv
index|[
name|INPIPE
index|]
operator|<
literal|0
operator|||
name|ipv
index|[
name|OTPIPE
index|]
operator|<
literal|0
condition|)
name|error
argument_list|(
name|piperr
argument_list|)
expr_stmt|;
name|pv
index|[
name|INPIPE
index|]
operator|=
name|fdopen
argument_list|(
name|ipv
index|[
name|INPIPE
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|pv
index|[
name|OTPIPE
index|]
operator|=
name|fdopen
argument_list|(
name|ipv
index|[
name|OTPIPE
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * close a pipe  */
end_comment

begin_function
name|void
name|pipe_close
parameter_list|(
name|pv
parameter_list|)
specifier|register
name|FILE
modifier|*
name|pv
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|pv
index|[
name|INPIPE
index|]
condition|)
name|fclose
argument_list|(
name|pv
index|[
name|INPIPE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
index|[
name|OTPIPE
index|]
condition|)
name|fclose
argument_list|(
name|pv
index|[
name|OTPIPE
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open a stream for reading  * On failure, print message.  */
end_comment

begin_function
name|FILE
modifier|*
name|chkopen
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|name
argument_list|,
name|badopen
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given a file stream f1, move it to a new file stream with file number  * f2.  If f2 is open then it is closed first.  * If the MARK bit not set on f2, then close on exec will be set for f2>2  * The original stream is closed.  * File numbers greater than 2 are marked close on exec if frenumber is   *  invoked by a parent shell.  *  The new file descriptor is returned;  */
end_comment

begin_function
name|FILE
modifier|*
name|frenumber
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
name|FILE
modifier|*
name|f1
decl_stmt|;
specifier|register
name|int
name|f2
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|int
name|flag
init|=
operator|(
name|f2
operator|&
name|MARK
operator|)
decl_stmt|;
specifier|register
name|int
name|fs
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|type
decl_stmt|;
name|f2
operator|&=
operator|~
name|MARK
expr_stmt|;
if|if
condition|(
name|f2
operator|>
literal|2
operator|&&
name|flag
operator|==
literal|0
condition|)
name|fs
operator|=
literal|1
expr_stmt|;
name|fd
operator|=
name|file_fd
argument_list|(
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileno
argument_list|(
name|f1
argument_list|)
operator|!=
name|f2
condition|)
block|{
name|int
name|fno
decl_stmt|;
if|if
condition|(
name|fs
operator|==
literal|0
condition|)
name|fs
operator|=
name|fcntl
argument_list|(
name|f2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fisopen
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|closefd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
name|close
argument_list|(
name|f2
argument_list|)
expr_stmt|;
name|fno
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|f1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fno
operator|<
literal|0
condition|)
name|error
argument_list|(
name|badfile
argument_list|)
expr_stmt|;
name|flag
operator|=
name|f1
operator|->
name|_flag
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|_IORW
condition|)
name|type
operator|=
literal|"w+"
expr_stmt|;
else|else
name|type
operator|=
operator|(
name|f1
operator|->
name|_flag
operator|&
name|_IOREAD
condition|?
literal|"r"
else|:
literal|"w"
operator|)
expr_stmt|;
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fdopen
argument_list|(
name|f2
argument_list|,
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|apollo
name|fd
operator|->
name|_file
operator|=
name|fno
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
name|fd
operator|->
name|_flag
operator|=
name|flag
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|output
condition|)
name|setbuf
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|_sobuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|==
name|input
operator|&&
operator|(
name|fd
operator|->
name|_flag
operator|&
name|_IONBF
operator|)
operator|==
literal|0
condition|)
name|setbuf
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|_sibuf
argument_list|)
expr_stmt|;
else|else
block|{
name|fd
operator|->
name|_cnt
operator|=
name|f1
operator|->
name|_cnt
expr_stmt|;
name|fd
operator|->
name|_ptr
operator|=
name|f1
operator|->
name|_ptr
expr_stmt|;
name|fd
operator|->
name|_base
operator|=
name|f1
operator|->
name|_base
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|f1
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|f2
operator|==
literal|0
condition|)
name|ioset
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|==
literal|1
condition|)
ifdef|#
directive|ifdef
name|BSD
name|ioctl
argument_list|(
name|f2
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|fcntl
argument_list|(
name|f2
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|tmp_open
parameter_list|(
name|fname
parameter_list|)
specifier|register
name|char
modifier|*
name|fname
decl_stmt|;
block|{
specifier|register
name|int
name|maxtry
init|=
literal|10
decl_stmt|;
specifier|register
name|char
modifier|*
name|tmp_name
init|=
name|tmpout
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
if|if
condition|(
name|states
operator|&
name|NO_TMP
condition|)
name|settemp
argument_list|(
name|itos
argument_list|(
name|getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|movstr
argument_list|(
name|itos
argument_list|(
operator|++
name|serial
argument_list|)
argument_list|,
name|temp_suffix
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fd
operator|=
name|create
argument_list|(
name|tmp_name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
name|maxtry
operator|--
condition|)
do|;
if|if
condition|(
name|fname
condition|)
block|{
name|movstr
argument_list|(
name|tmp_name
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|chkrdwr
argument_list|(
name|tmp_name
argument_list|,
name|fd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|failed
argument_list|(
name|tmp_name
argument_list|,
name|badcreate
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create the file named s and return an open stream to it  */
end_comment

begin_function
name|FILE
modifier|*
name|create
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
name|fd
operator|=
name|fdopen
argument_list|(
name|creat
argument_list|(
name|s
argument_list|,
literal|0666
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * close file stream and reopen for reading and writing  */
end_comment

begin_function
name|FILE
modifier|*
name|chkrdwr
parameter_list|(
name|name
parameter_list|,
name|fd
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|closefd
argument_list|(
name|fd
argument_list|)
specifier|register
name|FILE
operator|*
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* reposition seek pointer if necessary */
if|if
condition|(
operator|(
name|fd
operator|->
name|_flag
operator|&
name|_IOREAD
operator|)
operator|&&
name|fd
operator|->
name|_cnt
condition|)
name|lseek
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|,
operator|-
operator|(
call|(
name|long
call|)
argument_list|(
name|fd
operator|->
name|_cnt
argument_list|)
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fd
operator|->
name|_base
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fd
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|copy
argument_list|(
argument|ioparg
argument_list|)
end_macro

begin_decl_stmt
name|IOPTR
name|ioparg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
init|=
literal|'\n'
decl_stmt|;
specifier|register
name|char
modifier|*
name|clinep
decl_stmt|;
specifier|register
name|IOPTR
name|iop
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
name|BOOL
name|nosubst
decl_stmt|;
name|char
modifier|*
name|ends
decl_stmt|,
modifier|*
name|cline
decl_stmt|,
name|obuff
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|iop
operator|=
name|ioparg
condition|)
block|{
name|int
name|stripflg
init|=
name|iop
operator|->
name|iofile
operator|&
name|IOSTRIP
decl_stmt|;
specifier|register
name|nlflg
operator|=
name|stripflg
expr_stmt|;
name|copy
argument_list|(
name|iop
operator|->
name|iolst
argument_list|)
expr_stmt|;
name|ends
operator|=
name|iop
operator|->
name|ioname
expr_stmt|;
comment|/* check for and strip quoted characters in ends */
name|nosubst
operator|=
name|qtrim
argument_list|(
name|ends
argument_list|)
expr_stmt|;
if|if
condition|(
name|nosubst
condition|)
name|iop
operator|->
name|iofile
operator|&=
operator|~
name|IODOC
expr_stmt|;
name|fd
operator|=
name|tmp_open
argument_list|(
name|NIL
argument_list|)
expr_stmt|;
name|iop
operator|->
name|ioname
operator|=
operator|(
name|char
operator|*
operator|)
name|cpystak
argument_list|(
name|tmpout
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fd
argument_list|,
name|obuff
argument_list|)
expr_stmt|;
name|iop
operator|->
name|iolst
operator|=
name|iotemp
expr_stmt|;
name|iotemp
operator|=
name|iop
expr_stmt|;
name|cline
operator|=
operator|(
name|char
operator|*
operator|)
name|locstak
argument_list|()
expr_stmt|;
if|if
condition|(
name|stripflg
condition|)
while|while
condition|(
operator|*
name|ends
operator|==
literal|'\t'
condition|)
name|ends
operator|++
expr_stmt|;
name|clinep
operator|=
name|cline
operator|++
expr_stmt|;
operator|*
name|cline
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|clinep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|ends
argument_list|,
name|cline
argument_list|)
condition|)
break|break;
name|chkpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|clinep
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|clinep
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
name|cline
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|clinep
operator|=
name|cline
expr_stmt|;
name|nlflg
operator|=
name|stripflg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|&&
name|nlflg
condition|)
empty_stmt|;
else|else
block|{
operator|*
name|clinep
operator|++
operator|=
name|c
expr_stmt|;
name|nlflg
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|=
operator|(
name|nosubst
condition|?
name|readc
argument_list|()
else|:
name|nextc
argument_list|()
operator|)
condition|)
do|;
name|closefd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * trim quotes and the escapes  * returns non-zero if string is quoted 0 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|qtrim
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
init|=
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
init|=
name|sp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|quote
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|sp
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
block|{
name|quote
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|quote
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|quote
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * short version of fputs  */
end_comment

begin_function
name|int
name|fputs
parameter_list|(
name|s
parameter_list|,
name|fd
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|fd
operator|==
name|NULL
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create a link to iodoc for child process to use  */
end_comment

begin_expr_stmt
name|link_iodocs
argument_list|(
name|i
argument_list|)
specifier|register
expr|struct
name|ionod
operator|*
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|i
condition|)
block|{
comment|/* generate a tempory file name */
name|fclose
argument_list|(
name|tmp_open
argument_list|(
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|i
operator|->
name|iolink
argument_list|)
expr_stmt|;
name|i
operator|->
name|iolink
operator|=
name|heap
argument_list|(
name|tmpout
argument_list|)
expr_stmt|;
name|link
argument_list|(
name|i
operator|->
name|ioname
argument_list|,
name|i
operator|->
name|iolink
argument_list|)
expr_stmt|;
name|i
operator|=
name|i
operator|->
name|iolst
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * rename the file with the link name of the parent  */
end_comment

begin_function
name|void
name|swap_iodoc_nm
parameter_list|(
name|i
parameter_list|)
specifier|register
name|struct
name|ionod
modifier|*
name|i
decl_stmt|;
block|{
while|while
condition|(
name|i
condition|)
block|{
name|free
argument_list|(
name|i
operator|->
name|ioname
argument_list|)
expr_stmt|;
name|i
operator|->
name|ioname
operator|=
name|i
operator|->
name|iolink
expr_stmt|;
name|i
operator|->
name|iolink
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|i
operator|->
name|iolst
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * copy file fd into a save place  */
end_comment

begin_expr_stmt
name|savefd
argument_list|(
name|fd
argument_list|,
name|oldtop
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|f
init|=
name|topfd
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f1
init|=
name|file_fd
argument_list|(
name|fd
argument_list|)
decl_stmt|;
comment|/* see if already saved, only save once */
while|while
condition|(
name|f
operator|>
name|oldtop
condition|)
block|{
if|if
condition|(
name|fdmap
index|[
operator|--
name|f
index|]
operator|.
name|org_fd
operator|==
name|fd
condition|)
return|return;
block|}
if|if
condition|(
name|fiswrite
argument_list|(
name|f1
argument_list|)
condition|)
name|fflush
argument_list|(
name|f1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f1
operator|==
name|stdin
condition|)
name|sync_io
argument_list|()
expr_stmt|;
name|f
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
name|USERIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|topfd
operator|>=
name|MAXFILES
condition|)
name|error
argument_list|(
name|nomorefiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
operator|*
operator|(
name|file_fd
argument_list|(
name|f
argument_list|)
operator|)
operator|=
operator|*
name|f1
expr_stmt|;
name|setbuf
argument_list|(
name|f1
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
name|fdmap
index|[
name|topfd
index|]
operator|.
name|org_fd
operator|=
name|fd
expr_stmt|;
name|fdmap
index|[
name|topfd
operator|++
index|]
operator|.
name|dup_fd
operator|=
name|f
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  *  restore saved file descriptors from<last> on  */
end_comment

begin_function
name|void
name|restore
parameter_list|(
name|last
parameter_list|)
specifier|register
name|int
name|last
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|dupfd
decl_stmt|;
for|for
control|(
name|i
operator|=
name|topfd
operator|-
literal|1
init|;
name|i
operator|>=
name|last
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|dupfd
operator|=
name|fdmap
index|[
name|i
index|]
operator|.
name|dup_fd
operator|)
operator|>
literal|0
condition|)
block|{
operator|(
name|file_fd
argument_list|(
name|dupfd
argument_list|)
operator|)
operator|->
name|_file
operator|=
name|dupfd
expr_stmt|;
name|frenumber
argument_list|(
name|file_fd
argument_list|(
name|dupfd
argument_list|)
argument_list|,
name|fdmap
index|[
name|i
index|]
operator|.
name|org_fd
argument_list|)
expr_stmt|;
block|}
else|else
name|fclose
argument_list|(
name|file_fd
argument_list|(
name|fdmap
index|[
name|i
index|]
operator|.
name|org_fd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|topfd
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine returns 1 if fd corresponds to a pipe, 0 otherwise.  */
end_comment

begin_function
name|int
name|ispipe
parameter_list|(
name|fd
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
specifier|register
name|int
name|fno
init|=
name|fileno
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fno
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|ESPIPE
condition|)
return|return
operator|(
operator|!
name|isatty
argument_list|(
name|fno
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|BSD
comment|/* This may be a bug in lseek */
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* BSD */
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|ESH
operator|||
name|VSH
end_if

begin_comment
comment|/*  * Stripped down version of _filbuf from standard I/O library  */
end_comment

begin_expr_stmt
name|_filbuf
argument_list|(
name|iop
argument_list|)
specifier|register
name|FILE
operator|*
name|iop
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|state
init|=
name|states
decl_stmt|;
name|unsigned
name|char
name|cc
decl_stmt|;
specifier|register
name|int
name|syncread
decl_stmt|;
if|if
condition|(
name|iop
operator|->
name|_flag
operator|&
name|_IORW
condition|)
name|iop
operator|->
name|_flag
operator||=
name|_IOREAD
expr_stmt|;
if|if
condition|(
operator|(
name|iop
operator|->
name|_flag
operator|&
name|_IOREAD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|fnobuff
argument_list|(
name|iop
argument_list|)
condition|)
block|{
comment|/* unbuffered reads needed for pipes */
name|p_flush
argument_list|()
expr_stmt|;
name|iop
operator|->
name|_cnt
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|iop
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|cc
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iop
operator|->
name|_cnt
operator|>
literal|0
condition|)
block|{
name|iop
operator|->
name|_cnt
operator|--
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
goto|goto
name|skip
goto|;
block|}
name|syncread
operator|=
operator|(
operator|(
name|state
operator|&
name|PROMPT
operator|)
operator|&&
name|iop
operator|==
name|input
operator|&&
operator|(
name|standin
operator|->
name|fstak
operator|==
literal|0
operator|||
operator|(
name|state
operator|&
name|RWAIT
operator|)
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ESH
if|if
condition|(
name|is_option
argument_list|(
name|EMACS
operator||
name|GMACS
argument_list|)
operator|&&
name|syncread
condition|)
name|iop
operator|->
name|_cnt
operator|=
name|hread
argument_list|(
name|fileno
argument_list|(
name|iop
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iop
operator|->
name|_base
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* ESH */
ifdef|#
directive|ifdef
name|VSH
if|if
condition|(
name|is_option
argument_list|(
name|EDITVI
argument_list|)
operator|&&
name|syncread
condition|)
name|iop
operator|->
name|_cnt
operator|=
name|vread
argument_list|(
name|fileno
argument_list|(
name|iop
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|iop
operator|->
name|_base
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* VSH */
block|{
comment|/* flush before a read */
if|if
condition|(
name|syncread
condition|)
name|p_flush
argument_list|()
expr_stmt|;
name|iop
operator|->
name|_cnt
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|iop
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iop
operator|->
name|_base
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
block|}
name|iop
operator|->
name|_ptr
operator|=
name|iop
operator|->
name|_base
expr_stmt|;
name|skip
label|:
if|if
condition|(
operator|--
name|iop
operator|->
name|_cnt
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|iop
operator|->
name|_cnt
operator|==
operator|-
literal|1
condition|)
block|{
name|iop
operator|->
name|_flag
operator||=
name|_IOEOF
expr_stmt|;
if|if
condition|(
name|iop
operator|->
name|_flag
operator|&
name|_IORW
condition|)
name|iop
operator|->
name|_flag
operator|&=
operator|~
name|_IOREAD
expr_stmt|;
block|}
else|else
name|iop
operator|->
name|_flag
operator||=
name|_IOERR
expr_stmt|;
name|iop
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|*
name|iop
operator|->
name|_ptr
operator|++
operator|&
name|STRIP
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FCNTL
end_ifdef

begin_function
specifier|static
name|int
name|fcntl
parameter_list|(
name|f1
parameter_list|,
name|type
parameter_list|,
name|arg
parameter_list|)
specifier|register
name|int
name|arg
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|F_DUPFD
condition|)
block|{
specifier|register
name|int
name|fd
decl_stmt|;
comment|/* find first non-open file */
while|while
condition|(
name|arg
operator|<
name|_NFILE
operator|&&
operator|(
name|fstat
argument_list|(
name|arg
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
operator|)
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|arg
operator|>=
name|_NFILE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fd
operator|=
name|dup
argument_list|(
name|f1
operator||
name|DUPFLG
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_FCNTL */
end_comment

begin_if
if|#
directive|if
name|u370
operator|||
name|uts
end_if

begin_function_decl
specifier|extern
name|int
name|isatty
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|_smbuf
index|[]
index|[
name|_SBFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setbuf
parameter_list|(
name|iop
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|fno
init|=
name|fileno
argument_list|(
name|iop
argument_list|)
decl_stmt|;
comment|/* file number */
if|if
condition|(
name|iop
operator|->
name|_base
operator|!=
name|NULL
operator|&&
name|iop
operator|->
name|_flag
operator|&
name|_IOMYBUF
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iop
operator|->
name|_base
argument_list|)
expr_stmt|;
name|iop
operator|->
name|_flag
operator|&=
operator|~
operator|(
name|_IOMYBUF
operator||
name|_IONBF
operator||
name|_IOLBF
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|iop
operator|->
name|_base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|)
operator|==
name|NULL
condition|)
block|{
name|iop
operator|->
name|_flag
operator||=
name|_IONBF
expr_stmt|;
comment|/* file unbuffered except in fastio */
name|_bufend
argument_list|(
name|iop
argument_list|)
operator|=
operator|(
name|iop
operator|->
name|_base
operator|=
name|_smbuf
index|[
name|fno
index|]
operator|)
operator|+
name|_SBFSIZ
expr_stmt|;
block|}
else|else
block|{
comment|/* regular buffered I/O, standard buffer size */
name|_bufend
argument_list|(
name|iop
argument_list|)
operator|=
name|iop
operator|->
name|_base
operator|+
name|BUFSIZ
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fno
argument_list|)
condition|)
name|iop
operator|->
name|_flag
operator||=
name|_IOLBF
expr_stmt|;
block|}
name|iop
operator|->
name|_ptr
operator|=
name|iop
operator|->
name|_base
expr_stmt|;
name|iop
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* u370 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INT16
end_ifdef

begin_comment
comment|/*  * special version of fread for to save space  * only works if count is 1  */
end_comment

begin_expr_stmt
name|fread
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|count
argument_list|,
name|iop
argument_list|)
specifier|register
name|char
operator|*
name|ptr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|size
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|iop
argument_list|)
operator|)
operator|>=
literal|0
condition|)
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|while
condition|(
operator|--
name|size
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INT16 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VENIX
end_ifdef

begin_function
name|int
name|getppid
parameter_list|()
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VENIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_N_STATIC_IOBS
end_ifdef

begin_comment
comment|/*  ULTRIX doesn't have complete _iob */
end_comment

begin_decl_stmt
name|FILE
name|_myiob
index|[
name|FCIO
operator|+
literal|1
operator|-
name|_N_STATIC_IOBS
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|FILE
modifier|*
name|file_fd
parameter_list|(
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
name|_N_STATIC_IOBS
condition|)
return|return
operator|(
operator|&
name|_iob
index|[
name|n
index|]
operator|)
return|;
else|else
return|return
operator|(
operator|&
name|_myiob
index|[
name|n
operator|-
name|_N_STATIC_IOBS
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _N_STATIC_IOBS */
end_comment

end_unit

