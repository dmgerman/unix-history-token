begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)vfork.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"mode.h"
end_include

begin_comment
comment|/*  * This module is provided to allow the Shell to work with vfork instead  * of fork.  With vfork the data area is shared by parent and child.  * Save state variables at fork and make Shell variables copy on write.  * Restore everything to previous state when fork_exit is called and  * terminate process.  */
end_comment

begin_comment
comment|/* The following structure contains the variables that must be saved */
end_comment

begin_struct
struct|struct
name|f_save
block|{
name|struct
name|f_save
modifier|*
name|f_save_fork
decl_stmt|;
name|DOLPTR
name|f_savearg
decl_stmt|;
name|STKPTR
name|f_staksave
decl_stmt|;
name|struct
name|State
name|f_st
decl_stmt|;
name|char
name|f_trapflg
index|[
name|MAXTRAP
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|f_trapcom
index|[
name|MAXTRAP
operator|+
literal|1
index|]
decl_stmt|;
name|FILE
name|f_save_iob
index|[
name|FCIO
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|jobs
name|f_jobstat
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following routines are defined by this module */
end_comment

begin_function_decl
name|int
name|vfork_check
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|vfork_restore
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|vfork_save
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The following external routines are referenced by this module */
end_comment

begin_function_decl
specifier|extern
name|DOLPTR
name|arg_use
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|arg_free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|NAMPTR
name|checkfor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|chkid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|Amemory
modifier|*
name|namep
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|simple
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
name|trapflg
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|f_save
modifier|*
name|save_fork
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* most recently saved data */
end_comment

begin_comment
comment|/*  * Save state on fork  */
end_comment

begin_function
name|int
name|vfork_save
parameter_list|()
block|{
specifier|register
name|struct
name|f_save
modifier|*
name|fp
init|=
operator|(
expr|struct
name|f_save
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|f_save
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|locstak
argument_list|()
expr_stmt|;
name|fp
operator|->
name|f_save_fork
operator|=
name|save_fork
expr_stmt|;
name|save_fork
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|f_staksave
operator|=
name|savstak
argument_list|()
expr_stmt|;
name|fp
operator|->
name|f_st
operator|=
name|st
expr_stmt|;
name|fp
operator|->
name|f_jobstat
operator|=
name|jobstat
expr_stmt|;
name|jobstat
operator|.
name|p_pwlist
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_savearg
operator|=
name|arg_use
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|trapflg
argument_list|,
name|fp
operator|->
name|f_trapflg
argument_list|,
name|MAXTRAP
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|trapcom
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|f_trapcom
argument_list|,
operator|(
name|MAXTRAP
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_N_STATIC_IOBS
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|_iob
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|f_save_iob
argument_list|,
operator|(
name|_N_STATIC_IOBS
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FILE
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|_myiob
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|fp
operator|->
name|f_save_iob
operator|+
name|_N_STATIC_IOBS
operator|)
argument_list|,
operator|(
name|FCIO
operator|+
literal|1
operator|-
name|_N_STATIC_IOBS
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FILE
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|_iob
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|f_save_iob
argument_list|,
operator|(
name|FCIO
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FILE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _N_STATIC_IOBS */
name|states
operator||=
name|VFORKED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Restore state and exit  */
end_comment

begin_function
name|void
name|vfork_restore
parameter_list|()
block|{
specifier|register
name|struct
name|f_save
modifier|*
name|fp
init|=
name|save_fork
decl_stmt|;
if|if
condition|(
operator|(
name|states
operator|&
name|VFORKED
operator|)
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|_N_STATIC_IOBS
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|f_save_iob
argument_list|,
operator|(
name|char
operator|*
operator|)
name|_iob
argument_list|,
operator|(
name|_N_STATIC_IOBS
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FILE
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|fp
operator|->
name|f_save_iob
operator|+
name|_N_STATIC_IOBS
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|_myiob
argument_list|,
operator|(
name|FCIO
operator|+
literal|1
operator|-
name|_N_STATIC_IOBS
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FILE
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|f_save_iob
argument_list|,
operator|(
name|char
operator|*
operator|)
name|_iob
argument_list|,
operator|(
name|FCIO
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FILE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _N_STATIC_IOBS */
name|bcopy
argument_list|(
name|fp
operator|->
name|f_trapflg
argument_list|,
name|trapflg
argument_list|,
name|MAXTRAP
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|f_trapcom
argument_list|,
operator|(
name|char
operator|*
operator|)
name|trapcom
argument_list|,
operator|(
name|MAXTRAP
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|=
name|fp
operator|->
name|f_st
expr_stmt|;
name|jobstat
operator|=
name|fp
operator|->
name|f_jobstat
expr_stmt|;
name|arg_free
argument_list|(
name|fp
operator|->
name|f_savearg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|save_fork
operator|=
name|fp
operator|->
name|f_save_fork
expr_stmt|;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|tdystak
argument_list|(
name|fp
operator|->
name|f_staksave
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the interpreter name given a script file   * The first line must be of the form #!<iname>.  * Returns 1 if<iname> is found, 0 otherwise  */
end_comment

begin_function
name|int
name|get_shell
parameter_list|(
name|name
parameter_list|,
name|iname
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|iname
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|state
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|cp
operator|=
name|valup
argument_list|(
name|SHELLNOD
argument_list|)
expr_stmt|;
comment|/* don't use csh */
if|if
condition|(
name|strcmp
argument_list|(
name|simple
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|"csh"
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|iname
argument_list|,
name|cp
condition|?
name|cp
else|:
literal|"/bin/sh"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|c
operator|!=
literal|'#'
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|c
operator|!=
literal|'!'
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
continue|continue;
default|default:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|iname
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|iname
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|state
operator|++
expr_stmt|;
block|}
name|out
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns non-zero if process should vfork, 0 otherwise  * we do not vfork for functions and built-ins in the background  */
end_comment

begin_function
name|int
name|vfork_check
parameter_list|(
name|t
parameter_list|)
name|TREPTR
name|t
decl_stmt|;
block|{
specifier|register
name|COMPTR
name|tf
decl_stmt|;
specifier|register
name|ARGPTR
name|arg
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg0
init|=
name|NIL
decl_stmt|;
name|NAMPTR
name|np
decl_stmt|;
name|int
name|bltno
decl_stmt|;
comment|/* simple command */
if|if
condition|(
operator|(
name|t
operator|->
name|tretyp
operator|&
name|COMMSK
operator|)
operator|==
name|TCOM
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tf
operator|=
call|(
name|COMPTR
call|)
argument_list|(
operator|(
operator|(
name|FORKPTR
operator|)
name|t
operator|)
operator|->
name|forktre
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tf
operator|->
name|comtyp
operator|&
name|COMMSK
operator|)
operator|!=
name|TCOM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* background command */
name|arg
operator|=
name|tf
operator|->
name|comarg
expr_stmt|;
name|bltno
operator|=
name|tf
operator|->
name|comtyp
operator|>>
operator|(
name|COMBITS
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* can't vfork assignments or most built-ins */
if|if
condition|(
name|arg
operator|==
literal|0
operator|||
name|bltno
operator|>
name|SYSLOGIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tf
operator|->
name|comtyp
operator|&
name|COMSCAN
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|argflag
operator|&
name|A_RAW
condition|)
name|arg0
operator|=
name|arg
operator|->
name|argval
expr_stmt|;
block|}
else|else
name|arg0
operator|=
operator|*
operator|(
operator|(
operator|(
name|DOLPTR
operator|)
name|arg
operator|)
operator|->
name|dolarg
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* no vfork if not sure */
if|if
condition|(
name|arg0
operator|==
name|NIL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* eliminate functions */
if|if
condition|(
name|chkid
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|(
name|np
operator|=
name|checkfor
argument_list|(
name|arg0
argument_list|,
name|prnames
argument_list|)
operator|)
operator|&&
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|ip
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* command substitution with i/o redirection use fork */
if|if
condition|(
operator|(
name|t
operator|->
name|tretyp
operator|&
name|FCOMSUB
operator|)
operator|&&
name|t
operator|->
name|treio
operator|==
operator|(
name|IOPTR
operator|)
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BSD_4_2
end_ifndef

begin_comment
comment|/*  * copy<n> bytes from<sp> to<dp>  */
end_comment

begin_function
name|int
name|bcopy
parameter_list|(
name|sp
parameter_list|,
name|dp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
decl|*
name|dp
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|BSD_4_2
end_endif

end_unit

