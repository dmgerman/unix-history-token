begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)namscan.c	1.1 */
end_comment

begin_comment
comment|/*  *   NAMSCAN.C  *  *   GSCAN_ALL (FN, ROOT)  *        Execute FN at each node in the linked memory trees,  *        which are given by ROOT.  *  *   GSCAN_SOME (FN, ROOT, MASK, FLAG)  *        Execute FN at those nodes in the linked memory trees  *        that have certain attributes, as determined by MASK and  *        FLAG. ROOT is the first of the list of memory trees.  *  *   SCAN_ALL (FN, ROOT)  *        Execute function FN at each of the Namnods in the tree  *        given by ROOT.  *  */
end_comment

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_comment
comment|/* These routines are defined by this module */
end_comment

begin_function_decl
name|void
name|gscan_all
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|scan_all
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gscan_some
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|scanmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scanflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *   GSCAN_ALL (FN, ROOT)  *     *        int (*FN)();  *  *	  struct Amemory *root;  *  *   Execute FN at each node in the linked memory trees.   *   Note that the first tree need not exist.  */
end_comment

begin_decl_stmt
name|void
name|gscan_all
argument_list|(
name|fn
argument_list|,
name|root
argument_list|)
name|void
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Amemory
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Amemory
modifier|*
name|app
init|=
name|root
decl_stmt|;
while|while
condition|(
name|app
condition|)
block|{
name|scan_all
argument_list|(
name|fn
argument_list|,
name|app
argument_list|)
expr_stmt|;
name|app
operator|=
name|app
operator|->
name|nexttree
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  *   GSCAN_SOME (FN, ROOT, MASK, FLAG)  *        int (*FN)();  *        struct Amemory *ROOT;  *        int MASK;  *        int FLAG;  *  *   Execute FN at each of the Namnods in the trees given by ROOT  *   that meet certain criteria, as determined by MASK and FLAG.  *   If flag is non-zero then at least one of these mask bits must be on.  *   If flag is zero then all the mask bits must be off to match.  */
end_comment

begin_decl_stmt
name|void
name|gscan_some
argument_list|(
name|fn
argument_list|,
name|root
argument_list|,
name|mask
argument_list|,
name|flag
argument_list|)
name|void
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mask
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Amemory
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|scanmask
operator|=
name|mask
expr_stmt|;
name|scanflag
operator|=
name|flag
expr_stmt|;
name|gscan_all
argument_list|(
name|fn
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|scanmask
operator|=
name|scanflag
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *   SCAN_ALL (FN, ROOT)  *        int (*FN)();  *        struct Amemory *ROOT;  *  *   Execute FN at each node in the tree given by ROOT, according  *   to the values of scanmask and scanflag, which are established  *   in scan_some().  */
end_comment

begin_decl_stmt
name|void
name|scan_all
argument_list|(
name|fn
argument_list|,
name|root
argument_list|)
name|void
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Amemory
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Namnod
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|smask
init|=
name|scanmask
operator|^
name|N_AVAIL
decl_stmt|;
name|int
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|root
operator|->
name|memsize
condition|;
name|i
operator|++
control|)
for|for
control|(
name|np
operator|=
name|root
operator|->
name|memhead
index|[
name|i
index|]
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|namnxt
control|)
block|{
name|k
operator|=
name|np
operator|->
name|value
operator|.
name|namflg
operator|&
name|smask
expr_stmt|;
if|if
condition|(
operator|(
name|scanflag
condition|?
name|scanflag
operator|&
name|k
else|:
name|k
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|attest
argument_list|(
name|np
argument_list|,
name|ARRAY
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|Namaray
modifier|*
name|ap
init|=
name|arayp
argument_list|(
name|np
argument_list|)
decl_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
name|np
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
init|=
name|ap
operator|->
name|adot
decl_stmt|;
for|for
control|(
name|ap
operator|->
name|adot
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ap
operator|->
name|maxi
condition|;
name|i
operator|++
control|)
block|{
name|ap
operator|->
name|adot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|val
index|[
name|i
index|]
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|i
operator|=
name|ap
operator|->
name|adot
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|attest
argument_list|(
name|np
argument_list|,
operator|~
name|N_DEFAULT
argument_list|)
operator|||
name|np
operator|->
name|value
operator|.
name|namval
operator|.
name|cp
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

