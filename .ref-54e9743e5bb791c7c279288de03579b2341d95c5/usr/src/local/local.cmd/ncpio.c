begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: cpio.c,v 1.4 83/12/16 13:18:54 ks Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	@(#)cpio.c	1.7	*/
end_comment

begin_comment
comment|/*	cpio	COMPILE:	cc -O cpio.c -s -i -o cpio  	cpio -- copy file collections  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RT
end_ifdef

begin_include
include|#
directive|include
file|<rt/macro.h>
end_include

begin_include
include|#
directive|include
file|<rt/types.h>
end_include

begin_include
include|#
directive|include
file|<rt/stat.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EQ
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(strcmp(x,y)==0)
end_define

begin_comment
comment|/* for VAX, Interdata, ... */
end_comment

begin_define
define|#
directive|define
name|MKSHORT
parameter_list|(
name|v
parameter_list|,
name|lv
parameter_list|)
value|{U.l=1L;if(U.c[0]) U.l=lv,v[0]=U.s[1],v[1]=U.s[0]; else U.l=lv,v[0]=U.s[0],v[1]=U.s[1];}
end_define

begin_define
define|#
directive|define
name|MAGIC
value|070707
end_define

begin_comment
comment|/* cpio magic number */
end_comment

begin_define
define|#
directive|define
name|IN
value|1
end_define

begin_comment
comment|/* copy in */
end_comment

begin_define
define|#
directive|define
name|OUT
value|2
end_define

begin_comment
comment|/* copy out */
end_comment

begin_define
define|#
directive|define
name|PASS
value|3
end_define

begin_comment
comment|/* direct copy */
end_comment

begin_define
define|#
directive|define
name|HDRSIZE
value|(Hdr.h_name - (char *)&Hdr)
end_define

begin_comment
comment|/* header size minus filename field */
end_comment

begin_define
define|#
directive|define
name|LINKS
value|1000
end_define

begin_comment
comment|/* max no. of links allowed */
end_comment

begin_define
define|#
directive|define
name|CHARS
value|76
end_define

begin_comment
comment|/* ASCII header size minus filename field */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|512
end_define

begin_comment
comment|/* In u370, can't use BUFSIZ nor BSIZE */
end_comment

begin_define
define|#
directive|define
name|CPIOBSZ
value|8192
end_define

begin_comment
comment|/* file read/write */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHLEN
end_ifndef

begin_define
define|#
directive|define
name|MAXPATHLEN
value|1024
end_define

begin_comment
comment|/* Maximum length of any single path name */
end_comment

begin_endif
endif|#
directive|endif
endif|MAXPATHLEN
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RT
end_ifdef

begin_decl_stmt
specifier|extern
name|long
name|filespace
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|stat
name|Statb
decl_stmt|,
name|Xstatb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cpio header format */
end_comment

begin_struct
struct|struct
name|header
block|{
name|short
name|h_magic
decl_stmt|,
name|h_dev
decl_stmt|;
name|ushort
name|h_ino
decl_stmt|,
name|h_mode
decl_stmt|,
name|h_uid
decl_stmt|,
name|h_gid
decl_stmt|;
name|short
name|h_nlink
decl_stmt|,
name|h_rdev
decl_stmt|,
name|h_mtime
index|[
literal|2
index|]
decl_stmt|,
name|h_namesize
decl_stmt|,
name|h_filesize
index|[
literal|2
index|]
decl_stmt|;
name|char
name|h_name
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|Hdr
struct|;
end_struct

begin_decl_stmt
name|unsigned
name|Bufsize
init|=
name|BUFSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default record size */
end_comment

begin_decl_stmt
name|short
name|Buf
index|[
name|CPIOBSZ
operator|/
literal|2
index|]
decl_stmt|,
modifier|*
name|Dbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|BBuf
index|[
name|CPIOBSZ
index|]
decl_stmt|,
modifier|*
name|Cbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Wct
decl_stmt|,
name|Wc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|Wp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Cp
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RT
end_ifdef

begin_decl_stmt
name|short
name|Actual_size
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|short
name|Option
decl_stmt|,
name|Dir
decl_stmt|,
name|Uncond
decl_stmt|,
name|Link
decl_stmt|,
name|Rename
decl_stmt|,
name|Toc
decl_stmt|,
name|Verbose
decl_stmt|,
name|Select
decl_stmt|,
name|Mod_time
decl_stmt|,
name|Acc_time
decl_stmt|,
name|Cflag
decl_stmt|,
name|fflag
decl_stmt|,
name|hflag
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RT
end_ifdef

begin_expr_stmt
name|Extent
operator|,
endif|#
directive|endif
name|Swap
operator|,
name|byteswap
operator|,
name|bothswap
operator|,
name|halfswap
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Ifile
decl_stmt|,
name|Ofile
decl_stmt|,
name|Input
init|=
literal|0
decl_stmt|,
name|Output
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Blocks
decl_stmt|,
name|Longfile
decl_stmt|,
name|Longtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Fullname
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|,
name|Name
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Pathend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|Rtty
decl_stmt|,
modifier|*
name|Wtty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Pattern
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Strhdr
index|[
literal|500
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Chdr
init|=
name|Strhdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Dev
decl_stmt|,
name|Uid
decl_stmt|,
name|EUid
decl_stmt|,
name|Gid
decl_stmt|,
name|A_directory
decl_stmt|,
name|A_special
decl_stmt|,
ifdef|#
directive|ifdef
name|RT
name|One_extent
decl_stmt|,
name|Multi_extent
decl_stmt|,
endif|#
directive|endif
name|Filetype
init|=
name|S_IFMT
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern	errno;
end_extern

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|cd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*	char	*Cd_name;	*/
end_comment

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_union
union|union
block|{
name|long
name|l
decl_stmt|;
name|short
name|s
index|[
literal|2
index|]
decl_stmt|;
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|U
union|;
end_union

begin_comment
comment|/* for VAX, Interdata, ... */
end_comment

begin_function
name|long
name|mklong
parameter_list|(
name|v
parameter_list|)
name|short
name|v
index|[]
decl_stmt|;
block|{
name|U
operator|.
name|l
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|U
operator|.
name|c
index|[
literal|0
index|]
condition|)
name|U
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|1
index|]
operator|,
name|U
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
else|else
name|U
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
operator|,
name|U
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
return|return
name|U
operator|.
name|l
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|ct
expr_stmt|;
name|long
name|filesz
decl_stmt|;
specifier|register
name|char
modifier|*
name|fullp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|ans
decl_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argv
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
name|usage
argument_list|()
expr_stmt|;
name|Uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|EUid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|Pattern
index|[
literal|0
index|]
operator|=
literal|"*"
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|argv
index|[
literal|1
index|]
condition|)
block|{
switch|switch
condition|(
operator|*
name|argv
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* reset access time */
name|Acc_time
operator|++
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* change record size to 5120 bytes */
name|Bufsize
operator|=
literal|5120
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|Option
operator|=
name|IN
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
comment|/* save patterns, if any */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|+
literal|2
operator|)
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|Pattern
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* do not consider patterns in cmd line */
name|fflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|Option
operator|=
name|OUT
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|accerr
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot write in<%s>\n"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|Fullname
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* destination directory */
name|strcat
argument_list|(
name|Fullname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|hflag
condition|?
name|stat
argument_list|(
name|Fullname
argument_list|,
operator|&
name|Xstatb
argument_list|)
else|:
name|lstat
argument_list|(
name|Fullname
argument_list|,
operator|&
name|Xstatb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Xstatb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
goto|goto
name|accerr
goto|;
name|Option
operator|=
name|PASS
expr_stmt|;
name|Dev
operator|=
name|Xstatb
operator|.
name|st_dev
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* ASCII header */
name|Cflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* create directories when needed */
name|Dir
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* link files, when necessary */
name|Link
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* retain mod time */
name|Mod_time
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* rename files interactively */
name|Rename
operator|++
expr_stmt|;
name|Rtty
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|Wtty
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Rtty
operator|==
name|NULL
operator|||
name|Wtty
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot rename (/dev/tty missing)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* swap halfwords */
name|halfswap
operator|++
expr_stmt|;
name|Swap
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* swap bytes */
name|byteswap
operator|++
expr_stmt|;
name|Swap
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|bothswap
operator|++
expr_stmt|;
name|Swap
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* table of contents */
name|Toc
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* copy unconditionally */
name|Uncond
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* verbose table of contents */
name|Verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
comment|/* for old, sixth-edition files */
name|Filetype
operator|=
literal|060000
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RT
case|case
literal|'e'
case|:
name|Extent
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'h'
case|:
name|hflag
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Option
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Options must include o|i|p\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RT
name|setio
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* turn on physio */
endif|#
directive|endif
if|if
condition|(
name|Option
operator|==
name|PASS
condition|)
block|{
if|if
condition|(
name|Rename
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Pass and Rename cannot be used together\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Bufsize
operator|==
literal|5120
condition|)
block|{
name|printf
argument_list|(
literal|"`B' option is irrelevant with the '-p' option\n"
argument_list|)
expr_stmt|;
name|Bufsize
operator|=
name|BUFSIZE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Cflag
condition|)
name|Cp
operator|=
name|Cbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|Bufsize
argument_list|)
expr_stmt|;
else|else
name|Wp
operator|=
name|Dbuf
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
name|Bufsize
argument_list|)
expr_stmt|;
block|}
name|Wct
operator|=
name|Bufsize
operator|>>
literal|1
expr_stmt|;
name|Wc
operator|=
name|Bufsize
expr_stmt|;
switch|switch
condition|(
name|Option
condition|)
block|{
case|case
name|OUT
case|:
comment|/* get filename, copy header and file out */
while|while
condition|(
name|getname
argument_list|()
condition|)
block|{
if|if
condition|(
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
operator|==
literal|0L
condition|)
block|{
ifdef|#
directive|ifdef
name|S_IFLNK
if|if
condition|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
block|{
name|outsymlink
argument_list|()
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|Cflag
condition|)
name|writehdr
argument_list|(
name|Chdr
argument_list|,
name|CHARS
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RT
if|if
condition|(
name|One_extent
operator|||
name|Multi_extent
condition|)
block|{
name|actsize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
name|writehdr
argument_list|(
name|Chdr
argument_list|,
name|CHARS
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
operator|(
name|Ifile
operator|=
name|open
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s> ?\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Cflag
condition|)
name|writehdr
argument_list|(
name|Chdr
argument_list|,
name|CHARS
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RT
if|if
condition|(
name|One_extent
operator|||
name|Multi_extent
condition|)
block|{
name|actsize
argument_list|(
name|Ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
name|writehdr
argument_list|(
name|Chdr
argument_list|,
name|CHARS
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|h_filesize
index|[
literal|0
index|]
operator|=
name|Actual_size
index|[
literal|0
index|]
expr_stmt|;
name|Hdr
operator|.
name|h_filesize
index|[
literal|1
index|]
operator|=
name|Actual_size
index|[
literal|1
index|]
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|filesz
operator|=
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
init|;
name|filesz
operator|>
literal|0
condition|;
name|filesz
operator|-=
name|CPIOBSZ
control|)
block|{
name|ct
operator|=
name|filesz
operator|>
name|CPIOBSZ
condition|?
name|CPIOBSZ
else|:
name|filesz
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|Ifile
argument_list|,
name|Cflag
condition|?
name|BBuf
else|:
operator|(
name|char
operator|*
operator|)
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot read %s\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Cflag
condition|?
name|writehdr
argument_list|(
name|BBuf
argument_list|,
name|ct
argument_list|)
else|:
name|bwrite
argument_list|(
name|Buf
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|Ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Acc_time
condition|)
name|set_time
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Statb
operator|.
name|st_atime
argument_list|,
name|Statb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
block|}
comment|/* copy trailer, after all files have been copied */
name|strcpy
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
literal|"TRAILER!!!"
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|h_magic
operator|=
name|MAGIC
expr_stmt|;
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|h_namesize
operator|=
name|strlen
argument_list|(
literal|"TRAILER!!!"
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|bintochar
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|writehdr
argument_list|(
name|Chdr
argument_list|,
name|CHARS
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
block|}
else|else
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
name|Cflag
condition|?
name|writehdr
argument_list|(
name|Cbuf
argument_list|,
name|Bufsize
argument_list|)
else|:
name|bwrite
argument_list|(
name|Dbuf
argument_list|,
name|Bufsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN
case|:
name|pwd
argument_list|()
expr_stmt|;
while|while
condition|(
name|gethdr
argument_list|()
condition|)
block|{
name|Ofile
operator|=
name|ckname
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
condition|?
name|openout
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
else|:
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|S_IFLNK
if|if
condition|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFLNK
condition|)
endif|#
directive|endif
for|for
control|(
name|filesz
operator|=
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
init|;
name|filesz
operator|>
literal|0
condition|;
name|filesz
operator|-=
name|CPIOBSZ
control|)
block|{
name|ct
operator|=
name|filesz
operator|>
name|CPIOBSZ
condition|?
name|CPIOBSZ
else|:
name|filesz
expr_stmt|;
name|Cflag
condition|?
name|readhdr
argument_list|(
name|BBuf
argument_list|,
name|ct
argument_list|)
else|:
name|bread
argument_list|(
name|Buf
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ofile
condition|)
block|{
if|if
condition|(
name|Swap
condition|)
name|Cflag
condition|?
name|swap
argument_list|(
name|BBuf
argument_list|,
name|ct
argument_list|)
else|:
name|swap
argument_list|(
name|Buf
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|Ofile
argument_list|,
name|Cflag
condition|?
name|BBuf
else|:
operator|(
name|char
operator|*
operator|)
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot write %s\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|Ofile
condition|)
block|{
name|close
argument_list|(
name|Ofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chmod<%s> (errno:%d)\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|set_time
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Select
condition|)
continue|continue;
if|if
condition|(
name|Verbose
condition|)
if|if
condition|(
name|Toc
condition|)
name|pentry
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Toc
condition|)
name|puts
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PASS
case|:
comment|/* move files around */
name|fullp
operator|=
name|Fullname
operator|+
name|strlen
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
while|while
condition|(
name|getname
argument_list|()
condition|)
block|{
if|if
condition|(
name|A_directory
operator|&&
operator|!
name|Dir
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use `-d' option to copy<%s>\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ckname
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
condition|)
continue|continue;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|Hdr
operator|.
name|h_name
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|fullp
argument_list|,
operator|&
operator|(
name|Hdr
operator|.
name|h_name
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Link
operator|&&
operator|!
name|A_directory
ifdef|#
directive|ifdef
name|S_IFLNK
operator|&&
operator|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFLNK
operator|)
endif|#
directive|endif
operator|&&
name|Dev
operator|==
name|Statb
operator|.
name|st_dev
operator|&&
operator|(
name|Uid
operator|==
name|Statb
operator|.
name|st_uid
operator|||
operator|!
name|Uid
operator|)
condition|)
block|{
if|if
condition|(
name|link
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Fullname
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* missing dir.? */
name|unlink
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
name|missdir
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Fullname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot link<%s>&<%s>\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* try creating (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|link
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Fullname
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* missing dir.? */
name|unlink
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|Fullname
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create directory for<%s> (errno:%d)\n"
argument_list|,
name|Fullname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot link<%s>&<%s>\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|,
name|Fullname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chmod<%s> (errno:%d)\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|set_time
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|ckverbose
goto|;
block|}
ifdef|#
directive|ifdef
name|RT
if|if
condition|(
name|One_extent
operator|||
name|Multi_extent
condition|)
name|actsize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|Ofile
operator|=
name|openout
argument_list|(
name|Fullname
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|Ifile
operator|=
name|open
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s> ?\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Ofile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|filesz
operator|=
name|Statb
operator|.
name|st_size
expr_stmt|;
for|for
control|(
init|;
name|filesz
operator|>
literal|0
condition|;
name|filesz
operator|-=
name|CPIOBSZ
control|)
block|{
name|ct
operator|=
name|filesz
operator|>
name|CPIOBSZ
condition|?
name|CPIOBSZ
else|:
name|filesz
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|Ifile
argument_list|,
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot read %s\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Ofile
condition|)
if|if
condition|(
name|write
argument_list|(
name|Ofile
argument_list|,
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot write %s\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|u370
name|Blocks
operator|+=
operator|(
operator|(
name|ct
operator|+
operator|(
name|BUFSIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|BUFSIZE
operator|)
expr_stmt|;
else|#
directive|else
operator|++
name|Blocks
expr_stmt|;
endif|#
directive|endif
block|}
name|close
argument_list|(
name|Ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Acc_time
condition|)
name|set_time
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Statb
operator|.
name|st_atime
argument_list|,
name|Statb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ofile
condition|)
block|{
name|close
argument_list|(
name|Ofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|Fullname
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chmod<%s> (errno:%d)\n"
argument_list|,
name|Fullname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|set_time
argument_list|(
name|Fullname
argument_list|,
name|Statb
operator|.
name|st_atime
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|)
expr_stmt|;
name|ckverbose
label|:
if|if
condition|(
name|Verbose
condition|)
name|puts
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* print number of blocks actually copied */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld blocks\n"
argument_list|,
name|Blocks
operator|*
operator|(
name|Bufsize
operator|>>
literal|9
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: cpio -o[acvB]<name-list>collection\n%s\n%s\n"
argument_list|,
literal|"       cpio -i[cdmrstuvfB6] [pattern ...]<collection"
argument_list|,
literal|"       cpio -p[adlmruv] directory<name-list"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getname
argument_list|()
end_macro

begin_comment
comment|/* get file name, get info for header */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|namep
init|=
name|Name
decl_stmt|;
specifier|register
name|ushort
name|ftype
decl_stmt|;
name|long
name|tlong
decl_stmt|;
name|int
name|namelen
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|namep
argument_list|,
name|MAXPATHLEN
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|namelen
operator|=
name|strlen
argument_list|(
name|namep
argument_list|)
expr_stmt|;
name|namep
index|[
name|namelen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
literal|128
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: filename<%s> too long for older versions of cpio\n"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|namep
operator|==
literal|'.'
operator|&&
name|namep
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|namep
operator|+=
literal|2
expr_stmt|;
name|strcpy
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hflag
condition|?
name|stat
argument_list|(
name|namep
argument_list|,
operator|&
name|Statb
argument_list|)
else|:
name|lstat
argument_list|(
name|namep
argument_list|,
operator|&
name|Statb
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"< %s> ?\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ftype
operator|=
name|Statb
operator|.
name|st_mode
operator|&
name|Filetype
expr_stmt|;
name|A_directory
operator|=
operator|(
name|ftype
operator|==
name|S_IFDIR
operator|)
expr_stmt|;
name|A_special
operator|=
operator|(
name|ftype
operator|==
name|S_IFBLK
operator|)
ifdef|#
directive|ifdef
name|S_IFIFO
operator|||
operator|(
name|ftype
operator|==
name|S_IFIFO
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFLNK
operator|||
operator|(
name|ftype
operator|==
name|S_IFLNK
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISOCK
operator|||
operator|(
name|ftype
operator|==
name|S_ISOCK
operator|)
endif|#
directive|endif
operator|||
operator|(
name|ftype
operator|==
name|S_IFCHR
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RT
name|A_special
operator||=
operator|(
name|ftype
operator|==
name|S_IFREC
operator|)
expr_stmt|;
name|One_extent
operator|=
operator|(
name|ftype
operator|==
name|S_IF1EXT
operator|)
expr_stmt|;
name|Multi_extent
operator|=
operator|(
name|ftype
operator|==
name|S_IFEXT
operator|)
expr_stmt|;
endif|#
directive|endif
name|Hdr
operator|.
name|h_magic
operator|=
name|MAGIC
expr_stmt|;
name|Hdr
operator|.
name|h_namesize
operator|=
name|strlen
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|Hdr
operator|.
name|h_uid
operator|=
name|Statb
operator|.
name|st_uid
expr_stmt|;
name|Hdr
operator|.
name|h_gid
operator|=
name|Statb
operator|.
name|st_gid
expr_stmt|;
name|Hdr
operator|.
name|h_dev
operator|=
name|Statb
operator|.
name|st_dev
expr_stmt|;
name|Hdr
operator|.
name|h_ino
operator|=
name|Statb
operator|.
name|st_ino
expr_stmt|;
name|Hdr
operator|.
name|h_mode
operator|=
name|Statb
operator|.
name|st_mode
expr_stmt|;
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|,
name|Statb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|h_nlink
operator|=
name|Statb
operator|.
name|st_nlink
expr_stmt|;
name|tlong
operator|=
operator|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|)
condition|?
name|Statb
operator|.
name|st_size
else|:
literal|0L
expr_stmt|;
ifdef|#
directive|ifdef
name|RT
if|if
condition|(
name|One_extent
operator|||
name|Multi_extent
condition|)
name|tlong
operator|=
name|Statb
operator|.
name|st_size
expr_stmt|;
endif|#
directive|endif
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|,
name|tlong
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|h_rdev
operator|=
name|Statb
operator|.
name|st_rdev
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
name|bintochar
argument_list|(
name|tlong
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_macro
name|bintochar
argument_list|(
argument|t
argument_list|)
end_macro

begin_comment
comment|/* ASCII header write */
end_comment

begin_decl_stmt
name|long
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sprintf
argument_list|(
name|Chdr
argument_list|,
literal|"%.6o%.6ho%.6ho%.6ho%.6ho%.6ho%.6ho%.6ho%.11lo%.6ho%.11lo%s"
argument_list|,
name|MAGIC
argument_list|,
name|Statb
operator|.
name|st_dev
argument_list|,
name|Statb
operator|.
name|st_ino
argument_list|,
name|Statb
operator|.
name|st_mode
argument_list|,
name|Statb
operator|.
name|st_uid
argument_list|,
name|Statb
operator|.
name|st_gid
argument_list|,
name|Statb
operator|.
name|st_nlink
argument_list|,
name|Statb
operator|.
name|st_rdev
operator|&
literal|00000177777
argument_list|,
name|Statb
operator|.
name|st_mtime
argument_list|,
operator|(
name|short
operator|)
name|strlen
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|)
operator|+
literal|1
argument_list|,
name|t
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|chartobin
argument_list|()
end_macro

begin_comment
comment|/* ASCII header read */
end_comment

begin_block
block|{
name|sscanf
argument_list|(
name|Chdr
argument_list|,
literal|"%6ho%6ho%6ho%6ho%6ho%6ho%6ho%6ho%11lo%6ho%11lo"
argument_list|,
operator|&
name|Hdr
operator|.
name|h_magic
argument_list|,
operator|&
name|Hdr
operator|.
name|h_dev
argument_list|,
operator|&
name|Hdr
operator|.
name|h_ino
argument_list|,
operator|&
name|Hdr
operator|.
name|h_mode
argument_list|,
operator|&
name|Hdr
operator|.
name|h_uid
argument_list|,
operator|&
name|Hdr
operator|.
name|h_gid
argument_list|,
operator|&
name|Hdr
operator|.
name|h_nlink
argument_list|,
operator|&
name|Hdr
operator|.
name|h_rdev
argument_list|,
operator|&
name|Longtime
argument_list|,
operator|&
name|Hdr
operator|.
name|h_namesize
argument_list|,
operator|&
name|Longfile
argument_list|)
expr_stmt|;
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|,
name|Longfile
argument_list|)
expr_stmt|;
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|,
name|Longtime
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gethdr
argument_list|()
end_macro

begin_comment
comment|/* get file headers */
end_comment

begin_block
block|{
specifier|register
name|ushort
name|ftype
decl_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|readhdr
argument_list|(
name|Chdr
argument_list|,
name|CHARS
argument_list|)
expr_stmt|;
name|chartobin
argument_list|()
expr_stmt|;
block|}
else|else
name|bread
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Hdr
operator|.
name|h_magic
operator|!=
name|MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of phase--get help\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Cflag
condition|)
name|readhdr
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
else|else
name|bread
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
literal|"TRAILER!!!"
argument_list|)
condition|)
return|return
literal|0
return|;
name|ftype
operator|=
name|Hdr
operator|.
name|h_mode
operator|&
name|Filetype
expr_stmt|;
name|A_directory
operator|=
operator|(
name|ftype
operator|==
name|S_IFDIR
operator|)
expr_stmt|;
name|A_special
operator|=
operator|(
name|ftype
operator|==
name|S_IFBLK
operator|)
ifdef|#
directive|ifdef
name|S_IFIFO
operator|||
operator|(
name|ftype
operator|==
name|S_IFIFO
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFLNK
operator|||
operator|(
name|ftype
operator|==
name|S_IFLNK
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISOCK
operator|||
operator|(
name|ftype
operator|==
name|S_ISOCK
operator|)
endif|#
directive|endif
operator|||
operator|(
name|ftype
operator|==
name|S_IFCHR
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RT
name|A_special
operator||=
operator|(
name|ftype
operator|==
name|S_IFREC
operator|)
expr_stmt|;
name|One_extent
operator|=
operator|(
name|ftype
operator|==
name|S_IF1EXT
operator|)
expr_stmt|;
name|Multi_extent
operator|=
operator|(
name|ftype
operator|==
name|S_IFEXT
operator|)
expr_stmt|;
if|if
condition|(
name|One_extent
operator|||
name|Multi_extent
condition|)
block|{
name|Actual_size
index|[
literal|0
index|]
operator|=
name|Hdr
operator|.
name|h_filesize
index|[
literal|0
index|]
expr_stmt|;
name|Actual_size
index|[
literal|1
index|]
operator|=
name|Hdr
operator|.
name|h_filesize
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|readhdr
argument_list|(
name|Chdr
argument_list|,
name|CHARS
argument_list|)
expr_stmt|;
name|chartobin
argument_list|()
expr_stmt|;
block|}
else|else
name|bread
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Hdr
operator|.
name|h_magic
operator|!=
name|MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of phase--get RT help\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Cflag
condition|)
name|readhdr
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
else|else
name|bread
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_block

begin_expr_stmt
name|ckname
argument_list|(
name|namep
argument_list|)
comment|/* check filenames with patterns given on cmd line */
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|++
name|Select
expr_stmt|;
if|if
condition|(
name|fflag
operator|^
operator|!
name|nmatch
argument_list|(
name|namep
argument_list|,
name|Pattern
argument_list|)
condition|)
block|{
name|Select
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|Rename
operator|&&
operator|!
name|A_directory
condition|)
block|{
comment|/* rename interactively */
name|fprintf
argument_list|(
name|Wtty
argument_list|,
literal|"Rename<%s>\n"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|Wtty
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|namep
argument_list|,
name|MAXPATHLEN
argument_list|,
name|Rtty
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|Rtty
argument_list|)
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|namep
index|[
name|strlen
argument_list|(
name|namep
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|namep
argument_list|,
literal|""
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Skipped\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|S_IFLNK
if|if
condition|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
name|discardfile
argument_list|(
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|S_IFLNK
if|if
condition|(
name|Toc
operator|&&
operator|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
operator|)
condition|)
name|discardfile
argument_list|(
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|!
name|Toc
return|;
block|}
end_block

begin_expr_stmt
name|openout
argument_list|(
name|namep
argument_list|)
comment|/* open files for writing, set all necessary info */
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|f
expr_stmt|;
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
name|int
name|ans
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|namep
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
condition|)
name|namep
operator|+=
literal|2
expr_stmt|;
name|np
operator|=
name|namep
expr_stmt|;
comment|/* 	if(Option == IN) 		Cd_name = namep = cd(namep); */
if|if
condition|(
name|A_directory
condition|)
block|{
if|if
condition|(
operator|!
name|Dir
operator|||
name|Rename
operator|||
name|EQ
argument_list|(
name|namep
argument_list|,
literal|"."
argument_list|)
operator|||
name|EQ
argument_list|(
name|namep
argument_list|,
literal|".."
argument_list|)
condition|)
comment|/* do not consider . or .. files */
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|hflag
condition|?
name|stat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
else|:
name|lstat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* try creating (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|makdir
argument_list|(
name|namep
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|namep
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create directory for<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create directory<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|ret
label|:
if|if
condition|(
name|chmod
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chmod<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Uid
operator|==
literal|0
condition|)
if|if
condition|(
name|chown
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_uid
argument_list|,
name|Hdr
operator|.
name|h_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chown<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|set_time
argument_list|(
name|namep
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|Hdr
operator|.
name|h_nlink
operator|>
literal|1
condition|)
if|if
condition|(
operator|!
name|postml
argument_list|(
name|namep
argument_list|,
name|np
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|hflag
condition|?
name|stat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
else|:
name|lstat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|Uncond
operator|&&
operator|!
operator|(
operator|(
operator|!
operator|(
name|Xstatb
operator|.
name|st_mode
operator|&
name|S_IWRITE
operator|)
operator|||
name|A_special
operator|)
operator|&&
operator|(
name|Uid
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|namep
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot unlink current<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Uncond
operator|&&
operator|(
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
operator|<=
name|Xstatb
operator|.
name|st_mtime
operator|)
operator|&&
operator|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFLNK
operator|)
condition|)
block|{
comment|/* There's a newer version of file on destination */
if|if
condition|(
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
operator|<
name|Xstatb
operator|.
name|st_mtime
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current<%s> newer\n"
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|Option
operator|==
name|PASS
operator|&&
name|Hdr
operator|.
name|h_ino
operator|==
name|Xstatb
operator|.
name|st_ino
operator|&&
name|Hdr
operator|.
name|h_dev
operator|==
name|Xstatb
operator|.
name|st_dev
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Attempt to pass file to self!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|A_special
condition|)
block|{
ifdef|#
directive|ifdef
name|S_IFLNK
if|if
condition|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|Filetype
operator|)
operator|==
name|S_IFLNK
condition|)
block|{
name|ipsymlink
argument_list|(
name|namep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFIFO
if|if
condition|(
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
name|Filetype
operator|)
operator|==
name|S_IFIFO
condition|)
name|Hdr
operator|.
name|h_rdev
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* try creating (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|mknod
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|,
name|Hdr
operator|.
name|h_rdev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|np
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create directory for<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot mknod<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|ret
goto|;
block|}
ifdef|#
directive|ifdef
name|RT
if|if
condition|(
name|One_extent
operator|||
name|Multi_extent
condition|)
block|{
comment|/* try creating (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|falloc
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|,
name|longword
argument_list|(
name|Hdr
operator|.
name|h_filesize
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|np
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create directory for<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|filespace
operator|<
name|longword
argument_list|(
name|Hdr
operator|.
name|h_filesize
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create contiguous file<%s> proper size\n"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s> will be created as a regular file\n"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|Fullname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s> not removed\n"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|Hdr
operator|.
name|h_mode
operator|=
operator|(
name|Hdr
operator|.
name|h_mode
operator|&
operator|!
name|S_IFMT
operator|)
operator||
name|S_IFREG
expr_stmt|;
name|One_extent
operator|=
name|Multi_extent
operator|=
literal|0
expr_stmt|;
block|}
name|Hdr
operator|.
name|h_filesize
index|[
literal|0
index|]
operator|=
name|Actual_size
index|[
literal|0
index|]
expr_stmt|;
name|Hdr
operator|.
name|h_filesize
index|[
literal|1
index|]
operator|=
name|Actual_size
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|One_extent
operator|||
name|Multi_extent
operator|)
condition|)
block|{
endif|#
directive|endif
comment|/* try creating (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|creat
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|np
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create directory for<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|RT
block|}
endif|#
directive|endif
if|if
condition|(
name|Uid
operator|==
literal|0
condition|)
name|chown
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_uid
argument_list|,
name|Hdr
operator|.
name|h_gid
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_block

begin_expr_stmt
name|bread
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|nleft
operator|=
literal|0
expr_stmt|;
specifier|static
name|short
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|rv
decl_stmt|;
specifier|register
name|short
modifier|*
name|p
init|=
name|ip
decl_stmt|;
specifier|register
name|int
name|in
decl_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|--
condition|)
block|{
if|if
condition|(
name|nleft
operator|==
literal|0
condition|)
block|{
name|in
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|rv
operator|=
name|read
argument_list|(
name|Input
argument_list|,
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|Dbuf
operator|)
index|[
name|in
index|]
operator|)
argument_list|,
name|Bufsize
operator|-
name|in
argument_list|)
operator|)
operator|!=
name|Bufsize
operator|-
name|in
condition|)
block|{
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
block|{
name|Input
operator|=
name|chgreel
argument_list|(
literal|0
argument_list|,
name|Input
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|in
operator|+=
name|rv
expr_stmt|;
name|nleft
operator|+=
operator|(
name|rv
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
name|nleft
operator|+=
operator|(
name|rv
operator|>>
literal|1
operator|)
expr_stmt|;
name|p
operator|=
name|Dbuf
expr_stmt|;
operator|++
name|Blocks
expr_stmt|;
block|}
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|--
name|nleft
expr_stmt|;
block|}
name|ip
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|readhdr
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|nleft
operator|=
literal|0
expr_stmt|;
specifier|static
name|char
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|rv
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|ip
decl_stmt|;
specifier|register
name|int
name|in
decl_stmt|;
while|while
condition|(
name|c
operator|--
condition|)
block|{
if|if
condition|(
name|nleft
operator|==
literal|0
condition|)
block|{
name|in
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|rv
operator|=
name|read
argument_list|(
name|Input
argument_list|,
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|Cbuf
operator|)
index|[
name|in
index|]
operator|)
argument_list|,
name|Bufsize
operator|-
name|in
argument_list|)
operator|)
operator|!=
name|Bufsize
operator|-
name|in
condition|)
block|{
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
block|{
name|Input
operator|=
name|chgreel
argument_list|(
literal|0
argument_list|,
name|Input
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|in
operator|+=
name|rv
expr_stmt|;
name|nleft
operator|+=
name|rv
expr_stmt|;
block|}
name|nleft
operator|+=
name|rv
expr_stmt|;
name|p
operator|=
name|Cbuf
expr_stmt|;
operator|++
name|Blocks
expr_stmt|;
block|}
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|--
name|nleft
expr_stmt|;
block|}
name|ip
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|bwrite
argument_list|(
name|rp
argument_list|,
name|c
argument_list|)
specifier|register
name|short
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|wp
init|=
name|Wp
decl_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|Wct
condition|)
block|{
name|again
label|:
if|if
condition|(
name|write
argument_list|(
name|Output
argument_list|,
name|Dbuf
argument_list|,
name|Bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Output
operator|=
name|chgreel
argument_list|(
literal|1
argument_list|,
name|Output
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|Wct
operator|=
name|Bufsize
operator|>>
literal|1
expr_stmt|;
name|wp
operator|=
name|Dbuf
expr_stmt|;
operator|++
name|Blocks
expr_stmt|;
block|}
operator|*
name|wp
operator|++
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
operator|--
name|Wct
expr_stmt|;
block|}
name|Wp
operator|=
name|wp
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|writehdr
argument_list|(
name|rp
argument_list|,
name|c
argument_list|)
specifier|register
name|char
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|Cp
decl_stmt|;
while|while
condition|(
name|c
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|Wc
condition|)
block|{
name|again
label|:
if|if
condition|(
name|write
argument_list|(
name|Output
argument_list|,
name|Cbuf
argument_list|,
name|Bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Output
operator|=
name|chgreel
argument_list|(
literal|1
argument_list|,
name|Output
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|Wc
operator|=
name|Bufsize
expr_stmt|;
name|cp
operator|=
name|Cbuf
expr_stmt|;
operator|++
name|Blocks
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
operator|--
name|Wc
expr_stmt|;
block|}
name|Cp
operator|=
name|cp
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|postml
argument_list|(
name|namep
argument_list|,
name|np
argument_list|)
comment|/* linking funtion */
specifier|register
name|char
operator|*
name|namep
operator|,
operator|*
name|np
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|static
struct|struct
name|ml
block|{
name|short
name|m_dev
decl_stmt|,
name|m_ino
decl_stmt|;
name|char
name|m_name
index|[
literal|2
index|]
decl_stmt|;
block|}
modifier|*
name|ml
index|[
name|LINKS
index|]
struct|;
specifier|static
name|mlinks
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
name|mlp
decl_stmt|;
name|int
name|ans
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mlinks
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mlinks
operator|==
name|LINKS
condition|)
break|break;
if|if
condition|(
name|ml
index|[
name|i
index|]
operator|->
name|m_ino
operator|==
name|Hdr
operator|.
name|h_ino
operator|&&
name|ml
index|[
name|i
index|]
operator|->
name|m_dev
operator|==
name|Hdr
operator|.
name|h_dev
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"%s linked to %s\n"
argument_list|,
name|ml
index|[
name|i
index|]
operator|->
name|m_name
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|Option
operator|==
name|IN
operator|&&
operator|*
name|ml
index|[
name|i
index|]
operator|->
name|m_name
operator|!=
literal|'/'
condition|)
block|{
name|Fullname
index|[
name|Pathend
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|Fullname
argument_list|,
name|ml
index|[
name|i
index|]
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|mlp
operator|=
name|Fullname
expr_stmt|;
block|}
name|mlp
operator|=
name|ml
index|[
name|i
index|]
operator|->
name|m_name
expr_stmt|;
comment|/* try linking (only twice) */
name|ans
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|link
argument_list|(
name|mlp
argument_list|,
name|namep
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|np
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create directory for<%s> (errno:%d)\n"
argument_list|,
name|np
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot link<%s>&<%s>.\n"
argument_list|,
name|ml
index|[
name|i
index|]
operator|->
name|m_name
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|set_time
argument_list|(
name|namep
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|mlinks
operator|==
name|LINKS
operator|||
operator|!
operator|(
name|ml
index|[
name|mlinks
index|]
operator|=
operator|(
expr|struct
name|ml
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|np
argument_list|)
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ml
argument_list|)
argument_list|)
operator|)
condition|)
block|{
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|first
condition|)
if|if
condition|(
name|mlinks
operator|==
name|LINKS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many links\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No memory for links\n"
argument_list|)
expr_stmt|;
name|mlinks
operator|=
name|LINKS
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ml
index|[
name|mlinks
index|]
operator|->
name|m_dev
operator|=
name|Hdr
operator|.
name|h_dev
expr_stmt|;
name|ml
index|[
name|mlinks
index|]
operator|->
name|m_ino
operator|=
name|Hdr
operator|.
name|h_ino
expr_stmt|;
name|strcpy
argument_list|(
name|ml
index|[
name|mlinks
index|]
operator|->
name|m_name
argument_list|,
name|np
argument_list|)
expr_stmt|;
operator|++
name|mlinks
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_expr_stmt
name|pentry
argument_list|(
name|namep
argument_list|)
comment|/* print verbose table of contents */
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|short
name|lastid
init|=
operator|-
literal|1
decl_stmt|;
include|#
directive|include
file|<pwd.h>
specifier|static
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
specifier|static
name|char
name|tbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"%-7o"
argument_list|,
name|Hdr
operator|.
name|h_mode
operator|&
literal|0177777
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastid
operator|==
name|Hdr
operator|.
name|h_uid
condition|)
name|printf
argument_list|(
literal|"%-6s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|else
block|{
name|setpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|pw
operator|=
name|getpwuid
argument_list|(
operator|(
name|int
operator|)
name|Hdr
operator|.
name|h_uid
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-6s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|lastid
operator|=
name|Hdr
operator|.
name|h_uid
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%-6d"
argument_list|,
name|Hdr
operator|.
name|h_uid
argument_list|)
expr_stmt|;
name|lastid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%7ld "
argument_list|,
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
argument_list|)
expr_stmt|;
name|U
operator|.
name|l
operator|=
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tbuf
argument_list|,
name|ctime
argument_list|(
operator|(
name|long
operator|*
operator|)
operator|&
name|U
operator|.
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|" %s  %s\n"
argument_list|,
operator|&
name|tbuf
index|[
literal|4
index|]
argument_list|,
name|namep
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* pattern matching functions */
end_comment

begin_macro
name|nmatch
argument_list|(
argument|s
argument_list|,
argument|pat
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
modifier|*
name|pat
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|EQ
argument_list|(
operator|*
name|pat
argument_list|,
literal|"*"
argument_list|)
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|*
name|pat
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|pat
operator|==
literal|'!'
operator|&&
operator|!
name|gmatch
argument_list|(
name|s
argument_list|,
operator|*
name|pat
operator|+
literal|1
argument_list|)
operator|)
operator|||
name|gmatch
argument_list|(
name|s
argument_list|,
operator|*
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
operator|++
name|pat
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
name|gmatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|cc
operator|,
name|ok
operator|,
name|lc
operator|,
name|scc
expr_stmt|;
name|scc
operator|=
operator|*
name|s
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
condition|)
block|{
case|case
literal|'['
case|:
name|ok
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|']'
case|:
if|if
condition|(
name|ok
condition|)
return|return
operator|(
name|gmatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'-'
case|:
name|ok
operator||=
operator|(
operator|(
name|lc
operator|<=
name|scc
operator|)
operator|&&
operator|(
name|scc
operator|<=
operator|(
name|cc
operator|=
name|p
index|[
literal|1
index|]
operator|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|scc
operator|==
operator|(
name|lc
operator|=
name|cc
operator|)
condition|)
name|ok
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'?'
case|:
name|caseq
label|:
if|if
condition|(
name|scc
condition|)
return|return
operator|(
name|gmatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|umatch
argument_list|(
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
operator|!
name|scc
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|scc
condition|)
goto|goto
name|caseq
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|umatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|gmatch
argument_list|(
name|s
operator|++
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|S_IFLNK
end_ifdef

begin_comment
comment|/* If 4.2 BSD or greater, we have a nifty syscall for this .. */
end_comment

begin_macro
name|makdir
argument_list|(
argument|namep
argument_list|)
end_macro

begin_block
block|{
comment|/* 	 * Error:	mkdir returns -1, makdir returns 1 	 * Success:	mkdir returns  0, makdir returns 0 	 */
return|return
operator|(
operator|-
name|mkdir
argument_list|(
name|namep
argument_list|,
literal|0777
argument_list|)
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|makdir
argument_list|(
name|namep
argument_list|)
comment|/* make needed directories */
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|status
expr_stmt|;
specifier|register
name|pid
expr_stmt|;
if|if
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|pid
condition|)
empty_stmt|;
else|else
block|{
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/mkdir"
argument_list|,
literal|"mkdir"
argument_list|,
name|namep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|swap
argument_list|(
name|buf
argument_list|,
name|ct
argument_list|)
comment|/* swap halfwords, bytes or both */
specifier|register
name|ct
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
union|union
name|swp
block|{
name|long
name|longw
decl_stmt|;
name|short
name|shortv
index|[
literal|2
index|]
decl_stmt|;
name|char
name|charv
index|[
literal|4
index|]
decl_stmt|;
block|}
modifier|*
name|pbuf
union|;
name|int
name|savect
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|savebuf
decl_stmt|;
name|short
name|cc
decl_stmt|;
name|savect
operator|=
name|ct
expr_stmt|;
name|savebuf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|byteswap
operator|||
name|bothswap
condition|)
block|{
if|if
condition|(
name|ct
operator|%
literal|2
condition|)
name|buf
index|[
name|ct
index|]
operator|=
literal|0
expr_stmt|;
name|ct
operator|=
operator|(
name|ct
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|ct
operator|--
condition|)
block|{
name|c
operator|=
operator|*
name|buf
expr_stmt|;
operator|*
name|buf
operator|=
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
operator|=
name|c
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|bothswap
condition|)
block|{
name|ct
operator|=
name|savect
expr_stmt|;
name|pbuf
operator|=
operator|(
expr|union
name|swp
operator|*
operator|)
name|savebuf
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|ct
operator|%
sizeof|sizeof
argument_list|(
expr|union
name|swp
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|%
literal|2
condition|)
for|for
control|(
name|i
operator|=
name|ct
operator|+
literal|1
init|;
name|i
operator|<=
name|ct
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|swp
argument_list|)
operator|-
name|n
operator|)
condition|;
name|i
operator|++
control|)
name|pbuf
operator|->
name|charv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|ct
init|;
name|i
operator|<
name|ct
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|swp
argument_list|)
operator|-
name|n
operator|)
condition|;
name|i
operator|++
control|)
name|pbuf
operator|->
name|charv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ct
operator|=
operator|(
name|ct
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|swp
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|swp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ct
operator|--
condition|)
block|{
name|cc
operator|=
name|pbuf
operator|->
name|shortv
index|[
literal|0
index|]
expr_stmt|;
name|pbuf
operator|->
name|shortv
index|[
literal|0
index|]
operator|=
name|pbuf
operator|->
name|shortv
index|[
literal|1
index|]
expr_stmt|;
name|pbuf
operator|->
name|shortv
index|[
literal|1
index|]
operator|=
name|cc
expr_stmt|;
operator|++
name|pbuf
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|halfswap
condition|)
block|{
name|pbuf
operator|=
operator|(
expr|union
name|swp
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|ct
operator|%
sizeof|sizeof
argument_list|(
expr|union
name|swp
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
name|ct
init|;
name|i
operator|<
name|ct
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|swp
argument_list|)
operator|-
name|n
operator|)
condition|;
name|i
operator|++
control|)
name|pbuf
operator|->
name|charv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ct
operator|=
operator|(
name|ct
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|swp
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|swp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ct
operator|--
condition|)
block|{
name|cc
operator|=
name|pbuf
operator|->
name|shortv
index|[
literal|0
index|]
expr_stmt|;
name|pbuf
operator|->
name|shortv
index|[
literal|0
index|]
operator|=
name|pbuf
operator|->
name|shortv
index|[
literal|1
index|]
expr_stmt|;
name|pbuf
operator|->
name|shortv
index|[
literal|1
index|]
operator|=
name|cc
expr_stmt|;
operator|++
name|pbuf
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|set_time
argument_list|(
name|namep
argument_list|,
name|atime
argument_list|,
name|mtime
argument_list|)
comment|/* set access and modification times */
specifier|register
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|atime
decl_stmt|,
name|mtime
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|long
name|timevec
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|Mod_time
condition|)
return|return;
name|timevec
index|[
literal|0
index|]
operator|=
name|atime
expr_stmt|;
name|timevec
index|[
literal|1
index|]
operator|=
name|mtime
expr_stmt|;
name|utime
argument_list|(
name|namep
argument_list|,
name|timevec
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|chgreel
argument_list|(
argument|x
argument_list|,
argument|fl
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|f
expr_stmt|;
name|char
name|str
index|[
literal|22
index|]
decl_stmt|;
name|FILE
modifier|*
name|devtty
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"errno: %d, "
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't %s\n"
argument_list|,
name|x
condition|?
literal|"write output"
else|:
literal|"read input"
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fl
argument_list|,
operator|&
name|statb
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RT
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
operator|(
name|S_IFBLK
operator||
name|S_IFREC
operator|)
operator|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|again
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"If you want to go on, type device/file name when ready\n"
argument_list|)
expr_stmt|;
name|devtty
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|str
argument_list|,
literal|20
argument_list|,
name|devtty
argument_list|)
expr_stmt|;
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|str
argument_list|,
name|x
condition|?
literal|1
else|:
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"That didn't work"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|devtty
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
name|f
return|;
block|}
end_block

begin_expr_stmt
name|missdir
argument_list|(
name|namep
argument_list|)
specifier|register
name|char
operator|*
name|namep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
specifier|register
name|ct
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|np
operator|=
name|namep
init|;
operator|*
name|np
condition|;
operator|++
name|np
control|)
if|if
condition|(
operator|*
name|np
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|np
operator|==
name|namep
condition|)
continue|continue;
comment|/* skip over 'root slash' */
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|hflag
condition|?
name|stat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
else|:
name|lstat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|Dir
condition|)
block|{
if|if
condition|(
operator|(
name|ct
operator|=
name|makdir
argument_list|(
name|namep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|np
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|ct
operator|)
return|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"missing 'd' option\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|np
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|==
literal|2
condition|)
name|ct
operator|=
literal|0
expr_stmt|;
comment|/* the file already exists */
return|return
name|ct
return|;
block|}
end_block

begin_macro
name|pwd
argument_list|()
end_macro

begin_comment
comment|/* get working directory */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|popen
argument_list|(
literal|"pwd"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|Fullname
argument_list|,
literal|256
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|pclose
argument_list|(
name|dir
argument_list|)
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|Pathend
operator|=
name|strlen
argument_list|(
name|Fullname
argument_list|)
expr_stmt|;
name|Fullname
index|[
name|Pathend
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|cd
parameter_list|(
name|n
parameter_list|)
comment|/* change directories */
specifier|register
name|char
modifier|*
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|p_save
init|=
name|Name
decl_stmt|,
modifier|*
name|n_save
init|=
name|n
decl_stmt|,
modifier|*
name|p_end
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|Name
decl_stmt|;
specifier|static
name|char
name|dotdot
index|[]
init|=
literal|"../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../"
decl_stmt|;
name|int
name|slashes
decl_stmt|,
name|ans
decl_stmt|;
if|if
condition|(
operator|*
name|n
operator|==
literal|'/'
condition|)
comment|/* don't try to chdir on full pathnames */
return|return
name|n
return|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|*
name|n
operator|==
operator|*
name|p
condition|;
operator|++
name|p
operator|,
operator|++
name|n
control|)
block|{
comment|/* whatever part of strings == */
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p_save
operator|=
name|p
operator|+
literal|1
operator|,
name|n_save
operator|=
name|n
operator|+
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|p_save
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|slashes
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
comment|/* if prev is longer, chdir("..") */
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|slashes
expr_stmt|;
block|}
name|p
operator|=
name|p_save
expr_stmt|;
if|if
condition|(
name|slashes
condition|)
block|{
name|slashes
operator|=
name|slashes
operator|*
literal|3
operator|-
literal|1
expr_stmt|;
name|dotdot
index|[
name|slashes
index|]
operator|=
literal|'\0'
expr_stmt|;
name|chdir
argument_list|(
name|dotdot
argument_list|)
expr_stmt|;
name|dotdot
index|[
name|slashes
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|n
operator|=
name|n_save
expr_stmt|;
for|for
control|(
init|;
operator|*
name|n
condition|;
operator|++
name|n
operator|,
operator|++
name|p
control|)
block|{
operator|*
name|p
operator|=
operator|*
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|n
operator|==
literal|'/'
condition|)
name|p_end
operator|=
name|p
operator|+
literal|1
operator|,
name|n_save
operator|=
name|n
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p_end
condition|)
block|{
operator|*
name|p_end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|p_save
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|ans
operator|=
name|missdir
argument_list|(
name|p_save
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chdir (no `d' option)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chdir - no write permission\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chdir
argument_list|(
name|p_save
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chdir\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
operator|*
name|p_save
operator|=
literal|'\0'
expr_stmt|;
return|return
name|n_save
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RT
end_ifdef

begin_expr_stmt
name|actsize
argument_list|(
name|file
argument_list|)
specifier|register
name|int
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|long
name|tlong
decl_stmt|;
name|long
name|fsize
parameter_list|()
function_decl|;
specifier|register
name|int
name|tfile
decl_stmt|;
name|Actual_size
index|[
literal|0
index|]
operator|=
name|Hdr
operator|.
name|h_filesize
index|[
literal|0
index|]
expr_stmt|;
name|Actual_size
index|[
literal|1
index|]
operator|=
name|Hdr
operator|.
name|h_filesize
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|Extent
condition|)
return|return;
if|if
condition|(
name|file
condition|)
name|tfile
operator|=
name|file
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tfile
operator|=
name|open
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|tlong
operator|=
name|fsize
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|,
name|tlong
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
name|bintochar
argument_list|(
name|tlong
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
name|close
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|S_IFLNK
end_ifdef

begin_macro
name|outsymlink
argument_list|()
end_macro

begin_block
block|{
name|short
name|simlnksz
decl_stmt|;
if|if
condition|(
operator|(
name|simlnksz
operator|=
name|readlink
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Cflag
condition|?
name|BBuf
else|:
operator|(
name|char
operator|*
operator|)
name|Buf
argument_list|,
name|CPIOBSZ
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s> ?\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|MKSHORT
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|,
call|(
name|long
call|)
argument_list|(
name|simlnksz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Option
operator|==
name|OUT
condition|)
block|{
comment|/* Option!=PASS */
if|if
condition|(
name|Cflag
condition|)
block|{
name|writehdr
argument_list|(
name|Chdr
argument_list|,
name|CHARS
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
name|writehdr
argument_list|(
name|BBuf
argument_list|,
name|simlnksz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bwrite
argument_list|(
operator|&
name|Hdr
argument_list|,
name|HDRSIZE
operator|+
name|Hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|Buf
argument_list|,
name|simlnksz
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Acc_time
condition|)
name|set_time
argument_list|(
name|Hdr
operator|.
name|h_name
argument_list|,
name|Statb
operator|.
name|st_atime
argument_list|,
name|Statb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
operator|&&
name|Option
operator|==
name|OUT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|Hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ipsymlink
argument_list|(
argument|namep
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|namep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ans
decl_stmt|;
name|long
name|linklen
decl_stmt|;
name|int
name|statres
decl_stmt|;
comment|/* 	 * Get information concerning symbolic link. 	 */
if|if
condition|(
name|Option
operator|==
name|IN
condition|)
block|{
name|linklen
operator|=
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|linklen
operator|>
name|CPIOBSZ
condition|)
block|{
comment|/* This is fucked up.... */
comment|/* Print error and try to recover.... */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Symbolic link<%s> too long\n"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|discardfile
argument_list|(
name|linklen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * This is what normally happens for IN Option.. 		 */
if|if
condition|(
name|Cflag
condition|)
name|readhdr
argument_list|(
name|BBuf
argument_list|,
operator|(
name|int
operator|)
name|linklen
argument_list|)
expr_stmt|;
else|else
name|bread
argument_list|(
name|Buf
argument_list|,
operator|(
name|int
operator|)
name|linklen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Option == PASS */
name|outsymlink
argument_list|()
expr_stmt|;
name|linklen
operator|=
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_filesize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Null terminate the value of the symbolic link... 	 *   (what it points to..). 	 */
if|if
condition|(
name|Cflag
condition|)
name|BBuf
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
operator|(
name|char
operator|*
operator|)
name|Buf
operator|)
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|statres
operator|=
name|hflag
condition|?
name|stat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
else|:
name|lstat
argument_list|(
name|namep
argument_list|,
operator|&
name|Xstatb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Uncond
operator|&&
operator|(
name|statres
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mklong
argument_list|(
name|Hdr
operator|.
name|h_mtime
argument_list|)
operator|<=
name|Xstatb
operator|.
name|st_mtime
operator|)
condition|)
block|{
comment|/* There's a newer version of symbolic link on destination */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current<%s> newer\n"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * unlink an old symbolic link if it is present.. 	 */
if|if
condition|(
operator|(
name|statres
operator|==
literal|0
operator|)
operator|&&
operator|(
name|unlink
argument_list|(
name|namep
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot unlink existing symbolic link<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Make the link.. 	 */
name|ans
operator|=
literal|0
expr_stmt|;
name|umask
argument_list|(
operator|(
operator|~
name|Hdr
operator|.
name|h_mode
operator|)
operator|&
literal|0777
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|symlink
argument_list|(
operator|(
name|Cflag
condition|?
name|BBuf
else|:
operator|(
name|char
operator|*
operator|)
operator|(
name|Buf
operator|)
operator|)
argument_list|,
name|namep
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ans
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ans
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ans
operator|<
literal|2
operator|&&
name|missdir
argument_list|(
name|namep
argument_list|)
operator|==
literal|0
condition|)
do|;
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create directory for<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ans
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create symbolic link<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|Uid
operator|==
literal|0
operator|&&
name|chown
argument_list|(
name|namep
argument_list|,
name|Hdr
operator|.
name|h_uid
argument_list|,
name|Hdr
operator|.
name|h_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot chown<%s> (errno:%d)\n"
argument_list|,
name|namep
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * No way to set the modify time on a symbolic link.. 	 */
comment|/* 	 * Pass through option will miss printing this one.. 	 */
if|if
condition|(
operator|(
name|Option
operator|==
name|PASS
operator|)
operator|&&
name|Verbose
condition|)
name|puts
argument_list|(
name|namep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IFLNK
end_ifndef

begin_macro
name|symlink
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|lstat
argument_list|(
argument|name
argument_list|,
argument|statb
argument_list|)
end_macro

begin_expr_stmt
name|char
operator|*
name|name
expr|struct
name|stat
operator|*
name|statb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|stat
argument_list|(
name|name
argument_list|,
name|statb
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|discardfile
argument_list|(
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|long
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|len
operator|>
name|CPIOBSZ
condition|)
block|{
if|if
condition|(
name|Cflag
condition|)
name|readhdr
argument_list|(
name|BBuf
argument_list|,
name|CPIOBSZ
argument_list|)
expr_stmt|;
else|else
name|bread
argument_list|(
name|Buf
argument_list|,
name|CPIOBSZ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|Cflag
condition|)
name|readhdr
argument_list|(
name|BBuf
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
else|else
name|bread
argument_list|(
name|Buf
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

