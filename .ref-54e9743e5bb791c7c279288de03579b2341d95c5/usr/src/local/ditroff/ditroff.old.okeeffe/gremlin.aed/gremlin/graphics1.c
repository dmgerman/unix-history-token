begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)graphics1.c	1.3	%G%  *  * Copyright -C- 1982 Barry S. Roitblat  *  *  * This file contains primitive functions to manipulate an AED512  * color display.  *  * (Modified from software written by John Ousterhout for the caesar  *  program)  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_comment
comment|/* The following variables are used to hold state that we keep around  * between procedure calls in order to reduce the amount of information  * that must be shipped to the terminal.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to buffer display characters */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|sgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to save terminal control bits */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sgflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to save flags from sgttyb */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sgispeed
decl_stmt|,
name|sgospeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to save baud rates */
end_comment

begin_decl_stmt
specifier|static
name|int
name|localmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to save terminal local mode word */
end_comment

begin_expr_stmt
specifier|static
name|curcharsize
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Current character size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current write mask value */
end_comment

begin_comment
comment|/* The following strings are used to as the colors for drawing and  * erasing.  They permit layer inversion, such that the drawing of  * the layer causes zeroes to be written and erasing causes ones to  * be written.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|draw
index|[
literal|4
index|]
decl_stmt|,
name|erase
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following arrays are used to define the line styles we use for  * for drawing.  Color and stipple are used as a representation of  * styles on the AED but are not necessarily accurate with the final  * output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stylecolor
index|[
literal|11
index|]
init|=
block|{
literal|0
block|,
literal|041
block|,
literal|041
block|,
literal|043
block|,
literal|041
block|,
literal|041
block|,
literal|042
block|,
literal|044
block|,
literal|044
block|,
literal|0200
block|,
literal|0100
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stipple
index|[
literal|11
index|]
init|=
block|{
literal|255
block|,
literal|136
block|,
literal|228
block|,
literal|255
block|,
literal|240
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|136
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following table contains the color lookup used to represent  * different fonts on the AED.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fontmap
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|041
block|,
literal|044
block|,
literal|045
block|,
literal|046
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variables are made available to the outside world. */
end_comment

begin_decl_stmt
name|int
name|GrXMax
init|=
literal|511
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum x-coordinate of screen */
end_comment

begin_decl_stmt
name|int
name|GrYMax
init|=
literal|482
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum y-coordinate of screen */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The file for the AED512 */
end_comment

begin_decl_stmt
name|int
name|charxsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character x dimension */
end_comment

begin_decl_stmt
name|int
name|charysize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character y dimension */
end_comment

begin_decl_stmt
name|int
name|descenders
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character descender length */
end_comment

begin_decl_stmt
name|int
name|curx
decl_stmt|,
name|cury
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current access position */
end_comment

begin_decl_stmt
name|int
name|rmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* read mask */
end_comment

begin_comment
comment|/* The following table is used to convert numbers to hex.  We cannot use  * standard C library conversion because it generates lower case letters  * which are bad news to the AED512.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|FASTIO
end_ifndef

begin_macro
name|GRchex
argument_list|(
argument|val
argument_list|,
argument|string
argument_list|,
argument|nchars
argument_list|)
end_macro

begin_decl_stmt
name|int
name|val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Integer value to be converted. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to string area to be used for 				 * converted result. 				 */
end_comment

begin_decl_stmt
name|int
name|nchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters to be converted. */
end_comment

begin_comment
comment|/*---------------------------------------------------------  *	This is a routine that converts an integer to a string  *	of hexadecimal characters.  *  *	Results:	None.  *  *	Side Effects:  *	The string contains the value of the low-order nchars 4-bit chunks  *	of val, as represented in hexadecimal.  String is zero-filled.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|string
operator|=
operator|&
operator|(
name|string
index|[
name|nchars
index|]
operator|)
expr_stmt|;
operator|*
name|string
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|nchars
operator|>
literal|0
condition|;
name|nchars
operator|--
control|)
block|{
operator|*
operator|(
operator|--
name|string
operator|)
operator|=
name|hex
index|[
name|val
operator|&
literal|017
index|]
expr_stmt|;
name|val
operator|>>=
literal|4
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|GRsetwmask
argument_list|(
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New value for write mask */
end_comment

begin_comment
comment|/*---------------------------------------------------------  *	This is a routine that resets the value of the current  *	write mask, if necessary.  *  *	Results:	None.  *  *	Side Effects:  *	If wmask is different from mask, then the new mask is output to  *	the display and stored in wmask.  *  *	Errors:		None.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|char
name|s
index|[
literal|4
index|]
decl_stmt|;
name|wmask
operator|=
name|mask
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTIO
name|GRchex
argument_list|(
name|wmask
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"L%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|putc
argument_list|(
literal|'L'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|mask
operator|&
literal|0377
argument_list|,
name|display
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|GRsetcolor
argument_list|(
argument|color
argument_list|)
end_macro

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   *      This routine sets the current color for the graphics display  */
end_comment

begin_block
block|{
ifndef|#
directive|ifndef
name|FASTIO
name|char
name|s1
index|[
literal|3
index|]
decl_stmt|;
name|GRchex
argument_list|(
name|color
argument_list|,
name|s1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"C%s"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"C%c"
argument_list|,
name|color
operator|&
literal|0377
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* end setcolor */
end_comment

begin_macro
name|GRoutxy20
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The coordinates to be output */
end_comment

begin_comment
comment|/*---------------------------------------------------------  *	This routine outputs an x-y coordinate pair in the standard  *	format required by the AED display.  *  *	Results:	None.  *	  *	Side Effects:  *	Characters are output to the AED512 in the standard way required  *	for values indicated by "xy20" in the user manual.  *  *	Errors:		None.  *  * (Modified from software written by John Ousterhout for the caesar  *  program)  *---------------------------------------------------------  */
end_comment

begin_block
block|{
ifndef|#
directive|ifndef
name|FASTIO
name|char
name|s1
index|[
literal|4
index|]
decl_stmt|,
name|s2
index|[
literal|4
index|]
decl_stmt|,
name|s3
index|[
literal|4
index|]
decl_stmt|;
name|GRchex
argument_list|(
operator|(
operator|(
name|y
operator|>>
literal|8
operator|)
operator|&
literal|03
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|6
operator|)
operator|&
literal|014
operator|)
argument_list|,
name|s1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|GRchex
argument_list|(
name|x
operator|&
literal|0377
argument_list|,
name|s2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|GRchex
argument_list|(
name|y
operator|&
literal|0377
argument_list|,
name|s3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"%s%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
else|#
directive|else
name|putc
argument_list|(
operator|(
operator|(
name|x
operator|>>
literal|4
operator|)
operator|&
literal|020
operator|)
operator|+
operator|(
operator|(
name|y
operator|>>
literal|8
operator|)
operator|&
literal|01
operator|)
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|x
operator|&
literal|0377
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|y
operator|&
literal|0377
argument_list|,
name|display
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|GRsetpos
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Screen coordinates.  /*---------------------------------------------------------  *	This routine sets the current access position, if necessary.  *  *	Results:	None.  *  *	Side Effects:  *	If x and y are equal to curx and cury, respectively, then nothing  *	happens.  Otherwise, x and y are stored into curx and cury and the  *	current access position of the AED is set to those coordinates.  *  *	Errors:		None.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
if|if
condition|(
name|x
operator|==
name|curx
operator|&&
name|y
operator|==
name|cury
condition|)
return|return;
name|curx
operator|=
name|x
expr_stmt|;
name|cury
operator|=
name|y
expr_stmt|;
name|putc
argument_list|(
literal|'Q'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|GRoutxy20
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|GRsetcharstyle
argument_list|(
argument|style
argument_list|)
end_macro

begin_decl_stmt
name|int
name|style
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New font. */
end_comment

begin_comment
comment|/*---------------------------------------------------------  *	This routine sets the current character style.  *  *	Results:	None.  *  *	Side Effects:  *	A new character style is output to the display.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|GRsetcolor
argument_list|(
name|fontmap
index|[
name|style
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|GRsetlinestyle
argument_list|(
argument|style
argument_list|)
end_macro

begin_decl_stmt
name|int
name|style
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New stipple pattern for lines. */
end_comment

begin_comment
comment|/*---------------------------------------------------------  *	This routine sets the current line style.  *  *	Results:	None.  *  *	Side Effects:  *	A new line style is output to the display.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|char
name|s
index|[
literal|4
index|]
decl_stmt|;
name|GRsetcolor
argument_list|(
name|stylecolor
index|[
name|style
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTIO
name|GRchex
argument_list|(
name|stipple
index|[
name|style
index|]
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"1%sFF"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|putc
argument_list|(
literal|'1'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|stipple
index|[
name|style
index|]
operator|&
literal|0377
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0377
argument_list|,
name|display
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|GRsetcharsize
argument_list|(
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character size (1 - 4) */
end_comment

begin_comment
comment|/*---------------------------------------------------------  *	This routine sets the character size in the display,  *	if necessary.  *  *	Results:	None.  *  *	Side Effects:  *	If the current display character size isn't already equal to size,  *	then it is made so.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
if|if
condition|(
name|size
operator|==
name|curcharsize
condition|)
return|return;
name|curcharsize
operator|=
name|size
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTIO
if|if
condition|(
name|curcharsize
operator|==
literal|4
condition|)
block|{
name|fputs
argument_list|(
literal|"^270F18L"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|charxsize
operator|=
literal|15
expr_stmt|;
name|charysize
operator|=
literal|24
expr_stmt|;
name|descenders
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curcharsize
operator|==
literal|3
condition|)
block|{
name|fputs
argument_list|(
literal|"^250A0EL"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|charxsize
operator|=
literal|10
expr_stmt|;
name|charysize
operator|=
literal|14
expr_stmt|;
name|descenders
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curcharsize
operator|==
literal|2
condition|)
block|{
name|fputs
argument_list|(
literal|"^17070CL"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|charxsize
operator|=
literal|8
expr_stmt|;
name|charysize
operator|=
literal|12
expr_stmt|;
name|descenders
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"^15050BL"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|charxsize
operator|=
literal|6
expr_stmt|;
name|charysize
operator|=
literal|7
expr_stmt|;
name|descenders
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
else|#
directive|else
if|if
condition|(
name|curcharsize
operator|==
literal|4
condition|)
block|{
name|fputs
argument_list|(
literal|"^27\17\30L"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|charxsize
operator|=
literal|15
expr_stmt|;
name|charysize
operator|=
literal|24
expr_stmt|;
name|descenders
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curcharsize
operator|==
literal|3
condition|)
block|{
name|fputs
argument_list|(
literal|"^25\12\16L"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|charxsize
operator|=
literal|10
expr_stmt|;
name|charysize
operator|=
literal|14
expr_stmt|;
name|descenders
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curcharsize
operator|==
literal|2
condition|)
block|{
name|fputs
argument_list|(
literal|"^17\10\14L"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|charxsize
operator|=
literal|8
expr_stmt|;
name|charysize
operator|=
literal|12
expr_stmt|;
name|descenders
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"^15\6\7L"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|charxsize
operator|=
literal|6
expr_stmt|;
name|charysize
operator|=
literal|7
expr_stmt|;
name|descenders
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|GRInit
argument_list|(
argument|stream
argument_list|,
argument|invert
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the graphics display 				 * file descriptor.  The file must have 				 * been opened by the caller. 				 */
end_comment

begin_decl_stmt
name|int
name|invert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An integer whose low-order eight bits 				 * are ones iff the corresponding layers 				 * are to be inverted (drawing means write 				 * zeroes and erasing means write ones). 				 */
end_comment

begin_comment
comment|/*---------------------------------------------------------  *	GRInit initializes the graphics display and clears its screen.  *  *	Results:	None.  *  *	Side Effects:  *	The display is re-initialized and the file is remembered for  *	use in all subsequent calls to this module.  The display's  *	color map is reset.  The display is put into raw mode, but  *	the previous mode bits are saved.  *  *	Errors:		None.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
ifdef|#
directive|ifdef
name|FASTIO
specifier|static
name|int
name|litout
init|=
name|LLITOUT
decl_stmt|;
endif|#
directive|endif
specifier|static
name|int
name|ldisc
init|=
name|NTTYDISC
decl_stmt|;
comment|/* First, grab up the display modes, then reset them to put it      * into cooked mode.  Also, lock the terminal.  If doing fast I/O      * then set the LLITOUT bit.  Note:  setting the LLITOUT bit only      * works if it happens before the stty.  Also forces the display to      * run at 9600 baud.      */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|TIOCSETD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldisc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|TIOCLGET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|localmode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FASTIO
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|TIOCLBIS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|litout
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|gtty
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
name|sgflags
operator|=
name|sgttyb
operator|.
name|sg_flags
expr_stmt|;
name|sgispeed
operator|=
name|sgttyb
operator|.
name|sg_ispeed
expr_stmt|;
name|sgospeed
operator|=
name|sgttyb
operator|.
name|sg_ospeed
expr_stmt|;
name|sgttyb
operator|.
name|sg_flags
operator|=
operator|(
name|sgttyb
operator|.
name|sg_flags
operator|&
operator|~
operator|(
name|RAW
operator||
name|CBREAK
operator||
name|ECHO
operator||
name|LCASE
operator|)
operator|)
operator||
name|EVENP
operator||
name|ODDP
operator||
name|CRMOD
expr_stmt|;
name|sgttyb
operator|.
name|sg_ispeed
operator|=
name|B9600
expr_stmt|;
name|sgttyb
operator|.
name|sg_ospeed
operator|=
name|B9600
expr_stmt|;
operator|(
name|void
operator|)
name|stty
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|TIOCEXCL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
comment|/* Save the file pointer around for later use, then output an      * initialization string to the display.  The initialization      * string resets the terminal, sets formats, clears the display,      * and initializes the read and write masks.      */
name|display
operator|=
name|stream
expr_stmt|;
name|setbuf
argument_list|(
name|display
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTIO
name|GRchex
argument_list|(
name|invert
operator|&
literal|0377
argument_list|,
name|erase
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|GRchex
argument_list|(
operator|(
operator|~
name|invert
operator|)
operator|&
literal|0377
argument_list|,
name|draw
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\33\60"
argument_list|,
name|display
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
literal|"sleep 1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"\33\33G1HDHN[%sLFF\14\33C%sM7FFFFFFF"
argument_list|,
name|erase
argument_list|,
name|draw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"c404022]+00002019001F02828"
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|erase
operator|=
name|invert
operator|&
literal|0377
expr_stmt|;
operator|*
name|draw
operator|=
operator|(
operator|~
name|invert
operator|)
operator|&
literal|0377
expr_stmt|;
name|fputs
argument_list|(
literal|"\33\60"
argument_list|,
name|display
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
literal|"sleep 1"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\33\33G18D8N["
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|erase
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"L\377\14\33C"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|draw
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"M\177\377\377\377c\100\100\42]+"
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"2\01\220\01\360\50\50"
argument_list|,
name|display
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putc
argument_list|(
literal|'3'
argument_list|,
name|display
argument_list|)
expr_stmt|;
comment|/* Make sure the crosshair is off */
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|curx
operator|=
operator|-
literal|1
expr_stmt|;
name|cury
operator|=
operator|-
literal|1
expr_stmt|;
name|curcharsize
operator|=
operator|-
literal|1
expr_stmt|;
name|wmask
operator|=
literal|0177
expr_stmt|;
name|rmask
operator|=
literal|0177
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|GRClose
argument_list|()
end_macro

begin_comment
comment|/*---------------------------------------------------------  *	GRClose does whatever is necessary to reset the characteristics  *	of the AED512 after the program is finished.  *  *	Results:	None.  *  *	Side Effects:  *	The graphics display modes are reset.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|sgttyb
operator|.
name|sg_flags
operator|=
name|sgflags
expr_stmt|;
operator|(
name|void
operator|)
name|stty
argument_list|(
name|fileno
argument_list|(
name|display
argument_list|)
argument_list|,
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|display
argument_list|)
argument_list|,
name|TIOCNXCL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sgttyb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|display
argument_list|)
argument_list|,
name|TIOCLSET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|localmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|GRSetMap
argument_list|(
argument|pmap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to 256*3 bytes containing the 				 * new values for the color map.  The first 				 * three values are red, green, and blue 				 * intensities for color 0, and so on. 				 */
end_comment

begin_comment
comment|/*---------------------------------------------------------  *	GrSetMap outputs new values to the AED512 color map.  *  *	Results:	None.  *  *	Side Effects:  *	The values in the color map are set from the array indicated  *	by pmap.  The back1 and back2 strings are set so that the  *	routines GrBack1 and GrBack2 will switch the background color  *	to color 0 and color 256,respectively.  *  *	Errors:		None.  *  * (Modified from software written by John Ousterhout for the caesar  *  program)  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|char
name|s
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|pmap
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTIO
name|fputs
argument_list|(
literal|"K0000"
argument_list|,
name|display
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
operator|*
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|GRchex
argument_list|(
operator|*
name|p
operator|++
operator|&
literal|0377
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|putc
argument_list|(
literal|'K'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|display
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
operator|*
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|putc
argument_list|(
operator|*
name|p
operator|++
operator|&
literal|0377
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

