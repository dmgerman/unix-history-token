begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)misc.c	1.1 (CWI) 85/07/19"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"grap.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_decl_stmt
name|int
name|nnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of saved numbers */
end_comment

begin_decl_stmt
name|double
name|num
index|[
name|MAXNUM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|just
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current justification mode (RJUST, etc.) */
end_comment

begin_decl_stmt
name|int
name|sizeop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current optional operator for size change */
end_comment

begin_decl_stmt
name|double
name|sizexpr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current size change expression */
end_comment

begin_macro
name|savenum
argument_list|(
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_comment
comment|/* save f in num[n] */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|num
index|[
name|n
index|]
operator|=
name|f
expr_stmt|;
name|nnum
operator|=
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nnum
operator|>=
name|MAXNUM
condition|)
name|yyerror
argument_list|(
literal|"too many numbers"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setjust
argument_list|(
argument|j
argument_list|)
end_macro

begin_block
block|{
name|just
operator||=
name|j
expr_stmt|;
block|}
end_block

begin_macro
name|setsize
argument_list|(
argument|op
argument_list|,
argument|expr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|expr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sizeop
operator|=
name|op
expr_stmt|;
name|sizexpr
operator|=
name|expr
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|tostring
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"out of space in tostring on %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|range
argument_list|(
argument|pt
argument_list|)
end_macro

begin_comment
comment|/* update the range for point pt */
end_comment

begin_decl_stmt
name|Point
name|pt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Obj
modifier|*
name|p
init|=
name|pt
operator|.
name|obj
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|coord
operator|&
name|XFLAG
operator|)
condition|)
block|{
if|if
condition|(
name|pt
operator|.
name|x
operator|>
name|p
operator|->
name|pt1
operator|.
name|x
condition|)
name|p
operator|->
name|pt1
operator|.
name|x
operator|=
name|pt
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|pt
operator|.
name|x
operator|<
name|p
operator|->
name|pt
operator|.
name|x
condition|)
name|p
operator|->
name|pt
operator|.
name|x
operator|=
name|pt
operator|.
name|x
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|coord
operator|&
name|YFLAG
operator|)
condition|)
block|{
if|if
condition|(
name|pt
operator|.
name|y
operator|>
name|p
operator|->
name|pt1
operator|.
name|y
condition|)
name|p
operator|->
name|pt1
operator|.
name|y
operator|=
name|pt
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|pt
operator|.
name|y
operator|<
name|p
operator|->
name|pt
operator|.
name|y
condition|)
name|p
operator|->
name|pt
operator|.
name|y
operator|=
name|pt
operator|.
name|y
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|halfrange
argument_list|(
argument|p
argument_list|,
argument|side
argument_list|,
argument|val
argument_list|)
end_macro

begin_comment
comment|/* record max and min for one direction */
end_comment

begin_decl_stmt
name|Obj
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|side
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|coord
operator|&
name|XFLAG
operator|)
operator|&&
operator|(
name|side
operator|==
name|LEFT
operator|||
name|side
operator|==
name|RIGHT
operator|)
condition|)
block|{
if|if
condition|(
name|val
operator|<
name|p
operator|->
name|pt
operator|.
name|y
condition|)
name|p
operator|->
name|pt
operator|.
name|y
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|p
operator|->
name|pt1
operator|.
name|y
condition|)
name|p
operator|->
name|pt1
operator|.
name|y
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|coord
operator|&
name|YFLAG
operator|)
operator|&&
operator|(
name|side
operator|==
name|TOP
operator|||
name|side
operator|==
name|BOT
operator|)
condition|)
block|{
if|if
condition|(
name|val
operator|<
name|p
operator|->
name|pt
operator|.
name|x
condition|)
name|p
operator|->
name|pt
operator|.
name|x
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|p
operator|->
name|pt1
operator|.
name|x
condition|)
name|p
operator|->
name|pt1
operator|.
name|x
operator|=
name|val
expr_stmt|;
block|}
block|}
end_block

begin_function
name|Obj
modifier|*
name|lookup
parameter_list|(
name|s
parameter_list|,
name|inst
parameter_list|)
comment|/* find s in objlist, install if inst */
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|inst
decl_stmt|;
block|{
name|Obj
modifier|*
name|p
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|objlist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|inst
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|(
name|Obj
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"out of space in lookup"
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|tostring
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|NAME
expr_stmt|;
name|p
operator|->
name|pt
operator|=
name|ptmax
expr_stmt|;
name|p
operator|->
name|pt1
operator|=
name|ptmin
expr_stmt|;
name|p
operator|->
name|fval
operator|=
literal|0.0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|objlist
expr_stmt|;
name|objlist
operator|=
name|p
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|"lookup(%s,%d) = %d\n"
argument_list|,
name|s
argument_list|,
name|inst
argument_list|,
name|found
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|double
name|getvar
parameter_list|(
name|p
parameter_list|)
comment|/* return value of variable */
name|Obj
modifier|*
name|p
decl_stmt|;
block|{
return|return
name|p
operator|->
name|fval
return|;
block|}
end_function

begin_function
name|double
name|setvar
parameter_list|(
name|p
parameter_list|,
name|f
parameter_list|)
comment|/* set value of variable to f */
name|Obj
modifier|*
name|p
decl_stmt|;
name|double
name|f
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
literal|"pointsize"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* kludge */
name|pointsize
operator|=
name|f
expr_stmt|;
name|ps_set
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|->
name|type
operator|=
name|VARNAME
expr_stmt|;
return|return
name|p
operator|->
name|fval
operator|=
name|f
return|;
block|}
end_function

begin_function
name|Point
name|makepoint
parameter_list|(
name|s
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
comment|/* make a Point */
name|Obj
modifier|*
name|s
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|Point
name|p
decl_stmt|;
name|dprintf
argument_list|(
literal|"makepoint: %s, %g,%g\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|p
operator|.
name|obj
operator|=
name|s
expr_stmt|;
name|p
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|p
operator|.
name|y
operator|=
name|y
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|Attr
modifier|*
name|makefattr
parameter_list|(
name|type
parameter_list|,
name|fval
parameter_list|)
comment|/* set double in attribute */
name|int
name|type
decl_stmt|;
name|double
name|fval
decl_stmt|;
block|{
return|return
name|makeattr
argument_list|(
name|type
argument_list|,
name|fval
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|Attr
modifier|*
name|makesattr
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
comment|/* make an Attr cell containing s */
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|a
decl_stmt|;
comment|/* fake */
block|{
name|Attr
modifier|*
name|ap
init|=
name|makeattr
argument_list|(
name|STRING
argument_list|,
name|sizexpr
argument_list|,
name|s
argument_list|,
name|just
argument_list|,
name|sizeop
argument_list|)
decl_stmt|;
name|just
operator|=
name|sizeop
operator|=
literal|0
expr_stmt|;
name|sizexpr
operator|=
literal|0.0
expr_stmt|;
return|return
name|ap
return|;
block|}
end_function

begin_function
name|Attr
modifier|*
name|makeattr
parameter_list|(
name|type
parameter_list|,
name|fval
parameter_list|,
name|sval
parameter_list|,
name|just
parameter_list|,
name|op
parameter_list|)
name|int
name|type
decl_stmt|;
name|double
name|fval
decl_stmt|;
name|char
modifier|*
name|sval
decl_stmt|;
name|int
name|just
decl_stmt|,
name|op
decl_stmt|;
block|{
name|Attr
modifier|*
name|a
decl_stmt|;
name|a
operator|=
operator|(
name|Attr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"out of space in makeattr"
argument_list|)
expr_stmt|;
name|a
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|a
operator|->
name|fval
operator|=
name|fval
expr_stmt|;
name|a
operator|->
name|sval
operator|=
name|sval
expr_stmt|;
name|a
operator|->
name|just
operator|=
name|just
expr_stmt|;
name|a
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|a
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|Attr
modifier|*
name|addattr
parameter_list|(
name|a1
parameter_list|,
name|ap
parameter_list|)
comment|/* add attr ap to end of list a1 */
name|Attr
modifier|*
name|a1
decl_stmt|,
decl|*
name|ap
decl_stmt|;
end_function

begin_block
block|{
name|Attr
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
return|return
name|ap
return|;
if|if
condition|(
name|ap
operator|==
literal|0
condition|)
return|return
name|a1
return|;
for|for
control|(
name|p
operator|=
name|a1
init|;
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|next
operator|=
name|ap
expr_stmt|;
return|return
name|a1
return|;
block|}
end_block

begin_macro
name|freeattr
argument_list|(
argument|ap
argument_list|)
end_macro

begin_comment
comment|/* free an attribute list */
end_comment

begin_decl_stmt
name|Attr
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Attr
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|ap
condition|)
block|{
name|p
operator|=
name|ap
operator|->
name|next
expr_stmt|;
comment|/* save next */
if|if
condition|(
name|ap
operator|->
name|sval
condition|)
name|free
argument_list|(
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|=
name|p
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|slprint
parameter_list|(
name|stringlist
parameter_list|)
comment|/* print strings from stringlist */
name|Attr
modifier|*
name|stringlist
decl_stmt|;
block|{
name|int
name|ntext
decl_stmt|,
name|n
decl_stmt|,
name|last_op
decl_stmt|,
name|last_just
decl_stmt|;
name|double
name|last_fval
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|Attr
modifier|*
name|ap
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|last_op
operator|=
name|last_just
operator|=
literal|0
expr_stmt|;
name|last_fval
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|ntext
operator|=
literal|0
operator|,
name|ap
operator|=
name|stringlist
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
name|ntext
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"box invis wid 0 ht %d*textht"
argument_list|,
name|ntext
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|stringlist
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|op
operator|==
literal|0
condition|)
block|{
comment|/* propagate last value */
name|ap
operator|->
name|op
operator|=
name|last_op
expr_stmt|;
name|ap
operator|->
name|fval
operator|=
name|last_fval
expr_stmt|;
block|}
else|else
block|{
name|last_op
operator|=
name|ap
operator|->
name|op
expr_stmt|;
name|last_fval
operator|=
name|ap
operator|->
name|fval
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
literal|" \"%s\""
argument_list|,
name|ps_set
operator|||
name|ap
operator|->
name|op
condition|?
name|sizeit
argument_list|(
name|ap
argument_list|)
else|:
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|just
condition|)
name|last_just
operator|=
name|ap
operator|->
name|just
expr_stmt|;
if|if
condition|(
name|last_just
condition|)
name|strcat
argument_list|(
name|buf
operator|+
name|n
argument_list|,
name|juststr
argument_list|(
name|last_just
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
comment|/* watch it:  static */
block|}
end_function

begin_function
name|char
modifier|*
name|juststr
parameter_list|(
name|j
parameter_list|)
comment|/* convert RJUST, etc., into string */
name|int
name|j
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|RJUST
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" rjust"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|LJUST
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" ljust"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|ABOVE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" above"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|BELOW
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" below"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
comment|/* watch it:  static */
block|}
end_function

end_unit

