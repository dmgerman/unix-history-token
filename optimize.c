begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994, 1995, 1996  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *  Optimization module for tcpdump intermediate representation.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<pcap-stdinc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _WIN32 */
end_comment

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_STDINT_H
end_elif

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BITYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bitypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"gencode.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_decl_stmt
name|int
name|pcap_optimizer_debug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
end_if

begin_function_decl
specifier|extern
name|int
name|_w32_ffs
parameter_list|(
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ffs
value|_w32_ffs
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * So is the check for _MSC_VER done because MinGW has this?  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_comment
comment|/*  * ffs -- vax ffs instruction  *  * XXX - with versions of VS that have it, use _BitScanForward()?  */
end_comment

begin_function
specifier|static
name|int
name|ffs
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
name|int
name|bit
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|bit
operator|=
literal|1
init|;
operator|!
operator|(
name|mask
operator|&
literal|1
operator|)
condition|;
name|bit
operator|++
control|)
name|mask
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|bit
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Represents a deleted instruction.  */
end_comment

begin_define
define|#
directive|define
name|NOP
value|-1
end_define

begin_comment
comment|/*  * Register numbers for use-def values.  * 0 through BPF_MEMWORDS-1 represent the corresponding scratch memory  * location.  A_ATOM is the accumulator and X_ATOM is the index  * register.  */
end_comment

begin_define
define|#
directive|define
name|A_ATOM
value|BPF_MEMWORDS
end_define

begin_define
define|#
directive|define
name|X_ATOM
value|(BPF_MEMWORDS+1)
end_define

begin_comment
comment|/*  * This define is used to represent *both* the accumulator and  * x register in use-def computations.  * Currently, the use-def code assumes only one definition per instruction.  */
end_comment

begin_define
define|#
directive|define
name|AX_ATOM
value|N_ATOMS
end_define

begin_comment
comment|/*  * These data structures are used in a Cocke and Shwarz style  * value numbering scheme.  Since the flowgraph is acyclic,  * exit values can be propagated from a node's predecessors  * provided it is uniquely defined.  */
end_comment

begin_struct
struct|struct
name|valnode
block|{
name|int
name|code
decl_stmt|;
name|int
name|v0
decl_stmt|,
name|v1
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|valnode
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Integer constants mapped with the load immediate opcode. */
end_comment

begin_define
define|#
directive|define
name|K
parameter_list|(
name|i
parameter_list|)
value|F(opt_state, BPF_LD|BPF_IMM|BPF_W, i, 0L)
end_define

begin_struct
struct|struct
name|vmapinfo
block|{
name|int
name|is_const
decl_stmt|;
name|bpf_int32
name|const_val
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_opt_state
block|{
comment|/* 	 * A flag to indicate that further optimization is needed. 	 * Iterative passes are continued until a given pass yields no 	 * branch movement. 	 */
name|int
name|done
decl_stmt|;
name|int
name|n_blocks
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|blocks
decl_stmt|;
name|int
name|n_edges
decl_stmt|;
name|struct
name|edge
modifier|*
modifier|*
name|edges
decl_stmt|;
comment|/* 	 * A bit vector set representation of the dominators. 	 * We round up the set size to the next power of two. 	 */
name|int
name|nodewords
decl_stmt|;
name|int
name|edgewords
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|levels
decl_stmt|;
name|bpf_u_int32
modifier|*
name|space
decl_stmt|;
define|#
directive|define
name|BITS_PER_WORD
value|(8*sizeof(bpf_u_int32))
comment|/*  * True if a is in uset {p}  */
define|#
directive|define
name|SET_MEMBER
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
define|\
value|((p)[(unsigned)(a) / BITS_PER_WORD]& (1<< ((unsigned)(a) % BITS_PER_WORD)))
comment|/*  * Add 'a' to uset p.  */
define|#
directive|define
name|SET_INSERT
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
define|\
value|(p)[(unsigned)(a) / BITS_PER_WORD] |= (1<< ((unsigned)(a) % BITS_PER_WORD))
comment|/*  * Delete 'a' from uset p.  */
define|#
directive|define
name|SET_DELETE
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
define|\
value|(p)[(unsigned)(a) / BITS_PER_WORD]&= ~(1<< ((unsigned)(a) % BITS_PER_WORD))
comment|/*  * a := a intersect b  */
define|#
directive|define
name|SET_INTERSECT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|{\ 	register bpf_u_int32 *_x = a, *_y = b;\ 	register int _n = n;\ 	while (--_n>= 0) *_x++&= *_y++;\ }
comment|/*  * a := a - b  */
define|#
directive|define
name|SET_SUBTRACT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|{\ 	register bpf_u_int32 *_x = a, *_y = b;\ 	register int _n = n;\ 	while (--_n>= 0) *_x++&=~ *_y++;\ }
comment|/*  * a := a union b  */
define|#
directive|define
name|SET_UNION
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|{\ 	register bpf_u_int32 *_x = a, *_y = b;\ 	register int _n = n;\ 	while (--_n>= 0) *_x++ |= *_y++;\ }
name|uset
name|all_dom_sets
decl_stmt|;
name|uset
name|all_closure_sets
decl_stmt|;
name|uset
name|all_edge_sets
decl_stmt|;
define|#
directive|define
name|MODULUS
value|213
name|struct
name|valnode
modifier|*
name|hashtbl
index|[
name|MODULUS
index|]
decl_stmt|;
name|int
name|curval
decl_stmt|;
name|int
name|maxval
decl_stmt|;
name|struct
name|vmapinfo
modifier|*
name|vmap
decl_stmt|;
name|struct
name|valnode
modifier|*
name|vnode_base
decl_stmt|;
name|struct
name|valnode
modifier|*
name|next_vnode
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* 	 * Some pointers used to convert the basic block form of the code, 	 * into the array form that BPF requires.  'fstart' will point to 	 * the malloc'd array while 'ftail' is used during the recursive 	 * traversal. 	 */
name|struct
name|bpf_insn
modifier|*
name|fstart
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|ftail
decl_stmt|;
block|}
name|conv_state_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|opt_init
parameter_list|(
name|compiler_state_t
modifier|*
parameter_list|,
name|opt_state_t
modifier|*
parameter_list|,
name|struct
name|icode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_cleanup
parameter_list|(
name|opt_state_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intern_blocks
parameter_list|(
name|opt_state_t
modifier|*
parameter_list|,
name|struct
name|icode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_inedges
parameter_list|(
name|opt_state_t
modifier|*
parameter_list|,
name|struct
name|block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|opt_dump
parameter_list|(
name|compiler_state_t
modifier|*
parameter_list|,
name|struct
name|icode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b)?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|find_levels_r
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
name|int
name|level
decl_stmt|;
if|if
condition|(
name|isMarked
argument_list|(
name|ic
argument_list|,
name|b
argument_list|)
condition|)
return|return;
name|Mark
argument_list|(
name|ic
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|find_levels_r
argument_list|(
name|opt_state
argument_list|,
name|ic
argument_list|,
name|JT
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|find_levels_r
argument_list|(
name|opt_state
argument_list|,
name|ic
argument_list|,
name|JF
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|level
operator|=
name|MAX
argument_list|(
name|JT
argument_list|(
name|b
argument_list|)
operator|->
name|level
argument_list|,
name|JF
argument_list|(
name|b
argument_list|)
operator|->
name|level
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|level
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|b
operator|->
name|link
operator|=
name|opt_state
operator|->
name|levels
index|[
name|level
index|]
expr_stmt|;
name|opt_state
operator|->
name|levels
index|[
name|level
index|]
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Level graph.  The levels go from 0 at the leaves to  * N_LEVELS at the root.  The opt_state->levels[] array points to the  * first node of the level list, whose elements are linked  * with the 'link' field of the struct block.  */
end_comment

begin_function
specifier|static
name|void
name|find_levels
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opt_state
operator|->
name|levels
argument_list|,
literal|0
argument_list|,
name|opt_state
operator|->
name|n_blocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|levels
argument_list|)
argument_list|)
expr_stmt|;
name|unMarkAll
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|find_levels_r
argument_list|(
name|opt_state
argument_list|,
name|ic
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find dominator relationships.  * Assumes graph has been leveled.  */
end_comment

begin_function
specifier|static
name|void
name|find_dom
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|block
modifier|*
name|root
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|bpf_u_int32
modifier|*
name|x
decl_stmt|;
comment|/* 	 * Initialize sets to contain all nodes. 	 */
name|x
operator|=
name|opt_state
operator|->
name|all_dom_sets
expr_stmt|;
name|i
operator|=
name|opt_state
operator|->
name|n_blocks
operator|*
name|opt_state
operator|->
name|nodewords
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|x
operator|++
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* Root starts off empty. */
for|for
control|(
name|i
operator|=
name|opt_state
operator|->
name|nodewords
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|root
operator|->
name|dom
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* root->level is the highest level no found. */
for|for
control|(
name|i
operator|=
name|root
operator|->
name|level
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
for|for
control|(
name|b
operator|=
name|opt_state
operator|->
name|levels
index|[
name|i
index|]
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link
control|)
block|{
name|SET_INSERT
argument_list|(
name|b
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|b
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|SET_INTERSECT
argument_list|(
name|JT
argument_list|(
name|b
argument_list|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|dom
argument_list|,
name|opt_state
operator|->
name|nodewords
argument_list|)
expr_stmt|;
name|SET_INTERSECT
argument_list|(
name|JF
argument_list|(
name|b
argument_list|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|dom
argument_list|,
name|opt_state
operator|->
name|nodewords
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|propedom
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|edge
modifier|*
name|ep
parameter_list|)
block|{
name|SET_INSERT
argument_list|(
name|ep
operator|->
name|edom
argument_list|,
name|ep
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|succ
condition|)
block|{
name|SET_INTERSECT
argument_list|(
name|ep
operator|->
name|succ
operator|->
name|et
operator|.
name|edom
argument_list|,
name|ep
operator|->
name|edom
argument_list|,
name|opt_state
operator|->
name|edgewords
argument_list|)
expr_stmt|;
name|SET_INTERSECT
argument_list|(
name|ep
operator|->
name|succ
operator|->
name|ef
operator|.
name|edom
argument_list|,
name|ep
operator|->
name|edom
argument_list|,
name|opt_state
operator|->
name|edgewords
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute edge dominators.  * Assumes graph has been leveled and predecessors established.  */
end_comment

begin_function
specifier|static
name|void
name|find_edom
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|block
modifier|*
name|root
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uset
name|x
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|x
operator|=
name|opt_state
operator|->
name|all_edge_sets
expr_stmt|;
for|for
control|(
name|i
operator|=
name|opt_state
operator|->
name|n_edges
operator|*
name|opt_state
operator|->
name|edgewords
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|x
index|[
name|i
index|]
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* root->level is the highest level no found. */
name|memset
argument_list|(
name|root
operator|->
name|et
operator|.
name|edom
argument_list|,
literal|0
argument_list|,
name|opt_state
operator|->
name|edgewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|uset
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|root
operator|->
name|ef
operator|.
name|edom
argument_list|,
literal|0
argument_list|,
name|opt_state
operator|->
name|edgewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|uset
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|root
operator|->
name|level
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
for|for
control|(
name|b
operator|=
name|opt_state
operator|->
name|levels
index|[
name|i
index|]
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|link
control|)
block|{
name|propedom
argument_list|(
name|opt_state
argument_list|,
operator|&
name|b
operator|->
name|et
argument_list|)
expr_stmt|;
name|propedom
argument_list|(
name|opt_state
argument_list|,
operator|&
name|b
operator|->
name|ef
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Find the backwards transitive closure of the flow graph.  These sets  * are backwards in the sense that we find the set of nodes that reach  * a given node, not the set of nodes that can be reached by a node.  *  * Assumes graph has been leveled.  */
end_comment

begin_function
specifier|static
name|void
name|find_closure
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|block
modifier|*
name|root
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
comment|/* 	 * Initialize sets to contain no nodes. 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opt_state
operator|->
name|all_closure_sets
argument_list|,
literal|0
argument_list|,
name|opt_state
operator|->
name|n_blocks
operator|*
name|opt_state
operator|->
name|nodewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|all_closure_sets
argument_list|)
argument_list|)
expr_stmt|;
comment|/* root->level is the highest level no found. */
for|for
control|(
name|i
operator|=
name|root
operator|->
name|level
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
for|for
control|(
name|b
operator|=
name|opt_state
operator|->
name|levels
index|[
name|i
index|]
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link
control|)
block|{
name|SET_INSERT
argument_list|(
name|b
operator|->
name|closure
argument_list|,
name|b
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|b
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|SET_UNION
argument_list|(
name|JT
argument_list|(
name|b
argument_list|)
operator|->
name|closure
argument_list|,
name|b
operator|->
name|closure
argument_list|,
name|opt_state
operator|->
name|nodewords
argument_list|)
expr_stmt|;
name|SET_UNION
argument_list|(
name|JF
argument_list|(
name|b
argument_list|)
operator|->
name|closure
argument_list|,
name|b
operator|->
name|closure
argument_list|,
name|opt_state
operator|->
name|nodewords
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return the register number that is used by s.  If A and X are both  * used, return AX_ATOM.  If no register is used, return -1.  *  * The implementation should probably change to an array access.  */
end_comment

begin_function
specifier|static
name|int
name|atomuse
parameter_list|(
name|struct
name|stmt
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|int
name|c
init|=
name|s
operator|->
name|code
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NOP
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|BPF_CLASS
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|BPF_RET
case|:
return|return
operator|(
name|BPF_RVAL
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_A
operator|)
condition|?
name|A_ATOM
else|:
operator|(
name|BPF_RVAL
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_X
operator|)
condition|?
name|X_ATOM
else|:
operator|-
literal|1
return|;
case|case
name|BPF_LD
case|:
case|case
name|BPF_LDX
case|:
return|return
operator|(
name|BPF_MODE
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_IND
operator|)
condition|?
name|X_ATOM
else|:
operator|(
name|BPF_MODE
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_MEM
operator|)
condition|?
name|s
operator|->
name|k
else|:
operator|-
literal|1
return|;
case|case
name|BPF_ST
case|:
return|return
name|A_ATOM
return|;
case|case
name|BPF_STX
case|:
return|return
name|X_ATOM
return|;
case|case
name|BPF_JMP
case|:
case|case
name|BPF_ALU
case|:
if|if
condition|(
name|BPF_SRC
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_X
condition|)
return|return
name|AX_ATOM
return|;
return|return
name|A_ATOM
return|;
case|case
name|BPF_MISC
case|:
return|return
name|BPF_MISCOP
argument_list|(
name|c
argument_list|)
operator|==
name|BPF_TXA
condition|?
name|X_ATOM
else|:
name|A_ATOM
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Return the register number that is defined by 's'.  We assume that  * a single stmt cannot define more than one register.  If no register  * is defined, return -1.  *  * The implementation should probably change to an array access.  */
end_comment

begin_function
specifier|static
name|int
name|atomdef
parameter_list|(
name|struct
name|stmt
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|code
operator|==
name|NOP
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|BPF_CLASS
argument_list|(
name|s
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_LD
case|:
case|case
name|BPF_ALU
case|:
return|return
name|A_ATOM
return|;
case|case
name|BPF_LDX
case|:
return|return
name|X_ATOM
return|;
case|case
name|BPF_ST
case|:
case|case
name|BPF_STX
case|:
return|return
name|s
operator|->
name|k
return|;
case|case
name|BPF_MISC
case|:
return|return
name|BPF_MISCOP
argument_list|(
name|s
operator|->
name|code
argument_list|)
operator|==
name|BPF_TAX
condition|?
name|X_ATOM
else|:
name|A_ATOM
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the sets of registers used, defined, and killed by 'b'.  *  * "Used" means that a statement in 'b' uses the register before any  * statement in 'b' defines it, i.e. it uses the value left in  * that register by a predecessor block of this block.  * "Defined" means that a statement in 'b' defines it.  * "Killed" means that a statement in 'b' defines it before any  * statement in 'b' uses it, i.e. it kills the value left in that  * register by a predecessor block of this block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_local_ud
parameter_list|(
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
name|atomset
name|def
init|=
literal|0
decl_stmt|,
name|use
init|=
literal|0
decl_stmt|,
name|killed
init|=
literal|0
decl_stmt|;
name|int
name|atom
decl_stmt|;
for|for
control|(
name|s
operator|=
name|b
operator|->
name|stmts
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
continue|continue;
name|atom
operator|=
name|atomuse
argument_list|(
operator|&
name|s
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|atom
operator|==
name|AX_ATOM
condition|)
block|{
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|X_ATOM
argument_list|)
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|X_ATOM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|A_ATOM
argument_list|)
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|A_ATOM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|<
name|N_ATOMS
condition|)
block|{
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|atom
argument_list|)
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|atom
operator|=
name|atomdef
argument_list|(
operator|&
name|s
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|use
argument_list|,
name|atom
argument_list|)
condition|)
name|killed
operator||=
name|ATOMMASK
argument_list|(
name|atom
argument_list|)
expr_stmt|;
name|def
operator||=
name|ATOMMASK
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BPF_CLASS
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_JMP
condition|)
block|{
comment|/* 		 * XXX - what about RET? 		 */
name|atom
operator|=
name|atomuse
argument_list|(
operator|&
name|b
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|atom
operator|==
name|AX_ATOM
condition|)
block|{
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|X_ATOM
argument_list|)
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|X_ATOM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|A_ATOM
argument_list|)
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|A_ATOM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atom
operator|<
name|N_ATOMS
condition|)
block|{
if|if
condition|(
operator|!
name|ATOMELEM
argument_list|(
name|def
argument_list|,
name|atom
argument_list|)
condition|)
name|use
operator||=
name|ATOMMASK
argument_list|(
name|atom
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|b
operator|->
name|def
operator|=
name|def
expr_stmt|;
name|b
operator|->
name|kill
operator|=
name|killed
expr_stmt|;
name|b
operator|->
name|in_use
operator|=
name|use
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assume graph is already leveled.  */
end_comment

begin_function
specifier|static
name|void
name|find_ud
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|block
modifier|*
name|root
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|maxlevel
decl_stmt|;
name|struct
name|block
modifier|*
name|p
decl_stmt|;
comment|/* 	 * root->level is the highest level no found; 	 * count down from there. 	 */
name|maxlevel
operator|=
name|root
operator|->
name|level
expr_stmt|;
for|for
control|(
name|i
operator|=
name|maxlevel
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
for|for
control|(
name|p
operator|=
name|opt_state
operator|->
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|compute_local_ud
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|out_use
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxlevel
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|p
operator|=
name|opt_state
operator|->
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|p
operator|->
name|out_use
operator||=
name|JT
argument_list|(
name|p
argument_list|)
operator|->
name|in_use
operator||
name|JF
argument_list|(
name|p
argument_list|)
operator|->
name|in_use
expr_stmt|;
name|p
operator|->
name|in_use
operator||=
name|p
operator|->
name|out_use
operator|&
operator|~
name|p
operator|->
name|kill
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_val
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|)
block|{
name|opt_state
operator|->
name|curval
operator|=
literal|0
expr_stmt|;
name|opt_state
operator|->
name|next_vnode
operator|=
name|opt_state
operator|->
name|vnode_base
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opt_state
operator|->
name|vmap
argument_list|,
literal|0
argument_list|,
name|opt_state
operator|->
name|maxval
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|vmap
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opt_state
operator|->
name|hashtbl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|opt_state
operator|->
name|hashtbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Because we really don't have an IR, this stuff is a little messy. */
end_comment

begin_function
specifier|static
name|int
name|F
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|v0
parameter_list|,
name|int
name|v1
parameter_list|)
block|{
name|u_int
name|hash
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|valnode
modifier|*
name|p
decl_stmt|;
name|hash
operator|=
operator|(
name|u_int
operator|)
name|code
operator|^
operator|(
name|v0
operator|<<
literal|4
operator|)
operator|^
operator|(
name|v1
operator|<<
literal|8
operator|)
expr_stmt|;
name|hash
operator|%=
name|MODULUS
expr_stmt|;
for|for
control|(
name|p
operator|=
name|opt_state
operator|->
name|hashtbl
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|code
operator|==
name|code
operator|&&
name|p
operator|->
name|v0
operator|==
name|v0
operator|&&
name|p
operator|->
name|v1
operator|==
name|v1
condition|)
return|return
name|p
operator|->
name|val
return|;
name|val
operator|=
operator|++
name|opt_state
operator|->
name|curval
expr_stmt|;
if|if
condition|(
name|BPF_MODE
argument_list|(
name|code
argument_list|)
operator|==
name|BPF_IMM
operator|&&
operator|(
name|BPF_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|BPF_LD
operator|||
name|BPF_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|BPF_LDX
operator|)
condition|)
block|{
name|opt_state
operator|->
name|vmap
index|[
name|val
index|]
operator|.
name|const_val
operator|=
name|v0
expr_stmt|;
name|opt_state
operator|->
name|vmap
index|[
name|val
index|]
operator|.
name|is_const
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|opt_state
operator|->
name|next_vnode
operator|++
expr_stmt|;
name|p
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|p
operator|->
name|v0
operator|=
name|v0
expr_stmt|;
name|p
operator|->
name|v1
operator|=
name|v1
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|opt_state
operator|->
name|hashtbl
index|[
name|hash
index|]
expr_stmt|;
name|opt_state
operator|->
name|hashtbl
index|[
name|hash
index|]
operator|=
name|p
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|vstore
parameter_list|(
name|struct
name|stmt
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|valp
parameter_list|,
name|int
name|newval
parameter_list|,
name|int
name|alter
parameter_list|)
block|{
if|if
condition|(
name|alter
operator|&&
operator|*
name|valp
operator|==
name|newval
condition|)
name|s
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
else|else
operator|*
name|valp
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do constant-folding on binary operators.  * (Unary operators are handled elsewhere.)  */
end_comment

begin_function
specifier|static
name|void
name|fold_op
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|stmt
modifier|*
name|s
parameter_list|,
name|int
name|v0
parameter_list|,
name|int
name|v1
parameter_list|)
block|{
name|bpf_u_int32
name|a
decl_stmt|,
name|b
decl_stmt|;
name|a
operator|=
name|opt_state
operator|->
name|vmap
index|[
name|v0
index|]
operator|.
name|const_val
expr_stmt|;
name|b
operator|=
name|opt_state
operator|->
name|vmap
index|[
name|v1
index|]
operator|.
name|const_val
expr_stmt|;
switch|switch
condition|(
name|BPF_OP
argument_list|(
name|s
operator|->
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_ADD
case|:
name|a
operator|+=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_SUB
case|:
name|a
operator|-=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_MUL
case|:
name|a
operator|*=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_DIV
case|:
if|if
condition|(
name|b
operator|==
literal|0
condition|)
name|bpf_error
argument_list|(
name|cstate
argument_list|,
literal|"division by zero"
argument_list|)
expr_stmt|;
name|a
operator|/=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_MOD
case|:
if|if
condition|(
name|b
operator|==
literal|0
condition|)
name|bpf_error
argument_list|(
name|cstate
argument_list|,
literal|"modulus by zero"
argument_list|)
expr_stmt|;
name|a
operator|%=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_AND
case|:
name|a
operator|&=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_OR
case|:
name|a
operator||=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_XOR
case|:
name|a
operator|^=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_LSH
case|:
name|a
operator|<<=
name|b
expr_stmt|;
break|break;
case|case
name|BPF_RSH
case|:
name|a
operator|>>=
name|b
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|s
operator|->
name|k
operator|=
name|a
expr_stmt|;
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|slist
modifier|*
name|this_op
parameter_list|(
name|struct
name|slist
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
name|s
operator|!=
literal|0
operator|&&
name|s
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_not
parameter_list|(
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|tmp
init|=
name|JT
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|JT
argument_list|(
name|b
argument_list|)
operator|=
name|JF
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|JF
argument_list|(
name|b
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_peep
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
name|struct
name|slist
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|val
decl_stmt|;
name|s
operator|=
name|b
operator|->
name|stmts
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
name|last
operator|=
name|s
expr_stmt|;
for|for
control|(
comment|/*empty*/
init|;
comment|/*empty*/
condition|;
name|s
operator|=
name|next
control|)
block|{
comment|/* 		 * Skip over nops. 		 */
name|s
operator|=
name|this_op
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
break|break;
comment|/* nothing left in the block */
comment|/* 		 * Find the next real instruction after that one 		 * (skipping nops). 		 */
name|next
operator|=
name|this_op
argument_list|(
name|s
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
break|break;
comment|/* no next instruction */
name|last
operator|=
name|next
expr_stmt|;
comment|/* 		 * st  M[k]	-->	st  M[k] 		 * ldx M[k]		tax 		 */
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|==
name|BPF_ST
operator|&&
name|next
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_LDX
operator||
name|BPF_MEM
operator|)
operator|&&
name|s
operator|->
name|s
operator|.
name|k
operator|==
name|next
operator|->
name|s
operator|.
name|k
condition|)
block|{
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_MISC
operator||
name|BPF_TAX
expr_stmt|;
block|}
comment|/* 		 * ld  #k	-->	ldx  #k 		 * tax			txa 		 */
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_LD
operator||
name|BPF_IMM
operator|)
operator|&&
name|next
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_MISC
operator||
name|BPF_TAX
operator|)
condition|)
block|{
name|s
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_LDX
operator||
name|BPF_IMM
expr_stmt|;
name|next
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_MISC
operator||
name|BPF_TXA
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * This is an ugly special case, but it happens 		 * when you say tcp[k] or udp[k] where k is a constant. 		 */
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_LD
operator||
name|BPF_IMM
operator|)
condition|)
block|{
name|struct
name|slist
modifier|*
name|add
decl_stmt|,
modifier|*
name|tax
decl_stmt|,
modifier|*
name|ild
decl_stmt|;
comment|/* 			 * Check that X isn't used on exit from this 			 * block (which the optimizer might cause). 			 * We know the code generator won't generate 			 * any local dependencies. 			 */
if|if
condition|(
name|ATOMELEM
argument_list|(
name|b
operator|->
name|out_use
argument_list|,
name|X_ATOM
argument_list|)
condition|)
continue|continue;
comment|/* 			 * Check that the instruction following the ldi 			 * is an addx, or it's an ldxms with an addx 			 * following it (with 0 or more nops between the 			 * ldxms and addx). 			 */
if|if
condition|(
name|next
operator|->
name|s
operator|.
name|code
operator|!=
operator|(
name|BPF_LDX
operator||
name|BPF_MSH
operator||
name|BPF_B
operator|)
condition|)
name|add
operator|=
name|next
expr_stmt|;
else|else
name|add
operator|=
name|this_op
argument_list|(
name|next
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|==
literal|0
operator|||
name|add
operator|->
name|s
operator|.
name|code
operator|!=
operator|(
name|BPF_ALU
operator||
name|BPF_ADD
operator||
name|BPF_X
operator|)
condition|)
continue|continue;
comment|/* 			 * Check that a tax follows that (with 0 or more 			 * nops between them). 			 */
name|tax
operator|=
name|this_op
argument_list|(
name|add
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tax
operator|==
literal|0
operator|||
name|tax
operator|->
name|s
operator|.
name|code
operator|!=
operator|(
name|BPF_MISC
operator||
name|BPF_TAX
operator|)
condition|)
continue|continue;
comment|/* 			 * Check that an ild follows that (with 0 or more 			 * nops between them). 			 */
name|ild
operator|=
name|this_op
argument_list|(
name|tax
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ild
operator|==
literal|0
operator|||
name|BPF_CLASS
argument_list|(
name|ild
operator|->
name|s
operator|.
name|code
argument_list|)
operator|!=
name|BPF_LD
operator|||
name|BPF_MODE
argument_list|(
name|ild
operator|->
name|s
operator|.
name|code
argument_list|)
operator|!=
name|BPF_IND
condition|)
continue|continue;
comment|/* 			 * We want to turn this sequence: 			 * 			 * (004) ldi     #0x2		{s} 			 * (005) ldxms   [14]		{next}  -- optional 			 * (006) addx			{add} 			 * (007) tax			{tax} 			 * (008) ild     [x+0]		{ild} 			 * 			 * into this sequence: 			 * 			 * (004) nop 			 * (005) ldxms   [14] 			 * (006) nop 			 * (007) nop 			 * (008) ild     [x+2] 			 * 			 * XXX We need to check that X is not 			 * subsequently used, because we want to change 			 * what'll be in it after this sequence. 			 * 			 * We know we can eliminate the accumulator 			 * modifications earlier in the sequence since 			 * it is defined by the last stmt of this sequence 			 * (i.e., the last statement of the sequence loads 			 * a value into the accumulator, so we can eliminate 			 * earlier operations on the accumulator). 			 */
name|ild
operator|->
name|s
operator|.
name|k
operator|+=
name|s
operator|->
name|s
operator|.
name|k
expr_stmt|;
name|s
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|add
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|tax
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * If the comparison at the end of a block is an equality 	 * comparison against a constant, and nobody uses the value 	 * we leave in the A register at the end of a block, and 	 * the operation preceding the comparison is an arithmetic 	 * operation, we can sometime optimize it away. 	 */
if|if
condition|(
name|b
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_JMP
operator||
name|BPF_JEQ
operator||
name|BPF_K
operator|)
operator|&&
operator|!
name|ATOMELEM
argument_list|(
name|b
operator|->
name|out_use
argument_list|,
name|A_ATOM
argument_list|)
condition|)
block|{
comment|/* 	    	 * We can optimize away certain subtractions of the 	    	 * X register. 	    	 */
if|if
condition|(
name|last
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_ALU
operator||
name|BPF_SUB
operator||
name|BPF_X
operator|)
condition|)
block|{
name|val
operator|=
name|b
operator|->
name|val
index|[
name|X_ATOM
index|]
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|vmap
index|[
name|val
index|]
operator|.
name|is_const
condition|)
block|{
comment|/* 				 * If we have a subtract to do a comparison, 				 * and the X register is a known constant, 				 * we can merge this value into the 				 * comparison: 				 * 				 * sub x  ->	nop 				 * jeq #y	jeq #(x+y) 				 */
name|b
operator|->
name|s
operator|.
name|k
operator|+=
name|opt_state
operator|->
name|vmap
index|[
name|val
index|]
operator|.
name|const_val
expr_stmt|;
name|last
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|s
operator|.
name|k
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If the X register isn't a constant, 				 * and the comparison in the test is 				 * against 0, we can compare with the 				 * X register, instead: 				 * 				 * sub x  ->	nop 				 * jeq #0	jeq x 				 */
name|last
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|b
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_JMP
operator||
name|BPF_JEQ
operator||
name|BPF_X
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Likewise, a constant subtract can be simplified: 		 * 		 * sub #x ->	nop 		 * jeq #y ->	jeq #(x+y) 		 */
elseif|else
if|if
condition|(
name|last
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_ALU
operator||
name|BPF_SUB
operator||
name|BPF_K
operator|)
condition|)
block|{
name|last
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|b
operator|->
name|s
operator|.
name|k
operator|+=
name|last
operator|->
name|s
operator|.
name|k
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * And, similarly, a constant AND can be simplified 		 * if we're testing against 0, i.e.: 		 * 		 * and #k	nop 		 * jeq #0  ->	jset #k 		 */
elseif|else
if|if
condition|(
name|last
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_ALU
operator||
name|BPF_AND
operator||
name|BPF_K
operator|)
operator|&&
name|b
operator|->
name|s
operator|.
name|k
operator|==
literal|0
condition|)
block|{
name|b
operator|->
name|s
operator|.
name|k
operator|=
name|last
operator|->
name|s
operator|.
name|k
expr_stmt|;
name|b
operator|->
name|s
operator|.
name|code
operator|=
name|BPF_JMP
operator||
name|BPF_K
operator||
name|BPF_JSET
expr_stmt|;
name|last
operator|->
name|s
operator|.
name|code
operator|=
name|NOP
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|opt_not
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * jset #0        ->   never 	 * jset #ffffffff ->   always 	 */
if|if
condition|(
name|b
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_JMP
operator||
name|BPF_K
operator||
name|BPF_JSET
operator|)
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|s
operator|.
name|k
operator|==
literal|0
condition|)
name|JT
argument_list|(
name|b
argument_list|)
operator|=
name|JF
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|b
operator|->
name|s
operator|.
name|k
operator|==
literal|0xffffffffU
condition|)
name|JF
argument_list|(
name|b
argument_list|)
operator|=
name|JT
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're comparing against the index register, and the index 	 * register is a known constant, we can just compare against that 	 * constant. 	 */
name|val
operator|=
name|b
operator|->
name|val
index|[
name|X_ATOM
index|]
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|vmap
index|[
name|val
index|]
operator|.
name|is_const
operator|&&
name|BPF_SRC
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_X
condition|)
block|{
name|bpf_int32
name|v
init|=
name|opt_state
operator|->
name|vmap
index|[
name|val
index|]
operator|.
name|const_val
decl_stmt|;
name|b
operator|->
name|s
operator|.
name|code
operator|&=
operator|~
name|BPF_X
expr_stmt|;
name|b
operator|->
name|s
operator|.
name|k
operator|=
name|v
expr_stmt|;
block|}
comment|/* 	 * If the accumulator is a known constant, we can compute the 	 * comparison result. 	 */
name|val
operator|=
name|b
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|vmap
index|[
name|val
index|]
operator|.
name|is_const
operator|&&
name|BPF_SRC
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_K
condition|)
block|{
name|bpf_int32
name|v
init|=
name|opt_state
operator|->
name|vmap
index|[
name|val
index|]
operator|.
name|const_val
decl_stmt|;
switch|switch
condition|(
name|BPF_OP
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
condition|)
block|{
case|case
name|BPF_JEQ
case|:
name|v
operator|=
name|v
operator|==
name|b
operator|->
name|s
operator|.
name|k
expr_stmt|;
break|break;
case|case
name|BPF_JGT
case|:
name|v
operator|=
operator|(
name|unsigned
operator|)
name|v
operator|>
operator|(
name|unsigned
operator|)
name|b
operator|->
name|s
operator|.
name|k
expr_stmt|;
break|break;
case|case
name|BPF_JGE
case|:
name|v
operator|=
operator|(
name|unsigned
operator|)
name|v
operator|>=
operator|(
name|unsigned
operator|)
name|b
operator|->
name|s
operator|.
name|k
expr_stmt|;
break|break;
case|case
name|BPF_JSET
case|:
name|v
operator|&=
name|b
operator|->
name|s
operator|.
name|k
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|JF
argument_list|(
name|b
argument_list|)
operator|!=
name|JT
argument_list|(
name|b
argument_list|)
condition|)
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|JF
argument_list|(
name|b
argument_list|)
operator|=
name|JT
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
name|JT
argument_list|(
name|b
argument_list|)
operator|=
name|JF
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the symbolic value of expression of 's', and update  * anything it defines in the value table 'val'.  If 'alter' is true,  * do various optimizations.  This code would be cleaner if symbolic  * evaluation and code transformations weren't folded together.  */
end_comment

begin_function
specifier|static
name|void
name|opt_stmt
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|stmt
modifier|*
name|s
parameter_list|,
name|int
name|val
index|[]
parameter_list|,
name|int
name|alter
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
name|int
name|v
decl_stmt|;
switch|switch
condition|(
name|s
operator|->
name|code
condition|)
block|{
case|case
name|BPF_LD
operator||
name|BPF_ABS
operator||
name|BPF_W
case|:
case|case
name|BPF_LD
operator||
name|BPF_ABS
operator||
name|BPF_H
case|:
case|case
name|BPF_LD
operator||
name|BPF_ABS
operator||
name|BPF_B
case|:
name|v
operator|=
name|F
argument_list|(
name|opt_state
argument_list|,
name|s
operator|->
name|code
argument_list|,
name|s
operator|->
name|k
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LD
operator||
name|BPF_IND
operator||
name|BPF_W
case|:
case|case
name|BPF_LD
operator||
name|BPF_IND
operator||
name|BPF_H
case|:
case|case
name|BPF_LD
operator||
name|BPF_IND
operator||
name|BPF_B
case|:
name|v
operator|=
name|val
index|[
name|X_ATOM
index|]
expr_stmt|;
if|if
condition|(
name|alter
operator|&&
name|opt_state
operator|->
name|vmap
index|[
name|v
index|]
operator|.
name|is_const
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_ABS
operator||
name|BPF_SIZE
argument_list|(
name|s
operator|->
name|code
argument_list|)
expr_stmt|;
name|s
operator|->
name|k
operator|+=
name|opt_state
operator|->
name|vmap
index|[
name|v
index|]
operator|.
name|const_val
expr_stmt|;
name|v
operator|=
name|F
argument_list|(
name|opt_state
argument_list|,
name|s
operator|->
name|code
argument_list|,
name|s
operator|->
name|k
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|v
operator|=
name|F
argument_list|(
name|opt_state
argument_list|,
name|s
operator|->
name|code
argument_list|,
name|s
operator|->
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LD
operator||
name|BPF_LEN
case|:
name|v
operator|=
name|F
argument_list|(
name|opt_state
argument_list|,
name|s
operator|->
name|code
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LD
operator||
name|BPF_IMM
case|:
name|v
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LDX
operator||
name|BPF_IMM
case|:
name|v
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LDX
operator||
name|BPF_MSH
operator||
name|BPF_B
case|:
name|v
operator|=
name|F
argument_list|(
name|opt_state
argument_list|,
name|s
operator|->
name|code
argument_list|,
name|s
operator|->
name|k
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_ALU
operator||
name|BPF_NEG
case|:
if|if
condition|(
name|alter
operator|&&
name|opt_state
operator|->
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|is_const
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|s
operator|->
name|k
operator|=
operator|-
name|opt_state
operator|->
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|const_val
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
block|}
else|else
name|val
index|[
name|A_ATOM
index|]
operator|=
name|F
argument_list|(
name|opt_state
argument_list|,
name|s
operator|->
name|code
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_ALU
operator||
name|BPF_ADD
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_SUB
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_MUL
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_DIV
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_MOD
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_AND
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_OR
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_XOR
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_LSH
operator||
name|BPF_K
case|:
case|case
name|BPF_ALU
operator||
name|BPF_RSH
operator||
name|BPF_K
case|:
name|op
operator|=
name|BPF_OP
argument_list|(
name|s
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|alter
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|k
operator|==
literal|0
condition|)
block|{
comment|/* don't optimize away "sub #0" 				 * as it may be needed later to 				 * fixup the generated math code */
if|if
condition|(
name|op
operator|==
name|BPF_ADD
operator|||
name|op
operator|==
name|BPF_LSH
operator|||
name|op
operator|==
name|BPF_RSH
operator|||
name|op
operator|==
name|BPF_OR
operator|||
name|op
operator|==
name|BPF_XOR
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op
operator|==
name|BPF_MUL
operator|||
name|op
operator|==
name|BPF_AND
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|opt_state
operator|->
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|is_const
condition|)
block|{
name|fold_op
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|,
name|opt_state
argument_list|,
name|s
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|val
index|[
name|A_ATOM
index|]
operator|=
name|F
argument_list|(
name|opt_state
argument_list|,
name|s
operator|->
name|code
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_ALU
operator||
name|BPF_ADD
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_SUB
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_MUL
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_DIV
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_MOD
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_AND
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_OR
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_XOR
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_LSH
operator||
name|BPF_X
case|:
case|case
name|BPF_ALU
operator||
name|BPF_RSH
operator||
name|BPF_X
case|:
name|op
operator|=
name|BPF_OP
argument_list|(
name|s
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|alter
operator|&&
name|opt_state
operator|->
name|vmap
index|[
name|val
index|[
name|X_ATOM
index|]
index|]
operator|.
name|is_const
condition|)
block|{
if|if
condition|(
name|opt_state
operator|->
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|is_const
condition|)
block|{
name|fold_op
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|,
name|opt_state
argument_list|,
name|s
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|)
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|code
operator|=
name|BPF_ALU
operator||
name|BPF_K
operator||
name|op
expr_stmt|;
name|s
operator|->
name|k
operator|=
name|opt_state
operator|->
name|vmap
index|[
name|val
index|[
name|X_ATOM
index|]
index|]
operator|.
name|const_val
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|val
index|[
name|A_ATOM
index|]
operator|=
name|F
argument_list|(
name|opt_state
argument_list|,
name|s
operator|->
name|code
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Check if we're doing something to an accumulator 		 * that is 0, and simplify.  This may not seem like 		 * much of a simplification but it could open up further 		 * optimizations. 		 * XXX We could also check for mul by 1, etc. 		 */
if|if
condition|(
name|alter
operator|&&
name|opt_state
operator|->
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|is_const
operator|&&
name|opt_state
operator|->
name|vmap
index|[
name|val
index|[
name|A_ATOM
index|]
index|]
operator|.
name|const_val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|BPF_ADD
operator|||
name|op
operator|==
name|BPF_OR
operator|||
name|op
operator|==
name|BPF_XOR
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_MISC
operator||
name|BPF_TXA
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|BPF_MUL
operator|||
name|op
operator|==
name|BPF_DIV
operator|||
name|op
operator|==
name|BPF_MOD
operator|||
name|op
operator|==
name|BPF_AND
operator|||
name|op
operator|==
name|BPF_LSH
operator|||
name|op
operator|==
name|BPF_RSH
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|s
operator|->
name|k
operator|=
literal|0
expr_stmt|;
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|K
argument_list|(
name|s
operator|->
name|k
argument_list|)
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|BPF_NEG
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
break|break;
block|}
block|}
name|val
index|[
name|A_ATOM
index|]
operator|=
name|F
argument_list|(
name|opt_state
argument_list|,
name|s
operator|->
name|code
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_MISC
operator||
name|BPF_TXA
case|:
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LD
operator||
name|BPF_MEM
case|:
name|v
operator|=
name|val
index|[
name|s
operator|->
name|k
index|]
expr_stmt|;
if|if
condition|(
name|alter
operator|&&
name|opt_state
operator|->
name|vmap
index|[
name|v
index|]
operator|.
name|is_const
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LD
operator||
name|BPF_IMM
expr_stmt|;
name|s
operator|->
name|k
operator|=
name|opt_state
operator|->
name|vmap
index|[
name|v
index|]
operator|.
name|const_val
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_MISC
operator||
name|BPF_TAX
case|:
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_LDX
operator||
name|BPF_MEM
case|:
name|v
operator|=
name|val
index|[
name|s
operator|->
name|k
index|]
expr_stmt|;
if|if
condition|(
name|alter
operator|&&
name|opt_state
operator|->
name|vmap
index|[
name|v
index|]
operator|.
name|is_const
condition|)
block|{
name|s
operator|->
name|code
operator|=
name|BPF_LDX
operator||
name|BPF_IMM
expr_stmt|;
name|s
operator|->
name|k
operator|=
name|opt_state
operator|->
name|vmap
index|[
name|v
index|]
operator|.
name|const_val
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|v
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_ST
case|:
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|s
operator|->
name|k
index|]
argument_list|,
name|val
index|[
name|A_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPF_STX
case|:
name|vstore
argument_list|(
name|s
argument_list|,
operator|&
name|val
index|[
name|s
operator|->
name|k
index|]
argument_list|,
name|val
index|[
name|X_ATOM
index|]
argument_list|,
name|alter
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|deadstmt
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
specifier|register
name|struct
name|stmt
modifier|*
name|s
parameter_list|,
specifier|register
name|struct
name|stmt
modifier|*
name|last
index|[]
parameter_list|)
block|{
specifier|register
name|int
name|atom
decl_stmt|;
name|atom
operator|=
name|atomuse
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|atom
operator|==
name|AX_ATOM
condition|)
block|{
name|last
index|[
name|X_ATOM
index|]
operator|=
literal|0
expr_stmt|;
name|last
index|[
name|A_ATOM
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|last
index|[
name|atom
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|atom
operator|=
name|atomdef
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|atom
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|last
index|[
name|atom
index|]
condition|)
block|{
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|last
index|[
name|atom
index|]
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
block|}
name|last
index|[
name|atom
index|]
operator|=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|opt_deadstores
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
specifier|register
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
specifier|register
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|atom
decl_stmt|;
name|struct
name|stmt
modifier|*
name|last
index|[
name|N_ATOMS
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|last
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|last
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|b
operator|->
name|stmts
init|;
name|s
operator|!=
literal|0
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|deadstmt
argument_list|(
name|opt_state
argument_list|,
operator|&
name|s
operator|->
name|s
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|deadstmt
argument_list|(
name|opt_state
argument_list|,
operator|&
name|b
operator|->
name|s
argument_list|,
name|last
argument_list|)
expr_stmt|;
for|for
control|(
name|atom
operator|=
literal|0
init|;
name|atom
operator|<
name|N_ATOMS
condition|;
operator|++
name|atom
control|)
if|if
condition|(
name|last
index|[
name|atom
index|]
operator|&&
operator|!
name|ATOMELEM
argument_list|(
name|b
operator|->
name|out_use
argument_list|,
name|atom
argument_list|)
condition|)
block|{
name|last
index|[
name|atom
index|]
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|opt_blk
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|block
modifier|*
name|b
parameter_list|,
name|int
name|do_stmts
parameter_list|)
block|{
name|struct
name|slist
modifier|*
name|s
decl_stmt|;
name|struct
name|edge
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bpf_int32
name|aval
decl_stmt|,
name|xval
decl_stmt|;
if|#
directive|if
literal|0
block|for (s = b->stmts; s&& s->next; s = s->next) 		if (BPF_CLASS(s->s.code) == BPF_JMP) { 			do_stmts = 0; 			break; 		}
endif|#
directive|endif
comment|/* 	 * Initialize the atom values. 	 */
name|p
operator|=
name|b
operator|->
name|in_edges
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We have no predecessors, so everything is undefined 		 * upon entry to this block. 		 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|val
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Inherit values from our predecessors. 		 * 		 * First, get the values from the predecessor along the 		 * first edge leading to this node. 		 */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|pred
operator|->
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Now look at all the other nodes leading to this node. 		 * If, for the predecessor along that edge, a register 		 * has a different value from the one we have (i.e., 		 * control paths are merging, and the merging paths 		 * assign different values to that register), give the 		 * register the undefined value of 0. 		 */
while|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_ATOMS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|b
operator|->
name|val
index|[
name|i
index|]
operator|!=
name|p
operator|->
name|pred
operator|->
name|val
index|[
name|i
index|]
condition|)
name|b
operator|->
name|val
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|aval
operator|=
name|b
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
name|xval
operator|=
name|b
operator|->
name|val
index|[
name|X_ATOM
index|]
expr_stmt|;
for|for
control|(
name|s
operator|=
name|b
operator|->
name|stmts
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|opt_stmt
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|,
name|opt_state
argument_list|,
operator|&
name|s
operator|->
name|s
argument_list|,
name|b
operator|->
name|val
argument_list|,
name|do_stmts
argument_list|)
expr_stmt|;
comment|/* 	 * This is a special case: if we don't use anything from this 	 * block, and we load the accumulator or index register with a 	 * value that is already there, or if this block is a return, 	 * eliminate all the statements. 	 * 	 * XXX - what if it does a store? 	 * 	 * XXX - why does it matter whether we use anything from this 	 * block?  If the accumulator or index register doesn't change 	 * its value, isn't that OK even if we use that value? 	 * 	 * XXX - if we load the accumulator with a different value, 	 * and the block ends with a conditional branch, we obviously 	 * can't eliminate it, as the branch depends on that value. 	 * For the index register, the conditional branch only depends 	 * on the index register value if the test is against the index 	 * register value rather than a constant; if nothing uses the 	 * value we put into the index register, and we're not testing 	 * against the index register's value, and there aren't any 	 * other problems that would keep us from eliminating this 	 * block, can we eliminate it? 	 */
if|if
condition|(
name|do_stmts
operator|&&
operator|(
operator|(
name|b
operator|->
name|out_use
operator|==
literal|0
operator|&&
name|aval
operator|!=
literal|0
operator|&&
name|b
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|==
name|aval
operator|&&
name|xval
operator|!=
literal|0
operator|&&
name|b
operator|->
name|val
index|[
name|X_ATOM
index|]
operator|==
name|xval
operator|)
operator|||
name|BPF_CLASS
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_RET
operator|)
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|stmts
operator|!=
literal|0
condition|)
block|{
name|b
operator|->
name|stmts
operator|=
literal|0
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|opt_peep
argument_list|(
name|opt_state
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|opt_deadstores
argument_list|(
name|opt_state
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up values for branch optimizer. 	 */
if|if
condition|(
name|BPF_SRC
argument_list|(
name|b
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_K
condition|)
name|b
operator|->
name|oval
operator|=
name|K
argument_list|(
name|b
operator|->
name|s
operator|.
name|k
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|oval
operator|=
name|b
operator|->
name|val
index|[
name|X_ATOM
index|]
expr_stmt|;
name|b
operator|->
name|et
operator|.
name|code
operator|=
name|b
operator|->
name|s
operator|.
name|code
expr_stmt|;
name|b
operator|->
name|ef
operator|.
name|code
operator|=
operator|-
name|b
operator|->
name|s
operator|.
name|code
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return true if any register that is used on exit from 'succ', has  * an exit value that is different from the corresponding exit value  * from 'b'.  */
end_comment

begin_function
specifier|static
name|int
name|use_conflict
parameter_list|(
name|struct
name|block
modifier|*
name|b
parameter_list|,
name|struct
name|block
modifier|*
name|succ
parameter_list|)
block|{
name|int
name|atom
decl_stmt|;
name|atomset
name|use
init|=
name|succ
operator|->
name|out_use
decl_stmt|;
if|if
condition|(
name|use
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|atom
operator|=
literal|0
init|;
name|atom
operator|<
name|N_ATOMS
condition|;
operator|++
name|atom
control|)
if|if
condition|(
name|ATOMELEM
argument_list|(
name|use
argument_list|,
name|atom
argument_list|)
condition|)
if|if
condition|(
name|b
operator|->
name|val
index|[
name|atom
index|]
operator|!=
name|succ
operator|->
name|val
index|[
name|atom
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|block
modifier|*
name|fold_edge
parameter_list|(
name|struct
name|block
modifier|*
name|child
parameter_list|,
name|struct
name|edge
modifier|*
name|ep
parameter_list|)
block|{
name|int
name|sense
decl_stmt|;
name|int
name|aval0
decl_stmt|,
name|aval1
decl_stmt|,
name|oval0
decl_stmt|,
name|oval1
decl_stmt|;
name|int
name|code
init|=
name|ep
operator|->
name|code
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
name|code
operator|=
operator|-
name|code
expr_stmt|;
name|sense
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sense
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|s
operator|.
name|code
operator|!=
name|code
condition|)
return|return
literal|0
return|;
name|aval0
operator|=
name|child
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
name|oval0
operator|=
name|child
operator|->
name|oval
expr_stmt|;
name|aval1
operator|=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
name|oval1
operator|=
name|ep
operator|->
name|pred
operator|->
name|oval
expr_stmt|;
if|if
condition|(
name|aval0
operator|!=
name|aval1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|oval0
operator|==
name|oval1
condition|)
comment|/* 		 * The operands of the branch instructions are 		 * identical, so the result is true if a true 		 * branch was taken to get here, otherwise false. 		 */
return|return
name|sense
condition|?
name|JT
argument_list|(
name|child
argument_list|)
else|:
name|JF
argument_list|(
name|child
argument_list|)
return|;
if|if
condition|(
name|sense
operator|&&
name|code
operator|==
operator|(
name|BPF_JMP
operator||
name|BPF_JEQ
operator||
name|BPF_K
operator|)
condition|)
comment|/* 		 * At this point, we only know the comparison if we 		 * came down the true branch, and it was an equality 		 * comparison with a constant. 		 * 		 * I.e., if we came down the true branch, and the branch 		 * was an equality comparison with a constant, we know the 		 * accumulator contains that constant.  If we came down 		 * the false branch, or the comparison wasn't with a 		 * constant, we don't know what was in the accumulator. 		 * 		 * We rely on the fact that distinct constants have distinct 		 * value numbers. 		 */
return|return
name|JF
argument_list|(
name|child
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_j
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|edge
modifier|*
name|ep
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|ep
operator|->
name|succ
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
name|ep
operator|->
name|succ
argument_list|)
operator|==
name|JF
argument_list|(
name|ep
operator|->
name|succ
argument_list|)
condition|)
block|{
comment|/* 		 * Common branch targets can be eliminated, provided 		 * there is no data dependency. 		 */
if|if
condition|(
operator|!
name|use_conflict
argument_list|(
name|ep
operator|->
name|pred
argument_list|,
name|ep
operator|->
name|succ
operator|->
name|et
operator|.
name|succ
argument_list|)
condition|)
block|{
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|succ
operator|=
name|JT
argument_list|(
name|ep
operator|->
name|succ
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For each edge dominator that matches the successor of this 	 * edge, promote the edge successor to the its grandchild. 	 * 	 * XXX We violate the set abstraction here in favor a reasonably 	 * efficient loop. 	 */
name|top
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opt_state
operator|->
name|edgewords
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|bpf_u_int32
name|x
init|=
name|ep
operator|->
name|edom
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|k
operator|=
name|ffs
argument_list|(
name|x
argument_list|)
operator|-
literal|1
expr_stmt|;
name|x
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|k
operator|)
expr_stmt|;
name|k
operator|+=
name|i
operator|*
name|BITS_PER_WORD
expr_stmt|;
name|target
operator|=
name|fold_edge
argument_list|(
name|ep
operator|->
name|succ
argument_list|,
name|opt_state
operator|->
name|edges
index|[
name|k
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * Check that there is no data dependency between 			 * nodes that will be violated if we move the edge. 			 */
if|if
condition|(
name|target
operator|!=
literal|0
operator|&&
operator|!
name|use_conflict
argument_list|(
name|ep
operator|->
name|pred
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|succ
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|target
argument_list|)
operator|!=
literal|0
condition|)
comment|/* 					 * Start over unless we hit a leaf. 					 */
goto|goto
name|top
goto|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|or_pullup
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
name|int
name|val
decl_stmt|,
name|at_top
decl_stmt|;
name|struct
name|block
modifier|*
name|pull
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|diffp
decl_stmt|,
modifier|*
modifier|*
name|samep
decl_stmt|;
name|struct
name|edge
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|b
operator|->
name|in_edges
expr_stmt|;
if|if
condition|(
name|ep
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Make sure each predecessor loads the same value. 	 * XXX why? 	 */
name|val
operator|=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|ep
operator|->
name|next
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
if|if
condition|(
name|val
operator|!=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
operator|==
name|b
condition|)
name|diffp
operator|=
operator|&
name|JT
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
expr_stmt|;
else|else
name|diffp
operator|=
operator|&
name|JF
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
expr_stmt|;
name|at_top
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|diffp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
operator|*
name|diffp
argument_list|)
operator|!=
name|JT
argument_list|(
name|b
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|SET_MEMBER
argument_list|(
operator|(
operator|*
name|diffp
operator|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|diffp
operator|)
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|!=
name|val
condition|)
break|break;
name|diffp
operator|=
operator|&
name|JF
argument_list|(
operator|*
name|diffp
argument_list|)
expr_stmt|;
name|at_top
operator|=
literal|0
expr_stmt|;
block|}
name|samep
operator|=
operator|&
name|JF
argument_list|(
operator|*
name|diffp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|samep
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
operator|*
name|samep
argument_list|)
operator|!=
name|JT
argument_list|(
name|b
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|SET_MEMBER
argument_list|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|==
name|val
condition|)
break|break;
comment|/* XXX Need to check that there are no data dependencies 		   between dp0 and dp1.  Currently, the code generator 		   will not produce such dependencies. */
name|samep
operator|=
operator|&
name|JF
argument_list|(
operator|*
name|samep
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* XXX This doesn't cover everything. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_ATOMS
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|val
index|[
name|i
index|]
operator|!=
name|pred
operator|->
name|val
index|[
name|i
index|]
condition|)
return|return;
endif|#
directive|endif
comment|/* Pull up the node. */
name|pull
operator|=
operator|*
name|samep
expr_stmt|;
operator|*
name|samep
operator|=
name|JF
argument_list|(
name|pull
argument_list|)
expr_stmt|;
name|JF
argument_list|(
name|pull
argument_list|)
operator|=
operator|*
name|diffp
expr_stmt|;
comment|/* 	 * At the top of the chain, each predecessor needs to point at the 	 * pulled up node.  Inside the chain, there is only one predecessor 	 * to worry about. 	 */
if|if
condition|(
name|at_top
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|b
operator|->
name|in_edges
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
block|{
if|if
condition|(
name|JT
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|==
name|b
condition|)
name|JT
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|=
name|pull
expr_stmt|;
else|else
name|JF
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|=
name|pull
expr_stmt|;
block|}
block|}
else|else
operator|*
name|diffp
operator|=
name|pull
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|and_pullup
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
name|int
name|val
decl_stmt|,
name|at_top
decl_stmt|;
name|struct
name|block
modifier|*
name|pull
decl_stmt|;
name|struct
name|block
modifier|*
modifier|*
name|diffp
decl_stmt|,
modifier|*
modifier|*
name|samep
decl_stmt|;
name|struct
name|edge
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|b
operator|->
name|in_edges
expr_stmt|;
if|if
condition|(
name|ep
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Make sure each predecessor loads the same value. 	 */
name|val
operator|=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|ep
operator|->
name|next
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
if|if
condition|(
name|val
operator|!=
name|ep
operator|->
name|pred
operator|->
name|val
index|[
name|A_ATOM
index|]
condition|)
return|return;
if|if
condition|(
name|JT
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
operator|==
name|b
condition|)
name|diffp
operator|=
operator|&
name|JT
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
expr_stmt|;
else|else
name|diffp
operator|=
operator|&
name|JF
argument_list|(
name|b
operator|->
name|in_edges
operator|->
name|pred
argument_list|)
expr_stmt|;
name|at_top
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|diffp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JF
argument_list|(
operator|*
name|diffp
argument_list|)
operator|!=
name|JF
argument_list|(
name|b
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|SET_MEMBER
argument_list|(
operator|(
operator|*
name|diffp
operator|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|diffp
operator|)
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|!=
name|val
condition|)
break|break;
name|diffp
operator|=
operator|&
name|JT
argument_list|(
operator|*
name|diffp
argument_list|)
expr_stmt|;
name|at_top
operator|=
literal|0
expr_stmt|;
block|}
name|samep
operator|=
operator|&
name|JT
argument_list|(
operator|*
name|diffp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|samep
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|JF
argument_list|(
operator|*
name|samep
argument_list|)
operator|!=
name|JF
argument_list|(
name|b
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|SET_MEMBER
argument_list|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|dom
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|val
index|[
name|A_ATOM
index|]
operator|==
name|val
condition|)
break|break;
comment|/* XXX Need to check that there are no data dependencies 		   between diffp and samep.  Currently, the code generator 		   will not produce such dependencies. */
name|samep
operator|=
operator|&
name|JT
argument_list|(
operator|*
name|samep
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* XXX This doesn't cover everything. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_ATOMS
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
operator|*
name|samep
operator|)
operator|->
name|val
index|[
name|i
index|]
operator|!=
name|pred
operator|->
name|val
index|[
name|i
index|]
condition|)
return|return;
endif|#
directive|endif
comment|/* Pull up the node. */
name|pull
operator|=
operator|*
name|samep
expr_stmt|;
operator|*
name|samep
operator|=
name|JT
argument_list|(
name|pull
argument_list|)
expr_stmt|;
name|JT
argument_list|(
name|pull
argument_list|)
operator|=
operator|*
name|diffp
expr_stmt|;
comment|/* 	 * At the top of the chain, each predecessor needs to point at the 	 * pulled up node.  Inside the chain, there is only one predecessor 	 * to worry about. 	 */
if|if
condition|(
name|at_top
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|b
operator|->
name|in_edges
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
block|{
if|if
condition|(
name|JT
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|==
name|b
condition|)
name|JT
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|=
name|pull
expr_stmt|;
else|else
name|JF
argument_list|(
name|ep
operator|->
name|pred
argument_list|)
operator|=
name|pull
expr_stmt|;
block|}
block|}
else|else
operator|*
name|diffp
operator|=
name|pull
expr_stmt|;
name|opt_state
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_blks
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|int
name|do_stmts
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|maxlevel
decl_stmt|;
name|struct
name|block
modifier|*
name|p
decl_stmt|;
name|init_val
argument_list|(
name|opt_state
argument_list|)
expr_stmt|;
name|maxlevel
operator|=
name|ic
operator|->
name|root
operator|->
name|level
expr_stmt|;
name|find_inedges
argument_list|(
name|opt_state
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|maxlevel
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
for|for
control|(
name|p
operator|=
name|opt_state
operator|->
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
name|opt_blk
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|,
name|opt_state
argument_list|,
name|p
argument_list|,
name|do_stmts
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_stmts
condition|)
comment|/* 		 * No point trying to move branches; it can't possibly 		 * make a difference at this point. 		 */
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxlevel
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|p
operator|=
name|opt_state
operator|->
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|opt_j
argument_list|(
name|opt_state
argument_list|,
operator|&
name|p
operator|->
name|et
argument_list|)
expr_stmt|;
name|opt_j
argument_list|(
name|opt_state
argument_list|,
operator|&
name|p
operator|->
name|ef
argument_list|)
expr_stmt|;
block|}
block|}
name|find_inedges
argument_list|(
name|opt_state
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxlevel
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|p
operator|=
name|opt_state
operator|->
name|levels
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|or_pullup
argument_list|(
name|opt_state
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|and_pullup
argument_list|(
name|opt_state
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|link_inedge
parameter_list|(
name|struct
name|edge
modifier|*
name|parent
parameter_list|,
name|struct
name|block
modifier|*
name|child
parameter_list|)
block|{
name|parent
operator|->
name|next
operator|=
name|child
operator|->
name|in_edges
expr_stmt|;
name|child
operator|->
name|in_edges
operator|=
name|parent
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_inedges
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|block
modifier|*
name|root
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opt_state
operator|->
name|n_blocks
condition|;
operator|++
name|i
control|)
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
operator|->
name|in_edges
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Traverse the graph, adding each edge to the predecessor 	 * list of its successors.  Skip the leaves (i.e. level 0). 	 */
for|for
control|(
name|i
operator|=
name|root
operator|->
name|level
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
for|for
control|(
name|b
operator|=
name|opt_state
operator|->
name|levels
index|[
name|i
index|]
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|link
control|)
block|{
name|link_inedge
argument_list|(
operator|&
name|b
operator|->
name|et
argument_list|,
name|JT
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|link_inedge
argument_list|(
operator|&
name|b
operator|->
name|ef
argument_list|,
name|JF
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|opt_root
parameter_list|(
name|struct
name|block
modifier|*
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|slist
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|BPF_CLASS
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_JMP
operator|&&
name|JT
argument_list|(
operator|*
name|b
argument_list|)
operator|==
name|JF
argument_list|(
operator|*
name|b
argument_list|)
condition|)
operator|*
name|b
operator|=
name|JT
argument_list|(
operator|*
name|b
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
name|sappend
argument_list|(
name|s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
operator|=
name|s
expr_stmt|;
comment|/* 	 * If the root node is a return, then there is no 	 * point executing any statements (since the bpf machine 	 * has no side effects). 	 */
if|if
condition|(
name|BPF_CLASS
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|->
name|s
operator|.
name|code
argument_list|)
operator|==
name|BPF_RET
condition|)
operator|(
operator|*
name|b
operator|)
operator|->
name|stmts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_loop
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|int
name|do_stmts
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BDEBUG
if|if
condition|(
name|pcap_optimizer_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"opt_loop(root, %d) begin\n"
argument_list|,
name|do_stmts
argument_list|)
expr_stmt|;
name|opt_dump
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
do|do
block|{
name|opt_state
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|find_levels
argument_list|(
name|opt_state
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|find_dom
argument_list|(
name|opt_state
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
name|find_closure
argument_list|(
name|opt_state
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
name|find_ud
argument_list|(
name|opt_state
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
name|find_edom
argument_list|(
name|opt_state
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
name|opt_blks
argument_list|(
name|cstate
argument_list|,
name|opt_state
argument_list|,
name|ic
argument_list|,
name|do_stmts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BDEBUG
if|if
condition|(
name|pcap_optimizer_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"opt_loop(root, %d) bottom, done=%d\n"
argument_list|,
name|do_stmts
argument_list|,
name|opt_state
operator|->
name|done
argument_list|)
expr_stmt|;
name|opt_dump
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
do|while
condition|(
operator|!
name|opt_state
operator|->
name|done
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Optimize the filter code in its dag representation.  */
end_comment

begin_function
name|void
name|bpf_optimize
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|)
block|{
name|opt_state_t
name|opt_state
decl_stmt|;
name|opt_init
argument_list|(
name|cstate
argument_list|,
operator|&
name|opt_state
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|opt_loop
argument_list|(
name|cstate
argument_list|,
operator|&
name|opt_state
argument_list|,
name|ic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opt_loop
argument_list|(
name|cstate
argument_list|,
operator|&
name|opt_state
argument_list|,
name|ic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intern_blocks
argument_list|(
operator|&
name|opt_state
argument_list|,
name|ic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BDEBUG
if|if
condition|(
name|pcap_optimizer_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"after intern_blocks()\n"
argument_list|)
expr_stmt|;
name|opt_dump
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|opt_root
argument_list|(
operator|&
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BDEBUG
if|if
condition|(
name|pcap_optimizer_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"after opt_root()\n"
argument_list|)
expr_stmt|;
name|opt_dump
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|opt_cleanup
argument_list|(
operator|&
name|opt_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_marks
parameter_list|(
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|struct
name|block
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isMarked
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|Mark
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|BPF_CLASS
argument_list|(
name|p
operator|->
name|s
operator|.
name|code
argument_list|)
operator|!=
name|BPF_RET
condition|)
block|{
name|make_marks
argument_list|(
name|ic
argument_list|,
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|make_marks
argument_list|(
name|ic
argument_list|,
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Mark code array such that isMarked(ic->cur_mark, i) is true  * only for nodes that are alive.  */
end_comment

begin_function
specifier|static
name|void
name|mark_code
parameter_list|(
name|struct
name|icode
modifier|*
name|ic
parameter_list|)
block|{
name|ic
operator|->
name|cur_mark
operator|+=
literal|1
expr_stmt|;
name|make_marks
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * True iff the two stmt lists load the same value from the packet into  * the accumulator.  */
end_comment

begin_function
specifier|static
name|int
name|eq_slist
parameter_list|(
name|struct
name|slist
modifier|*
name|x
parameter_list|,
name|struct
name|slist
modifier|*
name|y
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|x
operator|&&
name|x
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
name|x
operator|=
name|x
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|y
operator|&&
name|y
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
name|y
operator|=
name|y
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|y
operator|==
literal|0
return|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
return|return
name|x
operator|==
literal|0
return|;
if|if
condition|(
name|x
operator|->
name|s
operator|.
name|code
operator|!=
name|y
operator|->
name|s
operator|.
name|code
operator|||
name|x
operator|->
name|s
operator|.
name|k
operator|!=
name|y
operator|->
name|s
operator|.
name|k
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|x
operator|->
name|next
expr_stmt|;
name|y
operator|=
name|y
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|eq_blk
parameter_list|(
name|struct
name|block
modifier|*
name|b0
parameter_list|,
name|struct
name|block
modifier|*
name|b1
parameter_list|)
block|{
if|if
condition|(
name|b0
operator|->
name|s
operator|.
name|code
operator|==
name|b1
operator|->
name|s
operator|.
name|code
operator|&&
name|b0
operator|->
name|s
operator|.
name|k
operator|==
name|b1
operator|->
name|s
operator|.
name|k
operator|&&
name|b0
operator|->
name|et
operator|.
name|succ
operator|==
name|b1
operator|->
name|et
operator|.
name|succ
operator|&&
name|b0
operator|->
name|ef
operator|.
name|succ
operator|==
name|b1
operator|->
name|ef
operator|.
name|succ
condition|)
return|return
name|eq_slist
argument_list|(
name|b0
operator|->
name|stmts
argument_list|,
name|b1
operator|->
name|stmts
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intern_blocks
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|done1
decl_stmt|;
comment|/* don't shadow global */
name|top
label|:
name|done1
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opt_state
operator|->
name|n_blocks
condition|;
operator|++
name|i
control|)
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|mark_code
argument_list|(
name|ic
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|opt_state
operator|->
name|n_blocks
operator|-
literal|1
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|isMarked
argument_list|(
name|ic
argument_list|,
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|opt_state
operator|->
name|n_blocks
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|isMarked
argument_list|(
name|ic
argument_list|,
name|opt_state
operator|->
name|blocks
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|eq_blk
argument_list|(
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
argument_list|,
name|opt_state
operator|->
name|blocks
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
operator|->
name|link
operator|=
name|opt_state
operator|->
name|blocks
index|[
name|j
index|]
operator|->
name|link
condition|?
name|opt_state
operator|->
name|blocks
index|[
name|j
index|]
operator|->
name|link
else|:
name|opt_state
operator|->
name|blocks
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opt_state
operator|->
name|n_blocks
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|JT
argument_list|(
name|p
argument_list|)
operator|->
name|link
condition|)
block|{
name|done1
operator|=
literal|0
expr_stmt|;
name|JT
argument_list|(
name|p
argument_list|)
operator|=
name|JT
argument_list|(
name|p
argument_list|)
operator|->
name|link
expr_stmt|;
block|}
if|if
condition|(
name|JF
argument_list|(
name|p
argument_list|)
operator|->
name|link
condition|)
block|{
name|done1
operator|=
literal|0
expr_stmt|;
name|JF
argument_list|(
name|p
argument_list|)
operator|=
name|JF
argument_list|(
name|p
argument_list|)
operator|->
name|link
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|done1
condition|)
goto|goto
name|top
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_cleanup
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|opt_state
operator|->
name|vnode_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|opt_state
operator|->
name|vmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|opt_state
operator|->
name|edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|opt_state
operator|->
name|space
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|opt_state
operator|->
name|levels
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|opt_state
operator|->
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of stmts in 's'.  */
end_comment

begin_function
specifier|static
name|u_int
name|slength
parameter_list|(
name|struct
name|slist
modifier|*
name|s
parameter_list|)
block|{
name|u_int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|code
operator|!=
name|NOP
condition|)
operator|++
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of nodes reachable by 'p'.  * All nodes should be initially unmarked.  */
end_comment

begin_function
specifier|static
name|int
name|count_blocks
parameter_list|(
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|struct
name|block
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|isMarked
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|Mark
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|count_blocks
argument_list|(
name|ic
argument_list|,
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
operator|+
name|count_blocks
argument_list|(
name|ic
argument_list|,
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Do a depth first search on the flow graph, numbering the  * the basic blocks, and entering them into the 'blocks' array.`  */
end_comment

begin_function
specifier|static
name|void
name|number_blks_r
parameter_list|(
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|struct
name|block
modifier|*
name|p
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|isMarked
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
condition|)
return|return;
name|Mark
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|opt_state
operator|->
name|n_blocks
operator|++
expr_stmt|;
name|p
operator|->
name|id
operator|=
name|n
expr_stmt|;
name|opt_state
operator|->
name|blocks
index|[
name|n
index|]
operator|=
name|p
expr_stmt|;
name|number_blks_r
argument_list|(
name|opt_state
argument_list|,
name|ic
argument_list|,
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|number_blks_r
argument_list|(
name|opt_state
argument_list|,
name|ic
argument_list|,
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of stmts in the flowgraph reachable by 'p'.  * The nodes should be unmarked before calling.  *  * Note that "stmts" means "instructions", and that this includes  *  *	side-effect statements in 'p' (slength(p->stmts));  *  *	statements in the true branch from 'p' (count_stmts(JT(p)));  *  *	statements in the false branch from 'p' (count_stmts(JF(p)));  *  *	the conditional jump itself (1);  *  *	an extra long jump if the true branch requires it (p->longjt);  *  *	an extra long jump if the false branch requires it (p->longjf).  */
end_comment

begin_function
specifier|static
name|u_int
name|count_stmts
parameter_list|(
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|struct
name|block
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|isMarked
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|Mark
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|count_stmts
argument_list|(
name|ic
argument_list|,
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
operator|+
name|count_stmts
argument_list|(
name|ic
argument_list|,
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|slength
argument_list|(
name|p
operator|->
name|stmts
argument_list|)
operator|+
name|n
operator|+
literal|1
operator|+
name|p
operator|->
name|longjt
operator|+
name|p
operator|->
name|longjf
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate memory.  All allocation is done before optimization  * is begun.  A linear bound on the size of all data structures is computed  * from the total number of blocks and/or statements.  */
end_comment

begin_function
specifier|static
name|void
name|opt_init
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|)
block|{
name|bpf_u_int32
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|max_stmts
decl_stmt|;
comment|/* 	 * First, count the blocks, so we can malloc an array to map 	 * block number to block.  Then, put the blocks into the array. 	 */
name|unMarkAll
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|n
operator|=
name|count_blocks
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
name|opt_state
operator|->
name|blocks
operator|=
operator|(
expr|struct
name|block
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|blocks
operator|==
name|NULL
condition|)
name|bpf_error
argument_list|(
name|cstate
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|unMarkAll
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|opt_state
operator|->
name|n_blocks
operator|=
literal|0
expr_stmt|;
name|number_blks_r
argument_list|(
name|opt_state
argument_list|,
name|ic
argument_list|,
name|ic
operator|->
name|root
argument_list|)
expr_stmt|;
name|opt_state
operator|->
name|n_edges
operator|=
literal|2
operator|*
name|opt_state
operator|->
name|n_blocks
expr_stmt|;
name|opt_state
operator|->
name|edges
operator|=
operator|(
expr|struct
name|edge
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|opt_state
operator|->
name|n_edges
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|edges
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|edges
operator|==
name|NULL
condition|)
name|bpf_error
argument_list|(
name|cstate
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
comment|/* 	 * The number of levels is bounded by the number of nodes. 	 */
name|opt_state
operator|->
name|levels
operator|=
operator|(
expr|struct
name|block
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|opt_state
operator|->
name|n_blocks
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|levels
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|levels
operator|==
name|NULL
condition|)
name|bpf_error
argument_list|(
name|cstate
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|opt_state
operator|->
name|edgewords
operator|=
name|opt_state
operator|->
name|n_edges
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|bpf_u_int32
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|opt_state
operator|->
name|nodewords
operator|=
name|opt_state
operator|->
name|n_blocks
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|bpf_u_int32
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* XXX */
name|opt_state
operator|->
name|space
operator|=
operator|(
name|bpf_u_int32
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|opt_state
operator|->
name|n_blocks
operator|*
name|opt_state
operator|->
name|nodewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|space
argument_list|)
operator|+
name|opt_state
operator|->
name|n_edges
operator|*
name|opt_state
operator|->
name|edgewords
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|space
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|space
operator|==
name|NULL
condition|)
name|bpf_error
argument_list|(
name|cstate
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|p
operator|=
name|opt_state
operator|->
name|space
expr_stmt|;
name|opt_state
operator|->
name|all_dom_sets
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
operator|->
name|dom
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|opt_state
operator|->
name|nodewords
expr_stmt|;
block|}
name|opt_state
operator|->
name|all_closure_sets
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
operator|->
name|closure
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|opt_state
operator|->
name|nodewords
expr_stmt|;
block|}
name|opt_state
operator|->
name|all_edge_sets
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
init|=
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
decl_stmt|;
name|b
operator|->
name|et
operator|.
name|edom
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|opt_state
operator|->
name|edgewords
expr_stmt|;
name|b
operator|->
name|ef
operator|.
name|edom
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|opt_state
operator|->
name|edgewords
expr_stmt|;
name|b
operator|->
name|et
operator|.
name|id
operator|=
name|i
expr_stmt|;
name|opt_state
operator|->
name|edges
index|[
name|i
index|]
operator|=
operator|&
name|b
operator|->
name|et
expr_stmt|;
name|b
operator|->
name|ef
operator|.
name|id
operator|=
name|opt_state
operator|->
name|n_blocks
operator|+
name|i
expr_stmt|;
name|opt_state
operator|->
name|edges
index|[
name|opt_state
operator|->
name|n_blocks
operator|+
name|i
index|]
operator|=
operator|&
name|b
operator|->
name|ef
expr_stmt|;
name|b
operator|->
name|et
operator|.
name|pred
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|ef
operator|.
name|pred
operator|=
name|b
expr_stmt|;
block|}
name|max_stmts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|max_stmts
operator|+=
name|slength
argument_list|(
name|opt_state
operator|->
name|blocks
index|[
name|i
index|]
operator|->
name|stmts
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * We allocate at most 3 value numbers per statement, 	 * so this is an upper bound on the number of valnodes 	 * we'll need. 	 */
name|opt_state
operator|->
name|maxval
operator|=
literal|3
operator|*
name|max_stmts
expr_stmt|;
name|opt_state
operator|->
name|vmap
operator|=
operator|(
expr|struct
name|vmapinfo
operator|*
operator|)
name|calloc
argument_list|(
name|opt_state
operator|->
name|maxval
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|vmap
argument_list|)
argument_list|)
expr_stmt|;
name|opt_state
operator|->
name|vnode_base
operator|=
operator|(
expr|struct
name|valnode
operator|*
operator|)
name|calloc
argument_list|(
name|opt_state
operator|->
name|maxval
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|opt_state
operator|->
name|vnode_base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|vmap
operator|==
name|NULL
operator|||
name|opt_state
operator|->
name|vnode_base
operator|==
name|NULL
condition|)
name|bpf_error
argument_list|(
name|cstate
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is only used when supporting optimizer debugging.  It is  * global state, so do *not* do more than one compile in parallel  * and expect it to provide meaningful information.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_decl_stmt
name|int
name|bids
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Returns true if successful.  Returns false if a branch has  * an offset that is too large.  If so, we have marked that  * branch so that on a subsequent iteration, it will be treated  * properly.  */
end_comment

begin_function
specifier|static
name|int
name|convert_code_r
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|conv_state_t
modifier|*
name|conv_state
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|struct
name|block
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|bpf_insn
modifier|*
name|dst
decl_stmt|;
name|struct
name|slist
modifier|*
name|src
decl_stmt|;
name|u_int
name|slen
decl_stmt|;
name|u_int
name|off
decl_stmt|;
name|int
name|extrajmps
decl_stmt|;
comment|/* number of extra jumps inserted */
name|struct
name|slist
modifier|*
modifier|*
name|offset
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|isMarked
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|Mark
argument_list|(
name|ic
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_code_r
argument_list|(
name|cstate
argument_list|,
name|conv_state
argument_list|,
name|ic
argument_list|,
name|JF
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|convert_code_r
argument_list|(
name|cstate
argument_list|,
name|conv_state
argument_list|,
name|ic
argument_list|,
name|JT
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|slen
operator|=
name|slength
argument_list|(
name|p
operator|->
name|stmts
argument_list|)
expr_stmt|;
name|dst
operator|=
name|conv_state
operator|->
name|ftail
operator|-=
operator|(
name|slen
operator|+
literal|1
operator|+
name|p
operator|->
name|longjt
operator|+
name|p
operator|->
name|longjf
operator|)
expr_stmt|;
comment|/* inflate length by any extra jumps */
name|p
operator|->
name|offset
operator|=
call|(
name|int
call|)
argument_list|(
name|dst
operator|-
name|conv_state
operator|->
name|fstart
argument_list|)
expr_stmt|;
comment|/* generate offset[] for convenience  */
if|if
condition|(
name|slen
condition|)
block|{
name|offset
operator|=
operator|(
expr|struct
name|slist
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|slen
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|slist
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
block|{
name|bpf_error
argument_list|(
name|cstate
argument_list|,
literal|"not enough core"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
name|src
operator|=
name|p
operator|->
name|stmts
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|slen
operator|&&
name|src
condition|;
name|off
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|printf("off=%d src=%x\n", off, src);
endif|#
directive|endif
name|offset
index|[
name|off
index|]
operator|=
name|src
expr_stmt|;
name|src
operator|=
name|src
operator|->
name|next
expr_stmt|;
block|}
name|off
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|src
operator|=
name|p
operator|->
name|stmts
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
block|{
if|if
condition|(
name|src
operator|->
name|s
operator|.
name|code
operator|==
name|NOP
condition|)
continue|continue;
name|dst
operator|->
name|code
operator|=
operator|(
name|u_short
operator|)
name|src
operator|->
name|s
operator|.
name|code
expr_stmt|;
name|dst
operator|->
name|k
operator|=
name|src
operator|->
name|s
operator|.
name|k
expr_stmt|;
comment|/* fill block-local relative jump */
if|if
condition|(
name|BPF_CLASS
argument_list|(
name|src
operator|->
name|s
operator|.
name|code
argument_list|)
operator|!=
name|BPF_JMP
operator|||
name|src
operator|->
name|s
operator|.
name|code
operator|==
operator|(
name|BPF_JMP
operator||
name|BPF_JA
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (src->s.jt || src->s.jf) { 				bpf_error(cstate, "illegal jmp destination");
comment|/*NOTREACHED*/
block|}
endif|#
directive|endif
goto|goto
name|filled
goto|;
block|}
if|if
condition|(
name|off
operator|==
name|slen
operator|-
literal|2
condition|)
comment|/*???*/
goto|goto
name|filled
goto|;
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|jt
decl_stmt|,
name|jf
decl_stmt|;
specifier|const
name|char
modifier|*
name|ljerr
init|=
literal|"%s for block-local relative jump: off=%d"
decl_stmt|;
if|#
directive|if
literal|0
block|printf("code=%x off=%d %x %x\n", src->s.code, 			off, src->s.jt, src->s.jf);
endif|#
directive|endif
if|if
condition|(
operator|!
name|src
operator|->
name|s
operator|.
name|jt
operator|||
operator|!
name|src
operator|->
name|s
operator|.
name|jf
condition|)
block|{
name|bpf_error
argument_list|(
name|cstate
argument_list|,
name|ljerr
argument_list|,
literal|"no jmp destination"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|jt
operator|=
name|jf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
index|[
name|i
index|]
operator|==
name|src
operator|->
name|s
operator|.
name|jt
condition|)
block|{
if|if
condition|(
name|jt
condition|)
block|{
name|bpf_error
argument_list|(
name|cstate
argument_list|,
name|ljerr
argument_list|,
literal|"multiple matches"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|dst
operator|->
name|jt
operator|=
name|i
operator|-
name|off
operator|-
literal|1
expr_stmt|;
name|jt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|offset
index|[
name|i
index|]
operator|==
name|src
operator|->
name|s
operator|.
name|jf
condition|)
block|{
if|if
condition|(
name|jf
condition|)
block|{
name|bpf_error
argument_list|(
name|cstate
argument_list|,
name|ljerr
argument_list|,
literal|"multiple matches"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|dst
operator|->
name|jf
operator|=
name|i
operator|-
name|off
operator|-
literal|1
expr_stmt|;
name|jf
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|jt
operator|||
operator|!
name|jf
condition|)
block|{
name|bpf_error
argument_list|(
name|cstate
argument_list|,
name|ljerr
argument_list|,
literal|"no destination found"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
name|filled
label|:
operator|++
name|dst
expr_stmt|;
operator|++
name|off
expr_stmt|;
block|}
if|if
condition|(
name|offset
condition|)
name|free
argument_list|(
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BDEBUG
name|bids
index|[
name|dst
operator|-
name|conv_state
operator|->
name|fstart
index|]
operator|=
name|p
operator|->
name|id
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
name|dst
operator|->
name|code
operator|=
operator|(
name|u_short
operator|)
name|p
operator|->
name|s
operator|.
name|code
expr_stmt|;
name|dst
operator|->
name|k
operator|=
name|p
operator|->
name|s
operator|.
name|k
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|extrajmps
operator|=
literal|0
expr_stmt|;
name|off
operator|=
name|JT
argument_list|(
name|p
argument_list|)
operator|->
name|offset
operator|-
operator|(
name|p
operator|->
name|offset
operator|+
name|slen
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|off
operator|>=
literal|256
condition|)
block|{
comment|/* offset too large for branch, must add a jump */
if|if
condition|(
name|p
operator|->
name|longjt
operator|==
literal|0
condition|)
block|{
comment|/* mark this instruction and retry */
name|p
operator|->
name|longjt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* branch if T to following jump */
name|dst
operator|->
name|jt
operator|=
name|extrajmps
expr_stmt|;
name|extrajmps
operator|++
expr_stmt|;
name|dst
index|[
name|extrajmps
index|]
operator|.
name|code
operator|=
name|BPF_JMP
operator||
name|BPF_JA
expr_stmt|;
name|dst
index|[
name|extrajmps
index|]
operator|.
name|k
operator|=
name|off
operator|-
name|extrajmps
expr_stmt|;
block|}
else|else
name|dst
operator|->
name|jt
operator|=
name|off
expr_stmt|;
name|off
operator|=
name|JF
argument_list|(
name|p
argument_list|)
operator|->
name|offset
operator|-
operator|(
name|p
operator|->
name|offset
operator|+
name|slen
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|off
operator|>=
literal|256
condition|)
block|{
comment|/* offset too large for branch, must add a jump */
if|if
condition|(
name|p
operator|->
name|longjf
operator|==
literal|0
condition|)
block|{
comment|/* mark this instruction and retry */
name|p
operator|->
name|longjf
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* branch if F to following jump */
comment|/* if two jumps are inserted, F goes to second one */
name|dst
operator|->
name|jf
operator|=
name|extrajmps
expr_stmt|;
name|extrajmps
operator|++
expr_stmt|;
name|dst
index|[
name|extrajmps
index|]
operator|.
name|code
operator|=
name|BPF_JMP
operator||
name|BPF_JA
expr_stmt|;
name|dst
index|[
name|extrajmps
index|]
operator|.
name|k
operator|=
name|off
operator|-
name|extrajmps
expr_stmt|;
block|}
else|else
name|dst
operator|->
name|jf
operator|=
name|off
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert flowgraph intermediate representation to the  * BPF array representation.  Set *lenp to the number of instructions.  *  * This routine does *NOT* leak the memory pointed to by fp.  It *must  * not* do free(fp) before returning fp; doing so would make no sense,  * as the BPF array pointed to by the return value of icode_to_fcode()  * must be valid - it's being returned for use in a bpf_program structure.  *  * If it appears that icode_to_fcode() is leaking, the problem is that  * the program using pcap_compile() is failing to free the memory in  * the BPF program when it's done - the leak is in the program, not in  * the routine that happens to be allocating the memory.  (By analogy, if  * a program calls fopen() without ever calling fclose() on the FILE *,  * it will leak the FILE structure; the leak is not in fopen(), it's in  * the program.)  Change the program to use pcap_freecode() when it's  * done with the filter program.  See the pcap man page.  */
end_comment

begin_function
name|struct
name|bpf_insn
modifier|*
name|icode_to_fcode
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|struct
name|block
modifier|*
name|root
parameter_list|,
name|u_int
modifier|*
name|lenp
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|fp
decl_stmt|;
name|conv_state_t
name|conv_state
decl_stmt|;
comment|/* 	 * Loop doing convert_code_r() until no branches remain 	 * with too-large offsets. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|unMarkAll
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|lenp
operator|=
name|count_stmts
argument_list|(
name|ic
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|bpf_error
argument_list|(
name|cstate
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|conv_state
operator|.
name|fstart
operator|=
name|fp
expr_stmt|;
name|conv_state
operator|.
name|ftail
operator|=
name|fp
operator|+
name|n
expr_stmt|;
name|unMarkAll
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_code_r
argument_list|(
name|cstate
argument_list|,
operator|&
name|conv_state
argument_list|,
name|ic
argument_list|,
name|root
argument_list|)
condition|)
break|break;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * Make a copy of a BPF program and put it in the "fcode" member of  * a "pcap_t".  *  * If we fail to allocate memory for the copy, fill in the "errbuf"  * member of the "pcap_t" with an error message, and return -1;  * otherwise, return 0.  */
end_comment

begin_function
name|int
name|install_bpf_program
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
name|size_t
name|prog_size
decl_stmt|;
comment|/* 	 * Validate the program. 	 */
if|if
condition|(
operator|!
name|bpf_validate
argument_list|(
name|fp
operator|->
name|bf_insns
argument_list|,
name|fp
operator|->
name|bf_len
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"BPF program is not valid"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Free up any already installed program. 	 */
name|pcap_freecode
argument_list|(
operator|&
name|p
operator|->
name|fcode
argument_list|)
expr_stmt|;
name|prog_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|fp
operator|->
name|bf_insns
argument_list|)
operator|*
name|fp
operator|->
name|bf_len
expr_stmt|;
name|p
operator|->
name|fcode
operator|.
name|bf_len
operator|=
name|fp
operator|->
name|bf_len
expr_stmt|;
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
name|malloc
argument_list|(
name|prog_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|fp
operator|->
name|bf_insns
argument_list|,
name|prog_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_function
specifier|static
name|void
name|dot_dump_node
parameter_list|(
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|prog
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|int
name|icount
decl_stmt|,
name|noffset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
operator|||
name|isMarked
argument_list|(
name|ic
argument_list|,
name|block
argument_list|)
condition|)
return|return;
name|Mark
argument_list|(
name|ic
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|icount
operator|=
name|slength
argument_list|(
name|block
operator|->
name|stmts
argument_list|)
operator|+
literal|1
operator|+
name|block
operator|->
name|longjt
operator|+
name|block
operator|->
name|longjf
expr_stmt|;
name|noffset
operator|=
name|min
argument_list|(
name|block
operator|->
name|offset
operator|+
name|icount
argument_list|,
operator|(
name|int
operator|)
name|prog
operator|->
name|bf_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tblock%d [shape=ellipse, id=\"block-%d\" label=\"BLOCK%d\\n"
argument_list|,
name|block
operator|->
name|id
argument_list|,
name|block
operator|->
name|id
argument_list|,
name|block
operator|->
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|block
operator|->
name|offset
init|;
name|i
operator|<
name|noffset
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\\n%s"
argument_list|,
name|bpf_image
argument_list|(
name|prog
operator|->
name|bf_insns
operator|+
name|i
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\" tooltip=\""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BPF_MEMWORDS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|block
operator|->
name|val
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"val[%d]=%d "
argument_list|,
name|i
argument_list|,
name|block
operator|->
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"val[A]=%d "
argument_list|,
name|block
operator|->
name|val
index|[
name|A_ATOM
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"val[X]=%d"
argument_list|,
name|block
operator|->
name|val
index|[
name|X_ATOM
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|block
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|", peripheries=2"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"];\n"
argument_list|)
expr_stmt|;
name|dot_dump_node
argument_list|(
name|ic
argument_list|,
name|JT
argument_list|(
name|block
argument_list|)
argument_list|,
name|prog
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|dot_dump_node
argument_list|(
name|ic
argument_list|,
name|JF
argument_list|(
name|block
argument_list|)
argument_list|,
name|prog
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dot_dump_edge
parameter_list|(
name|struct
name|icode
modifier|*
name|ic
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
if|if
condition|(
name|block
operator|==
name|NULL
operator|||
name|isMarked
argument_list|(
name|ic
argument_list|,
name|block
argument_list|)
condition|)
return|return;
name|Mark
argument_list|(
name|ic
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|JT
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\t\"block%d\":se -> \"block%d\":n [label=\"T\"]; \n"
argument_list|,
name|block
operator|->
name|id
argument_list|,
name|JT
argument_list|(
name|block
argument_list|)
operator|->
name|id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\t\"block%d\":sw -> \"block%d\":n [label=\"F\"]; \n"
argument_list|,
name|block
operator|->
name|id
argument_list|,
name|JF
argument_list|(
name|block
argument_list|)
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|dot_dump_edge
argument_list|(
name|ic
argument_list|,
name|JT
argument_list|(
name|block
argument_list|)
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|dot_dump_edge
argument_list|(
name|ic
argument_list|,
name|JF
argument_list|(
name|block
argument_list|)
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the block CFG using graphviz/DOT language  * In the CFG, block's code, value index for each registers at EXIT,  * and the jump relationship is show.  *  * example DOT for BPF `ip src host 1.1.1.1' is:     digraph BPF {     	block0 [shape=ellipse, id="block-0" label="BLOCK0\n\n(000) ldh      [12]\n(001) jeq      #0x800           jt 2	jf 5" tooltip="val[A]=0 val[X]=0"];     	block1 [shape=ellipse, id="block-1" label="BLOCK1\n\n(002) ld       [26]\n(003) jeq      #0x1010101       jt 4	jf 5" tooltip="val[A]=0 val[X]=0"];     	block2 [shape=ellipse, id="block-2" label="BLOCK2\n\n(004) ret      #68" tooltip="val[A]=0 val[X]=0", peripheries=2];     	block3 [shape=ellipse, id="block-3" label="BLOCK3\n\n(005) ret      #0" tooltip="val[A]=0 val[X]=0", peripheries=2];     	"block0":se -> "block1":n [label="T"];     	"block0":sw -> "block3":n [label="F"];     	"block1":se -> "block2":n [label="T"];     	"block1":sw -> "block3":n [label="F"];     }  *  *  After install graphviz on http://www.graphviz.org/, save it as bpf.dot  *  and run `dot -Tpng -O bpf.dot' to draw the graph.  */
end_comment

begin_function
specifier|static
name|void
name|dot_dump
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|bpf_program
name|f
decl_stmt|;
name|FILE
modifier|*
name|out
init|=
name|stdout
decl_stmt|;
name|memset
argument_list|(
name|bids
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|bids
argument_list|)
expr_stmt|;
name|f
operator|.
name|bf_insns
operator|=
name|icode_to_fcode
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|,
name|ic
operator|->
name|root
argument_list|,
operator|&
name|f
operator|.
name|bf_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"digraph BPF {\n"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|cur_mark
operator|=
literal|0
expr_stmt|;
name|unMarkAll
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|dot_dump_node
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|root
argument_list|,
operator|&
name|f
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|ic
operator|->
name|cur_mark
operator|=
literal|0
expr_stmt|;
name|unMarkAll
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|dot_dump_edge
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|root
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|.
name|bf_insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|plain_dump
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|bpf_program
name|f
decl_stmt|;
name|memset
argument_list|(
name|bids
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|bids
argument_list|)
expr_stmt|;
name|f
operator|.
name|bf_insns
operator|=
name|icode_to_fcode
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|,
name|ic
operator|->
name|root
argument_list|,
operator|&
name|f
operator|.
name|bf_len
argument_list|)
expr_stmt|;
name|bpf_dump
argument_list|(
operator|&
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|.
name|bf_insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opt_dump
parameter_list|(
name|compiler_state_t
modifier|*
name|cstate
parameter_list|,
name|struct
name|icode
modifier|*
name|ic
parameter_list|)
block|{
comment|/* if optimizer debugging is enabled, output DOT graph 	 * `pcap_optimizer_debug=4' is equivalent to -dddd to follow -d/-dd/-ddd 	 * convention in tcpdump command line 	 */
if|if
condition|(
name|pcap_optimizer_debug
operator|>
literal|3
condition|)
name|dot_dump
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|)
expr_stmt|;
else|else
name|plain_dump
argument_list|(
name|cstate
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

