begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 - 2005 NetGroup, Politecnico di Torino (Italy)  * Copyright (c) 2005 - 2008 CACE Technologies, Davis (California)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  * notice, this list of conditions and the following disclaimer in the  * documentation and/or other materials provided with the distribution.  * 3. Neither the name of the Politecnico di Torino, CACE Technologies  * nor the names of its contributors may be used to endorse or promote  * products derived from this software without specific prior written  * permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_comment
comment|// for the details of the pcap_t structure
end_comment

begin_include
include|#
directive|include
file|"pcap-rpcap.h"
end_include

begin_include
include|#
directive|include
file|"sockutils.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|// for the errno variable
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|// for malloc(), free(), ...
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|// for strstr, etc
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_comment
comment|// for readdir
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Keeps a list of all the opened connections in the active mode. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|activehosts
modifier|*
name|activeHosts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * \brief Keeps the main socket identifier when we want to accept a new remote connection (active mode only).  * See the documentation of pcap_remoteact_accept() and pcap_remoteact_cleanup() for more details.  */
end_comment

begin_decl_stmt
name|SOCKET
name|sockmain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String identifier to be used in the pcap_findalldevs_ex() */
end_comment

begin_define
define|#
directive|define
name|PCAP_TEXT_SOURCE_FILE
value|"File"
end_define

begin_comment
comment|/* String identifier to be used in the pcap_findalldevs_ex() */
end_comment

begin_define
define|#
directive|define
name|PCAP_TEXT_SOURCE_ADAPTER
value|"Network adapter"
end_define

begin_comment
comment|/* String identifier to be used in the pcap_findalldevs_ex() */
end_comment

begin_define
define|#
directive|define
name|PCAP_TEXT_SOURCE_ON_LOCAL_HOST
value|"on local host"
end_define

begin_comment
comment|/* String identifier to be used in the pcap_findalldevs_ex() */
end_comment

begin_define
define|#
directive|define
name|PCAP_TEXT_SOURCE_ON_REMOTE_HOST
value|"on remote node"
end_define

begin_comment
comment|/* * Private data for capturing on WinPcap devices. */
end_comment

begin_struct
struct|struct
name|pcap_win
block|{
name|int
name|nonblock
decl_stmt|;
name|int
name|rfmon_selfstart
decl_stmt|;
comment|/* a flag tells whether the monitor mode is set by itself */
name|int
name|filtering_in_kernel
decl_stmt|;
comment|/* using kernel filter */
ifdef|#
directive|ifdef
name|HAVE_DAG_API
name|int
name|dag_fcs_bits
decl_stmt|;
comment|/* Number of checksum bits from link layer */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/****************************************************  *                                                  *  * Function bodies                                  *  *                                                  *  ****************************************************/
end_comment

begin_function
name|int
name|pcap_findalldevs_ex
parameter_list|(
name|char
modifier|*
name|source
parameter_list|,
name|struct
name|pcap_rmtauth
modifier|*
name|auth
parameter_list|,
name|pcap_if_t
modifier|*
modifier|*
name|alldevs
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|SOCKET
name|sockctrl
decl_stmt|;
comment|/* socket descriptor of the control connection */
name|uint32
name|totread
init|=
literal|0
decl_stmt|;
comment|/* number of bytes of the payload read from the socket */
name|int
name|nread
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
comment|/* temp variable needed to resolve hostnames into to socket representation */
name|struct
name|addrinfo
modifier|*
name|addrinfo
decl_stmt|;
comment|/* temp variable needed to resolve hostnames into to socket representation */
name|struct
name|rpcap_header
name|header
decl_stmt|;
comment|/* structure that keeps the general header of the rpcap protocol */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* temp variables */
name|int
name|naddr
decl_stmt|;
comment|/* temp var needed to avoid problems with IPv6 addresses */
name|struct
name|pcap_addr
modifier|*
name|addr
decl_stmt|;
comment|/* another such temp */
name|int
name|retval
decl_stmt|;
comment|/* store the return value of the functions */
name|int
name|nif
decl_stmt|;
comment|/* Number of interfaces listed */
name|int
name|active
init|=
literal|0
decl_stmt|;
comment|/* 'true' if we the other end-party is in active mode */
name|char
name|host
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|,
name|port
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|,
name|name
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|,
name|path
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|,
name|filename
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|;
name|int
name|type
decl_stmt|;
name|pcap_t
modifier|*
name|fp
decl_stmt|;
name|char
name|tmpstring
index|[
name|PCAP_BUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Needed to convert names and descriptions from 'old' syntax to the 'new' one */
name|pcap_if_t
modifier|*
name|dev
decl_stmt|;
comment|/* Previous device into the pcap_if_t chain */
if|if
condition|(
name|strlen
argument_list|(
name|source
argument_list|)
operator|>
name|PCAP_BUF_SIZE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The source string is too long. Cannot handle it correctly."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Determine the type of the source (file, local, remote) 	 * There are some differences if pcap_findalldevs_ex() is called to list files and remote adapters. 	 * In the first case, the name of the directory we have to look into must be present (therefore 	 * the 'name' parameter of the pcap_parsesrcstr() is present). 	 * In the second case, the name of the adapter is not required (we need just the host). So, we have 	 * to use a first time this function to get the source type, and a second time to get the appropriate 	 * info, which depends on the source type. 	 */
if|if
condition|(
name|pcap_parsesrcstr
argument_list|(
name|source
argument_list|,
operator|&
name|type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|type
operator|==
name|PCAP_SRC_IFLOCAL
condition|)
block|{
if|if
condition|(
name|pcap_parsesrcstr
argument_list|(
name|source
argument_list|,
operator|&
name|type
argument_list|,
name|host
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Initialize temporary string */
name|tmpstring
index|[
name|PCAP_BUF_SIZE
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The user wants to retrieve adapters from a local host */
if|if
condition|(
name|pcap_findalldevs
argument_list|(
name|alldevs
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|alldevs
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|alldevs
operator|==
name|NULL
operator|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"No interfaces found! Make sure libpcap/WinPcap is properly installed"
literal|" on the local machine."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Scan all the interfaces and modify name and description */
comment|/* This is a trick in order to avoid the re-implementation of the pcap_findalldevs here */
name|dev
operator|=
operator|*
name|alldevs
expr_stmt|;
while|while
condition|(
name|dev
condition|)
block|{
comment|/* Create the new device identifier */
if|if
condition|(
name|pcap_createsrcstr
argument_list|(
name|tmpstring
argument_list|,
name|PCAP_SRC_IFLOCAL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Delete the old pointer */
name|free
argument_list|(
name|dev
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Make a copy of the new device identifier */
name|dev
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|tmpstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Create the new device description */
if|if
condition|(
operator|(
name|dev
operator|->
name|description
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dev
operator|->
name|description
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
name|pcap_snprintf
argument_list|(
name|tmpstring
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstring
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s '%s' %s"
argument_list|,
name|PCAP_TEXT_SOURCE_ADAPTER
argument_list|,
name|dev
operator|->
name|name
argument_list|,
name|PCAP_TEXT_SOURCE_ON_LOCAL_HOST
argument_list|)
expr_stmt|;
else|else
name|pcap_snprintf
argument_list|(
name|tmpstring
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstring
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s '%s' %s"
argument_list|,
name|PCAP_TEXT_SOURCE_ADAPTER
argument_list|,
name|dev
operator|->
name|description
argument_list|,
name|PCAP_TEXT_SOURCE_ON_LOCAL_HOST
argument_list|)
expr_stmt|;
comment|/* Delete the old pointer */
name|free
argument_list|(
name|dev
operator|->
name|description
argument_list|)
expr_stmt|;
comment|/* Make a copy of the description */
name|dev
operator|->
name|description
operator|=
name|strdup
argument_list|(
name|tmpstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|description
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dev
operator|=
name|dev
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|alldevs
operator|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PCAP_SRC_FILE
condition|)
block|{
name|size_t
name|stringlen
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|WIN32_FIND_DATA
name|filedata
decl_stmt|;
name|HANDLE
name|filehandle
decl_stmt|;
else|#
directive|else
name|struct
name|dirent
modifier|*
name|filedata
decl_stmt|;
name|DIR
modifier|*
name|unixdir
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pcap_parsesrcstr
argument_list|(
name|source
argument_list|,
operator|&
name|type
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|name
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check that the filename is correct */
name|stringlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* The directory must end with '\' in Win32 and '/' in UNIX */
ifdef|#
directive|ifdef
name|WIN32
define|#
directive|define
name|ENDING_CHAR
value|'\\'
else|#
directive|else
define|#
directive|define
name|ENDING_CHAR
value|'/'
endif|#
directive|endif
if|if
condition|(
name|name
index|[
name|stringlen
operator|-
literal|1
index|]
operator|!=
name|ENDING_CHAR
condition|)
block|{
name|name
index|[
name|stringlen
index|]
operator|=
name|ENDING_CHAR
expr_stmt|;
name|name
index|[
name|stringlen
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stringlen
operator|++
expr_stmt|;
block|}
comment|/* Save the path for future reference */
name|pcap_snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
comment|/* To perform directory listing, Win32 must have an 'asterisk' as ending char */
if|if
condition|(
name|name
index|[
name|stringlen
operator|-
literal|1
index|]
operator|!=
literal|'*'
condition|)
block|{
name|name
index|[
name|stringlen
index|]
operator|=
literal|'*'
expr_stmt|;
name|name
index|[
name|stringlen
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|filehandle
operator|=
name|FindFirstFile
argument_list|(
name|name
argument_list|,
operator|&
name|filedata
argument_list|)
expr_stmt|;
if|if
condition|(
name|filehandle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error when listing files: does folder '%s' exist?"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
comment|/* opening the folder */
name|unixdir
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* get the first file into it */
name|filedata
operator|=
name|readdir
argument_list|(
name|unixdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|filedata
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Error when listing files: does folder '%s' exist?"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
do|do
block|{
ifdef|#
directive|ifdef
name|WIN32
name|pcap_snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|path
argument_list|,
name|filedata
operator|.
name|cFileName
argument_list|)
expr_stmt|;
else|#
directive|else
name|pcap_snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|path
argument_list|,
name|filedata
operator|->
name|d_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|pcap_open_offline
argument_list|(
name|filename
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
comment|/* allocate the main structure */
if|if
condition|(
operator|*
name|alldevs
operator|==
name|NULL
condition|)
comment|/* This is in case it is the first file */
block|{
operator|(
operator|*
name|alldevs
operator|)
operator|=
operator|(
name|pcap_if_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_if_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
operator|(
operator|*
name|alldevs
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|next
operator|=
operator|(
name|pcap_if_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_if_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|dev
operator|->
name|next
expr_stmt|;
block|}
comment|/* check that the malloc() didn't fail */
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Initialize the structure to 'zero' */
name|memset
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap_if_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new source identifier */
if|if
condition|(
name|pcap_createsrcstr
argument_list|(
name|tmpstring
argument_list|,
name|PCAP_SRC_FILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|filename
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|stringlen
operator|=
name|strlen
argument_list|(
name|tmpstring
argument_list|)
expr_stmt|;
name|dev
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|stringlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|strlcpy
argument_list|(
name|dev
operator|->
name|name
argument_list|,
name|tmpstring
argument_list|,
name|stringlen
argument_list|)
expr_stmt|;
name|dev
operator|->
name|name
index|[
name|stringlen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Create the description */
name|pcap_snprintf
argument_list|(
name|tmpstring
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstring
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s '%s' %s"
argument_list|,
name|PCAP_TEXT_SOURCE_FILE
argument_list|,
name|filename
argument_list|,
name|PCAP_TEXT_SOURCE_ON_LOCAL_HOST
argument_list|)
expr_stmt|;
name|stringlen
operator|=
name|strlen
argument_list|(
name|tmpstring
argument_list|)
expr_stmt|;
name|dev
operator|->
name|description
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|stringlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|description
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Copy the new device description into the correct memory location */
name|strlcpy
argument_list|(
name|dev
operator|->
name|description
argument_list|,
name|tmpstring
argument_list|,
name|stringlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcap_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|WIN32
do|while
condition|(
name|FindNextFile
argument_list|(
name|filehandle
argument_list|,
operator|&
name|filedata
argument_list|)
operator|!=
literal|0
condition|)
do|;
else|#
directive|else
while|while
condition|(
operator|(
name|filedata
operator|=
name|readdir
argument_list|(
name|unixdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
comment|/* Close the search handle. */
name|FindClose
argument_list|(
name|filehandle
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* If we come here, it is a remote host */
comment|/* Retrieve the needed data for getting adapter list */
if|if
condition|(
name|pcap_parsesrcstr
argument_list|(
name|source
argument_list|,
operator|&
name|type
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Warning: this call can be the first one called by the user. */
comment|/* For this reason, we have to initialize the WinSock support. */
if|if
condition|(
name|sock_init
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check for active mode */
name|sockctrl
operator|=
name|rpcap_remoteact_getsock
argument_list|(
name|host
argument_list|,
operator|&
name|active
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockctrl
operator|==
name|INVALID_SOCKET
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
comment|/* 		 * We're not in active mode; let's try to open a new 		 * control connection. 		 */
name|addrinfo
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
if|if
condition|(
name|port
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* the user chose not to specify the port */
if|if
condition|(
name|sock_initaddress
argument_list|(
name|host
argument_list|,
name|RPCAP_DEFAULT_NETPORT
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|sock_initaddress
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|sockctrl
operator|=
name|sock_open
argument_list|(
name|addrinfo
argument_list|,
name|SOCKOPEN_CLIENT
argument_list|,
literal|0
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
comment|/* addrinfo is no longer used */
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
name|addrinfo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rpcap_sendauth
argument_list|(
name|sockctrl
argument_list|,
name|auth
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_close
argument_list|(
name|sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* RPCAP findalldevs command */
name|rpcap_createhdr
argument_list|(
operator|&
name|header
argument_list|,
name|RPCAP_MSG_FINDALLIF_REQ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_send
argument_list|(
name|sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|sock_recv
argument_list|(
name|sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
comment|/* Checks if the message is correct */
name|retval
operator|=
name|rpcap_checkmsg
argument_list|(
name|errbuf
argument_list|,
name|sockctrl
argument_list|,
operator|&
name|header
argument_list|,
name|RPCAP_MSG_FINDALLIF_REPLY
argument_list|,
name|RPCAP_MSG_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|RPCAP_MSG_FINDALLIF_REPLY
condition|)
comment|/* the message is not the one expected */
block|{
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
operator|-
literal|3
case|:
comment|/* Unrecoverable network error */
case|case
operator|-
literal|2
case|:
comment|/* The other endpoint send a message that is not allowed here */
case|case
operator|-
literal|1
case|:
comment|/* The other endpoint has a version number that is not compatible with our */
break|break;
case|case
name|RPCAP_MSG_ERROR
case|:
comment|/* The other endpoint reported an error */
break|break;
default|default:
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Internal error"
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|active
condition|)
name|sock_close
argument_list|(
name|sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* read the number of interfaces */
name|nif
operator|=
name|ntohs
argument_list|(
name|header
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* loop until all interfaces have been received */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nif
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|rpcap_findalldevs_if
name|findalldevs_if
decl_stmt|;
name|char
name|tmpstring2
index|[
name|PCAP_BUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Needed to convert names and descriptions from 'old' syntax to the 'new' one */
name|size_t
name|stringlen
decl_stmt|;
name|tmpstring2
index|[
name|PCAP_BUF_SIZE
index|]
operator|=
literal|0
expr_stmt|;
comment|/* receive the findalldevs structure from remote host */
name|nread
operator|=
name|sock_recv
argument_list|(
name|sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|findalldevs_if
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_findalldevs_if
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|totread
operator|+=
name|nread
expr_stmt|;
name|findalldevs_if
operator|.
name|namelen
operator|=
name|ntohs
argument_list|(
name|findalldevs_if
operator|.
name|namelen
argument_list|)
expr_stmt|;
name|findalldevs_if
operator|.
name|desclen
operator|=
name|ntohs
argument_list|(
name|findalldevs_if
operator|.
name|desclen
argument_list|)
expr_stmt|;
name|findalldevs_if
operator|.
name|naddr
operator|=
name|ntohs
argument_list|(
name|findalldevs_if
operator|.
name|naddr
argument_list|)
expr_stmt|;
comment|/* allocate the main structure */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|alldevs
operator|)
operator|=
operator|(
name|pcap_if_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_if_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
operator|(
operator|*
name|alldevs
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|next
operator|=
operator|(
name|pcap_if_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_if_t
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|dev
operator|->
name|next
expr_stmt|;
block|}
comment|/* check that the malloc() didn't fail */
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Initialize the structure to 'zero' */
name|memset
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap_if_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate mem for name and description */
if|if
condition|(
name|findalldevs_if
operator|.
name|namelen
condition|)
block|{
if|if
condition|(
name|findalldevs_if
operator|.
name|namelen
operator|>=
sizeof|sizeof
argument_list|(
name|tmpstring
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface name too long"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Retrieve adapter name */
name|nread
operator|=
name|sock_recv
argument_list|(
name|sockctrl
argument_list|,
name|tmpstring
argument_list|,
name|findalldevs_if
operator|.
name|namelen
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|totread
operator|+=
name|nread
expr_stmt|;
name|tmpstring
index|[
name|findalldevs_if
operator|.
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Create the new device identifier */
if|if
condition|(
name|pcap_createsrcstr
argument_list|(
name|tmpstring2
argument_list|,
name|PCAP_SRC_IFREMOTE
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|tmpstring
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|stringlen
operator|=
name|strlen
argument_list|(
name|tmpstring2
argument_list|)
expr_stmt|;
name|dev
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|stringlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Copy the new device name into the correct memory location */
name|strlcpy
argument_list|(
name|dev
operator|->
name|name
argument_list|,
name|tmpstring2
argument_list|,
name|stringlen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|findalldevs_if
operator|.
name|desclen
condition|)
block|{
if|if
condition|(
name|findalldevs_if
operator|.
name|desclen
operator|>=
sizeof|sizeof
argument_list|(
name|tmpstring
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Interface description too long"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Retrieve adapter description */
name|nread
operator|=
name|sock_recv
argument_list|(
name|sockctrl
argument_list|,
name|tmpstring
argument_list|,
name|findalldevs_if
operator|.
name|desclen
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|totread
operator|+=
name|nread
expr_stmt|;
name|tmpstring
index|[
name|findalldevs_if
operator|.
name|desclen
index|]
operator|=
literal|0
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|tmpstring2
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstring2
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s '%s' %s %s"
argument_list|,
name|PCAP_TEXT_SOURCE_ADAPTER
argument_list|,
name|tmpstring
argument_list|,
name|PCAP_TEXT_SOURCE_ON_REMOTE_HOST
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|stringlen
operator|=
name|strlen
argument_list|(
name|tmpstring2
argument_list|)
expr_stmt|;
name|dev
operator|->
name|description
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|stringlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|description
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Copy the new device description into the correct memory location */
name|strlcpy
argument_list|(
name|dev
operator|->
name|description
argument_list|,
name|tmpstring2
argument_list|,
name|stringlen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|flags
operator|=
name|ntohl
argument_list|(
name|findalldevs_if
operator|.
name|flags
argument_list|)
expr_stmt|;
name|naddr
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|NULL
expr_stmt|;
comment|/* loop until all addresses have been received */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|findalldevs_if
operator|.
name|naddr
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|rpcap_findalldevs_ifaddr
name|ifaddr
decl_stmt|;
comment|/* Retrieve the interface addresses */
name|nread
operator|=
name|sock_recv
argument_list|(
name|sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_findalldevs_ifaddr
argument_list|)
argument_list|,
name|SOCK_RECEIVEALL_YES
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|totread
operator|+=
name|nread
expr_stmt|;
comment|/* 			 * WARNING libpcap bug: the address listing is 			 * available only for AF_INET. 			 * 			 * XXX - IPv6? 			 */
if|if
condition|(
name|ntohs
argument_list|(
name|ifaddr
operator|.
name|addr
operator|.
name|ss_family
argument_list|)
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|dev
operator|->
name|addresses
operator|=
operator|(
expr|struct
name|pcap_addr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|dev
operator|->
name|addresses
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|->
name|next
operator|=
operator|(
expr|struct
name|pcap_addr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|addr
operator|->
name|next
expr_stmt|;
block|}
name|naddr
operator|++
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|addr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rpcap_deseraddr
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|ifaddr
operator|.
name|addr
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|*
operator|)
operator|&
name|addr
operator|->
name|addr
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|rpcap_deseraddr
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|ifaddr
operator|.
name|netmask
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|*
operator|)
operator|&
name|addr
operator|->
name|netmask
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|rpcap_deseraddr
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|ifaddr
operator|.
name|broadaddr
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|*
operator|)
operator|&
name|addr
operator|->
name|broadaddr
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|rpcap_deseraddr
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|ifaddr
operator|.
name|dstaddr
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|*
operator|)
operator|&
name|addr
operator|->
name|dstaddr
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|addr
operator|->
name|addr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|addr
operator|->
name|netmask
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|addr
operator|->
name|broadaddr
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|addr
operator|->
name|dstaddr
operator|==
name|NULL
operator|)
condition|)
block|{
name|free
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|naddr
operator|==
literal|1
condition|)
name|naddr
operator|=
literal|0
expr_stmt|;
comment|/* the first item of the list had NULL addresses */
block|}
block|}
block|}
block|}
comment|/* Checks if all the data has been read; if not, discard the data in excess */
if|if
condition|(
name|totread
operator|!=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock_discard
argument_list|(
name|sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|-
name|totread
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Control connection has to be closed only in case the remote machine is in passive mode */
if|if
condition|(
operator|!
name|active
condition|)
block|{
comment|/* DO not send RPCAP_CLOSE, since we did not open a pcap_t; no need to free resources */
if|if
condition|(
name|sock_close
argument_list|(
name|sockctrl
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* To avoid inconsistencies in the number of sock_init() */
name|sock_cleanup
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
comment|/* 	 * In case there has been an error, I don't want to overwrite it with a new one 	 * if the following call fails. I want to return always the original error. 	 * 	 * Take care: this connection can already be closed when we try to close it. 	 * This happens because a previous error in the rpcapd, which requested to 	 * closed the connection. In that case, we already recognized that into the 	 * rpspck_isheaderok() and we already acknowledged the closing. 	 * In that sense, this call is useless here (however it is needed in case 	 * the client generates the error). 	 * 	 * Checks if all the data has been read; if not, discard the data in excess 	 */
if|if
condition|(
name|totread
operator|!=
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock_discard
argument_list|(
name|sockctrl
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|plen
argument_list|)
operator|-
name|totread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Control connection has to be closed only in case the remote machine is in passive mode */
if|if
condition|(
operator|!
name|active
condition|)
name|sock_close
argument_list|(
name|sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* To avoid inconsistencies in the number of sock_init() */
name|sock_cleanup
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|pcap_createsrcstr
parameter_list|(
name|char
modifier|*
name|source
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|host
parameter_list|,
specifier|const
name|char
modifier|*
name|port
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PCAP_SRC_FILE
case|:
block|{
name|strlcpy
argument_list|(
name|source
argument_list|,
name|PCAP_SRC_FILE_STRING
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|)
operator|&&
operator|(
operator|*
name|name
operator|)
condition|)
block|{
name|strlcat
argument_list|(
name|source
argument_list|,
name|name
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The file name cannot be NULL."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
case|case
name|PCAP_SRC_IFREMOTE
case|:
block|{
name|strlcpy
argument_list|(
name|source
argument_list|,
name|PCAP_SRC_IF_STRING
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|host
operator|)
operator|&&
operator|(
operator|*
name|host
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|strcspn
argument_list|(
name|host
argument_list|,
literal|"aAbBcCdDeEfFgGhHjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ"
argument_list|)
operator|)
operator|==
name|strlen
argument_list|(
name|host
argument_list|)
condition|)
block|{
comment|/* the host name does not contains alphabetic chars. So, it is a numeric address */
comment|/* In this case we have to include it between square brackets */
name|strlcat
argument_list|(
name|source
argument_list|,
literal|"["
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|source
argument_list|,
name|host
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|source
argument_list|,
literal|"]"
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|strlcat
argument_list|(
name|source
argument_list|,
name|host
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|port
operator|)
operator|&&
operator|(
operator|*
name|port
operator|)
condition|)
block|{
name|strlcat
argument_list|(
name|source
argument_list|,
literal|":"
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|source
argument_list|,
name|port
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|source
argument_list|,
literal|"/"
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The host name cannot be NULL."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|name
operator|)
operator|&&
operator|(
operator|*
name|name
operator|)
condition|)
name|strlcat
argument_list|(
name|source
argument_list|,
name|name
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|PCAP_SRC_IFLOCAL
case|:
block|{
name|strlcpy
argument_list|(
name|source
argument_list|,
name|PCAP_SRC_IF_STRING
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|)
operator|&&
operator|(
operator|*
name|name
operator|)
condition|)
name|strlcat
argument_list|(
name|source
argument_list|,
name|name
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The interface type is not valid."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|pcap_parsesrcstr
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|int
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|host
parameter_list|,
name|char
modifier|*
name|port
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|ntoken
decl_stmt|;
name|char
name|tmpname
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|;
name|char
name|tmphost
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|;
name|char
name|tmpport
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|;
name|int
name|tmptype
decl_stmt|;
comment|/* Initialization stuff */
name|tmpname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmphost
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmpport
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|host
condition|)
operator|*
name|host
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|port
condition|)
operator|*
name|port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Look for a 'rpcap://' identifier */
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|source
argument_list|,
name|PCAP_SRC_IF_STRING
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|PCAP_SRC_IF_STRING
argument_list|)
operator|==
name|strlen
argument_list|(
name|source
argument_list|)
condition|)
block|{
comment|/* The source identifier contains only the 'rpcap://' string. */
comment|/* So, this is a local capture. */
operator|*
name|type
operator|=
name|PCAP_SRC_IFLOCAL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ptr
operator|+=
name|strlen
argument_list|(
name|PCAP_SRC_IF_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|'['
argument_list|)
condition|)
comment|/* This is probably a numeric address */
block|{
name|ntoken
operator|=
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"[%[1234567890:.]]:%[^/]/%s"
argument_list|,
name|tmphost
argument_list|,
name|tmpport
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntoken
operator|==
literal|1
condition|)
comment|/* probably the port is missing */
name|ntoken
operator|=
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"[%[1234567890:.]]/%s"
argument_list|,
name|tmphost
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|tmptype
operator|=
name|PCAP_SRC_IFREMOTE
expr_stmt|;
block|}
else|else
block|{
name|ntoken
operator|=
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"%[^/:]:%[^/]/%s"
argument_list|,
name|tmphost
argument_list|,
name|tmpport
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntoken
operator|==
literal|1
condition|)
block|{
comment|/* 				 * This can be due to two reasons: 				 * - we want a remote capture, but the network port is missing 				 * - we want to do a local capture 				 * To distinguish between the two, we look for the '/' char 				 */
if|if
condition|(
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
comment|/* We're on a remote capture */
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"%[^/]/%s"
argument_list|,
name|tmphost
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|tmptype
operator|=
name|PCAP_SRC_IFREMOTE
expr_stmt|;
block|}
else|else
block|{
comment|/* We're on a local capture */
if|if
condition|(
operator|*
name|ptr
condition|)
name|strlcpy
argument_list|(
name|tmpname
argument_list|,
name|ptr
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
comment|/* Clean the host name, since it is a remote capture */
comment|/* NOTE: the host name has been assigned in the previous "ntoken= sscanf(...)" line */
name|tmphost
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tmptype
operator|=
name|PCAP_SRC_IFLOCAL
expr_stmt|;
block|}
block|}
else|else
name|tmptype
operator|=
name|PCAP_SRC_IFREMOTE
expr_stmt|;
block|}
if|if
condition|(
name|host
condition|)
name|strlcpy
argument_list|(
name|host
argument_list|,
name|tmphost
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
name|strlcpy
argument_list|(
name|port
argument_list|,
name|tmpport
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|tmptype
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* 			 * If the user wants the host name, but it cannot be located into the source string, return error 			 * However, if the user is not interested in the interface name (e.g. if we're called by 			 * pcap_findalldevs_ex(), which does not have interface name, do not return error 			 */
if|if
condition|(
name|tmpname
index|[
literal|0
index|]
condition|)
block|{
name|strlcpy
argument_list|(
name|name
argument_list|,
name|tmpname
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The interface name has not been specified in the source string."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/* Look for a 'file://' identifier */
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|source
argument_list|,
name|PCAP_SRC_FILE_STRING
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|+=
name|strlen
argument_list|(
name|PCAP_SRC_FILE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|strlcpy
argument_list|(
name|name
argument_list|,
name|ptr
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|PCAP_SRC_FILE
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The file name has not been specified in the source string."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Backward compatibility; the user didn't use the 'rpcap://, file://'  specifiers */
if|if
condition|(
operator|(
name|source
operator|)
operator|&&
operator|(
operator|*
name|source
operator|)
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|strlcpy
argument_list|(
name|name
argument_list|,
name|source
argument_list|,
name|PCAP_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|PCAP_SRC_IFLOCAL
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|errbuf
condition|)
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The interface name has not been specified in the source string."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|pcap_t
modifier|*
name|pcap_open
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|read_timeout
parameter_list|,
name|struct
name|pcap_rmtauth
modifier|*
name|auth
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
name|host
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|,
name|port
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|,
name|name
index|[
name|PCAP_BUF_SIZE
index|]
decl_stmt|;
name|int
name|type
decl_stmt|;
name|pcap_t
modifier|*
name|fp
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|source
argument_list|)
operator|>
name|PCAP_BUF_SIZE
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The source string is too long. Cannot handle it correctly."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* determine the type of the source (file, local, remote) */
if|if
condition|(
name|pcap_parsesrcstr
argument_list|(
name|source
argument_list|,
operator|&
name|type
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|name
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PCAP_SRC_FILE
case|:
name|fp
operator|=
name|pcap_open_offline
argument_list|(
name|name
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCAP_SRC_IFREMOTE
case|:
name|fp
operator|=
name|pcap_create
argument_list|(
name|source
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* 		 * Although we already have host, port and iface, we prefer TO PASS only 'pars' to the 		 * pcap_open_remote() so that it has to call the pcap_parsesrcstr() again. 		 * This is less optimized, but much clearer. 		 */
name|result
operator|=
name|pcap_opensource_remote
argument_list|(
name|fp
argument_list|,
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|pcap_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|fp
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
name|fp
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
name|fp
operator|->
name|opt
operator|.
name|timeout
operator|=
name|read_timeout
expr_stmt|;
name|md
operator|->
name|rmt_flags
operator|=
name|flags
expr_stmt|;
break|break;
case|case
name|PCAP_SRC_IFLOCAL
case|:
name|fp
operator|=
name|pcap_open_live
argument_list|(
name|name
argument_list|,
name|snaplen
argument_list|,
operator|(
name|flags
operator|&
name|PCAP_OPENFLAG_PROMISCUOUS
operator|)
argument_list|,
name|read_timeout
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
comment|/* 		 * these flags are supported on Windows only 		 */
if|if
condition|(
name|fp
operator|!=
name|NULL
operator|&&
name|fp
operator|->
name|adapter
operator|!=
name|NULL
condition|)
block|{
comment|/* disable loopback capture if requested */
if|if
condition|(
name|flags
operator|&
name|PCAP_OPENFLAG_NOCAPTURE_LOCAL
condition|)
block|{
if|if
condition|(
operator|!
name|PacketSetLoopbackBehavior
argument_list|(
name|fp
operator|->
name|adapter
argument_list|,
name|NPF_DISABLE_LOOPBACK
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Unable to disable the capture of loopback packets."
argument_list|)
expr_stmt|;
name|pcap_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* set mintocopy to zero if requested */
if|if
condition|(
name|flags
operator|&
name|PCAP_OPENFLAG_MAX_RESPONSIVENESS
condition|)
block|{
if|if
condition|(
operator|!
name|PacketSetMinToCopy
argument_list|(
name|fp
operator|->
name|adapter
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Unable to set max responsiveness."
argument_list|)
expr_stmt|;
name|pcap_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* WIN32 */
break|break;
default|default:
name|strlcpy
argument_list|(
name|errbuf
argument_list|,
literal|"Source type not supported"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_function
name|struct
name|pcap_samp
modifier|*
name|pcap_setsampling
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_md
modifier|*
name|md
decl_stmt|;
comment|/* structure used when doing a remote live capture */
name|md
operator|=
operator|(
expr|struct
name|pcap_md
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|priv
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_win
argument_list|)
operator|)
expr_stmt|;
return|return
operator|&
operator|(
name|md
operator|->
name|rmt_samp
operator|)
return|;
block|}
end_function

begin_function
name|SOCKET
name|pcap_remoteact_accept
parameter_list|(
specifier|const
name|char
modifier|*
name|address
parameter_list|,
specifier|const
name|char
modifier|*
name|port
parameter_list|,
specifier|const
name|char
modifier|*
name|hostlist
parameter_list|,
name|char
modifier|*
name|connectinghost
parameter_list|,
name|struct
name|pcap_rmtauth
modifier|*
name|auth
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* socket-related variables */
name|struct
name|addrinfo
name|hints
decl_stmt|;
comment|/* temporary struct to keep settings needed to open the new socket */
name|struct
name|addrinfo
modifier|*
name|addrinfo
decl_stmt|;
comment|/* keeps the addrinfo chain; required to open a new socket */
name|struct
name|sockaddr_storage
name|from
decl_stmt|;
comment|/* generic sockaddr_storage variable */
name|socklen_t
name|fromlen
decl_stmt|;
comment|/* keeps the length of the sockaddr_storage variable */
name|SOCKET
name|sockctrl
decl_stmt|;
comment|/* keeps the main socket identifier */
name|struct
name|activehosts
modifier|*
name|temp
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* temp var needed to scan he host list chain */
operator|*
name|connectinghost
operator|=
literal|0
expr_stmt|;
comment|/* just in case */
comment|/* Prepare to open a new server socket */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* WARNING Currently it supports only ONE socket family among ipv4 and IPv6  */
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
comment|/* PF_UNSPEC to have both IPv4 and IPv6 server */
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
comment|/* Ready to a bind() socket */
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
comment|/* Warning: this call can be the first one called by the user. */
comment|/* For this reason, we have to initialize the WinSock support. */
if|if
condition|(
name|sock_init
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Do the work */
if|if
condition|(
operator|(
name|port
operator|==
name|NULL
operator|)
operator|||
operator|(
name|port
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|sock_initaddress
argument_list|(
name|address
argument_list|,
name|RPCAP_DEFAULT_NETPORT_ACTIVE
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|SOCK_ASSERT
argument_list|(
name|errbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sock_initaddress
argument_list|(
name|address
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|SOCK_ASSERT
argument_list|(
name|errbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
if|if
condition|(
operator|(
name|sockmain
operator|=
name|sock_open
argument_list|(
name|addrinfo
argument_list|,
name|SOCKOPEN_SERVER
argument_list|,
literal|1
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|SOCK_ASSERT
argument_list|(
name|errbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
comment|/* Connection creation */
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
name|sockctrl
operator|=
name|accept
argument_list|(
name|sockmain
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
comment|/* We're not using sock_close, since we do not want to send a shutdown */
comment|/* (which is not allowed on a non-connected socket) */
name|closesocket
argument_list|(
name|sockmain
argument_list|)
expr_stmt|;
name|sockmain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sockctrl
operator|==
operator|-
literal|1
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"accept(): "
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
comment|/* Get the numeric for of the name of the connecting host */
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
name|fromlen
argument_list|,
name|connectinghost
argument_list|,
name|RPCAP_HOSTLIST_SIZE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
condition|)
block|{
name|sock_geterror
argument_list|(
literal|"getnameinfo(): "
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
name|rpcap_senderror
argument_list|(
name|sockctrl
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERR_REMOTEACCEPT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sock_close
argument_list|(
name|sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* checks if the connecting host is among the ones allowed */
if|if
condition|(
name|sock_check_hostlist
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hostlist
argument_list|,
name|RPCAP_HOSTLIST_SEP
argument_list|,
operator|&
name|from
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rpcap_senderror
argument_list|(
name|sockctrl
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERR_REMOTEACCEPT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sock_close
argument_list|(
name|sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Send authentication to the remote machine */
if|if
condition|(
name|rpcap_sendauth
argument_list|(
name|sockctrl
argument_list|,
name|auth
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rpcap_senderror
argument_list|(
name|sockctrl
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERR_REMOTEACCEPT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sock_close
argument_list|(
name|sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|3
return|;
block|}
comment|/* Checks that this host does not already have a cntrl connection in place */
comment|/* Initialize pointers */
name|temp
operator|=
name|activeHosts
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
comment|/* This host already has an active connection in place, so I don't have to update the host list */
if|if
condition|(
name|sock_cmpaddr
argument_list|(
operator|&
name|temp
operator|->
name|host
argument_list|,
operator|&
name|from
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sockctrl
return|;
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
comment|/* The host does not exist in the list; so I have to update the list */
if|if
condition|(
name|prev
condition|)
block|{
name|prev
operator|->
name|next
operator|=
operator|(
expr|struct
name|activehosts
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|activehosts
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|prev
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|activeHosts
operator|=
operator|(
expr|struct
name|activehosts
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|activehosts
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|activeHosts
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rpcap_senderror
argument_list|(
name|sockctrl
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERR_REMOTEACCEPT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sock_close
argument_list|(
name|sockctrl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|temp
operator|->
name|host
argument_list|,
operator|&
name|from
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
name|temp
operator|->
name|sockctrl
operator|=
name|sockctrl
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|sockctrl
return|;
block|}
end_function

begin_function
name|int
name|pcap_remoteact_close
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|activehosts
modifier|*
name|temp
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* temp var needed to scan the host list chain */
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|addrinfo
decl_stmt|,
modifier|*
name|ai_next
decl_stmt|;
comment|/* temp var needed to translate between hostname to its address */
name|int
name|retval
decl_stmt|;
name|temp
operator|=
name|activeHosts
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* retrieve the network address corresponding to 'host' */
name|addrinfo
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|retval
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
literal|"0"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getaddrinfo() %s"
argument_list|,
name|gai_strerror
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|temp
condition|)
block|{
name|ai_next
operator|=
name|addrinfo
expr_stmt|;
while|while
condition|(
name|ai_next
condition|)
block|{
if|if
condition|(
name|sock_cmpaddr
argument_list|(
operator|&
name|temp
operator|->
name|host
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|ai_next
operator|->
name|ai_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|rpcap_header
name|header
decl_stmt|;
comment|/* Close this connection */
name|rpcap_createhdr
argument_list|(
operator|&
name|header
argument_list|,
name|RPCAP_MSG_CLOSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* I don't check for errors, since I'm going to close everything */
name|sock_send
argument_list|(
name|temp
operator|->
name|sockctrl
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcap_header
argument_list|)
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_close
argument_list|(
name|temp
operator|->
name|sockctrl
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
condition|)
block|{
comment|/* To avoid inconsistencies in the number of sock_init() */
name|sock_cleanup
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
else|else
name|activeHosts
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* To avoid inconsistencies in the number of sock_init() */
name|sock_cleanup
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ai_next
operator|=
name|ai_next
operator|->
name|ai_next
expr_stmt|;
block|}
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|addrinfo
condition|)
name|freeaddrinfo
argument_list|(
name|addrinfo
argument_list|)
expr_stmt|;
comment|/* To avoid inconsistencies in the number of sock_init() */
name|sock_cleanup
argument_list|()
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The host you want to close the active connection is not known"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|pcap_remoteact_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Very dirty, but it works */
if|if
condition|(
name|sockmain
condition|)
block|{
name|closesocket
argument_list|(
name|sockmain
argument_list|)
expr_stmt|;
comment|/* To avoid inconsistencies in the number of sock_init() */
name|sock_cleanup
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pcap_remoteact_list
parameter_list|(
name|char
modifier|*
name|hostlist
parameter_list|,
name|char
name|sep
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|activehosts
modifier|*
name|temp
decl_stmt|;
comment|/* temp var needed to scan the host list chain */
name|size_t
name|len
decl_stmt|;
name|char
name|hoststr
index|[
name|RPCAP_HOSTLIST_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|temp
operator|=
name|activeHosts
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|hostlist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
comment|/*int sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, int errbuflen) */
comment|/* Get the numeric form of the name of the connecting host */
if|if
condition|(
name|sock_getascii_addrport
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|temp
operator|->
name|host
argument_list|,
name|hoststr
argument_list|,
name|RPCAP_HOSTLIST_SIZE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
operator|!=
operator|-
literal|1
condition|)
comment|/*	if (getnameinfo( (struct sockaddr *)&temp->host, sizeof (struct sockaddr_storage), hoststr, */
comment|/*		RPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST) ) */
block|{
comment|/*	sock_geterror("getnameinfo(): ", errbuf, PCAP_ERRBUF_SIZE); */
return|return
operator|-
literal|1
return|;
block|}
name|len
operator|=
name|len
operator|+
name|strlen
argument_list|(
name|hoststr
argument_list|)
operator|+
literal|1
comment|/* the separator */
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|<
literal|0
operator|)
operator|||
operator|(
name|len
operator|>=
operator|(
name|size_t
operator|)
name|size
operator|)
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The string you provided is not able to keep "
literal|"the hostnames for all the active connections"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|strlcat
argument_list|(
name|hostlist
argument_list|,
name|hoststr
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
name|hostlist
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|sep
expr_stmt|;
name|hostlist
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

