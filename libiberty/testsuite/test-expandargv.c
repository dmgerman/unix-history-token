begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* expandargv test program,    Copyright (C) 2006 Free Software Foundation, Inc.    Written by Carlos O'Donell<carlos@codesourcery.com>     This file is part of the libiberty library, which is part of GCC.     This file is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     In addition to the permissions in the GNU General Public License, the    Free Software Foundation gives you unlimited permission to link the    compiled version of this file into combinations with other programs,    and to distribute those combinations without any restriction coming    from the use of this file.  (The General Public License restrictions    do apply in other respects; for example, they cover modification of    the file, and distribution when not linked into a combined    executable.)     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_SUCCESS
end_ifndef

begin_define
define|#
directive|define
name|EXIT_SUCCESS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_FAILURE
end_ifndef

begin_define
define|#
directive|define
name|EXIT_FAILURE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|fatal_error
argument_list|(
name|int
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|writeout_test
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|run_replaces
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hook_char_replace
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|run_tests
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|erase_test
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Test input data, argv before, and argv after:      The \n is an important part of test_data since expandargv    may have to work in environments where \n is translated    as \r\n. Thus \n is included in the test data for the file.      We use \b to indicate that the test data is the null character.    This is because we use \0 normally to represent the end of the     file data, so we need something else for this. */
end_comment

begin_define
define|#
directive|define
name|FILENAME_PATTERN
value|"test-expandargv-%d.lst"
end_define

begin_define
define|#
directive|define
name|ARGV0
value|"test-expandargv"
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|test_data
index|[]
init|=
block|{
comment|/* Test 0 - Check for expansion with \r\n */
literal|"a\r\nb"
block|,
comment|/* Test 0 data */
name|ARGV0
block|,
literal|"@test-expandargv-0.lst"
block|,
literal|0
block|,
comment|/* End of argv[] before expansion */
name|ARGV0
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|0
block|,
comment|/* End of argv[] after expansion */
comment|/* Test 1 - Check for expansion with \n */
literal|"a\nb"
block|,
comment|/* Test 1 data */
name|ARGV0
block|,
literal|"@test-expandargv-1.lst"
block|,
literal|0
block|,
name|ARGV0
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|0
block|,
comment|/* Test 2 - Check for expansion with \0 */
literal|"a\bb"
block|,
comment|/* Test 2 data */
name|ARGV0
block|,
literal|"@test-expandargv-2.lst"
block|,
literal|0
block|,
name|ARGV0
block|,
literal|"a"
block|,
literal|0
block|,
comment|/* Test 3 - Check for expansion with only \0 */
literal|"\b"
block|,
comment|/* Test 3 data */
name|ARGV0
block|,
literal|"@test-expandargv-3.lst"
block|,
literal|0
block|,
name|ARGV0
block|,
literal|0
block|,
literal|0
comment|/* Test done marker, don't remove. */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a fatal error and exit.  LINE is the line number where we    detected the error, ERRMSG is the error message to print, and ERR    is 0 or an errno value to print.  */
end_comment

begin_function
specifier|static
name|void
name|fatal_error
parameter_list|(
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|errmsg
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"test-expandargv:%d: %s"
argument_list|,
name|line
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|xstrerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* hook_char_replace:      Replace 'replacethis' with 'withthis' */
end_comment

begin_function
name|void
name|hook_char_replace
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
name|replacethis
parameter_list|,
name|char
name|withthis
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|replacethis
condition|)
name|string
index|[
name|i
index|]
operator|=
name|withthis
expr_stmt|;
block|}
end_function

begin_comment
comment|/* run_replaces:      Hook here all the character for character replaces.      Be warned that expanding the string or contracting the string      should be handled with care. */
end_comment

begin_function
name|void
name|run_replaces
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Store original string size */
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|hook_char_replace
argument_list|(
name|string
argument_list|,
name|len
argument_list|,
literal|'\b'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* write_test:    Write test datafile */
end_comment

begin_function
name|void
name|writeout_test
parameter_list|(
name|int
name|test
parameter_list|,
specifier|const
name|char
modifier|*
name|test_data
parameter_list|)
block|{
name|char
name|filename
index|[
literal|256
index|]
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|parse
decl_stmt|;
comment|/* Unique filename per test */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|FILENAME_PATTERN
argument_list|,
name|test
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
name|fatal_error
argument_list|(
name|__LINE__
argument_list|,
literal|"Failed to create test file."
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* Generate RW copy of data for replaces */
name|len
operator|=
name|strlen
argument_list|(
name|test_data
argument_list|)
expr_stmt|;
name|parse
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
operator|==
name|NULL
condition|)
name|fatal_error
argument_list|(
name|__LINE__
argument_list|,
literal|"Failed to malloc parse."
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|parse
argument_list|,
name|test_data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|len
argument_list|)
expr_stmt|;
comment|/* Run all possible replaces */
name|run_replaces
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|parse
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* erase_test:      Erase the test file */
end_comment

begin_function
name|void
name|erase_test
parameter_list|(
name|int
name|test
parameter_list|)
block|{
name|char
name|filename
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
name|FILENAME_PATTERN
argument_list|,
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|filename
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
name|__LINE__
argument_list|,
literal|"Failed to erase test file."
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* run_tests:     Run expandargv     Compare argv before and after.     Return number of fails */
end_comment

begin_function
name|int
name|run_tests
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|test_data
parameter_list|)
block|{
name|int
name|argc_after
decl_stmt|,
name|argc_before
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv_before
decl_stmt|,
modifier|*
modifier|*
name|argv_after
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|fails
decl_stmt|,
name|failed
decl_stmt|;
name|i
operator|=
name|j
operator|=
name|fails
operator|=
literal|0
expr_stmt|;
comment|/* Loop over all the tests */
while|while
condition|(
name|test_data
index|[
name|j
index|]
condition|)
block|{
comment|/* Write test data */
name|writeout_test
argument_list|(
name|i
argument_list|,
name|test_data
index|[
name|j
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* Copy argv before */
name|argv_before
operator|=
name|dupargv
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|test_data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* Count argc before/after */
name|argc_before
operator|=
literal|0
expr_stmt|;
name|argc_after
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|test_data
index|[
name|j
operator|+
name|argc_before
index|]
condition|)
name|argc_before
operator|++
expr_stmt|;
name|j
operator|+=
name|argc_before
operator|+
literal|1
expr_stmt|;
comment|/* Skip null */
while|while
condition|(
name|test_data
index|[
name|j
operator|+
name|argc_after
index|]
condition|)
name|argc_after
operator|++
expr_stmt|;
comment|/* Copy argv after */
name|argv_after
operator|=
name|dupargv
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|test_data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* Run all possible replaces */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argc_before
condition|;
name|k
operator|++
control|)
name|run_replaces
argument_list|(
name|argv_before
index|[
name|k
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argc_after
condition|;
name|k
operator|++
control|)
name|run_replaces
argument_list|(
name|argv_after
index|[
name|k
index|]
argument_list|)
expr_stmt|;
comment|/* Run test: Expand arguments */
name|expandargv
argument_list|(
operator|&
name|argc_before
argument_list|,
operator|&
name|argv_before
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|0
expr_stmt|;
comment|/* Compare size first */
if|if
condition|(
name|argc_before
operator|!=
name|argc_after
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: test-expandargv-%d. Number of arguments don't match.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|failed
operator|++
expr_stmt|;
block|}
comment|/* Compare each of the argv's ... */
else|else
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argc_after
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|argv_before
index|[
name|k
index|]
argument_list|,
name|argv_after
index|[
name|k
index|]
argument_list|,
name|strlen
argument_list|(
name|argv_after
index|[
name|k
index|]
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: test-expandargv-%d. Arguments don't match.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|failed
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|failed
condition|)
name|printf
argument_list|(
literal|"PASS: test-expandargv-%d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fails
operator|++
expr_stmt|;
name|freeargv
argument_list|(
name|argv_before
argument_list|)
expr_stmt|;
name|freeargv
argument_list|(
name|argv_after
argument_list|)
expr_stmt|;
comment|/* Advance to next test */
name|j
operator|+=
name|argc_after
operator|+
literal|1
expr_stmt|;
comment|/* Erase test file */
name|erase_test
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|fails
return|;
block|}
end_function

begin_comment
comment|/* main:     Run tests.      Check result and exit with appropriate code. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|fails
decl_stmt|;
comment|/* Repeat for all the tests:      - Parse data array and write into file.        - Run replace hooks before writing to file.      - Parse data array and build argv before/after.        - Run replace hooks on argv before/after      - Run expandargv.      - Compare output of expandargv argv to after argv.        - If they compare the same then test passes          else the test fails.       - Erase test file. */
name|fails
operator|=
name|run_tests
argument_list|(
name|test_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fails
condition|)
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

