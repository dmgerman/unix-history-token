begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Demangler test program,    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.    Written by Zack Weinberg<zack@codesourcery.com     This file is part of GNU libiberty.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|line
block|{
name|size_t
name|alloced
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Safely read a single line of arbitrary length from standard input.  */
end_comment

begin_define
define|#
directive|define
name|LINELEN
value|80
end_define

begin_function
specifier|static
name|void
name|getline
parameter_list|(
name|buf
parameter_list|)
name|struct
name|line
modifier|*
name|buf
decl_stmt|;
block|{
name|char
modifier|*
name|data
init|=
name|buf
operator|->
name|data
decl_stmt|;
name|size_t
name|alloc
init|=
name|buf
operator|->
name|alloced
decl_stmt|;
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|0
condition|)
block|{
name|data
operator|=
name|xmalloc
argument_list|(
name|LINELEN
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|LINELEN
expr_stmt|;
block|}
comment|/* Skip comment lines.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
comment|/* c is the first character on the line, and it's not a comment      line: copy this line into the buffer and return.  */
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|count
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|*=
literal|2
expr_stmt|;
name|data
operator|=
name|xrealloc
argument_list|(
name|data
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|data
index|[
name|count
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|lineno
operator|++
expr_stmt|;
name|data
index|[
name|count
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|buf
operator|->
name|alloced
operator|=
name|alloc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If we have mmap() and mprotect(), copy the string S just before a    protected page, so that if the demangler runs over the end of the    string we'll get a fault, and return the address of the new string.    If no mmap, or it fails, or it looks too hard, just return S.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MMAN_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|protect_end
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
name|size_t
name|pagesize
init|=
name|getpagesize
argument_list|()
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|s_len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Don't try if S is too long.  */
if|if
condition|(
name|s_len
operator|>=
name|pagesize
condition|)
return|return
name|s
return|;
comment|/* Allocate one page of allocated space followed by an unmapped      page.  */
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|pagesize
operator|*
literal|2
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|s
return|;
name|munmap
argument_list|(
name|buf
operator|+
name|pagesize
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|buf
operator|+
operator|(
name|pagesize
operator|-
name|s_len
operator|-
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|s_len
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
else|#
directive|else
return|return
name|s
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|fail
parameter_list|(
name|lineno
parameter_list|,
name|opts
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|,
name|exp
parameter_list|)
name|int
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
decl_stmt|;
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
specifier|const
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\ FAIL at line %d, options %s:\n\ in:  %s\n\ out: %s\n\ exp: %s\n"
argument_list|,
name|lineno
argument_list|,
name|opts
argument_list|,
name|in
argument_list|,
name|out
operator|!=
name|NULL
condition|?
name|out
else|:
literal|"(null)"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The tester operates on a data file consisting of groups of lines:    options    input to be demangled    expected output     Supported options:      --format=<name>     Sets the demangling style.      --no-params         There are two lines of expected output; the first                          is with DMGL_PARAMS, the second is without it.      --is-v3-ctor        Calls is_gnu_v3_mangled_ctor on input; expected                          output is an integer representing ctor_kind.      --is-v3-dtor        Likewise, but for dtors.      --ret-postfix       Passes the DMGL_RET_POSTFIX option     For compatibility, just in case it matters, the options line may be    empty, to mean --format=auto.  If it doesn't start with --, then it    may contain only a format name. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|enum
name|demangling_styles
name|style
init|=
name|auto_demangling
decl_stmt|;
name|int
name|no_params
decl_stmt|;
name|int
name|is_v3_ctor
decl_stmt|;
name|int
name|is_v3_dtor
decl_stmt|;
name|int
name|ret_postfix
decl_stmt|;
name|struct
name|line
name|format
decl_stmt|;
name|struct
name|line
name|input
decl_stmt|;
name|struct
name|line
name|expect
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|failures
init|=
literal|0
decl_stmt|;
name|int
name|tests
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s< test-set\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|format
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|input
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|expect
operator|.
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|inp
decl_stmt|;
name|getline
argument_list|(
operator|&
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
break|break;
name|getline
argument_list|(
operator|&
name|input
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|&
name|expect
argument_list|)
expr_stmt|;
name|inp
operator|=
name|protect_end
argument_list|(
name|input
operator|.
name|data
argument_list|)
expr_stmt|;
name|tests
operator|++
expr_stmt|;
name|no_params
operator|=
literal|0
expr_stmt|;
name|ret_postfix
operator|=
literal|0
expr_stmt|;
name|is_v3_ctor
operator|=
literal|0
expr_stmt|;
name|is_v3_dtor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|data
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|style
operator|=
name|auto_demangling
expr_stmt|;
elseif|else
if|if
condition|(
name|format
operator|.
name|data
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|format
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL at line %d: unknown demangling style %s\n"
argument_list|,
name|lineno
argument_list|,
name|format
operator|.
name|data
argument_list|)
expr_stmt|;
name|failures
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
name|p
operator|=
name|format
operator|.
name|data
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|c
decl_stmt|;
name|opt
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|" \t="
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--format"
argument_list|)
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'='
condition|)
block|{
name|char
modifier|*
name|fstyle
decl_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
operator|++
name|p
expr_stmt|;
name|fstyle
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|fstyle
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL at line %d: unknown demangling style %s\n"
argument_list|,
name|lineno
argument_list|,
name|fstyle
argument_list|)
expr_stmt|;
name|failures
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--no-params"
argument_list|)
operator|==
literal|0
condition|)
name|no_params
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--is-v3-ctor"
argument_list|)
operator|==
literal|0
condition|)
name|is_v3_ctor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--is-v3-dtor"
argument_list|)
operator|==
literal|0
condition|)
name|is_v3_dtor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--ret-postfix"
argument_list|)
operator|==
literal|0
condition|)
name|ret_postfix
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"FAIL at line %d: unrecognized option %s\n"
argument_list|,
name|lineno
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|failures
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|p
operator|+=
name|strspn
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_v3_ctor
operator|||
name|is_v3_dtor
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|is_v3_ctor
condition|)
block|{
name|enum
name|gnu_v3_ctor_kinds
name|kc
decl_stmt|;
name|kc
operator|=
name|is_gnu_v3_mangled_ctor
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|kc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|gnu_v3_dtor_kinds
name|kd
decl_stmt|;
name|kd
operator|=
name|is_gnu_v3_mangled_dtor
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|kd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|expect
operator|.
name|data
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fail
argument_list|(
name|lineno
argument_list|,
name|format
operator|.
name|data
argument_list|,
name|input
operator|.
name|data
argument_list|,
name|buf
argument_list|,
name|expect
operator|.
name|data
argument_list|)
expr_stmt|;
name|failures
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|inp
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
operator||
name|DMGL_TYPES
operator||
operator|(
name|ret_postfix
condition|?
name|DMGL_RET_POSTFIX
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|?
name|strcmp
argument_list|(
name|result
argument_list|,
name|expect
operator|.
name|data
argument_list|)
else|:
name|strcmp
argument_list|(
name|input
operator|.
name|data
argument_list|,
name|expect
operator|.
name|data
argument_list|)
condition|)
block|{
name|fail
argument_list|(
name|lineno
argument_list|,
name|format
operator|.
name|data
argument_list|,
name|input
operator|.
name|data
argument_list|,
name|result
argument_list|,
name|expect
operator|.
name|data
argument_list|)
expr_stmt|;
name|failures
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_params
condition|)
block|{
name|getline
argument_list|(
operator|&
name|expect
argument_list|)
expr_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|inp
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_TYPES
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|?
name|strcmp
argument_list|(
name|result
argument_list|,
name|expect
operator|.
name|data
argument_list|)
else|:
name|strcmp
argument_list|(
name|input
operator|.
name|data
argument_list|,
name|expect
operator|.
name|data
argument_list|)
condition|)
block|{
name|fail
argument_list|(
name|lineno
argument_list|,
name|format
operator|.
name|data
argument_list|,
name|input
operator|.
name|data
argument_list|,
name|result
argument_list|,
name|expect
operator|.
name|data
argument_list|)
expr_stmt|;
name|failures
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|format
operator|.
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input
operator|.
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expect
operator|.
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %d tests, %d failures\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|tests
argument_list|,
name|failures
argument_list|)
expr_stmt|;
return|return
name|failures
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

end_unit

