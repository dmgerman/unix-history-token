begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities to execute a program in a subprocess (possibly linked by pipes    with other subprocesses), and wait for it.  Generic Unix version    (also used for UWIN and VMS).    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"pex-common.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_ERRNO
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vfork
end_ifdef

begin_comment
comment|/* Autoconf may define this to fork for us. */
end_comment

begin_define
define|#
directive|define
name|VFORK_STRING
value|"fork"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VFORK_STRING
value|"vfork"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VFORK_H
end_ifdef

begin_include
include|#
directive|include
file|<vfork.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|vfork
parameter_list|()
value|(decc$$alloc_vfork_blocks()>= 0 ? \                lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/* File mode to use for private and world-readable files.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|S_IRUSR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IWUSR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IRGRP
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IWGRP
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IROTH
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IWOTH
argument_list|)
end_if

begin_define
define|#
directive|define
name|PUBLIC_MODE
define|\
value|(S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PUBLIC_MODE
value|0666
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get the exit status of a particular process, and optionally get the    time that it took.  This is simple if we have wait4, slightly    harder if we have waitpid, and is a pain if we only have wait.  */
end_comment

begin_function_decl
specifier|static
name|pid_t
name|pex_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|pid_t
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|pex_time
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WAIT4
end_ifdef

begin_function
specifier|static
name|pid_t
name|pex_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|struct
name|pex_time
modifier|*
name|time
parameter_list|)
block|{
name|pid_t
name|ret
decl_stmt|;
name|struct
name|rusage
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_WAITPID
if|if
condition|(
name|time
operator|==
name|NULL
condition|)
return|return
name|waitpid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
name|ret
operator|=
name|wait4
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|time
operator|!=
name|NULL
condition|)
block|{
name|time
operator|->
name|user_seconds
operator|=
name|r
operator|.
name|ru_utime
operator|.
name|tv_sec
expr_stmt|;
name|time
operator|->
name|user_microseconds
operator|=
name|r
operator|.
name|ru_utime
operator|.
name|tv_usec
expr_stmt|;
name|time
operator|->
name|system_seconds
operator|=
name|r
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|time
operator|->
name|system_microseconds
operator|=
name|r
operator|.
name|ru_stime
operator|.
name|tv_usec
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (HAVE_WAIT4) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WAITPID
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETRUSAGE
end_ifndef

begin_function
specifier|static
name|pid_t
name|pex_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|struct
name|pex_time
modifier|*
name|time
parameter_list|)
block|{
if|if
condition|(
name|time
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|time
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pex_time
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|waitpid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (HAVE_GETRUSAGE) */
end_comment

begin_function
specifier|static
name|pid_t
name|pex_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|struct
name|pex_time
modifier|*
name|time
parameter_list|)
block|{
name|struct
name|rusage
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|pid_t
name|ret
decl_stmt|;
if|if
condition|(
name|time
operator|==
name|NULL
condition|)
return|return
name|waitpid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
literal|0
argument_list|)
return|;
name|getrusage
argument_list|(
name|RUSAGE_CHILDREN
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|getrusage
argument_list|(
name|RUSAGE_CHILDREN
argument_list|,
operator|&
name|r2
argument_list|)
expr_stmt|;
name|time
operator|->
name|user_seconds
operator|=
name|r2
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|-
name|r1
operator|.
name|ru_utime
operator|.
name|tv_sec
expr_stmt|;
name|time
operator|->
name|user_microseconds
operator|=
name|r2
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|-
name|r1
operator|.
name|ru_utime
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|r2
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|<
name|r1
operator|.
name|ru_utime
operator|.
name|tv_usec
condition|)
block|{
operator|--
name|time
operator|->
name|user_seconds
expr_stmt|;
name|time
operator|->
name|user_microseconds
operator|+=
literal|1000000
expr_stmt|;
block|}
name|time
operator|->
name|system_seconds
operator|=
name|r2
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|-
name|r1
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|time
operator|->
name|system_microseconds
operator|=
name|r2
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|-
name|r1
operator|.
name|ru_stime
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|r2
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|<
name|r1
operator|.
name|ru_stime
operator|.
name|tv_usec
condition|)
block|{
operator|--
name|time
operator|->
name|system_seconds
expr_stmt|;
name|time
operator|->
name|system_microseconds
operator|+=
literal|1000000
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (HAVE_GETRUSAGE) */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (HAVE_WAITPID) */
end_comment

begin_struct
struct|struct
name|status_list
block|{
name|struct
name|status_list
modifier|*
name|next
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|pex_time
name|time
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|pid_t
name|pex_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|struct
name|pex_time
modifier|*
name|time
parameter_list|)
block|{
name|struct
name|status_list
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|(
expr|struct
name|status_list
operator|*
operator|*
operator|)
operator|&
name|obj
operator|->
name|sysdep
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|pid
operator|==
name|pid
condition|)
block|{
name|struct
name|status_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|status
operator|=
name|p
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|time
operator|!=
name|NULL
condition|)
operator|*
name|time
operator|=
name|p
operator|->
name|time
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|pid_t
name|cpid
decl_stmt|;
name|struct
name|status_list
modifier|*
name|psl
decl_stmt|;
name|struct
name|pex_time
name|pt
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
name|struct
name|rusage
name|r1
decl_stmt|,
name|r2
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|time
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
name|getrusage
argument_list|(
name|RUSAGE_CHILDREN
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
operator|&
name|pt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pex_time
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|cpid
operator|=
name|wait
argument_list|(
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
if|if
condition|(
name|time
operator|!=
name|NULL
operator|&&
name|cpid
operator|>=
literal|0
condition|)
block|{
name|getrusage
argument_list|(
name|RUSAGE_CHILDREN
argument_list|,
operator|&
name|r2
argument_list|)
expr_stmt|;
name|pt
operator|.
name|user_seconds
operator|=
name|r2
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|-
name|r1
operator|.
name|ru_utime
operator|.
name|tv_sec
expr_stmt|;
name|pt
operator|.
name|user_microseconds
operator|=
name|r2
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|-
name|r1
operator|.
name|ru_utime
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|pt
operator|.
name|user_microseconds
operator|<
literal|0
condition|)
block|{
operator|--
name|pt
operator|.
name|user_seconds
expr_stmt|;
name|pt
operator|.
name|user_microseconds
operator|+=
literal|1000000
expr_stmt|;
block|}
name|pt
operator|.
name|system_seconds
operator|=
name|r2
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|-
name|r1
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|pt
operator|.
name|system_microseconds
operator|=
name|r2
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|-
name|r1
operator|.
name|ru_stime
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|pt
operator|.
name|system_microseconds
operator|<
literal|0
condition|)
block|{
operator|--
name|pt
operator|.
name|system_seconds
expr_stmt|;
name|pt
operator|.
name|system_microseconds
operator|+=
literal|1000000
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|cpid
operator|<
literal|0
operator|||
name|cpid
operator|==
name|pid
condition|)
block|{
if|if
condition|(
name|time
operator|!=
name|NULL
condition|)
operator|*
name|time
operator|=
name|pt
expr_stmt|;
return|return
name|cpid
return|;
block|}
name|psl
operator|=
name|XNEW
argument_list|(
expr|struct
name|status_list
argument_list|)
expr_stmt|;
name|psl
operator|->
name|pid
operator|=
name|cpid
expr_stmt|;
name|psl
operator|->
name|status
operator|=
operator|*
name|status
expr_stmt|;
if|if
condition|(
name|time
operator|!=
name|NULL
condition|)
name|psl
operator|->
name|time
operator|=
name|pt
expr_stmt|;
name|psl
operator|->
name|next
operator|=
operator|(
expr|struct
name|status_list
operator|*
operator|)
name|obj
operator|->
name|sysdep
expr_stmt|;
name|obj
operator|->
name|sysdep
operator|=
operator|(
name|void
operator|*
operator|)
name|psl
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (HAVE_WAITPID) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (HAVE_WAIT4) */
end_comment

begin_decl_stmt
specifier|static
name|void
name|pex_child_error
argument_list|(
expr|struct
name|pex_obj
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pex_unix_open_read
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_unix_open_write
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|pex_unix_exec_child
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_unix_close
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_unix_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|pex_time
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_unix_pipe
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|pex_unix_fdopenr
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|pex_unix_fdopenw
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pex_unix_cleanup
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The list of functions we pass to the common routines.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|pex_funcs
name|funcs
init|=
block|{
name|pex_unix_open_read
block|,
name|pex_unix_open_write
block|,
name|pex_unix_exec_child
block|,
name|pex_unix_close
block|,
name|pex_unix_wait
block|,
name|pex_unix_pipe
block|,
name|pex_unix_fdopenr
block|,
name|pex_unix_fdopenw
block|,
name|pex_unix_cleanup
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a newly initialized pex_obj structure.  */
end_comment

begin_function
name|struct
name|pex_obj
modifier|*
name|pex_init
parameter_list|(
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|char
modifier|*
name|tempbase
parameter_list|)
block|{
return|return
name|pex_init_common
argument_list|(
name|flags
argument_list|,
name|pname
argument_list|,
name|tempbase
argument_list|,
operator|&
name|funcs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open a file for reading.  */
end_comment

begin_function
specifier|static
name|int
name|pex_unix_open_read
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|binary
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open a file for writing.  */
end_comment

begin_function
specifier|static
name|int
name|pex_unix_open_write
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|binary
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Note that we can't use O_EXCL here because gcc may have already      created the temporary file via make_temp_file.  */
return|return
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|PUBLIC_MODE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close a file.  */
end_comment

begin_function
specifier|static
name|int
name|pex_unix_close
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
return|return
name|close
argument_list|(
name|fd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Report an error from a child process.  We don't use stdio routines,    because we might be here due to a vfork call.  */
end_comment

begin_function
specifier|static
name|void
name|pex_child_error
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|executable
parameter_list|,
specifier|const
name|char
modifier|*
name|errmsg
parameter_list|,
name|int
name|err
parameter_list|)
block|{
define|#
directive|define
name|writeerr
parameter_list|(
name|s
parameter_list|)
value|write (STDERR_FILE_NO, s, strlen (s))
name|writeerr
argument_list|(
name|obj
operator|->
name|pname
argument_list|)
expr_stmt|;
name|writeerr
argument_list|(
literal|": error trying to exec '"
argument_list|)
expr_stmt|;
name|writeerr
argument_list|(
name|executable
argument_list|)
expr_stmt|;
name|writeerr
argument_list|(
literal|"': "
argument_list|)
expr_stmt|;
name|writeerr
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
name|writeerr
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|writeerr
argument_list|(
name|xstrerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|writeerr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute a child.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|long
name|pex_unix_exec_child
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|executable
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|int
name|errdes
parameter_list|,
name|int
name|toclose
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
comment|/* We declare these to be volatile to avoid warnings from gcc about      them being clobbered by vfork.  */
specifier|volatile
name|int
name|sleep_interval
decl_stmt|;
specifier|volatile
name|int
name|retries
decl_stmt|;
name|sleep_interval
operator|=
literal|1
expr_stmt|;
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|retries
operator|=
literal|0
init|;
name|retries
operator|<
literal|4
condition|;
operator|++
name|retries
control|)
block|{
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|>=
literal|0
condition|)
break|break;
name|sleep
argument_list|(
name|sleep_interval
argument_list|)
expr_stmt|;
name|sleep_interval
operator|*=
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
name|VFORK_STRING
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* Child process.  */
if|if
condition|(
name|in
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|in
argument_list|,
name|STDIN_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"dup2"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|in
argument_list|)
operator|<
literal|0
condition|)
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"close"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|out
argument_list|,
name|STDOUT_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"dup2"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|out
argument_list|)
operator|<
literal|0
condition|)
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"close"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errdes
operator|!=
name|STDERR_FILE_NO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|errdes
argument_list|,
name|STDERR_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"dup2"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|errdes
argument_list|)
operator|<
literal|0
condition|)
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"close"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toclose
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|toclose
argument_list|)
operator|<
literal|0
condition|)
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"close"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|PEX_STDERR_TO_STDOUT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|STDOUT_FILE_NO
argument_list|,
name|STDERR_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"dup2"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|env
condition|)
name|environ
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|env
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PEX_SEARCH
operator|)
operator|!=
literal|0
condition|)
block|{
name|execvp
argument_list|(
name|executable
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"execvp"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execv
argument_list|(
name|executable
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|pex_child_error
argument_list|(
name|obj
argument_list|,
name|executable
argument_list|,
literal|"execv"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
return|return
operator|-
literal|1
return|;
default|default:
comment|/* Parent process.  */
if|if
condition|(
name|in
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|in
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"close"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|out
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|out
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"close"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|errdes
operator|!=
name|STDERR_FILE_NO
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|errdes
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"close"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
operator|(
name|long
operator|)
name|pid
return|;
block|}
block|}
end_function

begin_comment
comment|/* Wait for a child process to complete.  */
end_comment

begin_function
specifier|static
name|int
name|pex_unix_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|long
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|struct
name|pex_time
modifier|*
name|time
parameter_list|,
name|int
name|done
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
comment|/* If we are cleaning up when the caller didn't retrieve process      status for some reason, encourage the process to go away.  */
if|if
condition|(
name|done
condition|)
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pex_wait
argument_list|(
name|obj
argument_list|,
name|pid
argument_list|,
name|status
argument_list|,
name|time
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"wait"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create a pipe.  */
end_comment

begin_function
specifier|static
name|int
name|pex_unix_pipe
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|p
parameter_list|,
name|int
name|binary
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|pipe
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a FILE pointer to read from a file descriptor.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|pex_unix_fdopenr
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|binary
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|pex_unix_fdopenw
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|binary
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pex_unix_cleanup
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_WAIT4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_WAITPID
argument_list|)
while|while
condition|(
name|obj
operator|->
name|sysdep
operator|!=
name|NULL
condition|)
block|{
name|struct
name|status_list
modifier|*
name|this
decl_stmt|;
name|struct
name|status_list
modifier|*
name|next
decl_stmt|;
name|this
operator|=
operator|(
expr|struct
name|status_list
operator|*
operator|)
name|obj
operator|->
name|sysdep
expr_stmt|;
name|next
operator|=
name|this
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|obj
operator|->
name|sysdep
operator|=
operator|(
name|void
operator|*
operator|)
name|next
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

