begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Common code for executing a program in a sub-process.    Copyright (C) 2005 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@airs.com>.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"pex-common.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_ERRNO
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|mkstemps
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This file contains subroutines for the program execution routines    (pex_init, pex_run, etc.).  This file is compiled on all    systems.  */
end_comment

begin_function_decl
specifier|static
name|void
name|pex_add_remove
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_get_status_and_time
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initialize a pex_obj structure.  */
end_comment

begin_function
name|struct
name|pex_obj
modifier|*
name|pex_init_common
parameter_list|(
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|char
modifier|*
name|tempbase
parameter_list|,
specifier|const
name|struct
name|pex_funcs
modifier|*
name|funcs
parameter_list|)
block|{
name|struct
name|pex_obj
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|XNEW
argument_list|(
expr|struct
name|pex_obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|obj
operator|->
name|pname
operator|=
name|pname
expr_stmt|;
name|obj
operator|->
name|tempbase
operator|=
name|tempbase
expr_stmt|;
name|obj
operator|->
name|next_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
name|obj
operator|->
name|next_input_name
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|next_input_name_allocated
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|stderr_pipe
operator|=
operator|-
literal|1
expr_stmt|;
name|obj
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|children
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|status
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|time
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|number_waited
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|input_file
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|read_output
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|read_err
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|remove_count
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|remove
operator|=
name|NULL
expr_stmt|;
name|obj
operator|->
name|funcs
operator|=
name|funcs
expr_stmt|;
name|obj
operator|->
name|sysdep
operator|=
name|NULL
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function

begin_comment
comment|/* Add a file to be removed when we are done.  */
end_comment

begin_function
specifier|static
name|void
name|pex_add_remove
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|allocated
parameter_list|)
block|{
name|char
modifier|*
name|add
decl_stmt|;
operator|++
name|obj
operator|->
name|remove_count
expr_stmt|;
name|obj
operator|->
name|remove
operator|=
name|XRESIZEVEC
argument_list|(
name|char
operator|*
argument_list|,
name|obj
operator|->
name|remove
argument_list|,
name|obj
operator|->
name|remove_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated
condition|)
name|add
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
else|else
name|add
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|obj
operator|->
name|remove
index|[
name|obj
operator|->
name|remove_count
operator|-
literal|1
index|]
operator|=
name|add
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a temporary file name based on OBJ, FLAGS, and NAME.    Return NULL if we were unable to reserve a temporary filename.     If non-NULL, the result is either allocated with malloc, or the    same pointer as NAME.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|temp_file
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|tempbase
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|make_temp_file
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|obj
operator|->
name|tempbase
argument_list|)
decl_stmt|;
name|int
name|out
decl_stmt|;
if|if
condition|(
name|len
operator|>=
literal|6
operator|&&
name|strcmp
argument_list|(
name|obj
operator|->
name|tempbase
operator|+
name|len
operator|-
literal|6
argument_list|,
literal|"XXXXXX"
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
name|xstrdup
argument_list|(
name|obj
operator|->
name|tempbase
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|concat
argument_list|(
name|obj
operator|->
name|tempbase
argument_list|,
literal|"XXXXXX"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
operator|=
name|mkstemps
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* This isn't obj->funcs->close because we got the              descriptor from mkstemps, not from a function in              obj->funcs.  Calling close here is just like what              make_temp_file does.  */
name|close
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|PEX_SUFFIX
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|tempbase
operator|==
name|NULL
condition|)
name|name
operator|=
name|make_temp_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|concat
argument_list|(
name|obj
operator|->
name|tempbase
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* As for pex_run (), but permits the environment for the child process    to be specified. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pex_run_in_environment
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|executable
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
specifier|const
name|char
modifier|*
name|orig_outname
parameter_list|,
specifier|const
name|char
modifier|*
name|errname
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|errdes
decl_stmt|;
name|char
modifier|*
name|outname
decl_stmt|;
name|int
name|outname_allocated
decl_stmt|;
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
name|int
name|toclose
decl_stmt|;
name|long
name|pid
decl_stmt|;
name|in
operator|=
operator|-
literal|1
expr_stmt|;
name|out
operator|=
operator|-
literal|1
expr_stmt|;
name|errdes
operator|=
operator|-
literal|1
expr_stmt|;
name|outname
operator|=
operator|(
name|char
operator|*
operator|)
name|orig_outname
expr_stmt|;
name|outname_allocated
operator|=
literal|0
expr_stmt|;
comment|/* If the user called pex_input_file, close the file now.  */
if|if
condition|(
name|obj
operator|->
name|input_file
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|obj
operator|->
name|input_file
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|errmsg
operator|=
literal|"closing pipeline input file"
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|obj
operator|->
name|input_file
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Set IN.  */
if|if
condition|(
name|obj
operator|->
name|next_input_name
operator|!=
name|NULL
condition|)
block|{
comment|/* We have to make sure that the previous process has completed 	 before we try to read the file.  */
if|if
condition|(
operator|!
name|pex_get_status_and_time
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
operator|&
name|errmsg
argument_list|,
name|err
argument_list|)
condition|)
goto|goto
name|error_exit
goto|;
name|in
operator|=
name|obj
operator|->
name|funcs
operator|->
name|open_read
argument_list|(
name|obj
argument_list|,
name|obj
operator|->
name|next_input_name
argument_list|,
operator|(
name|flags
operator|&
name|PEX_BINARY_INPUT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
name|errmsg
operator|=
literal|"open temporary file"
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|next_input_name_allocated
condition|)
block|{
name|free
argument_list|(
name|obj
operator|->
name|next_input_name
argument_list|)
expr_stmt|;
name|obj
operator|->
name|next_input_name_allocated
operator|=
literal|0
expr_stmt|;
block|}
name|obj
operator|->
name|next_input_name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
name|obj
operator|->
name|next_input
expr_stmt|;
if|if
condition|(
name|in
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
literal|0
expr_stmt|;
name|errmsg
operator|=
literal|"pipeline already complete"
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
comment|/* Set OUT and OBJ->NEXT_INPUT/OBJ->NEXT_INPUT_NAME.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|PEX_LAST
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|outname
operator|==
name|NULL
condition|)
name|out
operator|=
name|STDOUT_FILE_NO
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|PEX_SUFFIX
operator|)
operator|!=
literal|0
condition|)
block|{
name|outname
operator|=
name|concat
argument_list|(
name|obj
operator|->
name|tempbase
argument_list|,
name|outname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|outname_allocated
operator|=
literal|1
expr_stmt|;
block|}
name|obj
operator|->
name|next_input
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|obj
operator|->
name|flags
operator|&
name|PEX_USE_PIPES
operator|)
operator|==
literal|0
condition|)
block|{
name|outname
operator|=
name|temp_file
argument_list|(
name|obj
argument_list|,
name|flags
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outname
condition|)
block|{
operator|*
name|err
operator|=
literal|0
expr_stmt|;
name|errmsg
operator|=
literal|"could not create temporary file"
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|outname
operator|!=
name|orig_outname
condition|)
name|outname_allocated
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|flags
operator|&
name|PEX_SAVE_TEMPS
operator|)
operator|==
literal|0
condition|)
block|{
name|pex_add_remove
argument_list|(
name|obj
argument_list|,
name|outname
argument_list|,
name|outname_allocated
argument_list|)
expr_stmt|;
name|outname_allocated
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Hand off ownership of outname to the next stage.  */
name|obj
operator|->
name|next_input_name
operator|=
name|outname
expr_stmt|;
name|obj
operator|->
name|next_input_name_allocated
operator|=
name|outname_allocated
expr_stmt|;
name|outname_allocated
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|obj
operator|->
name|funcs
operator|->
name|pipe
argument_list|(
name|obj
argument_list|,
name|p
argument_list|,
operator|(
name|flags
operator|&
name|PEX_BINARY_OUTPUT
operator|)
operator|!=
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
name|errmsg
operator|=
literal|"pipe"
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|out
operator|=
name|p
index|[
name|WRITE_PORT
index|]
expr_stmt|;
name|obj
operator|->
name|next_input
operator|=
name|p
index|[
name|READ_PORT
index|]
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|<
literal|0
condition|)
block|{
name|out
operator|=
name|obj
operator|->
name|funcs
operator|->
name|open_write
argument_list|(
name|obj
argument_list|,
name|outname
argument_list|,
operator|(
name|flags
operator|&
name|PEX_BINARY_OUTPUT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
name|errmsg
operator|=
literal|"open temporary output file"
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
if|if
condition|(
name|outname_allocated
condition|)
block|{
name|free
argument_list|(
name|outname
argument_list|)
expr_stmt|;
name|outname_allocated
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set ERRDES.  */
if|if
condition|(
name|errname
operator|!=
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|PEX_STDERR_TO_PIPE
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|err
operator|=
literal|0
expr_stmt|;
name|errmsg
operator|=
literal|"both ERRNAME and PEX_STDERR_TO_PIPE specified."
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|obj
operator|->
name|stderr_pipe
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|err
operator|=
literal|0
expr_stmt|;
name|errmsg
operator|=
literal|"PEX_STDERR_TO_PIPE used in the middle of pipeline"
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|errname
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PEX_STDERR_TO_PIPE
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|funcs
operator|->
name|pipe
argument_list|(
name|obj
argument_list|,
name|p
argument_list|,
operator|(
name|flags
operator|&
name|PEX_BINARY_ERROR
operator|)
operator|!=
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
name|errmsg
operator|=
literal|"pipe"
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|errdes
operator|=
name|p
index|[
name|WRITE_PORT
index|]
expr_stmt|;
name|obj
operator|->
name|stderr_pipe
operator|=
name|p
index|[
name|READ_PORT
index|]
expr_stmt|;
block|}
else|else
block|{
name|errdes
operator|=
name|STDERR_FILE_NO
expr_stmt|;
block|}
block|}
else|else
block|{
name|errdes
operator|=
name|obj
operator|->
name|funcs
operator|->
name|open_write
argument_list|(
name|obj
argument_list|,
name|errname
argument_list|,
operator|(
name|flags
operator|&
name|PEX_BINARY_ERROR
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errdes
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
name|errmsg
operator|=
literal|"open error file"
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
comment|/* If we are using pipes, the child process has to close the next      input pipe.  */
if|if
condition|(
operator|(
name|obj
operator|->
name|flags
operator|&
name|PEX_USE_PIPES
operator|)
operator|==
literal|0
condition|)
name|toclose
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|toclose
operator|=
name|obj
operator|->
name|next_input
expr_stmt|;
comment|/* Run the program.  */
name|pid
operator|=
name|obj
operator|->
name|funcs
operator|->
name|exec_child
argument_list|(
name|obj
argument_list|,
name|flags
argument_list|,
name|executable
argument_list|,
name|argv
argument_list|,
name|env
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|errdes
argument_list|,
name|toclose
argument_list|,
operator|&
name|errmsg
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
goto|goto
name|error_exit
goto|;
operator|++
name|obj
operator|->
name|count
expr_stmt|;
name|obj
operator|->
name|children
operator|=
name|XRESIZEVEC
argument_list|(
name|long
argument_list|,
name|obj
operator|->
name|children
argument_list|,
name|obj
operator|->
name|count
argument_list|)
expr_stmt|;
name|obj
operator|->
name|children
index|[
name|obj
operator|->
name|count
operator|-
literal|1
index|]
operator|=
name|pid
expr_stmt|;
return|return
name|NULL
return|;
name|error_exit
label|:
if|if
condition|(
name|in
operator|>=
literal|0
operator|&&
name|in
operator|!=
name|STDIN_FILE_NO
condition|)
name|obj
operator|->
name|funcs
operator|->
name|close
argument_list|(
name|obj
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|>=
literal|0
operator|&&
name|out
operator|!=
name|STDOUT_FILE_NO
condition|)
name|obj
operator|->
name|funcs
operator|->
name|close
argument_list|(
name|obj
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|errdes
operator|>=
literal|0
operator|&&
name|errdes
operator|!=
name|STDERR_FILE_NO
condition|)
name|obj
operator|->
name|funcs
operator|->
name|close
argument_list|(
name|obj
argument_list|,
name|errdes
argument_list|)
expr_stmt|;
if|if
condition|(
name|outname_allocated
condition|)
name|free
argument_list|(
name|outname
argument_list|)
expr_stmt|;
return|return
name|errmsg
return|;
block|}
end_function

begin_comment
comment|/* Run a program.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pex_run
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|executable
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|orig_outname
parameter_list|,
specifier|const
name|char
modifier|*
name|errname
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
return|return
name|pex_run_in_environment
argument_list|(
name|obj
argument_list|,
name|flags
argument_list|,
name|executable
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
name|orig_outname
argument_list|,
name|errname
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a FILE pointer for a temporary file to fill with input for    the pipeline.  */
end_comment

begin_function
name|FILE
modifier|*
name|pex_input_file
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|in_name
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|in_name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* This must be called before the first pipeline stage is run, and      there must not have been any other input selected.  */
if|if
condition|(
name|obj
operator|->
name|count
operator|!=
literal|0
operator|||
operator|(
name|obj
operator|->
name|next_input
operator|>=
literal|0
operator|&&
name|obj
operator|->
name|next_input
operator|!=
name|STDIN_FILE_NO
operator|)
operator|||
name|obj
operator|->
name|next_input_name
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|name
operator|=
name|temp_file
argument_list|(
name|obj
argument_list|,
name|flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULL
return|;
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
operator|(
name|flags
operator|&
name|PEX_BINARY_OUTPUT
operator|)
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|obj
operator|->
name|input_file
operator|=
name|f
expr_stmt|;
name|obj
operator|->
name|next_input_name
operator|=
name|name
expr_stmt|;
name|obj
operator|->
name|next_input_name_allocated
operator|=
operator|(
name|name
operator|!=
name|in_name
operator|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Return a stream for a pipe connected to the standard input of the    first stage of the pipeline.  */
end_comment

begin_function
name|FILE
modifier|*
name|pex_input_pipe
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* You must call pex_input_pipe before the first pex_run or pex_one.  */
if|if
condition|(
name|obj
operator|->
name|count
operator|>
literal|0
condition|)
goto|goto
name|usage_error
goto|;
comment|/* You must be using pipes.  Implementations that don't support      pipes clear this flag before calling pex_init_common.  */
if|if
condition|(
operator|!
operator|(
name|obj
operator|->
name|flags
operator|&
name|PEX_USE_PIPES
operator|)
condition|)
goto|goto
name|usage_error
goto|;
comment|/* If we have somehow already selected other input, that's a      mistake.  */
if|if
condition|(
operator|(
name|obj
operator|->
name|next_input
operator|>=
literal|0
operator|&&
name|obj
operator|->
name|next_input
operator|!=
name|STDIN_FILE_NO
operator|)
operator|||
name|obj
operator|->
name|next_input_name
condition|)
goto|goto
name|usage_error
goto|;
if|if
condition|(
name|obj
operator|->
name|funcs
operator|->
name|pipe
argument_list|(
name|obj
argument_list|,
name|p
argument_list|,
name|binary
operator|!=
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|f
operator|=
name|obj
operator|->
name|funcs
operator|->
name|fdopenw
argument_list|(
name|obj
argument_list|,
name|p
index|[
name|WRITE_PORT
index|]
argument_list|,
name|binary
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|obj
operator|->
name|funcs
operator|->
name|close
argument_list|(
name|obj
argument_list|,
name|p
index|[
name|READ_PORT
index|]
argument_list|)
expr_stmt|;
name|obj
operator|->
name|funcs
operator|->
name|close
argument_list|(
name|obj
argument_list|,
name|p
index|[
name|WRITE_PORT
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|obj
operator|->
name|next_input
operator|=
name|p
index|[
name|READ_PORT
index|]
expr_stmt|;
return|return
name|f
return|;
name|usage_error
label|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a FILE pointer for the output of the last program    executed.  */
end_comment

begin_function
name|FILE
modifier|*
name|pex_read_output
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|next_input_name
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* We have to make sure that the process has completed before we 	 try to read the file.  */
if|if
condition|(
operator|!
name|pex_get_status_and_time
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
operator|&
name|errmsg
argument_list|,
operator|&
name|err
argument_list|)
condition|)
block|{
name|errno
operator|=
name|err
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|obj
operator|->
name|read_output
operator|=
name|fopen
argument_list|(
name|obj
operator|->
name|next_input_name
argument_list|,
name|binary
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|next_input_name_allocated
condition|)
block|{
name|free
argument_list|(
name|obj
operator|->
name|next_input_name
argument_list|)
expr_stmt|;
name|obj
operator|->
name|next_input_name_allocated
operator|=
literal|0
expr_stmt|;
block|}
name|obj
operator|->
name|next_input_name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|o
decl_stmt|;
name|o
operator|=
name|obj
operator|->
name|next_input
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
operator|||
name|o
operator|==
name|STDIN_FILE_NO
condition|)
return|return
name|NULL
return|;
name|obj
operator|->
name|read_output
operator|=
name|obj
operator|->
name|funcs
operator|->
name|fdopenr
argument_list|(
name|obj
argument_list|,
name|o
argument_list|,
name|binary
argument_list|)
expr_stmt|;
name|obj
operator|->
name|next_input
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|obj
operator|->
name|read_output
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|pex_read_err
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
name|int
name|o
decl_stmt|;
name|o
operator|=
name|obj
operator|->
name|stderr_pipe
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
operator|||
name|o
operator|==
name|STDIN_FILE_NO
condition|)
return|return
name|NULL
return|;
name|obj
operator|->
name|read_err
operator|=
name|obj
operator|->
name|funcs
operator|->
name|fdopenr
argument_list|(
name|obj
argument_list|,
name|o
argument_list|,
name|binary
argument_list|)
expr_stmt|;
return|return
name|obj
operator|->
name|read_err
return|;
block|}
end_function

begin_comment
comment|/* Get the exit status and, if requested, the resource time for all    the child processes.  Return 0 on failure, 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|pex_get_status_and_time
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|done
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|number_waited
operator|==
name|obj
operator|->
name|count
condition|)
return|return
literal|1
return|;
name|obj
operator|->
name|status
operator|=
name|XRESIZEVEC
argument_list|(
name|int
argument_list|,
name|obj
operator|->
name|status
argument_list|,
name|obj
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|flags
operator|&
name|PEX_RECORD_TIMES
operator|)
operator|!=
literal|0
condition|)
name|obj
operator|->
name|time
operator|=
name|XRESIZEVEC
argument_list|(
expr|struct
name|pex_time
argument_list|,
name|obj
operator|->
name|time
argument_list|,
name|obj
operator|->
name|count
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|obj
operator|->
name|number_waited
init|;
name|i
operator|<
name|obj
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|obj
operator|->
name|funcs
operator|->
name|wait
argument_list|(
name|obj
argument_list|,
name|obj
operator|->
name|children
index|[
name|i
index|]
argument_list|,
operator|&
name|obj
operator|->
name|status
index|[
name|i
index|]
argument_list|,
name|obj
operator|->
name|time
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|obj
operator|->
name|time
index|[
name|i
index|]
argument_list|,
name|done
argument_list|,
name|errmsg
argument_list|,
name|err
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|obj
operator|->
name|number_waited
operator|=
name|i
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get exit status of executed programs.  */
end_comment

begin_function
name|int
name|pex_get_status
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|vector
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|status
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|pex_get_status_and_time
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
operator|&
name|errmsg
argument_list|,
operator|&
name|err
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|count
operator|>
name|obj
operator|->
name|count
condition|)
block|{
name|memset
argument_list|(
name|vector
operator|+
name|obj
operator|->
name|count
argument_list|,
literal|0
argument_list|,
operator|(
name|count
operator|-
name|obj
operator|->
name|count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|obj
operator|->
name|count
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|vector
argument_list|,
name|obj
operator|->
name|status
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get process times of executed programs.  */
end_comment

begin_function
name|int
name|pex_get_times
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|count
parameter_list|,
name|struct
name|pex_time
modifier|*
name|vector
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|status
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|pex_get_status_and_time
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
operator|&
name|errmsg
argument_list|,
operator|&
name|err
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|time
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|count
operator|>
name|obj
operator|->
name|count
condition|)
block|{
name|memset
argument_list|(
name|vector
operator|+
name|obj
operator|->
name|count
argument_list|,
literal|0
argument_list|,
operator|(
name|count
operator|-
name|obj
operator|->
name|count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pex_time
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|obj
operator|->
name|count
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|vector
argument_list|,
name|obj
operator|->
name|time
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pex_time
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Free a pex_obj structure.  */
end_comment

begin_function
name|void
name|pex_free
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|next_input
operator|>=
literal|0
operator|&&
name|obj
operator|->
name|next_input
operator|!=
name|STDIN_FILE_NO
condition|)
name|obj
operator|->
name|funcs
operator|->
name|close
argument_list|(
name|obj
argument_list|,
name|obj
operator|->
name|next_input
argument_list|)
expr_stmt|;
comment|/* If the caller forgot to wait for the children, we do it here, to      avoid zombies.  */
if|if
condition|(
name|obj
operator|->
name|status
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|obj
operator|->
name|flags
operator|&=
operator|~
name|PEX_RECORD_TIMES
expr_stmt|;
name|pex_get_status_and_time
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|,
operator|&
name|errmsg
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|next_input_name_allocated
condition|)
name|free
argument_list|(
name|obj
operator|->
name|next_input_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|children
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|obj
operator|->
name|children
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|status
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|obj
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|time
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|obj
operator|->
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|read_output
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|obj
operator|->
name|read_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|read_err
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|obj
operator|->
name|read_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|remove_count
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|obj
operator|->
name|remove_count
condition|;
operator|++
name|i
control|)
block|{
name|remove
argument_list|(
name|obj
operator|->
name|remove
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj
operator|->
name|remove
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|obj
operator|->
name|remove
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|funcs
operator|->
name|cleanup
operator|!=
name|NULL
condition|)
name|obj
operator|->
name|funcs
operator|->
name|cleanup
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

