begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities to execute a program in a subprocess (possibly linked by pipes    with other subprocesses), and wait for it.  Generic Win32 specialization.    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"pex-common.h"
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* mingw32 headers may not define the following.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_P_WAIT
end_ifndef

begin_define
define|#
directive|define
name|_P_WAIT
value|0
end_define

begin_define
define|#
directive|define
name|_P_NOWAIT
value|1
end_define

begin_define
define|#
directive|define
name|_P_OVERLAY
value|2
end_define

begin_define
define|#
directive|define
name|_P_NOWAITO
value|3
end_define

begin_define
define|#
directive|define
name|_P_DETACH
value|4
end_define

begin_define
define|#
directive|define
name|WAIT_CHILD
value|0
end_define

begin_define
define|#
directive|define
name|WAIT_GRANDCHILD
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MINGW_NAME
value|"Minimalist GNU for Windows"
end_define

begin_define
define|#
directive|define
name|MINGW_NAME_LEN
value|(sizeof(MINGW_NAME) - 1)
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|stpcpy
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Ensure that the executable pathname uses Win32 backslashes. This    is not necessary on NT, but on W9x, forward slashes causes    failure of spawn* and exec* functions (and probably any function    that calls CreateProcess) *iff* the executable pathname (argv[0])    is a quoted string.  And quoting is necessary in case a pathname    contains embedded white space.  You can't win.  */
end_comment

begin_function
specifier|static
name|void
name|backslashify
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|'\\'
expr_stmt|;
return|return;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|pex_win32_open_read
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_win32_open_write
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|pex_win32_exec_child
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_win32_close
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_win32_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|pex_time
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_win32_pipe
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|pex_win32_fdopenr
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|pex_win32_fdopenw
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The list of functions we pass to the common routines.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|pex_funcs
name|funcs
init|=
block|{
name|pex_win32_open_read
block|,
name|pex_win32_open_write
block|,
name|pex_win32_exec_child
block|,
name|pex_win32_close
block|,
name|pex_win32_wait
block|,
name|pex_win32_pipe
block|,
name|pex_win32_fdopenr
block|,
name|pex_win32_fdopenw
block|,
name|NULL
comment|/* cleanup */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a newly initialized pex_obj structure.  */
end_comment

begin_function
name|struct
name|pex_obj
modifier|*
name|pex_init
parameter_list|(
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|char
modifier|*
name|tempbase
parameter_list|)
block|{
return|return
name|pex_init_common
argument_list|(
name|flags
argument_list|,
name|pname
argument_list|,
name|tempbase
argument_list|,
operator|&
name|funcs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open a file for reading.  */
end_comment

begin_function
specifier|static
name|int
name|pex_win32_open_read
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
return|return
name|_open
argument_list|(
name|name
argument_list|,
name|_O_RDONLY
operator||
operator|(
name|binary
condition|?
name|_O_BINARY
else|:
name|_O_TEXT
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open a file for writing.  */
end_comment

begin_function
specifier|static
name|int
name|pex_win32_open_write
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
comment|/* Note that we can't use O_EXCL here because gcc may have already      created the temporary file via make_temp_file.  */
return|return
name|_open
argument_list|(
name|name
argument_list|,
operator|(
name|_O_WRONLY
operator||
name|_O_CREAT
operator||
name|_O_TRUNC
operator||
operator|(
name|binary
condition|?
name|_O_BINARY
else|:
name|_O_TEXT
operator|)
operator|)
argument_list|,
name|_S_IREAD
operator||
name|_S_IWRITE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close a file.  */
end_comment

begin_function
specifier|static
name|int
name|pex_win32_close
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
return|return
name|_close
argument_list|(
name|fd
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MINGW_MSYS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mingw_keys
index|[]
init|=
block|{
literal|"SOFTWARE"
block|,
literal|"Microsoft"
block|,
literal|"Windows"
block|,
literal|"CurrentVersion"
block|,
literal|"Uninstall"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tack the executable on the end of a (possibly slash terminated) buffer    and convert everything to \. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tack_on_executable
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|executable
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|>
name|buf
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|backslashify
argument_list|(
name|strcat
argument_list|(
name|buf
argument_list|,
name|executable
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Walk down a registry hierarchy until the end.  Return the key. */
end_comment

begin_function
specifier|static
name|HKEY
name|openkey
parameter_list|(
name|HKEY
name|hStart
parameter_list|,
specifier|const
name|char
modifier|*
name|keys
index|[]
parameter_list|)
block|{
name|HKEY
name|hKey
decl_stmt|,
name|hTmp
decl_stmt|;
for|for
control|(
name|hKey
operator|=
name|hStart
init|;
operator|*
name|keys
condition|;
name|keys
operator|++
control|)
block|{
name|LONG
name|res
decl_stmt|;
name|hTmp
operator|=
name|hKey
expr_stmt|;
name|res
operator|=
name|RegOpenKey
argument_list|(
name|hTmp
argument_list|,
operator|*
name|keys
argument_list|,
operator|&
name|hKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|hTmp
operator|!=
name|HKEY_LOCAL_MACHINE
condition|)
name|RegCloseKey
argument_list|(
name|hTmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|hKey
return|;
block|}
end_function

begin_comment
comment|/* Return the "mingw root" as derived from the mingw uninstall information. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mingw_rootify
parameter_list|(
specifier|const
name|char
modifier|*
name|executable
parameter_list|)
block|{
name|HKEY
name|hKey
decl_stmt|,
name|hTmp
decl_stmt|;
name|DWORD
name|maxlen
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|,
modifier|*
name|foundbuf
decl_stmt|;
name|DWORD
name|i
decl_stmt|;
name|LONG
name|res
decl_stmt|;
comment|/* Open the uninstall "directory". */
name|hKey
operator|=
name|openkey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|mingw_keys
argument_list|)
expr_stmt|;
comment|/* Not found. */
if|if
condition|(
operator|!
name|hKey
condition|)
return|return
name|executable
return|;
comment|/* Need to enumerate all of the keys here looking for one the most recent      one for MinGW. */
if|if
condition|(
name|RegQueryInfoKey
argument_list|(
name|hKey
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|maxlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|RegCloseKey
argument_list|(
name|hKey
argument_list|)
expr_stmt|;
return|return
name|executable
return|;
block|}
name|namebuf
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
operator|++
name|maxlen
argument_list|)
expr_stmt|;
name|foundbuf
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|foundbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|namebuf
operator|||
operator|!
name|foundbuf
condition|)
block|{
name|RegCloseKey
argument_list|(
name|hKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|namebuf
condition|)
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundbuf
condition|)
name|free
argument_list|(
name|foundbuf
argument_list|)
expr_stmt|;
return|return
name|executable
return|;
block|}
comment|/* Look through all of the keys for one that begins with Minimal GNU...      Try to get the latest version by doing a string compare although that      string never really works with version number sorting. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|RegEnumKey
argument_list|(
name|hKey
argument_list|,
name|i
argument_list|,
name|namebuf
argument_list|,
name|maxlen
argument_list|)
operator|==
name|ERROR_SUCCESS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|match
init|=
name|strcasecmp
argument_list|(
name|namebuf
argument_list|,
name|MINGW_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|match
operator|>
literal|0
operator|&&
name|strncasecmp
argument_list|(
name|namebuf
argument_list|,
name|MINGW_NAME
argument_list|,
name|MINGW_NAME_LEN
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcasecmp
argument_list|(
name|namebuf
argument_list|,
name|foundbuf
argument_list|)
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
name|foundbuf
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
comment|/* If foundbuf is empty, we didn't find anything.  Punt. */
if|if
condition|(
operator|!
name|foundbuf
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|foundbuf
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|hKey
argument_list|)
expr_stmt|;
return|return
name|executable
return|;
block|}
comment|/* Open the key that we wanted */
name|res
operator|=
name|RegOpenKey
argument_list|(
name|hKey
argument_list|,
name|foundbuf
argument_list|,
operator|&
name|hTmp
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|hKey
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|foundbuf
argument_list|)
expr_stmt|;
comment|/* Don't know why this would fail, but you gotta check */
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
return|return
name|executable
return|;
name|maxlen
operator|=
literal|0
expr_stmt|;
comment|/* Get the length of the value pointed to by InstallLocation */
if|if
condition|(
name|RegQueryValueEx
argument_list|(
name|hTmp
argument_list|,
literal|"InstallLocation"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|maxlen
argument_list|)
operator|!=
name|ERROR_SUCCESS
operator|||
name|maxlen
operator|==
literal|0
condition|)
block|{
name|RegCloseKey
argument_list|(
name|hTmp
argument_list|)
expr_stmt|;
return|return
name|executable
return|;
block|}
comment|/* Allocate space for the install location */
name|foundbuf
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|maxlen
operator|+
name|strlen
argument_list|(
name|executable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundbuf
condition|)
block|{
name|free
argument_list|(
name|foundbuf
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|hTmp
argument_list|)
expr_stmt|;
block|}
comment|/* Read the install location into the buffer */
name|res
operator|=
name|RegQueryValueEx
argument_list|(
name|hTmp
argument_list|,
literal|"InstallLocation"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|LPBYTE
operator|)
name|foundbuf
argument_list|,
operator|&
name|maxlen
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|hTmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|foundbuf
argument_list|)
expr_stmt|;
return|return
name|executable
return|;
block|}
comment|/* Concatenate the install location and the executable, turn all slashes      to backslashes, and return that. */
return|return
name|tack_on_executable
argument_list|(
name|foundbuf
argument_list|,
name|executable
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the install location of msys from it's installation file and    rootify the executable based on that. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|msys_rootify
parameter_list|(
specifier|const
name|char
modifier|*
name|executable
parameter_list|)
block|{
name|size_t
name|bufsize
init|=
literal|64
decl_stmt|;
name|size_t
name|execlen
init|=
name|strlen
argument_list|(
name|executable
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|DWORD
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|buf
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|bufsize
operator|+
name|execlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
break|break;
name|res
operator|=
name|GetPrivateProfileString
argument_list|(
literal|"InstallSettings"
argument_list|,
literal|"InstallPath"
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"msys.ini"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|<
name|bufsize
condition|)
break|break;
name|res
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bufsize
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
literal|65536
condition|)
block|{
name|buf
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|res
condition|)
return|return
name|tack_on_executable
argument_list|(
name|buf
argument_list|,
name|executable
argument_list|)
return|;
comment|/* failed */
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|executable
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a Windows command-line from ARGV.  It is the caller's    responsibility to free the string returned.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|argv_to_cmdline
parameter_list|(
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|cmdline
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|cmdline_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|cmdline_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* We quote every last argument.  This simplifies the problem; 	 we need only escape embedded double-quotes and immediately 	 preceeding backslash characters.  A sequence of backslach characters 	 that is not follwed by a double quote character will not be 	 escaped.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|'"'
condition|)
block|{
comment|/* Escape preceeding backslashes.  */
for|for
control|(
name|k
operator|=
name|j
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
operator|&&
name|argv
index|[
name|i
index|]
index|[
name|k
index|]
operator|==
literal|'\\'
condition|;
name|k
operator|--
control|)
name|cmdline_len
operator|++
expr_stmt|;
comment|/* Escape the qote character.  */
name|cmdline_len
operator|++
expr_stmt|;
block|}
block|}
comment|/* Trailing backslashes also need to be escaped because they will be          followed by the terminating quote.  */
for|for
control|(
name|k
operator|=
name|j
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
operator|&&
name|argv
index|[
name|i
index|]
index|[
name|k
index|]
operator|==
literal|'\\'
condition|;
name|k
operator|--
control|)
name|cmdline_len
operator|++
expr_stmt|;
name|cmdline_len
operator|+=
name|j
expr_stmt|;
name|cmdline_len
operator|+=
literal|3
expr_stmt|;
comment|/* for leading and trailing quotes and space */
block|}
name|cmdline
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|cmdline_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|cmdline
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|k
operator|=
name|j
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
operator|&&
name|argv
index|[
name|i
index|]
index|[
name|k
index|]
operator|==
literal|'\\'
condition|;
name|k
operator|--
control|)
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|j
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
operator|&&
name|argv
index|[
name|i
index|]
index|[
name|k
index|]
operator|==
literal|'\\'
condition|;
name|k
operator|--
control|)
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|cmdline
return|;
block|}
end_function

begin_comment
comment|/* We'll try the passed filename with all the known standard    extensions, and then without extension.  We try no extension    last so that we don't try to run some random extension-less    file that might be hanging around.  We try both extension    and no extension so that we don't need any fancy logic    to determine if a file has extension.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|std_suffixes
index|[]
init|=
block|{
literal|".com"
block|,
literal|".exe"
block|,
literal|".bat"
block|,
literal|".cmd"
block|,
literal|""
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns the full path to PROGRAM.  If SEARCH is true, look for    PROGRAM in each directory in PATH.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_executable
parameter_list|(
specifier|const
name|char
modifier|*
name|program
parameter_list|,
name|BOOL
name|search
parameter_list|)
block|{
name|char
modifier|*
name|full_executable
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|size_t
name|fe_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|size_t
name|proglen
init|=
name|strlen
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|int
name|has_slash
init|=
operator|(
name|strchr
argument_list|(
name|program
argument_list|,
literal|'/'
argument_list|)
operator|||
name|strchr
argument_list|(
name|program
argument_list|,
literal|'\\'
argument_list|)
operator|)
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
if|if
condition|(
name|has_slash
condition|)
name|search
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|search
condition|)
name|path
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
literal|""
expr_stmt|;
name|fe_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
operator|*
name|p
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|';'
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
operator|>
name|fe_len
condition|)
name|fe_len
operator|=
name|q
operator|-
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|';'
condition|)
name|q
operator|++
expr_stmt|;
block|}
name|fe_len
operator|=
name|fe_len
operator|+
literal|1
operator|+
name|proglen
operator|+
literal|5
comment|/* space for extension */
expr_stmt|;
name|full_executable
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|fe_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
do|do
block|{
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|';'
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
name|q
operator|++
expr_stmt|;
name|e
operator|=
name|full_executable
expr_stmt|;
name|memcpy
argument_list|(
name|e
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|e
operator|+=
operator|(
name|q
operator|-
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|q
operator|-
name|p
condition|)
operator|*
name|e
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|strcpy
argument_list|(
name|e
argument_list|,
name|program
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|';'
condition|)
name|q
operator|++
expr_stmt|;
for|for
control|(
name|e
operator|=
name|full_executable
init|;
operator|*
name|e
condition|;
name|e
operator|++
control|)
if|if
condition|(
operator|*
name|e
operator|==
literal|'/'
condition|)
operator|*
name|e
operator|=
literal|'\\'
expr_stmt|;
comment|/* At this point, e points to the terminating NUL character for          full_executable.  */
for|for
control|(
name|ext
operator|=
name|std_suffixes
init|;
operator|*
name|ext
condition|;
name|ext
operator|++
control|)
block|{
comment|/* Remove any current extension.  */
operator|*
name|e
operator|=
literal|'\0'
expr_stmt|;
comment|/* Add the new one.  */
name|strcat
argument_list|(
name|full_executable
argument_list|,
operator|*
name|ext
argument_list|)
expr_stmt|;
comment|/* Attempt to open this file.  */
name|h
operator|=
name|CreateFile
argument_list|(
name|full_executable
argument_list|,
name|GENERIC_READ
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
literal|0
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
goto|goto
name|found
goto|;
block|}
name|p
operator|=
name|q
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
condition|)
do|;
name|free
argument_list|(
name|full_executable
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|found
label|:
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
name|full_executable
return|;
block|}
end_function

begin_comment
comment|/* Low-level process creation function and helper.  */
end_comment

begin_function
specifier|static
name|int
name|env_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a_ptr
parameter_list|,
specifier|const
name|void
modifier|*
name|b_ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|a
decl_stmt|;
specifier|const
name|char
modifier|*
name|b
decl_stmt|;
name|unsigned
name|char
name|c1
decl_stmt|;
name|unsigned
name|char
name|c2
decl_stmt|;
name|a
operator|=
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|a_ptr
expr_stmt|;
name|b
operator|=
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|b_ptr
expr_stmt|;
comment|/* a and b will be of the form: VAR=VALUE      We compare only the variable name part here using a case-insensitive      comparison algorithm.  It might appear that in fact strcasecmp () can      take the place of this whole function, and indeed it could, save for      the fact that it would fail in cases such as comparing A1=foo and      A=bar (because 1 is less than = in the ASCII character set).      (Environment variables containing no numbers would work in such a      scenario.)  */
do|do
block|{
name|c1
operator|=
operator|(
name|unsigned
name|char
operator|)
name|tolower
argument_list|(
operator|*
name|a
operator|++
argument_list|)
expr_stmt|;
name|c2
operator|=
operator|(
name|unsigned
name|char
operator|)
name|tolower
argument_list|(
operator|*
name|b
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'='
condition|)
name|c1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'='
condition|)
name|c2
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
name|c1
operator|==
name|c2
operator|&&
name|c1
operator|!=
literal|'\0'
condition|)
do|;
return|return
name|c1
operator|-
name|c2
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|win32_spawn
parameter_list|(
specifier|const
name|char
modifier|*
name|executable
parameter_list|,
name|BOOL
name|search
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
comment|/* array of strings of the form: VAR=VALUE */
name|DWORD
name|dwCreationFlags
parameter_list|,
name|LPSTARTUPINFO
name|si
parameter_list|,
name|LPPROCESS_INFORMATION
name|pi
parameter_list|)
block|{
name|char
modifier|*
name|full_executable
decl_stmt|;
name|char
modifier|*
name|cmdline
decl_stmt|;
name|char
modifier|*
modifier|*
name|env_copy
decl_stmt|;
name|char
modifier|*
name|env_block
init|=
name|NULL
decl_stmt|;
name|full_executable
operator|=
name|NULL
expr_stmt|;
name|cmdline
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|env
condition|)
block|{
name|int
name|env_size
decl_stmt|;
comment|/* Count the number of environment bindings supplied.  */
for|for
control|(
name|env_size
operator|=
literal|0
init|;
name|env
index|[
name|env_size
index|]
condition|;
name|env_size
operator|++
control|)
continue|continue;
comment|/* Assemble an environment block, if required.  This consists of          VAR=VALUE strings juxtaposed (with one null character between each          pair) and an additional null at the end.  */
if|if
condition|(
name|env_size
operator|>
literal|0
condition|)
block|{
name|int
name|var
decl_stmt|;
name|int
name|total_size
init|=
literal|1
decl_stmt|;
comment|/* 1 is for the final null.  */
name|char
modifier|*
name|bufptr
decl_stmt|;
comment|/* Windows needs the members of the block to be sorted by variable              name.  */
name|env_copy
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|env_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|env_copy
argument_list|,
name|env
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|env_size
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|env_copy
argument_list|,
name|env_size
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|env_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|var
operator|=
literal|0
init|;
name|var
operator|<
name|env_size
condition|;
name|var
operator|++
control|)
name|total_size
operator|+=
name|strlen
argument_list|(
name|env
index|[
name|var
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|env_block
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|env_block
expr_stmt|;
for|for
control|(
name|var
operator|=
literal|0
init|;
name|var
operator|<
name|env_size
condition|;
name|var
operator|++
control|)
name|bufptr
operator|=
name|stpcpy
argument_list|(
name|bufptr
argument_list|,
name|env_copy
index|[
name|var
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|bufptr
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|full_executable
operator|=
name|find_executable
argument_list|(
name|executable
argument_list|,
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|full_executable
condition|)
goto|goto
name|error
goto|;
name|cmdline
operator|=
name|argv_to_cmdline
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmdline
condition|)
goto|goto
name|error
goto|;
comment|/* Create the child process.  */
if|if
condition|(
operator|!
name|CreateProcess
argument_list|(
name|full_executable
argument_list|,
name|cmdline
argument_list|,
comment|/*lpProcessAttributes=*/
name|NULL
argument_list|,
comment|/*lpThreadAttributes=*/
name|NULL
argument_list|,
comment|/*bInheritHandles=*/
name|TRUE
argument_list|,
name|dwCreationFlags
argument_list|,
operator|(
name|LPVOID
operator|)
name|env_block
argument_list|,
comment|/*lpCurrentDirectory=*/
name|NULL
argument_list|,
name|si
argument_list|,
name|pi
argument_list|)
condition|)
block|{
if|if
condition|(
name|env_block
condition|)
name|free
argument_list|(
name|env_block
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|full_executable
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Clean up.  */
name|CloseHandle
argument_list|(
name|pi
operator|->
name|hThread
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|full_executable
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_block
condition|)
name|free
argument_list|(
name|env_block
argument_list|)
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|pi
operator|->
name|hProcess
return|;
name|error
label|:
if|if
condition|(
name|env_block
condition|)
name|free
argument_list|(
name|env_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdline
condition|)
name|free
argument_list|(
name|cmdline
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_executable
condition|)
name|free
argument_list|(
name|full_executable
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|spawn_script
parameter_list|(
specifier|const
name|char
modifier|*
name|executable
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
name|DWORD
name|dwCreationFlags
parameter_list|,
name|LPSTARTUPINFO
name|si
parameter_list|,
name|LPPROCESS_INFORMATION
name|pi
parameter_list|)
block|{
name|int
name|pid
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|int
name|fd
init|=
name|_open
argument_list|(
name|executable
argument_list|,
name|_O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|MAX_PATH
operator|+
literal|5
index|]
decl_stmt|;
name|int
name|len
init|=
name|_read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
condition|)
block|{
name|char
modifier|*
name|eol
decl_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|eol
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol
operator|&&
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"#!"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|executable1
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|avhere
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|--
name|argv
decl_stmt|;
do|do
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
do|while
condition|(
operator|*
operator|--
name|eol
operator|==
literal|'\r'
operator|||
operator|*
name|eol
operator|==
literal|' '
operator|||
operator|*
name|eol
operator|==
literal|'\t'
condition|)
do|;
for|for
control|(
name|executable1
operator|=
name|buf
operator|+
literal|2
init|;
operator|*
name|executable1
operator|==
literal|' '
operator|||
operator|*
name|executable1
operator|==
literal|'\t'
condition|;
name|executable1
operator|++
control|)
continue|continue;
name|backslashify
argument_list|(
name|executable1
argument_list|)
expr_stmt|;
operator|*
name|avhere
operator|=
name|executable1
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MINGW_MSYS
name|executable
operator|=
name|strrchr
argument_list|(
name|executable1
argument_list|,
literal|'\\'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|executable
condition|)
name|executable
operator|=
name|executable1
expr_stmt|;
name|pid
operator|=
name|win32_spawn
argument_list|(
name|executable
argument_list|,
name|TRUE
argument_list|,
name|argv
argument_list|,
name|env
argument_list|,
name|dwCreationFlags
argument_list|,
name|si
argument_list|,
name|pi
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|strchr
argument_list|(
name|executable1
argument_list|,
literal|'\\'
argument_list|)
operator|==
name|NULL
condition|)
name|pid
operator|=
name|win32_spawn
argument_list|(
name|executable1
argument_list|,
name|TRUE
argument_list|,
name|argv
argument_list|,
name|env
argument_list|,
name|dwCreationFlags
argument_list|,
name|si
argument_list|,
name|pi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|executable1
index|[
literal|0
index|]
operator|!=
literal|'\\'
condition|)
name|pid
operator|=
name|win32_spawn
argument_list|(
name|executable1
argument_list|,
name|FALSE
argument_list|,
name|argv
argument_list|,
name|env
argument_list|,
name|dwCreationFlags
argument_list|,
name|si
argument_list|,
name|pi
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|newex
init|=
name|mingw_rootify
argument_list|(
name|executable1
argument_list|)
decl_stmt|;
operator|*
name|avhere
operator|=
name|newex
expr_stmt|;
name|pid
operator|=
name|win32_spawn
argument_list|(
name|newex
argument_list|,
name|FALSE
argument_list|,
name|argv
argument_list|,
name|env
argument_list|,
name|dwCreationFlags
argument_list|,
name|si
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|executable1
operator|!=
name|newex
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newex
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|newex
operator|=
name|msys_rootify
argument_list|(
name|executable1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newex
operator|!=
name|executable1
condition|)
block|{
operator|*
name|avhere
operator|=
name|newex
expr_stmt|;
name|pid
operator|=
name|win32_spawn
argument_list|(
name|newex
argument_list|,
name|FALSE
argument_list|,
name|argv
argument_list|,
name|env
argument_list|,
name|dwCreationFlags
argument_list|,
name|si
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
block|}
block|}
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Execute a child.  */
end_comment

begin_function
specifier|static
name|long
name|pex_win32_exec_child
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|executable
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|int
name|errdes
parameter_list|,
name|int
name|toclose
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|long
name|pid
decl_stmt|;
name|HANDLE
name|stdin_handle
decl_stmt|;
name|HANDLE
name|stdout_handle
decl_stmt|;
name|HANDLE
name|stderr_handle
decl_stmt|;
name|DWORD
name|dwCreationFlags
decl_stmt|;
name|OSVERSIONINFO
name|version_info
decl_stmt|;
name|STARTUPINFO
name|si
decl_stmt|;
name|PROCESS_INFORMATION
name|pi
decl_stmt|;
name|stdin_handle
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|stdout_handle
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|stderr_handle
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|stdin_handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|stdout_handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PEX_STDERR_TO_STDOUT
operator|)
condition|)
name|stderr_handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|errdes
argument_list|)
expr_stmt|;
else|else
name|stderr_handle
operator|=
name|stdout_handle
expr_stmt|;
comment|/* Determine the version of Windows we are running on.  */
name|version_info
operator|.
name|dwOSVersionInfoSize
operator|=
sizeof|sizeof
argument_list|(
name|version_info
argument_list|)
expr_stmt|;
name|GetVersionEx
argument_list|(
operator|&
name|version_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|version_info
operator|.
name|dwPlatformId
operator|==
name|VER_PLATFORM_WIN32_WINDOWS
condition|)
comment|/* On Windows 95/98/ME the CREATE_NO_WINDOW flag is not        supported, so we cannot avoid creating a console window.  */
name|dwCreationFlags
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|HANDLE
name|conout_handle
decl_stmt|;
comment|/* Determine whether or not we have an associated console.  */
name|conout_handle
operator|=
name|CreateFile
argument_list|(
literal|"CONOUT$"
argument_list|,
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_WRITE
argument_list|,
comment|/*lpSecurityAttributes=*/
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
comment|/*hTemplateFile=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|conout_handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
comment|/* There is no console associated with this process.  Since 	   the child is a console process, the OS would normally 	   create a new console Window for the child.  Since we'll be 	   redirecting the child's standard streams, we do not need 	   the console window.  */
name|dwCreationFlags
operator|=
name|CREATE_NO_WINDOW
expr_stmt|;
else|else
block|{
comment|/* There is a console associated with the process, so the OS 	     will not create a new console.  And, if we use 	     CREATE_NO_WINDOW in this situation, the child will have 	     no associated console.  Therefore, if the child's 	     standard streams are connected to the console, the output 	     will be discarded.  */
name|CloseHandle
argument_list|(
name|conout_handle
argument_list|)
expr_stmt|;
name|dwCreationFlags
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Since the child will be a console process, it will, by default,      connect standard input/output to its console.  However, we want      the child to use the handles specifically designated above.  In      addition, if there is no console (such as when we are running in      a Cygwin X window), then we must redirect the child's      input/output, as there is no console for the child to use.  */
name|memset
argument_list|(
operator|&
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|.
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|si
operator|.
name|dwFlags
operator|=
name|STARTF_USESTDHANDLES
expr_stmt|;
name|si
operator|.
name|hStdInput
operator|=
name|stdin_handle
expr_stmt|;
name|si
operator|.
name|hStdOutput
operator|=
name|stdout_handle
expr_stmt|;
name|si
operator|.
name|hStdError
operator|=
name|stderr_handle
expr_stmt|;
comment|/* Create the child process.  */
name|pid
operator|=
name|win32_spawn
argument_list|(
name|executable
argument_list|,
operator|(
name|flags
operator|&
name|PEX_SEARCH
operator|)
operator|!=
literal|0
argument_list|,
name|argv
argument_list|,
name|env
argument_list|,
name|dwCreationFlags
argument_list|,
operator|&
name|si
argument_list|,
operator|&
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|pid
operator|=
name|spawn_script
argument_list|(
name|executable
argument_list|,
name|argv
argument_list|,
name|env
argument_list|,
name|dwCreationFlags
argument_list|,
operator|&
name|si
argument_list|,
operator|&
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|err
operator|=
name|ENOENT
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"CreateProcess"
expr_stmt|;
block|}
comment|/* Close the standard output and standard error handles in the      parent.  */
if|if
condition|(
name|out
operator|!=
name|STDOUT_FILENO
condition|)
name|obj
operator|->
name|funcs
operator|->
name|close
argument_list|(
name|obj
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|errdes
operator|!=
name|STDERR_FILENO
condition|)
name|obj
operator|->
name|funcs
operator|->
name|close
argument_list|(
name|obj
argument_list|,
name|errdes
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Wait for a child process to complete.  MS CRTDLL doesn't return    enough information in status to decide if the child exited due to a    signal or not, rather it simply returns an integer with the exit    code of the child; eg., if the child exited with an abort() call    and didn't have a handler for SIGABRT, it simply returns with    status == 3.  We fix the status code to conform to the usual WIF*    macros.  Note that WIFSIGNALED will never be true under CRTDLL. */
end_comment

begin_function
specifier|static
name|int
name|pex_win32_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|struct
name|pex_time
modifier|*
name|time
parameter_list|,
name|int
name|done
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|DWORD
name|termstat
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
if|if
condition|(
name|time
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|time
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|time
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|HANDLE
operator|)
name|pid
expr_stmt|;
comment|/* FIXME: If done is non-zero, we should probably try to kill the      process.  */
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|h
argument_list|,
name|INFINITE
argument_list|)
operator|!=
name|WAIT_OBJECT_0
condition|)
block|{
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
name|ECHILD
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"WaitForSingleObject"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|GetExitCodeProcess
argument_list|(
name|h
argument_list|,
operator|&
name|termstat
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* A value of 3 indicates that the child caught a signal, but not      which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we      report SIGABRT.  */
if|if
condition|(
name|termstat
operator|==
literal|3
condition|)
operator|*
name|status
operator|=
name|SIGABRT
expr_stmt|;
else|else
operator|*
name|status
operator|=
operator|(
name|termstat
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create a pipe.  */
end_comment

begin_function
specifier|static
name|int
name|pex_win32_pipe
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|p
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
return|return
name|_pipe
argument_list|(
name|p
argument_list|,
literal|256
argument_list|,
name|binary
condition|?
name|_O_BINARY
else|:
name|_O_TEXT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a FILE pointer to read from a file descriptor.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|pex_win32_fdopenr
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
return|return
name|fdopen
argument_list|(
name|fd
argument_list|,
name|binary
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|pex_win32_fdopenw
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
name|HANDLE
name|h
init|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|SetHandleInformation
argument_list|(
name|h
argument_list|,
name|HANDLE_FLAG_INHERIT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|fdopen
argument_list|(
name|fd
argument_list|,
name|binary
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|argv
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
name|pex_win32_exec_child
argument_list|(
name|NULL
argument_list|,
name|PEX_SEARCH
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
operator|&
name|errmsg
argument_list|,
operator|&
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

