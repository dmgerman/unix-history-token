begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities to execute a program in a subprocess (possibly linked by pipes    with other subprocesses), and wait for it.  Generic Win32 specialization.    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003    Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"pex-common.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* mingw32 headers may not define the following.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_P_WAIT
end_ifndef

begin_define
define|#
directive|define
name|_P_WAIT
value|0
end_define

begin_define
define|#
directive|define
name|_P_NOWAIT
value|1
end_define

begin_define
define|#
directive|define
name|_P_OVERLAY
value|2
end_define

begin_define
define|#
directive|define
name|_P_NOWAITO
value|3
end_define

begin_define
define|#
directive|define
name|_P_DETACH
value|4
end_define

begin_define
define|#
directive|define
name|WAIT_CHILD
value|0
end_define

begin_define
define|#
directive|define
name|WAIT_GRANDCHILD
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is a kludge to get around the Microsoft C spawn functions' propensity    to remove the outermost set of double quotes from all arguments.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|fix_argv
parameter_list|(
name|argvec
parameter_list|)
name|char
modifier|*
modifier|*
name|argvec
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|command0
init|=
name|argvec
index|[
literal|0
index|]
decl_stmt|;
comment|/* Ensure that the executable pathname uses Win32 backslashes.  */
for|for
control|(
init|;
operator|*
name|command0
operator|!=
literal|'\0'
condition|;
name|command0
operator|++
control|)
if|if
condition|(
operator|*
name|command0
operator|==
literal|'/'
condition|)
operator|*
name|command0
operator|=
literal|'\\'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argvec
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|newtemp
decl_stmt|;
name|temp
operator|=
name|argvec
index|[
name|i
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|temp
index|[
name|j
index|]
operator|==
literal|'"'
condition|)
block|{
name|newtemp
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newtemp
argument_list|,
name|temp
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|newtemp
index|[
name|j
index|]
operator|=
literal|'\\'
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|newtemp
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
operator|&
name|temp
index|[
name|j
index|]
argument_list|,
name|len
operator|-
name|j
argument_list|)
expr_stmt|;
name|newtemp
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|newtemp
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|argvec
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argvec
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strpbrk
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|,
literal|" \t"
argument_list|)
condition|)
block|{
name|int
name|len
decl_stmt|,
name|trailing_backslash
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|trailing_backslash
operator|=
literal|0
expr_stmt|;
comment|/* There is an added complication when an arg with embedded white 	     space ends in a backslash (such as in the case of -iprefix arg 	     passed to cpp). The resulting quoted strings gets misinterpreted 	     by the command interpreter -- it thinks that the ending quote 	     is escaped by the trailing backslash and things get confused.  	     We handle this case by escaping the trailing backslash, provided 	     it was not escaped in the first place.  */
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|argvec
index|[
name|i
index|]
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|argvec
index|[
name|i
index|]
index|[
name|len
operator|-
literal|2
index|]
operator|!=
literal|'\\'
condition|)
block|{
name|trailing_backslash
operator|=
literal|1
expr_stmt|;
operator|++
name|len
expr_stmt|;
comment|/* to escape the final backslash. */
block|}
name|len
operator|+=
literal|2
expr_stmt|;
comment|/* and for the enclosing quotes. */
name|temp
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|temp
index|[
literal|0
index|]
operator|=
literal|'"'
expr_stmt|;
name|strcpy
argument_list|(
name|temp
operator|+
literal|1
argument_list|,
name|argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trailing_backslash
condition|)
name|temp
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\\'
expr_stmt|;
name|temp
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'"'
expr_stmt|;
name|temp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|argvec
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
return|return
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|argvec
return|;
block|}
end_function

begin_comment
comment|/* Win32 supports pipes */
end_comment

begin_function
name|int
name|pexecute
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|,
name|this_pname
parameter_list|,
name|temp_base
parameter_list|,
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_pname
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_base
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg_fmt
decl_stmt|,
decl|*
modifier|*
name|errmsg_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|;
name|int
name|pdes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|org_stdin
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|org_stdout
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|input_desc
decl_stmt|,
name|output_desc
decl_stmt|;
comment|/* Pipe waiting from last process, to be used as input for the next one.      Value is STDIN_FILE_NO if no pipe is waiting      (i.e. the next command is the first of a group).  */
specifier|static
name|int
name|last_pipe_input
decl_stmt|;
comment|/* If this is the first process, initialize.  */
if|if
condition|(
name|flags
operator|&
name|PEXECUTE_FIRST
condition|)
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
name|input_desc
operator|=
name|last_pipe_input
expr_stmt|;
comment|/* If this isn't the last process, make a pipe for its output,      and record it as waiting to be the input to the next process.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PEXECUTE_LAST
operator|)
condition|)
block|{
if|if
condition|(
name|_pipe
argument_list|(
name|pdes
argument_list|,
literal|256
argument_list|,
name|O_BINARY
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
literal|"pipe"
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|output_desc
operator|=
name|pdes
index|[
name|WRITE_PORT
index|]
expr_stmt|;
name|last_pipe_input
operator|=
name|pdes
index|[
name|READ_PORT
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Last process.  */
name|output_desc
operator|=
name|STDOUT_FILE_NO
expr_stmt|;
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
block|}
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
name|org_stdin
operator|=
name|dup
argument_list|(
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|input_desc
argument_list|,
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
name|org_stdout
operator|=
name|dup
argument_list|(
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|output_desc
argument_list|,
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
operator|(
name|flags
operator|&
name|PEXECUTE_SEARCH
condition|?
name|_spawnvp
else|:
name|_spawnv
operator|)
operator|(
name|_P_NOWAIT
operator|,
name|program
operator|,
name|fix_argv
argument_list|(
name|argv
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
name|dup2
argument_list|(
name|org_stdin
argument_list|,
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|org_stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
name|dup2
argument_list|(
name|org_stdout
argument_list|,
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|org_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|errmsg_fmt
operator|=
name|install_error_msg
expr_stmt|;
operator|*
name|errmsg_arg
operator|=
operator|(
name|char
operator|*
operator|)
name|program
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|pid
return|;
block|}
end_block

begin_comment
comment|/* MS CRTDLL doesn't return enough information in status to decide if the    child exited due to a signal or not, rather it simply returns an    integer with the exit code of the child; eg., if the child exited with     an abort() call and didn't have a handler for SIGABRT, it simply returns    with status = 3. We fix the status code to conform to the usual WIF*    macros. Note that WIFSIGNALED will never be true under CRTDLL. */
end_comment

begin_function
name|int
name|pwait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|termstat
decl_stmt|;
name|pid
operator|=
name|_cwait
argument_list|(
operator|&
name|termstat
argument_list|,
name|pid
argument_list|,
name|WAIT_CHILD
argument_list|)
expr_stmt|;
comment|/* ??? Here's an opportunity to canonicalize the values in STATUS.      Needed?  */
comment|/* cwait returns the child process exit code in termstat.      A value of 3 indicates that the child caught a signal, but not      which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we      report SIGABRT.  */
if|if
condition|(
name|termstat
operator|==
literal|3
condition|)
operator|*
name|status
operator|=
name|SIGABRT
expr_stmt|;
else|else
operator|*
name|status
operator|=
operator|(
operator|(
operator|(
name|termstat
operator|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

end_unit

