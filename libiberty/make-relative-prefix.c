begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Relative (relocatable) prefix support.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2006 Free Software Foundation, Inc.  This file is part of libiberty.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/*  @deftypefn Extension {const char*} make_relative_prefix (const char *@var{progname}, const char *@var{bin_prefix}, const char *@var{prefix})  Given three paths @var{progname}, @var{bin_prefix}, @var{prefix}, return the path that is in the same position relative to @var{progname}'s directory as @var{prefix} is relative to @var{bin_prefix}.  That is, a string starting with the directory portion of @var{progname}, followed by a relative pathname of the difference between @var{bin_prefix} and @var{prefix}.  If @var{progname} does not contain any directory separators, @code{make_relative_prefix} will search @env{PATH} to find a program named @var{progname}.  Also, if @var{progname} is a symbolic link, the symbolic link will be resolved.  For example, if @var{bin_prefix} is @code{/alpha/beta/gamma/gcc/delta}, @var{prefix} is @code{/alpha/beta/gamma/omega/}, and @var{progname} is @code{/red/green/blue/gcc}, then this function will return @code{/red/green/blue/../../omega/}.  The return value is normally allocated via @code{malloc}.  If no relative prefix can be found, return @code{NULL}.  @end deftypefn  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIR_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|DIR_SEPARATOR
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OS2__
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_DOS_BASED_FILE_SYSTEM
end_define

begin_define
define|#
directive|define
name|HAVE_HOST_EXECUTABLE_SUFFIX
end_define

begin_define
define|#
directive|define
name|HOST_EXECUTABLE_SUFFIX
value|".exe"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DIR_SEPARATOR_2
end_ifndef

begin_define
define|#
directive|define
name|DIR_SEPARATOR_2
value|'\\'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|';'
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIR_SEPARATOR_2
end_ifndef

begin_define
define|#
directive|define
name|IS_DIR_SEPARATOR
parameter_list|(
name|ch
parameter_list|)
value|((ch) == DIR_SEPARATOR)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IS_DIR_SEPARATOR
parameter_list|(
name|ch
parameter_list|)
define|\
value|(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DIR_UP
value|".."
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|split_directories
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_split_directories
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|save_string
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Split a filename into component directories.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|split_directories
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|ptr_num_dirs
parameter_list|)
block|{
name|int
name|num_dirs
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|dirs
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|ch
decl_stmt|;
comment|/* Count the number of directories.  Special case MSDOS disk names as part      of the initial directory.  */
name|p
operator|=
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
name|num_dirs
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_DOS_BASED_FILE_SYSTEM */
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|num_dirs
operator|++
expr_stmt|;
while|while
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
name|dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|num_dirs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirs
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Now copy the directory parts.  */
name|num_dirs
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|dirs
index|[
name|num_dirs
operator|++
index|]
operator|=
name|save_string
argument_list|(
name|p
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirs
index|[
name|num_dirs
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|+=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_DOS_BASED_FILE_SYSTEM */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|ch
argument_list|)
condition|)
block|{
while|while
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|dirs
index|[
name|num_dirs
operator|++
index|]
operator|=
name|save_string
argument_list|(
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirs
index|[
name|num_dirs
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|dirs
index|[
name|num_dirs
index|]
operator|=
name|NULL
expr_stmt|;
name|free_split_directories
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|q
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|-
literal|1
operator|-
name|q
operator|>
literal|0
condition|)
name|dirs
index|[
name|num_dirs
operator|++
index|]
operator|=
name|save_string
argument_list|(
name|q
argument_list|,
name|p
operator|-
literal|1
operator|-
name|q
argument_list|)
expr_stmt|;
name|dirs
index|[
name|num_dirs
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dirs
index|[
name|num_dirs
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|free_split_directories
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ptr_num_dirs
condition|)
operator|*
name|ptr_num_dirs
operator|=
name|num_dirs
expr_stmt|;
return|return
name|dirs
return|;
block|}
end_function

begin_comment
comment|/* Release storage held by split directories.  */
end_comment

begin_function
specifier|static
name|void
name|free_split_directories
parameter_list|(
name|char
modifier|*
modifier|*
name|dirs
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|dirs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dirs
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given three strings PROGNAME, BIN_PREFIX, PREFIX, return a string that gets    to PREFIX starting with the directory portion of PROGNAME and a relative    pathname of the difference between BIN_PREFIX and PREFIX.     For example, if BIN_PREFIX is /alpha/beta/gamma/gcc/delta, PREFIX is    /alpha/beta/gamma/omega/, and PROGNAME is /red/green/blue/gcc, then this    function will return /red/green/blue/../../omega/.     If no relative prefix can be found, return NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_relative_prefix_1
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
specifier|const
name|char
modifier|*
name|bin_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|int
name|resolve_links
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|prog_dirs
decl_stmt|,
modifier|*
modifier|*
name|bin_dirs
decl_stmt|,
modifier|*
modifier|*
name|prefix_dirs
decl_stmt|;
name|int
name|prog_num
decl_stmt|,
name|bin_num
decl_stmt|,
name|prefix_num
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|common
decl_stmt|;
name|int
name|needed_len
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|full_progname
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|progname
operator|==
name|NULL
operator|||
name|bin_prefix
operator|==
name|NULL
operator|||
name|prefix
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* If there is no full pathname, try to find the program by checking in each      of the directories specified in the PATH environment variable.  */
if|if
condition|(
name|lbasename
argument_list|(
name|progname
argument_list|)
operator|==
name|progname
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|,
modifier|*
name|nstore
decl_stmt|;
name|size_t
name|prefixlen
init|=
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|prefixlen
operator|<
literal|2
condition|)
name|prefixlen
operator|=
literal|2
expr_stmt|;
name|nstore
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|prefixlen
operator|+
name|strlen
argument_list|(
name|progname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|startp
operator|=
name|endp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
block|{
name|nstore
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|nstore
index|[
literal|1
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|endp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|strcat
argument_list|(
name|nstore
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|nstore
argument_list|,
name|X_OK
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_HOST_EXECUTABLE_SUFFIX
operator|||
operator|!
name|access
argument_list|(
name|strcat
argument_list|(
name|nstore
argument_list|,
name|HOST_EXECUTABLE_SUFFIX
argument_list|)
argument_list|,
name|X_OK
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|progname
operator|=
name|nstore
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|resolve_links
condition|)
block|{
name|full_progname
operator|=
name|lrealpath
argument_list|(
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_progname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
else|else
name|full_progname
operator|=
name|strdup
argument_list|(
name|progname
argument_list|)
expr_stmt|;
name|prog_dirs
operator|=
name|split_directories
argument_list|(
name|full_progname
argument_list|,
operator|&
name|prog_num
argument_list|)
expr_stmt|;
name|bin_dirs
operator|=
name|split_directories
argument_list|(
name|bin_prefix
argument_list|,
operator|&
name|bin_num
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|full_progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin_dirs
operator|==
name|NULL
operator|||
name|prog_dirs
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Remove the program name from comparison of directory names.  */
name|prog_num
operator|--
expr_stmt|;
comment|/* If we are still installed in the standard location, we don't need to      specify relative directories.  Also, if argv[0] still doesn't contain      any directory specifiers after the search above, then there is not much      we can do.  */
if|if
condition|(
name|prog_num
operator|==
name|bin_num
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bin_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prog_dirs
index|[
name|i
index|]
argument_list|,
name|bin_dirs
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|prog_num
operator|<=
literal|0
operator|||
name|i
operator|==
name|bin_num
condition|)
block|{
name|free_split_directories
argument_list|(
name|prog_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|bin_dirs
argument_list|)
expr_stmt|;
name|prog_dirs
operator|=
name|bin_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|prefix_dirs
operator|=
name|split_directories
argument_list|(
name|prefix
argument_list|,
operator|&
name|prefix_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_dirs
operator|==
name|NULL
condition|)
block|{
name|free_split_directories
argument_list|(
name|prog_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|bin_dirs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Find how many directories are in common between bin_prefix& prefix.  */
name|n
operator|=
operator|(
name|prefix_num
operator|<
name|bin_num
operator|)
condition|?
name|prefix_num
else|:
name|bin_num
expr_stmt|;
for|for
control|(
name|common
operator|=
literal|0
init|;
name|common
operator|<
name|n
condition|;
name|common
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bin_dirs
index|[
name|common
index|]
argument_list|,
name|prefix_dirs
index|[
name|common
index|]
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If there are no common directories, there can be no relative prefix.  */
if|if
condition|(
name|common
operator|==
literal|0
condition|)
block|{
name|free_split_directories
argument_list|(
name|prog_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|bin_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|prefix_dirs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Two passes: first figure out the size of the result string, and      then construct it.  */
name|needed_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prog_num
condition|;
name|i
operator|++
control|)
name|needed_len
operator|+=
name|strlen
argument_list|(
name|prog_dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|needed_len
operator|+=
sizeof|sizeof
argument_list|(
name|DIR_UP
argument_list|)
operator|*
operator|(
name|bin_num
operator|-
name|common
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|common
init|;
name|i
operator|<
name|prefix_num
condition|;
name|i
operator|++
control|)
name|needed_len
operator|+=
name|strlen
argument_list|(
name|prefix_dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|needed_len
operator|+=
literal|1
expr_stmt|;
comment|/* Trailing NUL.  */
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|needed_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Build up the pathnames in argv[0].  */
operator|*
name|ret
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prog_num
condition|;
name|i
operator|++
control|)
name|strcat
argument_list|(
name|ret
argument_list|,
name|prog_dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Now build up the ..'s.  */
name|ptr
operator|=
name|ret
operator|+
name|strlen
argument_list|(
name|ret
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|common
init|;
name|i
operator|<
name|bin_num
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|ptr
argument_list|,
name|DIR_UP
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|DIR_UP
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|=
name|DIR_SEPARATOR
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Put in directories to move over to prefix.  */
for|for
control|(
name|i
operator|=
name|common
init|;
name|i
operator|<
name|prefix_num
condition|;
name|i
operator|++
control|)
name|strcat
argument_list|(
name|ret
argument_list|,
name|prefix_dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|prog_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|bin_dirs
argument_list|)
expr_stmt|;
name|free_split_directories
argument_list|(
name|prefix_dirs
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do the full job, including symlink resolution.    This path will find files installed in the same place as the    program even when a soft link has been made to the program    from somwhere else. */
end_comment

begin_function
name|char
modifier|*
name|make_relative_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
specifier|const
name|char
modifier|*
name|bin_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
return|return
name|make_relative_prefix_1
argument_list|(
name|progname
argument_list|,
name|bin_prefix
argument_list|,
name|prefix
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make the relative pathname without attempting to resolve any links.    '..' etc may also be left in the pathname.    This will find the files the user meant the program to find if the    installation is patched together with soft links. */
end_comment

begin_function
name|char
modifier|*
name|make_relative_prefix_ignore_links
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
specifier|const
name|char
modifier|*
name|bin_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
return|return
name|make_relative_prefix_1
argument_list|(
name|progname
argument_list|,
name|bin_prefix
argument_list|,
name|prefix
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

