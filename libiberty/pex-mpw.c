begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities to execute a program in a subprocess (possibly linked by pipes    with other subprocesses), and wait for it.  MPW specialization.    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003    Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"pex-common.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPW pexecute doesn't actually run anything; instead, it writes out    script commands that, when run, will do the actual executing.     For example, in GCC's case, GCC will write out several script commands:     cpp ...    cc1 ...    as ...    ld ...     and then exit.  None of the above programs will have run yet.  The task    that called GCC will then execute the script and cause cpp,etc. to run.    The caller must invoke pfinish before calling exit.  This adds    the finishing touches to the generated script.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|mpwify_filename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pexecute
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|,
name|this_pname
parameter_list|,
name|temp_base
parameter_list|,
name|errmsg_fmt
parameter_list|,
name|errmsg_arg
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_pname
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_base
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg_fmt
decl_stmt|,
decl|*
modifier|*
name|errmsg_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tmpprogram
index|[
literal|255
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tmpname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mpwify_filename
argument_list|(
name|program
argument_list|,
name|tmpprogram
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
block|{
name|printf
argument_list|(
literal|"Set Failed 0\n"
argument_list|)
expr_stmt|;
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"If {Failed} == 0\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* If being verbose, output a copy of the command.  It should be      accurate enough and escaped enough to be "clickable".  */
if|if
condition|(
name|flags
operator|&
name|PEXECUTE_VERBOSE
condition|)
block|{
name|fputs
argument_list|(
literal|"\tEcho "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tmpprogram
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* See if we have an argument that needs fixing.  */
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|tmpname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|mpwify_filename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|tmpname
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
comment|/* Write an Option-d escape char in front of special chars.  */
if|if
condition|(
name|strchr
argument_list|(
literal|"'+"
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\266'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\t"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tmpprogram
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* See if we have an argument that needs fixing.  */
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|tmpname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|mpwify_filename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|tmpname
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|' '
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
comment|/* Write an Option-d escape char in front of special chars.  */
if|if
condition|(
name|strchr
argument_list|(
literal|"'+"
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\266'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|' '
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* Output commands that arrange to clean up and exit if a failure occurs.      We have to be careful to collect the status from the program that was      run, rather than some other script command.  Also, we don't exit      immediately, since necessary cleanups are at the end of the script.  */
name|fputs
argument_list|(
literal|"\tSet TmpStatus {Status}\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tIf {TmpStatus} != 0\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t\tSet Failed {TmpStatus}\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tEnd\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"End\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* We're just composing a script, can't fail here.  */
return|return
literal|0
return|;
block|}
end_block

begin_function
name|int
name|pwait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
operator|*
name|status
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write out commands that will exit with the correct error code    if something in the script failed.  */
end_comment

begin_function
name|void
name|pfinish
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\tExit \"{Failed}\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

