begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities to execute a program in a subprocess (possibly linked by pipes    with other subprocesses), and wait for it.  DJGPP specialization.    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005    Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"pex-common.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_ERRNO
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_comment
comment|/* Use ECHILD if available, otherwise use EINVAL.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ECHILD
end_ifdef

begin_define
define|#
directive|define
name|PWAIT_ERROR
value|ECHILD
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PWAIT_ERROR
value|EINVAL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|pex_djgpp_open_read
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_djgpp_open_write
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|pex_djgpp_exec_child
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_djgpp_close
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pex_djgpp_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
parameter_list|,
name|long
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|pex_time
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The list of functions we pass to the common routines.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|pex_funcs
name|funcs
init|=
block|{
name|pex_djgpp_open_read
block|,
name|pex_djgpp_open_write
block|,
name|pex_djgpp_exec_child
block|,
name|pex_djgpp_close
block|,
name|pex_djgpp_wait
block|,
name|NULL
block|,
comment|/* pipe */
name|NULL
block|,
comment|/* fdopenr */
name|NULL
block|,
comment|/* fdopenw */
name|NULL
comment|/* cleanup */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a newly initialized pex_obj structure.  */
end_comment

begin_function
name|struct
name|pex_obj
modifier|*
name|pex_init
parameter_list|(
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|char
modifier|*
name|tempbase
parameter_list|)
block|{
comment|/* DJGPP does not support pipes.  */
name|flags
operator|&=
operator|~
name|PEX_USE_PIPES
expr_stmt|;
return|return
name|pex_init_common
argument_list|(
name|flags
argument_list|,
name|pname
argument_list|,
name|tempbase
argument_list|,
operator|&
name|funcs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open a file for reading.  */
end_comment

begin_function
specifier|static
name|int
name|pex_djgpp_open_read
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
return|return
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
operator||
operator|(
name|binary
condition|?
name|O_BINARY
else|:
name|O_TEXT
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open a file for writing.  */
end_comment

begin_function
specifier|static
name|int
name|pex_djgpp_open_write
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|binary
parameter_list|)
block|{
comment|/* Note that we can't use O_EXCL here because gcc may have already      created the temporary file via make_temp_file.  */
return|return
name|open
argument_list|(
name|name
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
operator|(
name|binary
condition|?
name|O_BINARY
else|:
name|O_TEXT
operator|)
operator|)
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close a file.  */
end_comment

begin_function
specifier|static
name|int
name|pex_djgpp_close
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
return|return
name|close
argument_list|(
name|fd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Execute a child.  */
end_comment

begin_function
specifier|static
name|long
name|pex_djgpp_exec_child
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|executable
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|int
name|errdes
parameter_list|,
name|int
name|toclose
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|int
name|org_in
decl_stmt|,
name|org_out
decl_stmt|,
name|org_errdes
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
modifier|*
name|statuses
decl_stmt|;
name|org_in
operator|=
operator|-
literal|1
expr_stmt|;
name|org_out
operator|=
operator|-
literal|1
expr_stmt|;
name|org_errdes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
name|org_in
operator|=
name|dup
argument_list|(
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|org_in
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"dup"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|dup2
argument_list|(
name|in
argument_list|,
name|STDIN_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"dup2"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|in
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"close"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|out
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
name|org_out
operator|=
name|dup
argument_list|(
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|org_out
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"dup"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|dup2
argument_list|(
name|out
argument_list|,
name|STDOUT_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"dup2"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|out
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"close"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|errdes
operator|!=
name|STDERR_FILE_NO
operator|||
operator|(
name|flags
operator|&
name|PEX_STDERR_TO_STDOUT
operator|)
operator|!=
literal|0
condition|)
block|{
name|org_errdes
operator|=
name|dup
argument_list|(
name|STDERR_FILE_NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|org_errdes
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"dup"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|dup2
argument_list|(
operator|(
name|flags
operator|&
name|PEX_STDERR_TO_STDOUT
operator|)
operator|!=
literal|0
condition|?
name|STDOUT_FILE_NO
else|:
name|errdes
argument_list|,
name|STDERR_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"dup2"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|errdes
operator|!=
name|STDERR_FILE_NO
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|errdes
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"close"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
if|if
condition|(
name|env
condition|)
name|status
operator|=
operator|(
operator|(
operator|(
name|flags
operator|&
name|PEX_SEARCH
operator|)
operator|!=
literal|0
condition|?
name|spawnvpe
else|:
name|spawnve
operator|)
operator|(
name|P_WAIT
operator|,
name|executable
operator|,
name|argv
operator|,
name|env
operator|)
operator|)
expr_stmt|;
else|else
name|status
operator|=
operator|(
operator|(
operator|(
name|flags
operator|&
name|PEX_SEARCH
operator|)
operator|!=
literal|0
condition|?
name|spawnvp
else|:
name|spawnv
operator|)
operator|(
name|P_WAIT
operator|,
name|executable
operator|,
name|argv
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
operator|(
operator|(
name|flags
operator|&
name|PEX_SEARCH
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|"spawnvp"
else|:
literal|"spawnv"
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|org_in
argument_list|,
name|STDIN_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"dup2"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|org_in
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"close"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|out
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|org_out
argument_list|,
name|STDOUT_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"dup2"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|org_out
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"close"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|errdes
operator|!=
name|STDERR_FILE_NO
operator|||
operator|(
name|flags
operator|&
name|PEX_STDERR_TO_STDOUT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|org_errdes
argument_list|,
name|STDERR_FILE_NO
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"dup2"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|org_errdes
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|err
operator|=
name|errno
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"close"
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Save the exit status for later.  When we are called, obj->count      is the number of children which have executed before this      one.  */
name|statuses
operator|=
operator|(
name|int
operator|*
operator|)
name|obj
operator|->
name|sysdep
expr_stmt|;
name|statuses
operator|=
name|XRESIZEVEC
argument_list|(
name|int
argument_list|,
name|statuses
argument_list|,
name|obj
operator|->
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|statuses
index|[
name|obj
operator|->
name|count
index|]
operator|=
name|status
expr_stmt|;
name|obj
operator|->
name|sysdep
operator|=
operator|(
name|void
operator|*
operator|)
name|statuses
expr_stmt|;
return|return
name|obj
operator|->
name|count
return|;
block|}
end_function

begin_comment
comment|/* Wait for a child process to complete.  Actually the child process    has already completed, and we just need to return the exit    status.  */
end_comment

begin_function
specifier|static
name|int
name|pex_djgpp_wait
parameter_list|(
name|struct
name|pex_obj
modifier|*
name|obj
parameter_list|,
name|long
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|struct
name|pex_time
modifier|*
name|time
parameter_list|,
name|int
name|done
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|err
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
modifier|*
name|statuses
decl_stmt|;
if|if
condition|(
name|time
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|time
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|time
argument_list|)
expr_stmt|;
name|statuses
operator|=
operator|(
name|int
operator|*
operator|)
name|obj
operator|->
name|sysdep
expr_stmt|;
operator|*
name|status
operator|=
name|statuses
index|[
name|pid
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

