begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"$Id: ex.c,v 10.80 2012/10/03 16:24:40 zy Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"../vi/vi.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMLOG
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|ex_comlog
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|EXCMD
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|EXCMDLIST
specifier|const
modifier|*
name|ex_comm_search
parameter_list|(
name|CHAR_T
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ex_discard
parameter_list|(
name|SCR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ex_line
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|EXCMD
modifier|*
parameter_list|,
name|MARK
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ex_load
parameter_list|(
name|SCR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ex_unknown
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|CHAR_T
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ex --  *	Main ex loop.  *  * PUBLIC: int ex(SCR **);  */
end_comment

begin_function
name|int
name|ex
parameter_list|(
name|SCR
modifier|*
modifier|*
name|spp
parameter_list|)
block|{
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|MSGS
modifier|*
name|mp
decl_stmt|;
name|SCR
modifier|*
name|sp
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|sp
operator|=
operator|*
name|spp
expr_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Start the ex screen. */
if|if
condition|(
name|ex_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Flush any saved messages. */
while|while
condition|(
operator|(
name|mp
operator|=
name|SLIST_FIRST
argument_list|(
name|gp
operator|->
name|msgq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|gp
operator|->
name|scr_msg
argument_list|(
name|sp
argument_list|,
name|mp
operator|->
name|mtype
argument_list|,
name|mp
operator|->
name|buf
argument_list|,
name|mp
operator|->
name|len
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|gp
operator|->
name|msgq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/* If reading from a file, errors should have name and line info. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_SCRIPTED
argument_list|)
condition|)
block|{
name|gp
operator|->
name|excmd
operator|.
name|if_lno
operator|=
literal|1
expr_stmt|;
name|gp
operator|->
name|excmd
operator|.
name|if_name
operator|=
literal|"script"
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * Initialize the text flags.  The beautify edit option historically 	 * applied to ex command input read from a file.  In addition, the 	 * first time a ^H was discarded from the input, there was a message, 	 * "^H discarded", that was displayed.  We don't bother. 	 */
name|LF_INIT
argument_list|(
name|TXT_BACKSLASH
operator||
name|TXT_CNTRLD
operator||
name|TXT_CR
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|gp
operator|->
name|excmd
operator|.
name|if_lno
control|)
block|{
comment|/* Display status line and flush. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_STATUS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX_SILENT
argument_list|)
condition|)
name|msgq_status
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_STATUS
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ex_fflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Set the flags the user can reset. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_BEAUTIFY
argument_list|)
condition|)
name|LF_SET
argument_list|(
name|TXT_BEAUTIFY
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_PROMPT
argument_list|)
condition|)
name|LF_SET
argument_list|(
name|TXT_PROMPT
argument_list|)
expr_stmt|;
comment|/* Clear any current interrupts, and get a command. */
name|CLR_INTERRUPT
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_txt
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|tiq
argument_list|,
literal|':'
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ex_puts
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ex_fflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Initialize the command structure. */
name|CLEAR_EX_PARSER
argument_list|(
operator|&
name|gp
operator|->
name|excmd
argument_list|)
expr_stmt|;
comment|/* 		 * If the user entered a single carriage return, send 		 * ex_cmd() a separator -- it discards single newlines. 		 */
name|tp
operator|=
name|TAILQ_FIRST
argument_list|(
name|sp
operator|->
name|tiq
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|gp
operator|->
name|excmd
operator|.
name|cp
operator|=
name|L
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
comment|/* __TK__ why not |? */
name|gp
operator|->
name|excmd
operator|.
name|clen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gp
operator|->
name|excmd
operator|.
name|cp
operator|=
name|tp
operator|->
name|lb
expr_stmt|;
name|gp
operator|->
name|excmd
operator|.
name|clen
operator|=
name|tp
operator|->
name|len
expr_stmt|;
block|}
name|F_INIT
argument_list|(
operator|&
name|gp
operator|->
name|excmd
argument_list|,
name|E_NRSEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_cmd
argument_list|(
name|sp
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_SCRIPTED
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|CLR_INTERRUPT
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"170|Interrupted"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the last command caused a restart, or switched screens 		 * or into vi, return. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_SRESTART
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SSWITCH
operator||
name|SC_VI
argument_list|)
condition|)
block|{
operator|*
name|spp
operator|=
name|sp
expr_stmt|;
break|break;
block|}
comment|/* If the last command switched files, we don't care. */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_FSWITCH
argument_list|)
expr_stmt|;
comment|/* 		 * If we're exiting this screen, move to the next one.  By 		 * definition, this means returning into vi, so return to the 		 * main editor loop.  The ordering is careful, don't discard 		 * the contents of sp until the end. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT
operator||
name|SC_EXIT_FORCE
argument_list|)
condition|)
block|{
if|if
condition|(
name|file_end
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT_FORCE
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|spp
operator|=
name|screen_next
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|screen_end
argument_list|(
name|sp
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_cmd --  *	The guts of the ex parser: parse and execute a string containing  *	ex commands.  *  * !!!  * This code MODIFIES the string that gets passed in, to delete quoting  * characters, etc.  The string cannot be readonly/text space, nor should  * you expect to use it again after ex_cmd() returns.  *  * !!!  * For the fun of it, if you want to see if a vi clone got the ex argument  * parsing right, try:  *  *	echo 'foo|bar'> file1; echo 'foo/bar'> file2;  *	vi  *	:edit +1|s/|/PIPE/|w file1| e file2|1 | s/\//SLASH/|wq  *  * or:	vi  *	:set|file|append|set|file  *  * For extra credit, try them in a startup .exrc file.  *  * PUBLIC: int ex_cmd(SCR *);  */
end_comment

begin_function
name|int
name|ex_cmd
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|enum
name|nresult
name|nret
decl_stmt|;
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|EXCMD
modifier|*
name|ecp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|MARK
name|cur
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|arg1_len
decl_stmt|,
name|discard
decl_stmt|,
name|len
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|long
name|ltmp
decl_stmt|;
name|int
name|at_found
decl_stmt|,
name|gv_found
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|delim
decl_stmt|,
name|isaddr
decl_stmt|,
name|namelen
decl_stmt|;
name|int
name|newscreen
decl_stmt|,
name|notempty
decl_stmt|,
name|tmp
decl_stmt|,
name|vi_address
decl_stmt|;
name|CHAR_T
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|CHAR_T
name|ch
init|=
literal|'\0'
decl_stmt|;
name|CHAR_T
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * We always start running the command on the top of the stack. 	 * This means that *everything* must be resolved when we leave 	 * this function for any reason. 	 */
name|loop
label|:
name|ecp
operator|=
name|SLIST_FIRST
argument_list|(
name|gp
operator|->
name|ecq
argument_list|)
expr_stmt|;
comment|/* If we're reading a command from a file, set up error information. */
if|if
condition|(
name|ecp
operator|->
name|if_name
operator|!=
name|NULL
condition|)
block|{
name|gp
operator|->
name|if_lno
operator|=
name|ecp
operator|->
name|if_lno
expr_stmt|;
name|gp
operator|->
name|if_name
operator|=
name|ecp
operator|->
name|if_name
expr_stmt|;
block|}
comment|/* 	 * If a move to the end of the file is scheduled for this command, 	 * do it now. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_MOVETOEND
argument_list|)
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|lno
argument_list|)
condition|)
goto|goto
name|rfail
goto|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_MOVETOEND
argument_list|)
expr_stmt|;
block|}
comment|/* If we found a newline, increment the count now. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_NEWLINE
argument_list|)
condition|)
block|{
operator|++
name|gp
operator|->
name|if_lno
expr_stmt|;
operator|++
name|ecp
operator|->
name|if_lno
expr_stmt|;
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_NEWLINE
argument_list|)
expr_stmt|;
block|}
comment|/* (Re)initialize the EXCMD structure, preserving some flags. */
name|CLEAR_EX_CMD
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* Initialize the argument structures. */
if|if
condition|(
name|argv_init
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Initialize +cmd, saved command information. */
name|arg1
operator|=
name|NULL
expr_stmt|;
name|ecp
operator|->
name|save_cmdlen
operator|=
literal|0
expr_stmt|;
comment|/* Skip<blank>s, empty lines.  */
for|for
control|(
name|notempty
operator|=
literal|0
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|++
name|ecp
operator|->
name|cp
operator|,
operator|--
name|ecp
operator|->
name|clen
control|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
operator|)
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|gp
operator|->
name|if_lno
expr_stmt|;
operator|++
name|ecp
operator|->
name|if_lno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdskip
argument_list|(
name|ch
argument_list|)
condition|)
name|notempty
operator|=
literal|1
expr_stmt|;
else|else
break|break;
comment|/* 	 * !!! 	 * Permit extra colons at the start of the line.  Historically, 	 * ex/vi allowed a single extra one.  It's simpler not to count. 	 * The stripping is done here because, historically, any command 	 * could have preceding colons, e.g. ":g/pattern/:p" worked. 	 */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|!=
literal|0
operator|&&
name|ch
operator|==
literal|':'
condition|)
block|{
name|notempty
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|ecp
operator|->
name|clen
operator|>
literal|0
operator|&&
operator|(
name|ch
operator|=
operator|*
operator|++
name|ecp
operator|->
name|cp
operator|)
operator|==
literal|':'
condition|)
empty_stmt|;
block|}
comment|/* 	 * Command lines that start with a double-quote are comments. 	 * 	 * !!! 	 * Historically, there was no escape or delimiter for a comment, e.g. 	 * :"foo|set was a single comment and nothing was output.  Since nvi 	 * permits users to escape<newline> characters into command lines, we 	 * have to check for that case. 	 */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|!=
literal|0
operator|&&
name|ch
operator|==
literal|'"'
condition|)
block|{
while|while
condition|(
operator|--
name|ecp
operator|->
name|clen
operator|>
literal|0
operator|&&
operator|*
operator|++
name|ecp
operator|->
name|cp
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|ecp
operator|->
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_NEWLINE
argument_list|)
expr_stmt|;
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
comment|/* Skip whitespace. */
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|++
name|ecp
operator|->
name|cp
operator|,
operator|--
name|ecp
operator|->
name|clen
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|cmdskip
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * The last point at which an empty line can mean do nothing. 	 * 	 * !!! 	 * Historically, in ex mode, lines containing only<blank> characters 	 * were the same as a single<carriage-return>, i.e. a default command. 	 * In vi mode, they were ignored.  In .exrc files this was a serious 	 * annoyance, as vi kept trying to treat them as print commands.  We 	 * ignore backward compatibility in this case, discarding lines that 	 * contain only<blank> characters from .exrc files. 	 * 	 * !!! 	 * This is where you end up when you're done a command, i.e. clen has 	 * gone to zero.  Continue if there are more commands to run. 	 */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|==
literal|0
operator|&&
operator|(
operator|!
name|notempty
operator|||
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_BLIGNORE
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ex_load
argument_list|(
name|sp
argument_list|)
condition|)
goto|goto
name|rfail
goto|;
name|ecp
operator|=
name|SLIST_FIRST
argument_list|(
name|gp
operator|->
name|ecq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|clen
operator|==
literal|0
condition|)
goto|goto
name|rsuccess
goto|;
goto|goto
name|loop
goto|;
block|}
comment|/* 	 * Check to see if this is a command for which we may want to move 	 * the cursor back up to the previous line.  (The command :1<CR> 	 * wants a<newline> separator, but the command :<CR> wants to erase 	 * the command line.)  If the line is empty except for<blank>s, 	 *<carriage-return> or<eof>, we'll probably want to move up.  I 	 * don't think there's any way to get<blank> characters *after* the 	 * command character, but this is the ex parser, and I've been wrong 	 * before. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_NRSEP
argument_list|)
operator|&&
name|ecp
operator|->
name|clen
operator|!=
literal|0
operator|&&
operator|(
name|ecp
operator|->
name|clen
operator|!=
literal|1
operator|||
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|!=
literal|'\004'
operator|)
condition|)
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_NRSEP
argument_list|)
expr_stmt|;
comment|/* Parse command addresses. */
if|if
condition|(
name|ex_range
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
goto|goto
name|rfail
goto|;
if|if
condition|(
name|tmp
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * Skip<blank>s and any more colons (the command :3,5:print 	 * worked, historically). 	 */
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|++
name|ecp
operator|->
name|cp
operator|,
operator|--
name|ecp
operator|->
name|clen
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|cmdskip
argument_list|(
name|ch
argument_list|)
operator|&&
name|ch
operator|!=
literal|':'
condition|)
break|break;
block|}
comment|/* 	 * If no command, ex does the last specified of p, l, or #, and vi 	 * moves to the line.  Otherwise, determine the length of the command 	 * name by looking for the first non-alphabetic character.  (There 	 * are a few non-alphabetic characters in command names, but they're 	 * all single character commands.)  This isn't a great test, because 	 * it means that, for the command ":e +cut.c file", we'll report that 	 * the command "cut" wasn't known.  However, it makes ":e+35 file" work 	 * correctly. 	 * 	 * !!! 	 * Historically, lines with multiple adjacent (or<blank> separated) 	 * command separators were very strange.  For example, the command 	 * |||<carriage-return>, when the cursor was on line 1, displayed 	 * lines 2, 3 and 5 of the file.  In addition, the command "   |  " 	 * would only display the line after the next line, instead of the 	 * next two lines.  No ideas why.  It worked reasonably when executed 	 * from vi mode, and displayed lines 2, 3, and 4, so we do a default 	 * command for each separator. 	 */
define|#
directive|define
name|SINGLE_CHAR_COMMANDS
value|L("\004!#&*<=>@~")
name|newscreen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|clen
operator|!=
literal|0
operator|&&
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|!=
literal|'|'
operator|&&
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|STRCHR
argument_list|(
name|SINGLE_CHAR_COMMANDS
argument_list|,
operator|*
name|ecp
operator|->
name|cp
argument_list|)
condition|)
block|{
name|p
operator|=
name|ecp
operator|->
name|cp
expr_stmt|;
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
name|namelen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|ecp
operator|->
name|cp
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|ecp
operator|->
name|cp
argument_list|)
operator|||
operator|!
name|isalpha
argument_list|(
operator|*
name|ecp
operator|->
name|cp
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|namelen
operator|=
name|ecp
operator|->
name|cp
operator|-
name|p
operator|)
operator|==
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"080|Unknown command name"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* 		 * !!! 		 * Historic vi permitted flags to immediately follow any 		 * subset of the 'delete' command, but then did not permit 		 * further arguments (flag, buffer, count).  Make it work. 		 * Permit further arguments for the few shreds of dignity 		 * it offers. 		 * 		 * Adding commands that start with 'd', and match "delete" 		 * up to a l, p, +, - or # character can break this code. 		 * 		 * !!! 		 * Capital letters beginning the command names ex, edit, 		 * next, previous, tag and visual (in vi mode) indicate the 		 * command should happen in a new screen. 		 */
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'d'
case|:
for|for
control|(
name|s
operator|=
name|p
operator|,
name|n
operator|=
name|cmds
index|[
name|C_DELETE
index|]
operator|.
name|name
init|;
operator|*
name|s
operator|==
operator|*
name|n
condition|;
operator|++
name|s
operator|,
operator|++
name|n
control|)
empty_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'l'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'p'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'^'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|len
operator|=
operator|(
name|ecp
operator|->
name|cp
operator|-
name|p
operator|)
operator|-
operator|(
name|s
operator|-
name|p
operator|)
expr_stmt|;
name|ecp
operator|->
name|cp
operator|-=
name|len
expr_stmt|;
name|ecp
operator|->
name|clen
operator|+=
name|len
expr_stmt|;
name|ecp
operator|->
name|rcmd
operator|=
name|cmds
index|[
name|C_DELETE
index|]
expr_stmt|;
name|ecp
operator|->
name|rcmd
operator|.
name|syntax
operator|=
literal|"1bca1"
expr_stmt|;
name|ecp
operator|->
name|cmd
operator|=
operator|&
name|ecp
operator|->
name|rcmd
expr_stmt|;
goto|goto
name|skip_srch
goto|;
block|}
break|break;
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'N'
case|:
case|case
literal|'P'
case|:
case|case
literal|'T'
case|:
case|case
literal|'V'
case|:
name|newscreen
operator|=
literal|1
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|tolower
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Search the table for the command. 		 * 		 * !!! 		 * Historic vi permitted the mark to immediately follow the 		 * 'k' in the 'k' command.  Make it work. 		 * 		 * !!! 		 * Historic vi permitted any flag to follow the s command, e.g. 		 * "s/e/E/|s|sgc3p" was legal.  Make the command "sgc" work. 		 * Since the following characters all have to be flags, i.e. 		 * alphabetics, we can let the s command routine return errors 		 * if it was some illegal command string.  This code will break 		 * if an "sg" or similar command is ever added.  The substitute 		 * code doesn't care if it's a "cgr" flag or a "#lp" flag that 		 * follows the 's', but we limit the choices here to "cgr" so 		 * that we get unknown command messages for wrong combinations. 		 */
if|if
condition|(
operator|(
name|ecp
operator|->
name|cmd
operator|=
name|ex_comm_search
argument_list|(
name|p
argument_list|,
name|namelen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'k'
case|:
if|if
condition|(
name|namelen
operator|==
literal|2
condition|)
block|{
name|ecp
operator|->
name|cp
operator|-=
name|namelen
operator|-
literal|1
expr_stmt|;
name|ecp
operator|->
name|clen
operator|+=
name|namelen
operator|-
literal|1
expr_stmt|;
name|ecp
operator|->
name|cmd
operator|=
operator|&
name|cmds
index|[
name|C_K
index|]
expr_stmt|;
break|break;
block|}
goto|goto
name|unknown
goto|;
case|case
literal|'s'
case|:
for|for
control|(
name|s
operator|=
name|p
operator|+
literal|1
operator|,
name|cnt
operator|=
name|namelen
init|;
operator|--
name|cnt
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'c'
operator|&&
name|s
index|[
literal|0
index|]
operator|!=
literal|'g'
operator|&&
name|s
index|[
literal|0
index|]
operator|!=
literal|'r'
condition|)
break|break;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|ecp
operator|->
name|cp
operator|-=
name|namelen
operator|-
literal|1
expr_stmt|;
name|ecp
operator|->
name|clen
operator|+=
name|namelen
operator|-
literal|1
expr_stmt|;
name|ecp
operator|->
name|rcmd
operator|=
name|cmds
index|[
name|C_SUBSTITUTE
index|]
expr_stmt|;
name|ecp
operator|->
name|rcmd
operator|.
name|fn
operator|=
name|ex_subagain
expr_stmt|;
name|ecp
operator|->
name|cmd
operator|=
operator|&
name|ecp
operator|->
name|rcmd
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|unknown
label|:
if|if
condition|(
name|newscreen
condition|)
name|p
index|[
literal|0
index|]
operator|=
name|toupper
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ex_unknown
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * The visual command has a different syntax when called 		 * from ex than when called from a vi colon command.  FMH. 		 * Make the change now, before we test for the newscreen 		 * semantic, so that we're testing the right one. 		 */
name|skip_srch
label|:
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_VISUAL_EX
index|]
operator|&&
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
condition|)
name|ecp
operator|->
name|cmd
operator|=
operator|&
name|cmds
index|[
name|C_VISUAL_VI
index|]
expr_stmt|;
comment|/* 		 * !!! 		 * Historic vi permitted a capital 'P' at the beginning of 		 * any command that started with 'p'.  Probably wanted the 		 * P[rint] command for backward compatibility, and the code 		 * just made Preserve and Put work by accident.  Nvi uses 		 * Previous to mean previous-in-a-new-screen, so be careful. 		 */
if|if
condition|(
name|newscreen
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|ecp
operator|->
name|cmd
argument_list|,
name|E_NEWSCREEN
argument_list|)
operator|&&
operator|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_PRINT
index|]
operator|||
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_PRESERVE
index|]
operator|)
condition|)
name|newscreen
operator|=
literal|0
expr_stmt|;
comment|/* Test for a newscreen associated with this command. */
if|if
condition|(
name|newscreen
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|ecp
operator|->
name|cmd
argument_list|,
name|E_NEWSCREEN
argument_list|)
condition|)
goto|goto
name|unknown
goto|;
comment|/* Secure means no shell access. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
operator|->
name|cmd
argument_list|,
name|E_SECURE
argument_list|)
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_SECURE
argument_list|)
condition|)
block|{
name|ex_wemsg
argument_list|(
name|sp
argument_list|,
name|ecp
operator|->
name|cmd
operator|->
name|name
argument_list|,
name|EXM_SECURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Multiple< and> characters; another "feature".  Note, 		 * The string passed to the underlying function may not be 		 * nul terminated in this case. 		 */
if|if
condition|(
operator|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_SHIFTL
index|]
operator|&&
operator|*
name|p
operator|==
literal|'<'
operator|)
operator|||
operator|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_SHIFTR
index|]
operator|&&
operator|*
name|p
operator|==
literal|'>'
operator|)
condition|)
block|{
for|for
control|(
name|ch
operator|=
operator|*
name|p
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
if|if
condition|(
operator|*
name|ecp
operator|->
name|cp
operator|!=
name|ch
condition|)
break|break;
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|p
argument_list|,
name|ecp
operator|->
name|cp
operator|-
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Set the format style flags for the next command. */
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_HASH
index|]
condition|)
name|exp
operator|->
name|fdef
operator|=
name|E_C_HASH
expr_stmt|;
elseif|else
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_LIST
index|]
condition|)
name|exp
operator|->
name|fdef
operator|=
name|E_C_LIST
expr_stmt|;
elseif|else
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_PRINT
index|]
condition|)
name|exp
operator|->
name|fdef
operator|=
name|E_C_PRINT
expr_stmt|;
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_USELASTCMD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Print is the default command. */
name|ecp
operator|->
name|cmd
operator|=
operator|&
name|cmds
index|[
name|C_PRINT
index|]
expr_stmt|;
comment|/* Set the saved format flags. */
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|exp
operator|->
name|fdef
argument_list|)
expr_stmt|;
comment|/* 		 * !!! 		 * If no address was specified, and it's not a global command, 		 * we up the address by one.  (I have no idea why globals are 		 * exempted, but it's (ahem) historic practice.) 		 */
if|if
condition|(
name|ecp
operator|->
name|addrcnt
operator|==
literal|0
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX_GLOBAL
argument_list|)
condition|)
block|{
name|ecp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_USELASTCMD
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * Historically, the number option applied to both ex and vi.  One 	 * strangeness was that ex didn't switch display formats until a 	 * command was entered, e.g.<CR>'s after the set didn't change to 	 * the new format, but :1p would. 	 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_NUMBER
argument_list|)
condition|)
block|{
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_OPTNUM
argument_list|)
expr_stmt|;
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_HASH
argument_list|)
expr_stmt|;
block|}
else|else
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_OPTNUM
argument_list|)
expr_stmt|;
comment|/* Check for ex mode legality. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|ecp
operator|->
name|cmd
argument_list|,
name|E_VIONLY
argument_list|)
operator|||
name|newscreen
operator|)
condition|)
block|{
name|msgq_wstr
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|ecp
operator|->
name|cmd
operator|->
name|name
argument_list|,
literal|"082|%s: command not available in ex mode"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Add standard command flags. */
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|ecp
operator|->
name|cmd
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newscreen
condition|)
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_NEWSCREEN
argument_list|)
expr_stmt|;
comment|/* 	 * There are three normal termination cases for an ex command.  They 	 * are the end of the string (ecp->clen), or unescaped (by<literal 	 * next> characters)<newline> or '|' characters.  As we're now past 	 * possible addresses, we can determine how long the command is, so we 	 * don't have to look for all the possible terminations.  Naturally, 	 * there are some exciting special cases: 	 * 	 * 1: The bang, global, v and the filter versions of the read and 	 *    write commands are delimited by<newline>s (they can contain 	 *    shell pipes). 	 * 2: The ex, edit, next and visual in vi mode commands all take ex 	 *    commands as their first arguments. 	 * 3: The s command takes an RE as its first argument, and wants it 	 *    to be specially delimited. 	 * 	 * Historically, '|' characters in the first argument of the ex, edit, 	 * next, vi visual, and s commands didn't delimit the command.  And, 	 * in the filter cases for read and write, and the bang, global and v 	 * commands, they did not delimit the command at all. 	 * 	 * For example, the following commands were legal: 	 * 	 *	:edit +25|s/abc/ABC/ file.c 	 *	:s/|/PIPE/ 	 *	:read !spell % | columnate 	 *	:global/pattern/p|l 	 * 	 * It's not quite as simple as it sounds, however.  The command: 	 * 	 *	:s/a/b/|s/c/d|set 	 * 	 * was also legal, i.e. the historic ex parser (using the word loosely, 	 * since "parser" implies some regularity of syntax) delimited the RE's 	 * based on its delimiter and not anything so irretrievably vulgar as a 	 * command syntax. 	 * 	 * Anyhow, the following code makes this all work.  First, for the 	 * special cases we move past their special argument(s).  Then, we 	 * do normal command processing on whatever is left.  Barf-O-Rama. 	 */
name|discard
operator|=
literal|0
expr_stmt|;
comment|/* Characters discarded from the command. */
name|arg1_len
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|save_cmd
operator|=
name|ecp
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_EDIT
index|]
operator|||
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_EX
index|]
operator|||
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_NEXT
index|]
operator|||
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_VISUAL_VI
index|]
operator|||
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_VSPLIT
index|]
condition|)
block|{
comment|/* 		 * Move to the next non-whitespace character.  A '!' 		 * immediately following the command is eaten as a 		 * force flag. 		 */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|>
literal|0
operator|&&
operator|*
name|ecp
operator|->
name|cp
operator|==
literal|'!'
condition|)
block|{
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_FORCE
argument_list|)
expr_stmt|;
comment|/* Reset, don't reparse. */
name|ecp
operator|->
name|save_cmd
operator|=
name|ecp
operator|->
name|cp
expr_stmt|;
block|}
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
if|if
condition|(
operator|!
name|cmdskip
argument_list|(
operator|*
name|ecp
operator|->
name|cp
argument_list|)
condition|)
break|break;
comment|/* 		 * QUOTING NOTE: 		 * 		 * The historic implementation ignored all escape characters 		 * so there was no way to put a space or newline into the +cmd 		 * field.  We do a simplistic job of fixing it by moving to the 		 * first whitespace character that isn't escaped.  The escaping 		 * characters are stripped as no longer useful. 		 */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|>
literal|0
operator|&&
operator|*
name|ecp
operator|->
name|cp
operator|==
literal|'+'
condition|)
block|{
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
for|for
control|(
name|arg1
operator|=
name|p
operator|=
name|ecp
operator|->
name|cp
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|ch
argument_list|)
operator|&&
name|ecp
operator|->
name|clen
operator|>
literal|1
condition|)
block|{
operator|++
name|discard
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
name|ch
operator|=
operator|*
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdskip
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
name|arg1_len
operator|=
name|ecp
operator|->
name|cp
operator|-
name|arg1
expr_stmt|;
comment|/* Reset, so the first argument isn't reparsed. */
name|ecp
operator|->
name|save_cmd
operator|=
name|ecp
operator|->
name|cp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_BANG
index|]
operator|||
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_GLOBAL
index|]
operator|||
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_V
index|]
condition|)
block|{
comment|/* 		 * QUOTING NOTE: 		 * 		 * We use backslashes to escape<newline> characters, although 		 * this wasn't historic practice for the bang command.  It was 		 * for the global and v commands, and it's common usage when 		 * doing text insert during the command.  Escaping characters 		 * are stripped as no longer useful. 		 */
for|for
control|(
name|p
operator|=
name|ecp
operator|->
name|cp
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|&&
name|ecp
operator|->
name|clen
operator|>
literal|1
operator|&&
name|ecp
operator|->
name|cp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|discard
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
name|ch
operator|=
operator|*
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|++
name|gp
operator|->
name|if_lno
expr_stmt|;
operator|++
name|ecp
operator|->
name|if_lno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_READ
index|]
operator|||
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_WRITE
index|]
condition|)
block|{
comment|/* 		 * For write commands, if the next character is a<blank>, and 		 * the next non-blank character is a '!', it's a filter command 		 * and we want to eat everything up to the<newline>.  For read 		 * commands, if the next non-blank character is a '!', it's a 		 * filter command and we want to eat everything up to the next 		 *<newline>.  Otherwise, we're done. 		 */
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|cmdskip
argument_list|(
name|ch
argument_list|)
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|ecp
operator|->
name|clen
operator|>
literal|0
operator|&&
name|ch
operator|==
literal|'!'
operator|&&
operator|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_READ
index|]
operator|||
name|tmp
operator|)
condition|)
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
if|if
condition|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_SUBSTITUTE
index|]
condition|)
block|{
comment|/* 		 * Move to the next non-whitespace character, we'll use it as 		 * the delimiter.  If the character isn't an alphanumeric or 		 * a '|', it's the delimiter, so parse it.  Otherwise, we're 		 * into something like ":s g", so use the special s command. 		 */
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
if|if
condition|(
operator|!
name|cmdskip
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
argument_list|)
operator|||
name|isalnum
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
argument_list|)
operator|||
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
name|ecp
operator|->
name|rcmd
operator|=
name|cmds
index|[
name|C_SUBSTITUTE
index|]
expr_stmt|;
name|ecp
operator|->
name|rcmd
operator|.
name|fn
operator|=
name|ex_subagain
expr_stmt|;
name|ecp
operator|->
name|cmd
operator|=
operator|&
name|ecp
operator|->
name|rcmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|)
block|{
comment|/* 			 * QUOTING NOTE: 			 * 			 * Backslashes quote delimiter characters for RE's. 			 * The backslashes are NOT removed since they'll be 			 * used by the RE code.  Move to the third delimiter 			 * that's not escaped (or the end of the command). 			 */
name|delim
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|2
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
operator|&&
name|cnt
operator|!=
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
if|if
condition|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ecp
operator|->
name|clen
operator|>
literal|1
condition|)
block|{
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
name|delim
condition|)
operator|--
name|cnt
expr_stmt|;
block|}
block|}
comment|/* 	 * Use normal quoting and termination rules to find the end of this 	 * command. 	 * 	 * QUOTING NOTE: 	 * 	 * Historically, vi permitted ^V's to escape<newline>'s in the .exrc 	 * file.  It was almost certainly a bug, but that's what bug-for-bug 	 * compatibility means, Grasshopper.  Also, ^V's escape the command 	 * delimiters.  Literal next quote characters in front of the newlines, 	 * '|' characters or literal next characters are stripped as they're 	 * no longer useful. 	 */
name|vi_address
operator|=
name|ecp
operator|->
name|clen
operator|!=
literal|0
operator|&&
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|!=
literal|'\n'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ecp
operator|->
name|cp
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
block|{
name|ch
operator|=
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|ch
argument_list|)
operator|&&
name|ecp
operator|->
name|clen
operator|>
literal|1
condition|)
block|{
name|CHAR_T
name|tmp
init|=
name|ecp
operator|->
name|cp
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'\n'
operator|||
name|tmp
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|gp
operator|->
name|if_lno
expr_stmt|;
operator|++
name|ecp
operator|->
name|if_lno
expr_stmt|;
block|}
operator|++
name|discard
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
name|ch
operator|=
name|tmp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_NEWLINE
argument_list|)
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
comment|/* 	 * Save off the next command information, go back to the 	 * original start of the command. 	 */
name|p
operator|=
name|ecp
operator|->
name|cp
operator|+
literal|1
expr_stmt|;
name|ecp
operator|->
name|cp
operator|=
name|ecp
operator|->
name|save_cmd
expr_stmt|;
name|ecp
operator|->
name|save_cmd
operator|=
name|p
expr_stmt|;
name|ecp
operator|->
name|save_cmdlen
operator|=
name|ecp
operator|->
name|clen
expr_stmt|;
name|ecp
operator|->
name|clen
operator|=
operator|(
operator|(
name|ecp
operator|->
name|save_cmd
operator|-
name|ecp
operator|->
name|cp
operator|)
operator|-
literal|1
operator|)
operator|-
name|discard
expr_stmt|;
comment|/* 	 * QUOTING NOTE: 	 * 	 * The "set tags" command historically used a backslash, not the 	 * user's literal next character, to escape whitespace.  Handle 	 * it here instead of complicating the argv_exp3() code.  Note, 	 * this isn't a particularly complex trap, and if backslashes were 	 * legal in set commands, this would have to be much more complicated. 	 */
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_SET
index|]
condition|)
for|for
control|(
name|p
operator|=
name|ecp
operator|->
name|cp
operator|,
name|len
operator|=
name|ecp
operator|->
name|clen
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|++
name|p
control|)
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
operator|*
name|p
argument_list|)
operator|&&
name|len
operator|>
literal|1
condition|)
block|{
operator|--
name|len
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
operator|*
name|p
operator|=
name|CH_LITERAL
expr_stmt|;
comment|/* 	 * Set the default addresses.  It's an error to specify an address for 	 * a command that doesn't take them.  If two addresses are specified 	 * for a command that only takes one, lose the first one.  Two special 	 * cases here, some commands take 0 or 2 addresses.  For most of them 	 * (the E_ADDR2_ALL flag), 0 defaults to the entire file.  For one 	 * (the `!' command, the E_ADDR2_NONE flag), 0 defaults to no lines. 	 * 	 * Also, if the file is empty, some commands want to use an address of 	 * 0, i.e. the entire file is 0 to 0, and the default first address is 	 * 0.  Otherwise, an entire file is 1 to N and the default line is 1. 	 * Note, we also add the E_ADDR_ZERO flag to the command flags, for the 	 * case where the 0 address is only valid if it's a default address. 	 * 	 * Also, set a flag if we set the default addresses.  Some commands 	 * (ex: z) care if the user specified an address or if we just used 	 * the current cursor. 	 */
switch|switch
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR1
operator||
name|E_ADDR2
operator||
name|E_ADDR2_ALL
operator||
name|E_ADDR2_NONE
argument_list|)
condition|)
block|{
case|case
name|E_ADDR1
case|:
comment|/* One address: */
switch|switch
condition|(
name|ecp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Default cursor/empty file. */
name|ecp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_ZERODEF
argument_list|)
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
block|}
else|else
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
comment|/* Lose the first address. */
name|ecp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|=
name|ecp
operator|->
name|addr2
expr_stmt|;
block|}
break|break;
case|case
name|E_ADDR2_NONE
case|:
comment|/* Zero/two addresses: */
if|if
condition|(
name|ecp
operator|->
name|addrcnt
operator|==
literal|0
condition|)
comment|/* Default to nothing. */
break|break;
goto|goto
name|two_addr
goto|;
case|case
name|E_ADDR2_ALL
case|:
comment|/* Zero/two addresses: */
if|if
condition|(
name|ecp
operator|->
name|addrcnt
operator|==
literal|0
condition|)
block|{
comment|/* Default entire/empty file. */
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_DEF
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ep
operator|==
name|NULL
condition|)
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|ecp
operator|->
name|addr2
operator|.
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_ZERODEF
argument_list|)
operator|&&
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|==
literal|0
condition|)
block|{
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR2_ALL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|E_ADDR2
case|:
comment|/* Two addresses: */
name|two_addr
label|:
switch|switch
condition|(
name|ecp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Default cursor/empty file. */
name|ecp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
literal|1
operator|&&
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_ZERODEF
argument_list|)
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
block|}
else|else
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Default to first address. */
name|ecp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|ecp
operator|->
name|addr2
operator|=
name|ecp
operator|->
name|addr1
expr_stmt|;
break|break;
case|case
literal|2
case|:
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|ecp
operator|->
name|addrcnt
condition|)
comment|/* Error. */
goto|goto
name|usage
goto|;
block|}
comment|/* 	 * !!! 	 * The ^D scroll command historically scrolled the value of the scroll 	 * option or to EOF.  It was an error if the cursor was already at EOF. 	 * (Leading addresses were permitted, but were then ignored.) 	 */
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_SCROLL
index|]
condition|)
block|{
name|ecp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SCROLL
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|lno
operator|!=
literal|0
operator|&&
name|lno
operator|>
name|sp
operator|->
name|lno
operator|&&
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|>
name|lno
condition|)
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
block|}
name|ecp
operator|->
name|flagoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|ecp
operator|->
name|cmd
operator|->
name|syntax
init|;
operator|*
name|np
operator|!=
literal|'\0'
condition|;
operator|++
name|np
control|)
block|{
comment|/* 		 * The force flag is sensitive to leading whitespace, i.e. 		 * "next !" is different from "next!".  Handle it before 		 * skipping leading<blank>s. 		 */
if|if
condition|(
operator|*
name|np
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|ecp
operator|->
name|clen
operator|>
literal|0
operator|&&
operator|*
name|ecp
operator|->
name|cp
operator|==
literal|'!'
condition|)
block|{
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_FORCE
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Skip leading<blank>s. */
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
if|if
condition|(
operator|!
name|cmdskip
argument_list|(
operator|*
name|ecp
operator|->
name|cp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ecp
operator|->
name|clen
operator|==
literal|0
condition|)
break|break;
switch|switch
condition|(
operator|*
name|np
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* +, -, #, l, p */
comment|/* 			 * !!! 			 * Historically, some flags were ignored depending 			 * on where they occurred in the command line.  For 			 * example, in the command, ":3+++p--#", historic vi 			 * acted on the '#' flag, but ignored the '-' flags. 			 * It's unambiguous what the flags mean, so we just 			 * handle them regardless of the stupidity of their 			 * location. 			 */
for|for
control|(
init|;
name|ecp
operator|->
name|clen
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
switch|switch
condition|(
operator|*
name|ecp
operator|->
name|cp
condition|)
block|{
case|case
literal|'+'
case|:
operator|++
name|ecp
operator|->
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'^'
case|:
operator|--
name|ecp
operator|->
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_OPTNUM
argument_list|)
expr_stmt|;
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_HASH
argument_list|)
expr_stmt|;
name|exp
operator|->
name|fdef
operator||=
name|E_C_HASH
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_LIST
argument_list|)
expr_stmt|;
name|exp
operator|->
name|fdef
operator||=
name|E_C_LIST
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_PRINT
argument_list|)
expr_stmt|;
name|exp
operator|->
name|fdef
operator||=
name|E_C_PRINT
expr_stmt|;
break|break;
default|default:
goto|goto
name|end_case1
goto|;
block|}
name|end_case1
label|:
break|break;
case|case
literal|'2'
case|:
comment|/* -, ., +, ^ */
case|case
literal|'3'
case|:
comment|/* -, ., +, ^, = */
for|for
control|(
init|;
name|ecp
operator|->
name|clen
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
switch|switch
condition|(
operator|*
name|ecp
operator|->
name|cp
condition|)
block|{
case|case
literal|'-'
case|:
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_DASH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_DOT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_PLUS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_CARAT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
operator|*
name|np
operator|==
literal|'3'
condition|)
block|{
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_EQUAL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
goto|goto
name|end_case23
goto|;
block|}
name|end_case23
label|:
break|break;
case|case
literal|'b'
case|:
comment|/* buffer */
comment|/* 			 * !!! 			 * Historically, "d #" was a delete with a flag, not a 			 * delete into the '#' buffer.  If the current command 			 * permits a flag, don't use one as a buffer.  However, 			 * the 'l' and 'p' flags were legal buffer names in the 			 * historic ex, and were used as buffers, not flags. 			 */
if|if
condition|(
operator|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'^'
operator|||
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
operator|&&
name|strchr
argument_list|(
name|np
argument_list|,
literal|'1'
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
comment|/* 			 * !!! 			 * Digits can't be buffer names in ex commands, or the 			 * command "d2" would be a delete into buffer '2', and 			 * not a two-line deletion. 			 */
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|ecp
operator|->
name|buffer
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_BUFFER
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* count [01+a] */
operator|++
name|np
expr_stmt|;
comment|/* Validate any signed value. */
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|ecp
operator|->
name|cp
argument_list|)
operator|&&
operator|(
operator|*
name|np
operator|!=
literal|'+'
operator|||
operator|(
operator|*
name|ecp
operator|->
name|cp
operator|!=
literal|'+'
operator|&&
operator|*
name|ecp
operator|->
name|cp
operator|!=
literal|'-'
operator|)
operator|)
condition|)
break|break;
comment|/* If a signed value, set appropriate flags. */
if|if
condition|(
operator|*
name|ecp
operator|->
name|cp
operator|==
literal|'-'
condition|)
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_COUNT_NEG
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ecp
operator|->
name|cp
operator|==
literal|'+'
condition|)
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_COUNT_POS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nret
operator|=
name|nget_slong
argument_list|(
operator|&
name|ltmp
argument_list|,
name|ecp
operator|->
name|cp
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
operator|)
operator|!=
name|NUM_OK
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_NOTSET
argument_list|,
name|nret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ltmp
operator|==
literal|0
operator|&&
operator|*
name|np
operator|!=
literal|'0'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"083|Count may not be zero"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ecp
operator|->
name|clen
operator|-=
operator|(
name|t
operator|-
name|ecp
operator|->
name|cp
operator|)
expr_stmt|;
name|ecp
operator|->
name|cp
operator|=
name|t
expr_stmt|;
comment|/* 			 * Counts as address offsets occur in commands taking 			 * two addresses.  Historic vi practice was to use 			 * the count as an offset from the *second* address. 			 * 			 * Set a count flag; some underlying commands (see 			 * join) do different things with counts than with 			 * line addresses. 			 */
if|if
condition|(
operator|*
name|np
operator|==
literal|'a'
condition|)
block|{
name|ecp
operator|->
name|addr1
operator|=
name|ecp
operator|->
name|addr2
expr_stmt|;
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|+
name|ltmp
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|ecp
operator|->
name|count
operator|=
name|ltmp
expr_stmt|;
name|FL_SET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_COUNT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* file */
if|if
condition|(
name|argv_exp2
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|ecp
operator|->
name|cp
argument_list|,
name|ecp
operator|->
name|clen
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|arg_cnt_chk
goto|;
case|case
literal|'l'
case|:
comment|/* line */
comment|/* 			 * Get a line specification. 			 * 			 * If the line was a search expression, we may have 			 * changed state during the call, and we're now 			 * searching the file.  Push ourselves onto the state 			 * stack. 			 */
if|if
condition|(
name|ex_line
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|isaddr
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
goto|goto
name|rfail
goto|;
if|if
condition|(
name|tmp
condition|)
goto|goto
name|err
goto|;
comment|/* Line specifications are always required. */
if|if
condition|(
operator|!
name|isaddr
condition|)
block|{
name|msgq_wstr
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|ecp
operator|->
name|cp
argument_list|,
literal|"084|%s: bad line specification"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 			 * The target line should exist for these commands, 			 * but 0 is legal for them as well. 			 */
if|if
condition|(
name|cur
operator|.
name|lno
operator|!=
literal|0
operator|&&
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|cur
operator|.
name|lno
argument_list|)
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_EOF
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ecp
operator|->
name|lineno
operator|=
name|cur
operator|.
name|lno
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* string, file exp. */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|argv_exp1
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|ecp
operator|->
name|cp
argument_list|,
name|ecp
operator|->
name|clen
argument_list|,
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_BANG
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|addr_verify
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'s'
case|:
comment|/* string */
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|ecp
operator|->
name|cp
argument_list|,
name|ecp
operator|->
name|clen
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|addr_verify
goto|;
case|case
literal|'W'
case|:
comment|/* word string */
comment|/* 			 * QUOTING NOTE: 			 * 			 * Literal next characters escape the following 			 * character.  Quoting characters are stripped here 			 * since they are no longer useful. 			 * 			 * First there was the word. 			 */
for|for
control|(
name|p
operator|=
name|t
operator|=
name|ecp
operator|->
name|cp
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|ch
argument_list|)
operator|&&
name|ecp
operator|->
name|clen
operator|>
literal|1
condition|)
block|{
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdskip
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|t
argument_list|,
name|p
operator|-
name|t
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Delete intervening whitespace. */
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|cmdskip
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ecp
operator|->
name|clen
operator|==
literal|0
condition|)
goto|goto
name|usage
goto|;
comment|/* Followed by the string. */
for|for
control|(
name|p
operator|=
name|t
operator|=
name|ecp
operator|->
name|cp
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
operator|,
operator|++
name|ecp
operator|->
name|cp
operator|,
operator|++
name|p
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|ch
argument_list|)
operator|&&
name|ecp
operator|->
name|clen
operator|>
literal|1
condition|)
block|{
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
operator|*
name|p
operator|=
operator|*
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|t
argument_list|,
name|p
operator|-
name|t
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|addr_verify
goto|;
case|case
literal|'w'
case|:
comment|/* word */
if|if
condition|(
name|argv_exp3
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|ecp
operator|->
name|cp
argument_list|,
name|ecp
operator|->
name|clen
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|arg_cnt_chk
label|:
if|if
condition|(
operator|*
operator|++
name|np
operator|!=
literal|'N'
condition|)
block|{
comment|/* N */
comment|/* 				 * If a number is specified, must either be 				 * 0 or that number, if optional, and that 				 * number, if required. 				 */
name|tmp
operator|=
operator|*
name|np
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|++
name|np
operator|!=
literal|'o'
operator|||
name|exp
operator|->
name|argsoff
operator|!=
literal|0
operator|)
operator|&&
name|exp
operator|->
name|argsoff
operator|!=
name|tmp
condition|)
goto|goto
name|usage
goto|;
block|}
goto|goto
name|addr_verify
goto|;
default|default:
block|{
name|size_t
name|nlen
decl_stmt|;
name|char
modifier|*
name|nstr
decl_stmt|;
name|INT2CHAR
argument_list|(
name|sp
argument_list|,
name|ecp
operator|->
name|cmd
operator|->
name|name
argument_list|,
name|STRLEN
argument_list|(
name|ecp
operator|->
name|cmd
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|nstr
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"085|Internal syntax table error (%s: %s)"
argument_list|,
name|nstr
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Skip trailing whitespace. */
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
operator|--
name|ecp
operator|->
name|clen
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|cmdskip
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * There shouldn't be anything left, and no more required fields, 	 * i.e neither 'l' or 'r' in the syntax string. 	 */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|!=
literal|0
operator|||
name|strpbrk
argument_list|(
name|np
argument_list|,
literal|"lr"
argument_list|)
condition|)
block|{
name|usage
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"086|Usage: %s"
argument_list|,
name|ecp
operator|->
name|cmd
operator|->
name|usage
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * Verify that the addresses are legal.  Check the addresses here, 	 * because this is a place where all ex addresses pass through. 	 * (They don't all pass through ex_line(), for instance.)  We're 	 * assuming that any non-existent line doesn't exist because it's 	 * past the end-of-file.  That's a pretty good guess. 	 * 	 * If it's a "default vi command", an address of zero is okay. 	 */
name|addr_verify
label|:
switch|switch
condition|(
name|ecp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|2
case|:
comment|/* 		 * Historic ex/vi permitted commands with counts to go past 		 * EOF.  So, for example, if the file only had 5 lines, the 		 * ex command "1,6>" would fail, but the command ">300" 		 * would succeed.  Since we don't want to have to make all 		 * of the underlying commands handle random line numbers, 		 * fix it here. 		 */
if|if
condition|(
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_ZERO
argument_list|)
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
operator|||
operator|!
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_USELASTCMD
argument_list|)
operator|)
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|ecp
operator|->
name|cmd
argument_list|,
name|A_ZERO
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|ecp
operator|->
name|addr2
operator|.
name|lno
argument_list|)
condition|)
if|if
condition|(
name|FL_ISSET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_COUNT
argument_list|)
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
block|}
else|else
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_EOF
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
if|if
condition|(
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_ADDR_ZERO
argument_list|)
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
operator|||
operator|!
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_USELASTCMD
argument_list|)
operator|)
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|ecp
operator|->
name|cmd
argument_list|,
name|A_ZERO
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|ecp
operator|->
name|addr1
operator|.
name|lno
argument_list|)
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_EOF
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
block|}
comment|/* 	 * If doing a default command and there's nothing left on the line, 	 * vi just moves to the line.  For example, ":3" and ":'a,'b" just 	 * move to line 3 and line 'b, respectively, but ":3|" prints line 3. 	 * 	 * !!! 	 * In addition, IF THE LINE CHANGES, move to the first nonblank of 	 * the line. 	 * 	 * !!! 	 * This is done before the absolute mark gets set; historically, 	 * "/a/,/b/" did NOT set vi's absolute mark, but "/a/,/b/d" did. 	 */
if|if
condition|(
operator|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_NOPRDEF
argument_list|)
operator|)
operator|&&
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_USELASTCMD
argument_list|)
operator|&&
name|vi_address
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|ecp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|sp
operator|->
name|lno
operator|!=
operator|(
name|ecp
operator|->
name|addr2
operator|.
name|lno
condition|?
name|ecp
operator|->
name|addr2
operator|.
name|lno
else|:
literal|1
operator|)
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|lno
condition|?
name|ecp
operator|->
name|addr2
operator|.
name|lno
else|:
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nonblank
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|sp
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|sp
operator|->
name|lno
operator|!=
operator|(
name|ecp
operator|->
name|addr1
operator|.
name|lno
condition|?
name|ecp
operator|->
name|addr1
operator|.
name|lno
else|:
literal|1
operator|)
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|ecp
operator|->
name|addr1
operator|.
name|lno
condition|?
name|ecp
operator|->
name|addr1
operator|.
name|lno
else|:
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nonblank
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|sp
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|ecp
operator|->
name|cp
operator|=
name|ecp
operator|->
name|save_cmd
expr_stmt|;
name|ecp
operator|->
name|clen
operator|=
name|ecp
operator|->
name|save_cmdlen
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* 	 * Set the absolute mark -- we have to set it for vi here, in case 	 * it's a compound command, e.g. ":5p|6" should set the absolute 	 * mark for vi. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_ABSMARK
argument_list|)
condition|)
block|{
name|cur
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cur
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_ABSMARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_set
argument_list|(
name|sp
argument_list|,
name|ABSMARK1
argument_list|,
operator|&
name|cur
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMLOG
argument_list|)
name|ex_comlog
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Increment the command count if not called from vi. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
operator|++
name|sp
operator|->
name|ccnt
expr_stmt|;
comment|/* 	 * If file state available, and not doing a global command, 	 * log the start of an action. 	 */
if|if
condition|(
name|sp
operator|->
name|ep
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX_GLOBAL
argument_list|)
condition|)
operator|(
name|void
operator|)
name|log_cursor
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * !!! 	 * There are two special commands for the purposes of this code: the 	 * default command (<carriage-return>) or the scrolling commands (^D 	 * and<EOF>) as the first non-<blank> characters  in the line. 	 * 	 * If this is the first command in the command line, we received the 	 * command from the ex command loop and we're talking to a tty, and 	 * and there's nothing else on the command line, and it's one of the 	 * special commands, we move back up to the previous line, and erase 	 * the prompt character with the output.  Since ex runs in canonical 	 * mode, we don't have to do anything else, a<newline> has already 	 * been echoed by the tty driver.  It's OK if vi calls us -- we won't 	 * be in ex mode so we'll do nothing. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_NRSEP
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|ep
operator|!=
name|NULL
operator|&&
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_SCRIPTED
argument_list|)
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_USELASTCMD
argument_list|)
operator|||
name|ecp
operator|->
name|cmd
operator|==
operator|&
name|cmds
index|[
name|C_SCROLL
index|]
operator|)
condition|)
name|gp
operator|->
name|scr_ex_adjust
argument_list|(
name|sp
argument_list|,
name|EX_TERM_SCROLL
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_NRSEP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Call the underlying function for the ex command. 	 * 	 * XXX 	 * Interrupts behave like errors, for now. 	 */
if|if
condition|(
name|ecp
operator|->
name|cmd
operator|->
name|fn
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|)
operator|||
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_SCRIPTED
argument_list|)
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT_FORCE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Make sure no function left global temporary space locked. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
expr_stmt|;
name|msgq_wstr
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|ecp
operator|->
name|cmd
operator|->
name|name
argument_list|,
literal|"087|%s: temporary buffer not released"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Ex displayed the number of lines modified immediately after each 	 * command, so the command "1,10d|1,10d" would display: 	 * 	 *	10 lines deleted 	 *	10 lines deleted 	 *<autoprint line> 	 * 	 * Executing ex commands from vi only reported the final modified 	 * lines message -- that's wrong enough that we don't match it. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
name|mod_rpt
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Integrate any offset parsed by the underlying command, and make 	 * sure the referenced line exists. 	 * 	 * XXX 	 * May not match historic practice (which I've never been able to 	 * completely figure out.)  For example, the '=' command from vi 	 * mode often got the offset wrong, and complained it was too large, 	 * but didn't seem to have a problem with the cursor.  If anyone 	 * complains, ask them how it's supposed to work, they might know. 	 */
if|if
condition|(
name|sp
operator|->
name|ep
operator|!=
name|NULL
operator|&&
name|ecp
operator|->
name|flagoff
condition|)
block|{
if|if
condition|(
name|ecp
operator|->
name|flagoff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|lno
operator|<=
operator|-
name|ecp
operator|->
name|flagoff
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"088|Flag offset to before line 1"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|NPFITS
argument_list|(
name|MAX_REC_NUMBER
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
name|ecp
operator|->
name|flagoff
argument_list|)
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_NOTSET
argument_list|,
name|NUM_OVER
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|db_exist
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
operator|+
name|ecp
operator|->
name|flagoff
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"089|Flag offset past end-of-file"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|sp
operator|->
name|lno
operator|+=
name|ecp
operator|->
name|flagoff
expr_stmt|;
block|}
comment|/* 	 * If the command executed successfully, we may want to display a line 	 * based on the autoprint option or an explicit print flag.  (Make sure 	 * that there's a line to display.)  Also, the autoprint edit option is 	 * turned off for the duration of global commands. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
operator|&&
name|sp
operator|->
name|ep
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|lno
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The print commands have already handled the `print' flags. 		 * If so, clear them. 		 */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_CLRFLAG
argument_list|)
condition|)
name|FL_CLR
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_HASH
operator||
name|E_C_LIST
operator||
name|E_C_PRINT
argument_list|)
expr_stmt|;
comment|/* If hash set only because of the number option, discard it. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_OPTNUM
argument_list|)
condition|)
name|FL_CLR
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_HASH
argument_list|)
expr_stmt|;
comment|/* 		 * If there was an explicit flag to display the new cursor line, 		 * or autoprint is set and a change was made, display the line. 		 * If any print flags were set use them, else default to print. 		 */
name|LF_INIT
argument_list|(
name|FL_ISSET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_HASH
operator||
name|E_C_LIST
operator||
name|E_C_PRINT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|E_C_HASH
operator||
name|E_C_LIST
operator||
name|E_C_PRINT
operator||
name|E_NOAUTO
argument_list|)
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX_GLOBAL
argument_list|)
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOPRINT
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_AUTOPRINT
argument_list|)
condition|)
name|LF_INIT
argument_list|(
name|E_C_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_C_HASH
operator||
name|E_C_LIST
operator||
name|E_C_PRINT
argument_list|)
condition|)
block|{
name|cur
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cur
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|ex_print
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|cur
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the command had an associated "+cmd", it has to be executed 	 * before we finish executing any more of this ex command.  For 	 * example, consider a .exrc file that contains the following lines: 	 * 	 *	:set all 	 *	:edit +25 file.c|s/abc/ABC/|1 	 *	:3,5 print 	 * 	 * This can happen more than once -- the historic vi simply hung or 	 * dropped core, of course.  Prepend the + command back into the 	 * current command and continue.  We may have to add an additional 	 *<literal next> character.  We know that it will fit because we 	 * discarded at least one space and the + character. 	 */
if|if
condition|(
name|arg1_len
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If the last character of the + command was a<literal next> 		 * character, it would be treated differently because of the 		 * append.  Quote it, if necessary. 		 */
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|arg1
index|[
name|arg1_len
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
operator|*
operator|--
name|ecp
operator|->
name|save_cmd
operator|=
name|CH_LITERAL
expr_stmt|;
operator|++
name|ecp
operator|->
name|save_cmdlen
expr_stmt|;
block|}
name|ecp
operator|->
name|save_cmd
operator|-=
name|arg1_len
expr_stmt|;
name|ecp
operator|->
name|save_cmdlen
operator|+=
name|arg1_len
expr_stmt|;
name|MEMCPY
argument_list|(
name|ecp
operator|->
name|save_cmd
argument_list|,
name|arg1
argument_list|,
name|arg1_len
argument_list|)
expr_stmt|;
comment|/* 		 * Any commands executed from a +cmd are executed starting at 		 * the first column of the last line of the file -- NOT the 		 * first nonblank.)  The main file startup code doesn't know 		 * that a +cmd was set, however, so it may have put us at the 		 * top of the file.  (Note, this is safe because we must have 		 * switched files to get here.) 		 */
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_MOVETOEND
argument_list|)
expr_stmt|;
block|}
comment|/* Update the current command. */
name|ecp
operator|->
name|cp
operator|=
name|ecp
operator|->
name|save_cmd
expr_stmt|;
name|ecp
operator|->
name|clen
operator|=
name|ecp
operator|->
name|save_cmdlen
expr_stmt|;
comment|/* 	 * !!! 	 * If we've changed screens or underlying files, any pending global or 	 * v command, or @ buffer that has associated addresses, has to be 	 * discarded.  This is historic practice for globals, and necessary for 	 * @ buffers that had associated addresses. 	 * 	 * Otherwise, if we've changed underlying files, it's not a problem, 	 * we continue with the rest of the ex command(s), operating on the 	 * new file.  However, if we switch screens (either by exiting or by 	 * an explicit command), we have no way of knowing where to put output 	 * messages, and, since we don't control screens here, we could screw 	 * up the upper layers, (e.g. we could exit/reenter a screen multiple 	 * times).  So, return and continue after we've got a new screen. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT
operator||
name|SC_EXIT_FORCE
operator||
name|SC_FSWITCH
operator||
name|SC_SSWITCH
argument_list|)
condition|)
block|{
name|at_found
operator|=
name|gv_found
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ecp
argument_list|,
argument|sp->gp->ecq
argument_list|,
argument|q
argument_list|)
switch|switch
condition|(
name|ecp
operator|->
name|agv_flags
condition|)
block|{
case|case
literal|0
case|:
case|case
name|AGV_AT_NORANGE
case|:
break|break;
case|case
name|AGV_AT
case|:
if|if
condition|(
operator|!
name|at_found
condition|)
block|{
name|at_found
operator|=
literal|1
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"090|@ with range running when the file/screen changed"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AGV_GLOBAL
case|:
case|case
name|AGV_V
case|:
if|if
condition|(
operator|!
name|gv_found
condition|)
block|{
name|gv_found
operator|=
literal|1
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"091|Global/v command running when the file/screen changed"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|at_found
operator|||
name|gv_found
condition|)
goto|goto
name|discard
goto|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT
operator||
name|SC_EXIT_FORCE
operator||
name|SC_SSWITCH
argument_list|)
condition|)
goto|goto
name|rsuccess
goto|;
block|}
goto|goto
name|loop
goto|;
comment|/* NOTREACHED */
name|err
label|:
comment|/* 	 * On command failure, we discard keys and pending commands remaining, 	 * as well as any keys that were mapped and waiting.  The save_cmdlen 	 * test is not necessarily correct.  If we fail early enough we don't 	 * know if the entire string was a single command or not.  Guess, as 	 * it's useful to know if commands other than the current one are being 	 * discarded. 	 */
if|if
condition|(
name|ecp
operator|->
name|save_cmdlen
operator|==
literal|0
condition|)
for|for
control|(
init|;
name|ecp
operator|->
name|clen
condition|;
operator|--
name|ecp
operator|->
name|clen
control|)
block|{
name|ch
operator|=
operator|*
name|ecp
operator|->
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
name|ch
argument_list|)
operator|&&
name|ecp
operator|->
name|clen
operator|>
literal|1
condition|)
block|{
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|ecp
operator|->
name|clen
operator|>
literal|1
condition|)
name|ecp
operator|->
name|save_cmdlen
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ecp
operator|->
name|save_cmdlen
operator|!=
literal|0
operator|||
name|SLIST_FIRST
argument_list|(
name|gp
operator|->
name|ecq
argument_list|)
operator|!=
operator|&
name|gp
operator|->
name|excmd
condition|)
block|{
name|discard
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"092|Ex command failed: pending commands discarded"
argument_list|)
expr_stmt|;
name|ex_discard
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v_event_flush
argument_list|(
name|sp
argument_list|,
name|CH_MAPPED
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"093|Ex command failed: mapped keys discarded"
argument_list|)
expr_stmt|;
name|rfail
label|:
name|tmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|rsuccess
label|:
name|tmp
operator|=
literal|0
expr_stmt|;
comment|/* Turn off any file name error information. */
name|gp
operator|->
name|if_name
operator|=
name|NULL
expr_stmt|;
comment|/* Turn off the global bit. */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_EX_GLOBAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_range --  *	Get a line range for ex commands, or perform a vi ex address search.  *  * PUBLIC: int ex_range(SCR *, EXCMD *, int *);  */
end_comment

begin_function
name|int
name|ex_range
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|ecp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
enum|enum
block|{
name|ADDR_FOUND
block|,
name|ADDR_NEED
block|,
name|ADDR_NONE
block|}
name|addr
enum|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|int
name|isaddr
decl_stmt|;
operator|*
name|errp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Parse comma or semi-colon delimited line specs. 	 * 	 * Semi-colon delimiters update the current address to be the last 	 * address.  For example, the command 	 * 	 *	:3;/pattern/ecp->cp 	 * 	 * will search for pattern from line 3.  In addition, if ecp->cp 	 * is not a valid command, the current line will be left at 3, not 	 * at the original address. 	 * 	 * Extra addresses are discarded, starting with the first. 	 * 	 * !!! 	 * If any addresses are missing, they default to the current line. 	 * This was historically true for both leading and trailing comma 	 * delimited addresses as well as for trailing semicolon delimited 	 * addresses.  For consistency, we make it true for leading semicolon 	 * addresses as well. 	 */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|ADDR_NONE
operator|,
name|ecp
operator|->
name|addrcnt
operator|=
literal|0
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
condition|;
control|)
switch|switch
condition|(
operator|*
name|ecp
operator|->
name|cp
condition|)
block|{
case|case
literal|'%'
case|:
comment|/* Entire file. */
comment|/* Vi ex address searches didn't permit % signs. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_VISEARCH
argument_list|)
condition|)
goto|goto
name|ret
goto|;
comment|/* It's an error if the file is empty. */
if|if
condition|(
name|sp
operator|->
name|ep
operator|==
name|NULL
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_EMPTY
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * !!! 			 * A percent character addresses all of the lines in 			 * the file.  Historically, it couldn't be followed by 			 * any other address.  We do it as a text substitution 			 * for simplicity.  POSIX 1003.2 is expected to follow 			 * this practice. 			 * 			 * If it's an empty file, the first line is 0, not 1. 			 */
if|if
condition|(
name|addr
operator|==
name|ADDR_FOUND
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_COMBO
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|ecp
operator|->
name|addr2
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|addr
operator|=
name|ADDR_FOUND
expr_stmt|;
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
break|break;
case|case
literal|','
case|:
comment|/* Comma delimiter. */
comment|/* Vi ex address searches didn't permit commas. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_VISEARCH
argument_list|)
condition|)
goto|goto
name|ret
goto|;
comment|/* FALLTHROUGH */
case|case
literal|';'
case|:
comment|/* Semi-colon delimiter. */
if|if
condition|(
name|sp
operator|->
name|ep
operator|==
name|NULL
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_EMPTY
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|addr
operator|!=
name|ADDR_FOUND
condition|)
switch|switch
condition|(
name|ecp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|ecp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ecp
operator|->
name|addr1
operator|=
name|ecp
operator|->
name|addr2
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|ecp
operator|->
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|ecp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|ecp
operator|->
name|cp
operator|==
literal|';'
condition|)
switch|switch
condition|(
name|ecp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|1
case|:
name|sp
operator|->
name|lno
operator|=
name|ecp
operator|->
name|addr1
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|ecp
operator|->
name|addr1
operator|.
name|cno
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sp
operator|->
name|lno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|ecp
operator|->
name|addr2
operator|.
name|cno
expr_stmt|;
break|break;
block|}
name|addr
operator|=
name|ADDR_NEED
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|' '
case|:
comment|/* Whitespace. */
case|case
literal|'\t'
case|:
comment|/* Whitespace. */
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
break|break;
default|default:
comment|/* Get a line specification. */
if|if
condition|(
name|ex_line
argument_list|(
name|sp
argument_list|,
name|ecp
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|isaddr
argument_list|,
name|errp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|errp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|isaddr
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|addr
operator|==
name|ADDR_FOUND
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_COMBO
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|ecp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
name|ecp
operator|->
name|addr1
operator|=
name|m
expr_stmt|;
name|ecp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ecp
operator|->
name|addr2
operator|=
name|m
expr_stmt|;
name|ecp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ecp
operator|->
name|addr1
operator|=
name|ecp
operator|->
name|addr2
expr_stmt|;
name|ecp
operator|->
name|addr2
operator|=
name|m
expr_stmt|;
break|break;
block|}
name|addr
operator|=
name|ADDR_FOUND
expr_stmt|;
break|break;
block|}
comment|/* 	 * !!! 	 * Vi ex address searches are indifferent to order or trailing 	 * semi-colons. 	 */
name|ret
label|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_VISEARCH
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|addr
operator|==
name|ADDR_NEED
condition|)
switch|switch
condition|(
name|ecp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
name|ecp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|ecp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|ecp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ecp
operator|->
name|addr1
operator|=
name|ecp
operator|->
name|addr2
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|ecp
operator|->
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|ecp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ecp
operator|->
name|addrcnt
operator|==
literal|2
operator|&&
name|ecp
operator|->
name|addr2
operator|.
name|lno
operator|<
name|ecp
operator|->
name|addr1
operator|.
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"094|The second address is smaller than the first"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_line --  *	Get a single line address specifier.  *  * The way the "previous context" mark worked was that any "non-relative"  * motion set it.  While ex/vi wasn't totally consistent about this, ANY  * numeric address, search pattern, '$', or mark reference in an address  * was considered non-relative, and set the value.  Which should explain  * why we're hacking marks down here.  The problem was that the mark was  * only set if the command was called, i.e. we have to set a flag and test  * it later.  *  * XXX  * This is probably still not exactly historic practice, although I think  * it's fairly close.  */
end_comment

begin_function
specifier|static
name|int
name|ex_line
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|EXCMD
modifier|*
name|ecp
parameter_list|,
name|MARK
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|isaddrp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|enum
name|nresult
name|nret
decl_stmt|;
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|long
name|total
decl_stmt|,
name|val
decl_stmt|;
name|int
name|isneg
decl_stmt|;
name|int
function_decl|(
modifier|*
name|sf
function_decl|)
parameter_list|(
name|SCR
modifier|*
parameter_list|,
name|MARK
modifier|*
parameter_list|,
name|MARK
modifier|*
parameter_list|,
name|CHAR_T
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|CHAR_T
modifier|*
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
name|CHAR_T
modifier|*
name|endp
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|*
name|isaddrp
operator|=
operator|*
name|errp
operator|=
literal|0
expr_stmt|;
name|F_CLR
argument_list|(
name|ecp
argument_list|,
name|E_DELTA
argument_list|)
expr_stmt|;
comment|/* No addresses permitted until a file has been read in. */
if|if
condition|(
name|sp
operator|->
name|ep
operator|==
name|NULL
operator|&&
name|STRCHR
argument_list|(
name|L
argument_list|(
literal|"$0123456789'\\/?.+-^"
argument_list|)
argument_list|,
operator|*
name|ecp
operator|->
name|cp
argument_list|)
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_EMPTY
argument_list|,
name|NUM_OK
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
operator|*
name|ecp
operator|->
name|cp
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* Last line in the file. */
operator|*
name|isaddrp
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ABSMARK
argument_list|)
expr_stmt|;
name|mp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|mp
operator|->
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
break|break;
comment|/* Absolute line number. */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
operator|*
name|isaddrp
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ABSMARK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nret
operator|=
name|nget_slong
argument_list|(
operator|&
name|val
argument_list|,
name|ecp
operator|->
name|cp
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
operator|)
operator|!=
name|NUM_OK
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_NOTSET
argument_list|,
name|nret
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|NPFITS
argument_list|(
name|MAX_REC_NUMBER
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_NOTSET
argument_list|,
name|NUM_OVER
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mp
operator|->
name|lno
operator|=
name|val
expr_stmt|;
name|mp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|clen
operator|-=
operator|(
name|endp
operator|-
name|ecp
operator|->
name|cp
operator|)
expr_stmt|;
name|ecp
operator|->
name|cp
operator|=
name|endp
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
comment|/* Use a mark. */
operator|*
name|isaddrp
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ABSMARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|clen
operator|==
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"095|No mark name supplied"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|mark_get
argument_list|(
name|sp
argument_list|,
name|ecp
operator|->
name|cp
index|[
literal|1
index|]
argument_list|,
name|mp
argument_list|,
name|M_ERR
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ecp
operator|->
name|cp
operator|+=
literal|2
expr_stmt|;
name|ecp
operator|->
name|clen
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Search: forward/backward. */
comment|/* 		 * !!! 		 * I can't find any difference between // and \/ or between 		 * ?? and \?.  Mark Horton doesn't remember there being any 		 * difference.  C'est la vie. 		 */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|<
literal|2
operator|||
operator|(
name|ecp
operator|->
name|cp
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|ecp
operator|->
name|cp
index|[
literal|1
index|]
operator|!=
literal|'?'
operator|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"096|\\ not followed by / or ?"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
name|sf
operator|=
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'/'
condition|?
name|f_search
else|:
name|b_search
expr_stmt|;
goto|goto
name|search
goto|;
case|case
literal|'/'
case|:
comment|/* Search forward. */
name|sf
operator|=
name|f_search
expr_stmt|;
goto|goto
name|search
goto|;
case|case
literal|'?'
case|:
comment|/* Search backward. */
name|sf
operator|=
name|b_search
expr_stmt|;
name|search
label|:
name|mp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|mp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|sf
argument_list|(
name|sp
argument_list|,
name|mp
argument_list|,
name|mp
argument_list|,
name|ecp
operator|->
name|cp
argument_list|,
name|ecp
operator|->
name|clen
argument_list|,
operator|&
name|endp
argument_list|,
name|SEARCH_MSG
operator||
name|SEARCH_PARSE
operator||
name|SEARCH_SET
operator||
operator|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_SEARCH_WMSG
argument_list|)
condition|?
name|SEARCH_WMSG
else|:
literal|0
operator|)
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Fix up the command pointers. */
name|ecp
operator|->
name|clen
operator|-=
operator|(
name|endp
operator|-
name|ecp
operator|->
name|cp
operator|)
expr_stmt|;
name|ecp
operator|->
name|cp
operator|=
name|endp
expr_stmt|;
operator|*
name|isaddrp
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_ABSMARK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
comment|/* Current position. */
operator|*
name|isaddrp
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* If an empty file, then '.' is 0, not 1. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|mp
operator|->
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|mp
operator|->
name|lno
operator|!=
literal|0
condition|)
name|mp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
comment|/* 		 * !!! 		 * Historically, .<number> was the same as .+<number>, i.e. 		 * the '+' could be omitted.  (This feature is found in ed 		 * as well.) 		 */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|>
literal|1
operator|&&
name|ISDIGIT
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|ecp
operator|->
name|cp
operator|=
literal|'+'
expr_stmt|;
else|else
block|{
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
block|}
break|break;
block|}
comment|/* Skip trailing<blank>s. */
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
operator|&&
name|cmdskip
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|ecp
operator|->
name|cp
operator|,
operator|--
name|ecp
operator|->
name|clen
control|)
empty_stmt|;
comment|/* 	 * Evaluate any offset.  If no address yet found, the offset 	 * is relative to ".". 	 */
name|total
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|clen
operator|!=
literal|0
operator|&&
operator|(
name|ISDIGIT
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
argument_list|)
operator|||
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'^'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|isaddrp
condition|)
block|{
operator|*
name|isaddrp
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|mp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
comment|/* 		 * Evaluate an offset, defined as: 		 * 		 *		[+-^<blank>]*[<blank>]*[0-9]* 		 * 		 * The rough translation is any number of signs, optionally 		 * followed by numbers, or a number by itself, all<blank> 		 * separated. 		 * 		 * !!! 		 * All address offsets were additive, e.g. "2 2 3p" was the 		 * same as "7p", or, "/ZZZ/ 2" was the same as "/ZZZ/+2". 		 * Note, however, "2 /ZZZ/" was an error.  It was also legal 		 * to insert signs without numbers, so "3 - 2" was legal, and 		 * equal to 4. 		 * 		 * !!! 		 * Offsets were historically permitted for any line address, 		 * e.g. the command "1,2 copy 2 2 2 2" copied lines 1,2 after 		 * line 8. 		 * 		 * !!! 		 * Offsets were historically permitted for search commands, 		 * and handled as addresses: "/pattern/2 2 2" was legal, and 		 * referenced the 6th line after pattern. 		 */
name|F_SET
argument_list|(
name|ecp
argument_list|,
name|E_DELTA
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|ecp
operator|->
name|clen
operator|>
literal|0
operator|&&
name|cmdskip
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|ecp
operator|->
name|cp
operator|,
operator|--
name|ecp
operator|->
name|clen
control|)
empty_stmt|;
if|if
condition|(
name|ecp
operator|->
name|clen
operator|==
literal|0
operator|||
operator|(
operator|!
name|ISDIGIT
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|&&
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|&&
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|!=
literal|'^'
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|ecp
operator|->
name|cp
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|total
operator|+=
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'+'
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|ecp
operator|->
name|cp
index|[
literal|0
index|]
operator|==
literal|'^'
condition|)
block|{
operator|++
name|ecp
operator|->
name|cp
expr_stmt|;
operator|--
name|ecp
operator|->
name|clen
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
comment|/* Get a signed long, add it to the total. */
if|if
condition|(
operator|(
name|nret
operator|=
name|nget_slong
argument_list|(
operator|&
name|val
argument_list|,
name|ecp
operator|->
name|cp
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
operator|)
operator|!=
name|NUM_OK
operator|||
operator|(
name|nret
operator|=
name|NADD_SLONG
argument_list|(
name|sp
argument_list|,
name|total
argument_list|,
name|val
argument_list|)
operator|)
operator|!=
name|NUM_OK
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_NOTSET
argument_list|,
name|nret
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|total
operator|+=
name|isneg
condition|?
operator|-
name|val
else|:
name|val
expr_stmt|;
name|ecp
operator|->
name|clen
operator|-=
operator|(
name|endp
operator|-
name|ecp
operator|->
name|cp
operator|)
expr_stmt|;
name|ecp
operator|->
name|cp
operator|=
name|endp
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Any value less than 0 is an error.  Make sure that the new value 	 * will fit into a recno_t. 	 */
if|if
condition|(
operator|*
name|isaddrp
operator|&&
name|total
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|total
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|-
name|total
operator|>
name|mp
operator|->
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"097|Reference to a line number less than 0"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|NPFITS
argument_list|(
name|MAX_REC_NUMBER
argument_list|,
name|mp
operator|->
name|lno
argument_list|,
name|total
argument_list|)
condition|)
block|{
name|ex_badaddr
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|A_NOTSET
argument_list|,
name|NUM_OVER
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mp
operator|->
name|lno
operator|+=
name|total
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_load --  *	Load up the next command, which may be an @ buffer or global command.  */
end_comment

begin_function
specifier|static
name|int
name|ex_load
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|EXCMD
modifier|*
name|ecp
decl_stmt|;
name|RANGE
modifier|*
name|rp
decl_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_EX_GLOBAL
argument_list|)
expr_stmt|;
comment|/* 	 * Lose any exhausted commands.  We know that the first command 	 * can't be an AGV command, which makes things a bit easier. 	 */
for|for
control|(
name|gp
operator|=
name|sp
operator|->
name|gp
init|;
condition|;
control|)
block|{
name|ecp
operator|=
name|SLIST_FIRST
argument_list|(
name|gp
operator|->
name|ecq
argument_list|)
expr_stmt|;
comment|/* Discard the allocated source name as requested. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_NAMEDISCARD
argument_list|)
condition|)
name|free
argument_list|(
name|ecp
operator|->
name|if_name
argument_list|)
expr_stmt|;
comment|/* 		 * If we're back to the original structure, leave it around, 		 * since we've returned to the beginning of the command stack. 		 */
if|if
condition|(
name|ecp
operator|==
operator|&
name|gp
operator|->
name|excmd
condition|)
block|{
name|ecp
operator|->
name|if_name
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * ecp->clen will be 0 for the first discarded command, but 		 * may not be 0 for subsequent ones, e.g. if the original 		 * command was ":g/xx/@a|s/b/c/", then when we discard the 		 * command pushed on the stack by the @a, we have to resume 		 * the global command which included the substitute command. 		 */
if|if
condition|(
name|ecp
operator|->
name|clen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * If it's an @, global or v command, we may need to continue 		 * the command on a different line. 		 */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|ecp
operator|->
name|agv_flags
argument_list|,
name|AGV_ALL
argument_list|)
condition|)
block|{
comment|/* Discard any exhausted ranges. */
while|while
condition|(
operator|(
name|rp
operator|=
name|TAILQ_FIRST
argument_list|(
name|ecp
operator|->
name|rq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|rp
operator|->
name|start
operator|>
name|rp
operator|->
name|stop
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|ecp
operator|->
name|rq
argument_list|,
name|rp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
comment|/* If there's another range, continue with it. */
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
break|break;
comment|/* If it's a global/v command, fix up the last line. */
if|if
condition|(
name|FL_ISSET
argument_list|(
name|ecp
operator|->
name|agv_flags
argument_list|,
name|AGV_GLOBAL
operator||
name|AGV_V
argument_list|)
operator|&&
name|ecp
operator|->
name|range_lno
operator|!=
name|OOBLNO
condition|)
if|if
condition|(
name|db_exist
argument_list|(
name|sp
argument_list|,
name|ecp
operator|->
name|range_lno
argument_list|)
condition|)
name|sp
operator|->
name|lno
operator|=
name|ecp
operator|->
name|range_lno
expr_stmt|;
else|else
block|{
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
literal|0
condition|)
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|ecp
operator|->
name|o_cp
argument_list|)
expr_stmt|;
block|}
comment|/* Discard the EXCMD. */
name|SLIST_REMOVE_HEAD
argument_list|(
name|gp
operator|->
name|ecq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We only get here if it's an active @, global or v command.  Set 	 * the current line number, and get a new copy of the command for 	 * the parser.  Note, the original pointer almost certainly moved, 	 * so we have play games. 	 */
name|ecp
operator|->
name|cp
operator|=
name|ecp
operator|->
name|o_cp
expr_stmt|;
name|MEMCPY
argument_list|(
name|ecp
operator|->
name|cp
argument_list|,
name|ecp
operator|->
name|cp
operator|+
name|ecp
operator|->
name|o_clen
argument_list|,
name|ecp
operator|->
name|o_clen
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|clen
operator|=
name|ecp
operator|->
name|o_clen
expr_stmt|;
name|ecp
operator|->
name|range_lno
operator|=
name|sp
operator|->
name|lno
operator|=
name|rp
operator|->
name|start
operator|++
expr_stmt|;
if|if
condition|(
name|FL_ISSET
argument_list|(
name|ecp
operator|->
name|agv_flags
argument_list|,
name|AGV_GLOBAL
operator||
name|AGV_V
argument_list|)
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_EX_GLOBAL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_discard --  *	Discard any pending ex commands.  */
end_comment

begin_function
specifier|static
name|int
name|ex_discard
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|)
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|EXCMD
modifier|*
name|ecp
decl_stmt|;
name|RANGE
modifier|*
name|rp
decl_stmt|;
comment|/* 	 * We know the first command can't be an AGV command, so we don't 	 * process it specially.  We do, however, nail the command itself. 	 */
for|for
control|(
name|gp
operator|=
name|sp
operator|->
name|gp
init|;
condition|;
control|)
block|{
name|ecp
operator|=
name|SLIST_FIRST
argument_list|(
name|gp
operator|->
name|ecq
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|ecp
argument_list|,
name|E_NAMEDISCARD
argument_list|)
condition|)
name|free
argument_list|(
name|ecp
operator|->
name|if_name
argument_list|)
expr_stmt|;
comment|/* Reset the last command without dropping it. */
if|if
condition|(
name|ecp
operator|==
operator|&
name|gp
operator|->
name|excmd
condition|)
break|break;
if|if
condition|(
name|FL_ISSET
argument_list|(
name|ecp
operator|->
name|agv_flags
argument_list|,
name|AGV_ALL
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|rp
operator|=
name|TAILQ_FIRST
argument_list|(
name|ecp
operator|->
name|rq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|ecp
operator|->
name|rq
argument_list|,
name|rp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ecp
operator|->
name|o_cp
argument_list|)
expr_stmt|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
name|gp
operator|->
name|ecq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
block|}
name|ecp
operator|->
name|if_name
operator|=
name|NULL
expr_stmt|;
name|ecp
operator|->
name|clen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_unknown --  *	Display an unknown command name.  */
end_comment

begin_function
specifier|static
name|void
name|ex_unknown
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
name|CHAR_T
modifier|*
name|cmd
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|blen
decl_stmt|;
name|CHAR_T
modifier|*
name|bp
decl_stmt|;
name|GET_SPACE_GOTOW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|MEMCPY
argument_list|(
name|bp
argument_list|,
name|cmd
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|msgq_wstr
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|bp
argument_list|,
literal|"098|The %s command is unknown"
argument_list|)
expr_stmt|;
name|FREE_SPACEW
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|alloc_err
label|:
return|return;
block|}
end_function

begin_comment
comment|/*  * ex_is_abbrev -  *	The vi text input routine needs to know if ex thinks this is an  *	[un]abbreviate command, so it can turn off abbreviations.  See  *	the usual ranting in the vi/v_txt_ev.c:txt_abbrev() routine.  *  * PUBLIC: int ex_is_abbrev(CHAR_T *, size_t);  */
end_comment

begin_function
name|int
name|ex_is_abbrev
parameter_list|(
name|CHAR_T
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
return|return
operator|(
operator|(
name|cp
operator|=
name|ex_comm_search
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_ABBR
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_UNABBREVIATE
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_is_unmap -  *	The vi text input routine needs to know if ex thinks this is an  *	unmap command, so it can turn off input mapping.  See the usual  *	ranting in the vi/v_txt_ev.c:txt_unmap() routine.  *  * PUBLIC: int ex_is_unmap(CHAR_T *, size_t);  */
end_comment

begin_function
name|int
name|ex_is_unmap
parameter_list|(
name|CHAR_T
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * The command the vi input routines are really interested in 	 * is "unmap!", not just unmap. 	 */
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'!'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|--
name|len
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|=
name|ex_comm_search
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_UNMAP
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_comm_search --  *	Search for a command name.  */
end_comment

begin_function
specifier|static
name|EXCMDLIST
specifier|const
modifier|*
name|ex_comm_search
parameter_list|(
name|CHAR_T
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|cmds
init|;
name|cp
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|cp
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|name
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|name
index|[
literal|0
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MEMCMP
argument_list|(
name|name
argument_list|,
name|cp
operator|->
name|name
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_badaddr --  *	Display a bad address message.  *  * PUBLIC: void ex_badaddr  * PUBLIC:   (SCR *, EXCMDLIST const *, enum badaddr, enum nresult);  */
end_comment

begin_function
name|void
name|ex_badaddr
parameter_list|(
name|SCR
modifier|*
name|sp
parameter_list|,
specifier|const
name|EXCMDLIST
modifier|*
name|cp
parameter_list|,
name|enum
name|badaddr
name|ba
parameter_list|,
name|enum
name|nresult
name|nret
parameter_list|)
block|{
name|recno_t
name|lno
decl_stmt|;
switch|switch
condition|(
name|nret
condition|)
block|{
case|case
name|NUM_OK
case|:
break|break;
case|case
name|NUM_ERR
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
case|case
name|NUM_OVER
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"099|Address value overflow"
argument_list|)
expr_stmt|;
return|return;
case|case
name|NUM_UNDER
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"100|Address value underflow"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * When encountering an address error, tell the user if there's no 	 * underlying file, that's the real problem. 	 */
if|if
condition|(
name|sp
operator|->
name|ep
operator|==
name|NULL
condition|)
block|{
name|ex_wemsg
argument_list|(
name|sp
argument_list|,
name|cp
condition|?
name|cp
operator|->
name|name
else|:
name|NULL
argument_list|,
name|EXM_NOFILEYET
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ba
condition|)
block|{
case|case
name|A_COMBO
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"101|Illegal address combination"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_EOF
case|:
if|if
condition|(
name|db_last
argument_list|(
name|sp
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return;
if|if
condition|(
name|lno
operator|!=
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"102|Illegal address: only %lu lines in the file"
argument_list|,
operator|(
name|u_long
operator|)
name|lno
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|A_EMPTY
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"103|Illegal address: the file is empty"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_NOTSET
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|A_ZERO
case|:
name|msgq_wstr
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|cp
operator|->
name|name
argument_list|,
literal|"104|The %s command doesn't permit an address of 0"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMLOG
argument_list|)
end_if

begin_comment
comment|/*  * ex_comlog --  *	Log ex commands.  */
end_comment

begin_function
specifier|static
name|void
name|ex_comlog
parameter_list|(
name|sp
parameter_list|,
name|ecp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXCMD
modifier|*
name|ecp
decl_stmt|;
block|{
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"ecmd: "
name|WS
argument_list|,
name|ecp
operator|->
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|addrcnt
operator|>
literal|0
condition|)
block|{
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" a1 %d"
argument_list|,
name|ecp
operator|->
name|addr1
operator|.
name|lno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|addrcnt
operator|>
literal|1
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" a2: %d"
argument_list|,
name|ecp
operator|->
name|addr2
operator|.
name|lno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ecp
operator|->
name|lineno
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" line %d"
argument_list|,
name|ecp
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|flags
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" flags 0x%x"
argument_list|,
name|ecp
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|FL_ISSET
argument_list|(
name|ecp
operator|->
name|iflags
argument_list|,
name|E_C_BUFFER
argument_list|)
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" buffer "
name|WC
argument_list|,
name|ecp
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|argc
condition|)
block|{
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ecp
operator|->
name|argc
condition|;
operator|++
name|cnt
control|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" arg %d: {"
name|WS
literal|"}"
argument_list|,
name|cnt
argument_list|,
name|ecp
operator|->
name|argv
index|[
name|cnt
index|]
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

