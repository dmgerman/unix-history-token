begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_io.c - input/output routines for ntpd.	The socket-opening code  *		   was shamelessly stolen from ntpd.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FNMATCH_H
end_ifdef

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FNM_CASEFOLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|FNM_IGNORECASE
argument_list|)
end_if

begin_define
define|#
directive|define
name|FNM_CASEFOLD
value|FNM_IGNORECASE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKIO_H
end_ifdef

begin_comment
comment|/* UXPV: SIOC* #defines (Frank Vance<fvance@waii.com>) */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lists.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_worker.h"
end_include

begin_include
include|#
directive|include
file|"ntp_request.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"timevalops.h"
end_include

begin_include
include|#
directive|include
file|"timespecops.h"
end_include

begin_include
include|#
directive|include
file|"ntpd-opts.h"
end_include

begin_comment
comment|/* Don't include ISC's version of IPv6 variables and structures */
end_comment

begin_define
define|#
directive|define
name|ISC_IPV6_H
value|1
end_define

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/interfaceiter.h>
end_include

begin_include
include|#
directive|include
file|<isc/netaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<isc/sockaddr.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_include
include|#
directive|include
file|"ntpsim.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_ROUTING_SOCKET
end_ifdef

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_RTNETLINK
end_ifdef

begin_include
include|#
directive|include
file|<linux/rtnetlink.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * setsockopt does not always have the same arg declaration  * across all platforms. If it's not defined we make it empty  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SETSOCKOPT_ARG_CAST
end_ifndef

begin_define
define|#
directive|define
name|SETSOCKOPT_ARG_CAST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|listen_to_virtual_ips
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * NIC rule entry  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|nic_rule_tag
name|nic_rule
typedef|;
end_typedef

begin_struct
struct|struct
name|nic_rule_tag
block|{
name|nic_rule
modifier|*
name|next
decl_stmt|;
name|nic_rule_action
name|action
decl_stmt|;
name|nic_rule_match
name|match_type
decl_stmt|;
name|char
modifier|*
name|if_name
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|int
name|prefixlen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * NIC rule listhead.  Entries are added at the head so that the first  * match in the list is the last matching rule specified.  */
end_comment

begin_decl_stmt
name|nic_rule
modifier|*
name|nic_rule_list
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SO_BINTIME
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCM_BINTIME
argument_list|)
operator|&&
name|defined
argument_list|(
name|CMSG_FIRSTHDR
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_PACKET_TIMESTAMP
end_define

begin_define
define|#
directive|define
name|HAVE_BINTIME
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|BINTIME_CTLMSGBUF_SIZE
end_ifdef

begin_define
define|#
directive|define
name|CMSG_BUFSIZE
value|BINTIME_CTLMSGBUF_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CMSG_BUFSIZE
value|1536
end_define

begin_comment
comment|/* moderate default */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|SO_TIMESTAMPNS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCM_TIMESTAMPNS
argument_list|)
operator|&&
name|defined
argument_list|(
name|CMSG_FIRSTHDR
argument_list|)
end_elif

begin_define
define|#
directive|define
name|HAVE_PACKET_TIMESTAMP
end_define

begin_define
define|#
directive|define
name|HAVE_TIMESTAMPNS
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TIMESTAMPNS_CTLMSGBUF_SIZE
end_ifdef

begin_define
define|#
directive|define
name|CMSG_BUFSIZE
value|TIMESTAMPNS_CTLMSGBUF_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CMSG_BUFSIZE
value|1536
end_define

begin_comment
comment|/* moderate default */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|SO_TIMESTAMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCM_TIMESTAMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|CMSG_FIRSTHDR
argument_list|)
end_elif

begin_define
define|#
directive|define
name|HAVE_PACKET_TIMESTAMP
end_define

begin_define
define|#
directive|define
name|HAVE_TIMESTAMP
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TIMESTAMP_CTLMSGBUF_SIZE
end_ifdef

begin_define
define|#
directive|define
name|CMSG_BUFSIZE
value|TIMESTAMP_CTLMSGBUF_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CMSG_BUFSIZE
value|1536
end_define

begin_comment
comment|/* moderate default */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* fill in for old/other timestamp interfaces */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_include
include|#
directive|include
file|"win32_io.h"
end_include

begin_include
include|#
directive|include
file|<isc/win32os.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We do asynchronous input using the SIGIO facility.  A number of  * recvbuf buffers are preallocated for input.	In the signal  * handler we poll to see which sockets are ready and read the  * packets from them into the recvbuf's along with a time stamp and  * an indication of the source host and the interface it was received  * through.  This allows us to get as accurate receive time stamps  * as possible independent of other processing going on.  *  * We watch the number of recvbufs available to the signal handler  * and allocate more when this number drops below the low water  * mark.  If the signal handler should run out of buffers in the  * interim it will drop incoming frames, the idea being that it is  * better to drop a packet than to be inaccurate.  */
end_comment

begin_comment
comment|/*  * Other statistics of possible interest  */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_dropped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets dropped on reception */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_ignored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets received on wild card interface */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_received
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets received */
end_comment

begin_decl_stmt
name|u_long
name|packets_sent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets sent */
end_comment

begin_decl_stmt
name|u_long
name|packets_notsent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets which couldn't be sent */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|handler_calls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of calls to interrupt handler */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|handler_pkts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pkts received by handler */
end_comment

begin_decl_stmt
name|u_long
name|io_timereset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time counters were reset */
end_comment

begin_comment
comment|/*  * Interface stuff  */
end_comment

begin_decl_stmt
name|endpt
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wildcard ipv4 interface */
end_comment

begin_decl_stmt
name|endpt
modifier|*
name|any6_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wildcard ipv6 interface */
end_comment

begin_decl_stmt
name|endpt
modifier|*
name|loopback_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* loopback ipv4 interface */
end_comment

begin_decl_stmt
name|isc_boolean_t
name|broadcast_client_enabled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is broadcast client enabled */
end_comment

begin_decl_stmt
name|u_int
name|sys_ifnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next .ifnum to assign */
end_comment

begin_decl_stmt
name|int
name|ninterfaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of interfaces */
end_comment

begin_decl_stmt
name|int
name|disable_dynamic_updates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scan interfaces once only */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * Refclock stuff.	We keep a chain of structures with data concerning  * the guys we are doing I/O for.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|refclockio
modifier|*
name|refio
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_comment
comment|/*  * File descriptor masks etc. for call to select  * Not needed for I/O Completion Ports or anything outside this file  */
end_comment

begin_decl_stmt
specifier|static
name|fd_set
name|activefds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxactivefd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * bit alternating value to detect verified interfaces during an update cycle  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|sys_interphase
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|endpt
modifier|*
name|new_interface
parameter_list|(
name|endpt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_interface
parameter_list|(
name|endpt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|update_interfaces
parameter_list|(
name|u_short
parameter_list|,
name|interface_receiver_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_interface
parameter_list|(
name|endpt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|endpt
modifier|*
name|create_interface
parameter_list|(
name|u_short
parameter_list|,
name|endpt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_wildcard_addr
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Multicast functions  */
end_comment

begin_function_decl
specifier|static
name|isc_boolean_t
name|addr_ismulticast
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|is_anycast
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Not all platforms support multicast  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MCAST
end_ifdef

begin_function_decl
specifier|static
name|isc_boolean_t
name|socket_multicast_enable
parameter_list|(
name|endpt
modifier|*
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|socket_multicast_disable
parameter_list|(
name|endpt
modifier|*
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|interface_dump
parameter_list|(
specifier|const
name|endpt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sockaddr_dump
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_interface
parameter_list|(
specifier|const
name|endpt
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DPRINT_INTERFACE
parameter_list|(
name|level
parameter_list|,
name|args
parameter_list|)
value|do { if (debug>= (level)) { print_interface args; } } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINT_INTERFACE
parameter_list|(
name|level
parameter_list|,
name|args
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|vsock
name|vsock_t
typedef|;
end_typedef

begin_enum
enum|enum
name|desc_type
block|{
name|FD_TYPE_SOCKET
block|,
name|FD_TYPE_FILE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|vsock
block|{
name|vsock_t
modifier|*
name|link
decl_stmt|;
name|SOCKET
name|fd
decl_stmt|;
name|enum
name|desc_type
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|vsock_t
modifier|*
name|fd_list
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ROUTING_SOCKET
argument_list|)
end_if

begin_comment
comment|/*  * async notification processing (e. g. routing sockets)  */
end_comment

begin_comment
comment|/*  * support for receiving data on fd that is not a refclock or a socket  * like e. g. routing sockets  */
end_comment

begin_struct
struct|struct
name|asyncio_reader
block|{
name|struct
name|asyncio_reader
modifier|*
name|link
decl_stmt|;
comment|/* the list this is being kept in */
name|SOCKET
name|fd
decl_stmt|;
comment|/* fd to be read */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* possibly local data */
name|void
function_decl|(
modifier|*
name|receiver
function_decl|)
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
parameter_list|)
function_decl|;
comment|/* input handler */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|asyncio_reader
modifier|*
name|asyncio_reader_list
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|delete_asyncio_reader
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|asyncio_reader
modifier|*
name|new_asyncio_reader
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_asyncio_reader
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
parameter_list|,
name|enum
name|desc_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_asyncio_reader
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_IO_COMPLETION_PORT)&& defined(HAS_ROUTING_SOCKET) */
end_comment

begin_function_decl
specifier|static
name|void
name|init_async_notifications
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addr_eqprefix
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addr_samesubnet
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_sockets
parameter_list|(
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|SOCKET
name|open_socket
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|endpt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|fdbits
parameter_list|(
name|int
parameter_list|,
name|fd_set
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_reuseaddr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|socket_broadcast_enable
parameter_list|(
name|struct
name|interface
modifier|*
parameter_list|,
name|SOCKET
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OS_MISSES_SPECIFIC_ROUTE_UPDATES
end_ifdef

begin_function_decl
specifier|static
name|isc_boolean_t
name|socket_broadcast_disable
parameter_list|(
name|struct
name|interface
modifier|*
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|remaddr
name|remaddr_t
typedef|;
end_typedef

begin_struct
struct|struct
name|remaddr
block|{
name|remaddr_t
modifier|*
name|link
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|endpt
modifier|*
name|ep
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|remaddr_t
modifier|*
name|remoteaddr_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|endpt
modifier|*
name|ep_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* complete endpt list */
end_comment

begin_decl_stmt
name|endpt
modifier|*
name|mc4_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IPv4 mcast-capable unicast endpts */
end_comment

begin_decl_stmt
name|endpt
modifier|*
name|mc6_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IPv6 mcast-capable unicast endpts */
end_comment

begin_decl_stmt
specifier|static
name|endpt
modifier|*
name|wildipv4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|endpt
modifier|*
name|wildipv6
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
name|int
name|accept_wildcard_if_for_winnt
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|int
name|accept_wildcard_if_for_winnt
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|add_fd_to_list
parameter_list|(
name|SOCKET
parameter_list|,
name|enum
name|desc_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|endpt
modifier|*
name|find_addr_in_list
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|endpt
modifier|*
name|find_flagged_addr_in_list
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
name|u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_addr_from_list
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_interface_from_list
parameter_list|(
name|endpt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|close_and_delete_fd_from_list
parameter_list|(
name|SOCKET
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_addr_to_list
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
name|endpt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_wildcards
parameter_list|(
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|endpt
modifier|*
name|findlocalinterface
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|endpt
modifier|*
name|findclosestinterface
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|action_text
parameter_list|(
name|nic_rule_action
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|nic_rule_action
name|interface_action
parameter_list|(
name|char
modifier|*
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|,
name|u_int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_isc_if
parameter_list|(
name|isc_interface_t
modifier|*
parameter_list|,
name|endpt
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calc_addr_distance
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_addr_distance
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Routines to read the ntp packets  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
end_if

begin_function_decl
specifier|static
specifier|inline
name|int
name|read_network_packet
parameter_list|(
name|SOCKET
parameter_list|,
name|struct
name|interface
modifier|*
parameter_list|,
name|l_fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntpd_addremove_io_fd
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|input_handler_t
name|input_handler
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_function_decl
specifier|static
specifier|inline
name|int
name|read_refclock_packet
parameter_list|(
name|SOCKET
parameter_list|,
name|struct
name|refclockio
modifier|*
parameter_list|,
name|l_fp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
end_ifndef

begin_function
name|void
name|maintain_activefds
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|closing
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fd
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Too many sockets in use, FD_SETSIZE %d exceeded by fd %d"
argument_list|,
name|FD_SETSIZE
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|closing
condition|)
block|{
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
name|maxactivefd
operator|=
name|max
argument_list|(
name|fd
argument_list|,
name|maxactivefd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxactivefd
operator|&&
name|fd
operator|==
name|maxactivefd
condition|)
block|{
for|for
control|(
name|i
operator|=
name|maxactivefd
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|activefds
argument_list|)
condition|)
block|{
name|maxactivefd
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|NTP_INSIST
argument_list|(
name|fd
operator|!=
name|maxactivefd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_IO_COMPLETION_PORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_TIMING
end_ifdef

begin_comment
comment|/*  * collect timing information for various processing  * paths. currently we only pass them on to the file  * for later processing. this could also do histogram  * based analysis in other to reduce the load (and skew)  * dur to the file output  */
end_comment

begin_function
name|void
name|collect_timing
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rb
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|int
name|count
parameter_list|,
name|l_fp
modifier|*
name|dts
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s %d %s %s"
argument_list|,
operator|(
name|rb
operator|!=
name|NULL
operator|)
condition|?
operator|(
operator|(
name|rb
operator|->
name|dstadr
operator|!=
name|NULL
operator|)
condition|?
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
else|:
literal|"-REFCLOCK-"
operator|)
else|:
literal|"-"
argument_list|,
name|count
argument_list|,
name|lfptoa
argument_list|(
name|dts
argument_list|,
literal|9
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|record_timing_stats
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * About dynamic interfaces, sockets, reception and more...  *  * the code solves following tasks:  *  *   - keep a current list of active interfaces in order  *     to bind to to the interface address on NTP_PORT so that  *     all wild and specific bindings for NTP_PORT are taken by ntpd  *     to avoid other daemons messing with the time or sockets.  *   - all interfaces keep a list of peers that are referencing  *     the interface in order to quickly re-assign the peers to  *     new interface in case an interface is deleted (=> gone from system or  *     down)  *   - have a preconfigured socket ready with the right local address  *     for transmission and reception  *   - have an address list for all destination addresses used within ntpd  *     to find the "right" preconfigured socket.  *   - facilitate updating the internal interface list with respect to  *     the current kernel state  *  * special issues:  *  *   - mapping of multicast addresses to the interface affected is not always  *     one to one - especially on hosts with multiple interfaces  *     the code here currently allocates a separate interface entry for those  *     multicast addresses  *     iff it is able to bind to a *new* socket with the multicast address (flags |= MCASTIF)  *     in case of failure the multicast address is bound to an existing interface.  *   - on some systems it is perfectly legal to assign the same address to  *     multiple interfaces. Therefore this code does not keep a list of interfaces  *     but a list of interfaces that represent a unique address as determined by the kernel  *     by the procedure in findlocalinterface. Thus it is perfectly legal to see only  *     one representative of a group of real interfaces if they share the same address.  *  * Frank Kardel 20050910  */
end_comment

begin_comment
comment|/*  * init_io - initialize I/O module.  */
end_comment

begin_function
name|void
name|init_io
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Init buffer free list and stat counters */
name|init_recvbuff
argument_list|(
name|RECV_INIT
argument_list|)
expr_stmt|;
comment|/* update interface every 5 minutes as default */
name|interface_interval
operator|=
literal|300
expr_stmt|;
ifdef|#
directive|ifdef
name|WORK_PIPE
name|addremove_io_fd
operator|=
operator|&
name|ntpd_addremove_io_fd
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_WINNT
name|init_io_completion_port
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
operator|(
name|void
operator|)
name|set_signal
argument_list|(
name|input_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ntpd_addremove_io_fd
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|is_pipe
parameter_list|,
name|int
name|remove_it
parameter_list|)
block|{
name|UNUSED_ARG
argument_list|(
name|is_pipe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
name|init_socket_sig
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGNALED_IO */
name|maintain_activefds
argument_list|(
name|fd
argument_list|,
name|remove_it
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * io_open_sockets - call socket creation routine  */
end_comment

begin_function
name|void
name|io_open_sockets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|already_opened
decl_stmt|;
if|if
condition|(
name|already_opened
operator|||
name|HAVE_OPT
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
condition|)
return|return;
name|already_opened
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Create the sockets 	 */
name|BLOCKIO
argument_list|()
expr_stmt|;
name|create_sockets
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
name|init_async_notifications
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"io_open_sockets: maxactivefd %d\n"
operator|,
name|maxactivefd
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * function to dump the contents of the interface structure  * for debugging use only.  */
end_comment

begin_function
name|void
name|interface_dump
parameter_list|(
specifier|const
name|endpt
modifier|*
name|itf
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Dumping interface: %p\n"
argument_list|,
name|itf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fd = %d\n"
argument_list|,
name|itf
operator|->
name|fd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bfd = %d\n"
argument_list|,
name|itf
operator|->
name|bfd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sin = %s,\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddr_dump
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bcast = %s,\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|itf
operator|->
name|bcast
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddr_dump
argument_list|(
operator|&
name|itf
operator|->
name|bcast
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mask = %s,\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|itf
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddr_dump
argument_list|(
operator|&
name|itf
operator|->
name|mask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"name = %s\n"
argument_list|,
name|itf
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flags = 0x%08x\n"
argument_list|,
name|itf
operator|->
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"last_ttl = %d\n"
argument_list|,
name|itf
operator|->
name|last_ttl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addr_refid = %08x\n"
argument_list|,
name|itf
operator|->
name|addr_refid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"num_mcast = %d\n"
argument_list|,
name|itf
operator|->
name|num_mcast
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"received = %ld\n"
argument_list|,
name|itf
operator|->
name|received
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sent = %ld\n"
argument_list|,
name|itf
operator|->
name|sent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"notsent = %ld\n"
argument_list|,
name|itf
operator|->
name|notsent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ifindex = %u\n"
argument_list|,
name|itf
operator|->
name|ifindex
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"peercnt = %u\n"
argument_list|,
name|itf
operator|->
name|peercnt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"phase = %u\n"
argument_list|,
name|itf
operator|->
name|phase
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sockaddr_dump - hex dump the start of a sockaddr_u  */
end_comment

begin_function
specifier|static
name|void
name|sockaddr_dump
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
name|psau
parameter_list|)
block|{
comment|/* Limit the size of the sockaddr_in6 hex dump */
specifier|const
name|int
name|maxsize
init|=
name|min
argument_list|(
literal|32
argument_list|,
sizeof|sizeof
argument_list|(
name|psau
operator|->
name|sa6
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX: Should we limit maxsize based on psau->saX.sin_family? */
name|cp
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|psau
operator|->
name|sa6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxsize
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|4
operator|)
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print_interface - helper to output debug information  */
end_comment

begin_function
specifier|static
name|void
name|print_interface
parameter_list|(
specifier|const
name|endpt
modifier|*
name|iface
parameter_list|,
name|char
modifier|*
name|pfx
parameter_list|,
name|char
modifier|*
name|sfx
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%sinterface #%d: fd=%d, bfd=%d, name=%s, flags=0x%x, ifindex=%u, sin=%s"
argument_list|,
name|pfx
argument_list|,
name|iface
operator|->
name|ifnum
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|iface
operator|->
name|bfd
argument_list|,
name|iface
operator|->
name|name
argument_list|,
name|iface
operator|->
name|flags
argument_list|,
name|iface
operator|->
name|ifindex
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|AF_INET
operator|==
name|iface
operator|->
name|family
condition|)
block|{
if|if
condition|(
name|iface
operator|->
name|flags
operator|&
name|INT_BROADCAST
condition|)
name|printf
argument_list|(
literal|", bcast=%s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|bcast
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", mask=%s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|", %s:%s"
argument_list|,
operator|(
name|iface
operator|->
name|ignore_packets
operator|)
condition|?
literal|"Disabled"
else|:
literal|"Enabled"
argument_list|,
name|sfx
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
comment|/* in-depth debugging only */
name|interface_dump
argument_list|(
name|iface
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ROUTING_SOCKET
argument_list|)
end_if

begin_comment
comment|/*  * create an asyncio_reader structure  */
end_comment

begin_function
specifier|static
name|struct
name|asyncio_reader
modifier|*
name|new_asyncio_reader
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|asyncio_reader
modifier|*
name|reader
decl_stmt|;
name|reader
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reader
argument_list|)
argument_list|)
expr_stmt|;
name|reader
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
return|return
name|reader
return|;
block|}
end_function

begin_comment
comment|/*  * delete a reader  */
end_comment

begin_function
specifier|static
name|void
name|delete_asyncio_reader
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
name|reader
parameter_list|)
block|{
name|free
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * add asynchio_reader  */
end_comment

begin_function
specifier|static
name|void
name|add_asyncio_reader
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
name|reader
parameter_list|,
name|enum
name|desc_type
name|type
parameter_list|)
block|{
name|LINK_SLIST
argument_list|(
name|asyncio_reader_list
argument_list|,
name|reader
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|add_fd_to_list
argument_list|(
name|reader
operator|->
name|fd
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove asynchio_reader  */
end_comment

begin_function
specifier|static
name|void
name|remove_asyncio_reader
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
name|reader
parameter_list|)
block|{
name|struct
name|asyncio_reader
modifier|*
name|unlinked
decl_stmt|;
name|UNLINK_SLIST
argument_list|(
name|unlinked
argument_list|,
name|asyncio_reader_list
argument_list|,
name|reader
argument_list|,
name|link
argument_list|,
expr|struct
name|asyncio_reader
argument_list|)
expr_stmt|;
if|if
condition|(
name|reader
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
name|close_and_delete_fd_from_list
argument_list|(
name|reader
operator|->
name|fd
argument_list|)
expr_stmt|;
name|reader
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_IO_COMPLETION_PORT)&& defined(HAS_ROUTING_SOCKET) */
end_comment

begin_comment
comment|/* compare two sockaddr prefixes */
end_comment

begin_function
specifier|static
name|int
name|addr_eqprefix
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
name|a
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
name|b
parameter_list|,
name|int
name|prefixlen
parameter_list|)
block|{
name|isc_netaddr_t
name|isc_a
decl_stmt|;
name|isc_netaddr_t
name|isc_b
decl_stmt|;
name|isc_sockaddr_t
name|isc_sa
decl_stmt|;
name|ZERO
argument_list|(
name|isc_sa
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|isc_sa
operator|.
name|type
argument_list|,
name|a
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|isc_sa
operator|.
name|type
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|isc_a
argument_list|,
operator|&
name|isc_sa
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|isc_sa
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|isc_sa
operator|.
name|type
argument_list|,
name|b
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|isc_sa
operator|.
name|type
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|isc_b
argument_list|,
operator|&
name|isc_sa
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|isc_netaddr_eqprefix
argument_list|(
operator|&
name|isc_a
argument_list|,
operator|&
name|isc_b
argument_list|,
operator|(
name|u_int
operator|)
name|prefixlen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|addr_samesubnet
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
name|a
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
name|a_mask
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
name|b
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
name|b_mask
parameter_list|)
block|{
specifier|const
name|u_int32
modifier|*
name|pa
decl_stmt|;
specifier|const
name|u_int32
modifier|*
name|pa_limit
decl_stmt|;
specifier|const
name|u_int32
modifier|*
name|pb
decl_stmt|;
specifier|const
name|u_int32
modifier|*
name|pm
decl_stmt|;
name|size_t
name|loops
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|AF
argument_list|(
name|a
argument_list|)
operator|==
name|AF
argument_list|(
name|a_mask
argument_list|)
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|AF
argument_list|(
name|b
argument_list|)
operator|==
name|AF
argument_list|(
name|b_mask
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * With address and mask families verified to match, comparing 	 * the masks also validates the address's families match. 	 */
if|if
condition|(
operator|!
name|SOCK_EQ
argument_list|(
name|a_mask
argument_list|,
name|b_mask
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|IS_IPV6
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|loops
operator|=
sizeof|sizeof
argument_list|(
name|NSRCADR6
argument_list|(
name|a
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|pa
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|NSRCADR6
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|pb
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|NSRCADR6
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|pm
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|NSRCADR6
argument_list|(
name|a_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loops
operator|=
sizeof|sizeof
argument_list|(
name|NSRCADR
argument_list|(
name|a
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|pa
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|NSRCADR
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|pb
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|NSRCADR
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|pm
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|NSRCADR
argument_list|(
name|a_mask
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pa_limit
operator|=
name|pa
operator|+
name|loops
init|;
name|pa
operator|<
name|pa_limit
condition|;
name|pa
operator|++
operator|,
name|pb
operator|++
operator|,
name|pm
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|pa
operator|&
operator|*
name|pm
operator|)
operator|!=
operator|(
operator|*
name|pb
operator|&
operator|*
name|pm
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Code to tell if we have an IP address  * If we have then return the sockaddr structure  * and set the return value  * see the bind9/getaddresses.c for details  */
end_comment

begin_function
name|int
name|is_ip_address
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|u_short
name|af
parameter_list|,
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|in_addr
name|in4
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|result
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|resaddr6
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|pch
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|host
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ZERO_SOCK
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Try IPv4, then IPv6.  In order to handle the extended format 	 * for IPv6 scoped addresses (address%scope_ID), we'll use a local 	 * working buffer of 128 bytes.  The length is an ad-hoc value, but 	 * should be enough for this purpose; the buffer can contain a string 	 * of at least 80 bytes for scope_ID in addition to any IPv6 numeric 	 * addresses (up to 46 bytes), the delimiter character and the 	 * terminating NULL character. 	 */
if|if
condition|(
name|AF_UNSPEC
operator|==
name|af
operator|||
name|AF_INET
operator|==
name|af
condition|)
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|host
argument_list|,
operator|&
name|in4
argument_list|)
operator|==
literal|1
condition|)
block|{
name|AF
argument_list|(
name|addr
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|SET_ADDR4N
argument_list|(
name|addr
argument_list|,
name|in4
operator|.
name|s_addr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|AF_UNSPEC
operator|==
name|af
operator|||
name|AF_INET6
operator|==
name|af
condition|)
if|if
condition|(
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|>
name|strlen
argument_list|(
name|host
argument_list|)
condition|)
block|{
if|if
condition|(
literal|'['
operator|==
name|host
index|[
literal|0
index|]
condition|)
block|{
name|strlcpy
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|host
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
argument_list|)
expr_stmt|;
name|pch
operator|=
name|strchr
argument_list|(
name|tmpbuf
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch
operator|!=
name|NULL
condition|)
operator|*
name|pch
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|strlcpy
argument_list|(
name|tmpbuf
argument_list|,
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator||=
name|AI_NUMERICHOST
expr_stmt|;
if|if
condition|(
name|getaddrinfo
argument_list|(
name|tmpbuf
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|result
argument_list|)
operator|==
literal|0
condition|)
block|{
name|AF
argument_list|(
name|addr
argument_list|)
operator|=
name|AF_INET6
expr_stmt|;
name|resaddr6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|result
operator|->
name|ai_addr
expr_stmt|;
name|SET_ADDR6N
argument_list|(
name|addr
argument_list|,
name|resaddr6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
name|SET_SCOPE
argument_list|(
name|addr
argument_list|,
name|resaddr6
operator|->
name|sin6_scope_id
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|/* 	 * If we got here it was not an IP address 	 */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * interface list enumerator - visitor pattern  */
end_comment

begin_function
name|void
name|interface_enumerate
parameter_list|(
name|interface_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|interface_info_t
name|ifi
decl_stmt|;
name|ifi
operator|.
name|action
operator|=
name|IFS_EXISTS
expr_stmt|;
for|for
control|(
name|ifi
operator|.
name|ep
operator|=
name|ep_list
init|;
name|ifi
operator|.
name|ep
operator|!=
name|NULL
condition|;
name|ifi
operator|.
name|ep
operator|=
name|ifi
operator|.
name|ep
operator|->
name|elink
control|)
call|(
modifier|*
name|receiver
call|)
argument_list|(
name|data
argument_list|,
operator|&
name|ifi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * do standard initialization of interface structure  */
end_comment

begin_function
specifier|static
name|void
name|init_interface
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
name|ZERO
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|ep
operator|->
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|ep
operator|->
name|phase
operator|=
name|sys_interphase
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * create new interface structure initialize from  * template structure or via standard initialization  * function  */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|new_interface
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|iface
decl_stmt|;
name|iface
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|interface
condition|)
name|init_interface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
else|else
comment|/* use the template */
name|memcpy
argument_list|(
name|iface
argument_list|,
name|interface
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* count every new instance of an interface in the system */
name|iface
operator|->
name|ifnum
operator|=
name|sys_ifnum
operator|++
expr_stmt|;
name|iface
operator|->
name|starttime
operator|=
name|current_time
expr_stmt|;
return|return
name|iface
return|;
block|}
end_function

begin_comment
comment|/*  * return interface storage into free memory pool  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|delete_interface
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * link interface into list of known interfaces  */
end_comment

begin_function
specifier|static
name|void
name|add_interface
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
name|endpt
modifier|*
modifier|*
name|pmclisthead
decl_stmt|;
name|endpt
modifier|*
name|scan
decl_stmt|;
name|endpt
modifier|*
name|scan_next
decl_stmt|;
name|endpt
modifier|*
name|unlinked
decl_stmt|;
name|sockaddr_u
modifier|*
name|addr
decl_stmt|;
name|int
name|ep_local
decl_stmt|;
name|int
name|scan_local
decl_stmt|;
name|int
name|same_subnet
decl_stmt|;
name|int
name|ep_univ_iid
decl_stmt|;
comment|/* iface ID from MAC address */
name|int
name|scan_univ_iid
decl_stmt|;
comment|/* see RFC 4291 */
name|int
name|ep_privacy
decl_stmt|;
comment|/* random local iface ID */
name|int
name|scan_privacy
decl_stmt|;
comment|/* see RFC 4941 */
name|int
name|rc
decl_stmt|;
comment|/* Calculate the refid */
name|ep
operator|->
name|addr_refid
operator|=
name|addr2refid
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
expr_stmt|;
comment|/* link at tail so ntpdc -c ifstats index increases each row */
name|LINK_TAIL_SLIST
argument_list|(
name|ep_list
argument_list|,
name|ep
argument_list|,
name|elink
argument_list|,
name|endpt
argument_list|)
expr_stmt|;
name|ninterfaces
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MCAST
comment|/* the rest is for enabled multicast-capable addresses only */
if|if
condition|(
name|ep
operator|->
name|ignore_packets
operator|||
operator|!
operator|(
name|INT_MULTICAST
operator|&
name|ep
operator|->
name|flags
operator|)
operator|||
name|INT_LOOPBACK
operator|&
name|ep
operator|->
name|flags
condition|)
return|return;
ifndef|#
directive|ifndef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
if|if
condition|(
name|AF_INET6
operator|==
name|ep
operator|->
name|family
condition|)
return|return;
endif|#
directive|endif
name|pmclisthead
operator|=
operator|(
name|AF_INET
operator|==
name|ep
operator|->
name|family
operator|)
condition|?
operator|&
name|mc4_list
else|:
operator|&
name|mc6_list
expr_stmt|;
if|if
condition|(
name|AF_INET6
operator|==
name|ep
operator|->
name|family
condition|)
block|{
name|ep_local
operator|=
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|PSOCK_ADDR6
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|)
operator|||
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
name|PSOCK_ADDR6
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|ep_univ_iid
operator|=
name|IS_IID_UNIV
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
expr_stmt|;
name|ep_privacy
operator|=
operator|!
operator|!
operator|(
name|INT_PRIVACY
operator|&
name|ep
operator|->
name|flags
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ep_local
operator|=
name|FALSE
expr_stmt|;
name|ep_univ_iid
operator|=
name|FALSE
expr_stmt|;
name|ep_privacy
operator|=
name|FALSE
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"add_interface mcast-capable %s%s%s%s\n"
operator|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
operator|,
operator|(
name|ep_local
operator|)
condition|?
literal|" link/scope-local"
else|:
literal|""
operator|,
operator|(
name|ep_univ_iid
operator|)
condition|?
literal|" univ-IID"
else|:
literal|""
operator|,
operator|(
name|ep_privacy
operator|)
condition|?
literal|" privacy"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we have multiple local addresses on the same network 	 * interface, and some are link- or site-local, do not multicast 	 * out from the link-/site-local addresses by default, to avoid 	 * duplicate manycastclient associations between v6 peers using 	 * link-local and global addresses.  link-local can still be 	 * chosen using "nic ignore myv6globalprefix::/64". 	 * Similarly, if we have multiple global addresses from the same 	 * prefix on the same network interface, multicast from one, 	 * preferring EUI-64, then static, then least RFC 4941 privacy 	 * addresses. 	 */
for|for
control|(
name|scan
operator|=
operator|*
name|pmclisthead
init|;
name|scan
operator|!=
name|NULL
condition|;
name|scan
operator|=
name|scan_next
control|)
block|{
name|scan_next
operator|=
name|scan
operator|->
name|mclink
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|family
operator|!=
name|scan
operator|->
name|family
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|ep
operator|->
name|name
argument_list|,
name|scan
operator|->
name|name
argument_list|)
condition|)
continue|continue;
name|same_subnet
operator|=
name|addr_samesubnet
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|,
operator|&
name|ep
operator|->
name|mask
argument_list|,
operator|&
name|scan
operator|->
name|sin
argument_list|,
operator|&
name|scan
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|AF_INET6
operator|==
name|ep
operator|->
name|family
condition|)
block|{
name|addr
operator|=
operator|&
name|scan
operator|->
name|sin
expr_stmt|;
name|scan_local
operator|=
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|PSOCK_ADDR6
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|||
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
name|PSOCK_ADDR6
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|scan_univ_iid
operator|=
name|IS_IID_UNIV
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|scan_privacy
operator|=
operator|!
operator|!
operator|(
name|INT_PRIVACY
operator|&
name|scan
operator|->
name|flags
operator|)
expr_stmt|;
block|}
else|else
block|{
name|scan_local
operator|=
name|FALSE
expr_stmt|;
name|scan_univ_iid
operator|=
name|FALSE
expr_stmt|;
name|scan_privacy
operator|=
name|FALSE
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"add_interface mcast-capable scan %s%s%s%s\n"
operator|,
name|stoa
argument_list|(
operator|&
name|scan
operator|->
name|sin
argument_list|)
operator|,
operator|(
name|scan_local
operator|)
condition|?
literal|" link/scope-local"
else|:
literal|""
operator|,
operator|(
name|scan_univ_iid
operator|)
condition|?
literal|" univ-IID"
else|:
literal|""
operator|,
operator|(
name|scan_privacy
operator|)
condition|?
literal|" privacy"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep_local
operator|&&
operator|!
name|scan_local
operator|)
operator|||
operator|(
name|same_subnet
operator|&&
operator|(
operator|(
name|ep_privacy
operator|&&
operator|!
name|scan_privacy
operator|)
operator|||
operator|(
operator|!
name|ep_univ_iid
operator|&&
name|scan_univ_iid
operator|)
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"did not add %s to %s of IPv6 multicast-capable list which already has %s\n"
operator|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
operator|,
operator|(
name|ep_local
operator|)
condition|?
literal|"tail"
else|:
literal|"head"
operator|,
name|stoa
argument_list|(
operator|&
name|scan
operator|->
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|scan_local
operator|&&
operator|!
name|ep_local
operator|)
operator|||
operator|(
name|same_subnet
operator|&&
operator|(
operator|(
name|scan_privacy
operator|&&
operator|!
name|ep_privacy
operator|)
operator|||
operator|(
operator|!
name|scan_univ_iid
operator|&&
name|ep_univ_iid
operator|)
operator|)
operator|)
condition|)
block|{
name|UNLINK_SLIST
argument_list|(
name|unlinked
argument_list|,
operator|*
name|pmclisthead
argument_list|,
name|scan
argument_list|,
name|mclink
argument_list|,
name|endpt
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s %s from IPv6 multicast-capable list to add %s\n"
operator|,
operator|(
name|unlinked
operator|!=
name|scan
operator|)
condition|?
literal|"Failed to remove"
else|:
literal|"removed"
operator|,
name|stoa
argument_list|(
operator|&
name|scan
operator|->
name|sin
argument_list|)
operator|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Add link/site local at the tail of the multicast- 	 * capable unicast interfaces list, so that ntpd will 	 * send from global addresses before link-/site-local 	 * ones. 	 */
if|if
condition|(
name|ep_local
condition|)
name|LINK_TAIL_SLIST
argument_list|(
operator|*
name|pmclisthead
argument_list|,
name|ep
argument_list|,
name|mclink
argument_list|,
name|endpt
argument_list|)
expr_stmt|;
else|else
name|LINK_SLIST
argument_list|(
operator|*
name|pmclisthead
argument_list|,
name|ep
argument_list|,
name|mclink
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"added %s to %s of IPv%s multicast-capable unicast local address list\n"
operator|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
operator|,
operator|(
name|ep_local
operator|)
condition|?
literal|"tail"
else|:
literal|"head"
operator|,
operator|(
name|AF_INET
operator|==
name|ep
operator|->
name|family
operator|)
condition|?
literal|"4"
else|:
literal|"6"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_SOCKET
operator|==
name|ep
operator|->
name|fd
condition|)
return|return;
comment|/* 	 * select the local address from which to send to multicast. 	 */
switch|switch
condition|(
name|AF
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
name|rc
operator|=
name|setsockopt
argument_list|(
name|ep
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_IF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|NSRCADR
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|NSRCADR
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_IF %s fails: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
case|case
name|AF_INET6
case|:
name|rc
operator|=
name|setsockopt
argument_list|(
name|ep
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_IF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ep
operator|->
name|ifindex
argument_list|,
sizeof|sizeof
argument_list|(
name|ep
operator|->
name|ifindex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do not complain if bound addr scope is ifindex */
if|if
condition|(
name|rc
operator|&&
name|ep
operator|->
name|ifindex
operator|!=
name|SCOPE
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_MULTICAST_IF %u for %s fails: %m"
argument_list|,
name|ep
operator|->
name|ifindex
argument_list|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* MCAST */
block|}
end_function

begin_comment
comment|/*  * remove interface from known interface list and clean up  * associated resources  */
end_comment

begin_function
specifier|static
name|void
name|remove_interface
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
name|endpt
modifier|*
name|unlinked
decl_stmt|;
name|endpt
modifier|*
modifier|*
name|pmclisthead
decl_stmt|;
name|sockaddr_u
name|resmask
decl_stmt|;
name|UNLINK_SLIST
argument_list|(
name|unlinked
argument_list|,
name|ep_list
argument_list|,
name|ep
argument_list|,
name|elink
argument_list|,
name|endpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|ignore_packets
operator|&&
name|INT_MULTICAST
operator|&
name|ep
operator|->
name|flags
condition|)
block|{
name|pmclisthead
operator|=
operator|(
name|AF_INET
operator|==
name|ep
operator|->
name|family
operator|)
condition|?
operator|&
name|mc4_list
else|:
operator|&
name|mc6_list
expr_stmt|;
name|UNLINK_SLIST
argument_list|(
name|unlinked
argument_list|,
operator|*
name|pmclisthead
argument_list|,
name|ep
argument_list|,
name|mclink
argument_list|,
name|endpt
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s %s IPv%s multicast-capable unicast local address list\n"
operator|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
operator|,
operator|(
name|unlinked
operator|!=
name|NULL
operator|)
condition|?
literal|"removed from"
else|:
literal|"not found on"
operator|,
operator|(
name|AF_INET
operator|==
name|ep
operator|->
name|family
operator|)
condition|?
literal|"4"
else|:
literal|"6"
operator|)
argument_list|)
expr_stmt|;
block|}
name|delete_interface_from_list
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Deleting interface #%d %s, %s#%d, interface stats: received=%ld, sent=%ld, dropped=%ld, active_time=%ld secs"
argument_list|,
name|ep
operator|->
name|ifnum
argument_list|,
name|ep
operator|->
name|name
argument_list|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|,
name|SRCPORT
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|,
name|ep
operator|->
name|received
argument_list|,
name|ep
operator|->
name|sent
argument_list|,
name|ep
operator|->
name|notsent
argument_list|,
name|current_time
operator|-
name|ep
operator|->
name|starttime
argument_list|)
expr_stmt|;
name|close_and_delete_fd_from_list
argument_list|(
name|ep
operator|->
name|fd
argument_list|)
expr_stmt|;
name|ep
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"stop listening for broadcasts to %s on interface #%d %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|bcast
argument_list|)
argument_list|,
name|ep
operator|->
name|ifnum
argument_list|,
name|ep
operator|->
name|name
argument_list|)
expr_stmt|;
name|close_and_delete_fd_from_list
argument_list|(
name|ep
operator|->
name|bfd
argument_list|)
expr_stmt|;
name|ep
operator|->
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|ep
operator|->
name|flags
operator|&=
operator|~
name|INT_BCASTOPEN
expr_stmt|;
block|}
name|ninterfaces
operator|--
expr_stmt|;
name|mon_clearinterface
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* remove restrict interface entry */
name|SET_HOSTMASK
argument_list|(
operator|&
name|resmask
argument_list|,
name|AF
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|hack_restrict
argument_list|(
name|RESTRICT_REMOVEIF
argument_list|,
operator|&
name|ep
operator|->
name|sin
argument_list|,
operator|&
name|resmask
argument_list|,
name|RESM_NTPONLY
operator||
name|RESM_INTERFACE
argument_list|,
name|RES_IGNORE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_listen_address
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s on %d %s %s"
argument_list|,
operator|(
name|ep
operator|->
name|ignore_packets
operator|)
condition|?
literal|"Listen and drop"
else|:
literal|"Listen normally"
argument_list|,
name|ep
operator|->
name|ifnum
argument_list|,
name|ep
operator|->
name|name
argument_list|,
name|sptoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_wildcards
parameter_list|(
name|u_short
name|port
parameter_list|)
block|{
name|int
name|v4wild
decl_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
name|int
name|v6wild
decl_stmt|;
endif|#
directive|endif
name|sockaddr_u
name|wildaddr
decl_stmt|;
name|nic_rule_action
name|action
decl_stmt|;
name|struct
name|interface
modifier|*
name|wildif
decl_stmt|;
comment|/* 	 * silence "potentially uninitialized" warnings from VC9 	 * failing to follow the logic.  Ideally action could remain 	 * uninitialized, and the memset be the first statement under 	 * the first if (v4wild). 	 */
name|action
operator|=
name|ACTION_LISTEN
expr_stmt|;
name|ZERO
argument_list|(
name|wildaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
comment|/* 	 * create pseudo-interface with wildcard IPv6 address 	 */
name|v6wild
operator|=
name|ipv6_works
expr_stmt|;
if|if
condition|(
name|v6wild
condition|)
block|{
comment|/* set wildaddr to the v6 wildcard address :: */
name|ZERO
argument_list|(
name|wildaddr
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|wildaddr
argument_list|)
operator|=
name|AF_INET6
expr_stmt|;
name|SET_ADDR6N
argument_list|(
operator|&
name|wildaddr
argument_list|,
name|in6addr_any
argument_list|)
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|wildaddr
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|SET_SCOPE
argument_list|(
operator|&
name|wildaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* check for interface/nic rules affecting the wildcard */
name|action
operator|=
name|interface_action
argument_list|(
name|NULL
argument_list|,
operator|&
name|wildaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|v6wild
operator|=
operator|(
name|ACTION_IGNORE
operator|!=
name|action
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|v6wild
condition|)
block|{
name|wildif
operator|=
name|new_interface
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|wildif
operator|->
name|name
argument_list|,
literal|"v6wildcard"
argument_list|,
sizeof|sizeof
argument_list|(
name|wildif
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|wildif
operator|->
name|sin
argument_list|,
operator|&
name|wildaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|wildif
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|wildif
operator|->
name|family
operator|=
name|AF_INET6
expr_stmt|;
name|AF
argument_list|(
operator|&
name|wildif
operator|->
name|mask
argument_list|)
operator|=
name|AF_INET6
expr_stmt|;
name|SET_ONESMASK
argument_list|(
operator|&
name|wildif
operator|->
name|mask
argument_list|)
expr_stmt|;
name|wildif
operator|->
name|flags
operator|=
name|INT_UP
operator||
name|INT_WILDCARD
expr_stmt|;
name|wildif
operator|->
name|ignore_packets
operator|=
operator|(
name|ACTION_DROP
operator|==
name|action
operator|)
expr_stmt|;
name|wildif
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|wildif
operator|->
name|sin
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|wildif
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildif
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|wildipv6
operator|=
name|wildif
expr_stmt|;
name|any6_interface
operator|=
name|wildif
expr_stmt|;
name|add_addr_to_list
argument_list|(
operator|&
name|wildif
operator|->
name|sin
argument_list|,
name|wildif
argument_list|)
expr_stmt|;
name|add_interface
argument_list|(
name|wildif
argument_list|)
expr_stmt|;
name|log_listen_address
argument_list|(
name|wildif
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to bind to wildcard address %s - another process may be running - EXITING"
argument_list|,
name|stoa
argument_list|(
operator|&
name|wildif
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT_INTERFACE
argument_list|(
literal|2
argument_list|,
operator|(
name|wildif
operator|,
literal|"created "
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * create pseudo-interface with wildcard IPv4 address 	 */
name|v4wild
operator|=
name|ipv4_works
expr_stmt|;
if|if
condition|(
name|v4wild
condition|)
block|{
comment|/* set wildaddr to the v4 wildcard address 0.0.0.0 */
name|AF
argument_list|(
operator|&
name|wildaddr
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|SET_ADDR4N
argument_list|(
operator|&
name|wildaddr
argument_list|,
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|wildaddr
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* check for interface/nic rules affecting the wildcard */
name|action
operator|=
name|interface_action
argument_list|(
name|NULL
argument_list|,
operator|&
name|wildaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|v4wild
operator|=
operator|(
name|ACTION_IGNORE
operator|!=
name|action
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|v4wild
condition|)
block|{
name|wildif
operator|=
name|new_interface
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|wildif
operator|->
name|name
argument_list|,
literal|"v4wildcard"
argument_list|,
sizeof|sizeof
argument_list|(
name|wildif
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|wildif
operator|->
name|sin
argument_list|,
operator|&
name|wildaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|wildif
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|wildif
operator|->
name|family
operator|=
name|AF_INET
expr_stmt|;
name|AF
argument_list|(
operator|&
name|wildif
operator|->
name|mask
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|SET_ONESMASK
argument_list|(
operator|&
name|wildif
operator|->
name|mask
argument_list|)
expr_stmt|;
name|wildif
operator|->
name|flags
operator|=
name|INT_BROADCAST
operator||
name|INT_UP
operator||
name|INT_WILDCARD
expr_stmt|;
name|wildif
operator|->
name|ignore_packets
operator|=
operator|(
name|ACTION_DROP
operator|==
name|action
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MCAST
argument_list|)
comment|/* 		 * enable multicast reception on the broadcast socket 		 */
name|AF
argument_list|(
operator|&
name|wildif
operator|->
name|bcast
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|SET_ADDR4N
argument_list|(
operator|&
name|wildif
operator|->
name|bcast
argument_list|,
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|wildif
operator|->
name|bcast
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
name|wildif
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|wildif
operator|->
name|sin
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|wildif
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildif
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|wildipv4
operator|=
name|wildif
expr_stmt|;
name|any_interface
operator|=
name|wildif
expr_stmt|;
name|add_addr_to_list
argument_list|(
operator|&
name|wildif
operator|->
name|sin
argument_list|,
name|wildif
argument_list|)
expr_stmt|;
name|add_interface
argument_list|(
name|wildif
argument_list|)
expr_stmt|;
name|log_listen_address
argument_list|(
name|wildif
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to bind to wildcard address %s - another process may be running - EXITING"
argument_list|,
name|stoa
argument_list|(
operator|&
name|wildif
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT_INTERFACE
argument_list|(
literal|2
argument_list|,
operator|(
name|wildif
operator|,
literal|"created "
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * add_nic_rule() -- insert a rule entry at the head of nic_rule_list.  */
end_comment

begin_function
name|void
name|add_nic_rule
parameter_list|(
name|nic_rule_match
name|match_type
parameter_list|,
specifier|const
name|char
modifier|*
name|if_name
parameter_list|,
comment|/* interface name or numeric address */
name|int
name|prefixlen
parameter_list|,
name|nic_rule_action
name|action
parameter_list|)
block|{
name|nic_rule
modifier|*
name|rule
decl_stmt|;
name|isc_boolean_t
name|is_ip
decl_stmt|;
name|rule
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
argument_list|)
expr_stmt|;
name|rule
operator|->
name|match_type
operator|=
name|match_type
expr_stmt|;
name|rule
operator|->
name|prefixlen
operator|=
name|prefixlen
expr_stmt|;
name|rule
operator|->
name|action
operator|=
name|action
expr_stmt|;
if|if
condition|(
name|MATCH_IFNAME
operator|==
name|match_type
condition|)
block|{
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|if_name
argument_list|)
expr_stmt|;
name|rule
operator|->
name|if_name
operator|=
name|estrdup
argument_list|(
name|if_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MATCH_IFADDR
operator|==
name|match_type
condition|)
block|{
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|if_name
argument_list|)
expr_stmt|;
comment|/* set rule->addr */
name|is_ip
operator|=
name|is_ip_address
argument_list|(
name|if_name
argument_list|,
name|AF_UNSPEC
argument_list|,
operator|&
name|rule
operator|->
name|addr
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|is_ip
argument_list|)
expr_stmt|;
block|}
else|else
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|==
name|if_name
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|nic_rule_list
argument_list|,
name|rule
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|action_text
parameter_list|(
name|nic_rule_action
name|action
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
default|default:
name|t
operator|=
literal|"ERROR"
expr_stmt|;
comment|/* quiet uninit warning */
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"fatal: unknown nic_rule_action %d\n"
operator|,
name|action
operator|)
argument_list|)
expr_stmt|;
name|NTP_ENSURE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_LISTEN
case|:
name|t
operator|=
literal|"listen"
expr_stmt|;
break|break;
case|case
name|ACTION_IGNORE
case|:
name|t
operator|=
literal|"ignore"
expr_stmt|;
break|break;
case|case
name|ACTION_DROP
case|:
name|t
operator|=
literal|"drop"
expr_stmt|;
break|break;
block|}
return|return
name|t
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function
specifier|static
name|nic_rule_action
name|interface_action
parameter_list|(
name|char
modifier|*
name|if_name
parameter_list|,
name|sockaddr_u
modifier|*
name|if_addr
parameter_list|,
name|u_int32
name|if_flags
parameter_list|)
block|{
name|nic_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|isloopback
decl_stmt|;
name|int
name|iswildcard
decl_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"interface_action: interface %s "
operator|,
operator|(
name|if_name
operator|!=
name|NULL
operator|)
condition|?
name|if_name
else|:
literal|"wildcard"
operator|)
argument_list|)
expr_stmt|;
name|iswildcard
operator|=
name|is_wildcard_addr
argument_list|(
name|if_addr
argument_list|)
expr_stmt|;
name|isloopback
operator|=
operator|!
operator|!
operator|(
name|INT_LOOPBACK
operator|&
name|if_flags
operator|)
expr_stmt|;
comment|/* 	 * Find any matching NIC rule from --interface / -I or ntp.conf 	 * interface/nic rules. 	 */
for|for
control|(
name|rule
operator|=
name|nic_rule_list
init|;
name|rule
operator|!=
name|NULL
condition|;
name|rule
operator|=
name|rule
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|rule
operator|->
name|match_type
condition|)
block|{
case|case
name|MATCH_ALL
case|:
comment|/* loopback and wildcard excluded from "all" */
if|if
condition|(
name|isloopback
operator|||
name|iswildcard
condition|)
break|break;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"nic all %s\n"
operator|,
name|action_text
argument_list|(
name|rule
operator|->
name|action
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rule
operator|->
name|action
return|;
case|case
name|MATCH_IPV4
case|:
if|if
condition|(
name|IS_IPV4
argument_list|(
name|if_addr
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"nic ipv4 %s\n"
operator|,
name|action_text
argument_list|(
name|rule
operator|->
name|action
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rule
operator|->
name|action
return|;
block|}
break|break;
case|case
name|MATCH_IPV6
case|:
if|if
condition|(
name|IS_IPV6
argument_list|(
name|if_addr
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"nic ipv6 %s\n"
operator|,
name|action_text
argument_list|(
name|rule
operator|->
name|action
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rule
operator|->
name|action
return|;
block|}
break|break;
case|case
name|MATCH_WILDCARD
case|:
if|if
condition|(
name|iswildcard
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"nic wildcard %s\n"
operator|,
name|action_text
argument_list|(
name|rule
operator|->
name|action
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rule
operator|->
name|action
return|;
block|}
break|break;
case|case
name|MATCH_IFADDR
case|:
if|if
condition|(
name|rule
operator|->
name|prefixlen
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|addr_eqprefix
argument_list|(
name|if_addr
argument_list|,
operator|&
name|rule
operator|->
name|addr
argument_list|,
name|rule
operator|->
name|prefixlen
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"subnet address match - %s\n"
operator|,
name|action_text
argument_list|(
name|rule
operator|->
name|action
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rule
operator|->
name|action
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|SOCK_EQ
argument_list|(
name|if_addr
argument_list|,
operator|&
name|rule
operator|->
name|addr
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"address match - %s\n"
operator|,
name|action_text
argument_list|(
name|rule
operator|->
name|action
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rule
operator|->
name|action
return|;
block|}
break|break;
case|case
name|MATCH_IFNAME
case|:
if|if
condition|(
name|if_name
operator|!=
name|NULL
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FNMATCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|FNM_CASEFOLD
argument_list|)
operator|&&
operator|!
name|fnmatch
argument_list|(
name|rule
operator|->
name|if_name
argument_list|,
name|if_name
argument_list|,
name|FNM_CASEFOLD
argument_list|)
else|#
directive|else
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|if_name
argument_list|,
name|rule
operator|->
name|if_name
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"interface name match - %s\n"
operator|,
name|action_text
argument_list|(
name|rule
operator|->
name|action
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rule
operator|->
name|action
return|;
block|}
break|break;
block|}
block|}
comment|/* 	 * Unless explicitly disabled such as with "nic ignore ::1" 	 * listen on loopback addresses.  Since ntpq and ntpdc query 	 * "localhost" by default, which typically resolves to ::1 and 	 * 127.0.0.1, it's useful to default to listening on both. 	 */
if|if
condition|(
name|isloopback
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"default loopback listen\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ACTION_LISTEN
return|;
block|}
comment|/* 	 * Treat wildcard addresses specially.  If there is no explicit 	 * "nic ... wildcard" or "nic ... 0.0.0.0" or "nic ... ::" rule 	 * default to drop. 	 */
if|if
condition|(
name|iswildcard
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"default wildcard drop\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ACTION_DROP
return|;
block|}
comment|/* 	 * Check for "virtual IP" (colon in the interface name) after 	 * the rules so that "ntpd --interface eth0:1 -novirtualips" 	 * does indeed listen on eth0:1's addresses. 	 */
if|if
condition|(
operator|!
name|listen_to_virtual_ips
operator|&&
name|if_name
operator|!=
name|NULL
operator|&&
operator|(
name|strchr
argument_list|(
name|if_name
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"virtual ip - ignore\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ACTION_IGNORE
return|;
block|}
comment|/* 	 * If there are no --interface/-I command-line options and no 	 * interface/nic rules in ntp.conf, the default action is to 	 * listen.  In the presence of rules from either, the default 	 * is to ignore.  This implements ntpd's traditional listen- 	 * every default with no interface listen configuration, and 	 * ensures a single -I eth0 or "nic listen eth0" means do not 	 * listen on any other addresses. 	 */
if|if
condition|(
name|NULL
operator|==
name|nic_rule_list
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"default listen\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ACTION_LISTEN
return|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"implicit ignore\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ACTION_IGNORE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_isc_if
parameter_list|(
name|isc_interface_t
modifier|*
name|isc_if
parameter_list|,
name|endpt
modifier|*
name|itf
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
specifier|const
name|u_char
name|v6loop
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
name|strlcpy
argument_list|(
name|itf
operator|->
name|name
argument_list|,
name|isc_if
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|itf
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|itf
operator|->
name|ifindex
operator|=
name|isc_if
operator|->
name|ifindex
expr_stmt|;
name|itf
operator|->
name|family
operator|=
operator|(
name|u_short
operator|)
name|isc_if
operator|->
name|af
expr_stmt|;
name|AF
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
operator|=
name|itf
operator|->
name|family
expr_stmt|;
name|AF
argument_list|(
operator|&
name|itf
operator|->
name|mask
argument_list|)
operator|=
name|itf
operator|->
name|family
expr_stmt|;
name|AF
argument_list|(
operator|&
name|itf
operator|->
name|bcast
argument_list|)
operator|=
name|itf
operator|->
name|family
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|itf
operator|->
name|mask
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|itf
operator|->
name|bcast
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IPV4
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
condition|)
block|{
name|NSRCADR
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
operator|=
name|isc_if
operator|->
name|address
operator|.
name|type
operator|.
name|in
operator|.
name|s_addr
expr_stmt|;
name|NSRCADR
argument_list|(
operator|&
name|itf
operator|->
name|mask
argument_list|)
operator|=
name|isc_if
operator|->
name|netmask
operator|.
name|type
operator|.
name|in
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_BROADCAST
condition|)
block|{
name|itf
operator|->
name|flags
operator||=
name|INT_BROADCAST
expr_stmt|;
name|NSRCADR
argument_list|(
operator|&
name|itf
operator|->
name|bcast
argument_list|)
operator|=
name|isc_if
operator|->
name|broadcast
operator|.
name|type
operator|.
name|in
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
elseif|else
if|if
condition|(
name|IS_IPV6
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
condition|)
block|{
name|SET_ADDR6N
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|,
name|isc_if
operator|->
name|address
operator|.
name|type
operator|.
name|in6
argument_list|)
expr_stmt|;
name|SET_ADDR6N
argument_list|(
operator|&
name|itf
operator|->
name|mask
argument_list|,
name|isc_if
operator|->
name|netmask
operator|.
name|type
operator|.
name|in6
argument_list|)
expr_stmt|;
name|SET_SCOPE
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|,
name|isc_if
operator|->
name|address
operator|.
name|zone
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
comment|/* Process the rest of the flags */
name|itf
operator|->
name|flags
operator||=
operator|(
operator|(
name|INTERFACE_F_UP
operator|&
name|isc_if
operator|->
name|flags
operator|)
condition|?
name|INT_UP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|INTERFACE_F_LOOPBACK
operator|&
name|isc_if
operator|->
name|flags
operator|)
condition|?
name|INT_LOOPBACK
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|INTERFACE_F_POINTTOPOINT
operator|&
name|isc_if
operator|->
name|flags
operator|)
condition|?
name|INT_PPP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|INTERFACE_F_MULTICAST
operator|&
name|isc_if
operator|->
name|flags
operator|)
condition|?
name|INT_MULTICAST
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|INTERFACE_F_PRIVACY
operator|&
name|isc_if
operator|->
name|flags
operator|)
condition|?
name|INT_PRIVACY
else|:
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Clear the loopback flag if the address is not localhost. 	 * http://bugs.ntp.org/1683 	 */
if|if
condition|(
name|INT_LOOPBACK
operator|&
name|itf
operator|->
name|flags
condition|)
block|{
if|if
condition|(
name|AF_INET
operator|==
name|itf
operator|->
name|family
condition|)
block|{
if|if
condition|(
literal|127
operator|!=
operator|(
name|SRCADR
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
operator|>>
literal|24
operator|)
condition|)
name|itf
operator|->
name|flags
operator|&=
operator|~
name|INT_LOOPBACK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|v6loop
argument_list|,
name|NSRCADR6
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|NSRCADR6
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
argument_list|)
argument_list|)
condition|)
name|itf
operator|->
name|flags
operator|&=
operator|~
name|INT_LOOPBACK
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * refresh_interface  *  * some OSes have been observed to keep  * cached routes even when more specific routes  * become available.  * this can be mitigated by re-binding  * the socket.  */
end_comment

begin_function
specifier|static
name|int
name|refresh_interface
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OS_MISSES_SPECIFIC_ROUTE_UPDATES
if|if
condition|(
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|int
name|bcast
init|=
operator|(
name|interface
operator|->
name|flags
operator|&
name|INT_BCASTXMIT
operator|)
operator|!=
literal|0
decl_stmt|;
comment|/* as we forcibly close() the socket remove the 		   broadcast permission indication */
if|if
condition|(
name|bcast
condition|)
name|socket_broadcast_disable
argument_list|(
name|interface
argument_list|,
operator|&
name|interface
operator|->
name|sin
argument_list|)
expr_stmt|;
name|close_and_delete_fd_from_list
argument_list|(
name|interface
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* create new socket picking up a new first hop binding 		   at connect() time */
name|interface
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|interface
operator|->
name|sin
argument_list|,
name|bcast
argument_list|,
literal|0
argument_list|,
name|interface
argument_list|)
expr_stmt|;
comment|/* 		  * reset TTL indication so TTL is is set again 		  * next time around 		  */
name|interface
operator|->
name|last_ttl
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
operator|)
return|;
block|}
else|else
return|return
literal|0
return|;
comment|/* invalid sockets are not refreshable */
else|#
directive|else
comment|/* !OS_MISSES_SPECIFIC_ROUTE_UPDATES */
return|return
operator|(
name|interface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
operator|)
return|;
endif|#
directive|endif
comment|/* !OS_MISSES_SPECIFIC_ROUTE_UPDATES */
block|}
end_function

begin_comment
comment|/*  * interface_update - externally callable update function  */
end_comment

begin_function
name|void
name|interface_update
parameter_list|(
name|interface_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|new_interface_found
decl_stmt|;
if|if
condition|(
name|disable_dynamic_updates
condition|)
return|return;
name|BLOCKIO
argument_list|()
expr_stmt|;
name|new_interface_found
operator|=
name|update_interfaces
argument_list|(
name|NTP_PORT
argument_list|,
name|receiver
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|new_interface_found
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"new interface(s) found: waking up resolver"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|interrupt_worker_sleep
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sau_from_netaddr() - convert network address on-wire formats.  * Convert from libisc's isc_netaddr_t to NTP's sockaddr_u  */
end_comment

begin_function
name|void
name|sau_from_netaddr
parameter_list|(
name|sockaddr_u
modifier|*
name|psau
parameter_list|,
specifier|const
name|isc_netaddr_t
modifier|*
name|pna
parameter_list|)
block|{
name|ZERO_SOCK
argument_list|(
name|psau
argument_list|)
expr_stmt|;
name|AF
argument_list|(
name|psau
argument_list|)
operator|=
operator|(
name|u_short
operator|)
name|pna
operator|->
name|family
expr_stmt|;
switch|switch
condition|(
name|pna
operator|->
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|memcpy
argument_list|(
operator|&
name|psau
operator|->
name|sa4
operator|.
name|sin_addr
argument_list|,
operator|&
name|pna
operator|->
name|type
operator|.
name|in
argument_list|,
sizeof|sizeof
argument_list|(
name|psau
operator|->
name|sa4
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|memcpy
argument_list|(
operator|&
name|psau
operator|->
name|sa6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|pna
operator|->
name|type
operator|.
name|in6
argument_list|,
sizeof|sizeof
argument_list|(
name|psau
operator|->
name|sa6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|is_wildcard_addr
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
name|psau
parameter_list|)
block|{
if|if
condition|(
name|IS_IPV4
argument_list|(
name|psau
argument_list|)
operator|&&
operator|!
name|NSRCADR
argument_list|(
name|psau
argument_list|)
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
if|if
condition|(
name|IS_IPV6
argument_list|(
name|psau
argument_list|)
operator|&&
name|S_ADDR6_EQ
argument_list|(
name|psau
argument_list|,
operator|&
name|in6addr_any
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OS_NEEDS_REUSEADDR_FOR_IFADDRBIND
end_ifdef

begin_comment
comment|/*  * enable/disable re-use of wildcard address socket  */
end_comment

begin_function
specifier|static
name|void
name|set_wildcard_reuse
parameter_list|(
name|u_short
name|family
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|any
decl_stmt|;
name|SOCKET
name|fd
init|=
name|INVALID_SOCKET
decl_stmt|;
name|any
operator|=
name|ANY_INTERFACE_BYFAM
argument_list|(
name|family
argument_list|)
expr_stmt|;
if|if
condition|(
name|any
operator|!=
name|NULL
condition|)
name|fd
operator|=
name|any
operator|->
name|fd
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"set_wildcard_reuse: setsockopt(SO_REUSEADDR, %s) failed: %m"
argument_list|,
name|on
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"set SO_REUSEADDR to %s on %s\n"
operator|,
name|on
condition|?
literal|"on"
else|:
literal|"off"
operator|,
name|stoa
argument_list|(
operator|&
name|any
operator|->
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS_NEEDS_REUSEADDR_FOR_IFADDRBIND */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|is_anycast
parameter_list|(
name|sockaddr_u
modifier|*
name|psau
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_IPV6_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGIFAFLAG_IN6
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|IN6_IFF_ANYCAST
argument_list|)
name|struct
name|in6_ifreq
name|ifr6
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|u_int32
name|flags6
decl_stmt|;
if|if
condition|(
name|psau
operator|->
name|sa
operator|.
name|sa_family
operator|!=
name|AF_INET6
condition|)
return|return
name|ISC_FALSE
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ISC_FALSE
return|;
name|ZERO
argument_list|(
name|ifr6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ifr6
operator|.
name|ifr_addr
argument_list|,
operator|&
name|psau
operator|->
name|sa6
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr6
operator|.
name|ifr_addr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifr6
operator|.
name|ifr_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr6
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFAFLAG_IN6
argument_list|,
operator|&
name|ifr6
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|flags6
operator|=
name|ifr6
operator|.
name|ifr_ifru
operator|.
name|ifru_flags6
expr_stmt|;
if|if
condition|(
operator|(
name|flags6
operator|&
name|IN6_IFF_ANYCAST
operator|)
operator|!=
literal|0
condition|)
return|return
name|ISC_TRUE
return|;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT&& SIOCGIFAFLAG_IN6&& IN6_IFF_ANYCAST */
return|return
name|ISC_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * update_interface strategy  *  * toggle configuration phase  *  * Phase 1:  * forall currently existing interfaces  *   if address is known:  *	drop socket - rebind again  *  *   if address is NOT known:  *	attempt to create a new interface entry  *  * Phase 2:  * forall currently known non MCAST and WILDCARD interfaces  *   if interface does not match configuration phase (not seen in phase 1):  *	remove interface from known interface list  *	forall peers associated with this interface  *         disconnect peer from this interface  *  * Phase 3:  *   attempt to re-assign interfaces to peers  *  */
end_comment

begin_function
specifier|static
name|int
name|update_interfaces
parameter_list|(
name|u_short
name|port
parameter_list|,
name|interface_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
init|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
decl_stmt|;
name|interface_info_t
name|ifi
decl_stmt|;
name|isc_interfaceiter_t
modifier|*
name|iter
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_interface_t
name|isc_if
decl_stmt|;
name|int
name|new_interface_found
decl_stmt|;
name|unsigned
name|int
name|family
decl_stmt|;
name|endpt
name|enumep
decl_stmt|;
name|endpt
modifier|*
name|ep
decl_stmt|;
name|endpt
modifier|*
name|next_ep
decl_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"update_interfaces(%d)\n"
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * phase one - scan interfaces 	 * - create those that are not found 	 * - update those that are found 	 */
name|new_interface_found
operator|=
name|FALSE
expr_stmt|;
name|iter
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_interfaceiter_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
literal|0
return|;
comment|/* 	 * Toggle system interface scan phase to find untouched 	 * interfaces to be deleted. 	 */
name|sys_interphase
operator|^=
literal|0x1
expr_stmt|;
for|for
control|(
name|result
operator|=
name|isc_interfaceiter_first
argument_list|(
name|iter
argument_list|)
init|;
name|ISC_R_SUCCESS
operator|==
name|result
condition|;
name|result
operator|=
name|isc_interfaceiter_next
argument_list|(
name|iter
argument_list|)
control|)
block|{
name|result
operator|=
name|isc_interfaceiter_current
argument_list|(
name|iter
argument_list|,
operator|&
name|isc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
comment|/* See if we have a valid family to use */
name|family
operator|=
name|isc_if
operator|.
name|address
operator|.
name|family
expr_stmt|;
if|if
condition|(
name|AF_INET
operator|!=
name|family
operator|&&
name|AF_INET6
operator|!=
name|family
condition|)
continue|continue;
if|if
condition|(
name|AF_INET
operator|==
name|family
operator|&&
operator|!
name|ipv4_works
condition|)
continue|continue;
if|if
condition|(
name|AF_INET6
operator|==
name|family
operator|&&
operator|!
name|ipv6_works
condition|)
continue|continue;
comment|/* create prototype */
name|init_interface
argument_list|(
operator|&
name|enumep
argument_list|)
expr_stmt|;
name|convert_isc_if
argument_list|(
operator|&
name|isc_if
argument_list|,
operator|&
name|enumep
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|DPRINT_INTERFACE
argument_list|(
literal|4
argument_list|,
operator|(
operator|&
name|enumep
operator|,
literal|"examining "
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Check if and how we are going to use the interface. 		 */
switch|switch
condition|(
name|interface_action
argument_list|(
name|enumep
operator|.
name|name
argument_list|,
operator|&
name|enumep
operator|.
name|sin
argument_list|,
name|enumep
operator|.
name|flags
argument_list|)
condition|)
block|{
case|case
name|ACTION_IGNORE
case|:
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"ignoring interface %s (%s) - by nic rules\n"
operator|,
name|enumep
operator|.
name|name
operator|,
name|stoa
argument_list|(
operator|&
name|enumep
operator|.
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ACTION_LISTEN
case|:
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"listen interface %s (%s) - by nic rules\n"
operator|,
name|enumep
operator|.
name|name
operator|,
name|stoa
argument_list|(
operator|&
name|enumep
operator|.
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|enumep
operator|.
name|ignore_packets
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
name|ACTION_DROP
case|:
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"drop on interface %s (%s) - by nic rules\n"
operator|,
name|enumep
operator|.
name|name
operator|,
name|stoa
argument_list|(
operator|&
name|enumep
operator|.
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|enumep
operator|.
name|ignore_packets
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
comment|/* interfaces must be UP to be usable */
if|if
condition|(
operator|!
operator|(
name|enumep
operator|.
name|flags
operator|&
name|INT_UP
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"skipping interface %s (%s) - DOWN\n"
operator|,
name|enumep
operator|.
name|name
operator|,
name|stoa
argument_list|(
operator|&
name|enumep
operator|.
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * skip any interfaces UP and bound to a wildcard 		 * address - some dhcp clients produce that in the 		 * wild 		 */
if|if
condition|(
name|is_wildcard_addr
argument_list|(
operator|&
name|enumep
operator|.
name|sin
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|is_anycast
argument_list|(
operator|&
name|enumep
operator|.
name|sin
argument_list|,
name|isc_if
operator|.
name|name
argument_list|)
condition|)
continue|continue;
comment|/* 		 * map to local *address* in order to map all duplicate 		 * interfaces to an endpt structure with the appropriate 		 * socket.  Our name space is (ip-address), NOT 		 * (interface name, ip-address). 		 */
name|ep
operator|=
name|getinterface
argument_list|(
operator|&
name|enumep
operator|.
name|sin
argument_list|,
name|INT_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
operator|&&
name|refresh_interface
argument_list|(
name|ep
argument_list|)
condition|)
block|{
comment|/* 			 * found existing and up to date interface - 			 * mark present. 			 */
if|if
condition|(
name|ep
operator|->
name|phase
operator|!=
name|sys_interphase
condition|)
block|{
comment|/* 				 * On a new round we reset the name so 				 * the interface name shows up again if 				 * this address is no longer shared. 				 * We reset ignore_packets from the 				 * new prototype to respect any runtime 				 * changes to the nic rules. 				 */
name|strlcpy
argument_list|(
name|ep
operator|->
name|name
argument_list|,
name|enumep
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ep
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|ignore_packets
operator|=
name|enumep
operator|.
name|ignore_packets
expr_stmt|;
block|}
else|else
block|{
comment|/* name collision - rename interface */
name|strlcpy
argument_list|(
name|ep
operator|->
name|name
argument_list|,
literal|"*multiple*"
argument_list|,
sizeof|sizeof
argument_list|(
name|ep
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DPRINT_INTERFACE
argument_list|(
literal|4
argument_list|,
operator|(
name|ep
operator|,
literal|"updating "
operator|,
literal|" present\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|ignore_packets
operator|!=
name|enumep
operator|.
name|ignore_packets
condition|)
block|{
comment|/* 				 * We have conflicting configurations 				 * for the interface address. This is 				 * caused by using -I<interfacename> 				 * for an interface that shares its 				 * address with other interfaces. We 				 * can not disambiguate incoming 				 * packets delivered to this socket 				 * without extra syscalls/features. 				 * These are not (commonly) available. 				 * Note this is a more unusual 				 * configuration where several 				 * interfaces share an address but 				 * filtering via interface name is 				 * attempted.  We resolve the 				 * configuration conflict by disabling 				 * the processing of received packets. 				 * This leads to no service on the 				 * interface address where the conflict 				 * occurs. 				 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WARNING: conflicting enable configuration for interfaces %s and %s for address %s - unsupported configuration - address DISABLED"
argument_list|,
name|enumep
operator|.
name|name
argument_list|,
name|ep
operator|->
name|name
argument_list|,
name|stoa
argument_list|(
operator|&
name|enumep
operator|.
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|ignore_packets
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|ep
operator|->
name|phase
operator|=
name|sys_interphase
expr_stmt|;
name|ifi
operator|.
name|action
operator|=
name|IFS_EXISTS
expr_stmt|;
name|ifi
operator|.
name|ep
operator|=
name|ep
expr_stmt|;
if|if
condition|(
name|receiver
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|receiver
call|)
argument_list|(
name|data
argument_list|,
operator|&
name|ifi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This is new or refreshing failed - add to 			 * our interface list.  If refreshing failed we 			 * will delete the interface structure in phase 			 * 2 as the interface was not marked current. 			 * We can bind to the address as the refresh 			 * code already closed the offending socket 			 */
name|ep
operator|=
name|create_interface
argument_list|(
name|port
argument_list|,
operator|&
name|enumep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|ifi
operator|.
name|action
operator|=
name|IFS_CREATED
expr_stmt|;
name|ifi
operator|.
name|ep
operator|=
name|ep
expr_stmt|;
if|if
condition|(
name|receiver
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|receiver
call|)
argument_list|(
name|data
argument_list|,
operator|&
name|ifi
argument_list|)
expr_stmt|;
name|new_interface_found
operator|=
name|TRUE
expr_stmt|;
name|DPRINT_INTERFACE
argument_list|(
literal|3
argument_list|,
operator|(
name|ep
operator|,
literal|"updating "
operator|,
literal|" new - created\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINT_INTERFACE
argument_list|(
literal|3
argument_list|,
operator|(
operator|&
name|enumep
operator|,
literal|"updating "
operator|,
literal|" new - creation FAILED"
operator|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"failed to init interface for address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|enumep
operator|.
name|sin
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|isc_interfaceiter_destroy
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
comment|/* 	 * phase 2 - delete gone interfaces - reassigning peers to 	 * other interfaces 	 */
for|for
control|(
name|ep
operator|=
name|ep_list
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|next_ep
control|)
block|{
name|next_ep
operator|=
name|ep
operator|->
name|elink
expr_stmt|;
comment|/* 		 * if phase does not match sys_phase this interface was 		 * not enumerated during the last interface scan - so it 		 * is gone and will be deleted here unless it did not 		 * originate from interface enumeration (INT_WILDCARD, 		 * INT_MCASTIF). 		 */
if|if
condition|(
operator|(
operator|(
name|INT_WILDCARD
operator||
name|INT_MCASTIF
operator|)
operator|&
name|ep
operator|->
name|flags
operator|)
operator|||
name|ep
operator|->
name|phase
operator|==
name|sys_interphase
condition|)
continue|continue;
name|DPRINT_INTERFACE
argument_list|(
literal|3
argument_list|,
operator|(
name|ep
operator|,
literal|"updating "
operator|,
literal|"GONE - deleting\n"
operator|)
argument_list|)
expr_stmt|;
name|remove_interface
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ifi
operator|.
name|action
operator|=
name|IFS_DELETED
expr_stmt|;
name|ifi
operator|.
name|ep
operator|=
name|ep
expr_stmt|;
if|if
condition|(
name|receiver
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|receiver
call|)
argument_list|(
name|data
argument_list|,
operator|&
name|ifi
argument_list|)
expr_stmt|;
comment|/* disconnect peers from deleted endpt. */
while|while
condition|(
name|ep
operator|->
name|peers
operator|!=
name|NULL
condition|)
name|set_peerdstadr
argument_list|(
name|ep
operator|->
name|peers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * update globals in case we lose 		 * a loopback interface 		 */
if|if
condition|(
name|ep
operator|==
name|loopback_interface
condition|)
name|loopback_interface
operator|=
name|NULL
expr_stmt|;
name|delete_interface
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * phase 3 - re-configure as the world has possibly changed 	 * 	 * never ever make this conditional again - it is needed to track 	 * routing updates. see bug #2506 	 */
name|refresh_all_peerinterfaces
argument_list|()
expr_stmt|;
if|if
condition|(
name|broadcast_client_enabled
condition|)
name|io_setbclient
argument_list|()
expr_stmt|;
return|return
name|new_interface_found
return|;
block|}
end_function

begin_comment
comment|/*  * create_sockets - create a socket for each interface plus a default  *			socket for when we don't know where to send  */
end_comment

begin_function
specifier|static
name|int
name|create_sockets
parameter_list|(
name|u_short
name|port
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
comment|/* 	 * I/O Completion Ports don't care about the select and FD_SET 	 */
name|maxactivefd
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|activefds
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"create_sockets(%d)\n"
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
name|create_wildcards
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|update_interfaces
argument_list|(
name|port
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we have opened all the sockets, turn off the reuse 	 * flag for security. 	 */
name|set_reuseaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"create_sockets: Total interfaces = %d\n"
operator|,
name|ninterfaces
operator|)
argument_list|)
expr_stmt|;
return|return
name|ninterfaces
return|;
block|}
end_function

begin_comment
comment|/*  * create_interface - create a new interface for a given prototype  *		      binding the socket.  */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|create_interface
parameter_list|(
name|u_short
name|port
parameter_list|,
name|struct
name|interface
modifier|*
name|protot
parameter_list|)
block|{
name|sockaddr_u
name|resmask
decl_stmt|;
name|endpt
modifier|*
name|iface
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MCAST
argument_list|)
operator|&&
name|defined
argument_list|(
name|MULTICAST_NONEWSOCKET
argument_list|)
name|remaddr_t
modifier|*
name|entry
decl_stmt|;
name|remaddr_t
modifier|*
name|next_entry
decl_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"create_interface(%s#%d)\n"
operator|,
name|stoa
argument_list|(
operator|&
name|protot
operator|->
name|sin
argument_list|)
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
comment|/* build an interface */
name|iface
operator|=
name|new_interface
argument_list|(
name|protot
argument_list|)
expr_stmt|;
comment|/* 	 * create socket 	 */
name|iface
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
name|log_listen_address
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INT_BROADCAST
operator|&
name|iface
operator|->
name|flags
operator|)
operator|&&
name|iface
operator|->
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listening on broadcast address %s#%d"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|iface
operator|->
name|bcast
operator|)
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_SOCKET
operator|==
name|iface
operator|->
name|fd
operator|&&
name|INVALID_SOCKET
operator|==
name|iface
operator|->
name|bfd
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to create socket on %s (%d) for %s#%d"
argument_list|,
name|iface
operator|->
name|name
argument_list|,
name|iface
operator|->
name|ifnum
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|iface
operator|->
name|sin
operator|)
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|delete_interface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Blacklist our own addresses, no use talking to ourself 	 */
name|SET_HOSTMASK
argument_list|(
operator|&
name|resmask
argument_list|,
name|AF
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|iface
operator|->
name|sin
argument_list|,
operator|&
name|resmask
argument_list|,
name|RESM_NTPONLY
operator||
name|RESM_INTERFACE
argument_list|,
name|RES_IGNORE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * set globals with the first found 	 * loopback interface of the appropriate class 	 */
if|if
condition|(
name|NULL
operator|==
name|loopback_interface
operator|&&
name|AF_INET
operator|==
name|iface
operator|->
name|family
operator|&&
operator|(
name|INT_LOOPBACK
operator|&
name|iface
operator|->
name|flags
operator|)
condition|)
name|loopback_interface
operator|=
name|iface
expr_stmt|;
comment|/* 	 * put into our interface list 	 */
name|add_addr_to_list
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|,
name|iface
argument_list|)
expr_stmt|;
name|add_interface
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MCAST
argument_list|)
operator|&&
name|defined
argument_list|(
name|MULTICAST_NONEWSOCKET
argument_list|)
comment|/* 	 * Join any previously-configured compatible multicast groups. 	 */
if|if
condition|(
name|INT_MULTICAST
operator|&
name|iface
operator|->
name|flags
operator|&&
operator|!
operator|(
operator|(
name|INT_LOOPBACK
operator||
name|INT_WILDCARD
operator|)
operator|&
name|iface
operator|->
name|flags
operator|)
operator|&&
operator|!
name|iface
operator|->
name|ignore_packets
condition|)
block|{
for|for
control|(
name|entry
operator|=
name|remoteaddr_list
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|next_entry
control|)
block|{
name|next_entry
operator|=
name|entry
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|AF
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|!=
name|AF
argument_list|(
operator|&
name|entry
operator|->
name|addr
argument_list|)
operator|||
operator|!
name|IS_MCAST
argument_list|(
operator|&
name|entry
operator|->
name|addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|socket_multicast_enable
argument_list|(
name|iface
argument_list|,
operator|&
name|entry
operator|->
name|addr
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Joined %s socket to multicast group %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|entry
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to join %s socket to multicast group %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|entry
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MCAST&& MCAST_NONEWSOCKET */
name|DPRINT_INTERFACE
argument_list|(
literal|2
argument_list|,
operator|(
name|iface
operator|,
literal|"created "
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|iface
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SO_EXCLUSIVEADDRUSE
end_ifdef

begin_function
specifier|static
name|void
name|set_excladdruse
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|int
name|one
init|=
literal|1
decl_stmt|;
name|int
name|failed
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|DWORD
name|err
decl_stmt|;
endif|#
directive|endif
name|failed
operator|=
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_EXCLUSIVEADDRUSE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|failed
condition|)
return|return;
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* 	 * Prior to Windows XP setting SO_EXCLUSIVEADDRUSE can fail with 	 * error WSAINVAL depending on service pack level and whether 	 * the user account is in the Administrators group.  Do not 	 * complain if it fails that way on versions prior to XP (5.1). 	 */
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|isc_win32os_versioncheck
argument_list|(
literal|5
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
comment|/*< 5.1/XP */
operator|&&
name|WSAEINVAL
operator|==
name|err
condition|)
return|return;
name|SetLastError
argument_list|(
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(%d, SO_EXCLUSIVEADDRUSE, on): %m"
argument_list|,
operator|(
name|int
operator|)
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SO_EXCLUSIVEADDRUSE */
end_comment

begin_comment
comment|/*  * set_reuseaddr() - set/clear REUSEADDR on all sockets  *			NB possible hole - should we be doing this on broadcast  *			fd's also?  */
end_comment

begin_function
specifier|static
name|void
name|set_reuseaddr
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SO_EXCLUSIVEADDRUSE
name|endpt
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|ep_list
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|elink
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|flags
operator|&
name|INT_WILDCARD
condition|)
continue|continue;
comment|/* 		 * if ep->fd  is INVALID_SOCKET, we might have a adapter 		 * configured but not present 		 */
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"setting SO_REUSEADDR on %.16s@%s to %s\n"
operator|,
name|ep
operator|->
name|name
operator|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
operator|,
name|flag
condition|?
literal|"on"
else|:
literal|"off"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|ep
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flag
argument_list|,
sizeof|sizeof
argument_list|(
name|flag
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"set_reuseaddr: setsockopt(%s, SO_REUSEADDR, %s) failed: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|,
name|flag
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* ! SO_EXCLUSIVEADDRUSE */
block|}
end_function

begin_comment
comment|/*  * This is just a wrapper around an internal function so we can  * make other changes as necessary later on  */
end_comment

begin_function
name|void
name|enable_broadcast
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|sockaddr_u
modifier|*
name|baddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPEN_BCAST_SOCKET
name|socket_broadcast_enable
argument_list|(
name|iface
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|baddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OPEN_BCAST_SOCKET
end_ifdef

begin_comment
comment|/*  * Enable a broadcast address to a given socket  * The socket is in the ep_list all we need to do is enable  * broadcasting. It is not this function's job to select the socket  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|socket_broadcast_enable
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|SOCKET
name|fd
parameter_list|,
name|sockaddr_u
modifier|*
name|baddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SO_BROADCAST
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|IS_IPV4
argument_list|(
name|baddr
argument_list|)
condition|)
block|{
comment|/* if this interface can support broadcast, set SO_BROADCAST */
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(SO_BROADCAST) enable failure on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|baddr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Broadcast enabled on socket %d for address %s\n"
operator|,
name|fd
operator|,
name|stoa
argument_list|(
name|baddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|iface
operator|->
name|flags
operator||=
name|INT_BCASTXMIT
expr_stmt|;
return|return
name|ISC_TRUE
return|;
else|#
directive|else
return|return
name|ISC_FALSE
return|;
endif|#
directive|endif
comment|/* SO_BROADCAST */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OS_MISSES_SPECIFIC_ROUTE_UPDATES
end_ifdef

begin_comment
comment|/*  * Remove a broadcast address from a given socket  * The socket is in the ep_list all we need to do is disable  * broadcasting. It is not this function's job to select the socket  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|socket_broadcast_disable
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|sockaddr_u
modifier|*
name|baddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SO_BROADCAST
name|int
name|off
init|=
literal|0
decl_stmt|;
comment|/* This seems to be OK as an int */
if|if
condition|(
name|IS_IPV4
argument_list|(
name|baddr
argument_list|)
operator|&&
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(SO_BROADCAST) disable failure on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|baddr
argument_list|)
argument_list|)
expr_stmt|;
name|iface
operator|->
name|flags
operator|&=
operator|~
name|INT_BCASTXMIT
expr_stmt|;
return|return
name|ISC_TRUE
return|;
else|#
directive|else
return|return
name|ISC_FALSE
return|;
endif|#
directive|endif
comment|/* SO_BROADCAST */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS_MISSES_SPECIFIC_ROUTE_UPDATES */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPEN_BCAST_SOCKET */
end_comment

begin_comment
comment|/*  * return the broadcast client flag value  */
end_comment

begin_function
name|isc_boolean_t
name|get_broadcastclient_flag
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|broadcast_client_enabled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the address is a multicast address  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|addr_ismulticast
parameter_list|(
name|sockaddr_u
modifier|*
name|maddr
parameter_list|)
block|{
name|isc_boolean_t
name|result
decl_stmt|;
ifndef|#
directive|ifndef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
comment|/* 	 * If we don't have IPV6 support any IPV6 addr is not multicast 	 */
if|if
condition|(
name|IS_IPV6
argument_list|(
name|maddr
argument_list|)
condition|)
name|result
operator|=
name|ISC_FALSE
expr_stmt|;
else|else
endif|#
directive|endif
name|result
operator|=
name|IS_MCAST
argument_list|(
name|maddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"address %s is not multicast\n"
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Multicast servers need to set the appropriate Multicast interface  * socket option in order for it to know which interface to use for  * send the multicast packet.  */
end_comment

begin_function
name|void
name|enable_multicast_if
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|sockaddr_u
modifier|*
name|maddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
ifdef|#
directive|ifdef
name|IP_MULTICAST_LOOP
name|TYPEOF_IP_MULTICAST_LOOP
name|off
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPV6_MULTICAST_LOOP
name|u_int
name|off6
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|NTP_REQUIRE
argument_list|(
name|AF
argument_list|(
name|maddr
argument_list|)
operator|==
name|AF
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|AF
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|IP_MULTICAST_LOOP
comment|/* 		 * Don't send back to itself, but allow failure to set 		 */
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_LOOP
argument_list|,
name|SETSOCKOPT_ARG_CAST
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_LOOP failed: %m on socket %d, addr %s for multicast address %s"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|AF_INET6
case|:
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
ifdef|#
directive|ifdef
name|IPV6_MULTICAST_LOOP
comment|/* 		 * Don't send back to itself, but allow failure to set 		 */
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_LOOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|off6
argument_list|,
sizeof|sizeof
argument_list|(
name|off6
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_MULTICAST_LOOP failed: %m on socket %d, addr %s for multicast address %s"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
else|#
directive|else
return|return;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
block|}
return|return;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Add a multicast address to a given socket  * The socket is in the ep_list all we need to do is enable  * multicasting. It is not this function's job to select the socket  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MCAST
argument_list|)
end_if

begin_function
specifier|static
name|isc_boolean_t
name|socket_multicast_enable
parameter_list|(
name|endpt
modifier|*
name|iface
parameter_list|,
name|sockaddr_u
modifier|*
name|maddr
parameter_list|)
block|{
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
name|struct
name|ipv6_mreq
name|mreq6
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|AF
argument_list|(
name|maddr
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
name|ZERO
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
name|mreq
operator|.
name|imr_multiaddr
operator|=
name|SOCK_ADDR4
argument_list|(
name|maddr
argument_list|)
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_ADD_MEMBERSHIP failed: %m on socket %d, addr %s for %x / %x (%s)"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
argument_list|,
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Added IPv4 multicast membership on socket %d, addr %s for %x / %x (%s)\n"
operator|,
name|iface
operator|->
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|,
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|,
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
comment|/* 		 * Enable reception of multicast packets. 		 * If the address is link-local we can get the 		 * interface index from the scope id. Don't do this 		 * for other types of multicast addresses. For now let 		 * the kernel figure it out. 		 */
name|ZERO
argument_list|(
name|mreq6
argument_list|)
expr_stmt|;
name|mreq6
operator|.
name|ipv6mr_multiaddr
operator|=
name|SOCK_ADDR6
argument_list|(
name|maddr
argument_list|)
expr_stmt|;
name|mreq6
operator|.
name|ipv6mr_interface
operator|=
name|iface
operator|->
name|ifindex
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_JOIN_GROUP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq6
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq6
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_JOIN_GROUP failed: %m on socket %d, addr %s for interface %u (%s)"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|mreq6
operator|.
name|ipv6mr_interface
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Added IPv6 multicast group on socket %d, addr %s for interface %u (%s)\n"
operator|,
name|iface
operator|->
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|,
name|mreq6
operator|.
name|ipv6mr_interface
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
return|return
name|ISC_FALSE
return|;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
block|}
name|iface
operator|->
name|flags
operator||=
name|INT_MCASTOPEN
expr_stmt|;
name|iface
operator|->
name|num_mcast
operator|++
expr_stmt|;
return|return
name|ISC_TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MCAST */
end_comment

begin_comment
comment|/*  * Remove a multicast address from a given socket  * The socket is in the ep_list all we need to do is disable  * multicasting. It is not this function's job to select the socket  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MCAST
end_ifdef

begin_function
specifier|static
name|isc_boolean_t
name|socket_multicast_disable
parameter_list|(
name|struct
name|interface
modifier|*
name|iface
parameter_list|,
name|sockaddr_u
modifier|*
name|maddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
name|struct
name|ipv6_mreq
name|mreq6
decl_stmt|;
endif|#
directive|endif
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
name|ZERO
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_addr_in_list
argument_list|(
name|maddr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"socket_multicast_disable(%s): not found\n"
operator|,
name|stoa
argument_list|(
name|maddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_TRUE
return|;
block|}
switch|switch
condition|(
name|AF
argument_list|(
name|maddr
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
name|mreq
operator|.
name|imr_multiaddr
operator|=
name|SOCK_ADDR4
argument_list|(
name|maddr
argument_list|)
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|=
name|SOCK_ADDR4
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_DROP_MEMBERSHIP failed: %m on socket %d, addr %s for %x / %x (%s)"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|SRCADR
argument_list|(
name|maddr
argument_list|)
argument_list|,
name|SRCADR
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
break|break;
case|case
name|AF_INET6
case|:
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
comment|/* 		 * Disable reception of multicast packets 		 * If the address is link-local we can get the 		 * interface index from the scope id.  Don't do this 		 * for other types of multicast addresses. For now let 		 * the kernel figure it out. 		 */
name|mreq6
operator|.
name|ipv6mr_multiaddr
operator|=
name|SOCK_ADDR6
argument_list|(
name|maddr
argument_list|)
expr_stmt|;
name|mreq6
operator|.
name|ipv6mr_interface
operator|=
name|iface
operator|->
name|ifindex
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|iface
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_LEAVE_GROUP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq6
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq6
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_LEAVE_GROUP failure: %m on socket %d, addr %s for %d (%s)"
argument_list|,
name|iface
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|iface
operator|->
name|ifindex
argument_list|,
name|stoa
argument_list|(
name|maddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ISC_FALSE
return|;
block|}
break|break;
else|#
directive|else
return|return
name|ISC_FALSE
return|;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
block|}
name|iface
operator|->
name|num_mcast
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|iface
operator|->
name|num_mcast
condition|)
name|iface
operator|->
name|flags
operator|&=
operator|~
name|INT_MCASTOPEN
expr_stmt|;
return|return
name|ISC_TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MCAST */
end_comment

begin_comment
comment|/*  * io_setbclient - open the broadcast client sockets  */
end_comment

begin_function
name|void
name|io_setbclient
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OPEN_BCAST_SOCKET
name|struct
name|interface
modifier|*
name|interf
decl_stmt|;
name|int
name|nif
decl_stmt|;
name|nif
operator|=
literal|0
expr_stmt|;
name|set_reuseaddr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|interf
operator|=
name|ep_list
init|;
name|interf
operator|!=
name|NULL
condition|;
name|interf
operator|=
name|interf
operator|->
name|elink
control|)
block|{
if|if
condition|(
name|interf
operator|->
name|flags
operator|&
operator|(
name|INT_WILDCARD
operator||
name|INT_LOOPBACK
operator|)
condition|)
continue|continue;
comment|/* use only allowed addresses */
if|if
condition|(
name|interf
operator|->
name|ignore_packets
condition|)
continue|continue;
comment|/* Need a broadcast-capable interface */
if|if
condition|(
operator|!
operator|(
name|interf
operator|->
name|flags
operator|&
name|INT_BROADCAST
operator|)
condition|)
continue|continue;
comment|/* Only IPv4 addresses are valid for broadcast */
name|NTP_REQUIRE
argument_list|(
name|IS_IPV4
argument_list|(
operator|&
name|interf
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do we already have the broadcast address open? */
if|if
condition|(
name|interf
operator|->
name|flags
operator|&
name|INT_BCASTOPEN
condition|)
block|{
comment|/* 			 * account for already open interfaces to avoid 			 * misleading warning below 			 */
name|nif
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Try to open the broadcast address 		 */
name|interf
operator|->
name|family
operator|=
name|AF_INET
expr_stmt|;
name|interf
operator|->
name|bfd
operator|=
name|open_socket
argument_list|(
operator|&
name|interf
operator|->
name|bcast
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|interf
argument_list|)
expr_stmt|;
comment|/* 		 * If we succeeded then we use it otherwise enable 		 * broadcast on the interface address 		 */
if|if
condition|(
name|interf
operator|->
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|nif
operator|++
expr_stmt|;
name|interf
operator|->
name|flags
operator||=
name|INT_BCASTOPEN
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listen for broadcasts to %s on interface #%d %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|interf
operator|->
name|bcast
argument_list|)
argument_list|,
name|interf
operator|->
name|ifnum
argument_list|,
name|interf
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* silently ignore EADDRINUSE as we probably opened 			   the socket already for an address in the same network */
if|if
condition|(
name|errno
operator|!=
name|EADDRINUSE
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"failed to listen for broadcasts to %s on interface #%d %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|interf
operator|->
name|bcast
argument_list|)
argument_list|,
name|interf
operator|->
name|ifnum
argument_list|,
name|interf
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|set_reuseaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nif
operator|>
literal|0
condition|)
block|{
name|broadcast_client_enabled
operator|=
name|ISC_TRUE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"io_setbclient: listening to %d broadcast addresses\n"
operator|,
name|nif
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nif
condition|)
block|{
name|broadcast_client_enabled
operator|=
name|ISC_FALSE
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to listen for broadcasts, no broadcast interfaces available"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"io_setbclient: Broadcast Client disabled by build"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPEN_BCAST_SOCKET */
block|}
end_function

begin_comment
comment|/*  * io_unsetbclient - close the broadcast client sockets  */
end_comment

begin_function
name|void
name|io_unsetbclient
parameter_list|(
name|void
parameter_list|)
block|{
name|endpt
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|ep_list
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|elink
control|)
block|{
if|if
condition|(
name|INT_WILDCARD
operator|&
name|ep
operator|->
name|flags
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|INT_BCASTOPEN
operator|&
name|ep
operator|->
name|flags
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ep
operator|->
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
comment|/* destroy broadcast listening socket */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"stop listening for broadcasts to %s on interface #%d %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|bcast
argument_list|)
argument_list|,
name|ep
operator|->
name|ifnum
argument_list|,
name|ep
operator|->
name|name
argument_list|)
expr_stmt|;
name|close_and_delete_fd_from_list
argument_list|(
name|ep
operator|->
name|bfd
argument_list|)
expr_stmt|;
name|ep
operator|->
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|ep
operator|->
name|flags
operator|&=
operator|~
name|INT_BCASTOPEN
expr_stmt|;
block|}
block|}
name|broadcast_client_enabled
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * io_multicast_add() - add multicast group address  */
end_comment

begin_function
name|void
name|io_multicast_add
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
name|endpt
modifier|*
name|ep
decl_stmt|;
name|endpt
modifier|*
name|one_ep
decl_stmt|;
comment|/* 	 * Check to see if this is a multicast address 	 */
if|if
condition|(
operator|!
name|addr_ismulticast
argument_list|(
name|addr
argument_list|)
condition|)
return|return;
comment|/* If we already have it we can just return */
if|if
condition|(
name|NULL
operator|!=
name|find_flagged_addr_in_list
argument_list|(
name|addr
argument_list|,
name|INT_MCASTOPEN
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Duplicate request found for multicast address %s"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|MULTICAST_NONEWSOCKET
name|ep
operator|=
name|new_interface
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Open a new socket for the multicast address 	 */
name|ep
operator|->
name|sin
operator|=
operator|*
name|addr
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|,
name|NTP_PORT
argument_list|)
expr_stmt|;
name|ep
operator|->
name|family
operator|=
name|AF
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|ep
operator|->
name|mask
argument_list|)
operator|=
name|ep
operator|->
name|family
expr_stmt|;
name|SET_ONESMASK
argument_list|(
operator|&
name|ep
operator|->
name|mask
argument_list|)
expr_stmt|;
name|set_reuseaddr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ep
operator|->
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|ep
operator|->
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|ep
operator|->
name|ignore_packets
operator|=
name|ISC_FALSE
expr_stmt|;
name|ep
operator|->
name|flags
operator||=
name|INT_MCASTIF
expr_stmt|;
name|strlcpy
argument_list|(
name|ep
operator|->
name|name
argument_list|,
literal|"multicast"
argument_list|,
sizeof|sizeof
argument_list|(
name|ep
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINT_INTERFACE
argument_list|(
literal|2
argument_list|,
operator|(
name|ep
operator|,
literal|"multicast add "
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|add_interface
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|log_listen_address
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* bind failed, re-use wildcard interface */
name|delete_interface
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IPV4
argument_list|(
name|addr
argument_list|)
condition|)
name|ep
operator|=
name|wildipv4
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
condition|)
name|ep
operator|=
name|wildipv6
expr_stmt|;
else|else
name|ep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
comment|/* HACK ! -- stuff in an address */
comment|/* because we don't bind addr? DH */
name|ep
operator|->
name|bcast
operator|=
operator|*
name|addr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"multicast address %s using wildcard interface #%d %s"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|ep
operator|->
name|ifnum
argument_list|,
name|ep
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No multicast socket available to use for address %s"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|{
comment|/* in place of the { following for in #else clause */
name|one_ep
operator|=
name|ep
expr_stmt|;
else|#
directive|else
comment|/* MULTICAST_NONEWSOCKET follows */
comment|/* 	 * For the case where we can't use a separate socket (Windows) 	 * join each applicable endpoint socket to the group address. 	 */
if|if
condition|(
name|IS_IPV4
argument_list|(
name|addr
argument_list|)
condition|)
name|one_ep
operator|=
name|wildipv4
expr_stmt|;
else|else
name|one_ep
operator|=
name|wildipv6
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|ep_list
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|elink
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|ignore_packets
operator|||
name|AF
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
operator|!=
name|AF
argument_list|(
name|addr
argument_list|)
operator|||
operator|!
operator|(
name|INT_MULTICAST
operator|&
name|ep
operator|->
name|flags
operator|)
operator|||
operator|(
name|INT_LOOPBACK
operator||
name|INT_WILDCARD
operator|)
operator|&
name|ep
operator|->
name|flags
condition|)
continue|continue;
name|one_ep
operator|=
name|ep
expr_stmt|;
endif|#
directive|endif
comment|/* MULTICAST_NONEWSOCKET */
if|if
condition|(
name|socket_multicast_enable
argument_list|(
name|ep
argument_list|,
name|addr
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Joined %s socket to multicast group %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to join %s socket to multicast group %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|add_addr_to_list
argument_list|(
name|addr
argument_list|,
name|one_ep
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !MCAST  follows*/
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can not add multicast address %s: no multicast support"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/*  * io_multicast_del() - delete multicast group address  */
name|void
name|io_multicast_del
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
name|endpt
modifier|*
name|iface
decl_stmt|;
comment|/* 	 * Check to see if this is a multicast address 	 */
if|if
condition|(
operator|!
name|addr_ismulticast
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid multicast address %s"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Disable reception of multicast packets 	 */
while|while
condition|(
operator|(
name|iface
operator|=
name|find_flagged_addr_in_list
argument_list|(
name|addr
argument_list|,
name|INT_MCASTOPEN
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|socket_multicast_disable
argument_list|(
name|iface
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|delete_addr_from_list
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not MCAST */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can not delete multicast address %s: no multicast support"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not MCAST */
block|}
comment|/*  * open_socket - open a socket, returning the file descriptor  */
specifier|static
name|SOCKET
name|open_socket
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|int
name|bcast
parameter_list|,
name|int
name|turn_off_reuse
parameter_list|,
name|endpt
modifier|*
name|interf
parameter_list|)
block|{
name|SOCKET
name|fd
decl_stmt|;
name|int
name|errval
decl_stmt|;
name|char
name|scopetext
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * int is OK for REUSEADR per 	 * http://www.kohala.com/start/mcast.api.txt 	 */
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|IPTOS_DSCP_EF
define|#
directive|define
name|IPTOS_DSCP_EF
value|0xb8
endif|#
directive|endif
name|int
name|qos
init|=
name|IPTOS_DSCP_EF
decl_stmt|;
comment|/* QoS RFC3246 */
if|if
condition|(
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
operator|&&
operator|!
name|ipv6_works
condition|)
return|return
name|INVALID_SOCKET
return|;
comment|/* create a datagram (UDP) socket */
name|fd
operator|=
name|socket
argument_list|(
name|AF
argument_list|(
name|addr
argument_list|)
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_SOCKET
operator|==
name|fd
condition|)
block|{
name|errval
operator|=
name|socket_errno
argument_list|()
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(AF_INET%s, SOCK_DGRAM, 0) failed on address %s: %m"
argument_list|,
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
condition|?
literal|"6"
else|:
literal|""
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errval
operator|==
name|EPROTONOSUPPORT
operator|||
name|errval
operator|==
name|EAFNOSUPPORT
operator|||
name|errval
operator|==
name|EPFNOSUPPORT
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
name|errno
operator|=
name|errval
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unexpected socket() error %m code %d (not EPROTONOSUPPORT nor EAFNOSUPPORT nor EPFNOSUPPORT) - exiting"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYS_WINNT
name|connection_reset_fix
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Fixup the file descriptor for some systems 	 * See bug #530 for details of the issue. 	 */
name|fd
operator|=
name|move_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * set SO_REUSEADDR since we will be binding the same port 	 * number on each interface according to turn_off_reuse. 	 * This is undesirable on Windows versions starting with 	 * Windows XP (numeric version 5.1). 	 */
ifdef|#
directive|ifdef
name|SYS_WINNT
if|if
condition|(
name|isc_win32os_versioncheck
argument_list|(
literal|5
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
comment|/* before 5.1 */
endif|#
directive|endif
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|turn_off_reuse
operator|)
condition|?
operator|&
name|off
else|:
operator|&
name|on
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt SO_REUSEADDR %s fails for address %s: %m"
argument_list|,
operator|(
name|turn_off_reuse
operator|)
condition|?
literal|"off"
else|:
literal|"on"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
ifdef|#
directive|ifdef
name|SO_EXCLUSIVEADDRUSE
comment|/* 	 * setting SO_EXCLUSIVEADDRUSE on the wildcard we open 	 * first will cause more specific binds to fail. 	 */
if|if
condition|(
operator|!
operator|(
name|interf
operator|->
name|flags
operator|&
name|INT_WILDCARD
operator|)
condition|)
name|set_excladdruse
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * IPv4 specific options go here 	 */
if|if
condition|(
name|IS_IPV4
argument_list|(
name|addr
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPPROTO_IP
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_TOS
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TOS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|qos
argument_list|,
sizeof|sizeof
argument_list|(
name|qos
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_TOS (%02x) fails on address %s: %m"
argument_list|,
name|qos
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPPROTO_IP&& IP_TOS */
if|if
condition|(
name|bcast
condition|)
name|socket_broadcast_enable
argument_list|(
name|interf
argument_list|,
name|fd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * IPv6 specific options go here 	 */
if|if
condition|(
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPPROTO_IPV6
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6_TCLASS
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_TCLASS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|qos
argument_list|,
sizeof|sizeof
argument_list|(
name|qos
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_TCLASS (%02x) fails on address %s: %m"
argument_list|,
name|qos
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPPROTO_IPV6&& IPV6_TCLASS */
ifdef|#
directive|ifdef
name|IPV6_V6ONLY
if|if
condition|(
name|isc_net_probe_ipv6only
argument_list|()
operator|==
name|ISC_R_SUCCESS
operator|&&
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_V6ONLY on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPV6_BINDV6ONLY
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_BINDV6ONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_BINDV6ONLY on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OS_NEEDS_REUSEADDR_FOR_IFADDRBIND
comment|/* 	 * some OSes don't allow binding to more specific 	 * addresses if a wildcard address already bound 	 * to the port and SO_REUSEADDR is not set 	 */
if|if
condition|(
operator|!
name|is_wildcard_addr
argument_list|(
name|addr
argument_list|)
condition|)
name|set_wildcard_reuse
argument_list|(
name|AF
argument_list|(
name|addr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * bind the local address. 	 */
name|errval
operator|=
name|bind
argument_list|(
name|fd
argument_list|,
operator|&
name|addr
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OS_NEEDS_REUSEADDR_FOR_IFADDRBIND
if|if
condition|(
operator|!
name|is_wildcard_addr
argument_list|(
name|addr
argument_list|)
condition|)
name|set_wildcard_reuse
argument_list|(
name|AF
argument_list|(
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|errval
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Don't log this under all conditions 		 */
if|if
condition|(
name|turn_off_reuse
operator|==
literal|0
ifdef|#
directive|ifdef
name|DEBUG
operator|||
name|debug
operator|>
literal|1
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|SCOPE
argument_list|(
name|addr
argument_list|)
condition|)
name|snprintf
argument_list|(
name|scopetext
argument_list|,
sizeof|sizeof
argument_list|(
name|scopetext
argument_list|)
argument_list|,
literal|"%%%d"
argument_list|,
name|SCOPE
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|scopetext
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind(%d) AF_INET%s %s%s#%d%s flags 0x%x failed: %m"
argument_list|,
name|fd
argument_list|,
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
condition|?
literal|"6"
else|:
literal|""
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|scopetext
argument_list|,
name|SRCPORT
argument_list|(
name|addr
argument_list|)
argument_list|,
name|IS_MCAST
argument_list|(
name|addr
argument_list|)
condition|?
literal|" (multicast)"
else|:
literal|""
argument_list|,
name|interf
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMP
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TIMESTAMP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"setsockopt SO_TIMESTAMP on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"setsockopt SO_TIMESTAMP enabled on fd %d address %s\n"
operator|,
name|fd
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMPNS
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TIMESTAMPNS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"setsockopt SO_TIMESTAMPNS on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"setsockopt SO_TIMESTAMPNS enabled on fd %d address %s\n"
operator|,
name|fd
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_BINTIME
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BINTIME
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"setsockopt SO_BINTIME on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"setsockopt SO_BINTIME enabled on fd %d address %s\n"
operator|,
name|fd
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"bind(%d) AF_INET%s, addr %s%%%d#%d, flags 0x%x\n"
operator|,
name|fd
operator|,
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
condition|?
literal|"6"
else|:
literal|""
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|,
name|SCOPE
argument_list|(
name|addr
argument_list|)
operator|,
name|SRCPORT
argument_list|(
name|addr
argument_list|)
operator|,
name|interf
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|make_socket_nonblocking
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
name|init_socket_sig
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGNALED_IO */
name|add_fd_to_list
argument_list|(
name|fd
argument_list|,
name|FD_TYPE_SOCKET
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"flags for fd %d: 0x%x\n"
operator|,
name|fd
operator|,
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT || VMS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
comment|/*  * Add the socket to the completion port  */
if|if
condition|(
name|io_completion_port_add_socket
argument_list|(
name|fd
argument_list|,
name|interf
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to set up io completion port - EXITING"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|fd
return|;
block|}
ifdef|#
directive|ifdef
name|SYS_WINNT
define|#
directive|define
name|sendto
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|,
name|dest
parameter_list|,
name|destsz
parameter_list|)
define|\
value|io_completion_port_sendto(fd, buf, len, (sockaddr_u *)(dest))
endif|#
directive|endif
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
comment|/*  * sendpkt - send a packet to the specified destination. Maintain a  * send error cache so that only the first consecutive error for a  * destination is logged.  */
name|void
name|sendpkt
parameter_list|(
name|sockaddr_u
modifier|*
name|dest
parameter_list|,
name|struct
name|interface
modifier|*
name|ep
parameter_list|,
name|int
name|ttl
parameter_list|,
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|endpt
modifier|*
name|src
decl_stmt|;
name|int
name|ismcast
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|u_char
name|cttl
decl_stmt|;
name|ismcast
operator|=
name|IS_MCAST
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ismcast
condition|)
name|src
operator|=
name|ep
expr_stmt|;
else|else
name|src
operator|=
operator|(
name|IS_IPV4
argument_list|(
name|dest
argument_list|)
operator|)
condition|?
name|mc4_list
else|:
name|mc6_list
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|src
condition|)
block|{
comment|/* 		 * unbound peer - drop request and wait for better 		 * network conditions 		 */
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%ssendpkt(dst=%s, ttl=%d, len=%d): no interface - IGNORED\n"
operator|,
name|ismcast
condition|?
literal|"\tMCAST\t***** "
else|:
literal|""
operator|,
name|stoa
argument_list|(
name|dest
argument_list|)
operator|,
name|ttl
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%ssendpkt(%d, dst=%s, src=%s, ttl=%d, len=%d)\n"
operator|,
name|ismcast
condition|?
literal|"\tMCAST\t***** "
else|:
literal|""
operator|,
name|src
operator|->
name|fd
operator|,
name|stoa
argument_list|(
name|dest
argument_list|)
operator|,
name|stoa
argument_list|(
operator|&
name|src
operator|->
name|sin
argument_list|)
operator|,
name|ttl
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MCAST
comment|/* 		 * for the moment we use the bcast option to set multicast ttl 		 */
if|if
condition|(
name|ismcast
operator|&&
name|ttl
operator|>
literal|0
operator|&&
name|ttl
operator|!=
name|src
operator|->
name|last_ttl
condition|)
block|{
comment|/* 			 * set the multicast ttl for outgoing packets 			 */
switch|switch
condition|(
name|AF
argument_list|(
operator|&
name|src
operator|->
name|sin
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
name|cttl
operator|=
operator|(
name|u_char
operator|)
name|ttl
expr_stmt|;
name|rc
operator|=
name|setsockopt
argument_list|(
name|src
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_TTL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cttl
argument_list|,
sizeof|sizeof
argument_list|(
name|cttl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
case|case
name|AF_INET6
case|:
name|rc
operator|=
name|setsockopt
argument_list|(
name|src
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_HOPS
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|ttl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INCLUDE_IPV6_SUPPORT */
default|default:
name|rc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rc
condition|)
name|src
operator|->
name|last_ttl
operator|=
name|ttl
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_TTL/IPV6_MULTICAST_HOPS fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|src
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MCAST */
ifdef|#
directive|ifdef
name|SIM
name|cc
operator|=
name|simulate_server
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
else|#
directive|else
name|cc
operator|=
name|sendto
argument_list|(
name|src
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
operator|(
name|u_int
operator|)
name|len
argument_list|,
literal|0
argument_list|,
operator|&
name|dest
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
name|src
operator|->
name|notsent
operator|++
expr_stmt|;
name|packets_notsent
operator|++
expr_stmt|;
block|}
else|else
block|{
name|src
operator|->
name|sent
operator|++
expr_stmt|;
name|packets_sent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ismcast
condition|)
name|src
operator|=
name|src
operator|->
name|mclink
expr_stmt|;
block|}
do|while
condition|(
name|ismcast
operator|&&
name|src
operator|!=
name|NULL
condition|)
do|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
comment|/*  * fdbits - generate ascii representation of fd_set (FAU debug support)  * HFDF format - highest fd first.  */
specifier|static
name|char
modifier|*
name|fdbits
parameter_list|(
name|int
name|count
parameter_list|,
name|fd_set
modifier|*
name|set
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|buffer
decl_stmt|;
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
literal|255
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|FD_ISSET
argument_list|(
name|count
argument_list|,
name|set
argument_list|)
condition|?
literal|'#'
else|:
literal|'-'
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/*  * Routine to read the refclock packets for a specific interface  * Return the number of bytes read. That way we know if we should  * read it again or go on to the next one if no bytes returned  */
specifier|static
specifier|inline
name|int
name|read_refclock_packet
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|struct
name|refclockio
modifier|*
name|rp
parameter_list|,
name|l_fp
name|ts
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
name|int
name|consumed
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|rb
condition|)
block|{
comment|/* 		 * No buffer space available - just drop the packet 		 */
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
name|buflen
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|packets_dropped
operator|++
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
name|i
operator|=
operator|(
name|rp
operator|->
name|datalen
operator|==
literal|0
operator|||
name|rp
operator|->
name|datalen
operator|>
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
else|:
name|rp
operator|->
name|datalen
expr_stmt|;
do|do
block|{
name|buflen
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
operator|(
name|u_int
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|buflen
operator|<
literal|0
operator|&&
name|EINTR
operator|==
name|errno
condition|)
do|;
if|if
condition|(
name|buflen
operator|<=
literal|0
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
return|return
name|buflen
return|;
block|}
comment|/* 	 * Got one. Mark how and when it got here, 	 * put it on the full list and do bookkeeping. 	 */
name|rb
operator|->
name|recv_length
operator|=
name|buflen
expr_stmt|;
name|rb
operator|->
name|recv_peer
operator|=
name|rp
operator|->
name|srcclock
expr_stmt|;
name|rb
operator|->
name|dstadr
operator|=
literal|0
expr_stmt|;
name|rb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|rp
operator|->
name|clock_recv
expr_stmt|;
name|consumed
operator|=
name|indicate_refclock_packet
argument_list|(
name|rp
argument_list|,
name|rb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|consumed
condition|)
block|{
name|rp
operator|->
name|recvcount
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
block|}
return|return
name|buflen
return|;
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
ifdef|#
directive|ifdef
name|HAVE_PACKET_TIMESTAMP
comment|/*  * extract timestamps from control message buffer  */
specifier|static
name|l_fp
name|fetch_timestamp
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rb
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msghdr
parameter_list|,
name|l_fp
name|ts
parameter_list|)
block|{
name|struct
name|cmsghdr
modifier|*
name|cmsghdr
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_BINTIME
name|struct
name|bintime
modifier|*
name|btp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMPNS
name|struct
name|timespec
modifier|*
name|tsp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMP
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|long
name|ticks
decl_stmt|;
name|double
name|fuzz
decl_stmt|;
name|l_fp
name|lfpfuzz
decl_stmt|;
name|l_fp
name|nts
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_TIMING
name|l_fp
name|dts
decl_stmt|;
endif|#
directive|endif
name|cmsghdr
operator|=
name|CMSG_FIRSTHDR
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmsghdr
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|cmsghdr
operator|->
name|cmsg_type
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_BINTIME
case|case
name|SCM_BINTIME
case|:
endif|#
directive|endif
comment|/* HAVE_BINTIME */
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMPNS
case|case
name|SCM_TIMESTAMPNS
case|:
endif|#
directive|endif
comment|/* HAVE_TIMESTAMPNS */
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMP
case|case
name|SCM_TIMESTAMP
case|:
endif|#
directive|endif
comment|/* HAVE_TIMESTAMP */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BINTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TIMESTAMPNS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TIMESTAMP
argument_list|)
switch|switch
condition|(
name|cmsghdr
operator|->
name|cmsg_type
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_BINTIME
case|case
name|SCM_BINTIME
case|:
name|btp
operator|=
operator|(
expr|struct
name|bintime
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsghdr
argument_list|)
expr_stmt|;
comment|/* 				 * bintime documentation is at http://phk.freebsd.dk/pubs/timecounter.pdf 				 */
name|nts
operator|.
name|l_i
operator|=
name|btp
operator|->
name|sec
operator|+
name|JAN_1970
expr_stmt|;
name|nts
operator|.
name|l_uf
operator|=
call|(
name|u_int32
call|)
argument_list|(
name|btp
operator|->
name|frac
operator|>>
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_tick
operator|>
name|measured_tick
operator|&&
name|sys_tick
operator|>
literal|1e-9
condition|)
block|{
name|ticks
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|nts
operator|.
name|l_uf
operator|/
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sys_tick
operator|*
name|FRAC
argument_list|)
argument_list|)
expr_stmt|;
name|nts
operator|.
name|l_uf
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|ticks
operator|*
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sys_tick
operator|*
name|FRAC
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"fetch_timestamp: system bintime network time stamp: %ld.%09lu\n"
operator|,
name|btp
operator|->
name|sec
operator|,
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|nts
operator|.
name|l_uf
operator|/
name|FRAC
operator|)
operator|*
literal|1e9
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE_BINTIME */
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMPNS
case|case
name|SCM_TIMESTAMPNS
case|:
name|tsp
operator|=
operator|(
expr|struct
name|timespec
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsghdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_tick
operator|>
name|measured_tick
operator|&&
name|sys_tick
operator|>
literal|1e-9
condition|)
block|{
name|ticks
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|tsp
operator|->
name|tv_nsec
operator|*
literal|1e-9
operator|)
operator|/
name|sys_tick
argument_list|)
expr_stmt|;
name|tsp
operator|->
name|tv_nsec
operator|=
call|(
name|long
call|)
argument_list|(
name|ticks
operator|*
literal|1e9
operator|*
name|sys_tick
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"fetch_timestamp: system nsec network time stamp: %ld.%09ld\n"
operator|,
name|tsp
operator|->
name|tv_sec
operator|,
name|tsp
operator|->
name|tv_nsec
operator|)
argument_list|)
expr_stmt|;
name|nts
operator|=
name|tspec_stamp_to_lfp
argument_list|(
operator|*
name|tsp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE_TIMESTAMPNS */
ifdef|#
directive|ifdef
name|HAVE_TIMESTAMP
case|case
name|SCM_TIMESTAMP
case|:
name|tvp
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsghdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_tick
operator|>
name|measured_tick
operator|&&
name|sys_tick
operator|>
literal|1e-6
condition|)
block|{
name|ticks
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|tvp
operator|->
name|tv_usec
operator|*
literal|1e-6
operator|)
operator|/
name|sys_tick
argument_list|)
expr_stmt|;
name|tvp
operator|->
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|ticks
operator|*
literal|1e6
operator|*
name|sys_tick
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"fetch_timestamp: system usec network time stamp: %ld.%06ld\n"
operator|,
name|tvp
operator|->
name|tv_sec
operator|,
name|tvp
operator|->
name|tv_usec
operator|)
argument_list|)
expr_stmt|;
name|nts
operator|=
name|tval_stamp_to_lfp
argument_list|(
operator|*
name|tvp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE_TIMESTAMP */
block|}
name|fuzz
operator|=
name|ntp_random
argument_list|()
operator|*
literal|2.
operator|/
name|FRAC
operator|*
name|sys_fuzz
expr_stmt|;
name|DTOLFP
argument_list|(
name|fuzz
argument_list|,
operator|&
name|lfpfuzz
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|nts
argument_list|,
operator|&
name|lfpfuzz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_TIMING
name|dts
operator|=
name|ts
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|dts
argument_list|,
operator|&
name|nts
argument_list|)
expr_stmt|;
name|collect_timing
argument_list|(
name|rb
argument_list|,
literal|"input processing delay"
argument_list|,
literal|1
argument_list|,
operator|&
name|dts
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"fetch_timestamp: timestamp delta: %s (incl. fuzz)\n"
operator|,
name|lfptoa
argument_list|(
operator|&
name|dts
argument_list|,
literal|9
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_TIMING */
name|ts
operator|=
name|nts
expr_stmt|;
comment|/* network time stamp */
break|break;
endif|#
directive|endif
comment|/* HAVE_BINTIME || HAVE_TIMESTAMPNS || HAVE_TIMESTAMP */
default|default:
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"fetch_timestamp: skipping control message 0x%x\n"
operator|,
name|cmsghdr
operator|->
name|cmsg_type
operator|)
argument_list|)
expr_stmt|;
block|}
name|cmsghdr
operator|=
name|CMSG_NXTHDR
argument_list|(
name|msghdr
argument_list|,
name|cmsghdr
argument_list|)
expr_stmt|;
block|}
return|return
name|ts
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_PACKET_TIMESTAMP */
comment|/*  * Routine to read the network NTP packets for a specific interface  * Return the number of bytes read. That way we know if we should  * read it again or go on to the next one if no bytes returned  */
specifier|static
specifier|inline
name|int
name|read_network_packet
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|struct
name|interface
modifier|*
name|itf
parameter_list|,
name|l_fp
name|ts
parameter_list|)
block|{
name|GETSOCKNAME_SOCKLEN_TYPE
name|fromlen
decl_stmt|;
name|int
name|buflen
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PACKET_TIMESTAMP
name|struct
name|msghdr
name|msghdr
decl_stmt|;
name|struct
name|iovec
name|iovec
decl_stmt|;
name|char
name|control
index|[
name|CMSG_BUFSIZE
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Get a buffer and read the frame.  If we 	 * haven't got a buffer, or this is received 	 * on a disallowed socket, just dump the 	 * packet. 	 */
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|rb
operator|||
name|itf
operator|->
name|ignore_packets
condition|)
block|{
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
name|sockaddr_u
name|from
decl_stmt|;
if|if
condition|(
name|rb
operator|!=
name|NULL
condition|)
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
operator|.
name|sa
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s on (%lu) fd=%d from %s\n"
operator|,
operator|(
name|itf
operator|->
name|ignore_packets
operator|)
condition|?
literal|"ignore"
else|:
literal|"drop"
operator|,
name|free_recvbuffs
argument_list|()
operator|,
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|from
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|itf
operator|->
name|ignore_packets
condition|)
name|packets_ignored
operator|++
expr_stmt|;
else|else
name|packets_dropped
operator|++
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_PACKET_TIMESTAMP
name|rb
operator|->
name|recv_length
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|rb
operator|->
name|recv_srcadr
operator|.
name|sa
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
else|#
directive|else
name|iovec
operator|.
name|iov_base
operator|=
operator|&
name|rb
operator|->
name|recv_space
expr_stmt|;
name|iovec
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
expr_stmt|;
name|msghdr
operator|.
name|msg_name
operator|=
operator|&
name|rb
operator|->
name|recv_srcadr
expr_stmt|;
name|msghdr
operator|.
name|msg_namelen
operator|=
name|fromlen
expr_stmt|;
name|msghdr
operator|.
name|msg_iov
operator|=
operator|&
name|iovec
expr_stmt|;
name|msghdr
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msghdr
operator|.
name|msg_control
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|control
expr_stmt|;
name|msghdr
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|msghdr
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|recvmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|msghdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buflen
operator|=
name|rb
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|buflen
operator|==
literal|0
operator|||
operator|(
name|buflen
operator|==
operator|-
literal|1
operator|&&
operator|(
name|EWOULDBLOCK
operator|==
name|errno
ifdef|#
directive|ifdef
name|EAGAIN
operator|||
name|EAGAIN
operator|==
name|errno
endif|#
directive|endif
operator|)
operator|)
condition|)
block|{
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"recvfrom(%s) fd=%d: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|5
argument_list|,
operator|(
literal|"read_network_packet: fd=%d dropped (bad recvfrom)\n"
operator|,
name|fd
operator|)
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"read_network_packet: fd=%d length %d from %s\n"
operator|,
name|fd
operator|,
name|buflen
operator|,
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	** Bug 2672: Some OSes (MacOSX and Linux) don't block spoofed ::1 	*/
comment|// temporary hack...
ifndef|#
directive|ifndef
name|HAVE_SOLARIS_PRIVS
if|if
condition|(
name|AF_INET6
operator|==
name|itf
operator|->
name|family
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Got an IPv6 packet, from<%s> (%d) to<%s> (%d)\n"
operator|,
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
operator|,
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
operator|.
name|sa6
operator|.
name|sin6_addr
argument_list|)
operator|,
name|stoa
argument_list|(
operator|&
name|itf
operator|->
name|sin
argument_list|)
operator|,
operator|!
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|itf
operator|->
name|sin
operator|.
name|sa6
operator|.
name|sin6_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AF_INET6
operator|==
name|itf
operator|->
name|family
operator|&&
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
operator|.
name|sa6
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|itf
operator|->
name|sin
operator|.
name|sa6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|packets_dropped
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"DROPPING that packet\n"
operator|)
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
return|return
name|buflen
return|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"processing that packet\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Got one.  Mark how and when it got here, 	 * put it on the full list and do bookkeeping. 	 */
name|rb
operator|->
name|dstadr
operator|=
name|itf
expr_stmt|;
name|rb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PACKET_TIMESTAMP
comment|/* pick up a network time stamp if possible */
name|ts
operator|=
name|fetch_timestamp
argument_list|(
name|rb
argument_list|,
operator|&
name|msghdr
argument_list|,
name|ts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|receive
expr_stmt|;
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|itf
operator|->
name|received
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
comment|/*  * attempt to handle io (select()/signaled IO)  */
name|void
name|io_handler
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_SIGNALED_IO
name|fd_set
name|rdfdes
decl_stmt|;
name|int
name|nfound
decl_stmt|;
comment|/* 	 * Use select() on all on all input fd's for unlimited 	 * time.  select() will terminate on SIGALARM or on the 	 * reception of input.	Using select() means we can't do 	 * robust signal handling and we get a potential race 	 * between checking for alarms and doing the select(). 	 * Mostly harmless, I think. 	 */
comment|/* 	 * On VMS, I suspect that select() can't be interrupted 	 * by a "signal" either, so I take the easy way out and 	 * have select() time out after one second. 	 * System clock updates really aren't time-critical, 	 * and - lacking a hardware reference clock - I have 	 * yet to learn about anything else that is. 	 */
name|rdfdes
operator|=
name|activefds
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
name|nfound
operator|=
name|select
argument_list|(
name|maxactivefd
operator|+
literal|1
argument_list|,
operator|&
name|rdfdes
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS, VxWorks */
comment|/* make select() wake up after one second */
block|{
name|struct
name|timeval
name|t1
decl_stmt|;
name|t1
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|t1
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|nfound
operator|=
name|select
argument_list|(
name|maxactivefd
operator|+
literal|1
argument_list|,
operator|&
name|rdfdes
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VMS, VxWorks */
if|if
condition|(
name|nfound
operator|>
literal|0
condition|)
block|{
name|l_fp
name|ts
decl_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|input_handler
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfound
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select() error: %m"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"select(): nfound=%d, error: %m"
argument_list|,
name|nfound
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"select() returned %d: %m\n"
operator|,
name|nfound
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
else|#
directive|else
comment|/* HAVE_SIGNALED_IO */
name|wait_for_signal
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGNALED_IO */
block|}
comment|/*  * input_handler - receive packets asynchronously  */
specifier|static
name|void
name|input_handler
parameter_list|(
name|l_fp
modifier|*
name|cts
parameter_list|)
block|{
name|int
name|buflen
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|int
name|doing
decl_stmt|;
name|SOCKET
name|fd
decl_stmt|;
name|blocking_child
modifier|*
name|c
decl_stmt|;
name|struct
name|timeval
name|tvzero
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
comment|/* Timestamp at BOselect() gob */
ifdef|#
directive|ifdef
name|DEBUG_TIMING
name|l_fp
name|ts_e
decl_stmt|;
comment|/* Timestamp at EOselect() gob */
endif|#
directive|endif
name|fd_set
name|fds
decl_stmt|;
name|size_t
name|select_count
decl_stmt|;
name|endpt
modifier|*
name|ep
decl_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
name|struct
name|refclockio
modifier|*
name|rp
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
specifier|const
name|char
modifier|*
name|clk
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_ROUTING_SOCKET
name|struct
name|asyncio_reader
modifier|*
name|asyncio_reader
decl_stmt|;
name|struct
name|asyncio_reader
modifier|*
name|next_asyncio_reader
decl_stmt|;
endif|#
directive|endif
name|handler_calls
operator|++
expr_stmt|;
name|select_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we have something to do, freeze a timestamp. 	 * See below for the other cases (nothing left to do or error) 	 */
name|ts
operator|=
operator|*
name|cts
expr_stmt|;
comment|/* 	 * Do a poll to see who has data 	 */
name|fds
operator|=
name|activefds
expr_stmt|;
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|maxactivefd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvzero
argument_list|)
expr_stmt|;
comment|/* 	 * If there are no packets waiting just return 	 */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
name|int
name|j
decl_stmt|,
name|b
decl_stmt|,
name|prior
decl_stmt|;
comment|/* 		 * extended FAU debugging output 		 */
if|if
condition|(
name|err
operator|!=
name|EINTR
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select(%d, %s, 0L, 0L,&0.0) error: %m"
argument_list|,
name|maxactivefd
operator|+
literal|1
argument_list|,
name|fdbits
argument_list|(
name|maxactivefd
argument_list|,
operator|&
name|activefds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EBADF
condition|)
goto|goto
name|ih_return
goto|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|prior
operator|=
literal|0
init|;
name|j
operator|<=
name|maxactivefd
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|j
argument_list|,
operator|&
name|activefds
argument_list|)
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|!=
name|read
argument_list|(
name|j
argument_list|,
operator|&
name|b
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|prior
operator|=
name|j
expr_stmt|;
continue|continue;
block|}
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Removing bad file descriptor %d from select set"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|j
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|prior
expr_stmt|;
block|}
block|}
goto|goto
name|ih_return
goto|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|ih_return
goto|;
operator|++
name|handler_pkts
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 	 * Check out the reference clocks first, if any 	 */
if|if
condition|(
name|refio
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|rp
operator|=
name|refio
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
name|fd
operator|=
name|rp
operator|->
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
continue|continue;
operator|++
name|select_count
expr_stmt|;
name|buflen
operator|=
name|read_refclock_packet
argument_list|(
name|fd
argument_list|,
name|rp
argument_list|,
name|ts
argument_list|)
expr_stmt|;
comment|/* 			 * The first read must succeed after select() 			 * indicates readability, or we've reached 			 * a permanent EOF.  http://bugs.ntp.org/1732 			 * reported ntpd munching CPU after a USB GPS 			 * was unplugged because select was indicating 			 * EOF but ntpd didn't remove the descriptor 			 * from the activefds set. 			 */
if|if
condition|(
name|buflen
operator|<
literal|0
operator|&&
name|EAGAIN
operator|!=
name|errno
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|clk
operator|=
name|refnumtoa
argument_list|(
operator|&
name|rp
operator|->
name|srcclock
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s read: %m"
argument_list|,
name|clk
argument_list|)
expr_stmt|;
name|maintain_activefds
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|buflen
condition|)
block|{
name|clk
operator|=
name|refnumtoa
argument_list|(
operator|&
name|rp
operator|->
name|srcclock
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s read EOF"
argument_list|,
name|clk
argument_list|)
expr_stmt|;
name|maintain_activefds
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* drain any remaining refclock input */
do|do
block|{
name|buflen
operator|=
name|read_refclock_packet
argument_list|(
name|fd
argument_list|,
name|rp
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|buflen
operator|>
literal|0
condition|)
do|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/* 	 * Loop through the interfaces looking for data to read. 	 */
for|for
control|(
name|ep
operator|=
name|ep_list
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|elink
control|)
block|{
for|for
control|(
name|doing
operator|=
literal|0
init|;
name|doing
operator|<
literal|2
condition|;
name|doing
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|doing
condition|)
block|{
name|fd
operator|=
name|ep
operator|->
name|fd
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ep
operator|->
name|flags
operator|&
name|INT_BCASTOPEN
operator|)
condition|)
break|break;
name|fd
operator|=
name|ep
operator|->
name|bfd
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
do|do
block|{
operator|++
name|select_count
expr_stmt|;
name|buflen
operator|=
name|read_network_packet
argument_list|(
name|fd
argument_list|,
name|ep
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|buflen
operator|>
literal|0
condition|)
do|;
comment|/* Check more interfaces */
block|}
block|}
ifdef|#
directive|ifdef
name|HAS_ROUTING_SOCKET
comment|/* 	 * scan list of asyncio readers - currently only used for routing sockets 	 */
name|asyncio_reader
operator|=
name|asyncio_reader_list
expr_stmt|;
while|while
condition|(
name|asyncio_reader
operator|!=
name|NULL
condition|)
block|{
comment|/* callback may unlink and free asyncio_reader */
name|next_asyncio_reader
operator|=
name|asyncio_reader
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|asyncio_reader
operator|->
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
operator|++
name|select_count
expr_stmt|;
call|(
modifier|*
name|asyncio_reader
operator|->
name|receiver
call|)
argument_list|(
name|asyncio_reader
argument_list|)
expr_stmt|;
block|}
name|asyncio_reader
operator|=
name|next_asyncio_reader
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_ROUTING_SOCKET */
comment|/* 	 * Check for a response from a blocking child 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|blocking_children_alloc
condition|;
name|idx
operator|++
control|)
block|{
name|c
operator|=
name|blocking_children
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|c
operator|||
operator|-
literal|1
operator|==
name|c
operator|->
name|resp_read_pipe
condition|)
continue|continue;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|c
operator|->
name|resp_read_pipe
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|select_count
operator|++
expr_stmt|;
name|process_blocking_resp
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Done everything from that select. 	 * If nothing to do, just return. 	 * If an error occurred, complain and return. 	 */
if|if
condition|(
name|select_count
operator|==
literal|0
condition|)
block|{
comment|/* We really had nothing to do */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"input_handler: select() returned 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
goto|goto
name|ih_return
goto|;
block|}
comment|/* We've done our work */
ifdef|#
directive|ifdef
name|DEBUG_TIMING
name|get_systime
argument_list|(
operator|&
name|ts_e
argument_list|)
expr_stmt|;
comment|/* 	 * (ts_e - ts) is the amount of time we spent 	 * processing this gob of file descriptors.  Log 	 * it. 	 */
name|L_SUB
argument_list|(
operator|&
name|ts_e
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|collect_timing
argument_list|(
name|NULL
argument_list|,
literal|"input handler"
argument_list|,
literal|1
argument_list|,
operator|&
name|ts_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"input_handler: Processed a gob of fd's in %s msec"
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|ts_e
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_TIMING */
comment|/* We're done... */
name|ih_return
label|:
return|return;
block|}
endif|#
directive|endif
comment|/* !HAVE_IO_COMPLETION_PORT */
comment|/*  * find an interface suitable for the src address  */
name|endpt
modifier|*
name|select_peerinterface
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|sockaddr_u
modifier|*
name|srcadr
parameter_list|,
name|endpt
modifier|*
name|dstadr
parameter_list|)
block|{
name|endpt
modifier|*
name|ep
decl_stmt|;
ifndef|#
directive|ifndef
name|SIM
name|endpt
modifier|*
name|wild
decl_stmt|;
name|wild
operator|=
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the peer structure and dance the interface jig. 	 * Reference clocks step the loopback waltz, the others 	 * squaredance around the interface list looking for a buddy. If 	 * the dance peters out, there is always the wildcard interface. 	 * This might happen in some systems and would preclude proper 	 * operation with public key cryptography. 	 */
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
name|srcadr
argument_list|)
condition|)
block|{
name|ep
operator|=
name|loopback_interface
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|cast_flags
operator|&
operator|(
name|MDF_BCLNT
operator||
name|MDF_ACAST
operator||
name|MDF_MCAST
operator||
name|MDF_BCAST
operator|)
condition|)
block|{
name|ep
operator|=
name|findbcastinter
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Found *-cast interface %s for address %s\n"
operator|,
name|stoa
argument_list|(
operator|&
name|ep
operator|->
name|sin
argument_list|)
operator|,
name|stoa
argument_list|(
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"No *-cast local address found for address %s\n"
operator|,
name|stoa
argument_list|(
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|=
name|dstadr
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ep
condition|)
name|ep
operator|=
name|wild
expr_stmt|;
block|}
comment|/* 	 * If it is a multicast address, findbcastinter() may not find 	 * it.  For unicast, we get to find the interface when dstadr is 	 * given to us as the wildcard (ANY_INTERFACE_CHOOSE).  Either 	 * way, try a little harder. 	 */
if|if
condition|(
name|wild
operator|==
name|ep
condition|)
name|ep
operator|=
name|findinterface
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
comment|/* 	 * we do not bind to the wildcard interfaces for output 	 * as our (network) source address would be undefined and 	 * crypto will not work without knowing the own transmit address 	 */
if|if
condition|(
name|ep
operator|!=
name|NULL
operator|&&
name|INT_WILDCARD
operator|&
name|ep
operator|->
name|flags
condition|)
if|if
condition|(
operator|!
name|accept_wildcard_if_for_winnt
condition|)
name|ep
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
comment|/* SIM follows */
name|ep
operator|=
name|loopback_interface
expr_stmt|;
endif|#
directive|endif
return|return
name|ep
return|;
block|}
comment|/*  * findinterface - find local interface corresponding to address  */
name|endpt
modifier|*
name|findinterface
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
name|endpt
modifier|*
name|iface
decl_stmt|;
name|iface
operator|=
name|findlocalinterface
argument_list|(
name|addr
argument_list|,
name|INT_WILDCARD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|iface
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Found no interface for address %s - returning wildcard\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|iface
operator|=
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Found interface #%d %s for address %s\n"
operator|,
name|iface
operator|->
name|ifnum
operator|,
name|iface
operator|->
name|name
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|iface
return|;
block|}
comment|/*  * findlocalinterface - find local interface corresponding to addr,  * which does not have any of flags set.  If bast is nonzero, addr is  * a broadcast address.  *  * This code attempts to find the local sending address for an outgoing  * address by connecting a new socket to destinationaddress:NTP_PORT  * and reading the sockname of the resulting connect.  * the complicated sequence simulates the routing table lookup  * for to first hop without duplicating any of the routing logic into  * ntpd. preferably we would have used an API call - but its not there -  * so this is the best we can do here short of duplicating to entire routing  * logic in ntpd which would be a silly and really unportable thing to do.  *  */
specifier|static
name|endpt
modifier|*
name|findlocalinterface
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|bcast
parameter_list|)
block|{
name|GETSOCKNAME_SOCKLEN_TYPE
name|sockaddrlen
decl_stmt|;
name|endpt
modifier|*
name|iface
decl_stmt|;
name|sockaddr_u
name|saddr
decl_stmt|;
name|SOCKET
name|s
decl_stmt|;
name|int
name|rtn
decl_stmt|;
name|int
name|on
decl_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Finding interface for addr %s in list of addresses\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF
argument_list|(
name|addr
argument_list|)
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_SOCKET
operator|==
name|s
condition|)
return|return
name|NULL
return|;
comment|/* 	 * If we are looking for broadcast interface we need to set this 	 * socket to allow broadcast 	 */
if|if
condition|(
name|bcast
condition|)
block|{
name|on
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SOCKET_ERROR
operator|==
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|rtn
operator|=
name|connect
argument_list|(
name|s
argument_list|,
operator|&
name|addr
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKET_ERROR
operator|==
name|rtn
condition|)
block|{
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sockaddrlen
operator|=
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
expr_stmt|;
name|rtn
operator|=
name|getsockname
argument_list|(
name|s
argument_list|,
operator|&
name|saddr
operator|.
name|sa
argument_list|,
operator|&
name|sockaddrlen
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKET_ERROR
operator|==
name|rtn
condition|)
return|return
name|NULL
return|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"findlocalinterface: kernel maps %s to %s\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|,
name|stoa
argument_list|(
operator|&
name|saddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|iface
operator|=
name|getinterface
argument_list|(
operator|&
name|saddr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * if we didn't find an exact match on saddr, find the closest 	 * available local address.  This handles the case of the 	 * address suggested by the kernel being excluded by nic rules 	 * or the user's -I and -L options to ntpd. 	 * See http://bugs.ntp.org/1184 and http://bugs.ntp.org/1683 	 * for more background. 	 */
if|if
condition|(
name|NULL
operator|==
name|iface
operator|||
name|iface
operator|->
name|ignore_packets
condition|)
name|iface
operator|=
name|findclosestinterface
argument_list|(
operator|&
name|saddr
argument_list|,
name|flags
operator||
name|INT_LOOPBACK
argument_list|)
expr_stmt|;
comment|/* Don't use an interface which will ignore replies */
if|if
condition|(
name|iface
operator|!=
name|NULL
operator|&&
name|iface
operator|->
name|ignore_packets
condition|)
name|iface
operator|=
name|NULL
expr_stmt|;
return|return
name|iface
return|;
block|}
comment|/*  * findclosestinterface  *  * If there are -I/--interface or -L/novirtualips command-line options,  * or "nic" or "interface" rules in ntp.conf, findlocalinterface() may  * find the kernel's preferred local address for a given peer address is  * administratively unavailable to ntpd, and punt to this routine's more  * expensive search.  *  * Find the numerically closest local address to the one connect()  * suggested.  This matches an address on the same subnet first, as  * needed by Bug 1184, and provides a consistent choice if there are  * multiple feasible local addresses, regardless of the order ntpd  * enumerated them.  */
name|endpt
modifier|*
name|findclosestinterface
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|endpt
modifier|*
name|ep
decl_stmt|;
name|endpt
modifier|*
name|winner
decl_stmt|;
name|sockaddr_u
name|addr_dist
decl_stmt|;
name|sockaddr_u
name|min_dist
decl_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|min_dist
argument_list|)
expr_stmt|;
name|winner
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|ep_list
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|elink
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|ignore_packets
operator|||
name|AF
argument_list|(
name|addr
argument_list|)
operator|!=
name|ep
operator|->
name|family
operator|||
name|flags
operator|&
name|ep
operator|->
name|flags
condition|)
continue|continue;
name|calc_addr_distance
argument_list|(
operator|&
name|addr_dist
argument_list|,
name|addr
argument_list|,
operator|&
name|ep
operator|->
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|winner
operator|||
operator|-
literal|1
operator|==
name|cmp_addr_distance
argument_list|(
operator|&
name|addr_dist
argument_list|,
operator|&
name|min_dist
argument_list|)
condition|)
block|{
name|min_dist
operator|=
name|addr_dist
expr_stmt|;
name|winner
operator|=
name|ep
expr_stmt|;
block|}
block|}
if|if
condition|(
name|NULL
operator|==
name|winner
condition|)
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"findclosestinterface(%s) failed\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"findclosestinterface(%s) -> %s\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|,
name|stoa
argument_list|(
operator|&
name|winner
operator|->
name|sin
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|winner
return|;
block|}
comment|/*  * calc_addr_distance - calculate the distance between two addresses,  *			the absolute value of the difference between  *			the addresses numerically, stored as an address.  */
specifier|static
name|void
name|calc_addr_distance
parameter_list|(
name|sockaddr_u
modifier|*
name|dist
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
name|a1
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
name|a2
parameter_list|)
block|{
name|u_int32
name|a1val
decl_stmt|;
name|u_int32
name|a2val
decl_stmt|;
name|u_int32
name|v4dist
decl_stmt|;
name|int
name|found_greater
decl_stmt|;
name|int
name|a1_greater
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|AF
argument_list|(
name|a1
argument_list|)
operator|==
name|AF
argument_list|(
name|a2
argument_list|)
argument_list|)
expr_stmt|;
name|ZERO_SOCK
argument_list|(
name|dist
argument_list|)
expr_stmt|;
name|AF
argument_list|(
name|dist
argument_list|)
operator|=
name|AF
argument_list|(
name|a1
argument_list|)
expr_stmt|;
comment|/* v4 can be done a bit simpler */
if|if
condition|(
name|IS_IPV4
argument_list|(
name|a1
argument_list|)
condition|)
block|{
name|a1val
operator|=
name|SRCADR
argument_list|(
name|a1
argument_list|)
expr_stmt|;
name|a2val
operator|=
name|SRCADR
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|v4dist
operator|=
operator|(
name|a1val
operator|>
name|a2val
operator|)
condition|?
name|a1val
operator|-
name|a2val
else|:
name|a2val
operator|-
name|a1val
expr_stmt|;
name|SET_ADDR4
argument_list|(
name|dist
argument_list|,
name|v4dist
argument_list|)
expr_stmt|;
return|return;
block|}
name|found_greater
operator|=
name|FALSE
expr_stmt|;
name|a1_greater
operator|=
name|FALSE
expr_stmt|;
comment|/* suppress pot. uninit. warning */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|NSRCADR6
argument_list|(
name|a1
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|found_greater
operator|&&
name|NSRCADR6
argument_list|(
name|a1
argument_list|)
index|[
name|i
index|]
operator|!=
name|NSRCADR6
argument_list|(
name|a2
argument_list|)
index|[
name|i
index|]
condition|)
block|{
name|found_greater
operator|=
name|TRUE
expr_stmt|;
name|a1_greater
operator|=
operator|(
name|NSRCADR6
argument_list|(
name|a1
argument_list|)
index|[
name|i
index|]
operator|>
name|NSRCADR6
argument_list|(
name|a2
argument_list|)
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_greater
condition|)
block|{
name|NSRCADR6
argument_list|(
name|dist
argument_list|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|a1_greater
condition|)
name|NSRCADR6
argument_list|(
name|dist
argument_list|)
index|[
name|i
index|]
operator|=
name|NSRCADR6
argument_list|(
name|a1
argument_list|)
index|[
name|i
index|]
operator|-
name|NSRCADR6
argument_list|(
name|a2
argument_list|)
index|[
name|i
index|]
expr_stmt|;
else|else
name|NSRCADR6
argument_list|(
name|dist
argument_list|)
index|[
name|i
index|]
operator|=
name|NSRCADR6
argument_list|(
name|a2
argument_list|)
index|[
name|i
index|]
operator|-
name|NSRCADR6
argument_list|(
name|a1
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/*  * cmp_addr_distance - compare two address distances, returning -1, 0,  *		       1 to indicate their relationship.  */
specifier|static
name|int
name|cmp_addr_distance
parameter_list|(
specifier|const
name|sockaddr_u
modifier|*
name|d1
parameter_list|,
specifier|const
name|sockaddr_u
modifier|*
name|d2
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|AF
argument_list|(
name|d1
argument_list|)
operator|==
name|AF
argument_list|(
name|d2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IPV4
argument_list|(
name|d1
argument_list|)
condition|)
block|{
if|if
condition|(
name|SRCADR
argument_list|(
name|d1
argument_list|)
operator|<
name|SRCADR
argument_list|(
name|d2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|SRCADR
argument_list|(
name|d1
argument_list|)
operator|==
name|SRCADR
argument_list|(
name|d2
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|NSRCADR6
argument_list|(
name|d1
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NSRCADR6
argument_list|(
name|d1
argument_list|)
index|[
name|i
index|]
operator|<
name|NSRCADR6
argument_list|(
name|d2
argument_list|)
index|[
name|i
index|]
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|NSRCADR6
argument_list|(
name|d1
argument_list|)
index|[
name|i
index|]
operator|>
name|NSRCADR6
argument_list|(
name|d2
argument_list|)
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  * fetch an interface structure the matches the  * address and has the given flags NOT set  */
name|endpt
modifier|*
name|getinterface
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|u_int32
name|flags
parameter_list|)
block|{
name|endpt
modifier|*
name|iface
decl_stmt|;
name|iface
operator|=
name|find_addr_in_list
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|!=
name|NULL
operator|&&
operator|(
name|iface
operator|->
name|flags
operator|&
name|flags
operator|)
condition|)
name|iface
operator|=
name|NULL
expr_stmt|;
return|return
name|iface
return|;
block|}
comment|/*  * findbcastinter - find broadcast interface corresponding to address  */
name|endpt
modifier|*
name|findbcastinter
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
name|endpt
modifier|*
name|iface
decl_stmt|;
name|iface
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MPE
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SIOCGIFCONF
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|)
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Finding broadcast/multicast interface for addr %s in list of addresses\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|iface
operator|=
name|findlocalinterface
argument_list|(
name|addr
argument_list|,
name|INT_LOOPBACK
operator||
name|INT_WILDCARD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Easily found bcast-/mcast- interface index #%d %s\n"
operator|,
name|iface
operator|->
name|ifnum
operator|,
name|iface
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|iface
return|;
block|}
comment|/* 	 * plan B - try to find something reasonable in our lists in 	 * case kernel lookup doesn't help 	 */
for|for
control|(
name|iface
operator|=
name|ep_list
init|;
name|iface
operator|!=
name|NULL
condition|;
name|iface
operator|=
name|iface
operator|->
name|elink
control|)
block|{
if|if
condition|(
name|iface
operator|->
name|flags
operator|&
name|INT_WILDCARD
condition|)
continue|continue;
comment|/* Don't bother with ignored interfaces */
if|if
condition|(
name|iface
operator|->
name|ignore_packets
condition|)
continue|continue;
comment|/* 		 * First look if this is the correct family 		 */
if|if
condition|(
name|AF
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|!=
name|AF
argument_list|(
name|addr
argument_list|)
condition|)
continue|continue;
comment|/* Skip the loopback addresses */
if|if
condition|(
name|iface
operator|->
name|flags
operator|&
name|INT_LOOPBACK
condition|)
continue|continue;
comment|/* 		 * If we are looking to match a multicast address and 		 * this interface is one... 		 */
if|if
condition|(
name|addr_ismulticast
argument_list|(
name|addr
argument_list|)
operator|&&
operator|(
name|iface
operator|->
name|flags
operator|&
name|INT_MULTICAST
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
comment|/* 			 * ...it is the winner unless we're looking for 			 * an interface to use for link-local multicast 			 * and its address is not link-local. 			 */
if|if
condition|(
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
operator|&&
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
name|PSOCK_ADDR6
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|PSOCK_ADDR6
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
break|break;
block|}
comment|/* 		 * We match only those interfaces marked as 		 * broadcastable and either the explicit broadcast 		 * address or the network portion of the IP address. 		 * Sloppy. 		 */
if|if
condition|(
name|IS_IPV4
argument_list|(
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SOCK_EQ
argument_list|(
operator|&
name|iface
operator|->
name|bcast
argument_list|,
name|addr
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|NSRCADR
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
operator|&
name|NSRCADR
argument_list|(
operator|&
name|iface
operator|->
name|mask
argument_list|)
operator|)
operator|==
operator|(
name|NSRCADR
argument_list|(
name|addr
argument_list|)
operator|&
name|NSRCADR
argument_list|(
operator|&
name|iface
operator|->
name|mask
argument_list|)
operator|)
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_SUPPORT
elseif|else
if|if
condition|(
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SOCK_EQ
argument_list|(
operator|&
name|iface
operator|->
name|bcast
argument_list|,
name|addr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|SOCK_EQ
argument_list|(
name|netof
argument_list|(
operator|&
name|iface
operator|->
name|sin
argument_list|)
argument_list|,
name|netof
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
break|break;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* SIOCGIFCONF */
if|if
condition|(
name|NULL
operator|==
name|iface
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"No bcast interface found for %s\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|iface
operator|=
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Found bcast-/mcast- interface index #%d %s\n"
operator|,
name|iface
operator|->
name|ifnum
operator|,
name|iface
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|iface
return|;
block|}
comment|/*  * io_clr_stats - clear I/O module statistics  */
name|void
name|io_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|packets_dropped
operator|=
literal|0
expr_stmt|;
name|packets_ignored
operator|=
literal|0
expr_stmt|;
name|packets_received
operator|=
literal|0
expr_stmt|;
name|packets_sent
operator|=
literal|0
expr_stmt|;
name|packets_notsent
operator|=
literal|0
expr_stmt|;
name|handler_calls
operator|=
literal|0
expr_stmt|;
name|handler_pkts
operator|=
literal|0
expr_stmt|;
name|io_timereset
operator|=
name|current_time
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/*  * io_addclock - add a reference clock to the list and arrange that we  *				 get SIGIO interrupts from it.  */
name|int
name|io_addclock
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * Stuff the I/O structure in the list and mark the descriptor 	 * in use.  There is a harmless (I hope) race condition here. 	 */
name|rio
operator|->
name|active
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
if|if
condition|(
name|init_clock_sig
argument_list|(
name|rio
argument_list|)
condition|)
block|{
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
if|if
condition|(
name|io_completion_port_add_clock_io
argument_list|(
name|rio
argument_list|)
condition|)
block|{
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* 	 * enqueue 	 */
name|LINK_SLIST
argument_list|(
name|refio
argument_list|,
name|rio
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* 	 * register fd 	 */
name|add_fd_to_list
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FD_TYPE_FILE
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  * io_closeclock - close the clock in the I/O structure given  */
name|void
name|io_closeclock
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
name|struct
name|refclockio
modifier|*
name|unlinked
decl_stmt|;
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * Remove structure from the list 	 */
name|rio
operator|->
name|active
operator|=
name|FALSE
expr_stmt|;
name|UNLINK_SLIST
argument_list|(
name|unlinked
argument_list|,
name|refio
argument_list|,
name|rio
argument_list|,
name|next
argument_list|,
expr|struct
name|refclockio
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|unlinked
condition|)
block|{
name|purge_recv_buffers_for_fd
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* 		 * Close the descriptor. 		 */
name|close_and_delete_fd_from_list
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
name|rio
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/*  * On NT a SOCKET is an unsigned int so we cannot possibly keep it in  * an array. So we use one of the ISC_LIST functions to hold the  * socket value and use that when we want to enumerate it.  *  * This routine is called by the forked intres child process to close  * all open sockets.  On Windows there's no need as intres runs in  * the same process as a thread.  */
ifndef|#
directive|ifndef
name|SYS_WINNT
name|void
name|kill_asyncio
parameter_list|(
name|int
name|startfd
parameter_list|)
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * In the child process we do not maintain activefds and 	 * maxactivefd.  Zeroing maxactivefd disables code which 	 * maintains it in close_and_delete_fd_from_list(). 	 */
name|maxactivefd
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fd_list
operator|!=
name|NULL
condition|)
name|close_and_delete_fd_from_list
argument_list|(
name|fd_list
operator|->
name|fd
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !SYS_WINNT */
comment|/*  * Add and delete functions for the list of open sockets  */
specifier|static
name|void
name|add_fd_to_list
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|enum
name|desc_type
name|type
parameter_list|)
block|{
name|vsock_t
modifier|*
name|lsock
init|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lsock
argument_list|)
argument_list|)
decl_stmt|;
name|lsock
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|lsock
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|fd_list
argument_list|,
name|lsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|maintain_activefds
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|close_and_delete_fd_from_list
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|vsock_t
modifier|*
name|lsock
decl_stmt|;
name|UNLINK_EXPR_SLIST
argument_list|(
name|lsock
argument_list|,
name|fd_list
argument_list|,
name|fd
operator|==
name|UNLINK_EXPR_SLIST_CURRENT
argument_list|()
operator|->
name|fd
argument_list|,
name|link
argument_list|,
name|vsock_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|lsock
condition|)
return|return;
switch|switch
condition|(
name|lsock
operator|->
name|type
condition|)
block|{
case|case
name|FD_TYPE_SOCKET
case|:
name|closesocket
argument_list|(
name|lsock
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
name|FD_TYPE_FILE
case|:
name|closeserial
argument_list|(
name|lsock
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error - illegal descriptor type %d - EXITING"
argument_list|,
operator|(
name|int
operator|)
name|lsock
operator|->
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lsock
argument_list|)
expr_stmt|;
comment|/* 	 * remove from activefds 	 */
name|maintain_activefds
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|add_addr_to_list
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|laddr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|find_addr_in_list
argument_list|(
name|addr
argument_list|)
operator|==
name|NULL
condition|)
block|{
endif|#
directive|endif
comment|/* not there yet - add to list */
name|laddr
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|laddr
argument_list|)
argument_list|)
expr_stmt|;
name|laddr
operator|->
name|addr
operator|=
operator|*
name|addr
expr_stmt|;
name|laddr
operator|->
name|ep
operator|=
name|ep
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|remoteaddr_list
argument_list|,
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Added addr %s to list of addresses\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|}
else|else
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"WARNING: Attempt to add duplicate addr %s to address list\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|delete_addr_from_list
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|unlinked
decl_stmt|;
name|UNLINK_EXPR_SLIST
argument_list|(
name|unlinked
argument_list|,
name|remoteaddr_list
argument_list|,
name|SOCK_EQ
argument_list|(
name|addr
argument_list|,
operator|&
operator|(
name|UNLINK_EXPR_SLIST_CURRENT
argument_list|()
operator|->
name|addr
operator|)
argument_list|)
argument_list|,
name|link
argument_list|,
name|remaddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlinked
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Deleted addr %s from list of addresses\n"
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unlinked
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|delete_interface_from_list
parameter_list|(
name|endpt
modifier|*
name|iface
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|unlinked
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_EXPR_SLIST
argument_list|(
name|unlinked
argument_list|,
name|remoteaddr_list
argument_list|,
name|iface
operator|==
name|UNLINK_EXPR_SLIST_CURRENT
argument_list|()
operator|->
name|ep
argument_list|,
name|link
argument_list|,
name|remaddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlinked
operator|==
name|NULL
condition|)
break|break;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Deleted addr %s for interface #%d %s from list of addresses\n"
operator|,
name|stoa
argument_list|(
operator|&
name|unlinked
operator|->
name|addr
argument_list|)
operator|,
name|iface
operator|->
name|ifnum
operator|,
name|iface
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unlinked
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|struct
name|interface
modifier|*
name|find_addr_in_list
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|entry
decl_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Searching for addr %s in list of addresses - "
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|remoteaddr_list
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|link
control|)
if|if
condition|(
name|SOCK_EQ
argument_list|(
operator|&
name|entry
operator|->
name|addr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"FOUND\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|entry
operator|->
name|ep
return|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"NOT FOUND\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  * Find the given address with the all given flags set in the list  */
specifier|static
name|endpt
modifier|*
name|find_flagged_addr_in_list
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|u_int32
name|flags
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|entry
decl_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Finding addr %s with flags %d in list: "
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|remoteaddr_list
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|link
control|)
if|if
condition|(
name|SOCK_EQ
argument_list|(
operator|&
name|entry
operator|->
name|addr
argument_list|,
name|addr
argument_list|)
operator|&&
operator|(
name|entry
operator|->
name|ep
operator|->
name|flags
operator|&
name|flags
operator|)
operator|==
name|flags
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"FOUND\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|entry
operator|->
name|ep
return|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"NOT FOUND\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
specifier|const
name|char
modifier|*
name|localaddrtoa
parameter_list|(
name|endpt
modifier|*
name|la
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|==
name|la
operator|)
condition|?
literal|"<null>"
else|:
name|stoa
argument_list|(
operator|&
name|la
operator|->
name|sin
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAS_ROUTING_SOCKET
ifndef|#
directive|ifndef
name|UPDATE_GRACE
define|#
directive|define
name|UPDATE_GRACE
value|2
comment|/* wait UPDATE_GRACE seconds before scanning */
endif|#
directive|endif
specifier|static
name|void
name|process_routing_msgs
parameter_list|(
name|struct
name|asyncio_reader
modifier|*
name|reader
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|5120
index|]
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|msg_type
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RTNETLINK
name|struct
name|nlmsghdr
modifier|*
name|nh
decl_stmt|;
else|#
directive|else
name|struct
name|rt_msghdr
name|rtm
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|disable_dynamic_updates
condition|)
block|{
comment|/* 		 * discard ourselves if we are not needed any more 		 * usually happens when running unprivileged 		 */
name|remove_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|delete_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
return|return;
block|}
name|cnt
operator|=
name|read
argument_list|(
name|reader
operator|->
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"i/o error on routing socket %m - disabling"
argument_list|)
expr_stmt|;
name|remove_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|delete_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * process routing message 	 */
ifdef|#
directive|ifdef
name|HAVE_RTNETLINK
for|for
control|(
name|nh
operator|=
operator|(
expr|struct
name|nlmsghdr
operator|*
operator|)
name|buffer
init|;
name|NLMSG_OK
argument_list|(
name|nh
argument_list|,
name|cnt
argument_list|)
condition|;
name|nh
operator|=
name|NLMSG_NEXT
argument_list|(
name|nh
argument_list|,
name|cnt
argument_list|)
control|)
block|{
name|msg_type
operator|=
name|nh
operator|->
name|nlmsg_type
expr_stmt|;
else|#
directive|else
for|for
control|(
name|p
operator|=
name|buffer
init|;
operator|(
name|p
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rt_msghdr
argument_list|)
operator|)
operator|<=
operator|(
name|buffer
operator|+
name|cnt
operator|)
condition|;
name|p
operator|+=
name|rtm
operator|.
name|rtm_msglen
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|rtm
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|rtm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtm
operator|.
name|rtm_version
operator|!=
name|RTM_VERSION
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"version mismatch (got %d - expected %d) on routing socket - disabling"
argument_list|,
name|rtm
operator|.
name|rtm_version
argument_list|,
name|RTM_VERSION
argument_list|)
expr_stmt|;
name|remove_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|delete_asyncio_reader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
return|return;
block|}
name|msg_type
operator|=
name|rtm
operator|.
name|rtm_type
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|msg_type
condition|)
block|{
ifdef|#
directive|ifdef
name|RTM_NEWADDR
case|case
name|RTM_NEWADDR
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_DELADDR
case|case
name|RTM_DELADDR
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_ADD
case|case
name|RTM_ADD
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_DELETE
case|case
name|RTM_DELETE
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_REDIRECT
case|case
name|RTM_REDIRECT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_CHANGE
case|case
name|RTM_CHANGE
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_LOSING
case|case
name|RTM_LOSING
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_IFINFO
case|case
name|RTM_IFINFO
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_IFANNOUNCE
case|case
name|RTM_IFANNOUNCE
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_NEWLINK
case|case
name|RTM_NEWLINK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_DELLINK
case|case
name|RTM_DELLINK
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_NEWROUTE
case|case
name|RTM_NEWROUTE
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_DELROUTE
case|case
name|RTM_DELROUTE
case|:
endif|#
directive|endif
comment|/* 			 * we are keen on new and deleted addresses and 			 * if an interface goes up and down or routing 			 * changes 			 */
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"routing message op = %d: scheduling interface update\n"
operator|,
name|msg_type
operator|)
argument_list|)
expr_stmt|;
name|timer_interfacetimeout
argument_list|(
name|current_time
operator|+
name|UPDATE_GRACE
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_RTNETLINK
case|case
name|NLMSG_DONE
case|:
comment|/* end of multipart message */
return|return;
endif|#
directive|endif
default|default:
comment|/* 			 * the rest doesn't bother us. 			 */
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"routing message op = %d: ignored\n"
operator|,
name|msg_type
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*  * set up routing notifications  */
specifier|static
name|void
name|init_async_notifications
parameter_list|()
block|{
name|struct
name|asyncio_reader
modifier|*
name|reader
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RTNETLINK
name|int
name|fd
init|=
name|socket
argument_list|(
name|PF_NETLINK
argument_list|,
name|SOCK_RAW
argument_list|,
name|NETLINK_ROUTE
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_nl
name|sa
decl_stmt|;
else|#
directive|else
name|int
name|fd
init|=
name|socket
argument_list|(
name|PF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to open routing socket (%m) - using polled interface update"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fd
operator|=
name|move_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RTNETLINK
name|ZERO
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|nl_family
operator|=
name|PF_NETLINK
expr_stmt|;
name|sa
operator|.
name|nl_groups
operator|=
name|RTMGRP_LINK
operator||
name|RTMGRP_IPV4_IFADDR
operator||
name|RTMGRP_IPV6_IFADDR
operator||
name|RTMGRP_IPV4_ROUTE
operator||
name|RTMGRP_IPV4_MROUTE
operator||
name|RTMGRP_IPV6_ROUTE
operator||
name|RTMGRP_IPV6_MROUTE
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind failed on routing socket (%m) - using polled interface update"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|make_socket_nonblocking
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
name|init_socket_sig
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGNALED_IO */
name|reader
operator|=
name|new_asyncio_reader
argument_list|()
expr_stmt|;
name|reader
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|reader
operator|->
name|receiver
operator|=
name|process_routing_msgs
expr_stmt|;
name|add_asyncio_reader
argument_list|(
name|reader
argument_list|,
name|FD_TYPE_SOCKET
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listening on routing socket on fd #%d for interface updates"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* HAS_ROUTING_SOCKET not defined */
specifier|static
name|void
name|init_async_notifications
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

