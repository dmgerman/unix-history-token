begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_io.c - input/output routines for ntpd.	The socket-opening code  *		   was shamelessly stolen from ntpd.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_comment
comment|/* Don't include ISC's version of IPv6 variables and structures */
end_comment

begin_define
define|#
directive|define
name|ISC_IPV6_H
value|1
end_define

begin_include
include|#
directive|include
file|<isc/interfaceiter.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_include
include|#
directive|include
file|"ntpsim.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PARAM_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_SYSTM_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Some old linux systems at least have in_system.h instead. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_SYSTEM_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in_system.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINET_IN_SYSTM_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IP_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKIO_H
end_ifdef

begin_comment
comment|/* UXPV: SIOC* #defines (Frank Vance<fvance@waii.com>) */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|listen_to_virtual_ips
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<transmitbuff.h>
end_include

begin_include
include|#
directive|include
file|<isc/win32os.h>
end_include

begin_comment
comment|/*  * Define this macro to control the behavior of connection  * resets on UDP sockets.  See Microsoft KnowledgeBase Article Q263823  * for details.  * NOTE: This requires that Windows 2000 systems install Service Pack 2  * or later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIO_UDP_CONNRESET
end_ifndef

begin_define
define|#
directive|define
name|SIO_UDP_CONNRESET
value|_WSAIOW(IOC_VENDOR,12)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We do asynchronous input using the SIGIO facility.  A number of  * recvbuf buffers are preallocated for input.	In the signal  * handler we poll to see which sockets are ready and read the  * packets from them into the recvbuf's along with a time stamp and  * an indication of the source host and the interface it was received  * through.  This allows us to get as accurate receive time stamps  * as possible independent of other processing going on.  *  * We watch the number of recvbufs available to the signal handler  * and allocate more when this number drops below the low water  * mark.  If the signal handler should run out of buffers in the  * interim it will drop incoming frames, the idea being that it is  * better to drop a packet than to be inaccurate.  */
end_comment

begin_comment
comment|/*  * Other statistics of possible interest  */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_dropped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets dropped on reception */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_ignored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets received on wild card interface */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|packets_received
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets received */
end_comment

begin_decl_stmt
name|u_long
name|packets_sent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets sent */
end_comment

begin_decl_stmt
name|u_long
name|packets_notsent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets which couldn't be sent */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|handler_calls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of calls to interrupt handler */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|handler_pkts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pkts received by handler */
end_comment

begin_decl_stmt
name|u_long
name|io_timereset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time counters were reset */
end_comment

begin_comment
comment|/*  * Interface stuff  */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default ipv4 interface */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|any6_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default ipv6 interface */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|loopback_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* loopback ipv4 interface */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|loopback6_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* loopback ipv6 interface */
end_comment

begin_decl_stmt
name|struct
name|interface
name|inter_list
index|[
name|MAXINTERFACES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interface list */
end_comment

begin_decl_stmt
name|int
name|ninterfaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of interfaces */
end_comment

begin_decl_stmt
name|int
name|nwilds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of wildcard intefaces */
end_comment

begin_decl_stmt
name|int
name|wildipv4
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into inter_list for IPv4 wildcard */
end_comment

begin_decl_stmt
name|int
name|wildipv6
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into inter_list for IPv6 wildcard */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * Refclock stuff.	We keep a chain of structures with data concerning  * the guys we are doing I/O for.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|refclockio
modifier|*
name|refio
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_comment
comment|/*  * Define what the possible "soft" errors can be.  These are non-fatal returns  * of various network related functions, like recv() and so on.  *  * For some reason, BSDI (and perhaps others) will sometimes return<0  * from recv() but will have errno==0.  This is broken, but we have to  * work around it here.  */
end_comment

begin_define
define|#
directive|define
name|SOFT_ERROR
parameter_list|(
name|e
parameter_list|)
value|((e) == EAGAIN || \ 			 (e) == EWOULDBLOCK || \ 			 (e) == EINTR || \ 			 (e) == 0)
end_define

begin_comment
comment|/*  * File descriptor masks etc. for call to select  * Not needed for I/O Completion Ports  */
end_comment

begin_decl_stmt
name|fd_set
name|activefds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxactivefd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|create_sockets
name|P
argument_list|(
operator|(
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SOCKET
name|open_socket
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_socket
name|P
argument_list|(
operator|(
name|SOCKET
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|close_file
name|P
argument_list|(
operator|(
name|SOCKET
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fdbits
name|P
argument_list|(
operator|(
name|int
operator|,
name|fd_set
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_reuseaddr
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|vsock
name|vsock_t
typedef|;
end_typedef

begin_struct
struct|struct
name|vsock
block|{
name|SOCKET
name|fd
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|vsock_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ISC_LIST
argument_list|(
argument|vsock_t
argument_list|)
end_macro

begin_expr_stmt
name|sockets_list
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|remaddr
name|remaddr_t
typedef|;
end_typedef

begin_struct
struct|struct
name|remaddr
block|{
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|int
name|if_index
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|remaddr_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ISC_LIST
argument_list|(
argument|remaddr_t
argument_list|)
end_macro

begin_expr_stmt
name|remoteaddr_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|add_socket_to_list
name|P
argument_list|(
operator|(
name|SOCKET
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|delete_socket_from_list
name|P
argument_list|(
operator|(
name|SOCKET
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|add_addr_to_list
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|delete_addr_from_list
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|find_addr_in_list
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|create_wildcards
name|P
argument_list|(
operator|(
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|address_okay
name|P
argument_list|(
operator|(
name|isc_interface_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|convert_isc_if
name|P
argument_list|(
operator|(
name|isc_interface_t
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_comment
comment|/*  * Windows 2000 systems incorrectly cause UDP sockets using WASRecvFrom  * to not work correctly, returning a WSACONNRESET error when a WSASendTo  * fails with an "ICMP port unreachable" response and preventing the  * socket from using the WSARecvFrom in subsequent operations.  * The function below fixes this, but requires that Windows 2000  * Service Pack 2 or later be installed on the system.  NT 4.0  * systems are not affected by this and work correctly.  * See Microsoft Knowledge Base Article Q263823 for details of this.  */
end_comment

begin_function
name|isc_result_t
name|connection_reset_fix
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|DWORD
name|dwBytesReturned
init|=
literal|0
decl_stmt|;
name|BOOL
name|bNewBehavior
init|=
name|FALSE
decl_stmt|;
name|DWORD
name|status
decl_stmt|;
if|if
condition|(
name|isc_win32os_majorversion
argument_list|()
operator|<
literal|5
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/*  NT 4.0 has no problem */
comment|/* disable bad behavior using IOCTL: SIO_UDP_CONNRESET */
name|status
operator|=
name|WSAIoctl
argument_list|(
name|fd
argument_list|,
name|SIO_UDP_CONNRESET
argument_list|,
operator|&
name|bNewBehavior
argument_list|,
sizeof|sizeof
argument_list|(
name|bNewBehavior
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|dwBytesReturned
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SOCKET_ERROR
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
else|else
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * init_io - initialize I/O data structures and call socket creation routine  */
end_comment

begin_function
name|void
name|init_io
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_WINNT
name|init_transmitbuff
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Init buffer free list and stat counters 	 */
name|init_recvbuff
argument_list|(
name|RECV_INIT
argument_list|)
expr_stmt|;
name|packets_dropped
operator|=
name|packets_received
operator|=
literal|0
expr_stmt|;
name|packets_ignored
operator|=
literal|0
expr_stmt|;
name|packets_sent
operator|=
name|packets_notsent
operator|=
literal|0
expr_stmt|;
name|handler_calls
operator|=
name|handler_pkts
operator|=
literal|0
expr_stmt|;
name|io_timereset
operator|=
literal|0
expr_stmt|;
name|loopback_interface
operator|=
name|NULL
expr_stmt|;
name|loopback6_interface
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
name|refio
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
operator|(
name|void
operator|)
name|set_signal
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_WINNT
if|if
condition|(
operator|!
name|Win32InitSockets
argument_list|()
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No useable winsock.dll: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
name|ISC_LIST_INIT
argument_list|(
name|sockets_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|remoteaddr_list
argument_list|)
expr_stmt|;
comment|/* 	 * Create the sockets 	 */
name|BLOCKIO
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|create_sockets
argument_list|(
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"init_io: maxactivefd %d\n"
argument_list|,
name|maxactivefd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|create_wildcards
parameter_list|(
name|u_short
name|port
parameter_list|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
comment|/* 	 * create pseudo-interface with wildcard IPv4 address 	 */
name|inter_list
index|[
name|idx
index|]
operator|.
name|sin
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|inter_list
index|[
name|idx
index|]
operator|.
name|sin
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|inter_list
index|[
name|idx
index|]
operator|.
name|sin
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|inter_list
index|[
name|idx
index|]
operator|.
name|name
argument_list|,
literal|"wildcard"
argument_list|,
sizeof|sizeof
argument_list|(
name|inter_list
index|[
name|idx
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|mask
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|inter_list
index|[
name|idx
index|]
operator|.
name|mask
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|~
operator|(
name|u_int32
operator|)
literal|0
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|num_mcast
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|received
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|sent
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|notsent
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|flags
operator|=
name|INT_BROADCAST
expr_stmt|;
name|any_interface
operator|=
operator|&
name|inter_list
index|[
name|idx
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MCAST
argument_list|)
comment|/* 	 * enable possible multicast reception on the broadcast socket 	 */
name|inter_list
index|[
name|idx
index|]
operator|.
name|bcast
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|inter_list
index|[
name|idx
index|]
operator|.
name|bcast
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|inter_list
index|[
name|idx
index|]
operator|.
name|bcast
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
name|wildipv4
operator|=
name|idx
expr_stmt|;
name|idx
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IPV6
comment|/* 	 * create pseudo-interface with wildcard IPv6 address 	 */
if|if
condition|(
name|isc_net_probeipv6
argument_list|()
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|inter_list
index|[
name|idx
index|]
operator|.
name|sin
operator|.
name|ss_family
operator|=
name|AF_INET6
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|inter_list
index|[
name|idx
index|]
operator|.
name|sin
operator|)
operator|->
name|sin6_addr
operator|=
name|in6addr_any
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|inter_list
index|[
name|idx
index|]
operator|.
name|sin
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|inter_list
index|[
name|idx
index|]
operator|.
name|name
argument_list|,
literal|"wildcard"
argument_list|,
sizeof|sizeof
argument_list|(
name|inter_list
index|[
name|idx
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|mask
operator|.
name|ss_family
operator|=
name|AF_INET6
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|inter_list
index|[
name|idx
index|]
operator|.
name|mask
operator|)
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|num_mcast
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|received
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|sent
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|notsent
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|any6_interface
operator|=
operator|&
name|inter_list
index|[
name|idx
index|]
expr_stmt|;
name|wildipv6
operator|=
name|idx
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|address_okay
parameter_list|(
name|isc_interface_t
modifier|*
name|isc_if
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"address_okay: listen Virtual: %d, IF name: %s, Up Flag: %d\n"
argument_list|,
name|listen_to_virtual_ips
argument_list|,
name|isc_if
operator|->
name|name
argument_list|,
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_UP
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|listen_to_virtual_ips
operator|==
literal|0
operator|&&
operator|(
name|strchr
argument_list|(
name|isc_if
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
literal|':'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* XXXPDM This should be fixed later, but since we may not have set 	 * the UP flag, we at least get to use the interface. 	 * The UP flag is not always set so we don't do this right now. 	 */
comment|/*	if ((isc_if->flags& INTERFACE_F_UP) == 0) 		return (ISC_FALSE); */
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|convert_isc_if
parameter_list|(
name|isc_interface_t
modifier|*
name|isc_if
parameter_list|,
name|struct
name|interface
modifier|*
name|itf
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
if|if
condition|(
name|isc_if
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|itf
operator|->
name|sin
operator|.
name|ss_family
operator|=
operator|(
name|u_short
operator|)
name|isc_if
operator|->
name|af
expr_stmt|;
name|strcpy
argument_list|(
name|itf
operator|->
name|name
argument_list|,
name|isc_if
operator|->
name|name
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|address
operator|.
name|type
operator|.
name|in
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_BROADCAST
operator|)
operator|!=
literal|0
condition|)
block|{
name|itf
operator|->
name|flags
operator||=
name|INT_BROADCAST
expr_stmt|;
name|itf
operator|->
name|bcast
operator|.
name|ss_family
operator|=
name|itf
operator|->
name|sin
operator|.
name|ss_family
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|bcast
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|broadcast
operator|.
name|type
operator|.
name|in
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|bcast
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
name|itf
operator|->
name|mask
operator|.
name|ss_family
operator|=
name|itf
operator|->
name|sin
operator|.
name|ss_family
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|mask
operator|)
operator|->
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|netmask
operator|.
name|type
operator|.
name|in
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|itf
operator|->
name|mask
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_LOOPBACK
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|loopback_interface
operator|==
name|NULL
operator|)
condition|)
block|{
name|loopback_interface
operator|=
name|itf
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_IPV6
elseif|else
if|if
condition|(
name|isc_if
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|itf
operator|->
name|sin
operator|.
name|ss_family
operator|=
operator|(
name|u_short
operator|)
name|isc_if
operator|->
name|af
expr_stmt|;
name|strcpy
argument_list|(
name|itf
operator|->
name|name
argument_list|,
name|isc_if
operator|->
name|name
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|address
operator|.
name|type
operator|.
name|in6
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|sin
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
name|itf
operator|->
name|mask
operator|.
name|ss_family
operator|=
name|itf
operator|->
name|sin
operator|.
name|ss_family
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|mask
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
operator|&
operator|(
name|isc_if
operator|->
name|netmask
operator|.
name|type
operator|.
name|in6
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|itf
operator|->
name|mask
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_LOOPBACK
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|loopback6_interface
operator|==
name|NULL
operator|)
condition|)
block|{
name|loopback6_interface
operator|=
name|itf
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_IPV6 */
comment|/* Process the rest of the flags */
if|if
condition|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_UP
operator|)
operator|!=
literal|0
condition|)
name|itf
operator|->
name|flags
operator||=
name|INT_UP
expr_stmt|;
if|if
condition|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
name|itf
operator|->
name|flags
operator||=
name|INT_LOOPBACK
expr_stmt|;
if|if
condition|(
operator|(
name|isc_if
operator|->
name|flags
operator|&
name|INTERFACE_F_POINTTOPOINT
operator|)
operator|!=
literal|0
condition|)
name|itf
operator|->
name|flags
operator||=
name|INT_PPP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * create_sockets - create a socket for each interface plus a default  *			socket for when we don't know where to send  */
end_comment

begin_function
specifier|static
name|int
name|create_sockets
parameter_list|(
name|u_short
name|port
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|resmask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|NULL
decl_stmt|;
name|isc_interfaceiter_t
modifier|*
name|iter
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|scan_ipv4
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|scan_ipv6
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"create_sockets(%d)\n"
argument_list|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isc_net_probeipv6
argument_list|()
operator|==
name|ISC_R_SUCCESS
condition|)
name|scan_ipv6
operator|=
name|ISC_TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IPV6
else|else
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no IPv6 interfaces found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isc_net_probeipv4
argument_list|()
operator|==
name|ISC_R_SUCCESS
condition|)
name|scan_ipv4
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no IPv4 interfaces found"
argument_list|)
expr_stmt|;
name|nwilds
operator|=
name|create_wildcards
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|idx
operator|=
name|nwilds
expr_stmt|;
name|result
operator|=
name|isc_interfaceiter_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|result
operator|=
name|isc_interfaceiter_first
argument_list|(
name|iter
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|isc_interfaceiter_next
argument_list|(
name|iter
argument_list|)
control|)
block|{
name|isc_interface_t
name|isc_if
decl_stmt|;
name|unsigned
name|int
name|family
decl_stmt|;
name|result
operator|=
name|isc_interfaceiter_current
argument_list|(
name|iter
argument_list|,
operator|&
name|isc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
comment|/* See if we have a valid family to use */
name|family
operator|=
name|isc_if
operator|.
name|address
operator|.
name|family
expr_stmt|;
if|if
condition|(
name|family
operator|!=
name|AF_INET
operator|&&
name|family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
name|scan_ipv4
operator|==
name|ISC_FALSE
operator|&&
name|family
operator|==
name|AF_INET
condition|)
continue|continue;
if|if
condition|(
name|scan_ipv6
operator|==
name|ISC_FALSE
operator|&&
name|family
operator|==
name|AF_INET6
condition|)
continue|continue;
comment|/* Check to see if we are going to use the interface */
if|if
condition|(
name|address_okay
argument_list|(
operator|&
name|isc_if
argument_list|)
operator|==
name|ISC_TRUE
condition|)
block|{
name|convert_isc_if
argument_list|(
operator|&
name|isc_if
argument_list|,
operator|&
name|inter_list
index|[
name|idx
index|]
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|num_mcast
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|received
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|sent
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
name|idx
index|]
operator|.
name|notsent
operator|=
literal|0
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
name|isc_interfaceiter_destroy
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
name|ninterfaces
operator|=
name|idx
expr_stmt|;
comment|/* 	 * I/O Completion Ports don't care about the select and FD_SET 	 */
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
name|maxactivefd
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|activefds
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listening on interface %s, %s#%d"
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|)
argument_list|)
argument_list|,
name|NTP_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
operator|)
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Listening on broadcast address %s#%d"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|)
argument_list|)
argument_list|,
name|NTP_PORT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|io_completion_port_add_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Now that we have opened all the sockets, turn off the reuse 	 * flag for security. 	 */
name|set_reuseaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Blacklist all bound interface addresses 	 * Wildcard interfaces are ignored. 	 */
for|for
control|(
name|i
operator|=
name|nwilds
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|SET_HOSTMASK
argument_list|(
operator|&
name|resmask
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|ss_family
argument_list|)
expr_stmt|;
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|,
operator|&
name|resmask
argument_list|,
name|RESM_NTPONLY
operator||
name|RESM_INTERFACE
argument_list|,
name|RES_IGNORE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate the address hash for each interface address. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|addr_refid
operator|=
name|addr2refid
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"create_sockets: ninterfaces=%d\n"
argument_list|,
name|ninterfaces
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"interface %d:  fd=%d,  bfd=%d,  name=%.8s,  flags=0x%x\n"
argument_list|,
name|i
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* Leave these as three printf calls. */
name|printf
argument_list|(
literal|"              sin=%s"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
condition|)
name|printf
argument_list|(
literal|"  bcast=%s,"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  mask=%s\n"
argument_list|,
name|stoa
argument_list|(
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|ninterfaces
return|;
block|}
end_function

begin_comment
comment|/*  * io_setbclient - open the broadcast client sockets  */
end_comment

begin_function
name|void
name|io_setbclient
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|OPEN_BCAST_SOCKET
name|set_reuseaddr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|nwilds
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* Only IPv4 addresses are valid for broadcast */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|ss_family
operator|!=
name|AF_INET
condition|)
continue|continue;
comment|/* Is this a broadcast address? */
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
operator|)
condition|)
continue|continue;
comment|/* Do we already have the broadcast address open? */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BCASTOPEN
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|SYS_SOLARIS
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPEN_BCAST_SOCKET
comment|/* Was: !SYS_DOMAINOS&& !SYS_LINUX */
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
name|open_socket
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
argument_list|,
name|INT_BROADCAST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_BCASTOPEN
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
name|io_completion_port_add_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
argument_list|,
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|!=
name|INVALID_SOCKET
condition|)
name|printf
argument_list|(
literal|"io_setbclient: Opened broadcast client on interface %d, socket: %d\n"
argument_list|,
name|i
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"io_setbclient: Unable to Open broadcast client on interface %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OPEN_BCAST_SOCKET
name|set_reuseaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"io_setbclient: Opened broadcast clients\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * set_reuseaddr() - set/clear REUSEADDR on all sockets  *			NB possible hole - should we be doing this on broadcast  *			fd's also?  */
end_comment

begin_function
specifier|static
name|void
name|set_reuseaddr
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * if inter_list[ n ].fd  is -1, we might have a adapter 		 * configured but not present 		 */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flag
argument_list|,
sizeof|sizeof
argument_list|(
name|flag
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"set_reuseaddr: setsockopt(SO_REUSEADDR, %s) failed: %m"
argument_list|,
name|flag
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * io_multicast_add() - add multicast group address  */
end_comment

begin_function
name|void
name|io_multicast_add
parameter_list|(
name|struct
name|sockaddr_storage
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
name|int
name|i
init|=
name|ninterfaces
decl_stmt|;
comment|/* Use the next interface */
name|u_int32
name|haddr
init|=
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
decl_stmt|;
name|struct
name|in_addr
name|iaddr
decl_stmt|;
name|SOCKET
name|s
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sinp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IPV6
name|struct
name|ipv6_mreq
name|mreq6
decl_stmt|;
name|struct
name|in6_addr
name|iaddr6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6p
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_IPV6 */
switch|switch
condition|(
name|addr
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|iaddr
operator|=
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin_addr
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN_CLASSD
argument_list|(
name|haddr
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"multicast address %s not class D"
argument_list|,
name|inet_ntoa
argument_list|(
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|nwilds
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* Be sure it's the correct family */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|ss_family
operator|!=
name|AF_INET
condition|)
continue|continue;
comment|/* Already have this address */
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return;
comment|/* found a free slot */
if|if
condition|(
name|SOCKNUL
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|<=
literal|0
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|<=
literal|0
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|==
literal|0
condition|)
break|break;
block|}
name|sinp
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|sinp
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sinp
operator|->
name|sin_addr
operator|=
name|iaddr
expr_stmt|;
name|sinp
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
comment|/* 		* Try opening a socket for the specified class D address. This 		* works under SunOS 4.x, but not OSF1 .. :-( 		*/
name|set_reuseaddr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|open_socket
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|sinp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_reuseaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildipv4
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|wildipv4
expr_stmt|;
comment|/* HACK ! -- stuff in an address */
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|=
name|addr
expr_stmt|;
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"...multicast address %s using wildcard socket"
argument_list|,
name|inet_ntoa
argument_list|(
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No wildcard socket available to use for address %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|s
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"multicast"
argument_list|,
sizeof|sizeof
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|~
operator|(
name|u_int32
operator|)
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
name|io_completion_port_add_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		* enable reception of multicast packets 		*/
name|mreq
operator|.
name|imr_multiaddr
operator|=
name|iaddr
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_ADD_MEMBERSHIP fails: %m for %x / %x (%s)"
argument_list|,
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
argument_list|,
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
argument_list|,
name|inet_ntoa
argument_list|(
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_MULTICAST
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|num_mcast
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|ninterfaces
condition|)
name|ninterfaces
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|add_addr_to_list
argument_list|(
operator|&
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_IPV6
case|case
name|AF_INET6
case|:
name|iaddr6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|iaddr6
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"address %s not IPv6 multicast address"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|nwilds
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* Be sure it's the correct family */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|ss_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
comment|/* Already have this address */
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return;
comment|/* found a free slot */
if|if
condition|(
name|SOCKNUL
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|<=
literal|0
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|<=
literal|0
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|==
literal|0
condition|)
break|break;
block|}
name|sin6p
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq6
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|sin6p
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6p
operator|->
name|sin6_addr
operator|=
name|iaddr6
expr_stmt|;
name|sin6p
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
comment|/* 		 * Try opening a socket for the specified class D address. This 		 * works under SunOS 4.x, but not OSF1 .. :-( 		 */
name|set_reuseaddr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|open_socket
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|sin6p
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_reuseaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildipv6
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|wildipv6
expr_stmt|;
comment|/* HACK ! -- stuff in an address */
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|=
name|addr
expr_stmt|;
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"...multicast address %s using wildcard socket"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No wildcard socket available to use for address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|s
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"multicast"
argument_list|,
sizeof|sizeof
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
name|io_completion_port_add_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * enable reception of multicast packets 		 */
name|mreq6
operator|.
name|ipv6mr_multiaddr
operator|=
name|iaddr6
expr_stmt|;
name|mreq6
operator|.
name|ipv6mr_interface
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_JOIN_GROUP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq6
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq6
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_JOIN_GROUP fails: %m on interface %d(%s)"
argument_list|,
name|mreq6
operator|.
name|ipv6mr_interface
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_MULTICAST
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|num_mcast
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|ninterfaces
condition|)
name|ninterfaces
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|add_addr_to_list
argument_list|(
operator|&
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE_IPV6 */
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"io_multicast_add %s\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* MCAST */
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot add multicast address %s as no MCAST support"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
block|}
end_function

begin_comment
comment|/*  * io_unsetbclient - close the broadcast client sockets  */
end_comment

begin_function
name|void
name|io_unsetbclient
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nwilds
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BCASTOPEN
operator|)
condition|)
continue|continue;
name|close_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|INT_BCASTOPEN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * io_multicast_del() - delete multicast group address  */
end_comment

begin_function
name|void
name|io_multicast_del
parameter_list|(
name|struct
name|sockaddr_storage
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MCAST
name|int
name|i
decl_stmt|;
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
name|u_int32
name|haddr
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IPV6
name|struct
name|ipv6_mreq
name|mreq6
decl_stmt|;
name|struct
name|in6_addr
name|haddr6
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_IPV6 */
switch|switch
condition|(
name|addr
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|haddr
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN_CLASSD
argument_list|(
name|haddr
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid multicast address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		* Disable reception of multicast packets 		*/
name|mreq
operator|.
name|imr_multiaddr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* Be sure it's the correct family */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|ss_family
operator|!=
name|AF_INET
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_MULTICAST
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|<
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|SOCKCMP
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
name|wildipv4
condition|)
block|{
comment|/* we have an explicit fd, so we can close it */
name|close_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
else|else
block|{
comment|/* We are sharing "any address" port :-(  Don't close it! */
if|if
condition|(
name|setsockopt
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_DROP_MEMBERSHIP fails on address: %s %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|num_mcast
operator|--
expr_stmt|;
comment|/* If there are none left negate the Multicast flag */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|num_mcast
operator|==
literal|0
condition|)
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|INT_MULTICAST
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|HAVE_IPV6
case|case
name|AF_INET6
case|:
name|haddr6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|haddr6
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid multicast address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		* Disable reception of multicast packets 		*/
name|mreq6
operator|.
name|ipv6mr_multiaddr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|mreq6
operator|.
name|ipv6mr_interface
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* Be sure it's the correct family */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|ss_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_MULTICAST
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|<
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|SOCKCMP
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
name|wildipv6
condition|)
block|{
comment|/* we have an explicit fd, so we can close it */
name|close_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inter_list
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
else|else
block|{
comment|/* We are sharing "any address" port :-(  Don't close it! */
if|if
condition|(
name|setsockopt
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_LEAVE_GROUP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq6
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq6
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_DROP_MEMBERSHIP fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there are none left negate the Multicast flag */
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|num_mcast
operator|==
literal|0
condition|)
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|INT_MULTICAST
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* HAVE_IPV6 */
block|}
comment|/* switch */
name|delete_addr_from_list
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not MCAST */
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"this function requires multicast kernel"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not MCAST */
block|}
end_function

begin_comment
comment|/*  * open_socket - open a socket, returning the file descriptor  */
end_comment

begin_function
specifier|static
name|SOCKET
name|open_socket
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|turn_off_reuse
parameter_list|)
block|{
name|int
name|errval
decl_stmt|;
name|SOCKET
name|fd
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|,
name|off
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPTOS_LOWDELAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPPROTO_IP
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_TOS
argument_list|)
name|int
name|tos
decl_stmt|;
endif|#
directive|endif
comment|/* IPTOS_LOWDELAY&& IPPROTO_IP&& IP_TOS */
if|if
condition|(
operator|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|isc_net_probeipv6
argument_list|()
operator|!=
name|ISC_R_SUCCESS
operator|)
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
comment|/* create a datagram (UDP) socket */
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|addr
operator|->
name|ss_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|errval
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(AF_INET, SOCK_DGRAM, 0) failed on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(AF_INET6, SOCK_DGRAM, 0) failed on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errval
operator|==
name|EPROTONOSUPPORT
operator|||
name|errval
operator|==
name|EAFNOSUPPORT
operator|||
name|errval
operator|==
name|EPFNOSUPPORT
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|addr
operator|->
name|ss_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|errval
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(AF_INET, SOCK_DGRAM, 0) failed on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(AF_INET6, SOCK_DGRAM, 0) failed on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errval
operator|==
name|WSAEPROTONOSUPPORT
operator|||
name|errval
operator|==
name|WSAEAFNOSUPPORT
operator|||
name|errval
operator|==
name|WSAEPFNOSUPPORT
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|connection_reset_fix
argument_list|(
name|fd
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"connection_reset_fix(fd) failed on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* set SO_REUSEADDR since we will be binding the same port 	   number on each interface */
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt SO_REUSEADDR on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|IPTOS_LOWDELAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPPROTO_IP
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_TOS
argument_list|)
comment|/* set IP_TOS to minimize packet delay */
name|tos
operator|=
name|IPTOS_LOWDELAY
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TOS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tos
argument_list|,
sizeof|sizeof
argument_list|(
name|tos
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPTOS_LOWDELAY on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|IPV6_V6ONLY
argument_list|)
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_V6ONLY on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* IPV6_V6ONLY */
if|#
directive|if
name|defined
argument_list|(
name|IPV6_BINDV6ONLY
argument_list|)
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_BINDV6ONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IPV6_BINDV6ONLY on fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPV6_BINDV6ONLY */
endif|#
directive|endif
comment|/* IPV6_V6ONLY */
endif|#
directive|endif
comment|/* IPTOS_LOWDELAY&& IPPROTO_IP&& IP_TOS */
comment|/* 	 * bind the local address. 	 */
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|SOCKLEN
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|buff
index|[
literal|160
index|]
decl_stmt|;
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"bind() fd %d, family %d, port %d, addr %s, in_classd=%d flags=%d fails: %%m"
argument_list|,
name|fd
argument_list|,
name|addr
operator|->
name|ss_family
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"bind() fd %d, family %d, port %d, addr %s, in6_is_addr_multicast=%d flags=%d fails: %%m"
argument_list|,
name|fd
argument_list|,
name|addr
operator|->
name|ss_family
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_port
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
return|return
name|INVALID_SOCKET
return|;
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 		 * soft fail if opening a multicast address 		 */
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|INVALID_SOCKET
operator|)
return|;
block|}
if|#
directive|if
literal|0
block|exit(1);
else|#
directive|else
return|return
name|INVALID_SOCKET
return|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bind() fd %d, family %d, port %d, addr %s, flags=%d\n"
argument_list|,
name|fd
argument_list|,
name|addr
operator|->
name|ss_family
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * I/O Completion Ports don't care about the select and FD_SET 	 */
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
if|if
condition|(
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_socket_to_list
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * set non-blocking, 	 */
ifdef|#
directive|ifdef
name|USE_FIONBIO
comment|/* in vxWorks we use FIONBIO, but the others are defined for old systems, so 	 * all hell breaks loose if we leave them defined 	 */
undef|#
directive|undef
name|O_NONBLOCK
undef|#
directive|undef
name|FNDELAY
undef|#
directive|undef
name|O_NDELAY
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
comment|/* POSIX */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NONBLOCK) fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY) fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
comment|/* generally the same as FNDELAY */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NDELAY) fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIONBIO
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
if|if
condition|(
name|ioctlsocket
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
name|SOCKET_ERROR
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIONBIO) fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIOSNBIO
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOSNBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSNBIO) fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
include|#
directive|include
file|"Bletch: Need non-blocking I/O!"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
name|init_socket_sig
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGNALED_IO */
comment|/* 	 *	Turn off the SO_REUSEADDR socket option.  It apparently 	 *	causes heartburn on systems with multicast IP installed. 	 *	On normal systems it only gets looked at when the address 	 *	is being bound anyway.. 	 */
if|if
condition|(
name|turn_off_reuse
condition|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt SO_REUSEADDR off fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SO_BROADCAST
comment|/* if this interface can support broadcast, set SO_BROADCAST */
if|if
condition|(
name|flags
operator|&
name|INT_BROADCAST
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(SO_BROADCAST) on address %s: %m"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SO_BROADCAST */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"flags for fd %d: 0%o\n"
argument_list|,
name|fd
argument_list|,
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SYS_WINNT || VMS */
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * close_socket - close a socket and remove from the activefd list  */
end_comment

begin_function
specifier|static
name|void
name|close_socket
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|SOCKET
name|i
decl_stmt|,
name|newmax
decl_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * I/O Completion Ports don't care about select and fd_set 	 */
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
name|FD_CLR
argument_list|(
operator|(
name|u_int
operator|)
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|maxactivefd
condition|)
block|{
name|newmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxactivefd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|activefds
argument_list|)
condition|)
name|newmax
operator|=
name|i
expr_stmt|;
name|maxactivefd
operator|=
name|newmax
expr_stmt|;
block|}
endif|#
directive|endif
name|delete_socket_from_list
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * close_file - close a file and remove from the activefd list  * added 1/31/1997 Greg Schueman for Windows NT portability  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_function
specifier|static
name|void
name|close_file
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|newmax
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * I/O Completion Ports don't care about select and fd_set 	 */
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
name|FD_CLR
argument_list|(
operator|(
name|u_int
operator|)
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|maxactivefd
condition|)
block|{
name|newmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxactivefd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|activefds
argument_list|)
condition|)
name|newmax
operator|=
name|i
expr_stmt|;
name|maxactivefd
operator|=
name|newmax
expr_stmt|;
block|}
endif|#
directive|endif
name|delete_socket_from_list
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
end_comment

begin_comment
comment|/*  * sendpkt - send a packet to the specified destination. Maintain a  * send error cache so that only the first consecutive error for a  * destination is logged.  */
end_comment

begin_function
name|void
name|sendpkt
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|dest
parameter_list|,
name|struct
name|interface
modifier|*
name|inter
parameter_list|,
name|int
name|ttl
parameter_list|,
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cc
decl_stmt|,
name|slot
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|DWORD
name|err
decl_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Send error caches. Empty slots have port == 0 	 * Set ERRORCACHESIZE to 0 to disable 	 */
struct|struct
name|cache
block|{
name|u_short
name|port
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
block|}
struct|;
ifdef|#
directive|ifdef
name|HAVE_IPV6
struct|struct
name|cache6
block|{
name|u_short
name|port
decl_stmt|;
name|struct
name|in6_addr
name|addr
decl_stmt|;
block|}
struct|;
endif|#
directive|endif
comment|/* HAVE_IPV6 */
ifndef|#
directive|ifndef
name|ERRORCACHESIZE
define|#
directive|define
name|ERRORCACHESIZE
value|8
endif|#
directive|endif
if|#
directive|if
name|ERRORCACHESIZE
operator|>
literal|0
specifier|static
name|struct
name|cache
name|badaddrs
index|[
name|ERRORCACHESIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IPV6
specifier|static
name|struct
name|cache6
name|badaddrs6
index|[
name|ERRORCACHESIZE
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_IPV6 */
else|#
directive|else
define|#
directive|define
name|badaddrs
value|((struct cache *)0)
comment|/* Only used in empty loops! */
ifdef|#
directive|ifdef
name|HAVE_IPV6
define|#
directive|define
name|badaddrs6
value|((struct cache6 *)0)
comment|/* Only used in empty loops! */
endif|#
directive|endif
comment|/* HAVE_IPV6 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%ssendpkt(fd=%d dst=%s, src=%s, ttl=%d, len=%d)\n"
argument_list|,
operator|(
name|ttl
operator|>=
literal|0
operator|)
condition|?
literal|"\tMCAST\t*****"
else|:
literal|""
argument_list|,
name|inter
operator|->
name|fd
argument_list|,
name|stoa
argument_list|(
name|dest
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|inter
operator|->
name|sin
argument_list|)
argument_list|,
name|ttl
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MCAST
switch|switch
condition|(
name|inter
operator|->
name|sin
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
comment|/* 		* for the moment we use the bcast option to set multicast ttl 		*/
if|if
condition|(
name|ttl
operator|>
literal|0
operator|&&
name|ttl
operator|!=
name|inter
operator|->
name|last_ttl
condition|)
block|{
comment|/* 			* set the multicast ttl for outgoing packets 			*/
if|if
condition|(
name|setsockopt
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_TTL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_TTL fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|inter
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inter
operator|->
name|last_ttl
operator|=
name|ttl
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|HAVE_IPV6
case|case
name|AF_INET6
case|:
comment|/* 		 * for the moment we use the bcast option to set 		 * multicast max hops 		 */
if|if
condition|(
name|ttl
operator|>
literal|0
operator|&&
name|ttl
operator|!=
name|inter
operator|->
name|last_ttl
condition|)
block|{
comment|/*                  	* set the multicast ttl for outgoing packets                  	*/
if|if
condition|(
name|setsockopt
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_HOPS
argument_list|,
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_TTL fails on address %s: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|inter
operator|->
name|sin
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|inter
operator|->
name|last_ttl
operator|=
name|ttl
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* HAVE_IPV6 */
default|default :
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MCAST */
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|dest
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin_port
operator|&&
name|badaddrs
index|[
name|slot
index|]
operator|.
name|addr
operator|.
name|s_addr
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|HAVE_IPV6
elseif|else
if|if
condition|(
name|dest
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|port
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin6_port
operator|&&
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|addr
operator|.
name|s6_addr
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin6_addr
operator|.
name|s6_addr
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* HAVE_IPV6 */
else|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* address family not supported yet */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
name|err
operator|=
name|io_completion_port_sendto
argument_list|(
name|inter
argument_list|,
name|pkt
argument_list|,
name|len
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ERROR_SUCCESS
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|SIM
name|cc
operator|=
name|srvr_rply
argument_list|(
operator|&
name|ntp_node
argument_list|,
name|dest
argument_list|,
name|inter
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SIM */
name|cc
operator|=
name|sendto
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dest
argument_list|,
name|SOCKLEN
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIM */
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|inter
operator|->
name|notsent
operator|++
expr_stmt|;
name|packets_notsent
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
name|err
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|WSAEWOULDBLOCK
operator|&&
name|err
operator|!=
name|WSAENOBUFS
operator|&&
name|slot
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENOBUFS
operator|&&
name|slot
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
comment|/* 			 * Remember this, if there's an empty slot 			 */
switch|switch
condition|(
name|dest
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|==
literal|0
condition|)
block|{
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|=
name|SRCPORT
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|badaddrs
index|[
name|slot
index|]
operator|.
name|addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin_addr
expr_stmt|;
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|HAVE_IPV6
case|case
name|AF_INET6
case|:
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|port
operator|==
literal|0
condition|)
block|{
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|port
operator|=
name|SRCPORT
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dest
operator|)
operator|->
name|sin6_addr
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
comment|/* HAVE_IPV6 */
default|default :
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto(%s): %m"
argument_list|,
name|stoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inter
operator|->
name|sent
operator|++
expr_stmt|;
name|packets_sent
operator|++
expr_stmt|;
comment|/* 		 * He's not bad any more 		 */
if|if
condition|(
name|slot
operator|>=
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Connection re-established to %s"
argument_list|,
name|stoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dest
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_IPV6
case|case
name|AF_INET6
case|:
name|badaddrs6
index|[
name|slot
index|]
operator|.
name|port
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE_IPV6 */
block|}
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
end_if

begin_comment
comment|/*  * fdbits - generate ascii representation of fd_set (FAU debug support)  * HFDF format - highest fd first.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fdbits
parameter_list|(
name|int
name|count
parameter_list|,
name|fd_set
modifier|*
name|set
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|buffer
decl_stmt|;
name|count
operator|=
operator|(
name|count
operator|<
literal|256
operator|)
condition|?
name|count
else|:
literal|255
expr_stmt|;
while|while
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|FD_ISSET
argument_list|(
name|count
argument_list|,
name|set
argument_list|)
condition|?
literal|'#'
else|:
literal|'-'
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*  * input_handler - receive packets asynchronously  */
end_comment

begin_function
name|void
name|input_handler
parameter_list|(
name|l_fp
modifier|*
name|cts
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
specifier|register
name|int
name|doing
decl_stmt|;
specifier|register
name|SOCKET
name|fd
decl_stmt|;
name|struct
name|timeval
name|tvzero
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
comment|/* Timestamp at BOselect() gob */
name|l_fp
name|ts_e
decl_stmt|;
comment|/* Timestamp at EOselect() gob */
name|fd_set
name|fds
decl_stmt|;
name|int
name|select_count
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|handler_count
init|=
literal|0
decl_stmt|;
operator|++
name|handler_count
expr_stmt|;
if|if
condition|(
name|handler_count
operator|!=
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"input_handler: handler_count is %d!"
argument_list|,
name|handler_count
argument_list|)
expr_stmt|;
name|handler_calls
operator|++
expr_stmt|;
name|ts
operator|=
operator|*
name|cts
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Do a poll to see who has data 		 */
name|fds
operator|=
name|activefds
expr_stmt|;
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we have something to do, freeze a timestamp. 		 * See below for the other cases (nothing (left) to do or error) 		 */
while|while
condition|(
literal|0
operator|<
operator|(
name|n
operator|=
name|select
argument_list|(
name|maxactivefd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvzero
argument_list|)
operator|)
condition|)
block|{
operator|++
name|select_count
expr_stmt|;
operator|++
name|handler_pkts
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 			 * Check out the reference clocks first, if any 			 */
if|if
condition|(
name|refio
operator|!=
literal|0
condition|)
block|{
specifier|register
name|struct
name|refclockio
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|refio
init|;
name|rp
operator|!=
literal|0
operator|&&
name|n
operator|>
literal|0
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
name|fd
operator|=
name|rp
operator|->
name|fd
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|free_recvbuffs
argument_list|()
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|packets_dropped
operator|++
expr_stmt|;
goto|goto
name|select_again
goto|;
block|}
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
name|i
operator|=
operator|(
name|rp
operator|->
name|datalen
operator|==
literal|0
operator|||
name|rp
operator|->
name|datalen
operator|>
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
else|:
name|rp
operator|->
name|datalen
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|==
operator|-
literal|1
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"clock read fd %d: %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
goto|goto
name|select_again
goto|;
block|}
comment|/* 						 * Got one.  Mark how 						 * and when it got here, 						 * put it on the full 						 * list and do 						 * bookkeeping. 						 */
name|rb
operator|->
name|recv_srcclock
operator|=
name|rp
operator|->
name|srcclock
expr_stmt|;
name|rb
operator|->
name|dstadr
operator|=
literal|0
expr_stmt|;
name|rb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|rp
operator|->
name|clock_recv
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|io_input
condition|)
block|{
comment|/* 							 * have direct 							 * input routine 							 * for refclocks 							 */
if|if
condition|(
name|rp
operator|->
name|io_input
argument_list|(
name|rb
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 								 * data 								 * was 								 * consumed 								 * - 								 * nothing 								 * to 								 * pass 								 * up 								 * into 								 * block 								 * input 								 * machine 								 */
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
goto|goto
name|select_again
goto|;
else|#
directive|else
continue|continue;
endif|#
directive|endif
block|}
block|}
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|rp
operator|->
name|recvcount
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/* 			 * Loop through the interfaces looking for data 			 * to read. 			 */
for|for
control|(
name|i
operator|=
name|ninterfaces
operator|-
literal|1
init|;
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|n
operator|>
literal|0
operator|)
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|doing
operator|=
literal|0
init|;
operator|(
name|doing
operator|<
literal|2
operator|)
operator|&&
operator|(
name|n
operator|>
literal|0
operator|)
condition|;
name|doing
operator|++
control|)
block|{
if|if
condition|(
name|doing
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BCASTOPEN
operator|)
condition|)
break|break;
name|fd
operator|=
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|n
operator|--
expr_stmt|;
comment|/* 						 * Get a buffer and read 						 * the frame.  If we 						 * haven't got a buffer, 						 * or this is received 						 * on the wild card 						 * socket, just dump the 						 * packet. 						 */
if|if
condition|(
ifdef|#
directive|ifdef
name|UDP_WILDCARD_DELIVERY
comment|/* 				 * these guys manage to put properly addressed 				 * packets into the wildcard queue 				 */
operator|(
name|free_recvbuffs
argument_list|()
operator|==
literal|0
operator|)
else|#
directive|else
operator|(
operator|(
name|i
operator|==
name|wildipv4
operator|)
operator|||
operator|(
name|i
operator|==
name|wildipv6
operator|)
operator|||
operator|(
name|free_recvbuffs
argument_list|()
operator|==
literal|0
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
name|struct
name|sockaddr_storage
name|from
decl_stmt|;
name|fromlen
operator|=
sizeof|sizeof
name|from
expr_stmt|;
operator|(
name|void
operator|)
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s on %d(%lu) fd=%d from %s\n"
argument_list|,
operator|(
name|i
operator|)
condition|?
literal|"drop"
else|:
literal|"ignore"
argument_list|,
name|i
argument_list|,
name|free_recvbuffs
argument_list|()
argument_list|,
name|fd
argument_list|,
name|stoa
argument_list|(
operator|&
name|from
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
name|wildipv4
operator|||
name|i
operator|==
name|wildipv6
condition|)
name|packets_ignored
operator|++
expr_stmt|;
else|else
name|packets_dropped
operator|++
expr_stmt|;
goto|goto
name|select_again
goto|;
block|}
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|==
literal|0
ifdef|#
directive|ifdef
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|EWOULDBLOCK
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAGAIN
operator|||
name|errno
operator|==
name|EAGAIN
endif|#
directive|endif
condition|)
block|{
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|<
literal|0
condition|)
block|{
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"recvfrom(%s) fd=%d: %m"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"input_handler: fd=%d dropped (bad recvfrom)\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|rb
operator|->
name|recv_srcadr
operator|.
name|ss_family
operator|==
name|AF_INET
condition|)
name|printf
argument_list|(
literal|"input_handler: if=%d fd=%d length %d from %08lx %s\n"
argument_list|,
name|i
argument_list|,
name|fd
argument_list|,
name|rb
operator|->
name|recv_length
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_srcadr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
literal|0x00000000ffffffff
argument_list|,
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"input_handler: if=%d fd=%d length %d from %s\n"
argument_list|,
name|i
argument_list|,
name|fd
argument_list|,
name|rb
operator|->
name|recv_length
argument_list|,
name|stoa
argument_list|(
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Got one.  Mark how and when it got here, 	 * put it on the full list and do bookkeeping. 	 */
name|rb
operator|->
name|dstadr
operator|=
operator|&
name|inter_list
index|[
name|i
index|]
expr_stmt|;
name|rb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|receive
expr_stmt|;
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|received
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
goto|goto
name|select_again
goto|;
block|}
comment|/* Check more interfaces */
block|}
block|}
name|select_again
label|:
empty_stmt|;
comment|/* 			 * Done everything from that select.  Poll again. 			 */
block|}
comment|/* 		 * If nothing more to do, try again. 		 * If nothing to do, just return. 		 * If an error occurred, complain and return. 		 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|select_count
operator|==
literal|0
condition|)
comment|/* We really had nothing to do */
block|{
if|if
condition|(
name|debug
condition|)
name|netsyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"input_handler: select() returned 0"
argument_list|)
expr_stmt|;
operator|--
name|handler_count
expr_stmt|;
return|return;
block|}
comment|/* We've done our work */
name|get_systime
argument_list|(
operator|&
name|ts_e
argument_list|)
expr_stmt|;
comment|/* 			 * (ts_e - ts) is the amount of time we spent 			 * processing this gob of file descriptors.  Log 			 * it. 			 */
name|L_SUB
argument_list|(
operator|&
name|ts_e
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|netsyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"input_handler: Processed a gob of fd's in %s msec"
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|ts_e
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
comment|/* just bail. */
operator|--
name|handler_count
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
comment|/* 			 * extended FAU debugging output 			 */
if|if
condition|(
name|err
operator|!=
name|EINTR
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select(%d, %s, 0L, 0L,&0.0) error: %m"
argument_list|,
name|maxactivefd
operator|+
literal|1
argument_list|,
name|fdbits
argument_list|(
name|maxactivefd
argument_list|,
operator|&
name|activefds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADF
condition|)
block|{
name|int
name|j
decl_stmt|,
name|b
decl_stmt|;
name|fds
operator|=
name|activefds
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|maxactivefd
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|FD_ISSET
argument_list|(
name|j
argument_list|,
operator|&
name|fds
argument_list|)
operator|&&
operator|(
name|read
argument_list|(
name|j
argument_list|,
operator|&
name|b
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
name|netsyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Bad file descriptor %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
operator|--
name|handler_count
expr_stmt|;
return|return;
block|}
block|}
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"input_handler: fell out of infinite for(;;) loop!"
argument_list|)
expr_stmt|;
operator|--
name|handler_count
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * findinterface - find interface corresponding to address  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|findinterface
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|)
block|{
name|SOCKET
name|s
decl_stmt|;
name|int
name|rtn
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sockaddr_storage
name|saddr
decl_stmt|;
name|int
name|saddrlen
init|=
name|SOCKLEN
argument_list|(
name|addr
argument_list|)
decl_stmt|;
comment|/* 	 * This is considerably hoke. We open a socket, connect to it 	 * and slap a getsockname() on it. If anything breaks, as it 	 * probably will in some j-random knockoff, we just return the 	 * wildcard interface. 	 */
name|memset
argument_list|(
operator|&
name|saddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
name|saddr
operator|.
name|ss_family
operator|=
name|addr
operator|->
name|ss_family
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|saddr
operator|)
operator|->
name|sin_addr
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|saddr
operator|)
operator|->
name|sin6_addr
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|saddr
operator|)
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|addr
operator|->
name|ss_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|INVALID_SOCKET
condition|)
return|return
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|addr
argument_list|)
return|;
name|rtn
operator|=
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
name|SOCKLEN
argument_list|(
operator|&
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|rtn
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|rtn
operator|==
name|SOCKET_ERROR
condition|)
endif|#
directive|endif
block|{
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|addr
argument_list|)
return|;
block|}
name|rtn
operator|=
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
operator|&
name|saddrlen
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|rtn
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|rtn
operator|==
name|SOCKET_ERROR
condition|)
endif|#
directive|endif
return|return
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|addr
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		* First look if is the the correct family 		*/
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|ss_family
operator|!=
name|saddr
operator|.
name|ss_family
condition|)
continue|continue;
comment|/* 		 * We match the unicast address only. 		 */
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|,
operator|&
name|saddr
argument_list|)
condition|)
return|return
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * findbcastinter - find broadcast interface corresponding to address  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|findbcastinter
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MPE
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SIOCGIFCONF
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|)
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|find_addr_in_list
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		* First look if this is the correct family 		*/
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|ss_family
operator|!=
name|addr
operator|->
name|ss_family
condition|)
continue|continue;
comment|/* 		 * We match only those interfaces marked as 		 * broadcastable and either the explicit broadcast 		 * address or the network portion of the IP address. 		 * Sloppy. 		 */
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
operator|)
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
argument_list|,
name|addr
argument_list|)
condition|)
return|return
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|)
return|;
if|if
condition|(
operator|(
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
operator|&
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
argument_list|)
operator|)
operator|==
operator|(
name|NSRCADR
argument_list|(
name|addr
argument_list|)
operator|&
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
argument_list|,
name|addr
argument_list|)
condition|)
return|return
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|)
return|;
if|if
condition|(
name|SOCKCMP
argument_list|(
name|netof
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
argument_list|,
name|netof
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* SIOCGIFCONF */
return|return
name|ANY_INTERFACE_CHOOSE
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * io_clr_stats - clear I/O module statistics  */
end_comment

begin_function
name|void
name|io_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|packets_dropped
operator|=
literal|0
expr_stmt|;
name|packets_ignored
operator|=
literal|0
expr_stmt|;
name|packets_received
operator|=
literal|0
expr_stmt|;
name|packets_sent
operator|=
literal|0
expr_stmt|;
name|packets_notsent
operator|=
literal|0
expr_stmt|;
name|handler_calls
operator|=
literal|0
expr_stmt|;
name|handler_pkts
operator|=
literal|0
expr_stmt|;
name|io_timereset
operator|=
name|current_time
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * This is a hack so that I don't have to fool with these ioctls in the  * pps driver ... we are already non-blocking and turn on SIGIO thru  * another mechanisim  */
end_comment

begin_function
name|int
name|io_addclock_simple
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * Stuff the I/O structure in the list and mark the descriptor 	 * in use.	There is a harmless (I hope) race condition here. 	 */
name|rio
operator|->
name|next
operator|=
name|refio
expr_stmt|;
name|refio
operator|=
name|rio
expr_stmt|;
comment|/* 	 * I/O Completion Ports don't care about select and fd_set 	 */
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
if|if
condition|(
name|rio
operator|->
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * io_addclock - add a reference clock to the list and arrange that we  *				 get SIGIO interrupts from it.  */
end_comment

begin_function
name|int
name|io_addclock
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * Stuff the I/O structure in the list and mark the descriptor 	 * in use.	There is a harmless (I hope) race condition here. 	 */
name|rio
operator|->
name|next
operator|=
name|refio
expr_stmt|;
name|refio
operator|=
name|rio
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
if|if
condition|(
name|init_clock_sig
argument_list|(
name|rio
argument_list|)
condition|)
block|{
name|refio
operator|=
name|rio
operator|->
name|next
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
if|if
condition|(
name|io_completion_port_add_clock_io
argument_list|(
name|rio
argument_list|)
condition|)
block|{
name|add_socket_to_list
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
name|refio
operator|=
name|rio
operator|->
name|next
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* 	 * I/O Completion Ports don't care about select and fd_set 	 */
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
if|if
condition|(
name|rio
operator|->
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * io_closeclock - close the clock in the I/O structure given  */
end_comment

begin_function
name|void
name|io_closeclock
parameter_list|(
name|struct
name|refclockio
modifier|*
name|rio
parameter_list|)
block|{
comment|/* 	 * Remove structure from the list 	 */
if|if
condition|(
name|refio
operator|==
name|rio
condition|)
block|{
name|refio
operator|=
name|rio
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|refclockio
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|refio
init|;
name|rp
operator|!=
literal|0
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|rp
operator|->
name|next
operator|==
name|rio
condition|)
block|{
name|rp
operator|->
name|next
operator|=
name|rio
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rp
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Internal error.	Report it. 			 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error: refclockio structure not found"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Close the descriptor. 	 */
name|close_file
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_comment
comment|/* 	 * I/O Completion Ports don't care about select and fd_set 	 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_IO_COMPLETION_PORT
end_ifndef

begin_function
name|void
name|kill_asyncio
parameter_list|(
name|int
name|startfd
parameter_list|)
block|{
name|SOCKET
name|i
decl_stmt|;
name|BLOCKIO
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|startfd
init|;
name|i
operator|<=
name|maxactivefd
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|close_socket
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * On NT a SOCKET is an unsigned int so we cannot possibly keep it in  * an array. So we use one of the ISC_LIST functions to hold the  * socket value and use that when we want to enumerate it.  */
end_comment

begin_function
name|void
name|kill_asyncio
parameter_list|(
name|int
name|startfd
parameter_list|)
block|{
name|vsock_t
modifier|*
name|lsock
decl_stmt|;
name|vsock_t
modifier|*
name|next
decl_stmt|;
name|BLOCKIO
argument_list|()
expr_stmt|;
name|lsock
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sockets_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|lsock
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|lsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|close_socket
argument_list|(
name|lsock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|lsock
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Add and delete functions for the list of open sockets  */
end_comment

begin_function
name|void
name|add_socket_to_list
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|vsock_t
modifier|*
name|lsock
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vsock_t
argument_list|)
argument_list|)
decl_stmt|;
name|lsock
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|sockets_list
argument_list|,
name|lsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_socket_from_list
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|vsock_t
modifier|*
name|next
decl_stmt|;
name|vsock_t
modifier|*
name|lsock
init|=
name|ISC_LIST_HEAD
argument_list|(
name|sockets_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|lsock
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|lsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsock
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
name|sockets_list
argument_list|,
name|lsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lsock
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|lsock
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|add_addr_to_list
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|int
name|if_index
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|laddr
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|remaddr_t
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|laddr
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|laddr
operator|->
name|if_index
operator|=
name|if_index
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|remoteaddr_list
argument_list|,
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Added addr %s to list of addresses\n"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|delete_addr_from_list
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|next
decl_stmt|;
name|remaddr_t
modifier|*
name|laddr
init|=
name|ISC_LIST_HEAD
argument_list|(
name|remoteaddr_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|laddr
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|laddr
operator|->
name|addr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
name|remoteaddr_list
argument_list|,
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|laddr
operator|=
name|next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Deleted addr %s from list of addresses\n"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|find_addr_in_list
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|)
block|{
name|remaddr_t
modifier|*
name|next
decl_stmt|;
name|remaddr_t
modifier|*
name|laddr
init|=
name|ISC_LIST_HEAD
argument_list|(
name|remoteaddr_list
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Finding addr %s in list of addresses\n"
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|laddr
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKCMP
argument_list|(
operator|&
name|laddr
operator|->
name|addr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
return|return
operator|(
name|laddr
operator|->
name|if_index
operator|)
return|;
break|break;
block|}
else|else
name|laddr
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Not found */
block|}
end_function

end_unit

