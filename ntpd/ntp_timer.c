begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_timer.c - event timer support routines  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SIGNAL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IO_COMPLETION_PORT
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntp_iocompletionport.h"
end_include

begin_include
include|#
directive|include
file|"ntp_timer.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_PLL
end_ifdef

begin_include
include|#
directive|include
file|"ntp_syscall.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * These routines provide support for the event timer.	The timer is  * implemented by an interrupt routine which sets a flag once every  * 2**EVENT_TIMEOUT seconds (currently 4), and a timer routine which  * is called when the mainline code gets around to seeing the flag.  * The timer routine dispatches the clock adjustment code if its time  * has come, then searches the timer queue for expiries which are  * dispatched to the transmit procedure.  Finally, we call the hourly  * procedure to do cleanup and print a message.  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|interface_interval
init|=
literal|300
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* update interface every 5 minutes as default */
end_comment

begin_comment
comment|/*  * Alarm flag. The mainline code imports this.  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|alarm_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The counters and timeouts  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|interface_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface update timer */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|adjust_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* second timer */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|stats_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stats timer */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|huffpuff_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* huff-n'-puff timer */
end_comment

begin_decl_stmt
name|u_long
name|leapsec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* leapseconds countdown */
end_comment

begin_decl_stmt
name|l_fp
name|sys_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current system time */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_decl_stmt
specifier|static
name|u_long
name|revoke_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys revoke timer */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|keys_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* session key timer */
end_comment

begin_decl_stmt
name|u_long
name|sys_revoke
init|=
name|KEY_REVOKE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys revoke timeout (log2 s) */
end_comment

begin_decl_stmt
name|u_long
name|sys_automax
init|=
name|NTP_AUTOMAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key list timeout (log2 s) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * Statistics counter for the interested.  */
end_comment

begin_decl_stmt
specifier|volatile
name|u_long
name|alarm_overflow
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MINUTE
value|60
end_define

begin_define
define|#
directive|define
name|HOUR
value|(60 * MINUTE)
end_define

begin_define
define|#
directive|define
name|DAY
value|(24 * HOUR)
end_define

begin_decl_stmt
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seconds since startup */
end_comment

begin_comment
comment|/*  * Stats.  Number of overflows and number of calls to transmit().  */
end_comment

begin_decl_stmt
name|u_long
name|timer_timereset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|timer_overflows
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|timer_xmtcalls
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|vmstimer
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time for next timer AST */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vmsinc
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timer increment */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_if
if|#
directive|if
name|defined
name|SYS_WINNT
end_if

begin_decl_stmt
specifier|static
name|HANDLE
name|WaitableTimerHandle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|RETSIGTYPE
name|alarming
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
name|SYS_WINNT
operator|||
name|defined
argument_list|(
name|SYS_CYGWIN32
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_TIMER_SETTIME
end_ifndef

begin_decl_stmt
name|struct
name|itimerval
name|itimer
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|timer_t
name|ntpd_timerid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|itimerspec
name|itimer
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TIMER_SETTIME */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/*  * reinit_timer - reinitialize interval timer.  */
end_comment

begin_function
name|void
name|reinit_timer
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TIMER_CREATE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_TIMER_SETTIME
argument_list|)
name|timer_gettime
argument_list|(
name|ntpd_timerid
argument_list|,
operator|&
name|itimer
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|>
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
condition|)
block|{
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|itimer
operator|.
name|it_value
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|itimer
operator|.
name|it_value
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|itimer
operator|.
name|it_value
operator|.
name|tv_nsec
operator|==
literal|0
condition|)
block|{
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|timer_settime
argument_list|(
name|ntpd_timerid
argument_list|,
literal|0
comment|/*!TIMER_ABSTIME*/
argument_list|,
operator|&
name|itimer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|getitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|>
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
condition|)
block|{
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|==
literal|0
condition|)
block|{
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* VMS */
block|}
end_function

begin_comment
comment|/*  * init_timer - initialize the timer data structures  */
end_comment

begin_function
name|void
name|init_timer
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize... 	 */
name|alarm_flag
operator|=
literal|0
expr_stmt|;
name|alarm_overflow
operator|=
literal|0
expr_stmt|;
name|adjust_timer
operator|=
literal|1
expr_stmt|;
name|stats_timer
operator|=
literal|0
expr_stmt|;
name|huffpuff_timer
operator|=
literal|0
expr_stmt|;
name|interface_timer
operator|=
literal|0
expr_stmt|;
name|current_time
operator|=
literal|0
expr_stmt|;
name|timer_overflows
operator|=
literal|0
expr_stmt|;
name|timer_xmtcalls
operator|=
literal|0
expr_stmt|;
name|timer_timereset
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
comment|/* 	 * Set up the alarm interrupt.	The first comes 2**EVENT_TIMEOUT 	 * seconds from now and they continue on every 2**EVENT_TIMEOUT 	 * seconds. 	 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TIMER_CREATE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_TIMER_SETTIME
argument_list|)
if|if
condition|(
name|timer_create
argument_list|(
name|CLOCK_REALTIME
argument_list|,
name|NULL
argument_list|,
operator|&
name|ntpd_timerid
argument_list|)
operator|==
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|ERROR
else|#
directive|else
operator|-
literal|1
endif|#
directive|endif
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"timer create FAILED\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|alarming
argument_list|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_nsec
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|timer_settime
argument_list|(
name|ntpd_timerid
argument_list|,
literal|0
comment|/*!TIMER_ABSTIME*/
argument_list|,
operator|&
name|itimer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|alarming
argument_list|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* VMS */
name|vmsinc
index|[
literal|0
index|]
operator|=
literal|10000000
expr_stmt|;
comment|/* 1 sec */
name|vmsinc
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|lib$emul
argument_list|(
operator|&
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
argument_list|,
operator|&
name|vmsinc
argument_list|,
operator|&
literal|0
argument_list|,
operator|&
name|vmsinc
argument_list|)
expr_stmt|;
name|sys$gettim
argument_list|(
operator|&
name|vmstimer
argument_list|)
expr_stmt|;
comment|/* that's "now" as abstime */
name|lib$addx
argument_list|(
operator|&
name|vmsinc
argument_list|,
operator|&
name|vmstimer
argument_list|,
operator|&
name|vmstimer
argument_list|)
expr_stmt|;
name|sys$setimr
argument_list|(
literal|0
argument_list|,
operator|&
name|vmstimer
argument_list|,
name|alarming
argument_list|,
name|alarming
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
else|#
directive|else
comment|/* SYS_WINNT */
comment|/* 	 * Set up timer interrupts for every 2**EVENT_TIMEOUT seconds 	 * Under Windows/NT,  	 */
name|WaitableTimerHandle
operator|=
name|CreateWaitableTimer
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitableTimerHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"CreateWaitableTimer failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DWORD
name|Period
init|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
operator|*
literal|1000
decl_stmt|;
name|LARGE_INTEGER
name|DueTime
decl_stmt|;
name|DueTime
operator|.
name|QuadPart
operator|=
name|Period
operator|*
literal|10000i
literal|64
expr_stmt|;
if|if
condition|(
operator|!
name|SetWaitableTimer
argument_list|(
name|WaitableTimerHandle
argument_list|,
operator|&
name|DueTime
argument_list|,
name|Period
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
operator|!=
name|NO_ERROR
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SetWaitableTimer failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_function
specifier|extern
name|HANDLE
name|get_timer_handle
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|WaitableTimerHandle
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * timer - event timer  */
end_comment

begin_function
name|void
name|timer
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|,
modifier|*
name|next_peer
decl_stmt|;
name|u_int
name|n
decl_stmt|;
comment|/* 	 * The basic timerevent is one second. This is used to adjust 	 * the system clock in time and frequency, implement the 	 * kiss-o'-deatch function and implement the association 	 * polling function.. 	 */
name|current_time
operator|++
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|sys_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust_timer
operator|<=
name|current_time
condition|)
block|{
name|adjust_timer
operator|+=
literal|1
expr_stmt|;
name|adj_host_clock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NTP_HASH_SIZE
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|n
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|next_peer
control|)
block|{
name|next_peer
operator|=
name|peer
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|refclock_timer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
block|}
comment|/* 	 * Now dispatch any peers whose event timer has expired. Be 	 * careful here, since the peer structure might go away as the 	 * result of the call. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NTP_HASH_SIZE
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|n
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|next_peer
control|)
block|{
name|next_peer
operator|=
name|peer
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|action
operator|&&
name|peer
operator|->
name|nextaction
operator|<=
name|current_time
condition|)
name|peer
operator|->
name|action
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* 			 * Restrain the non-burst packet rate not more 			 * than one packet every 16 seconds. This is 			 * usually tripped using iburst and minpoll of 			 * 128 s or less. 			 */
if|if
condition|(
name|peer
operator|->
name|throttle
operator|>
literal|0
condition|)
name|peer
operator|->
name|throttle
operator|--
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|nextdate
operator|<=
name|current_time
condition|)
block|{
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|refclock_transmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
else|else
name|transmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* REFCLOCK */
name|transmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* REFCLOCK */
block|}
block|}
block|}
comment|/* 	 * Orphan mode is active when enabled and when no servers less 	 * than the orphan stratum are available. A server with no other 	 * synchronization source is an orphan. It shows offset zero and 	 * reference ID the loopback address. 	 */
if|if
condition|(
name|sys_orphan
operator|<
name|STRATUM_UNSPEC
operator|&&
name|sys_peer
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
name|sys_leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|crypto_flags
condition|)
name|crypto_update
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
block|}
name|sys_stratum
operator|=
operator|(
name|u_char
operator|)
name|sys_orphan
expr_stmt|;
if|if
condition|(
name|sys_stratum
operator|>
literal|1
condition|)
name|sys_refid
operator|=
name|htonl
argument_list|(
name|LOOPBACKADR
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|sys_refid
argument_list|,
literal|"LOOP"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sys_offset
operator|=
literal|0
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdisp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Leapseconds. If a leap is pending, decrement the time 	 * remaining. If less than one day remains, set the leap bits. 	 * When no time remains, clear the leap bits and increment the 	 * TAI. If kernel suppport is not available, do the leap 	 * crudely. Note a leap cannot be pending unless the clock is 	 * set. 	 */
if|if
condition|(
name|leapsec
operator|>
literal|0
condition|)
block|{
name|leapsec
operator|--
expr_stmt|;
if|if
condition|(
name|leapsec
operator|==
literal|0
condition|)
block|{
name|sys_leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|sys_tai
operator|=
name|leap_tai
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNEL_PLL
if|if
condition|(
operator|!
operator|(
name|pll_control
operator|&&
name|kern_enable
operator|)
condition|)
name|step_systime
argument_list|(
operator|-
literal|1.0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* KERNEL_PLL */
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* WinNT port has its own leap second handling */
name|step_systime
argument_list|(
operator|-
literal|1.0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
endif|#
directive|endif
comment|/* KERNEL_PLL */
name|report_event
argument_list|(
name|EVNT_LEAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|leapsec
operator|<
name|DAY
condition|)
name|sys_leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
if|if
condition|(
name|leap_tai
operator|>
literal|0
condition|)
name|sys_tai
operator|=
name|leap_tai
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Update huff-n'-puff filter. 	 */
if|if
condition|(
name|huffpuff_timer
operator|<=
name|current_time
condition|)
block|{
name|huffpuff_timer
operator|+=
name|HUFFPUFF
expr_stmt|;
name|huffpuff
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 	 * Garbage collect expired keys. 	 */
if|if
condition|(
name|keys_timer
operator|<=
name|current_time
condition|)
block|{
name|keys_timer
operator|+=
literal|1
operator|<<
name|sys_automax
expr_stmt|;
name|auth_agekeys
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Garbage collect key list and generate new private value. The 	 * timer runs only after initial synchronization and fires about 	 * once per day. 	 */
if|if
condition|(
name|revoke_timer
operator|<=
name|current_time
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
block|{
name|revoke_timer
operator|+=
literal|1
operator|<<
name|sys_revoke
expr_stmt|;
name|RAND_bytes
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sys_private
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * Interface update timer 	 */
if|if
condition|(
name|interface_interval
operator|&&
name|interface_timer
operator|<=
name|current_time
condition|)
block|{
name|timer_interfacetimeout
argument_list|(
name|current_time
operator|+
name|interface_interval
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"timer: interface update\n"
operator|)
argument_list|)
expr_stmt|;
name|interface_update
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Finally, write hourly stats. 	 */
if|if
condition|(
name|stats_timer
operator|<=
name|current_time
condition|)
block|{
name|stats_timer
operator|+=
name|HOUR
expr_stmt|;
name|write_stats
argument_list|()
expr_stmt|;
if|if
condition|(
name|sys_tai
operator|!=
literal|0
operator|&&
name|sys_time
operator|.
name|l_ui
operator|>
name|leap_expire
condition|)
name|report_event
argument_list|(
name|EVNT_LEAPVAL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_comment
comment|/*  * alarming - tell the world we've been alarmed  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|alarming
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|initializing
condition|)
return|return;
if|if
condition|(
name|alarm_flag
condition|)
name|alarm_overflow
operator|++
expr_stmt|;
else|else
name|alarm_flag
operator|++
expr_stmt|;
else|#
directive|else
comment|/* VMS AST routine */
if|if
condition|(
operator|!
name|initializing
condition|)
block|{
if|if
condition|(
name|alarm_flag
condition|)
name|alarm_overflow
operator|++
expr_stmt|;
else|else
name|alarm_flag
operator|=
literal|1
expr_stmt|;
comment|/* increment is no good */
block|}
name|lib$addx
argument_list|(
operator|&
name|vmsinc
argument_list|,
operator|&
name|vmstimer
argument_list|,
operator|&
name|vmstimer
argument_list|)
expr_stmt|;
name|sys$setimr
argument_list|(
literal|0
argument_list|,
operator|&
name|vmstimer
argument_list|,
name|alarming
argument_list|,
name|alarming
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_function
name|void
name|timer_interfacetimeout
parameter_list|(
name|u_long
name|timeout
parameter_list|)
block|{
name|interface_timer
operator|=
name|timeout
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * timer_clr_stats - clear timer module stat counters  */
end_comment

begin_function
name|void
name|timer_clr_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|timer_overflows
operator|=
literal|0
expr_stmt|;
name|timer_xmtcalls
operator|=
literal|0
expr_stmt|;
name|timer_timereset
operator|=
name|current_time
expr_stmt|;
block|}
end_function

end_unit

