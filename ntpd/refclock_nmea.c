begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_nmea.c - clock driver for an NMEA GPS CLOCK  *		Michael Petry Jun 20, 1994  *		 based on refclock_heathn.c  *  * Updated to add support for Accord GPS Clock  *		Venu Gopal Dec 05, 2007  *		neo.venu@gmail.com, venugopal_d@pgad.gov.in  *  * Updated to process 'time1' fudge factor  *		Venu Gopal May 05, 2008  *  * Converted to common PPSAPI code, separate PPS fudge time1  * from serial timecode fudge time2.  *		Dave Hart July 1, 2009  *		hart@ntp.org, davehart@davehart.com  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_NMEA
argument_list|)
end_if

begin_define
define|#
directive|define
name|NMEA_WRITE_SUPPORT
value|0
end_define

begin_comment
comment|/* no write support at the moment */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"timespecops.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_include
include|#
directive|include
file|"ppsapi_timepps.h"
end_include

begin_include
include|#
directive|include
file|"refclock_atom.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * This driver supports NMEA-compatible GPS receivers  *  * Prototype was refclock_trak.c, Thanks a lot.  *  * The receiver used spits out the NMEA sentences for boat navigation.  * And you thought it was an information superhighway.	Try a raging river  * filled with rapids and whirlpools that rip away your data and warp time.  *  * If HAVE_PPSAPI is defined code to use the PPSAPI will be compiled in.  * On startup if initialization of the PPSAPI fails, it will fall back  * to the "normal" timestamps.  *  * The PPSAPI part of the driver understands fudge flag2 and flag3. If  * flag2 is set, it will use the clear edge of the pulse. If flag3 is  * set, kernel hardpps is enabled.  *  * GPS sentences other than RMC (the default) may be enabled by setting  * the relevent bits of 'mode' in the server configuration line  * server 127.127.20.x mode X  *   * bit 0 - enables RMC (1)  * bit 1 - enables GGA (2)  * bit 2 - enables GLL (4)  * bit 3 - enables ZDA (8) - Standard Time& Date  * bit 3 - enables ZDG (8) - Accord GPS Clock's custom sentence with GPS time   *			     very close to standard ZDA  *   * Multiple sentences may be selected except when ZDG/ZDA is selected.  *  * bit 4/5/6 - selects the baudrate for serial port :  *		0 for 4800 (default)   *		1 for 9600   *		2 for 19200   *		3 for 38400   *		4 for 57600   *		5 for 115200   */
end_comment

begin_define
define|#
directive|define
name|NMEA_MESSAGE_MASK
value|0x0000FF0FU
end_define

begin_define
define|#
directive|define
name|NMEA_BAUDRATE_MASK
value|0x00000070U
end_define

begin_define
define|#
directive|define
name|NMEA_BAUDRATE_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|NMEA_DELAYMEAS_MASK
value|0x80
end_define

begin_define
define|#
directive|define
name|NMEA_EXTLOG_MASK
value|0x00010000U
end_define

begin_define
define|#
directive|define
name|NMEA_DATETRUST_MASK
value|0x02000000U
end_define

begin_define
define|#
directive|define
name|NMEA_PROTO_IDLEN
value|5
end_define

begin_comment
comment|/* tag name must be at least 5 chars */
end_comment

begin_define
define|#
directive|define
name|NMEA_PROTO_MINLEN
value|6
end_define

begin_comment
comment|/* min chars in sentence, excluding CS */
end_comment

begin_define
define|#
directive|define
name|NMEA_PROTO_MAXLEN
value|80
end_define

begin_comment
comment|/* max chars in sentence, excluding CS */
end_comment

begin_define
define|#
directive|define
name|NMEA_PROTO_FIELDS
value|32
end_define

begin_comment
comment|/* not official; limit on fields per record */
end_comment

begin_comment
comment|/*  * We check the timecode format and decode its contents.  We only care  * about a few of them, the most important being the $GPRMC format:  *  * $GPRMC,hhmmss,a,fddmm.xx,n,dddmmm.xx,w,zz.z,yyy.,ddmmyy,dd,v*CC  *  * mode (0,1,2,3) selects sentence ANY/ALL, RMC, GGA, GLL, ZDA  * $GPGLL,3513.8385,S,14900.7851,E,232420.594,A*21  * $GPGGA,232420.59,3513.8385,S,14900.7851,E,1,05,3.4,00519,M,,,,*3F  * $GPRMC,232418.19,A,3513.8386,S,14900.7853,E,00.0,000.0,121199,12.,E*77  *  * Defining GPZDA to support Standard Time& Date  * sentence. The sentence has the following format   *    *  $--ZDA,HHMMSS.SS,DD,MM,YYYY,TH,TM,*CS<CR><LF>  *  *  Apart from the familiar fields,   *  'TH'    Time zone Hours  *  'TM'    Time zone Minutes  *  * Defining GPZDG to support Accord GPS Clock's custom NMEA   * sentence. The sentence has the following format   *    *  $GPZDG,HHMMSS.S,DD,MM,YYYY,AA.BB,V*CS<CR><LF>  *  *  It contains the GPS timestamp valid for next PPS pulse.  *  Apart from the familiar fields,   *  'AA.BB' denotes the signal strength( should be< 05.00 )   *  'V'	    denotes the GPS sync status :   *	   '0' indicates INVALID time,   *	   '1' indicates accuracy of +/-20 ms  *	   '2' indicates accuracy of +/-100 ns  *  * Defining PGRMF for Garmin GPS Fix Data  * $PGRMF,WN,WS,DATE,TIME,LS,LAT,LAT_DIR,LON,LON_DIR,MODE,FIX,SPD,DIR,PDOP,TDOP  * WN  -- GPS week number (weeks since 1980-01-06, mod 1024)  * WS  -- GPS seconds in week  * LS  -- GPS leap seconds, accumulated ( UTC + LS == GPS )  * FIX -- Fix type: 0=nofix, 1=2D, 2=3D  * DATE/TIME are standard date/time strings in UTC time scale  *  * The GPS time can be used to get the full century for the truncated  * date spec.  */
end_comment

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/gps%d"
end_define

begin_comment
comment|/* GPS serial device */
end_comment

begin_define
define|#
directive|define
name|PPSDEV
value|"/dev/gpspps%d"
end_define

begin_comment
comment|/* PPSAPI device override */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B4800
end_define

begin_comment
comment|/* uart speed (4800 bps) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-9)
end_define

begin_comment
comment|/* precision assumed (about 2 ms) */
end_comment

begin_define
define|#
directive|define
name|PPS_PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"GPS\0"
end_define

begin_comment
comment|/* reference id */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"NMEA GPS Clock"
end_define

begin_comment
comment|/* who we are */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|M_NOCTTY
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NOCTTY
value|O_NOCTTY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_define
define|#
directive|define
name|M_NONBLOCK
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NONBLOCK
value|O_NONBLOCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PPSOPENMODE
value|(O_RDWR | M_NOCTTY | M_NONBLOCK)
end_define

begin_comment
comment|/* NMEA sentence array indexes for those we use */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPRMC
value|0
end_define

begin_comment
comment|/* recommended min. nav. */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPGGA
value|1
end_define

begin_comment
comment|/* fix and quality */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPGLL
value|2
end_define

begin_comment
comment|/* geo. lat/long */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPZDA
value|3
end_define

begin_comment
comment|/* date/time */
end_comment

begin_comment
comment|/*  * $GPZDG is a proprietary sentence that violates the spec, by not  * using $P and an assigned company identifier to prefix the sentence  * identifier.	When used with this driver, the system needs to be  * isolated from other NTP networks, as it operates in GPS time, not  * UTC as is much more common.	GPS time is>15 seconds different from  * UTC due to not respecting leap seconds since 1970 or so.  Other  * than the different timebase, $GPZDG is similar to $GPZDA.  */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPZDG
value|4
end_define

begin_define
define|#
directive|define
name|NMEA_PGRMF
value|5
end_define

begin_define
define|#
directive|define
name|NMEA_ARRAY_SIZE
value|(NMEA_PGRMF + 1)
end_define

begin_comment
comment|/*  * Sentence selection mode bits  */
end_comment

begin_define
define|#
directive|define
name|USE_GPRMC
value|0x00000001u
end_define

begin_define
define|#
directive|define
name|USE_GPGGA
value|0x00000002u
end_define

begin_define
define|#
directive|define
name|USE_GPGLL
value|0x00000004u
end_define

begin_define
define|#
directive|define
name|USE_GPZDA
value|0x00000008u
end_define

begin_define
define|#
directive|define
name|USE_PGRMF
value|0x00000100u
end_define

begin_comment
comment|/* mapping from sentence index to controlling mode bit */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int32
name|sentence_mode
index|[
name|NMEA_ARRAY_SIZE
index|]
init|=
block|{
name|USE_GPRMC
block|,
name|USE_GPGGA
block|,
name|USE_GPGLL
block|,
name|USE_GPZDA
block|,
name|USE_GPZDA
block|,
name|USE_PGRMF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* date formats we support */
end_comment

begin_enum
enum|enum
name|date_fmt
block|{
name|DATE_1_DDMMYY
block|,
comment|/* use 1 field	with 2-digit year */
name|DATE_3_DDMMYYYY
comment|/* use 3 fields with 4-digit year */
block|}
enum|;
end_enum

begin_comment
comment|/* results for 'field_init()'  *  * Note: If a checksum is present, the checksum test must pass OK or the  * sentence is tagged invalid.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_EMPTY
value|-1
end_define

begin_comment
comment|/* no data			*/
end_comment

begin_define
define|#
directive|define
name|CHECK_INVALID
value|0
end_define

begin_comment
comment|/* not a valid NMEA sentence	*/
end_comment

begin_define
define|#
directive|define
name|CHECK_VALID
value|1
end_define

begin_comment
comment|/* valid but without checksum	*/
end_comment

begin_define
define|#
directive|define
name|CHECK_CSVALID
value|2
end_define

begin_comment
comment|/* valid with checksum OK	*/
end_comment

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|struct
name|refclock_atom
name|atom
decl_stmt|;
comment|/* PPSAPI structure */
name|int
name|ppsapi_fd
decl_stmt|;
comment|/* fd used with PPSAPI */
name|u_char
name|ppsapi_tried
decl_stmt|;
comment|/* attempt PPSAPI once */
name|u_char
name|ppsapi_lit
decl_stmt|;
comment|/* time_pps_create() worked */
name|u_char
name|ppsapi_gate
decl_stmt|;
comment|/* system is on PPS */
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
name|u_char
name|gps_time
decl_stmt|;
comment|/* use GPS time, not UTC */
name|u_short
name|century_cache
decl_stmt|;
comment|/* cached current century */
name|l_fp
name|last_reftime
decl_stmt|;
comment|/* last processed reference stamp */
name|short
name|epoch_warp
decl_stmt|;
comment|/* last epoch warp, for logging */
comment|/* tally stats, reset each poll cycle */
struct|struct
block|{
name|u_int
name|total
decl_stmt|;
name|u_int
name|accepted
decl_stmt|;
name|u_int
name|rejected
decl_stmt|;
comment|/* GPS said not enough signal */
name|u_int
name|malformed
decl_stmt|;
comment|/* Bad checksum, invalid date or time */
name|u_int
name|filtered
decl_stmt|;
comment|/* mode bits, not GPZDG, same second */
name|u_int
name|pps_used
decl_stmt|;
block|}
name|tally
struct|;
comment|/* per sentence checksum seen flag */
name|u_char
name|cksum_type
index|[
name|NMEA_ARRAY_SIZE
index|]
decl_stmt|;
block|}
name|nmea_unit
typedef|;
end_typedef

begin_comment
comment|/*  * helper for faster field access  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|base
decl_stmt|;
comment|/* buffer base		*/
name|char
modifier|*
name|cptr
decl_stmt|;
comment|/* current field ptr	*/
name|int
name|blen
decl_stmt|;
comment|/* buffer length	*/
name|int
name|cidx
decl_stmt|;
comment|/* current field index	*/
block|}
name|nmea_data
typedef|;
end_typedef

begin_comment
comment|/*  * NMEA gps week/time information  * This record contains the number of weeks since 1980-01-06 modulo  * 1024, the seconds elapsed since start of the week, and the number of  * leap seconds that are the difference between GPS and UTC time scale.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int32
name|wt_time
decl_stmt|;
comment|/* seconds since weekstart */
name|u_short
name|wt_week
decl_stmt|;
comment|/* week number */
name|short
name|wt_leap
decl_stmt|;
comment|/* leap seconds */
block|}
name|gps_weektm
typedef|;
end_typedef

begin_comment
comment|/*  * The GPS week time scale starts on Sunday, 1980-01-06. We need the  * rata die number of this day.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DAY_GPS_STARTS
end_ifndef

begin_define
define|#
directive|define
name|DAY_GPS_STARTS
value|722820
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|nmea_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nmea_start
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nmea_shutdown
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nmea_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nmea_poll
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_function_decl
specifier|static
name|void
name|nmea_control
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|refclockstat
modifier|*
parameter_list|,
name|struct
name|refclockstat
modifier|*
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NMEA_CONTROL
value|nmea_control
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NMEA_CONTROL
value|noentry
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_function_decl
specifier|static
name|void
name|nmea_timer
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* parsing helpers */
end_comment

begin_function_decl
specifier|static
name|int
name|field_init
parameter_list|(
name|nmea_data
modifier|*
name|data
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|field_parse
parameter_list|(
name|nmea_data
modifier|*
name|data
parameter_list|,
name|int
name|fn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|field_wipe
parameter_list|(
name|nmea_data
modifier|*
name|data
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
name|parse_qual
parameter_list|(
name|nmea_data
modifier|*
name|data
parameter_list|,
name|int
name|idx
parameter_list|,
name|char
name|tag
parameter_list|,
name|int
name|inv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_time
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|long
modifier|*
name|nsec
parameter_list|,
name|nmea_data
modifier|*
parameter_list|,
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|nmea_data
modifier|*
parameter_list|,
name|int
name|idx
parameter_list|,
name|enum
name|date_fmt
name|fmt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_weekdata
parameter_list|(
name|gps_weektm
modifier|*
parameter_list|,
name|nmea_data
modifier|*
parameter_list|,
name|int
name|weekidx
parameter_list|,
name|int
name|timeidx
parameter_list|,
name|int
name|leapidx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* calendar / date helpers */
end_comment

begin_function_decl
specifier|static
name|int
name|unfold_day
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|u_int32
name|rec_ui
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unfold_century
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|u_int32
name|rec_ui
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gpsfix_century
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
specifier|const
name|gps_weektm
modifier|*
name|wd
parameter_list|,
name|u_short
modifier|*
name|ccentury
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|l_fp
name|eval_gps_time
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
specifier|const
name|struct
name|calendar
modifier|*
name|gpst
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|gpso
parameter_list|,
specifier|const
name|l_fp
modifier|*
name|xrecv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nmead_open
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_ltc
parameter_list|(
name|struct
name|refclockproc
modifier|*
specifier|const
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * If we want the driver to ouput sentences, too: re-enable the send  * support functions by defining NMEA_WRITE_SUPPORT to non-zero...  */
end_comment

begin_if
if|#
directive|if
name|NMEA_WRITE_SUPPORT
end_if

begin_function_decl
specifier|static
name|void
name|gps_send
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_comment
comment|/* ports/winnt/include/config.h: #define write _write */
end_comment

begin_function_decl
specifier|extern
name|int
name|async_write
parameter_list|(
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|write
parameter_list|(
name|fd
parameter_list|,
name|data
parameter_list|,
name|octets
parameter_list|)
value|async_write(fd, data, octets)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NMEA_WRITE_SUPPORT */
end_comment

begin_decl_stmt
specifier|static
name|int32_t
name|g_gpsMinBase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|g_gpsMinYear
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * -------------------------------------------------------------------  * Transfer vector  * -------------------------------------------------------------------  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_nmea
init|=
block|{
name|nmea_start
block|,
comment|/* start up driver */
name|nmea_shutdown
block|,
comment|/* shut down driver */
name|nmea_poll
block|,
comment|/* transmit poll message */
name|NMEA_CONTROL
block|,
comment|/* fudge control */
name|nmea_init
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* buginfo */
name|nmea_timer
comment|/* called once per second */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * -------------------------------------------------------------------  * nmea_init - initialise data  *  * calculates a few runtime constants that cannot be made compile time  * constants.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|nmea_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|calendar
name|date
decl_stmt|;
comment|/* - calculate min. base value for GPS epoch& century unfolding  	 * This assumes that the build system was roughly in sync with 	 * the world, and that really synchronising to a time before the 	 * program was created would be unsafe or insane. If the build 	 * date cannot be stablished, at least use the start of GPS 	 * (1980-01-06) as minimum, because GPS can surely NOT 	 * synchronise beyond it's own big bang. We add a little safety 	 * margin for the fuzziness of the build date, which is in an 	 * undefined time zone. */
if|if
condition|(
name|ntpcal_get_build_date
argument_list|(
operator|&
name|date
argument_list|)
condition|)
name|g_gpsMinBase
operator|=
name|ntpcal_date_to_rd
argument_list|(
operator|&
name|date
argument_list|)
operator|-
literal|2
expr_stmt|;
else|else
name|g_gpsMinBase
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g_gpsMinBase
operator|<
name|DAY_GPS_STARTS
condition|)
name|g_gpsMinBase
operator|=
name|DAY_GPS_STARTS
expr_stmt|;
name|ntpcal_rd_to_date
argument_list|(
operator|&
name|date
argument_list|,
name|g_gpsMinBase
argument_list|)
expr_stmt|;
name|g_gpsMinYear
operator|=
name|date
operator|.
name|year
expr_stmt|;
name|g_gpsMinBase
operator|-=
name|DAY_NTP_STARTS
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * nmea_start - open the GPS devices and initialize data for processing  *  * return 0 on error, 1 on success. Even on error the peer structures  * must be in a state that permits 'nmea_shutdown()' to clean up all  * resources, because it will be called immediately to do so.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|nmea_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|nmea_unit
modifier|*
specifier|const
name|up
init|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
name|size_t
name|devlen
decl_stmt|;
name|u_int32
name|rate
decl_stmt|;
name|int
name|baudrate
decl_stmt|;
specifier|const
name|char
modifier|*
name|baudtext
decl_stmt|;
comment|/* Get baudrate choice from mode byte bits 4/5/6 */
name|rate
operator|=
operator|(
name|peer
operator|->
name|ttl
operator|&
name|NMEA_BAUDRATE_MASK
operator|)
operator|>>
name|NMEA_BAUDRATE_SHIFT
expr_stmt|;
switch|switch
condition|(
name|rate
condition|)
block|{
case|case
literal|0
case|:
name|baudrate
operator|=
name|SPEED232
expr_stmt|;
name|baudtext
operator|=
literal|"4800"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|baudrate
operator|=
name|B9600
expr_stmt|;
name|baudtext
operator|=
literal|"9600"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|baudrate
operator|=
name|B19200
expr_stmt|;
name|baudtext
operator|=
literal|"19200"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|baudrate
operator|=
name|B38400
expr_stmt|;
name|baudtext
operator|=
literal|"38400"
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|B57600
case|case
literal|4
case|:
name|baudrate
operator|=
name|B57600
expr_stmt|;
name|baudtext
operator|=
literal|"57600"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
case|case
literal|5
case|:
name|baudrate
operator|=
name|B115200
expr_stmt|;
name|baudtext
operator|=
literal|"115200"
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|baudrate
operator|=
name|SPEED232
expr_stmt|;
name|baudtext
operator|=
literal|"4800 (fallback)"
expr_stmt|;
break|break;
block|}
comment|/* Allocate and initialize unit structure */
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|nmea_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
comment|/* force change detection on first valid message */
name|memset
argument_list|(
operator|&
name|up
operator|->
name|last_reftime
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|last_reftime
argument_list|)
argument_list|)
expr_stmt|;
comment|/* force checksum on GPRMC, see below */
name|up
operator|->
name|cksum_type
index|[
name|NMEA_GPRMC
index|]
operator|=
name|CHECK_CSVALID
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|up
operator|->
name|ppsapi_fd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|ZERO
argument_list|(
name|up
operator|->
name|tally
argument_list|)
expr_stmt|;
comment|/* Initialize miscellaneous variables */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Open serial port. Use CLK line discipline, if available. */
name|devlen
operator|=
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|devlen
operator|>=
sizeof|sizeof
argument_list|(
name|device
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s clock device name too long"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* buffer overflow */
block|}
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|baudrate
argument_list|,
name|LDISC_CLK
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
block|{
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|nmead_open
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
return|return
name|FALSE
return|;
block|}
name|LOGIF
argument_list|(
name|CLOCKINFO
argument_list|,
operator|(
name|LOG_NOTICE
operator|,
literal|"%s serial %s open at %s bps"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|device
operator|,
name|baudtext
operator|)
argument_list|)
expr_stmt|;
comment|/* succeed if this clock can be added */
return|return
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * nmea_shutdown - shut down a GPS clock  *   * NOTE this routine is called after nmea_start() returns failure,  * as well as during a normal shutdown due to ntpq :config unpeer.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|nmea_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|nmea_unit
modifier|*
specifier|const
name|up
init|=
operator|(
name|nmea_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
if|if
condition|(
name|up
operator|->
name|ppsapi_lit
condition|)
name|time_pps_destroy
argument_list|(
name|up
operator|->
name|atom
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ppsapi_tried
operator|&&
name|up
operator|->
name|ppsapi_fd
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|close
argument_list|(
name|up
operator|->
name|ppsapi_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * nmea_control - configure fudge params  * -------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_function
specifier|static
name|void
name|nmea_control
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|const
name|struct
name|refclockstat
modifier|*
name|in_st
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out_st
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|nmea_unit
modifier|*
specifier|const
name|up
init|=
operator|(
name|nmea_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|char
name|device
index|[
literal|32
index|]
decl_stmt|;
name|size_t
name|devlen
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|in_st
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|out_st
argument_list|)
expr_stmt|;
comment|/* 	 * PPS control 	 * 	 * If /dev/gpspps$UNIT can be opened that will be used for 	 * PPSAPI.  Otherwise, the GPS serial device /dev/gps$UNIT 	 * already opened is used for PPSAPI as well. (This might not 	 * work, in which case the PPS API remains unavailable...) 	 */
comment|/* Light up the PPSAPI interface if not yet attempted. */
if|if
condition|(
operator|(
name|CLK_FLAG1
operator|&
name|pp
operator|->
name|sloppyclockflag
operator|)
operator|&&
operator|!
name|up
operator|->
name|ppsapi_tried
condition|)
block|{
name|up
operator|->
name|ppsapi_tried
operator|=
name|TRUE
expr_stmt|;
name|devlen
operator|=
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
name|PPSDEV
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|devlen
operator|<
sizeof|sizeof
argument_list|(
name|device
argument_list|)
condition|)
block|{
name|up
operator|->
name|ppsapi_fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|PPSOPENMODE
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|ppsapi_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s PPS device name too long"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|up
operator|->
name|ppsapi_fd
condition|)
name|up
operator|->
name|ppsapi_fd
operator|=
name|pp
operator|->
name|io
operator|.
name|fd
expr_stmt|;
if|if
condition|(
name|refclock_ppsapi
argument_list|(
name|up
operator|->
name|ppsapi_fd
argument_list|,
operator|&
name|up
operator|->
name|atom
argument_list|)
condition|)
block|{
comment|/* use the PPS API for our own purposes now. */
name|up
operator|->
name|ppsapi_lit
operator|=
name|refclock_params
argument_list|(
name|pp
operator|->
name|sloppyclockflag
argument_list|,
operator|&
name|up
operator|->
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|up
operator|->
name|ppsapi_lit
condition|)
block|{
comment|/* failed to configure, drop PPS unit */
name|time_pps_destroy
argument_list|(
name|up
operator|->
name|atom
operator|.
name|handle
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s set PPSAPI params fails"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* note: the PPS I/O handle remains valid until 			 * flag1 is cleared or the clock is shut down.  			 */
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s flag1 1 but PPSAPI fails"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* shut down PPS API if activated */
if|if
condition|(
operator|!
operator|(
name|CLK_FLAG1
operator|&
name|pp
operator|->
name|sloppyclockflag
operator|)
operator|&&
name|up
operator|->
name|ppsapi_tried
condition|)
block|{
comment|/* shutdown PPS API */
if|if
condition|(
name|up
operator|->
name|ppsapi_lit
condition|)
name|time_pps_destroy
argument_list|(
name|up
operator|->
name|atom
operator|.
name|handle
argument_list|)
expr_stmt|;
name|up
operator|->
name|atom
operator|.
name|handle
operator|=
literal|0
expr_stmt|;
comment|/* close/drop PPS fd */
if|if
condition|(
name|up
operator|->
name|ppsapi_fd
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|close
argument_list|(
name|up
operator|->
name|ppsapi_fd
argument_list|)
expr_stmt|;
name|up
operator|->
name|ppsapi_fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* clear markers and peer items */
name|up
operator|->
name|ppsapi_gate
operator|=
name|FALSE
expr_stmt|;
name|up
operator|->
name|ppsapi_lit
operator|=
name|FALSE
expr_stmt|;
name|up
operator|->
name|ppsapi_tried
operator|=
name|FALSE
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * -------------------------------------------------------------------  * nmea_timer - called once per second  *		this only polls (older?) Oncore devices now  *  * Usually 'nmea_receive()' can get a timestamp every second, but at  * least one Motorola unit needs prompting each time. Doing so in  * 'nmea_poll()' gives only one sample per poll cycle, which actually  * defeats the purpose of the median filter. Polling once per second  * seems a much better idea.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|nmea_timer
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
if|#
directive|if
name|NMEA_WRITE_SUPPORT
name|struct
name|refclockproc
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
comment|/* any mode bits to evaluate here? */
name|gps_send
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"$PMOTG,RMC,0000*1D\r\n"
argument_list|,
name|peer
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED_ARG
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|peer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NMEA_WRITE_SUPPORT */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_comment
comment|/*  * -------------------------------------------------------------------  * refclock_ppsrelate(...) -- correlate with PPS edge  *  * This function is used to correlate a receive time stamp and a  * reference time with a PPS edge time stamp. It applies the necessary  * fudges (fudge1 for PPS, fudge2 for receive time) and then tries to  * move the receive time stamp to the corresponding edge. This can warp  * into future, if a transmission delay of more than 500ms is not  * compensated with a corresponding fudge time2 value, because then the  * next PPS edge is nearer than the last. (Similiar to what the PPS ATOM  * driver does, but we deal with full time stamps here, not just phase  * shift information.) Likewise, a negative fudge time2 value must be  * used if the reference time stamp correlates with the *following* PPS  * pulse.  *  * Note that the receive time fudge value only needs to move the receive  * stamp near a PPS edge but that close proximity is not required;  * +/-100ms precision should be enough. But since the fudge value will  * probably also be used to compensate the transmission delay when no  * PPS edge can be related to the time stamp, it's best to get it as  * close as possible.  *  * It should also be noted that the typical use case is matching to the  * preceeding edge, as most units relate their sentences to the current  * second.  *  * The function returns PPS_RELATE_NONE (0) if no PPS edge correlation  * can be fixed; PPS_RELATE_EDGE (1) when a PPS edge could be fixed, but  * the distance to the reference time stamp is too big (exceeds  * +/-400ms) and the ATOM driver PLL cannot be used to fix the phase;  * and PPS_RELATE_PHASE (2) when the ATOM driver PLL code can be used.  *  * On output, the receive time stamp is replaced with the corresponding  * PPS edge time if a fix could be made; the PPS fudge is updated to  * reflect the proper fudge time to apply. (This implies that  * 'refclock_process_offset()' must be used!)  * -------------------------------------------------------------------  */
end_comment

begin_define
define|#
directive|define
name|PPS_RELATE_NONE
value|0
end_define

begin_comment
comment|/* no pps correlation possible	  */
end_comment

begin_define
define|#
directive|define
name|PPS_RELATE_EDGE
value|1
end_define

begin_comment
comment|/* recv time fixed, no phase lock */
end_comment

begin_define
define|#
directive|define
name|PPS_RELATE_PHASE
value|2
end_define

begin_comment
comment|/* recv time fixed, phase lock ok */
end_comment

begin_function
specifier|static
name|int
name|refclock_ppsrelate
parameter_list|(
specifier|const
name|struct
name|refclockproc
modifier|*
name|pp
parameter_list|,
comment|/* for sanity	  */
specifier|const
name|struct
name|refclock_atom
modifier|*
name|ap
parameter_list|,
comment|/* for PPS io	  */
specifier|const
name|l_fp
modifier|*
name|reftime
parameter_list|,
name|l_fp
modifier|*
name|rd_stamp
parameter_list|,
comment|/* i/o read stamp */
name|double
name|pp_fudge
parameter_list|,
comment|/* pps fudge	  */
name|double
modifier|*
name|rd_fudge
comment|/* i/o read fudge */
parameter_list|)
block|{
name|pps_info_t
name|pps_info
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|l_fp
name|pp_stamp
decl_stmt|,
name|pp_delta
decl_stmt|;
name|double
name|delta
decl_stmt|,
name|idelta
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
return|return
name|PPS_RELATE_NONE
return|;
comment|/* clock is insane, no chance */
name|ZERO
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|pps_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|ap
operator|->
name|handle
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|pps_info
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
return|return
name|PPS_RELATE_NONE
return|;
comment|/* can't get time stamps */
comment|/* get last active PPS edge before receive */
if|if
condition|(
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTUREASSERT
condition|)
name|timeout
operator|=
name|pps_info
operator|.
name|assert_timestamp
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTURECLEAR
condition|)
name|timeout
operator|=
name|pps_info
operator|.
name|clear_timestamp
expr_stmt|;
else|else
return|return
name|PPS_RELATE_NONE
return|;
comment|/* WHICH edge, please?!? */
comment|/* get delta between receive time and PPS time */
name|pp_stamp
operator|=
name|tspec_stamp_to_lfp
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|pp_delta
operator|=
operator|*
name|rd_stamp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|pp_delta
argument_list|,
operator|&
name|pp_stamp
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|pp_delta
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|+=
name|pp_fudge
operator|-
operator|*
name|rd_fudge
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|delta
argument_list|)
operator|>
literal|1.5
condition|)
return|return
name|PPS_RELATE_NONE
return|;
comment|/* PPS timeout control */
comment|/* eventually warp edges, check phase */
name|idelta
operator|=
name|floor
argument_list|(
name|delta
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|pp_fudge
operator|-=
name|idelta
expr_stmt|;
name|delta
operator|-=
name|idelta
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|delta
argument_list|)
operator|>
literal|0.45
condition|)
return|return
name|PPS_RELATE_NONE
return|;
comment|/* dead band control */
comment|/* we actually have a PPS edge to relate with! */
operator|*
name|rd_stamp
operator|=
name|pp_stamp
expr_stmt|;
operator|*
name|rd_fudge
operator|=
name|pp_fudge
expr_stmt|;
comment|/* if whole system out-of-sync, do not try to PLL */
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
condition|)
return|return
name|PPS_RELATE_EDGE
return|;
comment|/* cannot PLL with atom code */
comment|/* check against reftime if ATOM PLL can be used */
name|pp_delta
operator|=
operator|*
name|reftime
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|pp_delta
argument_list|,
operator|&
name|pp_stamp
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|pp_delta
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|+=
name|pp_fudge
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|delta
argument_list|)
operator|>
literal|0.45
condition|)
return|return
name|PPS_RELATE_EDGE
return|;
comment|/* cannot PLL with atom code */
comment|/* all checks passed, gets an AAA rating here! */
return|return
name|PPS_RELATE_PHASE
return|;
comment|/* can PLL with atom code */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * -------------------------------------------------------------------  * nmea_receive - receive data from the serial interface  *  * This is the workhorse for NMEA data evaluation:  *  * + it checks all NMEA data, and rejects sentences that are not valid  *   NMEA sentences  * + it checks whether a sentence is known and to be used  * + it parses the time and date data from the NMEA data string and  *   augments the missing bits. (century in dat, whole date, ...)  * + it rejects data that is not from the first accepted sentence in a  *   burst  * + it eventually replaces the receive time with the PPS edge time.  * + it feeds the data to the internal processing stages.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|nmea_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
comment|/* declare& init control structure ptrs */
name|struct
name|peer
modifier|*
specifier|const
name|peer
init|=
name|rbufp
operator|->
name|recv_peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|nmea_unit
modifier|*
specifier|const
name|up
init|=
operator|(
name|nmea_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
comment|/* Use these variables to hold data until we decide its worth keeping */
name|nmea_data
name|rdata
decl_stmt|;
name|char
name|rd_lastcode
index|[
name|BMAX
index|]
decl_stmt|;
name|l_fp
name|rd_timestamp
decl_stmt|,
name|rd_reftime
decl_stmt|;
name|int
name|rd_lencode
decl_stmt|;
name|double
name|rd_fudge
decl_stmt|;
comment|/* working stuff */
name|struct
name|calendar
name|date
decl_stmt|;
comment|/* to keep& convert the time stamp */
name|struct
name|timespec
name|tofs
decl_stmt|;
comment|/* offset to full-second reftime */
name|gps_weektm
name|gpsw
decl_stmt|;
comment|/* week time storage */
comment|/* results of sentence/date/time parsing */
name|u_char
name|sentence
decl_stmt|;
comment|/* sentence tag */
name|int
name|checkres
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|rc_date
decl_stmt|;
name|int
name|rc_time
decl_stmt|;
comment|/* make sure data has defined pristine state */
name|ZERO
argument_list|(
name|tofs
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|gpsw
argument_list|)
expr_stmt|;
name|sentence
operator|=
literal|0
expr_stmt|;
name|rc_date
operator|=
literal|0
expr_stmt|;
name|rc_time
operator|=
literal|0
expr_stmt|;
comment|/*  	 * Read the timecode and timestamp, then initialise field 	 * processing. The<CR><LF> at the NMEA line end is translated 	 * to<LF><LF> by the terminal input routines on most systems, 	 * and this gives us one spurious empty read per record which we 	 * better ignore silently. 	 */
name|rd_lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|rd_lastcode
argument_list|,
sizeof|sizeof
argument_list|(
name|rd_lastcode
argument_list|)
argument_list|,
operator|&
name|rd_timestamp
argument_list|)
expr_stmt|;
name|checkres
operator|=
name|field_init
argument_list|(
operator|&
name|rdata
argument_list|,
name|rd_lastcode
argument_list|,
name|rd_lencode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|checkres
condition|)
block|{
case|case
name|CHECK_INVALID
case|:
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s invalid data: '%s'\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|rd_lastcode
operator|)
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHECK_EMPTY
case|:
return|return;
default|default:
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s gpsread: %d '%s'\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|rd_lencode
operator|,
name|rd_lastcode
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|up
operator|->
name|tally
operator|.
name|total
operator|++
expr_stmt|;
comment|/*  	 * --> below this point we have a valid NMEA sentence<-- 	 * 	 * Check sentence name. Skip first 2 chars (talker ID) in most 	 * cases, to allow for $GLGGA and $GPGGA etc. Since the name 	 * field has at least 5 chars we can simply shift the field 	 * start. 	 */
name|cp
operator|=
name|field_parse
argument_list|(
operator|&
name|rdata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
literal|"RMC,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPRMC
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
literal|"GGA,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPGGA
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
literal|"GLL,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPGLL
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
literal|"ZDA,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPZDA
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
literal|"ZDG,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPZDG
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"PGRMF,"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_PGRMF
expr_stmt|;
else|else
return|return;
comment|/* not something we know about */
comment|/* Eventually output delay measurement now. */
if|if
condition|(
name|peer
operator|->
name|ttl
operator|&
name|NMEA_DELAYMEAS_MASK
condition|)
block|{
name|mprintf_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
literal|"delay %0.6f %.*s"
argument_list|,
name|ldexp
argument_list|(
name|rd_timestamp
operator|.
name|l_uf
argument_list|,
operator|-
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|strchr
argument_list|(
name|rd_lastcode
argument_list|,
literal|','
argument_list|)
operator|-
name|rd_lastcode
argument_list|)
argument_list|,
name|rd_lastcode
argument_list|)
expr_stmt|;
block|}
comment|/* See if I want to process this message type */
if|if
condition|(
operator|(
name|peer
operator|->
name|ttl
operator|&
name|NMEA_MESSAGE_MASK
operator|)
operator|&&
operator|!
operator|(
name|peer
operator|->
name|ttl
operator|&
name|sentence_mode
index|[
name|sentence
index|]
operator|)
condition|)
block|{
name|up
operator|->
name|tally
operator|.
name|filtered
operator|++
expr_stmt|;
return|return;
block|}
comment|/*  	 * make sure it came in clean 	 * 	 * Apparently, older NMEA specifications (which are expensive) 	 * did not require the checksum for all sentences.  $GPMRC is 	 * the only one so far identified which has always been required 	 * to include a checksum. 	 * 	 * Today, most NMEA GPS receivers checksum every sentence.  To 	 * preserve its error-detection capabilities with modern GPSes 	 * while allowing operation without checksums on all but $GPMRC, 	 * we keep track of whether we've ever seen a valid checksum on 	 * a given sentence, and if so, reject future instances without 	 * checksum.  ('up->cksum_type[NMEA_GPRMC]' is set in 	 * 'nmea_start()' to enforce checksums for $GPRMC right from the 	 * start.) 	 */
if|if
condition|(
name|up
operator|->
name|cksum_type
index|[
name|sentence
index|]
operator|<=
operator|(
name|u_char
operator|)
name|checkres
condition|)
block|{
name|up
operator|->
name|cksum_type
index|[
name|sentence
index|]
operator|=
operator|(
name|u_char
operator|)
name|checkres
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s checksum missing: '%s'\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|rd_lastcode
operator|)
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|up
operator|->
name|tally
operator|.
name|malformed
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * $GPZDG provides GPS time not UTC, and the two mix poorly. 	 * Once have processed a $GPZDG, do not process any further UTC 	 * sentences (all but $GPZDG currently). 	 */
if|if
condition|(
name|up
operator|->
name|gps_time
operator|&&
name|NMEA_GPZDG
operator|!=
name|sentence
condition|)
block|{
name|up
operator|->
name|tally
operator|.
name|filtered
operator|++
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s processing %d bytes, timecode '%s'\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|rd_lencode
operator|,
name|rd_lastcode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Grab fields depending on clock string type and possibly wipe 	 * sensitive data from the last timecode. 	 */
switch|switch
condition|(
name|sentence
condition|)
block|{
case|case
name|NMEA_GPRMC
case|:
comment|/* Check quality byte, fetch data& time */
name|rc_time
operator|=
name|parse_time
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|tofs
operator|.
name|tv_nsec
argument_list|,
operator|&
name|rdata
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|parse_qual
argument_list|(
operator|&
name|rdata
argument_list|,
literal|2
argument_list|,
literal|'A'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc_date
operator|=
name|parse_date
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|rdata
argument_list|,
literal|9
argument_list|,
name|DATE_1_DDMMYY
argument_list|)
operator|&&
name|unfold_century
argument_list|(
operator|&
name|date
argument_list|,
name|rd_timestamp
operator|.
name|l_ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLK_FLAG4
operator|&
name|pp
operator|->
name|sloppyclockflag
condition|)
name|field_wipe
argument_list|(
operator|&
name|rdata
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPGGA
case|:
comment|/* Check quality byte, fetch time only */
name|rc_time
operator|=
name|parse_time
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|tofs
operator|.
name|tv_nsec
argument_list|,
operator|&
name|rdata
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|parse_qual
argument_list|(
operator|&
name|rdata
argument_list|,
literal|6
argument_list|,
literal|'0'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc_date
operator|=
name|unfold_day
argument_list|(
operator|&
name|date
argument_list|,
name|rd_timestamp
operator|.
name|l_ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLK_FLAG4
operator|&
name|pp
operator|->
name|sloppyclockflag
condition|)
name|field_wipe
argument_list|(
operator|&
name|rdata
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPGLL
case|:
comment|/* Check quality byte, fetch time only */
name|rc_time
operator|=
name|parse_time
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|tofs
operator|.
name|tv_nsec
argument_list|,
operator|&
name|rdata
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|parse_qual
argument_list|(
operator|&
name|rdata
argument_list|,
literal|6
argument_list|,
literal|'A'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc_date
operator|=
name|unfold_day
argument_list|(
operator|&
name|date
argument_list|,
name|rd_timestamp
operator|.
name|l_ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLK_FLAG4
operator|&
name|pp
operator|->
name|sloppyclockflag
condition|)
name|field_wipe
argument_list|(
operator|&
name|rdata
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPZDA
case|:
comment|/* No quality.	Assume best, fetch time& full date */
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|rc_time
operator|=
name|parse_time
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|tofs
operator|.
name|tv_nsec
argument_list|,
operator|&
name|rdata
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc_date
operator|=
name|parse_date
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|rdata
argument_list|,
literal|2
argument_list|,
name|DATE_3_DDMMYYYY
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPZDG
case|:
comment|/* Check quality byte, fetch time& full date */
name|rc_time
operator|=
name|parse_time
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|tofs
operator|.
name|tv_nsec
argument_list|,
operator|&
name|rdata
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc_date
operator|=
name|parse_date
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|rdata
argument_list|,
literal|2
argument_list|,
name|DATE_3_DDMMYYYY
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|parse_qual
argument_list|(
operator|&
name|rdata
argument_list|,
literal|4
argument_list|,
literal|'0'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tofs
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* GPZDG is following second */
break|break;
case|case
name|NMEA_PGRMF
case|:
comment|/* get date, time, qualifier and GPS weektime. We need 		 * date and time-of-day for the century fix, so we read 		 * them first. 		 */
name|rc_date
operator|=
name|parse_weekdata
argument_list|(
operator|&
name|gpsw
argument_list|,
operator|&
name|rdata
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|)
operator|&&
name|parse_date
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|rdata
argument_list|,
literal|3
argument_list|,
name|DATE_1_DDMMYY
argument_list|)
expr_stmt|;
name|rc_time
operator|=
name|parse_time
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|tofs
operator|.
name|tv_nsec
argument_list|,
operator|&
name|rdata
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|parse_qual
argument_list|(
operator|&
name|rdata
argument_list|,
literal|11
argument_list|,
literal|'0'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc_date
operator|=
name|rc_date
operator|&&
name|gpsfix_century
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|gpsw
argument_list|,
operator|&
name|up
operator|->
name|century_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLK_FLAG4
operator|&
name|pp
operator|->
name|sloppyclockflag
condition|)
name|field_wipe
argument_list|(
operator|&
name|rdata
argument_list|,
literal|6
argument_list|,
literal|8
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INVARIANT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Coverity 97123 */
return|return;
block|}
comment|/* Check sanity of time-of-day. */
if|if
condition|(
name|rc_time
operator|==
literal|0
condition|)
block|{
comment|/* no time or conversion error? */
name|checkres
operator|=
name|CEVNT_BADTIME
expr_stmt|;
name|up
operator|->
name|tally
operator|.
name|malformed
operator|++
expr_stmt|;
block|}
comment|/* Check sanity of date. */
elseif|else
if|if
condition|(
name|rc_date
operator|==
literal|0
condition|)
block|{
comment|/* no date or conversion error? */
name|checkres
operator|=
name|CEVNT_BADDATE
expr_stmt|;
name|up
operator|->
name|tally
operator|.
name|malformed
operator|++
expr_stmt|;
block|}
comment|/* check clock sanity; [bug 2143] */
elseif|else
if|if
condition|(
name|pp
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
comment|/* no good status? */
name|checkres
operator|=
name|CEVNT_BADREPLY
expr_stmt|;
name|up
operator|->
name|tally
operator|.
name|rejected
operator|++
expr_stmt|;
block|}
else|else
name|checkres
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|checkres
operator|!=
operator|-
literal|1
condition|)
block|{
name|save_ltc
argument_list|(
name|pp
argument_list|,
name|rd_lastcode
argument_list|,
name|rd_lencode
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|checkres
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s effective timecode: %04u-%02u-%02u %02d:%02d:%02d\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|date
operator|.
name|year
operator|,
name|date
operator|.
name|month
operator|,
name|date
operator|.
name|monthday
operator|,
name|date
operator|.
name|hour
operator|,
name|date
operator|.
name|minute
operator|,
name|date
operator|.
name|second
operator|)
argument_list|)
expr_stmt|;
comment|/* Check if we must enter GPS time mode; log so if we do */
if|if
condition|(
operator|!
name|up
operator|->
name|gps_time
operator|&&
operator|(
name|sentence
operator|==
name|NMEA_GPZDG
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s using GPS time as if it were UTC"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|gps_time
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Get the reference time stamp from the calendar buffer. 	 * Process the new sample in the median filter and determine the 	 * timecode timestamp, but only if the PPS is not in control. 	 * Discard sentence if reference time did not change. 	 */
name|rd_reftime
operator|=
name|eval_gps_time
argument_list|(
name|peer
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|tofs
argument_list|,
operator|&
name|rd_timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|up
operator|->
name|last_reftime
argument_list|,
operator|&
name|rd_reftime
argument_list|)
condition|)
block|{
comment|/* Do not touch pp->a_lastcode on purpose! */
name|up
operator|->
name|tally
operator|.
name|filtered
operator|++
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|last_reftime
operator|=
name|rd_reftime
expr_stmt|;
name|rd_fudge
operator|=
name|pp
operator|->
name|fudgetime2
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s using '%s'\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|rd_lastcode
operator|)
argument_list|)
expr_stmt|;
comment|/* Data will be accepted. Update stats& log data. */
name|up
operator|->
name|tally
operator|.
name|accepted
operator|++
expr_stmt|;
name|save_ltc
argument_list|(
name|pp
argument_list|,
name|rd_lastcode
argument_list|,
name|rd_lencode
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|rd_timestamp
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
comment|/* 	 * If we have PPS running, we try to associate the sentence 	 * with the last active edge of the PPS signal. 	 */
if|if
condition|(
name|up
operator|->
name|ppsapi_lit
condition|)
switch|switch
condition|(
name|refclock_ppsrelate
argument_list|(
name|pp
argument_list|,
operator|&
name|up
operator|->
name|atom
argument_list|,
operator|&
name|rd_reftime
argument_list|,
operator|&
name|rd_timestamp
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|,
operator|&
name|rd_fudge
argument_list|)
condition|)
block|{
case|case
name|PPS_RELATE_PHASE
case|:
name|up
operator|->
name|ppsapi_gate
operator|=
name|TRUE
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PPS_PRECISION
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_PPS
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s PPS_RELATE_PHASE\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|tally
operator|.
name|pps_used
operator|++
expr_stmt|;
break|break;
case|case
name|PPS_RELATE_EDGE
case|:
name|up
operator|->
name|ppsapi_gate
operator|=
name|TRUE
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PPS_PRECISION
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s PPS_RELATE_EDGE\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPS_RELATE_NONE
case|:
default|default:
comment|/* 			 * Resetting precision and PPS flag is done in 			 * 'nmea_poll', since it might be a glitch. But 			 * at the end of the poll cycle we know... 			 */
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s PPS_RELATE_NONE\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|rd_reftime
argument_list|,
name|rd_timestamp
argument_list|,
name|rd_fudge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * nmea_poll - called by the transmit procedure  *  * Does the necessary bookkeeping stuff to keep the reported state of  * the clock in sync with reality.  *  * We go to great pains to avoid changing state here, since there may  * be more than one eavesdropper receiving the same timecode.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|nmea_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|nmea_unit
modifier|*
specifier|const
name|up
init|=
operator|(
name|nmea_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
comment|/* 	 * Process median filter samples. If none received, declare a 	 * timeout and keep going. 	 */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
comment|/* 	 * If we don't have PPS pulses and time stamps, turn PPS down 	 * for now. 	 */
if|if
condition|(
operator|!
name|up
operator|->
name|ppsapi_gate
condition|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|ppsapi_gate
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
comment|/* 	 * If the median filter is empty, claim a timeout. Else process 	 * the input data and keep the stats going. 	 */
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If extended logging is required, write the tally stats to the 	 * clockstats file; otherwise just do a normal clock stats 	 * record. Clear the tally stats anyway. 	*/
if|if
condition|(
name|peer
operator|->
name|ttl
operator|&
name|NMEA_EXTLOG_MASK
condition|)
block|{
comment|/* Log& reset counters with extended logging */
specifier|const
name|char
modifier|*
name|nmea
init|=
name|pp
operator|->
name|a_lastcode
decl_stmt|;
if|if
condition|(
operator|*
name|nmea
operator|==
literal|'\0'
condition|)
name|nmea
operator|=
literal|"(none)"
expr_stmt|;
name|mprintf_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
literal|"%s  %u %u %u %u %u %u"
argument_list|,
name|nmea
argument_list|,
name|up
operator|->
name|tally
operator|.
name|total
argument_list|,
name|up
operator|->
name|tally
operator|.
name|accepted
argument_list|,
name|up
operator|->
name|tally
operator|.
name|rejected
argument_list|,
name|up
operator|->
name|tally
operator|.
name|malformed
argument_list|,
name|up
operator|->
name|tally
operator|.
name|filtered
argument_list|,
name|up
operator|->
name|tally
operator|.
name|pps_used
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
block|}
name|ZERO
argument_list|(
name|up
operator|->
name|tally
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Save the last timecode string, making sure it's properly truncated  * if necessary and NUL terminated in any case.  */
end_comment

begin_function
specifier|static
name|void
name|save_ltc
parameter_list|(
name|struct
name|refclockproc
modifier|*
specifier|const
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|tc
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
operator|(
name|u_short
operator|)
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
name|tc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pp
operator|->
name|a_lastcode
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NMEA_WRITE_SUPPORT
end_if

begin_comment
comment|/*  * -------------------------------------------------------------------  *  gps_send(fd, cmd, peer)	Sends a command to the GPS receiver.  *   as in gps_send(fd, "rqts,u", peer);  *  * If 'cmd' starts with a '$' it is assumed that this command is in raw  * format, that is, starts with '$', ends with '<cr><lf>' and that any  * checksum is correctly provided; the command will be send 'as is' in  * that case. Otherwise the function will create the necessary frame  * (start char, chksum, final CRLF) on the fly.  *  * We don't currently send any data, but would like to send RTCM SC104  * messages for differential positioning. It should also give us better  * time. Without a PPS output, we're Just fooling ourselves because of  * the serial code paths  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|gps_send
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
comment|/* $...*xy<CR><LF><NUL> add 7 */
name|char
name|buf
index|[
name|NMEA_PROTO_MAXLEN
operator|+
literal|7
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_char
name|dcs
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|!=
literal|'$'
condition|)
block|{
comment|/* get checksum and length */
name|beg
operator|=
name|end
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|cmd
expr_stmt|;
name|dcs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|end
operator|>=
literal|' '
operator|&&
operator|*
name|end
operator|!=
literal|'*'
condition|)
name|dcs
operator|^=
operator|*
name|end
operator|++
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|beg
expr_stmt|;
comment|/* format into output buffer with overflow check */
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"$%.*s*%02X\r\n"
argument_list|,
name|len
argument_list|,
name|beg
argument_list|,
name|dcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s gps_send: buffer overflow for command '%s'\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return;
comment|/* game over player 1 */
block|}
name|cmd
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s gps_send: '%.*s'\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|len
operator|-
literal|2
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
comment|/* send out the whole stuff */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NMEA_WRITE_SUPPORT */
end_comment

begin_comment
comment|/*  * -------------------------------------------------------------------  * helpers for faster field splitting  * -------------------------------------------------------------------  *  * set up a field record, check syntax and verify checksum  *  * format is $XXXXX,1,2,3,4*ML  *  * 8-bit XOR of characters between $ and * noninclusive is transmitted  * in last two chars M and L holding most and least significant nibbles  * in hex representation such as:  *  *   $GPGLL,5057.970,N,00146.110,E,142451,A*27  *   $GPVTG,089.0,T,,,15.2,N,,*7F  *  * Some other constraints:  * + The field name must at least 5 upcase characters or digits and must  *   start with a character.  * + The checksum (if present) must be uppercase hex digits.  * + The length of a sentence is limited to 80 characters (not including  *   the final CR/LF nor the checksum, but including the leading '$')  *  * Return values:  *  + CHECK_INVALID  *	The data does not form a valid NMEA sentence or a checksum error  *	occurred.  *  + CHECK_VALID  *	The data is a valid NMEA sentence but contains no checksum.  *  + CHECK_CSVALID  *	The data is a valid NMEA sentence and passed the checksum test.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|field_init
parameter_list|(
name|nmea_data
modifier|*
name|data
parameter_list|,
comment|/* context structure		       */
name|char
modifier|*
name|cptr
parameter_list|,
comment|/* start of raw data		       */
name|int
name|dlen
comment|/* data len, not counting trailing NUL */
parameter_list|)
block|{
name|u_char
name|cs_l
decl_stmt|;
comment|/* checksum local computed	*/
name|u_char
name|cs_r
decl_stmt|;
comment|/* checksum remote given	*/
name|char
modifier|*
name|eptr
decl_stmt|;
comment|/* buffer end end pointer	*/
name|char
name|tmp
decl_stmt|;
comment|/* char buffer 			*/
name|cs_l
operator|=
literal|0
expr_stmt|;
name|cs_r
operator|=
literal|0
expr_stmt|;
comment|/* some basic input constraints */
if|if
condition|(
name|dlen
operator|<
literal|0
condition|)
name|dlen
operator|=
literal|0
expr_stmt|;
name|eptr
operator|=
name|cptr
operator|+
name|dlen
expr_stmt|;
operator|*
name|eptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* load data context */
name|data
operator|->
name|base
operator|=
name|cptr
expr_stmt|;
name|data
operator|->
name|cptr
operator|=
name|cptr
expr_stmt|;
name|data
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|blen
operator|=
name|dlen
expr_stmt|;
comment|/* syntax check follows here. check allowed character 	 * sequences, updating the local computed checksum as we go. 	 * 	 * regex equiv: '^\$[A-Z][A-Z0-9]{4,}[^*]*(\*[0-9A-F]{2})?$' 	 */
comment|/* -*- start character: '^\$' */
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'\0'
condition|)
return|return
name|CHECK_EMPTY
return|;
if|if
condition|(
operator|*
name|cptr
operator|++
operator|!=
literal|'$'
condition|)
return|return
name|CHECK_INVALID
return|;
comment|/* -*- advance context beyond start character */
name|data
operator|->
name|base
operator|++
expr_stmt|;
name|data
operator|->
name|cptr
operator|++
expr_stmt|;
name|data
operator|->
name|blen
operator|--
expr_stmt|;
comment|/* -*- field name: '[A-Z][A-Z0-9]{4,},' */
if|if
condition|(
operator|*
name|cptr
operator|<
literal|'A'
operator|||
operator|*
name|cptr
operator|>
literal|'Z'
condition|)
return|return
name|CHECK_INVALID
return|;
name|cs_l
operator|^=
operator|*
name|cptr
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cptr
operator|>=
literal|'A'
operator|&&
operator|*
name|cptr
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|>=
literal|'0'
operator|&&
operator|*
name|cptr
operator|<=
literal|'9'
operator|)
condition|)
name|cs_l
operator|^=
operator|*
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|!=
literal|','
operator|||
operator|(
name|cptr
operator|-
name|data
operator|->
name|base
operator|)
operator|<
name|NMEA_PROTO_IDLEN
condition|)
return|return
name|CHECK_INVALID
return|;
name|cs_l
operator|^=
operator|*
name|cptr
operator|++
expr_stmt|;
comment|/* -*- data: '[^*]*' */
while|while
condition|(
operator|*
name|cptr
operator|&&
operator|*
name|cptr
operator|!=
literal|'*'
condition|)
name|cs_l
operator|^=
operator|*
name|cptr
operator|++
expr_stmt|;
comment|/* -*- checksum field: (\*[0-9A-F]{2})?$ */
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'\0'
condition|)
return|return
name|CHECK_VALID
return|;
if|if
condition|(
operator|*
name|cptr
operator|!=
literal|'*'
operator|||
name|cptr
operator|!=
name|eptr
operator|-
literal|3
operator|||
operator|(
name|cptr
operator|-
name|data
operator|->
name|base
operator|)
operator|>=
name|NMEA_PROTO_MAXLEN
condition|)
return|return
name|CHECK_INVALID
return|;
for|for
control|(
name|cptr
operator|++
init|;
operator|(
name|tmp
operator|=
operator|*
name|cptr
operator|)
operator|!=
literal|'\0'
condition|;
name|cptr
operator|++
control|)
block|{
if|if
condition|(
name|tmp
operator|>=
literal|'0'
operator|&&
name|tmp
operator|<=
literal|'9'
condition|)
name|cs_r
operator|=
operator|(
name|cs_r
operator|<<
literal|4
operator|)
operator|+
operator|(
name|tmp
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|>=
literal|'A'
operator|&&
name|tmp
operator|<=
literal|'F'
condition|)
name|cs_r
operator|=
operator|(
name|cs_r
operator|<<
literal|4
operator|)
operator|+
operator|(
name|tmp
operator|-
literal|'A'
operator|+
literal|10
operator|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* -*- make sure we are at end of string and csum matches */
if|if
condition|(
name|cptr
operator|!=
name|eptr
operator|||
name|cs_l
operator|!=
name|cs_r
condition|)
return|return
name|CHECK_INVALID
return|;
return|return
name|CHECK_CSVALID
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * fetch a data field by index, zero being the name field. If this  * function is called repeatedly with increasing indices, the total load  * is O(n), n being the length of the string; if it is called with  * decreasing indices, the total load is O(n^2). Try not to go backwards  * too often.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|field_parse
parameter_list|(
name|nmea_data
modifier|*
name|data
parameter_list|,
name|int
name|fn
parameter_list|)
block|{
name|char
name|tmp
decl_stmt|;
if|if
condition|(
name|fn
operator|<
name|data
operator|->
name|cidx
condition|)
block|{
name|data
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|cptr
operator|=
name|data
operator|->
name|base
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|fn
operator|>
name|data
operator|->
name|cidx
operator|)
operator|&&
operator|(
name|tmp
operator|=
operator|*
name|data
operator|->
name|cptr
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|data
operator|->
name|cidx
operator|+=
operator|(
name|tmp
operator|==
literal|','
operator|)
expr_stmt|;
name|data
operator|->
name|cptr
operator|++
expr_stmt|;
block|}
return|return
name|data
operator|->
name|cptr
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Wipe (that is, overwrite with '_') data fields and the checksum in  * the last timecode.  The list of field indices is given as integers  * in a varargs list, preferrably in ascending order, in any case  * terminated by a negative field index.  *  * A maximum number of 8 fields can be overwritten at once to guard  * against runaway (that is, unterminated) argument lists.  *  * This function affects what a remote user can see with  *  * ntpq -c clockvar<server>  *  * Note that this also removes the wiped fields from any clockstats  * log.	 Some NTP operators monitor their NMEA GPS using the change in  * location in clockstats over time as as a proxy for the quality of  * GPS reception and thereby time reported.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|field_wipe
parameter_list|(
name|nmea_data
modifier|*
name|data
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
comment|/* vararg index list */
name|int
name|fcnt
decl_stmt|;
comment|/* safeguard against runaway arglist */
name|int
name|fidx
decl_stmt|;
comment|/* field to nuke, or -1 for checksum */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* overwrite destination */
name|fcnt
operator|=
literal|8
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|data
argument_list|)
expr_stmt|;
do|do
block|{
name|fidx
operator|=
name|va_arg
argument_list|(
name|va
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|fidx
operator|>=
literal|0
operator|&&
name|fidx
operator|<=
name|NMEA_PROTO_FIELDS
condition|)
block|{
name|cp
operator|=
name|field_parse
argument_list|(
name|data
argument_list|,
name|fidx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|data
operator|->
name|base
operator|+
name|data
operator|->
name|blen
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|blen
operator|>=
literal|3
operator|&&
name|cp
index|[
operator|-
literal|3
index|]
operator|==
literal|'*'
condition|)
name|cp
operator|-=
literal|2
expr_stmt|;
block|}
for|for
control|(
init|;
literal|'\0'
operator|!=
operator|*
name|cp
operator|&&
literal|'*'
operator|!=
operator|*
name|cp
operator|&&
literal|','
operator|!=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
literal|'.'
operator|!=
operator|*
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'_'
expr_stmt|;
block|}
do|while
condition|(
name|fcnt
operator|--
operator|&&
name|fidx
operator|>=
literal|0
condition|)
do|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * PARSING HELPERS  * -------------------------------------------------------------------  *  * Check sync status  *  * If the character at the data field start matches the tag value,  * return LEAP_NOWARNING and LEAP_NOTINSYNC otherwise. If the 'inverted'  * flag is given, just the opposite value is returned. If there is no  * data field (*cp points to the NUL byte) the result is LEAP_NOTINSYNC.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|u_char
name|parse_qual
parameter_list|(
name|nmea_data
modifier|*
name|rd
parameter_list|,
name|int
name|idx
parameter_list|,
name|char
name|tag
parameter_list|,
name|int
name|inv
parameter_list|)
block|{
specifier|static
specifier|const
name|u_char
name|table
index|[
literal|2
index|]
init|=
block|{
name|LEAP_NOTINSYNC
block|,
name|LEAP_NOWARNING
block|}
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|field_parse
argument_list|(
name|rd
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|table
index|[
operator|*
name|dp
operator|&&
operator|(
operator|(
operator|*
name|dp
operator|==
name|tag
operator|)
operator|==
operator|!
name|inv
operator|)
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Parse a time stamp in HHMMSS[.sss] format with error checking.  *  * returns 1 on success, 0 on failure  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|parse_time
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
comment|/* result calendar pointer */
name|long
modifier|*
name|ns
parameter_list|,
comment|/* storage for nsec fraction */
name|nmea_data
modifier|*
name|rd
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|long
name|weight
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|100000000
block|,
literal|10000000
block|,
literal|1000000
block|}
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|u_int
name|h
decl_stmt|;
name|u_int
name|m
decl_stmt|;
name|u_int
name|s
decl_stmt|;
name|int
name|p1
decl_stmt|;
name|int
name|p2
decl_stmt|;
name|u_long
name|f
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|field_parse
argument_list|(
name|rd
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sscanf
argument_list|(
name|dp
argument_list|,
literal|"%2u%2u%2u%n.%3lu%n"
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|f
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|3
operator|||
name|p1
operator|!=
literal|6
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"nmea: invalid time code: '%.6s'\n"
operator|,
name|dp
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* value sanity check */
if|if
condition|(
name|h
operator|>
literal|23
operator|||
name|m
operator|>
literal|59
operator|||
name|s
operator|>
literal|60
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"nmea: invalid time spec %02u:%02u:%02u\n"
operator|,
name|h
operator|,
name|m
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|jd
operator|->
name|hour
operator|=
operator|(
name|u_char
operator|)
name|h
expr_stmt|;
name|jd
operator|->
name|minute
operator|=
operator|(
name|u_char
operator|)
name|m
expr_stmt|;
name|jd
operator|->
name|second
operator|=
operator|(
name|u_char
operator|)
name|s
expr_stmt|;
comment|/* if we have a fraction, scale it up to nanoseconds. */
if|if
condition|(
name|rc
operator|==
literal|4
condition|)
operator|*
name|ns
operator|=
name|f
operator|*
name|weight
index|[
name|p2
operator|-
name|p1
operator|-
literal|1
index|]
expr_stmt|;
else|else
operator|*
name|ns
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Parse a date string from an NMEA sentence. This could either be a  * partial date in DDMMYY format in one field, or DD,MM,YYYY full date  * spec spanning three fields. This function does some extensive error  * checking to make sure the date string was consistent.  *  * returns 1 on success, 0 on failure  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|parse_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
comment|/* result pointer */
name|nmea_data
modifier|*
name|rd
parameter_list|,
name|int
name|idx
parameter_list|,
name|enum
name|date_fmt
name|fmt
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|u_int
name|y
decl_stmt|;
name|u_int
name|m
decl_stmt|;
name|u_int
name|d
decl_stmt|;
name|int
name|p
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|field_parse
argument_list|(
name|rd
argument_list|,
name|idx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|DATE_1_DDMMYY
case|:
name|rc
operator|=
name|sscanf
argument_list|(
name|dp
argument_list|,
literal|"%2u%2u%2u%n"
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|3
operator|||
name|p
operator|!=
literal|6
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"nmea: invalid date code: '%.6s'\n"
operator|,
name|dp
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|DATE_3_DDMMYYYY
case|:
name|rc
operator|=
name|sscanf
argument_list|(
name|dp
argument_list|,
literal|"%2u,%2u,%4u%n"
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|3
operator|||
name|p
operator|!=
literal|10
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"nmea: invalid date code: '%.10s'\n"
operator|,
name|dp
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"nmea: invalid parse format: %d\n"
operator|,
name|fmt
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* value sanity check */
if|if
condition|(
name|d
operator|<
literal|1
operator|||
name|d
operator|>
literal|31
operator|||
name|m
operator|<
literal|1
operator|||
name|m
operator|>
literal|12
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"nmea: invalid date spec (YMD) %04u:%02u:%02u\n"
operator|,
name|y
operator|,
name|m
operator|,
name|d
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* store results */
name|jd
operator|->
name|monthday
operator|=
operator|(
name|u_char
operator|)
name|d
expr_stmt|;
name|jd
operator|->
name|month
operator|=
operator|(
name|u_char
operator|)
name|m
expr_stmt|;
name|jd
operator|->
name|year
operator|=
operator|(
name|u_short
operator|)
name|y
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Parse GPS week time info from an NMEA sentence. This info contains  * the GPS week number, the GPS time-of-week and the leap seconds GPS  * to UTC.  *  * returns 1 on success, 0 on failure  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|parse_weekdata
parameter_list|(
name|gps_weektm
modifier|*
name|wd
parameter_list|,
name|nmea_data
modifier|*
name|rd
parameter_list|,
name|int
name|weekidx
parameter_list|,
name|int
name|timeidx
parameter_list|,
name|int
name|leapidx
parameter_list|)
block|{
name|u_long
name|secs
decl_stmt|;
name|int
name|fcnt
decl_stmt|;
comment|/* parse fields and count success */
name|fcnt
operator|=
name|sscanf
argument_list|(
name|field_parse
argument_list|(
name|rd
argument_list|,
name|weekidx
argument_list|)
argument_list|,
literal|"%hu"
argument_list|,
operator|&
name|wd
operator|->
name|wt_week
argument_list|)
expr_stmt|;
name|fcnt
operator|+=
name|sscanf
argument_list|(
name|field_parse
argument_list|(
name|rd
argument_list|,
name|timeidx
argument_list|)
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|secs
argument_list|)
expr_stmt|;
name|fcnt
operator|+=
name|sscanf
argument_list|(
name|field_parse
argument_list|(
name|rd
argument_list|,
name|leapidx
argument_list|)
argument_list|,
literal|"%hd"
argument_list|,
operator|&
name|wd
operator|->
name|wt_leap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcnt
operator|!=
literal|3
operator|||
name|wd
operator|->
name|wt_week
operator|>=
literal|1024
operator|||
name|secs
operator|>=
literal|7
operator|*
name|SECSPERDAY
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"nmea: parse_weekdata: invalid weektime spec\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|wd
operator|->
name|wt_time
operator|=
operator|(
name|u_int32
operator|)
name|secs
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * funny calendar-oriented stuff -- perhaps a bit hard to grok.  * -------------------------------------------------------------------  *  * Unfold a time-of-day (seconds since midnight) around the current  * system time in a manner that guarantees an absolute difference of  * less than 12hrs.  *  * This function is used for NMEA sentences that contain no date  * information. This requires the system clock to be in +/-12hrs  * around the true time, or the clock will synchronize the system 1day  * off if not augmented with a time sources that also provide the  * necessary date information.  *  * The function updates the calendar structure it also uses as  * input to fetch the time from.  *  * returns 1 on success, 0 on failure  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|unfold_day
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|u_int32
name|rec_ui
parameter_list|)
block|{
name|vint64
name|rec_qw
decl_stmt|;
name|ntpcal_split
name|rec_ds
decl_stmt|;
comment|/* 	 * basically this is the peridiodic extension of the receive 	 * time - 12hrs to the time-of-day with a period of 1 day. 	 * But we would have to execute this in 64bit arithmetic, and we 	 * cannot assume we can do this; therefore this is done 	 * in split representation. 	 */
name|rec_qw
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|rec_ui
operator|-
name|SECSPERDAY
operator|/
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rec_ds
operator|=
name|ntpcal_daysplit
argument_list|(
operator|&
name|rec_qw
argument_list|)
expr_stmt|;
name|rec_ds
operator|.
name|lo
operator|=
name|ntpcal_periodic_extend
argument_list|(
name|rec_ds
operator|.
name|lo
argument_list|,
name|ntpcal_date_to_daysec
argument_list|(
name|jd
argument_list|)
argument_list|,
name|SECSPERDAY
argument_list|)
expr_stmt|;
name|rec_ds
operator|.
name|hi
operator|+=
name|ntpcal_daysec_to_date
argument_list|(
name|jd
argument_list|,
name|rec_ds
operator|.
name|lo
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntpcal_rd_to_date
argument_list|(
name|jd
argument_list|,
name|rec_ds
operator|.
name|hi
operator|+
name|DAY_NTP_STARTS
argument_list|)
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * A 2-digit year is expanded into full year spec around the year found  * in 'jd->year'. This should be in +79/-19 years around the system time,  * or the result will be off by 100 years.  The assymetric behaviour was  * chosen to enable inital sync for systems that do not have a  * battery-backup clock and start with a date that is typically years in  * the past.  *  * Since the GPS epoch starts at 1980-01-06, the resulting year will be  * not be before 1980 in any case.  *  * returns 1 on success, 0 on failure  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|unfold_century
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|u_int32
name|rec_ui
parameter_list|)
block|{
name|struct
name|calendar
name|rec
decl_stmt|;
name|int32
name|baseyear
decl_stmt|;
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|rec
argument_list|,
name|rec_ui
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|baseyear
operator|=
name|rec
operator|.
name|year
operator|-
literal|20
expr_stmt|;
if|if
condition|(
name|baseyear
operator|<
name|g_gpsMinYear
condition|)
name|baseyear
operator|=
name|g_gpsMinYear
expr_stmt|;
name|jd
operator|->
name|year
operator|=
operator|(
name|u_short
operator|)
name|ntpcal_periodic_extend
argument_list|(
name|baseyear
argument_list|,
name|jd
operator|->
name|year
argument_list|,
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|baseyear
operator|<=
name|jd
operator|->
name|year
operator|)
operator|&&
operator|(
name|baseyear
operator|+
literal|100
operator|>
name|jd
operator|->
name|year
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * A 2-digit year is expanded into a full year spec by correlation with  * a GPS week number and the current leap second count.  *  * The GPS week time scale counts weeks since Sunday, 1980-01-06, modulo  * 1024 and seconds since start of the week. The GPS time scale is based  * on international atomic time (TAI), so the leap second difference to  * UTC is also needed for a proper conversion.  *  * A brute-force analysis (that is, test for every date) shows that a  * wrong assignment of the century can not happen between the years 1900  * to 2399 when comparing the week signatures for different  * centuries. (I *think* that will not happen for 400*1024 years, but I  * have no valid proof. -*-perlinger@ntp.org-*-)  *  * This function is bound to to work between years 1980 and 2399  * (inclusive), which should suffice for now ;-)  *  * Note: This function needs a full date&time spec on input due to the  * necessary leap second corrections!  *  * returns 1 on success, 0 on failure  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|gpsfix_century
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
specifier|const
name|gps_weektm
modifier|*
name|wd
parameter_list|,
name|u_short
modifier|*
name|century
parameter_list|)
block|{
name|int32
name|days
decl_stmt|;
name|int32
name|doff
decl_stmt|;
name|u_short
name|week
decl_stmt|;
name|u_short
name|year
decl_stmt|;
name|int
name|loop
decl_stmt|;
comment|/* Get day offset. Assumes that the input time is in range and 	 * that the leap seconds do not shift more than +/-1 day. 	 */
name|doff
operator|=
name|ntpcal_date_to_daysec
argument_list|(
name|jd
argument_list|)
operator|+
name|wd
operator|->
name|wt_leap
expr_stmt|;
name|doff
operator|=
operator|(
name|doff
operator|>=
name|SECSPERDAY
operator|)
operator|-
operator|(
name|doff
operator|<
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Loop over centuries to get a match, starting with the last 	 * successful one. (Or with the 19th century if the cached value 	 * is out of range...) 	 */
name|year
operator|=
name|jd
operator|->
name|year
operator|%
literal|100
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|5
init|;
name|loop
operator|>
literal|0
condition|;
name|loop
operator|--
operator|,
operator|(
operator|*
name|century
operator|)
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|century
operator|<
literal|19
operator|||
operator|*
name|century
operator|>=
literal|24
condition|)
operator|*
name|century
operator|=
literal|19
expr_stmt|;
comment|/* Get days and week in GPS epoch */
name|jd
operator|->
name|year
operator|=
name|year
operator|+
operator|*
name|century
operator|*
literal|100
expr_stmt|;
name|days
operator|=
name|ntpcal_date_to_rd
argument_list|(
name|jd
argument_list|)
operator|-
name|DAY_GPS_STARTS
operator|+
name|doff
expr_stmt|;
name|week
operator|=
operator|(
name|days
operator|/
literal|7
operator|)
operator|%
literal|1024
expr_stmt|;
if|if
condition|(
name|days
operator|>=
literal|0
operator|&&
name|wd
operator|->
name|wt_week
operator|==
name|week
condition|)
return|return
name|TRUE
return|;
comment|/* matched... */
block|}
name|jd
operator|->
name|year
operator|=
name|year
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* match failed... */
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * And now the final execise: Considering the fact that many (most?)  * GPS receivers cannot handle a GPS epoch wrap well, we try to  * compensate for that problem by unwrapping a GPS epoch around the  * receive stamp. Another execise in periodic unfolding, of course,  * but with enough points to take care of.  *  * Note: The integral part of 'tofs' is intended to handle small(!)  * systematic offsets, as -1 for handling $GPZDG, which gives the  * following second. (sigh...) The absolute value shall be less than a  * day (86400 seconds).  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|l_fp
name|eval_gps_time
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* for logging etc */
specifier|const
name|struct
name|calendar
modifier|*
name|gpst
parameter_list|,
comment|/* GPS time stamp  */
specifier|const
name|struct
name|timespec
modifier|*
name|tofs
parameter_list|,
comment|/* GPS frac second& offset */
specifier|const
name|l_fp
modifier|*
name|xrecv
comment|/* receive time stamp */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|nmea_unit
modifier|*
specifier|const
name|up
init|=
operator|(
name|nmea_unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|l_fp
name|retv
decl_stmt|;
comment|/* components of calculation */
name|int32_t
name|rcv_sec
decl_stmt|,
name|rcv_day
decl_stmt|;
comment|/* receive ToD and day */
name|int32_t
name|gps_sec
decl_stmt|,
name|gps_day
decl_stmt|;
comment|/* GPS ToD and day in NTP epoch */
name|int32_t
name|adj_day
decl_stmt|,
name|weeks
decl_stmt|;
comment|/* adjusted GPS day and week shift */
comment|/* some temporaries to shuffle data */
name|vint64
name|vi64
decl_stmt|;
name|ntpcal_split
name|rs64
decl_stmt|;
comment|/* evaluate time stamp from receiver. */
name|gps_sec
operator|=
name|ntpcal_date_to_daysec
argument_list|(
name|gpst
argument_list|)
expr_stmt|;
name|gps_day
operator|=
name|ntpcal_date_to_rd
argument_list|(
name|gpst
argument_list|)
operator|-
name|DAY_NTP_STARTS
expr_stmt|;
comment|/* merge in fractional offset */
name|retv
operator|=
name|tspec_intv_to_lfp
argument_list|(
operator|*
name|tofs
argument_list|)
expr_stmt|;
name|gps_sec
operator|+=
name|retv
operator|.
name|l_i
expr_stmt|;
comment|/* If we fully trust the GPS receiver, just combine days and 	 * seconds and be done. */
if|if
condition|(
name|peer
operator|->
name|ttl
operator|&
name|NMEA_DATETRUST_MASK
condition|)
block|{
name|retv
operator|.
name|l_ui
operator|=
name|ntpcal_dayjoin
argument_list|(
name|gps_day
argument_list|,
name|gps_sec
argument_list|)
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
return|return
name|retv
return|;
block|}
comment|/* So we do not trust the GPS receiver to deliver a correct date 	 * due to the GPS epoch changes. We map the date from the 	 * receiver into the +/-512 week interval around the receive 	 * time in that case. This would be a tad easier with 64bit 	 * calculations, but again, we restrict the code to 32bit ops 	 * when possible. */
comment|/* - make sure the GPS fractional day is normalised 	 * Applying the offset value might have put us slightly over the 	 * edge of the allowed range for seconds-of-day. Doing a full 	 * division with floor correction is overkill here; a simple 	 * addition or subtraction step is sufficient. Using WHILE loops 	 * gives the right result even if the offset exceeds one day, 	 * which is NOT what it's intented for! */
while|while
condition|(
name|gps_sec
operator|>=
name|SECSPERDAY
condition|)
block|{
name|gps_sec
operator|-=
name|SECSPERDAY
expr_stmt|;
name|gps_day
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|gps_sec
operator|<
literal|0
condition|)
block|{
name|gps_sec
operator|+=
name|SECSPERDAY
expr_stmt|;
name|gps_day
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* - get unfold base: day of full recv time - 512 weeks */
name|vi64
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|xrecv
operator|->
name|l_ui
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rs64
operator|=
name|ntpcal_daysplit
argument_list|(
operator|&
name|vi64
argument_list|)
expr_stmt|;
name|rcv_sec
operator|=
name|rs64
operator|.
name|lo
expr_stmt|;
name|rcv_day
operator|=
name|rs64
operator|.
name|hi
operator|-
literal|512
operator|*
literal|7
expr_stmt|;
comment|/* - take the fractional days into account 	 * If the fractional day of the GPS time is smaller than the 	 * fractional day of the receive time, we shift the base day for 	 * the unfold by 1. */
if|if
condition|(
name|gps_sec
operator|<
name|rcv_sec
operator|||
operator|(
name|gps_sec
operator|==
name|rcv_sec
operator|&&
name|retv
operator|.
name|l_uf
operator|<
name|xrecv
operator|->
name|l_uf
operator|)
condition|)
name|rcv_day
operator|+=
literal|1
expr_stmt|;
comment|/* - don't warp ahead of GPS invention! */
if|if
condition|(
name|rcv_day
operator|<
name|g_gpsMinBase
condition|)
name|rcv_day
operator|=
name|g_gpsMinBase
expr_stmt|;
comment|/* - let the magic happen: */
name|adj_day
operator|=
name|ntpcal_periodic_extend
argument_list|(
name|rcv_day
argument_list|,
name|gps_day
argument_list|,
literal|1024
operator|*
literal|7
argument_list|)
expr_stmt|;
comment|/* - check if we should log a GPS epoch warp */
name|weeks
operator|=
operator|(
name|adj_day
operator|-
name|gps_day
operator|)
operator|/
literal|7
expr_stmt|;
if|if
condition|(
name|weeks
operator|!=
name|up
operator|->
name|epoch_warp
condition|)
block|{
name|up
operator|->
name|epoch_warp
operator|=
name|weeks
expr_stmt|;
name|LOGIF
argument_list|(
name|CLOCKINFO
argument_list|,
operator|(
name|LOG_INFO
operator|,
literal|"%s Changed GPS epoch warp to %d weeks"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|weeks
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* - build result and be done */
name|retv
operator|.
name|l_ui
operator|=
name|ntpcal_dayjoin
argument_list|(
name|adj_day
argument_list|,
name|gps_sec
argument_list|)
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/*  * ===================================================================  *  * NMEAD support  *  * original nmead support added by Jon Miner (cp_n18@yahoo.com)  *  * See http://home.hiwaay.net/~taylorc/gps/nmea-server/  * for information about nmead  *  * To use this, you need to create a link from /dev/gpsX to  * the server:port where nmead is running.  Something like this:  *  * ln -s server:port /dev/gps1  *  * Split into separate function by Juergen Perlinger  * (perlinger-at-ntp-dot-org)  *  * ===================================================================  */
end_comment

begin_function
specifier|static
name|int
name|nmead_open
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* result file descriptor */
ifdef|#
directive|ifdef
name|HAVE_READLINK
name|char
name|host
index|[
literal|80
index|]
decl_stmt|;
comment|/* link target buffer	*/
name|char
modifier|*
name|port
decl_stmt|;
comment|/* port name or number	*/
name|int
name|rc
decl_stmt|;
comment|/* result code (several)*/
name|int
name|sh
decl_stmt|;
comment|/* socket handle	*/
name|struct
name|addrinfo
name|ai_hint
decl_stmt|;
comment|/* resolution hint	*/
name|struct
name|addrinfo
modifier|*
name|ai_list
decl_stmt|;
comment|/* resolution result	*/
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
comment|/* result scan ptr	*/
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* try to read as link, make sure no overflow occurs */
name|rc
operator|=
name|readlink
argument_list|(
name|device
argument_list|,
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|rc
operator|>=
sizeof|sizeof
argument_list|(
name|host
argument_list|)
condition|)
return|return
name|fd
return|;
comment|/* error / overflow / truncation */
name|host
index|[
name|rc
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* readlink does not place NUL	*/
comment|/* get port */
name|port
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
return|return
name|fd
return|;
comment|/* not 'host:port' syntax ? */
operator|*
name|port
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* put in separator */
comment|/* get address infos and try to open socket 	 * 	 * This getaddrinfo() is naughty in ntpd's nonblocking main 	 * thread, but you have to go out of your wary to use this code 	 * and typically the blocking is at startup where its impact is 	 * reduced. The same holds for the 'connect()', as it is 	 * blocking, too... 	 */
name|ZERO
argument_list|(
name|ai_hint
argument_list|)
expr_stmt|;
name|ai_hint
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|ai_hint
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
if|if
condition|(
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
operator|&
name|ai_hint
argument_list|,
operator|&
name|ai_list
argument_list|)
condition|)
return|return
name|fd
return|;
for|for
control|(
name|ai
operator|=
name|ai_list
init|;
name|ai
operator|&&
operator|(
name|fd
operator|==
operator|-
literal|1
operator|)
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
name|sh
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_SOCKET
operator|==
name|sh
condition|)
continue|continue;
name|rc
operator|=
name|connect
argument_list|(
name|sh
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|rc
condition|)
name|fd
operator|=
name|sh
expr_stmt|;
else|else
name|close
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|ai_list
argument_list|)
expr_stmt|;
else|#
directive|else
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|fd
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_macro
name|NONEMPTY_TRANSLATION_UNIT
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK&& CLOCK_NMEA */
end_comment

end_unit

