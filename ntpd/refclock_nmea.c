begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_nmea.c - clock driver for an NMEA GPS CLOCK  *		Michael Petry Jun 20, 1994  *		 based on refclock_heathn.c  *  * Updated to add support for Accord GPS Clock  *		Venu Gopal Dec 05, 2007  *		neo.venu@gmail.com, venugopal_d@pgad.gov.in  *  * Updated to process 'time1' fudge factor  *		Venu Gopal May 05, 2008  *  * Converted to common PPSAPI code, separate PPS fudge time1  * from serial timecode fudge time2.  *		Dave Hart July 1, 2009  *		hart@ntp.org, davehart@davehart.com  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_NMEA
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_include
include|#
directive|include
file|"ppsapi_timepps.h"
end_include

begin_include
include|#
directive|include
file|"refclock_atom.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_comment
comment|/* ports/winnt/include/config.h: #define write _write */
end_comment

begin_function_decl
specifier|extern
name|int
name|async_write
parameter_list|(
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|write
parameter_list|(
name|fd
parameter_list|,
name|data
parameter_list|,
name|octets
parameter_list|)
value|async_write(fd, data, octets)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TIMESPECTOTS
end_ifndef

begin_define
define|#
directive|define
name|TIMESPECTOTS
parameter_list|(
name|ptspec
parameter_list|,
name|pts
parameter_list|)
define|\
value|do {								\ 		DTOLFP((ptspec)->tv_nsec * 1.0e-9, pts);		\ 		(pts)->l_ui += (u_int32)((ptspec)->tv_sec) + JAN_1970;	\ 	} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This driver supports NMEA-compatible GPS receivers  *  * Prototype was refclock_trak.c, Thanks a lot.  *  * The receiver used spits out the NMEA sentences for boat navigation.  * And you thought it was an information superhighway.	Try a raging river  * filled with rapids and whirlpools that rip away your data and warp time.  *  * If HAVE_PPSAPI is defined code to use the PPSAPI will be compiled in.  * On startup if initialization of the PPSAPI fails, it will fall back  * to the "normal" timestamps.  *  * The PPSAPI part of the driver understands fudge flag2 and flag3. If  * flag2 is set, it will use the clear edge of the pulse. If flag3 is  * set, kernel hardpps is enabled.  *  * GPS sentences other than RMC (the default) may be enabled by setting  * the relevent bits of 'mode' in the server configuration line  * server 127.127.20.x mode X  *   * bit 0 - enables RMC (1)  * bit 1 - enables GGA (2)  * bit 2 - enables GLL (4)  * bit 3 - enables ZDA (8) - Standard Time& Date  * bit 3 - enables ZDG (8) - Accord GPS Clock's custom sentence with GPS time   *			     very close to standard ZDA  *   * Multiple sentences may be selected except when ZDG/ZDA is selected.  *  * bit 4/5/6 - selects the baudrate for serial port :  *		0 for 4800 (default)   *		1 for 9600   *		2 for 19200   *		3 for 38400   *		4 for 57600   *		5 for 115200   */
end_comment

begin_define
define|#
directive|define
name|NMEA_MESSAGE_MASK_OLD
value|0x07
end_define

begin_define
define|#
directive|define
name|NMEA_MESSAGE_MASK_SINGLE
value|0x08
end_define

begin_define
define|#
directive|define
name|NMEA_MESSAGE_MASK
value|(NMEA_MESSAGE_MASK_OLD | NMEA_MESSAGE_MASK_SINGLE)
end_define

begin_define
define|#
directive|define
name|NMEA_BAUDRATE_MASK
value|0x70
end_define

begin_define
define|#
directive|define
name|NMEA_BAUDRATE_SHIFT
value|4
end_define

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/gps%d"
end_define

begin_comment
comment|/* GPS serial device */
end_comment

begin_define
define|#
directive|define
name|PPSDEV
value|"/dev/gpspps%d"
end_define

begin_comment
comment|/* PPSAPI device override */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B4800
end_define

begin_comment
comment|/* uart speed (4800 bps) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-9)
end_define

begin_comment
comment|/* precision assumed (about 2 ms) */
end_comment

begin_define
define|#
directive|define
name|PPS_PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"GPS\0"
end_define

begin_comment
comment|/* reference id */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"NMEA GPS Clock"
end_define

begin_comment
comment|/* who we are */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|M_NOCTTY
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NOCTTY
value|O_NOCTTY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_define
define|#
directive|define
name|M_NONBLOCK
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NONBLOCK
value|O_NONBLOCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PPSOPENMODE
value|(O_RDWR | M_NOCTTY | M_NONBLOCK)
end_define

begin_comment
comment|/* NMEA sentence array indexes for those we use */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPRMC
value|0
end_define

begin_comment
comment|/* recommended min. nav. */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPGGA
value|1
end_define

begin_comment
comment|/* fix and quality */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPGLL
value|2
end_define

begin_comment
comment|/* geo. lat/long */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPZDA
value|3
end_define

begin_comment
comment|/* date/time */
end_comment

begin_comment
comment|/*  * $GPZDG is a proprietary sentence that violates the spec, by not  * using $P and an assigned company identifier to prefix the sentence  * identifier.	When used with this driver, the system needs to be  * isolated from other NTP networks, as it operates in GPS time, not  * UTC as is much more common.	GPS time is>15 seconds different from  * UTC due to not respecting leap seconds since 1970 or so.  Other  * than the different timebase, $GPZDG is similar to $GPZDA.  */
end_comment

begin_define
define|#
directive|define
name|NMEA_GPZDG
value|4
end_define

begin_define
define|#
directive|define
name|NMEA_ARRAY_SIZE
value|(NMEA_GPZDG + 1)
end_define

begin_comment
comment|/*  * Sentence selection mode bits  */
end_comment

begin_define
define|#
directive|define
name|USE_ALL
value|0
end_define

begin_comment
comment|/* any/all */
end_comment

begin_define
define|#
directive|define
name|USE_GPRMC
value|1
end_define

begin_define
define|#
directive|define
name|USE_GPGGA
value|2
end_define

begin_define
define|#
directive|define
name|USE_GPGLL
value|4
end_define

begin_define
define|#
directive|define
name|USE_GPZDA_ZDG
value|8
end_define

begin_comment
comment|/* affects both */
end_comment

begin_comment
comment|/* mapping from sentence index to controlling mode bit */
end_comment

begin_decl_stmt
name|u_char
name|sentence_mode
index|[
name|NMEA_ARRAY_SIZE
index|]
init|=
block|{
name|USE_GPRMC
block|,
name|USE_GPGGA
block|,
name|USE_GPGLL
block|,
name|USE_GPZDA_ZDG
block|,
name|USE_GPZDA_ZDG
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|nmeaunit
block|{
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|struct
name|refclock_atom
name|atom
decl_stmt|;
comment|/* PPSAPI structure */
name|int
name|ppsapi_tried
decl_stmt|;
comment|/* attempt PPSAPI once */
name|int
name|ppsapi_lit
decl_stmt|;
comment|/* time_pps_create() worked */
name|int
name|ppsapi_fd
decl_stmt|;
comment|/* fd used with PPSAPI */
name|int
name|ppsapi_gate
decl_stmt|;
comment|/* allow edge detection processing */
name|int
name|tcount
decl_stmt|;
comment|/* timecode sample counter */
name|int
name|pcount
decl_stmt|;
comment|/* PPS sample counter */
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
name|l_fp
name|tstamp
decl_stmt|;
comment|/* timestamp of last poll */
name|int
name|gps_time
decl_stmt|;
comment|/* 0 UTC, 1 GPS time */
comment|/* per sentence checksum seen flag */
name|struct
name|calendar
name|used
decl_stmt|;
comment|/* hh:mm:ss of used sentence */
name|u_char
name|cksum_seen
index|[
name|NMEA_ARRAY_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|nmea_start
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nmea_shutdown
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nmea_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nmea_poll
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_function_decl
specifier|static
name|void
name|nmea_control
parameter_list|(
name|int
parameter_list|,
name|struct
name|refclockstat
modifier|*
parameter_list|,
name|struct
name|refclockstat
modifier|*
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nmea_timer
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NMEA_CONTROL
value|nmea_control
end_define

begin_define
define|#
directive|define
name|NMEA_TIMER
value|nmea_timer
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NMEA_CONTROL
value|noentry
end_define

begin_define
define|#
directive|define
name|NMEA_TIMER
value|noentry
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_function_decl
specifier|static
name|void
name|gps_send
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|field_parse
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nmea_checksum_ok
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nmea_day_unfold
parameter_list|(
name|struct
name|calendar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nmea_century_unfold
parameter_list|(
name|struct
name|calendar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_nmea
init|=
block|{
name|nmea_start
block|,
comment|/* start up driver */
name|nmea_shutdown
block|,
comment|/* shut down driver */
name|nmea_poll
block|,
comment|/* transmit poll message */
name|NMEA_CONTROL
block|,
comment|/* fudge control */
name|noentry
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* buginfo */
name|NMEA_TIMER
comment|/* called once per second */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * nmea_start - open the GPS devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|nmea_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|nmeaunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
name|int
name|baudrate
decl_stmt|;
name|char
modifier|*
name|baudtext
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* 	 * Open serial port. Use CLK line discipline, if available. 	 */
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* 	 * Opening the serial port with appropriate baudrate 	 * based on the value of bit 4/5/6 	 */
switch|switch
condition|(
operator|(
name|peer
operator|->
name|ttl
operator|&
name|NMEA_BAUDRATE_MASK
operator|)
operator|>>
name|NMEA_BAUDRATE_SHIFT
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
default|default:
name|baudrate
operator|=
name|SPEED232
expr_stmt|;
name|baudtext
operator|=
literal|"4800"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|baudrate
operator|=
name|B9600
expr_stmt|;
name|baudtext
operator|=
literal|"9600"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|baudrate
operator|=
name|B19200
expr_stmt|;
name|baudtext
operator|=
literal|"19200"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|baudrate
operator|=
name|B38400
expr_stmt|;
name|baudtext
operator|=
literal|"38400"
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|B57600
case|case
literal|4
case|:
name|baudrate
operator|=
name|B57600
expr_stmt|;
name|baudtext
operator|=
literal|"57600"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
case|case
literal|5
case|:
name|baudrate
operator|=
name|B115200
expr_stmt|;
name|baudtext
operator|=
literal|"115200"
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|baudrate
argument_list|,
name|LDISC_CLK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_READLINK
comment|/* nmead support added by Jon Miner (cp_n18@yahoo.com) 		 * 		 * See http://home.hiwaay.net/~taylorc/gps/nmea-server/ 		 * for information about nmead 		 * 		 * To use this, you need to create a link from /dev/gpsX 		 * to the server:port where nmead is running.  Something 		 * like this: 		 * 		 * ln -s server:port /dev/gps1 		 */
name|char
name|buffer
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|nmea_host
decl_stmt|,
modifier|*
name|nmea_tail
decl_stmt|;
name|int
name|nmea_port
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|struct
name|protoent
modifier|*
name|p
decl_stmt|;
name|struct
name|sockaddr_in
name|so_addr
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|readlink
argument_list|(
name|device
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|buffer
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|nmea_host
operator|=
name|strtok
argument_list|(
name|buffer
argument_list|,
literal|":"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|nmea_tail
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nmea_port
operator|=
name|atoi
argument_list|(
name|nmea_tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|he
operator|=
name|gethostbyname
argument_list|(
name|nmea_host
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|getprotobyname
argument_list|(
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
operator|&
name|so_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|so_addr
argument_list|)
argument_list|)
expr_stmt|;
name|so_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|so_addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|nmea_port
argument_list|)
expr_stmt|;
name|so_addr
operator|.
name|sin_addr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|he
operator|->
name|h_addr
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|p
operator|->
name|p_proto
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|so_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|so_addr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s serial %s open at %s bps"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|device
argument_list|,
name|baudtext
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize unit structure 	 */
name|up
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|nmea_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gps_send
argument_list|(
name|fd
argument_list|,
literal|"$PMOTG,RMC,0000*1D\r\n"
argument_list|,
name|peer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nmea_shutdown - shut down a GPS clock  *   * NOTE this routine is called after nmea_start() returns failure,  * as well as during a normal shutdown due to ntpq :config unpeer.  */
end_comment

begin_function
specifier|static
name|void
name|nmea_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|nmeaunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|nmeaunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
if|if
condition|(
name|up
operator|->
name|ppsapi_lit
condition|)
block|{
name|time_pps_destroy
argument_list|(
name|up
operator|->
name|atom
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ppsapi_fd
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|close
argument_list|(
name|up
operator|->
name|ppsapi_fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * nmea_control - configure fudge params  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_function
specifier|static
name|void
name|nmea_control
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|in_st
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out_st
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|char
name|device
index|[
literal|32
index|]
decl_stmt|;
specifier|register
name|struct
name|nmeaunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|pps_fd
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|in_st
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|out_st
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|nmeaunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CLK_FLAG1
operator|&
name|pp
operator|->
name|sloppyclockflag
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|up
operator|->
name|ppsapi_tried
condition|)
return|return;
name|up
operator|->
name|ppsapi_tried
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|up
operator|->
name|ppsapi_lit
condition|)
return|return;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|time_pps_destroy
argument_list|(
name|up
operator|->
name|atom
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ppsapi_fd
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|close
argument_list|(
name|up
operator|->
name|ppsapi_fd
argument_list|)
expr_stmt|;
name|up
operator|->
name|atom
operator|.
name|handle
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|ppsapi_lit
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|ppsapi_fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|up
operator|->
name|ppsapi_tried
condition|)
return|return;
comment|/* 	 * Light up the PPSAPI interface. 	 */
name|up
operator|->
name|ppsapi_tried
operator|=
literal|1
expr_stmt|;
comment|/* 	 * if /dev/gpspps$UNIT can be opened that will be used for 	 * PPSAPI.  Otherwise, the GPS serial device /dev/gps$UNIT 	 * already opened is used for PPSAPI as well. 	 */
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
name|PPSDEV
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|pps_fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|PPSOPENMODE
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|pps_fd
condition|)
name|pps_fd
operator|=
name|pp
operator|->
name|io
operator|.
name|fd
expr_stmt|;
if|if
condition|(
name|refclock_ppsapi
argument_list|(
name|pps_fd
argument_list|,
operator|&
name|up
operator|->
name|atom
argument_list|)
condition|)
block|{
name|up
operator|->
name|ppsapi_lit
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|ppsapi_fd
operator|=
name|pps_fd
expr_stmt|;
comment|/* prepare to use the PPS API for our own purposes now. */
name|refclock_params
argument_list|(
name|pp
operator|->
name|sloppyclockflag
argument_list|,
operator|&
name|up
operator|->
name|atom
argument_list|)
expr_stmt|;
return|return;
block|}
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s flag1 1 but PPSAPI fails"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * nmea_timer - called once per second, fetches PPS  *		timestamp and stuffs in median filter.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_function
specifier|static
name|void
name|nmea_timer
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|nmeaunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|nmeaunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ppsapi_lit
operator|&&
name|up
operator|->
name|ppsapi_gate
operator|&&
name|refclock_pps
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|atom
argument_list|,
name|pp
operator|->
name|sloppyclockflag
argument_list|)
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|pcount
operator|++
operator|,
name|peer
operator|->
name|flags
operator||=
name|FLAG_PPS
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PPS_PRECISION
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_comment
comment|/*  * This function is used to correlate a receive time stamp and a  * reference time with a PPS edge time stamp. It applies the necessary  * fudges (fudge1 for PPS, fudge2 for receive time) and then tries to  * move the receive time stamp to the corresponding edge. This can  * warp into future, if a transmission delay of more than 500ms is not  * compensated with a corresponding fudge time2 value, because then  * the next PPS edge is nearer than the last. (Similiar to what the  * PPS ATOM driver does, but we deal with full time stamps here, not  * just phase shift information.) Likewise, a negative fudge time2  * value must be used if the reference time stamp correlates with the  * *following* PPS pulse.  *  * Note that the receive time fudge value only needs to move the receive  * stamp near a PPS edge but that close proximity is not required;  * +/-100ms precision should be enough. But since the fudge value will  * probably also be used to compensate the transmission delay when no PPS  * edge can be related to the time stamp, it's best to get it as close  * as possible.  *  * It should also be noted that the typical use case is matching to  * the preceeding edge, as most units relate their sentences to the  * current second.  *  * The function returns PPS_RELATE_NONE (0) if no PPS edge correlation  * can be fixed; PPS_RELATE_EDGE (1) when a PPS edge could be fixed, but  * the distance to the reference time stamp is too big (exceeds +/-400ms)  * and the ATOM driver PLL cannot be used to fix the phase; and  * PPS_RELATE_PHASE (2) when the ATOM driver PLL code can be used.  *  * On output, the receive time stamp is replaced with the  * corresponding PPS edge time if a fix could be made; the PPS fudge  * is updated to reflect the proper fudge time to apply. (This implies  * that 'refclock_process_f()' must be used!)  */
end_comment

begin_define
define|#
directive|define
name|PPS_RELATE_NONE
value|0
end_define

begin_comment
comment|/* no pps correlation possible	  */
end_comment

begin_define
define|#
directive|define
name|PPS_RELATE_EDGE
value|1
end_define

begin_comment
comment|/* recv time fixed, no phase lock */
end_comment

begin_define
define|#
directive|define
name|PPS_RELATE_PHASE
value|2
end_define

begin_comment
comment|/* recv time fixed, phase lock ok */
end_comment

begin_function
specifier|static
name|int
name|refclock_ppsrelate
parameter_list|(
specifier|const
name|struct
name|refclockproc
modifier|*
name|pp
parameter_list|,
comment|/* for sanity	  */
specifier|const
name|struct
name|refclock_atom
modifier|*
name|ap
parameter_list|,
comment|/* for PPS io	  */
specifier|const
name|l_fp
modifier|*
name|reftime
parameter_list|,
name|l_fp
modifier|*
name|rd_stamp
parameter_list|,
comment|/* i/o read stamp */
name|double
name|pp_fudge
parameter_list|,
comment|/* pps fudge	  */
name|double
modifier|*
name|rd_fudge
parameter_list|)
comment|/* i/o read fudge */
block|{
name|pps_info_t
name|pps_info
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|l_fp
name|pp_stamp
decl_stmt|,
name|pp_delta
decl_stmt|;
name|double
name|delta
decl_stmt|,
name|idelta
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
return|return
name|PPS_RELATE_NONE
return|;
comment|/* clock is insane, no chance */
name|memset
argument_list|(
operator|&
name|timeout
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pps_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pps_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|ap
operator|->
name|handle
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|pps_info
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
return|return
name|PPS_RELATE_NONE
return|;
comment|/* get last active PPS edge before receive */
if|if
condition|(
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTUREASSERT
condition|)
name|timeout
operator|=
name|pps_info
operator|.
name|assert_timestamp
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|pps_params
operator|.
name|mode
operator|&
name|PPS_CAPTURECLEAR
condition|)
name|timeout
operator|=
name|pps_info
operator|.
name|clear_timestamp
expr_stmt|;
else|else
return|return
name|PPS_RELATE_NONE
return|;
comment|/* get delta between receive time and PPS time */
name|TIMESPECTOTS
argument_list|(
operator|&
name|timeout
argument_list|,
operator|&
name|pp_stamp
argument_list|)
expr_stmt|;
name|pp_delta
operator|=
operator|*
name|rd_stamp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|pp_delta
argument_list|,
operator|&
name|pp_stamp
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|pp_delta
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|+=
name|pp_fudge
operator|-
operator|*
name|rd_fudge
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|delta
argument_list|)
operator|>
literal|1.5
condition|)
return|return
name|PPS_RELATE_NONE
return|;
comment|/* PPS timeout control */
comment|/* eventually warp edges, check phase */
name|idelta
operator|=
name|floor
argument_list|(
name|delta
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|pp_fudge
operator|-=
name|idelta
expr_stmt|;
name|delta
operator|-=
name|idelta
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|delta
argument_list|)
operator|>
literal|0.45
condition|)
return|return
name|PPS_RELATE_NONE
return|;
comment|/* dead band control */
comment|/* we actually have a PPS edge to relate with! */
operator|*
name|rd_stamp
operator|=
name|pp_stamp
expr_stmt|;
operator|*
name|rd_fudge
operator|=
name|pp_fudge
expr_stmt|;
comment|/* if whole system out-of-sync, do not try to PLL */
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
condition|)
return|return
name|PPS_RELATE_EDGE
return|;
comment|/* cannot PLL with atom code */
comment|/* check against reftime if ATOM PLL can be used */
name|pp_delta
operator|=
operator|*
name|reftime
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|pp_delta
argument_list|,
operator|&
name|pp_stamp
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|pp_delta
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|+=
name|pp_fudge
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|delta
argument_list|)
operator|>
literal|0.45
condition|)
return|return
name|PPS_RELATE_EDGE
return|;
comment|/* cannot PLL with atom code */
comment|/* all checks passed, gets an AAA rating here! */
return|return
name|PPS_RELATE_PHASE
return|;
comment|/* can PLL with atom code */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_comment
comment|/*  * nmea_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|nmea_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|nmeaunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|u_char
name|sentence
decl_stmt|;
comment|/* Use these variables to hold data until we decide its worth 	 * keeping */
name|char
name|rd_lastcode
index|[
name|BMAX
index|]
decl_stmt|;
name|l_fp
name|rd_timestamp
decl_stmt|,
name|reftime
decl_stmt|;
name|int
name|rd_lencode
decl_stmt|;
name|double
name|rd_fudge
decl_stmt|;
name|struct
name|calendar
name|date
decl_stmt|;
comment|/* 	 * Initialize pointers and read the timecode and timestamp 	 */
name|peer
operator|=
name|rbufp
operator|->
name|recv_peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|nmeaunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|rd_lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|rd_lastcode
argument_list|,
sizeof|sizeof
argument_list|(
name|rd_lastcode
argument_list|)
argument_list|,
operator|&
name|rd_timestamp
argument_list|)
expr_stmt|;
comment|/* 	 * There is a case that a<CR><LF> gives back a "blank" line. 	 * We can't have a well-formed sentence with less than 8 chars. 	 */
if|if
condition|(
literal|0
operator|==
name|rd_lencode
condition|)
return|return;
if|if
condition|(
name|rd_lencode
operator|<
literal|8
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"nmea: gpsread %d %s\n"
operator|,
name|rd_lencode
operator|,
name|rd_lastcode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We check the timecode format and decode its contents. The 	 * we only care about a few of them.  The most important being 	 * the $GPRMC format 	 * $GPRMC,hhmmss,a,fddmm.xx,n,dddmmm.xx,w,zz.z,yyy.,ddmmyy,dd,v*CC 	 * mode (0,1,2,3) selects sentence ANY/ALL, RMC, GGA, GLL, ZDA 	 * $GPGLL,3513.8385,S,14900.7851,E,232420.594,A*21 	 * $GPGGA,232420.59,3513.8385,S,14900.7851,E,1,05,3.4,00519,M,,,,*3F 	 * $GPRMC,232418.19,A,3513.8386,S,14900.7853,E,00.0,000.0,121199,12.,E*77 	 * 	 * Defining GPZDA to support Standard Time& Date 	 * sentence. The sentence has the following format  	 *   	 *  $--ZDA,HHMMSS.SS,DD,MM,YYYY,TH,TM,*CS<CR><LF> 	 * 	 *  Apart from the familiar fields,  	 *  'TH'    Time zone Hours 	 *  'TM'    Time zone Minutes 	 * 	 * Defining GPZDG to support Accord GPS Clock's custom NMEA  	 * sentence. The sentence has the following format  	 *   	 *  $GPZDG,HHMMSS.S,DD,MM,YYYY,AA.BB,V*CS<CR><LF> 	 * 	 *  It contains the GPS timestamp valid for next PPS pulse. 	 *  Apart from the familiar fields,  	 *  'AA.BB' denotes the signal strength( should be< 05.00 )  	 *  'V'	    denotes the GPS sync status :  	 *	   '0' indicates INVALID time,  	 *	   '1' indicates accuracy of +/-20 ms 	 *	   '2' indicates accuracy of +/-100 ns 	 */
name|cp
operator|=
name|rd_lastcode
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
comment|/* Allow for GLGGA and GPGGA etc. */
name|msg
operator|=
name|cp
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|msg
argument_list|,
literal|"RMC"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPRMC
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|msg
argument_list|,
literal|"GGA"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPGGA
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|msg
argument_list|,
literal|"GLL"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPGLL
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|msg
argument_list|,
literal|"ZDG"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPZDG
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|msg
argument_list|,
literal|"ZDA"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|sentence
operator|=
name|NMEA_GPZDA
expr_stmt|;
else|else
return|return;
block|}
else|else
return|return;
comment|/* See if I want to process this message type */
if|if
condition|(
operator|(
name|peer
operator|->
name|ttl
operator|&
name|NMEA_MESSAGE_MASK
operator|)
operator|&&
operator|!
operator|(
name|peer
operator|->
name|ttl
operator|&
name|sentence_mode
index|[
name|sentence
index|]
operator|)
condition|)
return|return;
comment|/*  	 * $GPZDG provides GPS time not UTC, and the two mix poorly. 	 * Once have processed a $GPZDG, do not process any further 	 * UTC sentences (all but $GPZDG currently). 	 */
if|if
condition|(
name|up
operator|->
name|gps_time
operator|&&
name|NMEA_GPZDG
operator|!=
name|sentence
condition|)
return|return;
comment|/* 	 * Apparently, older NMEA specifications (which are expensive) 	 * did not require the checksum for all sentences.  $GPMRC is 	 * the only one so far identified which has always been required 	 * to include a checksum. 	 * 	 * Today, most NMEA GPS receivers checksum every sentence.  To 	 * preserve its error-detection capabilities with modern GPSes 	 * while allowing operation without checksums on all but $GPMRC, 	 * we keep track of whether we've ever seen a checksum on a 	 * given sentence, and if so, reject future checksum failures. 	 */
if|if
condition|(
name|nmea_checksum_ok
argument_list|(
name|rd_lastcode
argument_list|)
condition|)
block|{
name|up
operator|->
name|cksum_seen
index|[
name|sentence
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NMEA_GPRMC
operator|==
name|sentence
operator|||
name|up
operator|->
name|cksum_seen
index|[
name|sentence
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|rd_lastcode
expr_stmt|;
comment|/* Grab field depending on clock string type */
name|memset
argument_list|(
operator|&
name|date
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|date
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sentence
condition|)
block|{
case|case
name|NMEA_GPRMC
case|:
comment|/* 		 * Test for synchronization.  Check for quality byte. 		 */
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|!=
literal|'A'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
comment|/* Now point at the time field */
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPGGA
case|:
comment|/* 		 * Test for synchronization.  Check for quality byte. 		 */
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
comment|/* Now point at the time field */
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPGLL
case|:
comment|/* 		 * Test for synchronization.  Check for quality byte. 		 */
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|!=
literal|'A'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
comment|/* Now point at the time field */
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPZDG
case|:
comment|/* For $GPZDG check for validity of GPS time. */
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
comment|/* fall through to NMEA_GPZDA */
case|case
name|NMEA_GPZDA
case|:
if|if
condition|(
name|NMEA_GPZDA
operator|==
name|sentence
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
comment|/* Now point at the time field */
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
comment|/* 	 * Check time code format of NMEA 	 */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dp
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dp
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dp
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dp
index|[
literal|3
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dp
index|[
literal|4
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dp
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"NMEA time code %c%c%c%c%c%c non-numeric"
operator|,
name|dp
index|[
literal|0
index|]
operator|,
name|dp
index|[
literal|1
index|]
operator|,
name|dp
index|[
literal|2
index|]
operator|,
name|dp
index|[
literal|3
index|]
operator|,
name|dp
index|[
literal|4
index|]
operator|,
name|dp
index|[
literal|5
index|]
operator|)
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Convert time and check values. 	 */
name|date
operator|.
name|hour
operator|=
operator|(
operator|(
name|dp
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
name|dp
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|date
operator|.
name|minute
operator|=
operator|(
operator|(
name|dp
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
name|dp
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
name|date
operator|.
name|second
operator|=
operator|(
operator|(
name|dp
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|)
operator|+
name|dp
index|[
literal|5
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/*  	 * Default to 0 milliseconds, if decimal convert milliseconds in 	 * one, two or three digits 	 */
name|pp
operator|->
name|nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|6
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dp
index|[
literal|7
index|]
argument_list|)
condition|)
block|{
name|pp
operator|->
name|nsec
operator|=
operator|(
name|dp
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|100000000
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dp
index|[
literal|8
index|]
argument_list|)
condition|)
block|{
name|pp
operator|->
name|nsec
operator|+=
operator|(
name|dp
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10000000
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|dp
index|[
literal|9
index|]
argument_list|)
condition|)
block|{
name|pp
operator|->
name|nsec
operator|+=
operator|(
name|dp
index|[
literal|9
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|1000000
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|date
operator|.
name|hour
operator|>
literal|23
operator|||
name|date
operator|.
name|minute
operator|>
literal|59
operator|||
name|date
operator|.
name|second
operator|>
literal|59
operator|||
name|pp
operator|->
name|nsec
operator|>
literal|1000000000
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"NMEA hour/min/sec/nsec range %02d:%02d:%02d.%09ld\n"
operator|,
name|pp
operator|->
name|hour
operator|,
name|pp
operator|->
name|minute
operator|,
name|pp
operator|->
name|second
operator|,
name|pp
operator|->
name|nsec
operator|)
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Used only the first recognized sentence each second. 	 */
if|if
condition|(
name|date
operator|.
name|hour
operator|==
name|up
operator|->
name|used
operator|.
name|hour
operator|&&
name|date
operator|.
name|minute
operator|==
name|up
operator|->
name|used
operator|.
name|minute
operator|&&
name|date
operator|.
name|second
operator|==
name|up
operator|->
name|used
operator|.
name|second
condition|)
return|return;
name|pp
operator|->
name|lencode
operator|=
operator|(
name|u_short
operator|)
name|rd_lencode
expr_stmt|;
name|memcpy
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
name|rd_lastcode
argument_list|,
name|pp
operator|->
name|lencode
operator|+
literal|1
argument_list|)
expr_stmt|;
name|up
operator|->
name|tstamp
operator|=
name|rd_timestamp
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|tstamp
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"nmea: timecode %d %s\n"
operator|,
name|pp
operator|->
name|lencode
operator|,
name|pp
operator|->
name|a_lastcode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert date and check values. 	 */
if|if
condition|(
name|NMEA_GPRMC
operator|==
name|sentence
condition|)
block|{
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|date
operator|.
name|monthday
operator|=
literal|10
operator|*
operator|(
name|dp
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|+
operator|(
name|dp
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|date
operator|.
name|month
operator|=
literal|10
operator|*
operator|(
name|dp
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|+
operator|(
name|dp
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|date
operator|.
name|year
operator|=
literal|10
operator|*
operator|(
name|dp
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
operator|+
operator|(
name|dp
index|[
literal|5
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|nmea_century_unfold
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NMEA_GPZDA
operator|==
name|sentence
operator|||
name|NMEA_GPZDG
operator|==
name|sentence
condition|)
block|{
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|date
operator|.
name|monthday
operator|=
literal|10
operator|*
operator|(
name|dp
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|+
operator|(
name|dp
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|date
operator|.
name|month
operator|=
literal|10
operator|*
operator|(
name|dp
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|+
operator|(
name|dp
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|date
operator|.
name|year
operator|=
literal|1000
operator|*
operator|(
name|dp
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|+
literal|100
operator|*
operator|(
name|dp
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|+
literal|10
operator|*
operator|(
name|dp
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|+
operator|(
name|dp
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
name|nmea_day_unfold
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|.
name|month
operator|<
literal|1
operator|||
name|date
operator|.
name|month
operator|>
literal|12
operator|||
name|date
operator|.
name|monthday
operator|<
literal|1
operator|||
name|date
operator|.
name|monthday
operator|>
literal|31
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|used
operator|.
name|hour
operator|=
name|date
operator|.
name|hour
expr_stmt|;
name|up
operator|->
name|used
operator|.
name|minute
operator|=
name|date
operator|.
name|minute
expr_stmt|;
name|up
operator|->
name|used
operator|.
name|second
operator|=
name|date
operator|.
name|second
expr_stmt|;
comment|/* 	 * If "fudge 127.127.20.__ flag4 1" is configured in ntp.conf, 	 * remove the location and checksum from the NMEA sentence 	 * recorded as the last timecode and visible to remote users 	 * with: 	 * 	 * ntpq -c clockvar<server> 	 * 	 * Note that this also removes the location from the clockstats 	 * log (if it is enabled).  Some NTP operators monitor their 	 * NMEA GPS using the change in location in clockstats over 	 * time as as a proxy for the quality of GPS reception and 	 * thereby time reported. 	 */
if|if
condition|(
name|CLK_FLAG4
operator|&
name|pp
operator|->
name|sloppyclockflag
condition|)
block|{
comment|/* 		 * Start by pointing cp and dp at the fields with  		 * longitude and latitude in the last timecode. 		 */
switch|switch
condition|(
name|sentence
condition|)
block|{
case|case
name|NMEA_GPGLL
case|:
name|cp
operator|=
name|field_parse
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPGGA
case|:
name|cp
operator|=
name|field_parse
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPRMC
case|:
name|cp
operator|=
name|field_parse
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|dp
operator|=
name|field_parse
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|NMEA_GPZDA
case|:
case|case
name|NMEA_GPZDG
case|:
default|default:
name|cp
operator|=
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Blank the entire latitude& longitude. */
while|while
condition|(
name|cp
condition|)
block|{
while|while
condition|(
literal|','
operator|!=
operator|*
name|cp
condition|)
block|{
if|if
condition|(
literal|'.'
operator|!=
operator|*
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'_'
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
comment|/* Longitude at cp then latitude at dp */
if|if
condition|(
name|cp
operator|<
name|dp
condition|)
name|cp
operator|=
name|dp
expr_stmt|;
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Blank the checksum, the last two characters */
if|if
condition|(
name|dp
condition|)
block|{
name|cp
operator|=
name|pp
operator|->
name|a_lastcode
operator|+
name|pp
operator|->
name|lencode
operator|-
literal|2
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|cp
index|[
literal|2
index|]
condition|)
name|cp
index|[
literal|0
index|]
operator|=
name|cp
index|[
literal|1
index|]
operator|=
literal|'_'
expr_stmt|;
block|}
block|}
comment|/* 	 * Get the reference time stamp from the calendar buffer. 	 * Process the new sample in the median filter and determine 	 * the timecode timestamp, but only if the PPS is not in 	 * control. 	 */
name|rd_fudge
operator|=
name|pp
operator|->
name|fudgetime2
expr_stmt|;
name|date
operator|.
name|yearday
operator|=
literal|0
expr_stmt|;
comment|/* make sure it's not used */
name|DTOLFP
argument_list|(
name|pp
operator|->
name|nsec
operator|*
literal|1.0e-9
argument_list|,
operator|&
name|reftime
argument_list|)
expr_stmt|;
name|reftime
operator|.
name|l_ui
operator|+=
name|caltontp
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
comment|/* $GPZDG postprocessing first... */
if|if
condition|(
name|NMEA_GPZDG
operator|==
name|sentence
condition|)
block|{
comment|/* 		 * Note if we're only using GPS timescale from now on. 		 */
if|if
condition|(
operator|!
name|up
operator|->
name|gps_time
condition|)
block|{
name|up
operator|->
name|gps_time
operator|=
literal|1
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s using only $GPZDG"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * $GPZDG indicates the second after the *next* PPS 		 * pulse. So we remove 1 second from the reference 		 * time now. 		 */
name|reftime
operator|.
name|l_ui
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
name|up
operator|->
name|tcount
operator|++
expr_stmt|;
comment|/* 	 * If we have PPS running, we try to associate the sentence with 	 * the last active edge of the PPS signal. 	 */
if|if
condition|(
name|up
operator|->
name|ppsapi_lit
condition|)
switch|switch
condition|(
name|refclock_ppsrelate
argument_list|(
name|pp
argument_list|,
operator|&
name|up
operator|->
name|atom
argument_list|,
operator|&
name|reftime
argument_list|,
operator|&
name|rd_timestamp
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|,
operator|&
name|rd_fudge
argument_list|)
condition|)
block|{
case|case
name|PPS_RELATE_EDGE
case|:
name|up
operator|->
name|ppsapi_gate
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PPS_RELATE_PHASE
case|:
name|up
operator|->
name|ppsapi_gate
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
else|else
name|up
operator|->
name|ppsapi_gate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ppsapi_gate
operator|&&
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PPS
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|reftime
argument_list|,
name|rd_timestamp
argument_list|,
name|rd_fudge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * nmea_poll - called by the transmit procedure  *  * We go to great pains to avoid changing state here, since there may be  * more than one eavesdropper receiving the same timecode.  */
end_comment

begin_function
specifier|static
name|void
name|nmea_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|nmeaunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|nmeaunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Process median filter samples. If none received, declare a 	 * timeout and keep going. 	 */
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
if|if
condition|(
name|up
operator|->
name|pcount
operator|==
literal|0
condition|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|tcount
operator|==
literal|0
condition|)
block|{
name|pp
operator|->
name|coderecv
operator|=
name|pp
operator|->
name|codeproc
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|pcount
operator|=
name|up
operator|->
name|tcount
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* HAVE_PPSAPI */
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_PPSAPI */
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
comment|/* 	 * usually nmea_receive can get a timestamp every second,  	 * but at least one Motorola unit needs prompting each 	 * time. 	 */
name|gps_send
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"$PMOTG,RMC,0000*1D\r\n"
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  *	gps_send(fd,cmd, peer)	Sends a command to the GPS receiver.  *	 as	gps_send(fd,"rqts,u\r", peer);  *  *	We don't currently send any data, but would like to send  *	RTCM SC104 messages for differential positioning. It should  *	also give us better time. Without a PPS output, we're  *	Just fooling ourselves because of the serial code paths  *  */
end_comment

begin_function
specifier|static
name|void
name|gps_send
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|field_parse
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|fn
parameter_list|)
block|{
name|char
modifier|*
name|tp
decl_stmt|;
name|int
name|i
init|=
name|fn
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|cp
init|;
name|i
operator|&&
operator|*
name|tp
condition|;
name|tp
operator|++
control|)
if|if
condition|(
operator|*
name|tp
operator|==
literal|','
condition|)
name|i
operator|--
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/*  * nmea_checksum_ok verifies 8-bit XOR checksum is correct then returns 1  *  * format is $XXXXX,1,2,3,4*ML  *  * 8-bit XOR of characters between $ and * noninclusive is transmitted  * in last two chars M and L holding most and least significant nibbles  * in hex representation such as:  *  *   $GPGLL,5057.970,N,00146.110,E,142451,A*27  *   $GPVTG,089.0,T,,,15.2,N,,*7F  */
end_comment

begin_function
name|int
name|nmea_checksum_ok
parameter_list|(
specifier|const
name|char
modifier|*
name|sentence
parameter_list|)
block|{
name|u_char
name|my_cs
decl_stmt|;
name|u_long
name|input_cs
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|my_cs
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|sentence
expr_stmt|;
if|if
condition|(
literal|'$'
operator|!=
operator|*
name|p
operator|++
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
literal|'*'
operator|!=
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|my_cs
operator|^=
operator|*
name|p
expr_stmt|;
block|}
if|if
condition|(
literal|'*'
operator|!=
operator|*
name|p
operator|++
condition|)
return|return
literal|0
return|;
if|if
condition|(
literal|0
operator|==
name|p
index|[
literal|0
index|]
operator|||
literal|0
operator|==
name|p
index|[
literal|1
index|]
operator|||
literal|0
operator|!=
name|p
index|[
literal|2
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
literal|0
operator|==
name|hextoint
argument_list|(
name|p
argument_list|,
operator|&
name|input_cs
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|my_cs
operator|!=
name|input_cs
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * funny calendar-oriented stuff -- a bit hard to grok.  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * Do a periodic unfolding of a truncated value around a given pivot  * value.  * The result r will hold to pivot<= r< pivot+period (period>0) or  * pivot+period< r<= pivot (period< 0) and value % period == r % period,  * using floor division convention.  */
end_comment

begin_function
specifier|static
name|time_t
name|nmea_periodic_unfold
parameter_list|(
name|time_t
name|pivot
parameter_list|,
name|time_t
name|value
parameter_list|,
name|time_t
name|period
parameter_list|)
block|{
comment|/* 	 * This will only work as long as 'value - pivot%period' does 	 * not create a signed overflow condition. 	 */
name|value
operator|=
operator|(
name|value
operator|-
operator|(
name|pivot
operator|%
name|period
operator|)
operator|)
operator|%
name|period
expr_stmt|;
if|if
condition|(
name|value
operator|&&
operator|(
name|value
operator|^
name|period
operator|)
operator|<
literal|0
condition|)
name|value
operator|+=
name|period
expr_stmt|;
return|return
name|pivot
operator|+
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * Unfold a time-of-day (seconds since midnight) around the current  * system time in a manner that guarantees an absolute difference of  * less than 12hrs.  *  * This function is used for NMEA sentences that contain no date  * information. This requires the system clock to be in +/-12hrs  * around the true time, or the clock will synchronize the system 1day  * off if not augmented with a time sources that also provide the  * necessary date information.  *  * The function updates the refclockproc structure is also uses as  * input to fetch the time from.  */
end_comment

begin_function
specifier|static
name|void
name|nmea_day_unfold
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
name|time_t
name|value
decl_stmt|,
name|pivot
decl_stmt|;
name|struct
name|tm
modifier|*
name|tdate
decl_stmt|;
name|value
operator|=
operator|(
operator|(
name|time_t
operator|)
name|jd
operator|->
name|hour
operator|*
name|MINSPERHR
operator|+
operator|(
name|time_t
operator|)
name|jd
operator|->
name|minute
operator|)
operator|*
name|SECSPERMIN
operator|+
operator|(
name|time_t
operator|)
name|jd
operator|->
name|second
expr_stmt|;
name|pivot
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|SECSPERDAY
operator|/
literal|2
expr_stmt|;
name|value
operator|=
name|nmea_periodic_unfold
argument_list|(
name|pivot
argument_list|,
name|value
argument_list|,
name|SECSPERDAY
argument_list|)
expr_stmt|;
name|tdate
operator|=
name|gmtime
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdate
condition|)
block|{
name|jd
operator|->
name|year
operator|=
name|tdate
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|jd
operator|->
name|yearday
operator|=
name|tdate
operator|->
name|tm_yday
operator|+
literal|1
expr_stmt|;
name|jd
operator|->
name|month
operator|=
name|tdate
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|jd
operator|->
name|monthday
operator|=
name|tdate
operator|->
name|tm_mday
expr_stmt|;
name|jd
operator|->
name|hour
operator|=
name|tdate
operator|->
name|tm_hour
expr_stmt|;
name|jd
operator|->
name|minute
operator|=
name|tdate
operator|->
name|tm_min
expr_stmt|;
name|jd
operator|->
name|second
operator|=
name|tdate
operator|->
name|tm_sec
expr_stmt|;
block|}
else|else
block|{
name|jd
operator|->
name|year
operator|=
literal|0
expr_stmt|;
name|jd
operator|->
name|yearday
operator|=
literal|0
expr_stmt|;
name|jd
operator|->
name|month
operator|=
literal|0
expr_stmt|;
name|jd
operator|->
name|monthday
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Unfold a 2-digit year into full year spec around the current year  * of the system time. This requires the system clock to be in -79/+19  * years around the true time, or the result will be off by  * 100years. The assymetric behaviour was chosen to enable inital sync  * for systems that do not have a battery-backup-clock and start with  * a date that is typically years in the past.  *  * The function updates the calendar structure that is also used as  * input to fetch the year from.  */
end_comment

begin_function
specifier|static
name|void
name|nmea_century_unfold
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
name|time_t
name|pivot_time
decl_stmt|;
name|struct
name|tm
modifier|*
name|pivot_date
decl_stmt|;
name|time_t
name|pivot_year
decl_stmt|;
comment|/* get warp limit and century start of pivot from system time */
name|pivot_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|pivot_date
operator|=
name|gmtime
argument_list|(
operator|&
name|pivot_time
argument_list|)
expr_stmt|;
name|pivot_year
operator|=
name|pivot_date
operator|->
name|tm_year
operator|+
literal|1900
operator|-
literal|20
expr_stmt|;
name|jd
operator|->
name|year
operator|=
name|nmea_periodic_unfold
argument_list|(
name|pivot_year
argument_list|,
name|jd
operator|->
name|year
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_nmea_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK&& CLOCK_NMEA */
end_comment

end_unit

