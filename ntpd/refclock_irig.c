begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_irig - audio IRIG-B/E demodulator/decoder  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_IRIG
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_IOCTL_H */
end_comment

begin_include
include|#
directive|include
file|"audio.h"
end_include

begin_comment
comment|/*  * Audio IRIG-B/E demodulator/decoder  *  * This driver synchronizes the computer time using data encoded in  * IRIG-B/E signals commonly produced by GPS receivers and other timing  * devices. The IRIG signal is an amplitude-modulated carrier with  * pulse-width modulated data bits. For IRIG-B, the carrier frequency is  * 1000 Hz and bit rate 100 b/s; for IRIG-E, the carrier frequenchy is  * 100 Hz and bit rate 10 b/s. The driver automatically recognizes which& format is in use.  *  * The driver requires an audio codec or sound card with sampling rate 8  * kHz and mu-law companding. This is the same standard as used by the  * telephone industry and is supported by most hardware and operating  * systems, including Solaris, SunOS, FreeBSD, NetBSD and Linux. In this  * implementation, only one audio driver and codec can be supported on a  * single machine.  *  * The program processes 8000-Hz mu-law companded samples using separate  * signal filters for IRIG-B and IRIG-E, a comb filter, envelope  * detector and automatic threshold corrector. Cycle crossings relative  * to the corrected slice level determine the width of each pulse and  * its value - zero, one or position identifier.  *  * The data encode 20 BCD digits which determine the second, minute,  * hour and day of the year and sometimes the year and synchronization  * condition. The comb filter exponentially averages the corresponding  * samples of successive baud intervals in order to reliably identify  * the reference carrier cycle. A type-II phase-lock loop (PLL) performs  * additional integration and interpolation to accurately determine the  * zero crossing of that cycle, which determines the reference  * timestamp. A pulse-width discriminator demodulates the data pulses,  * which are then encoded as the BCD digits of the timecode.  *  * The timecode and reference timestamp are updated once each second  * with IRIG-B (ten seconds with IRIG-E) and local clock offset samples  * saved for later processing. At poll intervals of 64 s, the saved  * samples are processed by a trimmed-mean filter and used to update the  * system clock.  *  * An automatic gain control feature provides protection against  * overdriven or underdriven input signal amplitudes. It is designed to  * maintain adequate demodulator signal amplitude while avoiding  * occasional noise spikes. In order to assure reliable capture, the  * decompanded input signal amplitude must be greater than 100 units and  * the codec sample frequency error less than 250 PPM (.025 percent).  *  * Monitor Data  *  * The timecode format used for debugging and data recording includes  * data helpful in diagnosing problems with the IRIG signal and codec  * connections. The driver produces one line for each timecode in the  * following format:  *  * 00 00 98 23 19:26:52 2782 143 0.694 10 0.3 66.5 3094572411.00027  *  * If clockstats is enabled, the most recent line is written to the  * clockstats file every 64 s. If verbose recording is enabled (fudge  * flag 4) each line is written as generated.  *  * The first field containes the error flags in hex, where the hex bits  * are interpreted as below. This is followed by the year of century,  * day of year and time of day. Note that the time of day is for the  * previous minute, not the current time. The status indicator and year  * are not produced by some IRIG devices and appear as zeros. Following  * these fields are the carrier amplitude (0-3000), codec gain (0-255),  * modulation index (0-1), time constant (4-10), carrier phase error  * +-.5) and carrier frequency error (PPM). The last field is the on-  * time timestamp in NTP format.  *  * The error flags are defined as follows in hex:  *  * x01	Low signal. The carrier amplitude is less than 100 units. This  *	is usually the result of no signal or wrong input port.  * x02	Frequency error. The codec frequency error is greater than 250  *	PPM. This may be due to wrong signal format or (rarely)  *	defective codec.  * x04	Modulation error. The IRIG modulation index is less than 0.5.  *	This is usually the result of an overdriven codec, wrong signal  *	format or wrong input port.  * x08	Frame synch error. The decoder frame does not match the IRIG  *	frame. This is usually the result of an overdriven codec, wrong  *	signal format or noisy IRIG signal. It may also be the result of  *	an IRIG signature check which indicates a failure of the IRIG  *	signal synchronization source.  * x10	Data bit error. The data bit length is out of tolerance. This is  *	usually the result of an overdriven codec, wrong signal format  *	or noisy IRIG signal.  * x20	Seconds numbering discrepancy. The decoder second does not match  *	the IRIG second. This is usually the result of an overdriven  *	codec, wrong signal format or noisy IRIG signal.  * x40	Codec error (overrun). The machine is not fast enough to keep up  *	with the codec.  * x80	Device status error (Spectracom).  *  *  * Once upon a time, an UltrSPARC 30 and Solaris 2.7 kept the clock  * within a few tens of microseconds relative to the IRIG-B signal.  * Accuracy with IRIG-E was about ten times worse. Unfortunately, Sun  * broke the 2.7 audio driver in 2.8, which has a 10-ms sawtooth  * modulation.  *  * Unlike other drivers, which can have multiple instantiations, this  * one supports only one. It does not seem likely that more than one  * audio codec would be useful in a single machine. More than one would  * probably chew up too much CPU time anyway.  *  * Fudge factors  *  * Fudge flag4 causes the dubugging output described above to be  * recorded in the clockstats file. Fudge flag2 selects the audio input  * port, where 0 is the mike port (default) and 1 is the line-in port.  * It does not seem useful to select the compact disc player port. Fudge  * flag3 enables audio monitoring of the input signal. For this purpose,  * the monitor gain is set t a default value. Fudgetime2 is used as a  * frequency vernier for broken codec sample frequency.  *  * Alarm codes  *  * CEVNT_BADTIME	invalid date or time  * CEVNT_TIMEOUT	no IRIG data since last poll  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE_AUDIO
value|"/dev/audio"
end_define

begin_comment
comment|/* audio device name */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-17)
end_define

begin_comment
comment|/* precision assumed (about 10 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"IRIG"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Generic IRIG Audio Driver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|AUDIO_BUFSIZ
value|320
end_define

begin_comment
comment|/* audio buffer size (40 ms) */
end_comment

begin_define
define|#
directive|define
name|SECOND
value|8000
end_define

begin_comment
comment|/* nominal sample rate (Hz) */
end_comment

begin_define
define|#
directive|define
name|BAUD
value|80
end_define

begin_comment
comment|/* samples per baud interval */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|128
end_define

begin_comment
comment|/* companded sample offset */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|256
end_define

begin_comment
comment|/* decompanding table size */
end_comment

begin_define
define|#
directive|define
name|CYCLE
value|8
end_define

begin_comment
comment|/* samples per bit */
end_comment

begin_define
define|#
directive|define
name|SUBFLD
value|10
end_define

begin_comment
comment|/* bits per frame */
end_comment

begin_define
define|#
directive|define
name|FIELD
value|100
end_define

begin_comment
comment|/* bits per second */
end_comment

begin_define
define|#
directive|define
name|MINTC
value|2
end_define

begin_comment
comment|/* min PLL time constant */
end_comment

begin_define
define|#
directive|define
name|MAXTC
value|10
end_define

begin_comment
comment|/* max PLL time constant max */
end_comment

begin_define
define|#
directive|define
name|MAXAMP
value|3000.
end_define

begin_comment
comment|/* maximum signal amplitude */
end_comment

begin_define
define|#
directive|define
name|MINAMP
value|2000.
end_define

begin_comment
comment|/* minimum signal amplitude */
end_comment

begin_define
define|#
directive|define
name|DRPOUT
value|100.
end_define

begin_comment
comment|/* dropout signal amplitude */
end_comment

begin_define
define|#
directive|define
name|MODMIN
value|0.5
end_define

begin_comment
comment|/* minimum modulation index */
end_comment

begin_define
define|#
directive|define
name|MAXFREQ
value|(250e-6 * SECOND)
end_define

begin_comment
comment|/* freq tolerance (.025%) */
end_comment

begin_comment
comment|/*  * The on-time synchronization point is the positive-going zero crossing  * of the first cycle of the second. The IIR baseband filter phase delay  * is 1.03 ms for IRIG-B and 3.47 ms for IRIG-E. The fudge value 2.68 ms  * due to the codec and other causes was determined by calibrating to a  * PPS signal from a GPS receiver.  *  * The results with a 2.4-GHz P4 running FreeBSD 6.1 are generally  * within .02 ms short-term with .02 ms jitter. The processor load due  * to the driver is 0.51 percent.  */
end_comment

begin_define
define|#
directive|define
name|IRIG_B
value|((1.03 + 2.68) / 1000)
end_define

begin_comment
comment|/* IRIG-B system delay (s) */
end_comment

begin_define
define|#
directive|define
name|IRIG_E
value|((3.47 + 2.68) / 1000)
end_define

begin_comment
comment|/* IRIG-E system delay (s) */
end_comment

begin_comment
comment|/*  * Data bit definitions  */
end_comment

begin_define
define|#
directive|define
name|BIT0
value|0
end_define

begin_comment
comment|/* zero */
end_comment

begin_define
define|#
directive|define
name|BIT1
value|1
end_define

begin_comment
comment|/* one */
end_comment

begin_define
define|#
directive|define
name|BITP
value|2
end_define

begin_comment
comment|/* position identifier */
end_comment

begin_comment
comment|/*  * Error flags  */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_AMP
value|0x01
end_define

begin_comment
comment|/* low carrier amplitude */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_FREQ
value|0x02
end_define

begin_comment
comment|/* frequency tolerance exceeded */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_MOD
value|0x04
end_define

begin_comment
comment|/* low modulation index */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_SYNCH
value|0x08
end_define

begin_comment
comment|/* frame synch error */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_DECODE
value|0x10
end_define

begin_comment
comment|/* frame decoding error */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_CHECK
value|0x20
end_define

begin_comment
comment|/* second numbering discrepancy */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_ERROR
value|0x40
end_define

begin_comment
comment|/* codec error (overrun) */
end_comment

begin_define
define|#
directive|define
name|IRIG_ERR_SIGERR
value|0x80
end_define

begin_comment
comment|/* IRIG status error (Spectracom) */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hexchar
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IRIG unit control structure  */
end_comment

begin_struct
struct|struct
name|irigunit
block|{
name|u_char
name|timecode
index|[
literal|2
operator|*
name|SUBFLD
operator|+
literal|1
index|]
decl_stmt|;
comment|/* timecode string */
name|l_fp
name|timestamp
decl_stmt|;
comment|/* audio sample timestamp */
name|l_fp
name|tick
decl_stmt|;
comment|/* audio sample increment */
name|l_fp
name|refstamp
decl_stmt|;
comment|/* reference timestamp */
name|l_fp
name|chrstamp
decl_stmt|;
comment|/* baud timestamp */
name|l_fp
name|prvstamp
decl_stmt|;
comment|/* previous baud timestamp */
name|double
name|integ
index|[
name|BAUD
index|]
decl_stmt|;
comment|/* baud integrator */
name|double
name|phase
decl_stmt|,
name|freq
decl_stmt|;
comment|/* logical clock phase and frequency */
name|double
name|zxing
decl_stmt|;
comment|/* phase detector integrator */
name|double
name|yxing
decl_stmt|;
comment|/* cycle phase */
name|double
name|exing
decl_stmt|;
comment|/* envelope phase */
name|double
name|modndx
decl_stmt|;
comment|/* modulation index */
name|double
name|irig_b
decl_stmt|;
comment|/* IRIG-B signal amplitude */
name|double
name|irig_e
decl_stmt|;
comment|/* IRIG-E signal amplitude */
name|int
name|errflg
decl_stmt|;
comment|/* error flags */
comment|/* 	 * Audio codec variables 	 */
name|double
name|comp
index|[
name|SIZE
index|]
decl_stmt|;
comment|/* decompanding table */
name|double
name|signal
decl_stmt|;
comment|/* peak signal for AGC */
name|int
name|port
decl_stmt|;
comment|/* codec port */
name|int
name|gain
decl_stmt|;
comment|/* codec gain */
name|int
name|mongain
decl_stmt|;
comment|/* codec monitor gain */
name|int
name|seccnt
decl_stmt|;
comment|/* second interval counter */
comment|/* 	 * RF variables 	 */
name|double
name|bpf
index|[
literal|9
index|]
decl_stmt|;
comment|/* IRIG-B filter shift register */
name|double
name|lpf
index|[
literal|5
index|]
decl_stmt|;
comment|/* IRIG-E filter shift register */
name|double
name|envmin
decl_stmt|,
name|envmax
decl_stmt|;
comment|/* envelope min and max */
name|double
name|slice
decl_stmt|;
comment|/* envelope slice level */
name|double
name|intmin
decl_stmt|,
name|intmax
decl_stmt|;
comment|/* integrated envelope min and max */
name|double
name|maxsignal
decl_stmt|;
comment|/* integrated peak amplitude */
name|double
name|noise
decl_stmt|;
comment|/* integrated noise amplitude */
name|double
name|lastenv
index|[
name|CYCLE
index|]
decl_stmt|;
comment|/* last cycle amplitudes */
name|double
name|lastint
index|[
name|CYCLE
index|]
decl_stmt|;
comment|/* last integrated cycle amplitudes */
name|double
name|lastsig
decl_stmt|;
comment|/* last carrier sample */
name|double
name|fdelay
decl_stmt|;
comment|/* filter delay */
name|int
name|decim
decl_stmt|;
comment|/* sample decimation factor */
name|int
name|envphase
decl_stmt|;
comment|/* envelope phase */
name|int
name|envptr
decl_stmt|;
comment|/* envelope phase pointer */
name|int
name|envsw
decl_stmt|;
comment|/* envelope state */
name|int
name|envxing
decl_stmt|;
comment|/* envelope slice crossing */
name|int
name|tc
decl_stmt|;
comment|/* time constant */
name|int
name|tcount
decl_stmt|;
comment|/* time constant counter */
name|int
name|badcnt
decl_stmt|;
comment|/* decimation interval counter */
comment|/* 	 * Decoder variables 	 */
name|int
name|pulse
decl_stmt|;
comment|/* cycle counter */
name|int
name|cycles
decl_stmt|;
comment|/* carrier cycles */
name|int
name|dcycles
decl_stmt|;
comment|/* data cycles */
name|int
name|lastbit
decl_stmt|;
comment|/* last code element */
name|int
name|second
decl_stmt|;
comment|/* previous second */
name|int
name|bitcnt
decl_stmt|;
comment|/* bit count in frame */
name|int
name|frmcnt
decl_stmt|;
comment|/* bit count in second */
name|int
name|xptr
decl_stmt|;
comment|/* timecode pointer */
name|int
name|bits
decl_stmt|;
comment|/* demodulated bits */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|irig_start
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|irig_shutdown
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|irig_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|irig_poll
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * More function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|irig_base
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|irig_rf
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|irig_baud
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|irig_decode
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|irig_gain
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_irig
init|=
block|{
name|irig_start
block|,
comment|/* start up driver */
name|irig_shutdown
block|,
comment|/* shut down driver */
name|irig_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old irig_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old irig_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * irig_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|irig_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (used for PCM) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|i
decl_stmt|;
comment|/* index */
name|double
name|step
decl_stmt|;
comment|/* codec adjustment */
comment|/* 	 * Open audio device 	 */
name|fd
operator|=
name|audio_init
argument_list|(
name|DEVICE_AUDIO
argument_list|,
name|AUDIO_BUFSIZ
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|audio_show
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate and initialize unit structure 	 */
name|up
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|irig_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|tc
operator|=
name|MINTC
expr_stmt|;
name|up
operator|->
name|decim
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|gain
operator|=
literal|127
expr_stmt|;
comment|/* 	 * The companded samples are encoded sign-magnitude. The table 	 * contains all the 256 values in the interest of speed. 	 */
name|up
operator|->
name|comp
index|[
literal|0
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|OFFSET
index|]
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|1
index|]
operator|=
operator|-
literal|1.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|2
index|]
operator|=
operator|-
literal|3.
expr_stmt|;
name|step
operator|=
literal|2.
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|OFFSET
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|comp
index|[
name|i
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|step
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
name|i
index|]
operator|=
operator|-
name|up
operator|->
name|comp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
name|step
operator|*=
literal|2.
expr_stmt|;
block|}
name|DTOLFP
argument_list|(
literal|1.
operator|/
name|SECOND
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * irig_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|irig_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|up
condition|)
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * irig_receive - receive data from the audio device  *  * This routine reads input samples and adjusts the logical clock to  * track the irig clock by dropping or duplicating codec samples.  */
end_comment

begin_function
specifier|static
name|void
name|irig_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|sample
decl_stmt|;
comment|/* codec sample */
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* buffer pointer */
name|int
name|bufcnt
decl_stmt|;
comment|/* buffer counter */
name|l_fp
name|ltemp
decl_stmt|;
comment|/* l_fp temp */
name|peer
operator|=
name|rbufp
operator|->
name|recv_peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Main loop - read until there ain't no more. Note codec 	 * samples are bit-inverted. 	 */
name|DTOLFP
argument_list|(
operator|(
name|double
operator|)
name|rbufp
operator|->
name|recv_length
operator|/
name|SECOND
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|dpt
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
for|for
control|(
name|bufcnt
operator|=
literal|0
init|;
name|bufcnt
operator|<
name|rbufp
operator|->
name|recv_length
condition|;
name|bufcnt
operator|++
control|)
block|{
name|sample
operator|=
name|up
operator|->
name|comp
index|[
operator|~
operator|*
name|dpt
operator|++
operator|&
literal|0xff
index|]
expr_stmt|;
comment|/* 		 * Variable frequency oscillator. The codec oscillator 		 * runs at the nominal rate of 8000 samples per second, 		 * or 125 us per sample. A frequency change of one unit 		 * results in either duplicating or deleting one sample 		 * per second, which results in a frequency change of 		 * 125 PPM. 		 */
name|up
operator|->
name|phase
operator|+=
operator|(
name|up
operator|->
name|freq
operator|+
name|clock_codec
operator|)
operator|/
name|SECOND
expr_stmt|;
name|up
operator|->
name|phase
operator|+=
name|pp
operator|->
name|fudgetime2
operator|/
literal|1e6
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|phase
operator|>=
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|-=
literal|1.
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|phase
operator|<
operator|-
literal|.5
condition|)
block|{
name|up
operator|->
name|phase
operator|+=
literal|1.
expr_stmt|;
name|irig_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
name|irig_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|irig_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
name|L_ADD
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
name|sample
operator|=
name|fabs
argument_list|(
name|sample
argument_list|)
expr_stmt|;
if|if
condition|(
name|sample
operator|>
name|up
operator|->
name|signal
condition|)
name|up
operator|->
name|signal
operator|=
name|sample
expr_stmt|;
name|up
operator|->
name|signal
operator|+=
operator|(
name|sample
operator|-
name|up
operator|->
name|signal
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* 		 * Once each second, determine the IRIG format and gain. 		 */
name|up
operator|->
name|seccnt
operator|=
operator|(
name|up
operator|->
name|seccnt
operator|+
literal|1
operator|)
operator|%
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|seccnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|irig_b
operator|>
name|up
operator|->
name|irig_e
condition|)
block|{
name|up
operator|->
name|decim
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|fdelay
operator|=
name|IRIG_B
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|decim
operator|=
literal|10
expr_stmt|;
name|up
operator|->
name|fdelay
operator|=
name|IRIG_E
expr_stmt|;
block|}
name|up
operator|->
name|irig_b
operator|=
name|up
operator|->
name|irig_e
operator|=
literal|0
expr_stmt|;
name|irig_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set the input port and monitor gain for the next buffer. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|up
operator|->
name|port
operator|=
literal|2
expr_stmt|;
else|else
name|up
operator|->
name|port
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
condition|)
name|up
operator|->
name|mongain
operator|=
name|MONGAIN
expr_stmt|;
else|else
name|up
operator|->
name|mongain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * irig_rf - RF processing  *  * This routine filters the RF signal using a bandass filter for IRIG-B  * and a lowpass filter for IRIG-E. In case of IRIG-E, the samples are  * decimated by a factor of ten. Note that the codec filters function as  * roofing filters to attenuate both the high and low ends of the  * passband. IIR filter coefficients were determined using Matlab Signal  * Processing Toolkit.  */
end_comment

begin_function
specifier|static
name|void
name|irig_rf
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample
comment|/* current signal sample */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|irig_b
decl_stmt|,
name|irig_e
decl_stmt|;
comment|/* irig filter outputs */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * IRIG-B filter. Matlab 4th-order IIR elliptic, 800-1200 Hz 	 * bandpass, 0.3 dB passband ripple, -50 dB stopband ripple, 	 * phase delay 1.03 ms. 	 */
name|irig_b
operator|=
operator|(
name|up
operator|->
name|bpf
index|[
literal|8
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|)
operator|*
literal|6.505491e-001
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|)
operator|*
operator|-
literal|3.875180e+000
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|)
operator|*
literal|1.151180e+001
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|)
operator|*
operator|-
literal|2.141264e+001
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|)
operator|*
literal|2.712837e+001
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|2.384486e+001
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|)
operator|*
literal|1.427663e+001
expr_stmt|;
name|irig_b
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|5.352734e+000
expr_stmt|;
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|=
name|sample
operator|-
name|irig_b
expr_stmt|;
name|irig_b
operator|=
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|*
literal|4.952157e-003
operator|+
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|*
operator|-
literal|2.055878e-002
operator|+
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|*
literal|4.401413e-002
operator|+
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|*
operator|-
literal|6.558851e-002
operator|+
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|*
literal|7.462108e-002
operator|+
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|*
operator|-
literal|6.558851e-002
operator|+
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|*
literal|4.401413e-002
operator|+
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|*
operator|-
literal|2.055878e-002
operator|+
name|up
operator|->
name|bpf
index|[
literal|8
index|]
operator|*
literal|4.952157e-003
expr_stmt|;
name|up
operator|->
name|irig_b
operator|+=
name|irig_b
operator|*
name|irig_b
expr_stmt|;
comment|/* 	 * IRIG-E filter. Matlab 4th-order IIR elliptic, 130-Hz lowpass, 	 * 0.3 dB passband ripple, -50 dB stopband ripple, phase delay 	 * 3.47 ms. 	 */
name|irig_e
operator|=
operator|(
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|)
operator|*
literal|8.694604e-001
expr_stmt|;
name|irig_e
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|)
operator|*
operator|-
literal|3.589893e+000
expr_stmt|;
name|irig_e
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|)
operator|*
literal|5.570154e+000
expr_stmt|;
name|irig_e
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|)
operator|*
operator|-
literal|3.849667e+000
expr_stmt|;
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|=
name|sample
operator|-
name|irig_e
expr_stmt|;
name|irig_e
operator|=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|*
literal|3.215696e-003
operator|+
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|*
operator|-
literal|1.174951e-002
operator|+
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|*
literal|1.712074e-002
operator|+
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|*
operator|-
literal|1.174951e-002
operator|+
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|*
literal|3.215696e-003
expr_stmt|;
name|up
operator|->
name|irig_e
operator|+=
name|irig_e
operator|*
name|irig_e
expr_stmt|;
comment|/* 	 * Decimate by a factor of either 1 (IRIG-B) or 10 (IRIG-E). 	 */
name|up
operator|->
name|badcnt
operator|=
operator|(
name|up
operator|->
name|badcnt
operator|+
literal|1
operator|)
operator|%
name|up
operator|->
name|decim
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|badcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|decim
operator|==
literal|1
condition|)
name|irig_base
argument_list|(
name|peer
argument_list|,
name|irig_b
argument_list|)
expr_stmt|;
else|else
name|irig_base
argument_list|(
name|peer
argument_list|,
name|irig_e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * irig_base - baseband processing  *  * This routine processes the baseband signal and demodulates the AM  * carrier using a synchronous detector. It then synchronizes to the  * data frame at the baud rate and decodes the width-modulated data  * pulses.  */
end_comment

begin_function
specifier|static
name|void
name|irig_base
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample
comment|/* current signal sample */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|lope
decl_stmt|;
comment|/* integrator output */
name|double
name|env
decl_stmt|;
comment|/* envelope detector output */
name|double
name|dtemp
decl_stmt|;
name|int
name|carphase
decl_stmt|;
comment|/* carrier phase */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Synchronous baud integrator. Corresponding samples of current 	 * and past baud intervals are integrated to refine the envelope 	 * amplitude and phase estimate. We keep one cycle (1 ms) of the 	 * raw data and one baud (10 ms) of the integrated data. 	 */
name|up
operator|->
name|envphase
operator|=
operator|(
name|up
operator|->
name|envphase
operator|+
literal|1
operator|)
operator|%
name|BAUD
expr_stmt|;
name|up
operator|->
name|integ
index|[
name|up
operator|->
name|envphase
index|]
operator|+=
operator|(
name|sample
operator|-
name|up
operator|->
name|integ
index|[
name|up
operator|->
name|envphase
index|]
operator|)
operator|/
operator|(
literal|5
operator|*
name|up
operator|->
name|tc
operator|)
expr_stmt|;
name|lope
operator|=
name|up
operator|->
name|integ
index|[
name|up
operator|->
name|envphase
index|]
expr_stmt|;
name|carphase
operator|=
name|up
operator|->
name|envphase
operator|%
name|CYCLE
expr_stmt|;
name|up
operator|->
name|lastenv
index|[
name|carphase
index|]
operator|=
name|sample
expr_stmt|;
name|up
operator|->
name|lastint
index|[
name|carphase
index|]
operator|=
name|lope
expr_stmt|;
comment|/* 	 * Phase detector. Find the negative-going zero crossing 	 * relative to sample 4 in the 8-sample sycle. A phase change of 	 * 360 degrees produces an output change of one unit. 	 */
if|if
condition|(
name|up
operator|->
name|lastsig
operator|>
literal|0
operator|&&
name|lope
operator|<=
literal|0
condition|)
name|up
operator|->
name|zxing
operator|+=
call|(
name|double
call|)
argument_list|(
name|carphase
operator|-
literal|4
argument_list|)
operator|/
name|CYCLE
expr_stmt|;
name|up
operator|->
name|lastsig
operator|=
name|lope
expr_stmt|;
comment|/* 	 * End of the baud. Update signal/noise estimates and PLL 	 * phase, frequency and time constant. 	 */
if|if
condition|(
name|up
operator|->
name|envphase
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|maxsignal
operator|=
name|up
operator|->
name|intmax
expr_stmt|;
name|up
operator|->
name|noise
operator|=
name|up
operator|->
name|intmin
expr_stmt|;
name|up
operator|->
name|intmin
operator|=
literal|1e6
expr_stmt|;
name|up
operator|->
name|intmax
operator|=
operator|-
literal|1e6
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|maxsignal
operator|<
name|DRPOUT
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_AMP
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|maxsignal
operator|>
literal|0
condition|)
name|up
operator|->
name|modndx
operator|=
operator|(
name|up
operator|->
name|maxsignal
operator|-
name|up
operator|->
name|noise
operator|)
operator|/
name|up
operator|->
name|maxsignal
expr_stmt|;
else|else
name|up
operator|->
name|modndx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|modndx
operator|<
name|MODMIN
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_MOD
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errflg
operator|&
operator|(
name|IRIG_ERR_AMP
operator||
name|IRIG_ERR_FREQ
operator||
name|IRIG_ERR_MOD
operator||
name|IRIG_ERR_SYNCH
operator|)
condition|)
block|{
name|up
operator|->
name|tc
operator|=
name|MINTC
expr_stmt|;
name|up
operator|->
name|tcount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Update PLL phase and frequency. The PLL time constant 		 * is set initially to stabilize the frequency within a 		 * minute or two, then increases to the maximum. The 		 * frequency is clamped so that the PLL capture range 		 * cannot be exceeded. 		 */
name|dtemp
operator|=
name|up
operator|->
name|zxing
operator|*
name|up
operator|->
name|decim
operator|/
name|BAUD
expr_stmt|;
name|up
operator|->
name|yxing
operator|=
name|dtemp
expr_stmt|;
name|up
operator|->
name|zxing
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|phase
operator|+=
name|dtemp
operator|/
name|up
operator|->
name|tc
expr_stmt|;
name|up
operator|->
name|freq
operator|+=
name|dtemp
operator|/
operator|(
literal|4.
operator|*
name|up
operator|->
name|tc
operator|*
name|up
operator|->
name|tc
operator|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|freq
operator|>
name|MAXFREQ
condition|)
block|{
name|up
operator|->
name|freq
operator|=
name|MAXFREQ
expr_stmt|;
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_FREQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|freq
operator|<
operator|-
name|MAXFREQ
condition|)
block|{
name|up
operator|->
name|freq
operator|=
operator|-
name|MAXFREQ
expr_stmt|;
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_FREQ
expr_stmt|;
block|}
block|}
comment|/* 	 * Synchronous demodulator. There are eight samples in the cycle 	 * and ten cycles in the baud. Since the PLL has aligned the 	 * negative-going zero crossing at sample 4, the maximum 	 * amplitude is at sample 2 and minimum at sample 6. The 	 * beginning of the data pulse is determined from the integrated 	 * samples, while the end of the pulse is determined from the 	 * raw samples. The raw data bits are demodulated relative to 	 * the slice level and left-shifted in the decoding register. 	 */
if|if
condition|(
name|carphase
operator|!=
literal|7
condition|)
return|return;
name|lope
operator|=
operator|(
name|up
operator|->
name|lastint
index|[
literal|2
index|]
operator|-
name|up
operator|->
name|lastint
index|[
literal|6
index|]
operator|)
operator|/
literal|2.
expr_stmt|;
if|if
condition|(
name|lope
operator|>
name|up
operator|->
name|intmax
condition|)
name|up
operator|->
name|intmax
operator|=
name|lope
expr_stmt|;
if|if
condition|(
name|lope
operator|<
name|up
operator|->
name|intmin
condition|)
name|up
operator|->
name|intmin
operator|=
name|lope
expr_stmt|;
comment|/* 	 * Pulse code demodulator and reference timestamp. The decoder 	 * looks for a sequence of ten bits; the first two bits must be 	 * one, the last two bits must be zero. Frame synch is asserted 	 * when three correct frames have been found. 	 */
name|up
operator|->
name|pulse
operator|=
operator|(
name|up
operator|->
name|pulse
operator|+
literal|1
operator|)
operator|%
literal|10
expr_stmt|;
name|up
operator|->
name|cycles
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|lope
operator|>=
operator|(
name|up
operator|->
name|maxsignal
operator|+
name|up
operator|->
name|noise
operator|)
operator|/
literal|2.
condition|)
name|up
operator|->
name|cycles
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|up
operator|->
name|cycles
operator|&
literal|0x303c0f03
operator|)
operator|==
literal|0x300c0300
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|pulse
operator|!=
literal|0
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_SYNCH
expr_stmt|;
name|up
operator|->
name|pulse
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Assemble the baud and max/min to get the slice level for the 	 * next baud. The slice level is based on the maximum over the 	 * first two bits and the minimum over the last two bits, with 	 * the slice level halfway between the maximum and minimum. 	 */
name|env
operator|=
operator|(
name|up
operator|->
name|lastenv
index|[
literal|2
index|]
operator|-
name|up
operator|->
name|lastenv
index|[
literal|6
index|]
operator|)
operator|/
literal|2.
expr_stmt|;
name|up
operator|->
name|dcycles
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|env
operator|>=
name|up
operator|->
name|slice
condition|)
name|up
operator|->
name|dcycles
operator||=
literal|1
expr_stmt|;
switch|switch
condition|(
name|up
operator|->
name|pulse
condition|)
block|{
case|case
literal|0
case|:
name|irig_baud
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|dcycles
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|<
name|up
operator|->
name|envmin
condition|)
name|up
operator|->
name|envmin
operator|=
name|env
expr_stmt|;
name|up
operator|->
name|slice
operator|=
operator|(
name|up
operator|->
name|envmax
operator|+
name|up
operator|->
name|envmin
operator|)
operator|/
literal|2
expr_stmt|;
name|up
operator|->
name|envmin
operator|=
literal|1e6
expr_stmt|;
name|up
operator|->
name|envmax
operator|=
operator|-
literal|1e6
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|up
operator|->
name|envmax
operator|=
name|env
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|env
operator|>
name|up
operator|->
name|envmax
condition|)
name|up
operator|->
name|envmax
operator|=
name|env
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|up
operator|->
name|envmin
operator|=
name|env
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * irig_baud - update the PLL and decode the pulse-width signal  */
end_comment

begin_function
specifier|static
name|void
name|irig_baud
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|bits
comment|/* decoded bits */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|l_fp
name|ltemp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * The PLL time constant starts out small, in order to 	 * sustain a frequency tolerance of 250 PPM. It 	 * gradually increases as the loop settles down. Note 	 * that small wiggles are not believed, unless they 	 * persist for lots of samples. 	 */
name|up
operator|->
name|exing
operator|=
operator|-
name|up
operator|->
name|yxing
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|up
operator|->
name|envxing
operator|-
name|up
operator|->
name|envphase
argument_list|)
operator|<=
literal|1
condition|)
block|{
name|up
operator|->
name|tcount
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|tcount
operator|>
literal|20
operator|*
name|up
operator|->
name|tc
condition|)
block|{
name|up
operator|->
name|tc
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|tc
operator|>
name|MAXTC
condition|)
name|up
operator|->
name|tc
operator|=
name|MAXTC
expr_stmt|;
name|up
operator|->
name|tcount
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|envxing
operator|=
name|up
operator|->
name|envphase
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|exing
operator|-=
name|up
operator|->
name|envxing
operator|-
name|up
operator|->
name|envphase
expr_stmt|;
block|}
block|}
else|else
block|{
name|up
operator|->
name|tcount
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|envxing
operator|=
name|up
operator|->
name|envphase
expr_stmt|;
block|}
comment|/* 	 * Strike the baud timestamp as the positive zero crossing of 	 * the first bit, accounting for the codec delay and filter 	 * delay. 	 */
name|up
operator|->
name|prvstamp
operator|=
name|up
operator|->
name|chrstamp
expr_stmt|;
name|dtemp
operator|=
name|up
operator|->
name|decim
operator|*
operator|(
name|up
operator|->
name|exing
operator|/
name|SECOND
operator|)
operator|+
name|up
operator|->
name|fdelay
expr_stmt|;
name|DTOLFP
argument_list|(
name|dtemp
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|up
operator|->
name|chrstamp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|chrstamp
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
comment|/* 	 * The data bits are collected in ten-bit bauds. The first two 	 * bits are not used. The resulting patterns represent runs of 	 * 0-1 bits (0), 2-4 bits (1) and 5-7 bits (PI). The remaining 	 * 8-bit run represents a soft error and is treated as 0. 	 */
switch|switch
condition|(
name|up
operator|->
name|dcycles
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* 0-1 bits (0) */
case|case
literal|0x80
case|:
name|irig_decode
argument_list|(
name|peer
argument_list|,
name|BIT0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
comment|/* 2-4 bits (1) */
case|case
literal|0xe0
case|:
case|case
literal|0xf0
case|:
name|irig_decode
argument_list|(
name|peer
argument_list|,
name|BIT1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf8
case|:
comment|/* (5-7 bits (PI) */
case|case
literal|0xfc
case|:
case|case
literal|0xfe
case|:
name|irig_decode
argument_list|(
name|peer
argument_list|,
name|BITP
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 8 bits (error) */
name|irig_decode
argument_list|(
name|peer
argument_list|,
name|BIT0
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_DECODE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * irig_decode - decode the data  *  * This routine assembles bauds into digits, digits into frames and  * frames into the timecode fields. Bits can have values of zero, one  * or position identifier. There are four bits per digit, ten digits per  * frame and ten frames per second.  */
end_comment

begin_function
specifier|static
name|void
name|irig_decode
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|bit
comment|/* data bit (0, 1 or 2) */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|int
name|syncdig
decl_stmt|;
comment|/* sync digit (Spectracom) */
name|char
name|sbs
index|[
literal|6
operator|+
literal|1
index|]
decl_stmt|;
comment|/* binary seconds since 0h */
name|char
name|spare
index|[
literal|2
operator|+
literal|1
index|]
decl_stmt|;
comment|/* mulligan digits */
name|int
name|temp
decl_stmt|;
name|syncdig
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Assemble frame bits. 	 */
name|up
operator|->
name|bits
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bit
operator|==
name|BIT1
condition|)
block|{
name|up
operator|->
name|bits
operator||=
literal|0x200
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit
operator|==
name|BITP
operator|&&
name|up
operator|->
name|lastbit
operator|==
name|BITP
condition|)
block|{
comment|/* 		 * Frame sync - two adjacent position identifiers, which 		 * mark the beginning of the second. The reference time 		 * is the beginning of the second position identifier, 		 * so copy the character timestamp to the reference 		 * timestamp. 		 */
if|if
condition|(
name|up
operator|->
name|frmcnt
operator|!=
literal|1
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_SYNCH
expr_stmt|;
name|up
operator|->
name|frmcnt
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|refstamp
operator|=
name|up
operator|->
name|prvstamp
expr_stmt|;
block|}
name|up
operator|->
name|lastbit
operator|=
name|bit
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|frmcnt
operator|%
name|SUBFLD
operator|==
literal|0
condition|)
block|{
comment|/* 		 * End of frame. Encode two hexadecimal digits in 		 * little-endian timecode field. Note frame 1 is shifted 		 * right one bit to account for the marker PI. 		 */
name|temp
operator|=
name|up
operator|->
name|bits
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|frmcnt
operator|==
literal|10
condition|)
name|temp
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|xptr
operator|>=
literal|2
condition|)
block|{
name|up
operator|->
name|timecode
index|[
operator|--
name|up
operator|->
name|xptr
index|]
operator|=
name|hexchar
index|[
name|temp
operator|&
literal|0xf
index|]
expr_stmt|;
name|up
operator|->
name|timecode
index|[
operator|--
name|up
operator|->
name|xptr
index|]
operator|=
name|hexchar
index|[
operator|(
name|temp
operator|>>
literal|5
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|frmcnt
operator|==
literal|0
condition|)
block|{
comment|/* 			 * End of second. Decode the timecode and wind 			 * the clock. Not all IRIG generators have the 			 * year; if so, it is nonzero after year 2000. 			 * Not all have the hardware status bit; if so, 			 * it is lit when the source is okay and dim 			 * when bad. We watch this only if the year is 			 * nonzero. Not all are configured for signature 			 * control. If so, all BCD digits are set to 			 * zero if the source is bad. In this case the 			 * refclock_process() will reject the timecode 			 * as invalid. 			 */
name|up
operator|->
name|xptr
operator|=
literal|2
operator|*
name|SUBFLD
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
operator|->
name|timecode
argument_list|,
literal|"%6s%2d%1d%2s%3d%2d%2d%2d"
argument_list|,
name|sbs
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|syncdig
argument_list|,
name|spare
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|)
operator|!=
literal|8
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|up
operator|->
name|second
operator|=
operator|(
name|up
operator|->
name|second
operator|+
name|up
operator|->
name|decim
operator|)
operator|%
literal|60
expr_stmt|;
comment|/* 			 * Raise an alarm if the day field is zero, 			 * which happens when signature control is 			 * enabled and the device has lost 			 * synchronization. Raise an alarm if the year 			 * field is nonzero and the sync indicator is 			 * zero, which happens when a Spectracom radio 			 * has lost synchronization. Raise an alarm if 			 * the expected second does not agree with the 			 * decoded second, which happens with a garbled 			 * IRIG signal. We are very particular. 			 */
if|if
condition|(
name|pp
operator|->
name|day
operator|==
literal|0
operator|||
operator|(
name|pp
operator|->
name|year
operator|!=
literal|0
operator|&&
name|syncdig
operator|==
literal|0
operator|)
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_SIGERR
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|second
operator|!=
name|up
operator|->
name|second
condition|)
name|up
operator|->
name|errflg
operator||=
name|IRIG_ERR_CHECK
expr_stmt|;
name|up
operator|->
name|second
operator|=
name|pp
operator|->
name|second
expr_stmt|;
comment|/* 			 * Wind the clock only if there are no errors 			 * and the time constant has reached the 			 * maximum. 			 */
if|if
condition|(
name|up
operator|->
name|errflg
operator|==
literal|0
operator|&&
name|up
operator|->
name|tc
operator|==
name|MAXTC
condition|)
block|{
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|refstamp
expr_stmt|;
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|)
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
argument_list|,
literal|"%02x %02d %03d %02d:%02d:%02d %4.0f %3d %6.3f %2d %6.2f %6.1f %s"
argument_list|,
name|up
operator|->
name|errflg
argument_list|,
name|pp
operator|->
name|year
argument_list|,
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|up
operator|->
name|maxsignal
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|modndx
argument_list|,
name|up
operator|->
name|tc
argument_list|,
name|up
operator|->
name|exing
operator|*
literal|1e6
operator|/
name|SECOND
argument_list|,
name|up
operator|->
name|freq
operator|*
literal|1e6
operator|/
name|SECOND
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"irig %s\n"
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
block|}
name|up
operator|->
name|frmcnt
operator|=
operator|(
name|up
operator|->
name|frmcnt
operator|+
literal|1
operator|)
operator|%
name|FIELD
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * irig_poll - called by the transmit procedure  *  * This routine sweeps up the timecode updates since the last poll. For  * IRIG-B there should be at least 60 updates; for IRIG-E there should  * be at least 6. If nothing is heard, a timeout event is declared.   */
end_comment

begin_function
specifier|static
name|void
name|irig_poll
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
operator|)
condition|)
block|{
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"irig %s\n"
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * irig_gain - adjust codec gain  *  * This routine is called at the end of each second. It uses the AGC to  * bradket the maximum signal level between MINAMP and MAXAMP to avoid  * hunting. The routine also jiggles the input port and selectively  * mutes the monitor.  */
end_comment

begin_function
specifier|static
name|void
name|irig_gain
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|irigunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Apparently, the codec uses only the high order bits of the 	 * gain control field. Thus, it may take awhile for changes to 	 * wiggle the hardware bits. 	 */
if|if
condition|(
name|up
operator|->
name|maxsignal
operator|<
name|MINAMP
condition|)
block|{
name|up
operator|->
name|gain
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|>
name|MAXGAIN
condition|)
name|up
operator|->
name|gain
operator|=
name|MAXGAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|maxsignal
operator|>
name|MAXAMP
condition|)
block|{
name|up
operator|->
name|gain
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|<
literal|0
condition|)
name|up
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
name|audio_gain
argument_list|(
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|mongain
argument_list|,
name|up
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_irig_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

