begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_monitor - monitor ntpd statistics  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<ntp_random.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Record statistics based on source address, mode and version. The  * receive procedure calls us with the incoming rbufp before it does  * anything else. While at it, implement rate controls for inbound  * traffic.  *  * Each entry is doubly linked into two lists, a hash table and a most-  * recently-used (MRU) list. When a packet arrives it is looked up in  * the hash table. If found, the statistics are updated and the entry  * relinked at the head of the MRU list. If not found, a new entry is  * allocated, initialized and linked into both the hash table and at the  * head of the MRU list.  *  * Memory is usually allocated by grabbing a big chunk of new memory and  * cutting it up into littler pieces. The exception to this when we hit  * the memory limit. Then we free memory by grabbing entries off the  * tail for the MRU list, unlinking from the hash table, and  * reinitializing.  */
end_comment

begin_comment
comment|/*  * Limits on the number of structures allocated.  This limit is picked  * with the illicit knowlege that we can only return somewhat less than  * 8K bytes in a mode 7 response packet, and that each structure will  * require about 20 bytes of space in the response.  *  * ... I don't believe the above is true anymore ... jdg  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXMONMEM
end_ifndef

begin_define
define|#
directive|define
name|MAXMONMEM
value|600
end_define

begin_comment
comment|/* we allocate up to 600 structures */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MONMEMINC
end_ifndef

begin_define
define|#
directive|define
name|MONMEMINC
value|40
end_define

begin_comment
comment|/* allocate them 40 at a time */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hashing stuff  */
end_comment

begin_define
define|#
directive|define
name|MON_HASH_SIZE
value|NTP_HASH_SIZE
end_define

begin_define
define|#
directive|define
name|MON_HASH_MASK
value|NTP_HASH_MASK
end_define

begin_define
define|#
directive|define
name|MON_HASH
parameter_list|(
name|addr
parameter_list|)
value|NTP_HASH_ADDR(addr)
end_define

begin_comment
comment|/*  * Pointers to the hash table, the MRU list and the count table.  Memory  * for the hash and count tables is only allocated if monitoring is  * turned on.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mon_data
modifier|*
name|mon_hash
index|[
name|MON_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list ptrs */
end_comment

begin_decl_stmt
name|struct
name|mon_data
name|mon_mru_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of free structures structures, and counters of free and total  * structures. The free structures are linked with the hash_next field.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mon_data
modifier|*
name|mon_free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free list or null if none */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mon_total_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total structures allocated */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mon_mem_increments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* times called malloc() */
end_comment

begin_comment
comment|/*  * Parameters of the RES_LIMITED restriction option. We define headway  * as the idle time between packets. A packet is discarded if the  * headway is less than the minimum, as well as if the average headway  * is less than eight times the increment.  */
end_comment

begin_decl_stmt
name|int
name|ntp_minpkt
init|=
name|NTP_MINPKT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum (log 2 s) */
end_comment

begin_decl_stmt
name|int
name|ntp_minpoll
init|=
name|NTP_MINPOLL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* increment (log 2 s) */
end_comment

begin_comment
comment|/*  * Initialization state.  We may be monitoring, we may not.  If  * we aren't, we may not even have allocated any memory yet.  */
end_comment

begin_decl_stmt
name|int
name|mon_enabled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable switch */
end_comment

begin_decl_stmt
name|int
name|mon_age
init|=
literal|3000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preemption limit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mon_have_memory
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mon_getmoremem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_from_hash
parameter_list|(
name|struct
name|mon_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * init_mon - initialize monitoring global data  */
end_comment

begin_function
name|void
name|init_mon
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Don't do much of anything here.  We don't allocate memory 	 * until someone explicitly starts us. 	 */
name|mon_enabled
operator|=
name|MON_OFF
expr_stmt|;
name|mon_have_memory
operator|=
literal|0
expr_stmt|;
name|mon_total_mem
operator|=
literal|0
expr_stmt|;
name|mon_mem_increments
operator|=
literal|0
expr_stmt|;
name|mon_free
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mon_hash
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|mon_hash
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mon_mru_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|mon_mru_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_start - start up the monitoring software  */
end_comment

begin_function
name|void
name|mon_start
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mon_enabled
operator|!=
name|MON_OFF
condition|)
block|{
name|mon_enabled
operator||=
name|mode
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mode
operator|==
name|MON_OFF
condition|)
return|return;
if|if
condition|(
operator|!
name|mon_have_memory
condition|)
block|{
name|mon_total_mem
operator|=
literal|0
expr_stmt|;
name|mon_mem_increments
operator|=
literal|0
expr_stmt|;
name|mon_free
operator|=
name|NULL
expr_stmt|;
name|mon_getmoremem
argument_list|()
expr_stmt|;
name|mon_have_memory
operator|=
literal|1
expr_stmt|;
block|}
name|mon_mru_list
operator|.
name|mru_next
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_enabled
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_stop - stop the monitoring software  */
end_comment

begin_function
name|void
name|mon_stop
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|,
modifier|*
name|md_next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mon_enabled
operator|==
name|MON_OFF
condition|)
return|return;
if|if
condition|(
operator|(
name|mon_enabled
operator|&
name|mode
operator|)
operator|==
literal|0
operator|||
name|mode
operator|==
name|MON_OFF
condition|)
return|return;
name|mon_enabled
operator|&=
operator|~
name|mode
expr_stmt|;
if|if
condition|(
name|mon_enabled
operator|!=
name|MON_OFF
condition|)
return|return;
comment|/* 	 * Put everything back on the free list 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MON_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|=
name|mon_hash
index|[
name|i
index|]
expr_stmt|;
comment|/* get next list */
name|mon_hash
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* zero the list head */
while|while
condition|(
name|md
operator|!=
name|NULL
condition|)
block|{
name|md_next
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
name|md
operator|->
name|hash_next
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
expr_stmt|;
name|md
operator|=
name|md_next
expr_stmt|;
block|}
block|}
name|mon_mru_list
operator|.
name|mru_next
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ntp_monclearinterface
parameter_list|(
name|struct
name|interface
modifier|*
name|interface
parameter_list|)
block|{
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
for|for
control|(
name|md
operator|=
name|mon_mru_list
operator|.
name|mru_next
init|;
name|md
operator|!=
operator|&
name|mon_mru_list
condition|;
name|md
operator|=
name|md
operator|->
name|mru_next
control|)
block|{
if|if
condition|(
name|md
operator|->
name|interface
operator|==
name|interface
condition|)
block|{
comment|/* dequeue from mru list and put to free list */
name|md
operator|->
name|mru_prev
operator|->
name|mru_next
operator|=
name|md
operator|->
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
operator|->
name|mru_prev
expr_stmt|;
name|remove_from_hash
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|md
operator|->
name|hash_next
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * ntp_monitor - record stats about this packet  *  * Returns flags  */
end_comment

begin_function
name|int
name|ntp_monitor
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
specifier|register
name|u_int
name|hash
decl_stmt|;
specifier|register
name|int
name|mode
decl_stmt|;
name|int
name|interval
decl_stmt|;
if|if
condition|(
name|mon_enabled
operator|==
name|MON_OFF
condition|)
return|return
operator|(
name|flags
operator|)
return|;
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
operator|(
name|rbufp
operator|->
name|recv_srcadr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
name|MON_HASH
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|md
operator|=
name|mon_hash
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|md
operator|!=
name|NULL
condition|)
block|{
name|int
name|head
decl_stmt|;
comment|/* headway increment */
name|int
name|leak
decl_stmt|;
comment|/* new headway */
name|int
name|limit
decl_stmt|;
comment|/* average threshold */
comment|/* 		 * Match address only to conserve MRU size. 		 */
if|if
condition|(
name|SOCK_EQ
argument_list|(
operator|&
name|md
operator|->
name|rmtadr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|interval
operator|=
name|current_time
operator|-
name|md
operator|->
name|lasttime
expr_stmt|;
name|md
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
name|md
operator|->
name|count
operator|++
expr_stmt|;
name|md
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|md
operator|->
name|rmtport
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|md
operator|->
name|mode
operator|=
operator|(
name|u_char
operator|)
name|mode
expr_stmt|;
name|md
operator|->
name|version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
comment|/* 			 * Shuffle to the head of the MRU list. 			 */
name|md
operator|->
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
operator|->
name|mru_prev
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|->
name|mru_next
operator|=
name|md
operator|->
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_next
operator|=
name|mon_mru_list
operator|.
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|=
name|md
expr_stmt|;
comment|/* 			 * At this point the most recent arrival is 			 * first in the MRU list. Decrease the counter 			 * by the headway, but not less than zero. 			 */
name|md
operator|->
name|leak
operator|-=
name|interval
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|leak
operator|<
literal|0
condition|)
name|md
operator|->
name|leak
operator|=
literal|0
expr_stmt|;
name|head
operator|=
literal|1
operator|<<
name|ntp_minpoll
expr_stmt|;
name|leak
operator|=
name|md
operator|->
name|leak
operator|+
name|head
expr_stmt|;
name|limit
operator|=
name|NTP_SHIFT
operator|*
name|head
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"restrict: interval %d headway %d limit %d\n"
argument_list|,
name|interval
argument_list|,
name|leak
argument_list|,
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * If the minimum and average thresholds are not 			 * exceeded, douse the RES_LIMITED and RES_KOD 			 * bits and increase the counter by the headway 			 * increment. Note that we give a 1-s grace for 			 * the minimum threshold and a 2-s grace for the 			 * headway increment. If one or both thresholds 			 * are exceeded and the old counter is less than 			 * the average threshold, set the counter to the 			 * average threshold plus the inrcrment and 			 * leave the RES_KOD bit lit. Othewise, leave 			 * the counter alone and douse the RES_KOD bit. 			 * This rate-limits the KoDs to no less than the 			 * average headway. 			 */
if|if
condition|(
name|interval
operator|+
literal|1
operator|>=
operator|(
literal|1
operator|<<
name|ntp_minpkt
operator|)
operator|&&
name|leak
operator|<
name|limit
condition|)
block|{
name|md
operator|->
name|leak
operator|=
name|leak
operator|-
literal|2
expr_stmt|;
name|md
operator|->
name|flags
operator|&=
operator|~
operator|(
name|RES_LIMITED
operator||
name|RES_KOD
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|md
operator|->
name|leak
operator|<
name|limit
condition|)
block|{
name|md
operator|->
name|leak
operator|=
name|limit
operator|+
name|head
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|flags
operator|&=
operator|~
name|RES_KOD
expr_stmt|;
block|}
return|return
operator|(
name|md
operator|->
name|flags
operator|)
return|;
block|}
name|md
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
block|}
comment|/* 	 * If we got here, this is the first we've heard of this 	 * guy.  Get him some memory, either from the free list 	 * or from the tail of the MRU list. 	 */
if|if
condition|(
name|mon_free
operator|==
name|NULL
operator|&&
name|mon_total_mem
operator|>=
name|MAXMONMEM
condition|)
block|{
comment|/* 		 * Preempt from the MRU list if old enough. 		 */
name|md
operator|=
name|mon_mru_list
operator|.
name|mru_prev
expr_stmt|;
if|if
condition|(
name|ntp_random
argument_list|()
operator|/
operator|(
literal|2.
operator|*
name|FRAC
operator|)
operator|>
call|(
name|double
call|)
argument_list|(
name|current_time
operator|-
name|md
operator|->
name|lasttime
argument_list|)
operator|/
name|mon_age
condition|)
return|return
operator|(
name|flags
operator|&
operator|~
operator|(
name|RES_LIMITED
operator||
name|RES_KOD
operator|)
operator|)
return|;
name|md
operator|->
name|mru_prev
operator|->
name|mru_next
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_prev
operator|=
name|md
operator|->
name|mru_prev
expr_stmt|;
name|remove_from_hash
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mon_free
operator|==
name|NULL
condition|)
name|mon_getmoremem
argument_list|()
expr_stmt|;
name|md
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
block|}
comment|/* 	 * Got one, initialize it 	 */
name|md
operator|->
name|lasttime
operator|=
name|md
operator|->
name|firsttime
operator|=
name|current_time
expr_stmt|;
name|md
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|md
operator|->
name|flags
operator|=
name|flags
operator|&
operator|~
operator|(
name|RES_LIMITED
operator||
name|RES_KOD
operator|)
expr_stmt|;
name|md
operator|->
name|leak
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|md
operator|->
name|rmtadr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|rmtadr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|md
operator|->
name|rmtadr
argument_list|,
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|rmtport
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|md
operator|->
name|mode
operator|=
operator|(
name|u_char
operator|)
name|mode
expr_stmt|;
name|md
operator|->
name|version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|md
operator|->
name|interface
operator|=
name|rbufp
operator|->
name|dstadr
expr_stmt|;
name|md
operator|->
name|cast_flags
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
operator|(
name|rbufp
operator|->
name|dstadr
operator|->
name|flags
operator|&
name|INT_MCASTOPEN
operator|)
operator|&&
name|rbufp
operator|->
name|fd
operator|==
name|md
operator|->
name|interface
operator|->
name|fd
operator|)
condition|?
name|MDF_MCAST
else|:
name|rbufp
operator|->
name|fd
operator|==
name|md
operator|->
name|interface
operator|->
name|bfd
condition|?
name|MDF_BCAST
else|:
name|MDF_UCAST
argument_list|)
expr_stmt|;
comment|/* 	 * Drop him into front of the hash table. Also put him on top of 	 * the MRU list. 	 */
name|md
operator|->
name|hash_next
operator|=
name|mon_hash
index|[
name|hash
index|]
expr_stmt|;
name|mon_hash
index|[
name|hash
index|]
operator|=
name|md
expr_stmt|;
name|md
operator|->
name|mru_next
operator|=
name|mon_mru_list
operator|.
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|=
name|md
expr_stmt|;
return|return
operator|(
name|md
operator|->
name|flags
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mon_getmoremem - get more memory and put it on the free list  */
end_comment

begin_function
specifier|static
name|void
name|mon_getmoremem
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|mon_data
modifier|*
name|freedata
decl_stmt|;
comment|/* 'old' free list (null) */
name|md
operator|=
operator|(
expr|struct
name|mon_data
operator|*
operator|)
name|emalloc
argument_list|(
name|MONMEMINC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mon_data
argument_list|)
argument_list|)
expr_stmt|;
name|freedata
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|MONMEMINC
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|->
name|hash_next
operator|=
operator|(
name|md
operator|+
literal|1
operator|)
expr_stmt|;
name|md
operator|++
expr_stmt|;
block|}
comment|/* 	 * md now points at the last.  Link in the rest of the chain. 	 */
name|md
operator|->
name|hash_next
operator|=
name|freedata
expr_stmt|;
name|mon_total_mem
operator|+=
name|MONMEMINC
expr_stmt|;
name|mon_mem_increments
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_from_hash
parameter_list|(
name|struct
name|mon_data
modifier|*
name|md
parameter_list|)
block|{
specifier|register
name|u_int
name|hash
decl_stmt|;
specifier|register
name|struct
name|mon_data
modifier|*
name|md_prev
decl_stmt|;
name|hash
operator|=
name|MON_HASH
argument_list|(
operator|&
name|md
operator|->
name|rmtadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mon_hash
index|[
name|hash
index|]
operator|==
name|md
condition|)
block|{
name|mon_hash
index|[
name|hash
index|]
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
block|}
else|else
block|{
name|md_prev
operator|=
name|mon_hash
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|md_prev
operator|->
name|hash_next
operator|!=
name|md
condition|)
block|{
name|md_prev
operator|=
name|md_prev
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
name|md_prev
operator|==
name|NULL
condition|)
block|{
comment|/* logic error */
return|return;
block|}
block|}
name|md_prev
operator|->
name|hash_next
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
block|}
block|}
end_function

end_unit

