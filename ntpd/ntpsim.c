begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntpdsim.c  *  * The source code for the ntp discrete event simulator.   *  * Written By:	Sachin Kamboj  *		University of Delaware  *		Newark, DE 19711  * Copyright (c) 2006  * (Some code shamelessly based on the original NTP discrete event simulator)  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_config.h"
end_include

begin_comment
comment|/* forward prototypes */
end_comment

begin_function_decl
name|int
name|determine_event_ordering
parameter_list|(
specifier|const
name|Event
modifier|*
name|e1
parameter_list|,
specifier|const
name|Event
modifier|*
name|e2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|determine_recv_buf_ordering
parameter_list|(
specifier|const
name|struct
name|recvbuf
modifier|*
name|b1
parameter_list|,
specifier|const
name|struct
name|recvbuf
modifier|*
name|b2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|create_server_associations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init_sim_io
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Global Variable Definitions */
end_comment

begin_decl_stmt
name|sim_info
name|simulation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simulation Control Variables */
end_comment

begin_decl_stmt
name|local_clock_info
name|simclock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local Clock Variables */
end_comment

begin_decl_stmt
name|queue
modifier|*
name|event_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Event Queue */
end_comment

begin_decl_stmt
name|queue
modifier|*
name|recv_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Receive Queue */
end_comment

begin_decl_stmt
specifier|static
name|double
name|sys_residual
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adjustment residue (s) */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|event_ptr
index|[]
function_decl|)
parameter_list|(
name|Event
modifier|*
parameter_list|)
init|=
block|{
name|sim_event_beep
operator|,
function_decl|sim_update_clocks
operator|,
function_decl|sim_event_timer
operator|,
function_decl|sim_event_recv_packet
end_function_decl

begin_comment
unit|};
comment|/* Function pointer to the events */
end_comment

begin_comment
comment|/*  * Define a function to compare two events to determine which one occurs  * first.  */
end_comment

begin_function
name|int
name|determine_event_ordering
parameter_list|(
specifier|const
name|Event
modifier|*
name|e1
parameter_list|,
specifier|const
name|Event
modifier|*
name|e2
parameter_list|)
block|{
return|return
operator|(
name|e1
operator|->
name|time
operator|-
name|e2
operator|->
name|time
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define a function to compare two received packets to determine which  * one is received first.  */
end_comment

begin_function
name|int
name|determine_recv_buf_ordering
parameter_list|(
specifier|const
name|struct
name|recvbuf
modifier|*
name|b1
parameter_list|,
specifier|const
name|struct
name|recvbuf
modifier|*
name|b2
parameter_list|)
block|{
name|double
name|recv_time1
decl_stmt|;
name|double
name|recv_time2
decl_stmt|;
comment|/* Simply convert the time received to double and subtract */
name|LFPTOD
argument_list|(
operator|&
name|b1
operator|->
name|recv_time
argument_list|,
name|recv_time1
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|b2
operator|->
name|recv_time
argument_list|,
name|recv_time2
argument_list|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|recv_time1
operator|-
name|recv_time2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define a function to create the server associations */
end_comment

begin_function
name|void
name|create_server_associations
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|simulation
operator|.
name|num_of_servers
condition|;
operator|++
name|i
control|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|stoa
argument_list|(
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer_config
argument_list|(
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|NULL
argument_list|,
name|loopback_interface
argument_list|,
name|MODE_CLIENT
argument_list|,
name|NTP_VERSION
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
literal|0
argument_list|,
comment|/* peerflags */
literal|0
argument_list|,
comment|/* ttl */
literal|0
argument_list|,
comment|/* peerkey */
name|NULL
comment|/* group ident */
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR!! Could not create association for: %s\n"
argument_list|,
name|stoa
argument_list|(
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Main Simulator Code */
end_comment

begin_function
name|int
name|ntpsim
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|Event
modifier|*
name|curr_event
decl_stmt|;
name|struct
name|timeval
name|seed
decl_stmt|;
comment|/* Initialize the local Clock */
name|simclock
operator|.
name|local_time
operator|=
literal|0
expr_stmt|;
name|simclock
operator|.
name|adj
operator|=
literal|0
expr_stmt|;
name|simclock
operator|.
name|slew
operator|=
literal|500e-6
expr_stmt|;
comment|/* Initialize the simulation */
name|simulation
operator|.
name|num_of_servers
operator|=
literal|0
expr_stmt|;
name|simulation
operator|.
name|beep_delay
operator|=
name|BEEP_DLY
expr_stmt|;
name|simulation
operator|.
name|sim_time
operator|=
literal|0
expr_stmt|;
name|simulation
operator|.
name|end_time
operator|=
name|SIM_TIME
expr_stmt|;
comment|/* Initialize ntp modules */
name|initializing
operator|=
name|TRUE
expr_stmt|;
name|msyslog_term
operator|=
name|TRUE
expr_stmt|;
name|init_sim_io
argument_list|()
expr_stmt|;
name|init_auth
argument_list|()
expr_stmt|;
name|init_util
argument_list|()
expr_stmt|;
name|init_restrict
argument_list|()
expr_stmt|;
name|init_mon
argument_list|()
expr_stmt|;
name|init_timer
argument_list|()
expr_stmt|;
name|init_lib
argument_list|()
expr_stmt|;
name|init_request
argument_list|()
expr_stmt|;
name|init_control
argument_list|()
expr_stmt|;
name|init_peer
argument_list|()
expr_stmt|;
name|init_proto
argument_list|()
expr_stmt|;
name|init_loopfilter
argument_list|()
expr_stmt|;
name|mon_start
argument_list|(
name|MON_OFF
argument_list|)
expr_stmt|;
comment|/* Call getconfig to parse the configuration file */
name|getconfig
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|loop_config
argument_list|(
name|LOOP_DRIFTINIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initializing
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Watch out here, we want the real time, not the silly stuff. 	 */
name|gettimeofday
argument_list|(
operator|&
name|seed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ntp_srandom
argument_list|(
name|seed
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* Initialize the event queue */
name|event_queue
operator|=
name|create_priority_queue
argument_list|(
operator|(
name|q_order_func
operator|)
name|determine_event_ordering
argument_list|)
expr_stmt|;
comment|/* Initialize the receive queue */
name|recv_queue
operator|=
name|create_priority_queue
argument_list|(
operator|(
name|q_order_func
operator|)
name|determine_recv_buf_ordering
argument_list|)
expr_stmt|;
comment|/* Push a beep and a timer on the event queue */
name|enqueue
argument_list|(
name|event_queue
argument_list|,
name|event
argument_list|(
literal|0
argument_list|,
name|BEEP
argument_list|)
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|event_queue
argument_list|,
name|event
argument_list|(
name|simulation
operator|.
name|sim_time
operator|+
literal|1.0
argument_list|,
name|TIMER
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  	 * Pop the queue until nothing is left or time is exceeded 	 */
comment|/* maxtime = simulation.sim_time + simulation.end_time;*/
while|while
condition|(
name|simulation
operator|.
name|sim_time
operator|<=
name|simulation
operator|.
name|end_time
operator|&&
operator|(
operator|!
name|empty
argument_list|(
name|event_queue
argument_list|)
operator|)
condition|)
block|{
name|curr_event
operator|=
name|dequeue
argument_list|(
name|event_queue
argument_list|)
expr_stmt|;
comment|/* Update all the clocks to the time on the event */
name|sim_update_clocks
argument_list|(
name|curr_event
argument_list|)
expr_stmt|;
comment|/* Execute the function associated with the event */
call|(
modifier|*
name|event_ptr
index|[
name|curr_event
operator|->
name|function
index|]
call|)
argument_list|(
name|curr_event
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|curr_event
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"sys_received: %lu\n"
argument_list|,
name|sys_received
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sys_badlength: %lu\n"
argument_list|,
name|sys_badlength
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sys_declined: %lu\n"
argument_list|,
name|sys_declined
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sys_restricted: %lu\n"
argument_list|,
name|sys_restricted
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sys_newversion: %lu\n"
argument_list|,
name|sys_newversion
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sys_oldversion: %lu\n"
argument_list|,
name|sys_oldversion
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sys_limitrejected: %lu\n"
argument_list|,
name|sys_limitrejected
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sys_badauth: %lu\n"
argument_list|,
name|sys_badauth
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|init_sim_io
parameter_list|(
name|void
parameter_list|)
block|{
name|loopback_interface
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|loopback_interface
argument_list|)
argument_list|)
expr_stmt|;
name|ep_list
operator|=
name|loopback_interface
expr_stmt|;
name|strlcpy
argument_list|(
name|loopback_interface
operator|->
name|name
argument_list|,
literal|"IPv4loop"
argument_list|,
sizeof|sizeof
argument_list|(
name|loopback_interface
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|loopback_interface
operator|->
name|flags
operator|=
name|INT_UP
operator||
name|INT_LOOPBACK
expr_stmt|;
name|loopback_interface
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|loopback_interface
operator|->
name|bfd
operator|=
operator|-
literal|1
expr_stmt|;
name|loopback_interface
operator|->
name|ifnum
operator|=
literal|1
expr_stmt|;
name|loopback_interface
operator|->
name|family
operator|=
name|AF_INET
expr_stmt|;
name|AF
argument_list|(
operator|&
name|loopback_interface
operator|->
name|sin
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|SET_ADDR4
argument_list|(
operator|&
name|loopback_interface
operator|->
name|sin
argument_list|,
name|LOOPBACKADR
argument_list|)
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|loopback_interface
operator|->
name|sin
argument_list|,
name|NTP_PORT
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|loopback_interface
operator|->
name|mask
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|SET_ADDR4
argument_list|(
operator|&
name|loopback_interface
operator|->
name|mask
argument_list|,
name|LOOPNETMASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a function to create an return an Event  */
end_comment

begin_function
name|Event
modifier|*
name|event
parameter_list|(
name|double
name|t
parameter_list|,
name|funcTkn
name|f
parameter_list|)
block|{
name|Event
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|get_node
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|abortsim
argument_list|(
literal|"get_node failed in event"
argument_list|)
expr_stmt|;
name|e
operator|->
name|time
operator|=
name|t
expr_stmt|;
name|e
operator|->
name|function
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_comment
comment|/* NTP SIMULATION FUNCTIONS */
end_comment

begin_comment
comment|/* Define a function for processing a timer interrupt.  * On every timer interrupt, call the NTP timer to send packets and process  * the clock and then call the receive function to receive packets.  */
end_comment

begin_function
name|void
name|sim_event_timer
parameter_list|(
name|Event
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|recvbuf
modifier|*
name|rbuf
decl_stmt|;
comment|/* Call the NTP timer.      * This will be responsible for actually "sending the packets."      * Since this is a simulation, the packets sent over the network      * will be processed by the simulate_server routine below.      */
name|timer
argument_list|()
expr_stmt|;
comment|/* Process received buffers */
while|while
condition|(
operator|!
name|empty
argument_list|(
name|recv_queue
argument_list|)
condition|)
block|{
name|rbuf
operator|=
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
name|dequeue
argument_list|(
name|recv_queue
argument_list|)
expr_stmt|;
call|(
modifier|*
name|rbuf
operator|->
name|receiver
call|)
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
block|}
comment|/* Arm the next timer interrupt. */
name|enqueue
argument_list|(
name|event_queue
argument_list|,
name|event
argument_list|(
name|simulation
operator|.
name|sim_time
operator|+
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
argument_list|,
name|TIMER
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a function to simulate a server.  * This function processes the sent packet according to the server script,  * creates a reply packet and pushes the reply packet onto the event queue  */
end_comment

begin_function
name|int
name|simulate_server
parameter_list|(
name|sockaddr_u
modifier|*
name|serv_addr
parameter_list|,
comment|/* Address of the server */
name|endpt
modifier|*
name|inter
parameter_list|,
comment|/* Interface on which the reply should 				   be inserted */
name|struct
name|pkt
modifier|*
name|rpkt
comment|/* Packet sent to the server that 				   needs to be processed. */
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* Packet to be transmitted back 				   to the client */
name|struct
name|recvbuf
name|rbuf
decl_stmt|;
comment|/* Buffer for the received packet */
name|Event
modifier|*
name|e
decl_stmt|;
comment|/* Packet receive event */
name|server_info
modifier|*
name|server
decl_stmt|;
comment|/* Pointer to the server being simulated */
name|script_info
modifier|*
name|curr_script
decl_stmt|;
comment|/* Current script being processed */
name|int
name|i
decl_stmt|;
name|double
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
comment|/* Delays while the packet is enroute */
name|double
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
comment|/* The four timestamps in the packet */
name|l_fp
name|lfp_host
decl_stmt|;
comment|/* host-order l_fp */
name|ZERO
argument_list|(
name|xpkt
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
comment|/* Search for the server with the desired address */
name|server
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|simulation
operator|.
name|num_of_servers
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|serv_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|serv_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|server
operator|=
operator|&
name|simulation
operator|.
name|servers
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Received packet from %s on %s\n"
argument_list|,
name|stoa
argument_list|(
name|serv_addr
argument_list|)
argument_list|,
name|latoa
argument_list|(
name|inter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
name|NULL
condition|)
name|abortsim
argument_list|(
literal|"Server with specified address not found!!!"
argument_list|)
expr_stmt|;
comment|/* Get the current script for the server */
name|curr_script
operator|=
name|server
operator|->
name|curr_script
expr_stmt|;
comment|/* Create a server reply packet.       * Masquerade the reply as a stratum-1 server with a GPS clock      */
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOWARNING
argument_list|,
name|NTP_VERSION
argument_list|,
name|MODE_SERVER
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
operator|(
operator|(
name|u_char
operator|)
literal|1
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|xpkt
operator|.
name|refid
argument_list|,
literal|"GPS"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|rpkt
operator|->
name|ppoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|rpkt
operator|->
name|precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
literal|0
expr_stmt|;
name|xpkt
operator|.
name|rootdisp
operator|=
literal|0
expr_stmt|;
comment|/* TIMESTAMP CALCULATIONS 	    t1				 t4 	     \				/ 	  d1  \			       / d3 	       \		      / 	       t2 ----------------- t3 			 d2     */
comment|/* Compute the delays */
name|d1
operator|=
name|poisson
argument_list|(
name|curr_script
operator|->
name|prop_delay
argument_list|,
name|curr_script
operator|->
name|jitter
argument_list|)
expr_stmt|;
name|d2
operator|=
name|poisson
argument_list|(
name|curr_script
operator|->
name|proc_delay
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d3
operator|=
name|poisson
argument_list|(
name|curr_script
operator|->
name|prop_delay
argument_list|,
name|curr_script
operator|->
name|jitter
argument_list|)
expr_stmt|;
comment|/* Note: In the transmitted packet:       * 1. t1 and t4 are times in the client according to the local clock.      * 2. t2 and t3 are server times according to the simulated server.      * Compute t1, t2, t3 and t4      * Note: This function is called at time t1.       */
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|xmt
argument_list|,
operator|&
name|lfp_host
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|lfp_host
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|server
operator|->
name|server_time
operator|+
name|d1
expr_stmt|;
name|t3
operator|=
name|server
operator|->
name|server_time
operator|+
name|d1
operator|+
name|d2
expr_stmt|;
name|t4
operator|=
name|t1
operator|+
name|d1
operator|+
name|d2
operator|+
name|d3
expr_stmt|;
comment|/* Save the timestamps */
name|xpkt
operator|.
name|org
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|DTOLFP
argument_list|(
name|t2
argument_list|,
operator|&
name|lfp_host
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|lfp_host
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
name|DTOLFP
argument_list|(
name|t3
argument_list|,
operator|&
name|lfp_host
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|lfp_host
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|reftime
operator|=
name|xpkt
operator|.
name|xmt
expr_stmt|;
comment|/*       * Ok, we are done with the packet. Now initialize the receive      * buffer for the packet.      */
name|rbuf
operator|.
name|used
operator|=
literal|1
expr_stmt|;
name|rbuf
operator|.
name|receiver
operator|=
operator|&
name|receive
expr_stmt|;
comment|/* callback to process the packet */
name|rbuf
operator|.
name|recv_length
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
name|rbuf
operator|.
name|recv_pkt
operator|=
name|xpkt
expr_stmt|;
name|rbuf
operator|.
name|dstadr
operator|=
name|inter
expr_stmt|;
name|rbuf
operator|.
name|fd
operator|=
name|inter
operator|->
name|fd
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|rbuf
operator|.
name|srcadr
argument_list|,
name|serv_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
operator|.
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|rbuf
operator|.
name|recv_srcadr
argument_list|,
name|serv_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
operator|.
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Create a packet event and insert it onto the event_queue at the      * arrival time (t4) of the packet at the client       */
name|e
operator|=
name|event
argument_list|(
name|t4
argument_list|,
name|PACKET
argument_list|)
expr_stmt|;
name|e
operator|->
name|rcv_buf
operator|=
name|rbuf
expr_stmt|;
name|enqueue
argument_list|(
name|event_queue
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/*      * Check if the time of the script has expired. If yes, delete it.      */
if|if
condition|(
name|curr_script
operator|->
name|duration
operator|>
name|simulation
operator|.
name|sim_time
operator|&&
name|NULL
operator|==
name|HEAD_PFIFO
argument_list|(
name|server
operator|->
name|script
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Hello\n"
argument_list|)
expr_stmt|;
comment|/*  	 * For some reason freeing up the curr_script memory kills the 	 * simulation. Further debugging is needed to determine why. 	 * free(curr_script); 	 */
name|UNLINK_FIFO
argument_list|(
name|curr_script
argument_list|,
operator|*
name|server
operator|->
name|script
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Define a function to update all the clocks   * Most of the code is modified from the systime.c file by Prof. Mills  */
end_comment

begin_function
name|void
name|sim_update_clocks
parameter_list|(
name|Event
modifier|*
name|e
parameter_list|)
block|{
name|double
name|time_gap
decl_stmt|;
name|double
name|adj
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Compute the time between the last update event and this update */
name|time_gap
operator|=
name|e
operator|->
name|time
operator|-
name|simulation
operator|.
name|sim_time
expr_stmt|;
if|if
condition|(
name|time_gap
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"WARNING: e->time %.6g comes before sim_time %.6g (gap %+.6g)\n"
argument_list|,
name|e
operator|->
name|time
argument_list|,
name|simulation
operator|.
name|sim_time
argument_list|,
name|time_gap
argument_list|)
expr_stmt|;
comment|/* Advance the client clock */
if|if
condition|(
name|e
operator|->
name|time
operator|+
name|time_gap
operator|<
name|simclock
operator|.
name|local_time
condition|)
name|printf
argument_list|(
literal|"WARNING: e->time + gap %.6g comes before local_time %.6g\n"
argument_list|,
name|e
operator|->
name|time
operator|+
name|time_gap
argument_list|,
name|simclock
operator|.
name|local_time
argument_list|)
expr_stmt|;
name|simclock
operator|.
name|local_time
operator|=
name|e
operator|->
name|time
operator|+
name|time_gap
expr_stmt|;
comment|/* Advance the simulation time */
name|simulation
operator|.
name|sim_time
operator|=
name|e
operator|->
name|time
expr_stmt|;
comment|/* Advance the server clocks adjusted for systematic and random frequency      * errors. The random error is a random walk computed as the      * integral of samples from a Gaussian distribution.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|simulation
operator|.
name|num_of_servers
condition|;
operator|++
name|i
control|)
block|{
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|.
name|curr_script
operator|->
name|freq_offset
operator|+=
name|gauss
argument_list|(
literal|0
argument_list|,
name|time_gap
operator|*
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|.
name|curr_script
operator|->
name|wander
argument_list|)
expr_stmt|;
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|.
name|server_time
operator|+=
name|time_gap
operator|*
operator|(
literal|1
operator|+
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|.
name|curr_script
operator|->
name|freq_offset
operator|)
expr_stmt|;
block|}
comment|/* Perform the adjtime() function. If the adjustment completed      * in the previous interval, amortize the entire amount; if not,      * carry the leftover to the next interval.      */
name|adj
operator|=
name|time_gap
operator|*
name|simclock
operator|.
name|slew
expr_stmt|;
if|if
condition|(
name|adj
operator|<
name|fabs
argument_list|(
name|simclock
operator|.
name|adj
argument_list|)
condition|)
block|{
if|if
condition|(
name|simclock
operator|.
name|adj
operator|<
literal|0
condition|)
block|{
name|simclock
operator|.
name|adj
operator|+=
name|adj
expr_stmt|;
name|simclock
operator|.
name|local_time
operator|-=
name|adj
expr_stmt|;
block|}
else|else
block|{
name|simclock
operator|.
name|adj
operator|-=
name|adj
expr_stmt|;
name|simclock
operator|.
name|local_time
operator|+=
name|adj
expr_stmt|;
block|}
block|}
else|else
block|{
name|simclock
operator|.
name|local_time
operator|+=
name|simclock
operator|.
name|adj
expr_stmt|;
name|simclock
operator|.
name|adj
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Define a function that processes a receive packet event.   * This function simply inserts the packet received onto the receive queue  */
end_comment

begin_function
name|void
name|sim_event_recv_packet
parameter_list|(
name|Event
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|recvbuf
modifier|*
name|rbuf
decl_stmt|;
comment|/* Allocate a receive buffer and copy the packet to it */
if|if
condition|(
operator|(
name|rbuf
operator|=
name|get_node
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rbuf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|abortsim
argument_list|(
literal|"get_node failed in sim_event_recv_packet"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rbuf
argument_list|,
operator|&
name|e
operator|->
name|rcv_buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the local time in the received packet */
name|DTOLFP
argument_list|(
name|simclock
operator|.
name|local_time
argument_list|,
operator|&
name|rbuf
operator|->
name|recv_time
argument_list|)
expr_stmt|;
comment|/* Insert the packet received onto the receive queue */
name|enqueue
argument_list|(
name|recv_queue
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a function to output simulation statistics on a beep event  */
end_comment

begin_comment
comment|/*** TODO: Need to decide on how to output for multiple servers ***/
end_comment

begin_function
name|void
name|sim_event_beep
parameter_list|(
name|Event
modifier|*
name|e
parameter_list|)
block|{
if|#
directive|if
literal|0
block|static int first_time = 1;     char *dash = "-----------------";
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BEEP!!!\n"
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|event_queue
argument_list|,
name|event
argument_list|(
name|e
operator|->
name|time
operator|+
name|simulation
operator|.
name|beep_delay
argument_list|,
name|BEEP
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if(simulation.beep_delay> 0) { 	if (first_time) { 	    printf("\t%4c    T    %4c\t%4c  T+ERR  %3c\t%5cT+ERR+NTP\n",  	           ' ', ' ', ' ', ' ',' '); 	    printf("\t%s\t%s\t%s\n", dash, dash, dash); 	    first_time = 0;  	    printf("\t%16.6f\t%16.6f\t%16.6f\n", 	           n->time, n->clk_time, n->ntp_time); 	    return; 	} 	printf("\t%16.6f\t%16.6f\t%16.6f\n", 	       simclock.local_time,  	       n->time, n->clk_time, n->ntp_time);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Define a function to abort the simulation on an error and spit out an  * error message  */
end_comment

begin_function
name|void
name|abortsim
parameter_list|(
name|char
modifier|*
name|errmsg
parameter_list|)
block|{
name|perror
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CODE ORIGINALLY IN libntp/systime.c   * -----------------------------------  * This code was a part of the original NTP simulator and originally   * had its home in the libntp/systime.c file.   *  * It has been shamelessly moved to here and has been modified for the  * purposes of the current simulator.  */
end_comment

begin_comment
comment|/*  * get_systime - return the system time in NTP timestamp format   */
end_comment

begin_function
name|void
name|get_systime
parameter_list|(
name|l_fp
modifier|*
name|now
comment|/* current system time in l_fp */
parameter_list|)
block|{
comment|/*      * To fool the code that determines the local clock precision,      * we advance the clock a minimum of 200 nanoseconds on every      * clock read. This is appropriate for a typical modern machine      * with nanosecond clocks. Note we make no attempt here to      * simulate reading error, since the error is so small. This may      * change when the need comes to implement picosecond clocks.      */
if|if
condition|(
name|simclock
operator|.
name|local_time
operator|==
name|simclock
operator|.
name|last_read_time
condition|)
name|simclock
operator|.
name|local_time
operator|+=
literal|200e-9
expr_stmt|;
name|simclock
operator|.
name|last_read_time
operator|=
name|simclock
operator|.
name|local_time
expr_stmt|;
name|DTOLFP
argument_list|(
name|simclock
operator|.
name|local_time
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|/* OLD Code    if (ntp_node.ntp_time == ntp_node.last_time)    ntp_node.ntp_time += 200e-9;    ntp_node.last_time = ntp_node.ntp_time;    DTOLFP(ntp_node.ntp_time, now); */
block|}
end_function

begin_comment
comment|/*  * adj_systime - advance or retard the system clock exactly like the  * real thng.  */
end_comment

begin_function
name|int
comment|/* always succeeds */
name|adj_systime
parameter_list|(
name|double
name|now
comment|/* time adjustment (s) */
parameter_list|)
block|{
name|struct
name|timeval
name|adjtv
decl_stmt|;
comment|/* new adjustment */
name|double
name|dtemp
decl_stmt|;
name|long
name|ticks
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
comment|/*      * Most Unix adjtime() implementations adjust the system clock      * in microsecond quanta, but some adjust in 10-ms quanta. We      * carefully round the adjustment to the nearest quantum, then      * adjust in quanta and keep the residue for later.      */
name|dtemp
operator|=
name|now
operator|+
name|sys_residual
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|=
operator|-
name|dtemp
expr_stmt|;
block|}
name|adjtv
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|dtemp
expr_stmt|;
name|dtemp
operator|-=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|ticks
operator|=
call|(
name|long
call|)
argument_list|(
name|dtemp
operator|/
name|sys_tick
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|ticks
operator|*
name|sys_tick
operator|*
literal|1e6
argument_list|)
expr_stmt|;
name|dtemp
operator|-=
name|adjtv
operator|.
name|tv_usec
operator|/
literal|1e6
expr_stmt|;
name|sys_residual
operator|=
name|dtemp
expr_stmt|;
comment|/*      * Convert to signed seconds and microseconds for the Unix      * adjtime() system call. Note we purposely lose the adjtime()      * leftover.      */
if|if
condition|(
name|isneg
condition|)
block|{
name|adjtv
operator|.
name|tv_sec
operator|=
operator|-
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
operator|-
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
name|sys_residual
operator|=
operator|-
name|sys_residual
expr_stmt|;
block|}
name|simclock
operator|.
name|adj
operator|=
name|now
expr_stmt|;
comment|/*	ntp_node.adj = now; */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * step_systime - step the system clock. We are religious here.  */
end_comment

begin_function
name|int
comment|/* always succeeds */
name|step_systime
parameter_list|(
name|double
name|now
comment|/* step adjustment (s) */
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"step_systime: time %.6f adj %.6f\n"
argument_list|,
name|simclock
operator|.
name|local_time
argument_list|,
name|now
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|simclock
operator|.
name|local_time
operator|+=
name|now
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gauss() - returns samples from a gaussion distribution  */
end_comment

begin_function
name|double
comment|/* Gaussian sample */
name|gauss
parameter_list|(
name|double
name|m
parameter_list|,
comment|/* sample mean */
name|double
name|s
comment|/* sample standard deviation (sigma) */
parameter_list|)
block|{
name|double
name|q1
decl_stmt|,
name|q2
decl_stmt|;
comment|/*      * Roll a sample from a Gaussian distribution with mean m and      * standard deviation s. For m = 0, s = 1, mean(y) = 0,      * std(y) = 1.      */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
operator|(
name|m
operator|)
return|;
while|while
condition|(
operator|(
name|q1
operator|=
name|drand48
argument_list|()
operator|)
operator|==
literal|0
condition|)
comment|/* empty statement */
empty_stmt|;
name|q2
operator|=
name|drand48
argument_list|()
expr_stmt|;
return|return
operator|(
name|m
operator|+
name|s
operator|*
name|sqrt
argument_list|(
operator|-
literal|2.
operator|*
name|log
argument_list|(
name|q1
argument_list|)
argument_list|)
operator|*
name|cos
argument_list|(
literal|2.
operator|*
name|PI
operator|*
name|q2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * poisson() - returns samples from a network delay distribution  */
end_comment

begin_function
name|double
comment|/* delay sample (s) */
name|poisson
parameter_list|(
name|double
name|m
parameter_list|,
comment|/* fixed propagation delay (s) */
name|double
name|s
comment|/* exponential parameter (mu) */
parameter_list|)
block|{
name|double
name|q1
decl_stmt|;
comment|/*      * Roll a sample from a composite distribution with propagation      * delay m and exponential distribution time with parameter s.      * For m = 0, s = 1, mean(y) = std(y) = 1.      */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
operator|(
name|m
operator|)
return|;
while|while
condition|(
operator|(
name|q1
operator|=
name|drand48
argument_list|()
operator|)
operator|==
literal|0
condition|)
comment|/* empty statement */
empty_stmt|;
return|return
operator|(
name|m
operator|-
name|s
operator|*
name|log
argument_list|(
name|q1
operator|*
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

