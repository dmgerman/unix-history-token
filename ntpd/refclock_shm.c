begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_shm - clock driver for utc via shared memory  * - under construction -  * To add new modes: Extend or union the shmTime-struct. Do not  * extend/shrink size, because otherwise existing implementations  * will specify wrong size of shared memory-segment  * PB 18.3.97  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_SHM
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_undef
undef|#
directive|undef
name|fileno
end_undef

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_undef
undef|#
directive|undef
name|fileno
end_undef

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_undef
undef|#
directive|undef
name|fileno
end_undef

begin_include
include|#
directive|include
file|"timespecops.h"
end_include

begin_undef
undef|#
directive|undef
name|fileno
end_undef

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_undef
undef|#
directive|undef
name|fileno
end_undef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_undef
undef|#
directive|undef
name|fileno
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This driver supports a reference clock attached thru shared memory  */
end_comment

begin_comment
comment|/*  * SHM interface definitions  */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-1)
end_define

begin_comment
comment|/* precision assumed (0.5 s) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"SHM"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"SHM/Shared memory interface"
end_define

begin_define
define|#
directive|define
name|NSAMPLES
value|3
end_define

begin_comment
comment|/* stages of median filter */
end_comment

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|shm_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shm_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shm_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shm_timer
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shm_peek
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shm_clockstats
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shm_control
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|const
name|struct
name|refclockstat
modifier|*
name|in_st
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out_st
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_shm
init|=
block|{
name|shm_start
block|,
comment|/* start up driver */
name|shm_shutdown
block|,
comment|/* shut down driver */
name|shm_poll
block|,
comment|/* transmit poll message */
name|shm_control
block|,
comment|/* control settings */
name|noentry
block|,
comment|/* not used: init */
name|noentry
block|,
comment|/* not used: buginfo */
name|shm_timer
block|,
comment|/* once per second */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|shmTime
block|{
name|int
name|mode
decl_stmt|;
comment|/* 0 - if valid is set: 		      *       use values, 		      *       clear valid 		      * 1 - if valid is set: 		      *       if count before and after read of values is equal, 		      *         use values 		      *       clear valid 		      */
specifier|volatile
name|int
name|count
decl_stmt|;
name|time_t
name|clockTimeStampSec
decl_stmt|;
name|int
name|clockTimeStampUSec
decl_stmt|;
name|time_t
name|receiveTimeStampSec
decl_stmt|;
name|int
name|receiveTimeStampUSec
decl_stmt|;
name|int
name|leap
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|int
name|nsamples
decl_stmt|;
specifier|volatile
name|int
name|valid
decl_stmt|;
name|unsigned
name|clockTimeStampNSec
decl_stmt|;
comment|/* Unsigned ns timestamps */
name|unsigned
name|receiveTimeStampNSec
decl_stmt|;
comment|/* Unsigned ns timestamps */
name|int
name|dummy
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|shmunit
block|{
name|struct
name|shmTime
modifier|*
name|shm
decl_stmt|;
comment|/* pointer to shared memory segment */
comment|/* debugging/monitoring counters - reset when printed */
name|int
name|ticks
decl_stmt|;
comment|/* number of attempts to read data*/
name|int
name|good
decl_stmt|;
comment|/* number of valid samples */
name|int
name|notready
decl_stmt|;
comment|/* number of peeks without data ready */
name|int
name|bad
decl_stmt|;
comment|/* number of invalid samples */
name|int
name|clash
decl_stmt|;
comment|/* number of access clashes while reading */
name|time_t
name|max_delta
decl_stmt|;
comment|/* difference limit */
name|time_t
name|max_delay
decl_stmt|;
comment|/* age/stale limit */
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|shmTime
modifier|*
name|getShmTime
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|shmTime
modifier|*
name|getShmTime
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
name|int
name|shmid
init|=
literal|0
decl_stmt|;
comment|/* 0x4e545030 is NTP0. 	 * Big units will give non-ascii but that's OK 	 * as long as everybody does it the same way. 	 */
name|shmid
operator|=
name|shmget
argument_list|(
literal|0x4e545030
operator|+
name|unit
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shmTime
argument_list|)
argument_list|,
name|IPC_CREAT
operator||
operator|(
operator|(
name|unit
operator|<
literal|2
operator|)
condition|?
literal|0600
else|:
literal|0666
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* error */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SHM shmget (unit %d): %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* no error  */
name|struct
name|shmTime
modifier|*
name|p
init|=
operator|(
expr|struct
name|shmTime
operator|*
operator|)
name|shmat
argument_list|(
name|shmid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
operator|(
expr|struct
name|shmTime
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* error */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SHM shmat (unit %d): %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|p
return|;
block|}
else|#
directive|else
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|LPSECURITY_ATTRIBUTES
name|psec
init|=
literal|0
decl_stmt|;
name|HANDLE
name|shmid
init|=
literal|0
decl_stmt|;
name|SECURITY_DESCRIPTOR
name|sd
decl_stmt|;
name|SECURITY_ATTRIBUTES
name|sa
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"NTP%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|2
condition|)
block|{
comment|/* world access */
if|if
condition|(
operator|!
name|InitializeSecurityDescriptor
argument_list|(
operator|&
name|sd
argument_list|,
name|SECURITY_DESCRIPTOR_REVISION
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SHM InitializeSecurityDescriptor (unit %d): %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|SetSecurityDescriptorDacl
argument_list|(
operator|&
name|sd
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SHM SetSecurityDescriptorDacl (unit %d): %m"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sa
operator|.
name|nLength
operator|=
sizeof|sizeof
argument_list|(
name|SECURITY_ATTRIBUTES
argument_list|)
expr_stmt|;
name|sa
operator|.
name|lpSecurityDescriptor
operator|=
operator|&
name|sd
expr_stmt|;
name|sa
operator|.
name|bInheritHandle
operator|=
literal|0
expr_stmt|;
name|psec
operator|=
operator|&
name|sa
expr_stmt|;
block|}
name|shmid
operator|=
name|CreateFileMapping
argument_list|(
operator|(
name|HANDLE
operator|)
literal|0xffffffff
argument_list|,
name|psec
argument_list|,
name|PAGE_READWRITE
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shmTime
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shmid
condition|)
block|{
comment|/*error*/
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
literal|0
argument_list|,
name|GetLastError
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SHM CreateFileMapping (unit %d): %s"
argument_list|,
name|unit
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|struct
name|shmTime
modifier|*
name|p
init|=
operator|(
expr|struct
name|shmTime
operator|*
operator|)
name|MapViewOfFile
argument_list|(
name|shmid
argument_list|,
name|FILE_MAP_WRITE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shmTime
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
comment|/*error*/
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
literal|0
argument_list|,
name|GetLastError
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
argument|LOG_ERR
argument_list|,
literal|"SHM MapViewOfFile (unit %d): %s"
argument_list|,
argument|unit
argument_list|,
argument|buf
argument_list|)
return|return
literal|0
return|;
block|}
return|return
name|p
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * shm_start - attach to shared memory  */
end_comment

begin_function
specifier|static
name|int
name|shm_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|shmunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|noentry
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|shm
operator|=
name|getShmTime
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize miscellaneous peer variables 	 */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|shm
operator|!=
literal|0
condition|)
block|{
name|pp
operator|->
name|unitptr
operator|=
name|up
expr_stmt|;
name|up
operator|->
name|shm
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|up
operator|->
name|shm
operator|->
name|precision
expr_stmt|;
name|up
operator|->
name|shm
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|shm
operator|->
name|nsamples
operator|=
name|NSAMPLES
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
comment|/* items to be changed later in 'shm_control()': */
name|up
operator|->
name|max_delay
operator|=
literal|5
expr_stmt|;
name|up
operator|->
name|max_delta
operator|=
literal|4
operator|*
literal|3600
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * shm_control - configure flag1/time2 params  *  * These are not yet available during 'shm_start', so we have to do any  * pre-computations we want to avoid during regular poll/timer callbacks  * in this callback.  */
end_comment

begin_function
specifier|static
name|void
name|shm_control
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|const
name|struct
name|refclockstat
modifier|*
name|in_st
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out_st
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|shmunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|up
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG1
condition|)
name|up
operator|->
name|max_delta
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|->
name|fudgetime2
operator|<
literal|1.
operator|||
name|pp
operator|->
name|fudgetime2
operator|>
literal|86400.
condition|)
name|up
operator|->
name|max_delta
operator|=
literal|4
operator|*
literal|3600
expr_stmt|;
else|else
name|up
operator|->
name|max_delta
operator|=
operator|(
name|time_t
operator|)
name|floor
argument_list|(
name|pp
operator|->
name|fudgetime2
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * shm_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|shm_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|shmunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|up
condition|)
return|return;
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* HMS: shmdt() wants char* or const void * */
operator|(
name|void
operator|)
name|shmdt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
operator|->
name|shm
argument_list|)
expr_stmt|;
else|#
directive|else
name|UnmapViewOfFile
argument_list|(
name|up
operator|->
name|shm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * shm_timer - called every second  */
end_comment

begin_function
specifier|static
name|void
name|shm_timer
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|shm_peek
argument_list|(
name|unit
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * shm_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|shm_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|shmunit
modifier|*
name|up
decl_stmt|;
name|int
name|major_error
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
comment|/* get dominant reason if we have no samples at all */
name|major_error
operator|=
name|max
argument_list|(
name|up
operator|->
name|notready
argument_list|,
name|up
operator|->
name|bad
argument_list|)
expr_stmt|;
name|major_error
operator|=
name|max
argument_list|(
name|major_error
argument_list|,
name|up
operator|->
name|clash
argument_list|)
expr_stmt|;
comment|/*          * Process median filter samples. If none received, see what          * happened, tell the core and keep going.          */
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|!=
name|pp
operator|->
name|codeproc
condition|)
block|{
comment|/* have some samples, everything OK */
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NULL
operator|==
name|up
operator|->
name|shm
condition|)
block|{
comment|/* is this possible at all? */
comment|/* we're out of business without SHM access */
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|major_error
operator|==
name|up
operator|->
name|clash
condition|)
block|{
comment|/* too many collisions is like a bad signal */
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_PROP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|major_error
operator|==
name|up
operator|->
name|bad
condition|)
block|{
comment|/* too much stale/bad/garbled data */
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* in any other case assume it's just a timeout */
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* shm_clockstats() clears the tallies, so it must be last... */
name|shm_clockstats
argument_list|(
name|unit
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * shm_peek - try to grab a sample  */
end_comment

begin_function
specifier|static
name|void
name|shm_peek
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|shmunit
modifier|*
name|up
decl_stmt|;
comment|/* access order is important for lock-free SHM access; we 	** enforce order by treating the whole structure volatile. 	** 	** IMPORTANT NOTE: This does not protect from reordering on CPU 	** level, and it does nothing for cache consistency and 	** visibility of changes by other cores. We need atomic and/or 	** fence instructions for that. 	*/
specifier|volatile
name|struct
name|shmTime
modifier|*
name|shm
decl_stmt|;
name|struct
name|timespec
name|tvr
decl_stmt|;
name|struct
name|timespec
name|tvt
decl_stmt|;
name|l_fp
name|tsrcv
decl_stmt|;
name|l_fp
name|tsref
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|unsigned
name|int
name|cns_new
decl_stmt|,
name|rns_new
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* for formatting 'a_lastcode': */
name|struct
name|calendar
name|cd
decl_stmt|;
name|time_t
name|tt
decl_stmt|,
name|now
decl_stmt|;
name|vint64
name|ts
decl_stmt|;
comment|/* 	 * This is the main routine. It snatches the time from the shm 	 * board and tacks on a local timestamp. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
name|up
operator|->
name|ticks
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|shm
operator|==
literal|0
condition|)
block|{
comment|/* try to map again - this may succeed if meanwhile some- 		body has ipcrm'ed the old (unaccessible) shared mem segment */
name|up
operator|->
name|shm
operator|=
name|getShmTime
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|shm
operator|=
name|up
operator|->
name|shm
expr_stmt|;
if|if
condition|(
name|shm
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: no SHM segment\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|shm
operator|->
name|valid
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: SHM not ready\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|notready
operator|++
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|shm
operator|->
name|mode
condition|)
block|{
case|case
literal|0
case|:
name|tvr
operator|.
name|tv_sec
operator|=
name|shm
operator|->
name|receiveTimeStampSec
expr_stmt|;
name|tvr
operator|.
name|tv_nsec
operator|=
name|shm
operator|->
name|receiveTimeStampUSec
operator|*
literal|1000
expr_stmt|;
name|rns_new
operator|=
name|shm
operator|->
name|receiveTimeStampNSec
expr_stmt|;
name|tvt
operator|.
name|tv_sec
operator|=
name|shm
operator|->
name|clockTimeStampSec
expr_stmt|;
name|tvt
operator|.
name|tv_nsec
operator|=
name|shm
operator|->
name|clockTimeStampUSec
operator|*
literal|1000
expr_stmt|;
name|cns_new
operator|=
name|shm
operator|->
name|clockTimeStampNSec
expr_stmt|;
comment|/* Since the following comparisons are between unsigned 		** variables they are always well defined, and any 		** (signed) underflow will turn into very large unsigned 		** values, well above the 1000 cutoff. 		** 		** Note: The usecs *must* be a *truncated* 		** representation of the nsecs. This code will fail for 		** *rounded* usecs, and the logic to deal with 		** wrap-arounds in the presence of rounded values is 		** much more convoluted. 		*/
if|if
condition|(
operator|(
operator|(
name|cns_new
operator|-
operator|(
name|unsigned
operator|)
name|tvt
operator|.
name|tv_nsec
operator|)
operator|<
literal|1000
operator|)
operator|&&
operator|(
operator|(
name|rns_new
operator|-
operator|(
name|unsigned
operator|)
name|tvr
operator|.
name|tv_nsec
operator|)
operator|<
literal|1000
operator|)
condition|)
block|{
name|tvt
operator|.
name|tv_nsec
operator|=
name|cns_new
expr_stmt|;
name|tvr
operator|.
name|tv_nsec
operator|=
name|rns_new
expr_stmt|;
block|}
comment|/* At this point tvr and tvt contains valid ns-level 		** timestamps, possibly generated by extending the old 		** us-level timestamps 		*/
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: SHM type 0 sample\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cnt
operator|=
name|shm
operator|->
name|count
expr_stmt|;
name|tvr
operator|.
name|tv_sec
operator|=
name|shm
operator|->
name|receiveTimeStampSec
expr_stmt|;
name|tvr
operator|.
name|tv_nsec
operator|=
name|shm
operator|->
name|receiveTimeStampUSec
operator|*
literal|1000
expr_stmt|;
name|rns_new
operator|=
name|shm
operator|->
name|receiveTimeStampNSec
expr_stmt|;
name|tvt
operator|.
name|tv_sec
operator|=
name|shm
operator|->
name|clockTimeStampSec
expr_stmt|;
name|tvt
operator|.
name|tv_nsec
operator|=
name|shm
operator|->
name|clockTimeStampUSec
operator|*
literal|1000
expr_stmt|;
name|cns_new
operator|=
name|shm
operator|->
name|clockTimeStampNSec
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
name|shm
operator|->
name|count
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: type 1 access clash\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"SHM: access clash in shared memory"
argument_list|)
expr_stmt|;
name|up
operator|->
name|clash
operator|++
expr_stmt|;
return|return;
block|}
comment|/* See the case above for an explanation of the 		** following test. 		*/
if|if
condition|(
operator|(
operator|(
name|cns_new
operator|-
operator|(
name|unsigned
operator|)
name|tvt
operator|.
name|tv_nsec
operator|)
operator|<
literal|1000
operator|)
operator|&&
operator|(
operator|(
name|rns_new
operator|-
operator|(
name|unsigned
operator|)
name|tvr
operator|.
name|tv_nsec
operator|)
operator|<
literal|1000
operator|)
condition|)
block|{
name|tvt
operator|.
name|tv_nsec
operator|=
name|cns_new
expr_stmt|;
name|tvr
operator|.
name|tv_nsec
operator|=
name|rns_new
expr_stmt|;
block|}
comment|/* At this point tvr and tvt contains valid ns-level 		** timestamps, possibly generated by extending the old 		** us-level timestamps 		*/
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: SHM type 1 sample\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: SHM type blooper, mode=%d\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|shm
operator|->
name|mode
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|bad
operator|++
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SHM: bad mode found in shared memory: %d"
argument_list|,
name|shm
operator|->
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
name|shm
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
comment|/* format the last time code in human-readable form into 	 * 'pp->a_lastcode'. Someone claimed: "NetBSD has incompatible 	 * tv_sec". I can't find a base for this claim, but we can work 	 * around that potential problem. BTW, simply casting a pointer 	 * is a receipe for disaster on some architectures. 	 */
name|tt
operator|=
operator|(
name|time_t
operator|)
name|tvt
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|=
name|time_to_vint64
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|ntpcal_time_to_date
argument_list|(
operator|&
name|cd
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* add ntpq -c cv timecode in ISO 8601 format */
name|c
operator|=
name|snprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
argument_list|,
literal|"%04u-%02u-%02uT%02u:%02u:%02u.%09ldZ"
argument_list|,
name|cd
operator|.
name|year
argument_list|,
name|cd
operator|.
name|month
argument_list|,
name|cd
operator|.
name|monthday
argument_list|,
name|cd
operator|.
name|hour
argument_list|,
name|cd
operator|.
name|minute
argument_list|,
name|cd
operator|.
name|second
argument_list|,
operator|(
name|long
operator|)
name|tvt
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
operator|(
name|c
operator|<
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
operator|)
condition|?
name|c
else|:
literal|0
expr_stmt|;
comment|/* check 1: age control of local time stamp */
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|tt
operator|=
name|now
operator|-
name|tvr
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|tt
operator|<
literal|0
operator|||
name|tt
operator|>
name|up
operator|->
name|max_delay
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s:SHM stale/bad receive time, delay=%llds\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
operator|(
name|long
name|long
operator|)
name|tt
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|bad
operator|++
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SHM: stale/bad receive time, delay=%llds"
argument_list|,
operator|(
name|long
name|long
operator|)
name|tt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* check 2: delta check */
name|tt
operator|=
name|tvr
operator|.
name|tv_sec
operator|-
name|tvt
operator|.
name|tv_sec
operator|-
operator|(
name|tvr
operator|.
name|tv_nsec
operator|<
name|tvt
operator|.
name|tv_nsec
operator|)
expr_stmt|;
if|if
condition|(
name|tt
operator|<
literal|0
condition|)
name|tt
operator|=
operator|-
name|tt
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|max_delta
operator|>
literal|0
operator|&&
name|tt
operator|>
name|up
operator|->
name|max_delta
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: SHM diff limit exceeded, delta=%llds\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
operator|(
name|long
name|long
operator|)
name|tt
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|bad
operator|++
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SHM: difference limit exceeded, delta=%llds\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|tt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if we really made it to this point... we're winners! */
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%s: SHM feeding data\n"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tsrcv
operator|=
name|tspec_stamp_to_lfp
argument_list|(
name|tvr
argument_list|)
expr_stmt|;
name|tsref
operator|=
name|tspec_stamp_to_lfp
argument_list|(
name|tvt
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|shm
operator|->
name|leap
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|shm
operator|->
name|precision
expr_stmt|;
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|tsref
argument_list|,
name|tsrcv
argument_list|,
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
name|up
operator|->
name|good
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * shm_clockstats - dump and reset counters  */
end_comment

begin_function
specifier|static
name|void
name|shm_clockstats
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|shmunit
modifier|*
name|up
decl_stmt|;
name|char
name|logbuf
index|[
literal|64
index|]
decl_stmt|;
name|unsigned
name|int
name|llen
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
comment|/* if snprintf() returns a negative values on errors 		** (some older ones do) make sure we are NUL 		** terminated. Using an unsigned result does the trick. 		*/
name|llen
operator|=
name|snprintf
argument_list|(
name|logbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|logbuf
argument_list|)
argument_list|,
literal|"%3d %3d %3d %3d %3d"
argument_list|,
name|up
operator|->
name|ticks
argument_list|,
name|up
operator|->
name|good
argument_list|,
name|up
operator|->
name|notready
argument_list|,
name|up
operator|->
name|bad
argument_list|,
name|up
operator|->
name|clash
argument_list|)
expr_stmt|;
name|logbuf
index|[
name|min
argument_list|(
name|llen
argument_list|,
sizeof|sizeof
argument_list|(
name|logbuf
argument_list|)
operator|-
literal|1
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|logbuf
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|ticks
operator|=
name|up
operator|->
name|good
operator|=
name|up
operator|->
name|notready
operator|=
name|up
operator|->
name|bad
operator|=
name|up
operator|->
name|clash
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_macro
name|NONEMPTY_TRANSLATION_UNIT
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

