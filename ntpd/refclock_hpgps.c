begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_hpgps - clock driver for HP 58503A GPS receiver  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_HPGPS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Version 0.1 April  1, 1995    *         0.2 April 25, 1995  *             tolerant of missing timecode response prompt and sends  *             clear status if prompt indicates error;  *             can use either local time or UTC from receiver;  *             can get receiver status screen via flag4  *  * WARNING!: This driver is UNDER CONSTRUCTION  * Everything in here should be treated with suspicion.  * If it looks wrong, it probably is.  *  * Comments and/or questions to: Dave Vitanye  *                               Hewlett Packard Company  *                               dave@scd.hp.com  *                               (408) 553-2856  *  * Thanks to the author of the PST driver, which was the starting point for  * this one.  *  * This driver supports the HP 58503A Time and Frequency Reference Receiver.  * This receiver uses HP SmartClock (TM) to implement an Enhanced GPS receiver.  * The receiver accuracy when locked to GPS in normal operation is better  * than 1 usec. The accuracy when operating in holdover is typically better  * than 10 usec. per day.  *  * The same driver also handles the HP Z3801A which is available surplus  * from the cell phone industry.  It's popular with hams.  * It needs a different line setup: 19200 baud, 7 data bits, odd parity  * That is selected by adding "mode 1" to the server line in ntp.conf  * HP Z3801A code from Jeff Mock added by Hal Murray, Sep 2005  *  *  * The receiver should be operated with factory default settings.  * Initial driver operation: expects the receiver to be already locked  * to GPS, configured and able to output timecode format 2 messages.  *  * The driver uses the poll sequence :PTIME:TCODE? to get a response from  * the receiver. The receiver responds with a timecode string of ASCII  * printing characters, followed by a<cr><lf>, followed by a prompt string  * issued by the receiver, in the following format:  * T#yyyymmddhhmmssMFLRVcc<cr><lf>scpi>   *  * The driver processes the response at the<cr> and<lf>, so what the  * driver sees is the prompt from the previous poll, followed by this  * timecode. The prompt from the current poll is (usually) left unread until  * the next poll. So (except on the very first poll) the driver sees this:  *  * scpi> T#yyyymmddhhmmssMFLRVcc<cr><lf>  *  * The T is the on-time character, at 980 msec. before the next 1PPS edge.  * The # is the timecode format type. We look for format 2.  * Without any of the CLK or PPS stuff, then, the receiver buffer timestamp  * at the<cr> is 24 characters later, which is about 25 msec. at 9600 bps,  * so the first approximation for fudge time1 is nominally -0.955 seconds.  * This number probably needs adjusting for each machine / OS type, so far:  *  -0.955000 on an HP 9000 Model 712/80 HP-UX 9.05  *  -0.953175 on an HP 9000 Model 370    HP-UX 9.10   *  * This receiver also provides a 1PPS signal, but I haven't figured out  * how to deal with any of the CLK or PPS stuff yet. Stay tuned.  *  */
end_comment

begin_comment
comment|/*  * Fudge Factors  *  * Fudge time1 is used to accomodate the timecode serial interface adjustment.  * Fudge flag4 can be set to request a receiver status screen summary, which  * is recorded in the clockstats file.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/hpgps%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B9600
end_define

begin_comment
comment|/* uart speed (9600 baud) */
end_comment

begin_define
define|#
directive|define
name|SPEED232Z
value|B19200
end_define

begin_comment
comment|/* uart speed (19200 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"GPS\0"
end_define

begin_comment
comment|/*  reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"HP 58503A GPS Time and Frequency Reference Receiver"
end_define

begin_define
define|#
directive|define
name|SMAX
value|23*80+1
end_define

begin_comment
comment|/* for :SYSTEM:PRINT? status screen response */
end_comment

begin_define
define|#
directive|define
name|MTZONE
value|2
end_define

begin_comment
comment|/* number of fields in timezone reply */
end_comment

begin_define
define|#
directive|define
name|MTCODET2
value|12
end_define

begin_comment
comment|/* number of fields in timecode format T2 */
end_comment

begin_define
define|#
directive|define
name|NTCODET2
value|21
end_define

begin_comment
comment|/* number of chars to checksum in format T2 */
end_comment

begin_comment
comment|/*  * Tables to compute the day of year from yyyymmdd timecode.  * Viva la leap.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|day1tab
index|[]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|day2tab
index|[]
init|=
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|hpgpsunit
block|{
name|int
name|pollcnt
decl_stmt|;
comment|/* poll message counter */
name|int
name|tzhour
decl_stmt|;
comment|/* timezone offset, hours */
name|int
name|tzminute
decl_stmt|;
comment|/* timezone offset, minutes */
name|int
name|linecnt
decl_stmt|;
comment|/* set for expected multiple line responses */
name|char
modifier|*
name|lastptr
decl_stmt|;
comment|/* pointer to receiver response data */
name|char
name|statscrn
index|[
name|SMAX
index|]
decl_stmt|;
comment|/* receiver status screen buffer */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|hpgps_start
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpgps_shutdown
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpgps_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpgps_poll
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_hpgps
init|=
block|{
name|hpgps_start
block|,
comment|/* start up driver */
name|hpgps_shutdown
block|,
comment|/* shut down driver */
name|hpgps_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old hpgps_control) */
name|noentry
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* not used (old hpgps_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * hpgps_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|hpgps_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|hpgpsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|speed
decl_stmt|,
name|ldisc
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Open serial port. Use CLK line discipline, if available. 	 * Default is HP 58503A, mode arg selects HP Z3801A 	 */
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ldisc
operator|=
name|LDISC_CLK
expr_stmt|;
name|speed
operator|=
name|SPEED232
expr_stmt|;
comment|/* mode parameter to server config line shares ttl slot */
if|if
condition|(
literal|1
operator|==
name|peer
operator|->
name|ttl
condition|)
block|{
name|ldisc
operator||=
name|LDISC_7O1
expr_stmt|;
name|speed
operator|=
name|SPEED232Z
expr_stmt|;
block|}
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|speed
argument_list|,
name|ldisc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
name|up
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|hpgps_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|tzhour
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|tzminute
operator|=
literal|0
expr_stmt|;
operator|*
name|up
operator|->
name|statscrn
operator|=
literal|'\0'
expr_stmt|;
name|up
operator|->
name|lastptr
operator|=
name|up
operator|->
name|statscrn
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Get the identifier string, which is logged but otherwise ignored, 	 * and get the local timezone information 	 */
name|up
operator|->
name|linecnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"*IDN?\r:PTIME:TZONE?\r"
argument_list|,
literal|20
argument_list|)
operator|!=
literal|20
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * hpgps_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|hpgps_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|hpgpsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|up
condition|)
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * hpgps_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|hpgps_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|hpgpsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
name|trtmp
decl_stmt|;
name|char
name|tcodechar1
decl_stmt|;
comment|/* identifies timecode format */
name|char
name|tcodechar2
decl_stmt|;
comment|/* identifies timecode format */
name|char
name|timequal
decl_stmt|;
comment|/* time figure of merit: 0-9 */
name|char
name|freqqual
decl_stmt|;
comment|/* frequency figure of merit: 0-3 */
name|char
name|leapchar
decl_stmt|;
comment|/* leapsecond: + or 0 or - */
name|char
name|servchar
decl_stmt|;
comment|/* request for service: 0 = no, 1 = yes */
name|char
name|syncchar
decl_stmt|;
comment|/* time info is invalid: 0 = no, 1 = yes */
name|short
name|expectedsm
decl_stmt|;
comment|/* expected timecode byte checksum */
name|short
name|tcodechksm
decl_stmt|;
comment|/* computed timecode byte checksum */
name|int
name|i
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
name|int
name|month
decl_stmt|,
name|day
decl_stmt|,
name|lastday
decl_stmt|;
name|char
modifier|*
name|tcp
decl_stmt|;
comment|/* timecode pointer (skips over the prompt) */
name|char
name|prompt
index|[
name|BMAX
index|]
decl_stmt|;
comment|/* prompt in response from receiver */
comment|/* 	 * Initialize pointers and read the receiver response 	 */
name|peer
operator|=
name|rbufp
operator|->
name|recv_peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
operator|*
name|pp
operator|->
name|a_lastcode
operator|=
literal|'\0'
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|trtmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: lencode: %d timecode:%s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If there's no characters in the reply, we can quit now 	 */
if|if
condition|(
name|pp
operator|->
name|lencode
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If linecnt is greater than zero, we are getting information only, 	 * such as the receiver identification string or the receiver status 	 * screen, so put the receiver response at the end of the status 	 * screen buffer. When we have the last line, write the buffer to 	 * the clockstats file and return without further processing. 	 * 	 * If linecnt is zero, we are expecting either the timezone 	 * or a timecode. At this point, also write the response 	 * to the clockstats file, and go on to process the prompt (if any), 	 * timezone, or timecode and timestamp. 	 */
if|if
condition|(
name|up
operator|->
name|linecnt
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|lencode
operator|+
literal|2
argument_list|)
operator|<=
operator|(
name|SMAX
operator|-
operator|(
name|up
operator|->
name|lastptr
operator|-
name|up
operator|->
name|statscrn
operator|)
operator|)
condition|)
block|{
operator|*
name|up
operator|->
name|lastptr
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|memcpy
argument_list|(
name|up
operator|->
name|lastptr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
name|pp
operator|->
name|lencode
argument_list|)
expr_stmt|;
name|up
operator|->
name|lastptr
operator|+=
name|pp
operator|->
name|lencode
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|linecnt
operator|==
literal|0
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|up
operator|->
name|statscrn
argument_list|)
expr_stmt|;
return|return;
block|}
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|trtmp
expr_stmt|;
name|up
operator|->
name|lastptr
operator|=
name|up
operator|->
name|statscrn
expr_stmt|;
operator|*
name|up
operator|->
name|lastptr
operator|=
literal|'\0'
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
comment|/* 	 * We get down to business: get a prompt if one is there, issue 	 * a clear status command if it contains an error indication. 	 * Next, check for either the timezone reply or the timecode reply 	 * and decode it.  If we don't recognize the reply, or don't get the 	 * proper number of decoded fields, or get an out of range timezone, 	 * or if the timecode checksum is bad, then we declare bad format 	 * and exit. 	 * 	 * Timezone format (including nominal prompt): 	 * scpi> -H,-M<cr><lf> 	 * 	 * Timecode format (including nominal prompt): 	 * scpi> T2yyyymmddhhmmssMFLRVcc<cr><lf> 	 * 	 */
name|strlcpy
argument_list|(
name|prompt
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
sizeof|sizeof
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
name|tcp
operator|=
name|strrchr
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp
operator|==
name|NULL
condition|)
name|tcp
operator|=
name|pp
operator|->
name|a_lastcode
expr_stmt|;
else|else
name|tcp
operator|++
expr_stmt|;
name|prompt
index|[
name|tcp
operator|-
name|pp
operator|->
name|a_lastcode
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|tcp
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|tcp
operator|==
literal|'\t'
operator|)
condition|)
name|tcp
operator|++
expr_stmt|;
comment|/* 	 * deal with an error indication in the prompt here 	 */
if|if
condition|(
name|strrchr
argument_list|(
name|prompt
argument_list|,
literal|'E'
argument_list|)
operator|>
name|strrchr
argument_list|(
name|prompt
argument_list|,
literal|'s'
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: error indicated in prompt: %s\n"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"*CLS\r\r"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|6
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * make sure we got a timezone or timecode format and  	 * then process accordingly 	 */
name|m
operator|=
name|sscanf
argument_list|(
name|tcp
argument_list|,
literal|"%c%c"
argument_list|,
operator|&
name|tcodechar1
argument_list|,
operator|&
name|tcodechar2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: no format indicator\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|tcodechar1
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
name|m
operator|=
name|sscanf
argument_list|(
name|tcp
argument_list|,
literal|"%d,%d"
argument_list|,
operator|&
name|up
operator|->
name|tzhour
argument_list|,
operator|&
name|up
operator|->
name|tzminute
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|MTZONE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: only %d fields recognized in timezone\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|up
operator|->
name|tzhour
operator|<
operator|-
literal|12
operator|)
operator|||
operator|(
name|up
operator|->
name|tzhour
operator|>
literal|13
operator|)
operator|||
operator|(
name|up
operator|->
name|tzminute
operator|<
operator|-
literal|59
operator|)
operator|||
operator|(
name|up
operator|->
name|tzminute
operator|>
literal|59
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: timezone %d, %d out of range\n"
argument_list|,
name|up
operator|->
name|tzhour
argument_list|,
name|up
operator|->
name|tzminute
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
case|case
literal|'T'
case|:
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: unrecognized reply format %c%c\n"
argument_list|,
name|tcodechar1
argument_list|,
name|tcodechar2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* end of tcodechar1 switch */
switch|switch
condition|(
name|tcodechar2
condition|)
block|{
case|case
literal|'2'
case|:
name|m
operator|=
name|sscanf
argument_list|(
name|tcp
argument_list|,
literal|"%*c%*c%4d%2d%2d%2d%2d%2d%c%c%c%c%c%2hx"
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|timequal
argument_list|,
operator|&
name|freqqual
argument_list|,
operator|&
name|leapchar
argument_list|,
operator|&
name|servchar
argument_list|,
operator|&
name|syncchar
argument_list|,
operator|&
name|expectedsm
argument_list|)
expr_stmt|;
name|n
operator|=
name|NTCODET2
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|MTCODET2
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: only %d fields recognized in timecode\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: unrecognized timecode format %c%c\n"
argument_list|,
name|tcodechar1
argument_list|,
name|tcodechar2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* end of tcodechar2 format switch */
comment|/*  	 * Compute and verify the checksum. 	 * Characters are summed starting at tcodechar1, ending at just 	 * before the expected checksum.  Bail out if incorrect. 	 */
name|tcodechksm
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|tcodechksm
operator|+=
operator|*
name|tcp
operator|++
expr_stmt|;
name|tcodechksm
operator|&=
literal|0x00ff
expr_stmt|;
if|if
condition|(
name|tcodechksm
operator|!=
name|expectedsm
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: checksum %2hX doesn't match %2hX expected\n"
argument_list|,
name|tcodechksm
argument_list|,
name|expectedsm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  	 * Compute the day of year from the yyyymmdd format. 	 */
if|if
condition|(
name|month
operator|<
literal|1
operator|||
name|month
operator|>
literal|12
operator|||
name|day
operator|<
literal|1
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|isleap_4
argument_list|(
name|pp
operator|->
name|year
argument_list|)
condition|)
block|{
comment|/* Y2KFixes */
comment|/* not a leap year */
if|if
condition|(
name|day
operator|>
name|day1tab
index|[
name|month
operator|-
literal|1
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|month
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|day
operator|+=
name|day1tab
index|[
name|i
index|]
expr_stmt|;
name|lastday
operator|=
literal|365
expr_stmt|;
block|}
else|else
block|{
comment|/* a leap year */
if|if
condition|(
name|day
operator|>
name|day2tab
index|[
name|month
operator|-
literal|1
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|month
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|day
operator|+=
name|day2tab
index|[
name|i
index|]
expr_stmt|;
name|lastday
operator|=
literal|366
expr_stmt|;
block|}
comment|/* 	 * Deal with the timezone offset here. The receiver timecode is in 	 * local time = UTC + :PTIME:TZONE, so SUBTRACT the timezone values. 	 * For example, Pacific Standard Time is -8 hours , 0 minutes. 	 * Deal with the underflows and overflows. 	 */
name|pp
operator|->
name|minute
operator|-=
name|up
operator|->
name|tzminute
expr_stmt|;
name|pp
operator|->
name|hour
operator|-=
name|up
operator|->
name|tzhour
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|minute
operator|<
literal|0
condition|)
block|{
name|pp
operator|->
name|minute
operator|+=
literal|60
expr_stmt|;
name|pp
operator|->
name|hour
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|minute
operator|>
literal|59
condition|)
block|{
name|pp
operator|->
name|minute
operator|-=
literal|60
expr_stmt|;
name|pp
operator|->
name|hour
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|hour
operator|<
literal|0
condition|)
block|{
name|pp
operator|->
name|hour
operator|+=
literal|24
expr_stmt|;
name|day
operator|--
expr_stmt|;
if|if
condition|(
name|day
operator|<
literal|1
condition|)
block|{
name|pp
operator|->
name|year
operator|--
expr_stmt|;
if|if
condition|(
name|isleap_4
argument_list|(
name|pp
operator|->
name|year
argument_list|)
condition|)
comment|/* Y2KFixes */
name|day
operator|=
literal|366
expr_stmt|;
else|else
name|day
operator|=
literal|365
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pp
operator|->
name|hour
operator|>
literal|23
condition|)
block|{
name|pp
operator|->
name|hour
operator|-=
literal|24
expr_stmt|;
name|day
operator|++
expr_stmt|;
if|if
condition|(
name|day
operator|>
name|lastday
condition|)
block|{
name|pp
operator|->
name|year
operator|++
expr_stmt|;
name|day
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|pp
operator|->
name|day
operator|=
name|day
expr_stmt|;
comment|/* 	 * Decode the MFLRV indicators. 	 * NEED TO FIGURE OUT how to deal with the request for service, 	 * time quality, and frequency quality indicators some day.  	 */
if|if
condition|(
name|syncchar
operator|!=
literal|'0'
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
switch|switch
condition|(
name|leapchar
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
comment|/* See http://bugs.ntp.org/1090 		     * Ignore leap announcements unless June or December. 		     * Better would be to use :GPSTime? to find the month, 		     * but that seems too likely to introduce other bugs. 		     */
case|case
literal|'+'
case|:
if|if
condition|(
operator|(
name|month
operator|==
literal|6
operator|)
operator|||
operator|(
name|month
operator|==
literal|12
operator|)
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
operator|(
name|month
operator|==
literal|6
operator|)
operator|||
operator|(
name|month
operator|==
literal|12
operator|)
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"hpgps: unrecognized leap indicator: %c\n"
argument_list|,
name|leapchar
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* end of leapchar switch */
block|}
comment|/* 	 * Process the new sample in the median filter and determine the 	 * reference clock offset and dispersion. We use lastrec as both 	 * the reference time and receive time in order to avoid being 	 * cute, like setting the reference time later than the receive 	 * time, which may cause a paranoid protocol module to chuck out 	 * the data. 	 */
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* 	 * If CLK_FLAG4 is set, ask for the status screen response. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
name|up
operator|->
name|linecnt
operator|=
literal|22
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|":SYSTEM:PRINT?\r"
argument_list|,
literal|15
argument_list|)
operator|!=
literal|15
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * hpgps_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|hpgps_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|hpgpsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Time to poll the clock. The HP 58503A responds to a 	 * ":PTIME:TCODE?" by returning a timecode in the format specified 	 * above. If nothing is heard from the clock for two polls, 	 * declare a timeout and keep going. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|pollcnt
operator|==
literal|0
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|pollcnt
operator|--
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|":PTIME:TCODE?\r"
argument_list|,
literal|14
argument_list|)
operator|!=
literal|14
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
block|}
else|else
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_hpgps_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

