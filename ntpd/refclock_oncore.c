begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * refclock_oncore.c  *  * Driver for some of the various the Motorola Oncore GPS receivers.  *   should work with Basic, PVT6, VP, UT, UT+, GT, GT+, SL, M12, M12+T  *	The receivers with TRAIM (VP, UT, UT+, M12+T), will be more accurate  *	than the others.  *	The receivers without position hold (GT, GT+) will be less accurate.  *  * Tested with:  *  *		(UT)				   (VP)  *   COPYRIGHT 1991-1997 MOTOROLA INC.	COPYRIGHT 1991-1996 MOTOROLA INC.  *   SFTW P/N #     98-P36848P		SFTW P/N # 98-P36830P  *   SOFTWARE VER # 2			SOFTWARE VER # 8  *   SOFTWARE REV # 2			SOFTWARE REV # 8  *   SOFTWARE DATE  APR 24 1998 	SOFTWARE DATE  06 Aug 1996  *   MODEL #	R1121N1114		MODEL #    B4121P1155  *   HWDR P/N # 1			HDWR P/N # _  *   SERIAL #	R0010A			SERIAL #   SSG0226478  *   MANUFACTUR DATE 6H07		MANUFACTUR DATE 7E02  *					OPTIONS LIST	IB  *  *	      (Basic)				   (M12)  *   COPYRIGHT 1991-1994 MOTOROLA INC.	COPYRIGHT 1991-2000 MOTOROLA INC.  *   SFTW P/N # 98-P39949M		SFTW P/N # 61-G10002A  *   SOFTWARE VER # 5			SOFTWARE VER # 1  *   SOFTWARE REV # 0			SOFTWARE REV # 3  *   SOFTWARE DATE  20 JAN 1994 	SOFTWARE DATE  Mar 13 2000  *   MODEL #	A11121P116		MODEL #    P143T12NR1  *   HDWR P/N # _			HWDR P/N # 1  *   SERIAL #	SSG0049809		SERIAL #   P003UD  *   MANUFACTUR DATE 417AMA199		MANUFACTUR DATE 0C27  *   OPTIONS LIST    AB  *  *	      (M12+T)				  (M12+T later version)  *   COPYRIGHT 1991-2002 MOTOROLA INC.	COPYRIGHT 1991-2003 MOTOROLA INC.  *   SFTW P/N #     61-G10268A		SFTW P/N #     61-G10268A  *   SOFTWARE VER # 2			SOFTWARE VER # 2  *   SOFTWARE REV # 0			SOFTWARE REV # 1  *   SOFTWARE DATE  AUG 14 2002 	SOFTWARE DATE  APR 16 2003  *   MODEL #	P283T12T11		MODEL #    P273T12T12  *   HWDR P/N # 2			HWDR P/N # 2  *   SERIAL #	P04DC2			SERIAL #   P05Z7Z  *   MANUFACTUR DATE 2J17		MANUFACTUR DATE 3G15  *  * --------------------------------------------------------------------------  * Reg Clemens (June 2009)  * BUG[1220] OK, big patch, but mostly done mechanically.  Change direct calls to write  * to clockstats to a call to oncore_log, which now calls the old routine plus msyslog.  * Have to set the LOG_LEVELS of the calls for msyslog, and this was done by hand. New  * routine oncore_log.  * --------------------------------------------------------------------------  * Reg Clemens (June 2009)  * BUG[1218] The comment on where the oncore driver gets its input file does not  * agree with the code.  Change the comment.  * --------------------------------------------------------------------------  * Reg Clemens (June 2009)  * change exit statements to return(0) in main program.  I had assumed that if the  * PPS driver did not start for some reason, we shuould stop NTPD itelf.  Others  * disagree.  We now give an ERR log message and stop this driver.  * --------------------------------------------------------------------------  * Reg Clemens (June 2009)  * A bytes available message for the input subsystem (Debug message).  * --------------------------------------------------------------------------  * Reg Clemens (Nov 2008)  * This code adds a message for TRAIM messages.  Users often worry about the  * driver not starting up, and it is often because of signal strength being low.  * Low signal strength will give TRAIM messages.  * --------------------------------------------------------------------------  * Reg Clemens (Nov 2008)  * Add waiting on Almanac Message.  * --------------------------------------------------------------------------  * Reg Clemens (Nov 2008)  * Add back in @@Bl code to do the @@Bj/@@Gj that is in later ONCOREs  * LEAP SECONDS: All of the ONCORE receivers, VP -> M12T have the @@Bj command  * that says 'Leap Pending'.  As documented it only becomes true in the month  * before the leap second is to be applied, but in practice at least some of  * the receivers turn this indicator on as soon as the message is posted, which  * can be 6months early.  As such, we use the Bj command to turn on the  * instance->pp->leap indicator but only run this test in December and June for  * updates on 1Jan and 1July.  *  * The @@Gj command exists in later ONCOREs, and it gives the exact date  * and size of the Leap Update.  It can be emulated in the VP using the @@Bl  * command which reads the raw Satellite Broadcast Messages.  * We use these two commands to print informative messages in the clockstats  * file once per day as soon as the message appears on the satellites.  * --------------------------------------------------------------------------  * Reg Clemens (Feb 2006)  * Fix some gcc4 compiler complaints  * Fix possible segfault in oncore_init_shmem  * change all (possible) fprintf(stderr, to record_clock_stats  * Apply patch from Russell J. Yount<rjy@cmu.edu> Fixed (new) MT12+T UTC not correct  *   immediately after new Almanac Read.  * Apply patch for new PPS implementation by Rodolfo Giometti<giometti@linux.it>  *   now code can use old Ulrich Windl<Ulrich.Windl@rz.uni-regensburg.de> or  *   the new one.  Compiles depending on timepps.h seen.  * --------------------------------------------------------------------------  * Luis Batanero Guerrero<luisba@rao.es> (Dec 2005) Patch for leap seconds  * (the oncore driver was setting the wrong ntpd variable)  * --------------------------------------------------------------------------  * Reg.Clemens (Mar 2004)  * Support for interfaces other than PPSAPI removed, for Solaris, SunOS,  * SCO, you now need to use one of the timepps.h files in the root dir.  * this driver will 'grab' it for you if you dont have one in /usr/include  * --------------------------------------------------------------------------  * This code uses the two devices  *	/dev/oncore.serial.n  *	/dev/oncore.pps.n  * which may be linked to the same device.  * and can read initialization data from the file  *	/etc/ntp.oncoreN, /etc/ntp.oncore.N, or /etc/ntp.oncore, where  *	n or N are the unit number, viz 127.127.30.N.  * --------------------------------------------------------------------------  * Reg.Clemens<reg@dwf.com> Sep98.  *  Original code written for FreeBSD.  *  With these mods it works on FreeBSD, SunOS, Solaris and Linux  *    (SunOS 4.1.3 + ppsclock)  *    (Solaris7 + MU4)  *    (RedHat 5.1 2.0.35 + PPSKit, 2.1.126 + or later).  *  *  Lat,Long,Ht, cable-delay, offset, and the ReceiverID (along with the  *  state machine state) are printed to CLOCKSTATS if that file is enabled  *  in /etc/ntp.conf.  *  * --------------------------------------------------------------------------  *  * According to the ONCORE manual (TRM0003, Rev 3.2, June 1998, page 3.13)  * doing an average of 10000 valid 2D and 3D fixes is what the automatic  * site survey mode does.  Looking at the output from the receiver  * it seems like it is only using 3D fixes.  * When we do it ourselves, take 10000 3D fixes.  */
end_comment

begin_define
define|#
directive|define
name|POS_HOLD_AVERAGE
value|10000
end_define

begin_comment
comment|/* nb, 10000s ~= 2h45m */
end_comment

begin_comment
comment|/*  * ONCORE_SHMEM_STATUS will create a mmap(2)'ed file named according to a  * "STATUS" line in the oncore config file, which contains the most recent  * copy of all types of messages we recognize.	This file can be mmap(2)'ed  * by monitoring and statistics programs.  *  * See separate HTML documentation for this option.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_ONCORE
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MMAN_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|((u_char *) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAP_FAILED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_MMAN_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ONCORE_SHMEM_STATUS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_include
include|#
directive|include
file|"ppsapi_timepps.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|Bl
block|{
name|int
name|dt_ls
decl_stmt|;
name|int
name|dt_lsf
decl_stmt|;
name|int
name|WN
decl_stmt|;
name|int
name|DN
decl_stmt|;
name|int
name|WN_lsf
decl_stmt|;
name|int
name|DN_lsf
decl_stmt|;
name|int
name|wn_flg
decl_stmt|;
name|int
name|lsf_flg
decl_stmt|;
name|int
name|Bl_day
decl_stmt|;
block|}
name|Bl
struct|;
end_struct

begin_enum
enum|enum
name|receive_state
block|{
name|ONCORE_NO_IDEA
block|,
name|ONCORE_CHECK_ID
block|,
name|ONCORE_CHECK_CHAN
block|,
name|ONCORE_HAVE_CHAN
block|,
name|ONCORE_RESET_SENT
block|,
name|ONCORE_TEST_SENT
block|,
name|ONCORE_INIT
block|,
name|ONCORE_ALMANAC
block|,
name|ONCORE_RUN
block|}
enum|;
end_enum

begin_enum
enum|enum
name|site_survey_state
block|{
name|ONCORE_SS_UNKNOWN
block|,
name|ONCORE_SS_TESTING
block|,
name|ONCORE_SS_HW
block|,
name|ONCORE_SS_SW
block|,
name|ONCORE_SS_DONE
block|}
enum|;
end_enum

begin_enum
enum|enum
name|antenna_state
block|{
name|ONCORE_ANTENNA_UNKNOWN
init|=
operator|-
literal|1
block|,
name|ONCORE_ANTENNA_OK
init|=
literal|0
block|,
name|ONCORE_ANTENNA_OC
init|=
literal|1
block|,
name|ONCORE_ANTENNA_UC
init|=
literal|2
block|,
name|ONCORE_ANTENNA_NV
init|=
literal|3
block|}
enum|;
end_enum

begin_comment
comment|/* Model Name, derived from the @@Cj message.  * Used to initialize some variables.  */
end_comment

begin_enum
enum|enum
name|oncore_model
block|{
name|ONCORE_BASIC
block|,
name|ONCORE_PVT6
block|,
name|ONCORE_VP
block|,
name|ONCORE_UT
block|,
name|ONCORE_UTPLUS
block|,
name|ONCORE_GT
block|,
name|ONCORE_GTPLUS
block|,
name|ONCORE_SL
block|,
name|ONCORE_M12
block|,
name|ONCORE_UNKNOWN
block|}
enum|;
end_enum

begin_comment
comment|/* the bits that describe these properties are in the same place  * on the VP/UT, but have moved on the M12.  As such we extract  * them, and use them from this struct.  *  */
end_comment

begin_struct
struct|struct
name|RSM
block|{
name|u_char
name|posn0D
decl_stmt|;
name|u_char
name|posn2D
decl_stmt|;
name|u_char
name|posn3D
decl_stmt|;
name|u_char
name|bad_almanac
decl_stmt|;
name|u_char
name|bad_fix
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* It is possible to test the VP/UT each cycle (@@Ea or equivalent) to  * see what mode it is in.  The bits on the M12 are multiplexed with  * other messages, so we have to 'keep' the last known mode here.  */
end_comment

begin_enum
enum|enum
name|posn_mode
block|{
name|MODE_UNKNOWN
block|,
name|MODE_0D
block|,
name|MODE_2D
block|,
name|MODE_3D
block|}
enum|;
end_enum

begin_struct
struct|struct
name|instance
block|{
name|int
name|unit
decl_stmt|;
comment|/* 127.127.30.unit */
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|ttyfd
decl_stmt|;
comment|/* TTY file descriptor */
name|int
name|ppsfd
decl_stmt|;
comment|/* PPS file descriptor */
name|int
name|shmemfd
decl_stmt|;
comment|/* Status shm descriptor */
name|pps_handle_t
name|pps_h
decl_stmt|;
name|pps_params_t
name|pps_p
decl_stmt|;
name|enum
name|receive_state
name|o_state
decl_stmt|;
comment|/* Receive state */
name|enum
name|posn_mode
name|mode
decl_stmt|;
comment|/* 0D, 2D, 3D */
name|enum
name|site_survey_state
name|site_survey
decl_stmt|;
comment|/* Site Survey state */
name|enum
name|antenna_state
name|ant_state
decl_stmt|;
comment|/* antenna state */
name|int
name|Bj_day
decl_stmt|;
name|u_long
name|delay
decl_stmt|;
comment|/* ns */
name|long
name|offset
decl_stmt|;
comment|/* ns */
name|u_char
modifier|*
name|shmem
decl_stmt|;
name|char
modifier|*
name|shmem_fname
decl_stmt|;
name|u_int
name|shmem_Cb
decl_stmt|;
name|u_int
name|shmem_Ba
decl_stmt|;
name|u_int
name|shmem_Ea
decl_stmt|;
name|u_int
name|shmem_Ha
decl_stmt|;
name|u_char
name|shmem_reset
decl_stmt|;
name|u_char
name|shmem_Posn
decl_stmt|;
name|u_char
name|shmem_bad_Ea
decl_stmt|;
name|u_char
name|almanac_from_shmem
decl_stmt|;
name|double
name|ss_lat
decl_stmt|;
name|double
name|ss_long
decl_stmt|;
name|double
name|ss_ht
decl_stmt|;
name|double
name|dH
decl_stmt|;
name|int
name|ss_count
decl_stmt|;
name|u_char
name|posn_set
decl_stmt|;
name|enum
name|oncore_model
name|model
decl_stmt|;
name|u_int
name|version
decl_stmt|;
name|u_int
name|revision
decl_stmt|;
name|u_char
name|chan
decl_stmt|;
comment|/* 6 for PVT6 or BASIC, 8 for UT/VP, 12 for m12, 0 if unknown */
name|s_char
name|traim
decl_stmt|;
comment|/* do we have traim? yes UT/VP, M12+T, no BASIC, GT, M12, -1 unknown, 0 no, +1 yes */
comment|/* the following 7 are all timing counters */
name|u_char
name|traim_delay
decl_stmt|;
comment|/* seconds counter, waiting for reply */
name|u_char
name|count
decl_stmt|;
comment|/* cycles thru Ea before starting */
name|u_char
name|count1
decl_stmt|;
comment|/* cycles thru Ea after SS_TESTING, waiting for SS_HW */
name|u_char
name|count2
decl_stmt|;
comment|/* cycles thru Ea after count, to check for @@Ea */
name|u_char
name|count3
decl_stmt|;
comment|/* cycles thru Ea checking for # channels */
name|u_char
name|count4
decl_stmt|;
comment|/* cycles thru leap after Gj to issue Bj */
name|u_char
name|count5
decl_stmt|;
comment|/* cycles thru get_timestamp waiting for valid UTC correction */
name|u_char
name|count5_set
decl_stmt|;
comment|/* only set count5 once */
name|u_char
name|counta
decl_stmt|;
comment|/* count for waiting on almanac message */
name|u_char
name|pollcnt
decl_stmt|;
name|u_char
name|timeout
decl_stmt|;
comment|/* count to retry Cj after Fa self-test */
name|u_char
name|max_len
decl_stmt|;
comment|/* max length message seen by oncore_log, for debugging */
name|u_char
name|max_count
decl_stmt|;
comment|/* count for message statistics */
name|struct
name|RSM
name|rsm
decl_stmt|;
comment|/* bits extracted from Receiver Status Msg in @@Ea */
name|struct
name|Bl
name|Bl
decl_stmt|;
comment|/* Satellite Broadcast Data Message */
name|u_char
name|printed
decl_stmt|;
name|u_char
name|polled
decl_stmt|;
name|u_long
name|ev_serial
decl_stmt|;
name|int
name|Rcvptr
decl_stmt|;
name|u_char
name|Rcvbuf
index|[
literal|500
index|]
decl_stmt|;
name|u_char
name|BEHa
index|[
literal|160
index|]
decl_stmt|;
comment|/* Ba, Ea or Ha */
name|u_char
name|BEHn
index|[
literal|80
index|]
decl_stmt|;
comment|/* Bn , En , or Hn */
name|u_char
name|Cj
index|[
literal|300
index|]
decl_stmt|;
name|u_char
name|Ag
decl_stmt|;
comment|/* Satellite mask angle */
name|u_char
name|saw_At
decl_stmt|;
name|u_char
name|saw_Ay
decl_stmt|;
name|u_char
name|saw_Az
decl_stmt|;
name|s_char
name|saw_Bj
decl_stmt|;
name|s_char
name|saw_Gj
decl_stmt|;
name|u_char
name|have_dH
decl_stmt|;
name|u_char
name|init_type
decl_stmt|;
name|s_char
name|saw_tooth
decl_stmt|;
name|s_char
name|chan_in
decl_stmt|;
comment|/* chan number from INPUT, will always use it */
name|u_char
name|chan_id
decl_stmt|;
comment|/* chan number determined from part number */
name|u_char
name|chan_ck
decl_stmt|;
comment|/* chan number determined by sending commands to hardware */
name|s_char
name|traim_in
decl_stmt|;
comment|/* TRAIM from INPUT, will always use ON/OFF specified */
name|s_char
name|traim_id
decl_stmt|;
comment|/* TRAIM determined from part number */
name|u_char
name|traim_ck
decl_stmt|;
comment|/* TRAIM determined by sending commands to hardware */
name|u_char
name|once
decl_stmt|;
comment|/* one pass code at top of BaEaHa */
name|s_char
name|assert
decl_stmt|;
name|u_char
name|hardpps
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|rcvbuf
value|instance->Rcvbuf
end_define

begin_define
define|#
directive|define
name|rcvptr
value|instance->Rcvptr
end_define

begin_function_decl
specifier|static
name|int
name|oncore_start
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_poll
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_shutdown
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_consume
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_read_config
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oncore_ppsapi
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_get_timestamp
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|long
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_init_shmem
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_antenna_report
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|enum
name|antenna_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_chan_test
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_check_almanac
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_check_antenna
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_check_leap_sec
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oncore_checksum_ok
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_compute_dH
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_load_almanac
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_log
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_print_Cb
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static  void    oncore_print_array	 (u_char *, int);	*/
end_comment

begin_function_decl
specifier|static
name|void
name|oncore_print_posn
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_sendmsg
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_set_posn
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_set_traim
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_shmem_get_3D
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_ss
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oncore_wait_almanac
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_any
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Adef
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Ag
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_As
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_At
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Ay
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Az
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_BaEaHa
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Bd
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Bj
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Bl
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_BnEnHn
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_CaFaIa
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Cb
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Cf
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Cj
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Cj_id
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Cj_init
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Ga
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Gb
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Gj
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oncore_msg_Sz
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|refclock
name|refclock_oncore
init|=
block|{
name|oncore_start
block|,
comment|/* start up driver */
name|oncore_shutdown
block|,
comment|/* shut down driver */
name|oncore_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used */
name|noentry
block|,
comment|/* not used */
name|noentry
block|,
comment|/* not used */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Understanding the next bit here is not easy unless you have a manual  * for the the various Oncore Models.  */
end_comment

begin_struct
specifier|static
struct|struct
name|msg_desc
block|{
specifier|const
name|char
name|flag
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|int
name|len
decl_stmt|;
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|struct
name|instance
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|shmem
decl_stmt|;
block|}
name|oncore_messages
index|[]
init|=
block|{
comment|/* Ea and En first since they're most common */
block|{
literal|"Ea"
block|,
literal|76
block|,
name|oncore_msg_BaEaHa
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmvvhhddtntimsdimsdimsdimsdimsdimsdimsdimsdsC"
block|}
block|,
block|{
literal|"Ba"
block|,
literal|68
block|,
name|oncore_msg_BaEaHa
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmvvhhddtntimsdimsdimsdimsdimsdimsdsC"
block|}
block|,
block|{
literal|"Ha"
block|,
literal|154
block|,
name|oncore_msg_BaEaHa
block|,
literal|"mdyyhmsffffaaaaoooohhhhmmmmaaaaoooohhhhmmmmVVvvhhddntimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddimsiddssrrccooooTTushmvvvvvvC"
block|}
block|,
block|{
literal|"Bn"
block|,
literal|59
block|,
name|oncore_msg_BnEnHn
block|,
literal|"otaapxxxxxxxxxxpysreensffffsffffsffffsffffsffffsffffC"
block|}
block|,
block|{
literal|"En"
block|,
literal|69
block|,
name|oncore_msg_BnEnHn
block|,
literal|"otaapxxxxxxxxxxpysreensffffsffffsffffsffffsffffsffffsffffsffffC"
block|}
block|,
block|{
literal|"Hn"
block|,
literal|78
block|,
name|oncore_msg_BnEnHn
block|,
literal|""
block|}
block|,
block|{
literal|"Ab"
block|,
literal|10
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ac"
block|,
literal|11
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ad"
block|,
literal|11
block|,
name|oncore_msg_Adef
block|,
literal|""
block|}
block|,
block|{
literal|"Ae"
block|,
literal|11
block|,
name|oncore_msg_Adef
block|,
literal|""
block|}
block|,
block|{
literal|"Af"
block|,
literal|15
block|,
name|oncore_msg_Adef
block|,
literal|""
block|}
block|,
block|{
literal|"Ag"
block|,
literal|8
block|,
name|oncore_msg_Ag
block|,
literal|""
block|}
block|,
comment|/* Satellite mask angle */
block|{
literal|"As"
block|,
literal|20
block|,
name|oncore_msg_As
block|,
literal|""
block|}
block|,
block|{
literal|"At"
block|,
literal|8
block|,
name|oncore_msg_At
block|,
literal|""
block|}
block|,
block|{
literal|"Au"
block|,
literal|12
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Av"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Aw"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ay"
block|,
literal|11
block|,
name|oncore_msg_Ay
block|,
literal|""
block|}
block|,
block|{
literal|"Az"
block|,
literal|11
block|,
name|oncore_msg_Az
block|,
literal|""
block|}
block|,
block|{
literal|"AB"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Bb"
block|,
literal|92
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Bd"
block|,
literal|23
block|,
name|oncore_msg_Bd
block|,
literal|""
block|}
block|,
block|{
literal|"Bj"
block|,
literal|8
block|,
name|oncore_msg_Bj
block|,
literal|""
block|}
block|,
block|{
literal|"Bl"
block|,
literal|41
block|,
name|oncore_msg_Bl
block|,
literal|""
block|}
block|,
block|{
literal|"Ca"
block|,
literal|9
block|,
name|oncore_msg_CaFaIa
block|,
literal|""
block|}
block|,
block|{
literal|"Cb"
block|,
literal|33
block|,
name|oncore_msg_Cb
block|,
literal|""
block|}
block|,
block|{
literal|"Cf"
block|,
literal|7
block|,
name|oncore_msg_Cf
block|,
literal|""
block|}
block|,
block|{
literal|"Cg"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ch"
block|,
literal|9
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Cj"
block|,
literal|294
block|,
name|oncore_msg_Cj
block|,
literal|""
block|}
block|,
block|{
literal|"Ek"
block|,
literal|71
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Fa"
block|,
literal|9
block|,
name|oncore_msg_CaFaIa
block|,
literal|""
block|}
block|,
block|{
literal|"Ga"
block|,
literal|20
block|,
name|oncore_msg_Ga
block|,
literal|""
block|}
block|,
block|{
literal|"Gb"
block|,
literal|17
block|,
name|oncore_msg_Gb
block|,
literal|""
block|}
block|,
block|{
literal|"Gc"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Gd"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Ge"
block|,
literal|8
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"Gj"
block|,
literal|21
block|,
name|oncore_msg_Gj
block|,
literal|""
block|}
block|,
block|{
literal|"Ia"
block|,
literal|10
block|,
name|oncore_msg_CaFaIa
block|,
literal|""
block|}
block|,
block|{
literal|"Sz"
block|,
literal|8
block|,
name|oncore_msg_Sz
block|,
literal|""
block|}
block|,
block|{
block|{
literal|0
block|}
block|,
literal|7
block|,
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Aa
index|[]
init|=
block|{
literal|'A'
block|,
literal|'a'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Time of Day				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ab
index|[]
init|=
block|{
literal|'A'
block|,
literal|'b'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	GMT Correction				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_AB
index|[]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VP	Application Type: Static		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ac
index|[]
init|=
block|{
literal|'A'
block|,
literal|'c'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Date					*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ad
index|[]
init|=
block|{
literal|'A'
block|,
literal|'d'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Latitude				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ae
index|[]
init|=
block|{
literal|'A'
block|,
literal|'e'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Longitude				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Af
index|[]
init|=
block|{
literal|'A'
block|,
literal|'f'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Height					*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ag
index|[]
init|=
block|{
literal|'A'
block|,
literal|'g'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Satellite Mask Angle			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Agx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'g'
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Satellite Mask Angle: read		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_As
index|[]
init|=
block|{
literal|'A'
block|,
literal|'s'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Posn Hold Parameters			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Asx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'s'
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* 6/8/12	Posn Hold Readback			*/
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/*		 on UT+ this doesnt work with 0xff	*/
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*		 but does work with 0x7f (sigh).	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At0
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Posn Hold: off				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At1
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Posn Hold: on				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_At2
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Posn Hold: Start Site Survey		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Atx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'t'
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Posn Hold: Read Back			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Au
index|[]
init|=
block|{
literal|'A'
block|,
literal|'u'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GT/M12	Altitude Hold Ht.			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Av0
index|[]
init|=
block|{
literal|'A'
block|,
literal|'v'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VP/GT	Altitude Hold: off			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Av1
index|[]
init|=
block|{
literal|'A'
block|,
literal|'v'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VP/GT	Altitude Hold: on			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Aw
index|[]
init|=
block|{
literal|'A'
block|,
literal|'w'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	UTC/GPS time selection			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ay
index|[]
init|=
block|{
literal|'A'
block|,
literal|'y'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timing	1PPS time offset: set			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ayx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'y'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timing	1PPS time offset: Read			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Az
index|[]
init|=
block|{
literal|'A'
block|,
literal|'z'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8UT/12 1PPS Cable Delay: set			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Azx
index|[]
init|=
block|{
literal|'A'
block|,
literal|'z'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8UT/12 1PPS Cable Delay: Read			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ba0
index|[]
init|=
block|{
literal|'B'
block|,
literal|'a'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	Position/Data/Status: off		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ba
index|[]
init|=
block|{
literal|'B'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	Position/Data/Status: on		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bb
index|[]
init|=
block|{
literal|'B'
block|,
literal|'b'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Visible Satellites			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bd
index|[]
init|=
block|{
literal|'B'
block|,
literal|'d'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12?	Almanac Status Msg.			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Be
index|[]
init|=
block|{
literal|'B'
block|,
literal|'e'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Request Almanac Data			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bj
index|[]
init|=
block|{
literal|'B'
block|,
literal|'j'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8	Leap Second Pending			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bl
index|[]
init|=
block|{
literal|'B'
block|,
literal|'l'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VP	Satellite Broadcast Data Msg		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bn0
index|[]
init|=
block|{
literal|'B'
block|,
literal|'n'
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	TRAIM setup/status: msg off, traim on	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bn
index|[]
init|=
block|{
literal|'B'
block|,
literal|'n'
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	TRAIM setup/status: msg on,  traim on	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Bnx
index|[]
init|=
block|{
literal|'B'
block|,
literal|'n'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	TRAIM setup/status: msg off, traim off	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ca
index|[]
init|=
block|{
literal|'C'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6	Self Test				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cf
index|[]
init|=
block|{
literal|'C'
block|,
literal|'f'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Set to Defaults 			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cg
index|[]
init|=
block|{
literal|'C'
block|,
literal|'g'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VP	Posn Fix/Idle Mode			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Cj
index|[]
init|=
block|{
literal|'C'
block|,
literal|'j'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/8/12	Receiver ID				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ea0
index|[]
init|=
block|{
literal|'E'
block|,
literal|'a'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8	Position/Data/Status: off		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ea
index|[]
init|=
block|{
literal|'E'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8	Position/Data/Status: on		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ek
index|[]
init|=
block|{
literal|'E'
block|,
literal|'k'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* just turn off */
end_comment

begin_comment
comment|/* 8	Posn/Status/Data - extension		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_En0
index|[]
init|=
block|{
literal|'E'
block|,
literal|'n'
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8/GT	TRAIM setup/status: msg off, traim on	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_En
index|[]
init|=
block|{
literal|'E'
block|,
literal|'n'
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8/GT	TRAIM setup/status: msg on,  traim on	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Enx
index|[]
init|=
block|{
literal|'E'
block|,
literal|'n'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8/GT	TRAIM setup/status: msg off, traim off	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Fa
index|[]
init|=
block|{
literal|'F'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8	Self Test				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ga
index|[]
init|=
block|{
literal|'G'
block|,
literal|'a'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Set				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gax
index|[]
init|=
block|{
literal|'G'
block|,
literal|'a'
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* 12	Position Set: Read			*/
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/*							*/
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*							*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gb
index|[]
init|=
block|{
literal|'G'
block|,
literal|'b'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	set Date/Time				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gc
index|[]
init|=
block|{
literal|'G'
block|,
literal|'c'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	PPS Control: On Cont			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gd0
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Control: 3D (no hold)		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gd1
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Control: 0D (3D hold)		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gd2
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Control: 2D (Alt Hold) 	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gd3
index|[]
init|=
block|{
literal|'G'
block|,
literal|'d'
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position Coltrol: Start Site Survey	*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ge0
index|[]
init|=
block|{
literal|'G'
block|,
literal|'e'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* M12+T	TRAIM: off				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ge
index|[]
init|=
block|{
literal|'G'
block|,
literal|'e'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* M12+T	TRAIM: on				*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Gj
index|[]
init|=
block|{
literal|'G'
block|,
literal|'j'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8?/12	Leap Second Pending			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ha0
index|[]
init|=
block|{
literal|'H'
block|,
literal|'a'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position/Data/Status: off		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ha
index|[]
init|=
block|{
literal|'H'
block|,
literal|'a'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Position/Data/Status: on		*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Hn0
index|[]
init|=
block|{
literal|'H'
block|,
literal|'n'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	TRAIM Status: off			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Hn
index|[]
init|=
block|{
literal|'H'
block|,
literal|'n'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	TRAIM Status: on			*/
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|oncore_cmd_Ia
index|[]
init|=
block|{
literal|'I'
block|,
literal|'a'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12	Self Test				*/
end_comment

begin_comment
comment|/* it appears that as of 1997/1998, the UT had As,At, but not Au,Av  *				    the GT had Au,Av, but not As,At  * This was as of v2.0 of both firmware sets. possibly 1.3 for UT.  * Bj in UT at v1.3  * dont see Bd in UT/GT thru 1999  * Gj in UT as of 3.0, 1999 , Bj as of 1.3  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Month
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jly"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEVICE1
value|"/dev/oncore.serial.%d"
end_define

begin_comment
comment|/* name of serial device */
end_comment

begin_define
define|#
directive|define
name|DEVICE2
value|"/dev/oncore.pps.%d"
end_define

begin_comment
comment|/* name of pps device */
end_comment

begin_define
define|#
directive|define
name|SPEED
value|B9600
end_define

begin_comment
comment|/* Oncore Binary speed (9600 bps) */
end_comment

begin_comment
comment|/*  * Assemble and disassemble 32bit signed quantities from a buffer.  *  */
end_comment

begin_comment
comment|/* to buffer, int w, u_char *buf */
end_comment

begin_define
define|#
directive|define
name|w32_buf
parameter_list|(
name|buf
parameter_list|,
name|w
parameter_list|)
value|{ u_int i_tmp;			   \ 			  i_tmp = (w<0) ? (~(-w)+1) : (w); \ 			  (buf)[0] = (i_tmp>> 24)& 0xff; \ 			  (buf)[1] = (i_tmp>> 16)& 0xff; \ 			  (buf)[2] = (i_tmp>>	8)& 0xff; \ 			  (buf)[3] = (i_tmp	 )& 0xff; \ 			}
end_define

begin_define
define|#
directive|define
name|w32
parameter_list|(
name|buf
parameter_list|)
value|(((buf)[0]&0xff)<< 24 | \ 		       ((buf)[1]&0xff)<< 16 | \ 		       ((buf)[2]&0xff)<<  8 | \ 		       ((buf)[3]&0xff) )
end_define

begin_comment
comment|/* from buffer, char *buf, result to an int */
end_comment

begin_define
define|#
directive|define
name|buf_w32
parameter_list|(
name|buf
parameter_list|)
value|(((buf)[0]&0200) ? (-(~w32(buf)+1)) : w32(buf))
end_define

begin_comment
comment|/*  * oncore_start - initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|oncore_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
define|#
directive|define
name|STRING_LEN
value|32
specifier|register
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|char
name|device1
index|[
name|STRING_LEN
index|]
decl_stmt|,
name|device2
index|[
name|STRING_LEN
index|]
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|struct
name|stat
name|stat1
decl_stmt|,
name|stat2
decl_stmt|;
comment|/* create instance structure for this unit */
name|instance
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|instance
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|instance
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize miscellaneous variables */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|instance
expr_stmt|;
name|instance
operator|->
name|pp
operator|=
name|pp
expr_stmt|;
name|instance
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|instance
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|instance
operator|->
name|assert
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|once
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|Bj_day
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|traim
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|traim_in
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|chan_in
operator|=
operator|-
literal|1
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UNKNOWN
expr_stmt|;
name|instance
operator|->
name|mode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_UNKNOWN
expr_stmt|;
name|instance
operator|->
name|Ag
operator|=
literal|0xff
expr_stmt|;
comment|/* Satellite mask angle, unset by user */
name|instance
operator|->
name|ant_state
operator|=
name|ONCORE_ANTENNA_UNKNOWN
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
operator|-
literal|26
expr_stmt|;
name|peer
operator|->
name|minpoll
operator|=
literal|4
expr_stmt|;
name|peer
operator|->
name|maxpoll
operator|=
literal|4
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
literal|"Motorola Oncore GPS Receiver"
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|"GPS\0"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"ONCORE DRIVER -- CONFIGURING"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_NO_IDEA
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_NO_IDEA"
argument_list|)
expr_stmt|;
comment|/* Now open files. 	 * This is a bit complicated, a we dont want to open the same file twice 	 * (its a problem on some OS), and device2 may not exist for the new PPS 	 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|device1
argument_list|,
sizeof|sizeof
argument_list|(
name|device1
argument_list|)
argument_list|,
name|DEVICE1
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|device2
argument_list|,
sizeof|sizeof
argument_list|(
name|device2
argument_list|)
argument_list|,
name|DEVICE2
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* OPEN DEVICES */
comment|/* opening different devices for fd1 and fd2 presents no problems */
comment|/* opening the SAME device twice, seems to be OS dependent. 		(a) on Linux (no streams) no problem 		(b) on SunOS (and possibly Solaris, untested), (streams) 			never see the line discipline. 	   Since things ALWAYS work if we only open the device once, we check 	     to see if the two devices are in fact the same, then proceed to 	     do one open or two.  	   For use with linuxPPS we assume that the N_TTY file has been opened 	     and that the line discipline has been changed to N_PPS by another 	     program (say ppsldisc) so that the two files expected by the oncore 	     driver can be opened.  	   Note that the linuxPPS N_PPS file is just like a N_TTY, so we can do 	     the stat below without error even though the file has already had its 	     line discipline changed by another process.  	   The Windows port of ntpd arranges to return duplicate handles for 	     multiple opens of the same serial device, and doesn't have inodes 	     for serial handles, so we just open both on Windows. 	*/
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|stat
argument_list|(
name|device1
argument_list|,
operator|&
name|stat1
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Can't stat fd1 (%s)"
argument_list|,
name|device1
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* exit, no file, can't start driver */
block|}
if|if
condition|(
name|stat
argument_list|(
name|device2
argument_list|,
operator|&
name|stat2
argument_list|)
condition|)
block|{
name|stat2
operator|.
name|st_dev
operator|=
name|stat2
operator|.
name|st_ino
operator|=
operator|-
literal|2
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Can't stat fd2 (%s) errno = %d"
argument_list|,
name|device2
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !SYS_WINNT */
if|if
condition|(
operator|!
operator|(
name|fd1
operator|=
name|refclock_open
argument_list|(
name|device1
argument_list|,
name|SPEED
argument_list|,
name|LDISC_RAW
argument_list|)
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Can't open fd1 (%s)"
argument_list|,
name|device1
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* exit, can't open file, can't start driver */
block|}
comment|/* for LINUX the PPS device is the result of a line discipline. 	   It seems simplest to let an external program create the appropriate 	   /dev/pps<n> file, and only check (carefully) for its existance here 	 */
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
operator|(
name|stat1
operator|.
name|st_dev
operator|==
name|stat2
operator|.
name|st_dev
operator|)
operator|&&
operator|(
name|stat1
operator|.
name|st_ino
operator|==
name|stat2
operator|.
name|st_ino
operator|)
condition|)
comment|/* same device here */
name|fd2
operator|=
name|fd1
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* !SYS_WINNT */
block|{
comment|/* different devices here */
if|if
condition|(
operator|(
name|fd2
operator|=
name|tty_open
argument_list|(
name|device2
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Can't open fd2 (%s)"
argument_list|,
name|device2
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* exit, can't open PPS file, can't start driver */
block|}
block|}
comment|/* open ppsapi source */
if|if
condition|(
name|time_pps_create
argument_list|(
name|fd2
argument_list|,
operator|&
name|instance
operator|->
name|pps_h
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"exit, PPSAPI not found in kernel"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* exit, don't find PPSAPI in kernel */
block|}
comment|/* continue initialization */
name|instance
operator|->
name|ttyfd
operator|=
name|fd1
expr_stmt|;
name|instance
operator|->
name|ppsfd
operator|=
name|fd2
expr_stmt|;
comment|/* go read any input data in /etc/ntp.oncoreX or /etc/ntp/oncore.X */
name|oncore_read_config
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oncore_ppsapi
argument_list|(
name|instance
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|oncore_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd1
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"can't do io_addclock"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|instance
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
comment|/* 	 * Before starting ONCORE, lets setup SHMEM 	 * This will include merging an old SHMEM into the new one if 	 * an old one is found. 	 */
name|oncore_init_shmem
argument_list|(
name|instance
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This will return the Model of the Oncore receiver. 	 * and start the Initialization loop in oncore_msg_Cj. 	 */
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_CHECK_ID
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_CHECK_ID"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|4
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Cg
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set Posn Fix mode (not Idle (VP)) */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * oncore_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|oncore_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|time_pps_destroy
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|instance
operator|->
name|ppsfd
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|instance
operator|->
name|ppsfd
operator|!=
name|instance
operator|->
name|ttyfd
operator|)
condition|)
name|close
argument_list|(
name|instance
operator|->
name|ppsfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmemfd
condition|)
name|close
argument_list|(
name|instance
operator|->
name|shmemfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * oncore_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|oncore_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|timeout
condition|)
block|{
name|instance
operator|->
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"Oncore: No response from @@Cj, shutting down driver"
argument_list|)
expr_stmt|;
name|oncore_shutdown
argument_list|(
name|unit
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_WARNING
argument_list|,
literal|"Oncore: Resend @@Cj"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|instance
operator|->
name|pollcnt
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|instance
operator|->
name|pollcnt
operator|--
expr_stmt|;
name|peer
operator|->
name|procptr
operator|->
name|polls
operator|++
expr_stmt|;
name|instance
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize PPSAPI  */
end_comment

begin_function
specifier|static
name|int
name|oncore_ppsapi
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|cap
decl_stmt|,
name|mode
decl_stmt|,
name|mode1
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|cap
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msnprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|time_pps_getparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|instance
operator|->
name|pps_p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msnprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"time_pps_getparams failed: %m"
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* nb. only turn things on, if someone else has turned something 	 *	on before we get here, leave it alone! 	 */
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
block|{
name|cp
operator|=
literal|"Assert"
expr_stmt|;
name|mode
operator|=
name|PPS_CAPTUREASSERT
expr_stmt|;
name|mode1
operator|=
name|PPS_OFFSETASSERT
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
literal|"Clear"
expr_stmt|;
name|mode
operator|=
name|PPS_CAPTURECLEAR
expr_stmt|;
name|mode1
operator|=
name|PPS_OFFSETCLEAR
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Initializing timing to %s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|cap
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Can't set timing to %s, exiting..."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|mode1
operator|&
name|cap
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Can't set %s, this will increase jitter."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|mode1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* only set what is legal */
name|instance
operator|->
name|pps_p
operator|.
name|mode
operator|=
operator|(
name|mode
operator||
name|mode1
operator||
name|PPS_TSFMT_TSPEC
operator|)
operator|&
name|cap
expr_stmt|;
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|instance
operator|->
name|pps_p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"ONCORE: time_pps_setparams fails"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* exit, can't do time_pps_setparans on PPS file */
block|}
comment|/* If HARDPPS is on, we tell kernel */
if|if
condition|(
name|instance
operator|->
name|hardpps
condition|)
block|{
name|int
name|i
decl_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
literal|"HARDPPS Set."
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|i
operator|=
name|PPS_CAPTUREASSERT
expr_stmt|;
else|else
name|i
operator|=
name|PPS_CAPTURECLEAR
expr_stmt|;
comment|/* we know that 'i' is legal from above */
if|if
condition|(
name|time_pps_kcbind
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
name|PPS_KC_HARDPPS
argument_list|,
name|i
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msnprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"time_pps_kcbind failed: %m"
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"HARDPPS failed, abort..."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pps_enable
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ONCORE_SHMEM_STATUS
end_ifdef

begin_function
specifier|static
name|void
name|oncore_init_shmem
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|n
decl_stmt|,
name|fd
decl_stmt|,
name|shmem_old_size
decl_stmt|,
name|n1
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|shmem_old
decl_stmt|;
name|struct
name|msg_desc
modifier|*
name|mp
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|size_t
name|shmem_length
decl_stmt|;
comment|/* 	* The first thing we do is see if there is an instance->shmem_fname file (still) 	* out there from a previous run.  If so, we copy it in and use it to initialize 	* shmem (so we won't lose our almanac if we need it). 	*/
name|shmem_old
operator|=
literal|0
expr_stmt|;
name|shmem_old_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_WARNING
argument_list|,
literal|"ONCORE: Can't open SHMEM file"
argument_list|)
expr_stmt|;
else|else
block|{
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|shmem_old_size
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|shmem_old_size
operator|!=
literal|0
condition|)
block|{
name|shmem_old
operator|=
name|emalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|sbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fd
argument_list|,
name|shmem_old
argument_list|,
name|shmem_old_size
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* OK, we now create the NEW SHMEM. */
if|if
condition|(
operator|(
name|instance
operator|->
name|shmemfd
operator|=
name|open
argument_list|(
name|instance
operator|->
name|shmem_fname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_WARNING
argument_list|,
literal|"ONCORE: Can't open shmem"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmem_old
condition|)
name|free
argument_list|(
name|shmem_old
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* see how big it needs to be */
name|n
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|oncore_messages
init|;
name|mp
operator|->
name|flag
index|[
literal|0
index|]
condition|;
name|mp
operator|++
control|)
block|{
name|mp
operator|->
name|shmem
operator|=
name|n
expr_stmt|;
comment|/* Allocate space for multiplexed almanac, and 0D/2D/3D @@Ea records */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Cb
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|34
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ba"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Ba
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ea"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Ea
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ha"
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Ha
operator|=
name|n
expr_stmt|;
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|*
literal|3
expr_stmt|;
block|}
name|n
operator|+=
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
expr_stmt|;
block|}
name|shmem_length
operator|=
name|n
operator|+
literal|2
expr_stmt|;
name|buf
operator|=
name|emalloc
argument_list|(
name|shmem_length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|shmem_length
argument_list|)
expr_stmt|;
comment|/* next build the new SHMEM buffer in memory */
for|for
control|(
name|mp
operator|=
name|oncore_messages
init|;
name|mp
operator|->
name|flag
index|[
literal|0
index|]
condition|;
name|mp
operator|++
control|)
block|{
name|l
operator|=
name|mp
operator|->
name|shmem
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|0
index|]
operator|=
name|mp
operator|->
name|len
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|1
index|]
operator|=
name|mp
operator|->
name|len
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|3
index|]
operator|=
literal|'@'
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|4
index|]
operator|=
literal|'@'
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|5
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|0
index|]
expr_stmt|;
name|buf
index|[
name|l
operator|+
literal|6
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ba"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ea"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Ha"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mp
operator|->
name|flag
argument_list|,
literal|"Cb"
argument_list|)
condition|)
name|n
operator|=
literal|35
expr_stmt|;
else|else
name|n
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|0
index|]
operator|=
name|mp
operator|->
name|len
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|1
index|]
operator|=
name|mp
operator|->
name|len
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|3
index|]
operator|=
literal|'@'
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|4
index|]
operator|=
literal|'@'
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|5
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|0
index|]
expr_stmt|;
name|buf
index|[
name|l
operator|+
name|i
operator|*
operator|(
name|mp
operator|->
name|len
operator|+
literal|3
operator|)
operator|+
literal|6
index|]
operator|=
name|mp
operator|->
name|flag
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* we now walk thru the two buffers (shmem_old and buf, soon to become shmem) 	 * copying the data in shmem_old to buf. 	 * When we are done we write it out and free both buffers. 	 * If the structure sizes dont agree, I will not copy. 	 * This could be due to an addition/deletion or a problem with the disk file. 	 */
if|if
condition|(
name|shmem_old
condition|)
block|{
if|if
condition|(
name|shmem_old_size
operator|==
name|shmem_length
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buf
operator|+
literal|4
operator|,
name|cp1
operator|=
name|shmem_old
operator|+
literal|4
init|;
operator|(
name|n
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp
operator|-
literal|2
operator|)
operator|)
condition|;
name|cp
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
operator|,
name|cp1
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
control|)
block|{
name|n1
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp1
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp1
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|n1
operator|!=
name|n
operator|||
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
literal|4
argument_list|)
condition|)
break|break;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
operator|(
name|size_t
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|shmem_old
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|write
argument_list|(
name|instance
operator|->
name|shmemfd
argument_list|,
name|buf
argument_list|,
name|shmem_length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|shmem_length
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"ONCORE: error writing shmem"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|shmemfd
argument_list|)
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|shmem
operator|=
operator|(
name|u_char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|shmem_length
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
ifdef|#
directive|ifdef
name|MAP_HASSEMAPHORE
name|MAP_HASSEMAPHORE
operator||
endif|#
directive|endif
name|MAP_SHARED
argument_list|,
name|instance
operator|->
name|shmemfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem
operator|==
operator|(
name|u_char
operator|*
operator|)
name|MAP_FAILED
condition|)
block|{
name|instance
operator|->
name|shmem
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|instance
operator|->
name|shmemfd
argument_list|)
expr_stmt|;
return|return;
block|}
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"SHMEM (size = %ld) is CONFIGURED and available as %s"
argument_list|,
operator|(
name|u_long
operator|)
name|shmem_length
argument_list|,
name|instance
operator|->
name|shmem_fname
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ONCORE_SHMEM_STATUS */
end_comment

begin_comment
comment|/*  * Read Input file if it exists.  */
end_comment

begin_function
specifier|static
name|void
name|oncore_read_config
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
comment|/*  * First we try to open the configuration file  *    /etc/ntp.oncore.N  * where N is the unit number viz 127.127.30.N.  * If we don't find it we try  *    /etc/ntp.oncoreN  * and then  *    /etc/ntp.oncore  *  * If we don't find any then we don't have the cable delay or PPS offset  * and we choose MODE (4) below.  *  * Five Choices for MODE  *    (0) ONCORE is preinitialized, don't do anything to change it.  *	    nb, DON'T set 0D mode, DON'T set Delay, position...  *    (1) NO RESET, Read Position, delays from data file, lock it in, go to 0D mode.  *    (2) NO RESET, Read Delays from data file, do SITE SURVEY to get position,  *		    lock this in, go to 0D mode.  *    (3) HARD RESET, Read Position, delays from data file, lock it in, go to 0D mode.  *    (4) HARD RESET, Read Delays from data file, do SITE SURVEY to get position,  *		    lock this in, go to 0D mode.  *     NB. If a POSITION is specified in the config file with mode=(2,4) [SITE SURVEY]  *	   then this position is set as the INITIAL position of the ONCORE.  *	   This can reduce the time to first fix.  * -------------------------------------------------------------------------------  * Note that an Oncore UT without a battery backup retains NO information if it is  *   power cycled, with a Battery Backup it remembers the almanac, etc.  * For an Oncore VP, there is an eeprom that will contain this data, along with the  *   option of Battery Backup.  * So a UT without Battery Backup is equivalent to doing a HARD RESET on each  *   power cycle, since there is nowhere to store the data.  * -------------------------------------------------------------------------------  *  * If we open one or the other of the files, we read it looking for  *   MODE, LAT, LON, (HT, HTGPS, HTMSL), DELAY, OFFSET, ASSERT, CLEAR, HARDPPS,  *   STATUS, POSN3D, POSN2D, CHAN, TRAIM  * then initialize using method MODE.  For Mode = (1,3) all of (LAT, LON, HT) must  *   be present or mode reverts to (2,4).  *  * Read input file.  *  *	# is comment to end of line  *	= allowed between 1st and 2nd fields.  *  *	Expect to see one line with 'MODE' as first field, followed by an integer  *	   in the range 0-4 (default = 4).  *  *	Expect to see two lines with 'LONG', 'LAT' followed by 1-3 fields.  *	All numbers are floating point.  *		DDD.ddd  *		DDD  MMM.mmm  *		DDD  MMM  SSS.sss  *  *	Expect to see one line with 'HT' as first field,  *	   followed by 1-2 fields.  First is a number, the second is 'FT' or 'M'  *	   for feet or meters.	HT is the height above the GPS ellipsoid.  *	   If the receiver reports height in both GPS and MSL, then we will report  *	   the difference GPS-MSL on the clockstats file.  *  *	There is an optional line, starting with DELAY, followed  *	   by 1 or two fields.	The first is a number (a time) the second is  *	   'MS', 'US' or 'NS' for miliseconds, microseconds or nanoseconds.  *	    DELAY  is cable delay, typically a few tens of ns.  *  *	There is an optional line, starting with OFFSET, followed  *	   by 1 or two fields.	The first is a number (a time) the second is  *	   'MS', 'US' or 'NS' for miliseconds, microseconds or nanoseconds.  *	   OFFSET is the offset of the PPS pulse from 0. (only fully implemented  *		with the PPSAPI, we need to be able to tell the Kernel about this  *		offset if the Kernel PLL is in use, but can only do this presently  *		when using the PPSAPI interface.  If not using the Kernel PLL,  *		then there is no problem.  *  *	There is an optional line, with either ASSERT or CLEAR on it, which  *	   determine which transition of the PPS signal is used for timing by the  *	   PPSAPI.  If neither is present, then ASSERT is assumed.  *	   ASSERT/CLEAR can also be set with FLAG2 of the ntp.conf input.  *	   For Flag2, ASSERT=0, and hence is default.  *  *	There is an optional line, with HARDPPS on it.	Including this line causes  *	   the PPS signal to control the kernel PLL.  *	   HARDPPS can also be set with FLAG3 of the ntp.conf input.  *	   For Flag3, 0 is disabled, and the default.  *  *	There are three options that have to do with using the shared memory option.  *	   First, to enable the option there must be a SHMEM line with a file name.  *	   The file name is the file associated with the shared memory.  *  *	In shared memory, there is one 'record' for each returned variable.  *	For the @@Ea data there are three 'records' containing position data.  *	   There will always be data in the record corresponding to the '0D' @@Ea record,  *	   and the user has a choice of filling the '3D' record by specifying POSN3D,  *	   or the '2D' record by specifying POSN2D.  In either case the '2D' or '3D'  *	   record is filled once every 15s.  *  *	Two additional variables that can be set are CHAN and TRAIM.  These should be  *	   set correctly by the code examining the @@Cj record, but we bring them out here  *	   to allow the user to override either the # of channels, or the existence of TRAIM.  *	   CHAN expects to be followed by in integer: 6, 8, or 12. TRAIM expects to be  *	   followed by YES or NO.  *  *	There is an optional line with MASK on it followed by one integer field in the  *	   range 0 to 89. This sets the satellite mask angle and will determine the minimum  *	   elevation angle for satellites to be tracked by the receiver. The default value  *	   is 10 deg for the VP and 0 deg for all other receivers.  *  * So acceptable input would be  *	# these are my coordinates (RWC)  *	LON  -106 34.610  *	LAT    35 08.999  *	HT	1589	# could equally well say HT 5215 FT  *	DELAY  60 ns  */
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cc
decl_stmt|,
modifier|*
name|ca
decl_stmt|,
name|line
index|[
literal|100
index|]
decl_stmt|,
name|units
index|[
literal|2
index|]
decl_stmt|,
name|device
index|[
literal|64
index|]
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|,
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|char
modifier|*
name|dirs
index|[]
init|=
block|{
literal|"/etc/ntp"
block|,
literal|"/etc"
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sign
decl_stmt|,
name|lat_flg
decl_stmt|,
name|long_flg
decl_stmt|,
name|ht_flg
decl_stmt|,
name|mode
decl_stmt|,
name|mask
decl_stmt|;
name|double
name|f1
decl_stmt|,
name|f2
decl_stmt|,
name|f3
decl_stmt|;
name|fd
operator|=
name|NULL
expr_stmt|;
comment|/* just to shutup gcc complaint */
for|for
control|(
name|cpp
operator|=
name|dirs
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
block|{
name|cp
operator|=
operator|*
name|cpp
expr_stmt|;
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
literal|"%s/ntp.oncore.%d"
argument_list|,
name|cp
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* try "ntp.oncore.0 */
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|device
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
break|break;
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
literal|"%s/ntp.oncore%d"
argument_list|,
name|cp
argument_list|,
name|instance
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* try "ntp.oncore0" */
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|device
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
break|break;
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
literal|"%s/ntp.oncore"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|device
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
comment|/* last try "ntp.oncore" */
break|break;
block|}
if|if
condition|(
operator|!
name|fd
condition|)
block|{
comment|/* no inputfile, default to the works ... */
name|instance
operator|->
name|init_type
operator|=
literal|4
expr_stmt|;
return|return;
block|}
name|mode
operator|=
name|mask
operator|=
literal|0
expr_stmt|;
name|lat_flg
operator|=
name|long_flg
operator|=
name|ht_flg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|100
argument_list|,
name|fd
argument_list|)
condition|)
block|{
comment|/* Remove comments */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'#'
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove trailing space */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
init|;
name|i
operator|>
literal|0
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
name|line
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|line
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|;
control|)
name|line
index|[
operator|--
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove leading space */
for|for
control|(
name|cc
operator|=
name|line
init|;
operator|*
name|cc
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|)
condition|;
name|cc
operator|++
control|)
continue|continue;
comment|/* Stop if nothing left */
if|if
condition|(
operator|!
operator|*
name|cc
condition|)
continue|continue;
comment|/* Uppercase the command and find the arg */
for|for
control|(
name|ca
operator|=
name|cc
init|;
operator|*
name|ca
condition|;
name|ca
operator|++
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
condition|)
block|{
operator|*
name|ca
operator|=
name|toupper
argument_list|(
operator|*
name|ca
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|||
operator|(
operator|*
name|ca
operator|==
literal|'='
operator|)
condition|)
break|break;
block|}
block|}
comment|/* Remove space (and possible =) leading the arg */
for|for
control|(
init|;
operator|*
name|ca
operator|&&
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|&&
operator|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|ca
argument_list|)
operator|||
operator|(
operator|*
name|ca
operator|==
literal|'='
operator|)
operator|)
condition|;
name|ca
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"STATUS"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"SHMEM"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_fname
operator|=
name|estrdup
argument_list|(
name|ca
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Uppercase argument as well */
for|for
control|(
name|cp
operator|=
name|ca
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isascii
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|islower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"LAT"
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
condition|)
block|{
name|f1
operator|=
name|f2
operator|=
name|f3
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %lf %lf"
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|f3
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
condition|)
block|{
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|instance
operator|->
name|ss_lat
operator|=
name|sign
operator|*
literal|1000
operator|*
operator|(
name|fabs
argument_list|(
name|f3
argument_list|)
operator|+
literal|60
operator|*
operator|(
name|fabs
argument_list|(
name|f2
argument_list|)
operator|+
literal|60
operator|*
name|f1
operator|)
operator|)
expr_stmt|;
comment|/*miliseconds*/
name|lat_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"LON"
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
condition|)
block|{
name|f1
operator|=
name|f2
operator|=
name|f3
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %lf %lf"
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|f3
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
condition|)
block|{
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|instance
operator|->
name|ss_long
operator|=
name|sign
operator|*
literal|1000
operator|*
operator|(
name|fabs
argument_list|(
name|f3
argument_list|)
operator|+
literal|60
operator|*
operator|(
name|fabs
argument_list|(
name|f2
argument_list|)
operator|+
literal|60
operator|*
name|f1
operator|)
operator|)
expr_stmt|;
comment|/*miliseconds*/
name|long_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"HT"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'F'
condition|)
name|f1
operator|=
literal|0.3048
operator|*
name|f1
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
literal|100
operator|*
name|f1
expr_stmt|;
comment|/* cm */
name|ht_flg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"DELAY"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|f1
operator|=
literal|1000
operator|*
name|f1
expr_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
name|f1
operator|=
literal|1000000
operator|*
name|f1
expr_stmt|;
else|else
name|f1
operator|=
literal|1000000000
operator|*
name|f1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|1.e9
condition|)
name|f1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|999999
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"PPS Cable delay of %fns out of Range, ignored"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_WARNING
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
else|else
name|instance
operator|->
name|delay
operator|=
name|f1
expr_stmt|;
comment|/* delay in ns */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"OFFSET"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|f1
operator|=
literal|0
expr_stmt|;
name|units
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%lf %1s"
argument_list|,
operator|&
name|f1
argument_list|,
name|units
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|f1
operator|=
literal|1000
operator|*
name|f1
expr_stmt|;
elseif|else
if|if
condition|(
name|units
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
name|f1
operator|=
literal|1000000
operator|*
name|f1
expr_stmt|;
else|else
name|f1
operator|=
literal|1000000000
operator|*
name|f1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|1.e9
condition|)
name|f1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0
operator|||
name|f1
operator|>
literal|999999999.
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"PPS Offset of %fns out of Range, ignored"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_WARNING
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
else|else
name|instance
operator|->
name|offset
operator|=
name|f1
expr_stmt|;
comment|/* offset in ns */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"MODE"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
literal|0
operator|||
name|mode
operator|>
literal|4
condition|)
name|mode
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"ASSERT"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|assert
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"CLEAR"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|instance
operator|->
name|assert
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"HARDPPS"
argument_list|,
operator|(
name|size_t
operator|)
literal|7
argument_list|)
condition|)
block|{
name|instance
operator|->
name|hardpps
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"POSN2D"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Posn
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"POSN3D"
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|)
condition|)
block|{
name|instance
operator|->
name|shmem_Posn
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"CHAN"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|6
operator|)
operator|||
operator|(
name|i
operator|==
literal|8
operator|)
operator|||
operator|(
name|i
operator|==
literal|12
operator|)
condition|)
name|instance
operator|->
name|chan_in
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"TRAIM"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
condition|)
block|{
name|instance
operator|->
name|traim_in
operator|=
literal|1
expr_stmt|;
comment|/* so TRAIM alone is YES */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ca
argument_list|,
literal|"NO"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ca
argument_list|,
literal|"OFF"
argument_list|)
condition|)
comment|/* Yes/No, On/Off */
name|instance
operator|->
name|traim_in
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cc
argument_list|,
literal|"MASK"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|ca
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|>
operator|-
literal|1
operator|&&
name|mask
operator|<
literal|90
condition|)
name|instance
operator|->
name|Ag
operator|=
name|mask
expr_stmt|;
comment|/* Satellite mask angle */
block|}
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 *    OK, have read all of data file, and extracted the good stuff. 	 *    If lat/long/ht specified they ALL must be specified for mode = (1,3). 	 */
name|instance
operator|->
name|posn_set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lat_flg
operator|&&
name|long_flg
operator|&&
name|ht_flg
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"ONCORE: incomplete data on %s"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_WARNING
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|instance
operator|->
name|posn_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|1
operator|||
name|mode
operator|==
literal|3
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Input Mode = %d, but no/incomplete position, mode set to %d"
argument_list|,
name|mode
argument_list|,
name|mode
operator|+
literal|1
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_WARNING
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|mode
operator|++
expr_stmt|;
block|}
block|}
name|instance
operator|->
name|init_type
operator|=
name|mode
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Input mode = %d"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * move data from NTP to buffer (toss the extra in the unlikely case it won't fit)  */
end_comment

begin_function
specifier|static
name|void
name|oncore_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|instance
modifier|*
name|instance
decl_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|instance
operator|=
operator|(
expr|struct
name|instance
operator|*
operator|)
name|peer
operator|->
name|procptr
operator|->
name|unitptr
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_RECEIVE
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|,
name|Msg2
index|[
literal|10
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|">>> %d bytes available"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|Msg
argument_list|,
literal|">>>"
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbufp
operator|->
name|recv_length
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg2
argument_list|)
argument_list|,
literal|"%02x "
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|Msg
argument_list|,
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|Msg
argument_list|,
literal|">>>"
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbufp
operator|->
name|recv_length
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg2
argument_list|)
argument_list|,
literal|"%03o "
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|Msg
argument_list|,
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|i
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|rcvbuf
operator|+
name|rcvptr
operator|+
name|i
operator|>
operator|&
name|rcvbuf
index|[
sizeof|sizeof
name|rcvbuf
index|]
condition|)
name|i
operator|=
sizeof|sizeof
argument_list|(
name|rcvbuf
argument_list|)
operator|-
name|rcvptr
expr_stmt|;
comment|/* and some char will be lost */
name|memcpy
argument_list|(
name|rcvbuf
operator|+
name|rcvptr
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rcvptr
operator|+=
name|i
expr_stmt|;
name|oncore_consume
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deal with any complete messages  */
end_comment

begin_function
specifier|static
name|void
name|oncore_consume
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
name|unsigned
name|l
decl_stmt|;
while|while
condition|(
name|rcvptr
operator|>=
literal|7
condition|)
block|{
if|if
condition|(
name|rcvbuf
index|[
literal|0
index|]
operator|!=
literal|'@'
operator|||
name|rcvbuf
index|[
literal|1
index|]
operator|!=
literal|'@'
condition|)
block|{
comment|/* We're not in sync, lets try to get there */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rcvptr
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rcvbuf
index|[
name|i
index|]
operator|==
literal|'@'
operator|&&
name|rcvbuf
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'@'
condition|)
break|break;
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_CONSUME
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|">>> skipping %d chars"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|i
operator|!=
name|rcvptr
condition|)
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
name|i
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|rcvptr
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* Ok, we have a header now */
name|l
operator|=
sizeof|sizeof
argument_list|(
name|oncore_messages
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|oncore_messages
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|l
condition|;
name|m
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|oncore_messages
index|[
name|m
index|]
operator|.
name|flag
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|rcvbuf
operator|+
literal|2
operator|)
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|l
condition|)
block|{
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_CONSUME
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|">>> Unknown MSG, skipping 4 (%c%c)"
argument_list|,
name|rcvbuf
index|[
literal|2
index|]
argument_list|,
name|rcvbuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
literal|4
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
literal|4
expr_stmt|;
continue|continue;
block|}
name|l
operator|=
name|oncore_messages
index|[
name|m
index|]
operator|.
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_CONSUME
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"GOT: %c%c  %d of %d entry %d"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|rcvbuf
index|[
literal|2
index|]
argument_list|,
name|rcvbuf
index|[
literal|3
index|]
argument_list|,
name|rcvptr
argument_list|,
name|l
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Got the entire message ? */
if|if
condition|(
name|rcvptr
operator|<
name|l
condition|)
return|return;
comment|/* are we at the end of message? should be<Cksum><CR><LF> */
if|if
condition|(
name|rcvbuf
index|[
name|l
operator|-
literal|2
index|]
operator|!=
literal|'\r'
operator|||
name|rcvbuf
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_CONSUME
if|if
condition|(
name|debug
condition|)
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"NO<CR><LF> at end of message"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* check the CheckSum */
if|if
condition|(
name|oncore_checksum_ok
argument_list|(
name|rcvbuf
argument_list|,
name|l
argument_list|)
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|shmem
operator|!=
name|NULL
condition|)
block|{
name|instance
operator|->
name|shmem
index|[
name|oncore_messages
index|[
name|m
index|]
operator|.
name|shmem
operator|+
literal|2
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|instance
operator|->
name|shmem
operator|+
name|oncore_messages
index|[
name|m
index|]
operator|.
name|shmem
operator|+
literal|3
argument_list|,
name|rcvbuf
argument_list|,
operator|(
name|size_t
operator|)
name|l
argument_list|)
expr_stmt|;
block|}
name|oncore_msg_any
argument_list|(
name|instance
argument_list|,
name|rcvbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|l
operator|-
literal|3
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|oncore_messages
index|[
name|m
index|]
operator|.
name|handler
condition|)
name|oncore_messages
index|[
name|m
index|]
operator|.
name|handler
argument_list|(
name|instance
argument_list|,
name|rcvbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|l
operator|-
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_CONSUME
elseif|else
if|if
condition|(
name|debug
condition|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|,
name|Msg2
index|[
literal|10
index|]
decl_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"Checksum mismatch!"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"@@%c%c "
argument_list|,
name|rcvbuf
index|[
literal|2
index|]
argument_list|,
name|rcvbuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg2
argument_list|)
argument_list|,
literal|"%03o "
argument_list|,
name|rcvbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|Msg
argument_list|,
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|l
operator|!=
name|rcvptr
condition|)
name|memcpy
argument_list|(
name|rcvbuf
argument_list|,
name|rcvbuf
operator|+
name|l
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|rcvptr
operator|-
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|rcvptr
operator|-=
name|l
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|oncore_get_timestamp
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|long
name|dt1
parameter_list|,
comment|/* tick offset THIS time step */
name|long
name|dt2
comment|/* tick offset NEXT time step */
parameter_list|)
block|{
name|int
name|Rsm
decl_stmt|;
name|u_long
name|j
decl_stmt|;
name|l_fp
name|ts
decl_stmt|,
name|ts_tmp
decl_stmt|;
name|double
name|dmy
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|struct
name|timespec
modifier|*
name|tsp
init|=
literal|0
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
modifier|*
name|tsp
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|current_mode
decl_stmt|;
name|pps_params_t
name|current_params
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|pps_info_t
name|pps_i
decl_stmt|;
name|char
name|Msg
index|[
literal|140
index|]
decl_stmt|;
name|peer
operator|=
name|instance
operator|->
name|peer
expr_stmt|;
if|#
directive|if
literal|1
comment|/* If we are in SiteSurvey mode, then we are in 3D mode, and we fall thru. 	 * If we have Finished the SiteSurvey, then we fall thru for the 14/15 	 *  times we get here in 0D mode (the 1/15 is in 3D for SHMEM). 	 * This gives good time, which gets better when the SS is done. 	 */
if|if
condition|(
operator|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_DONE
operator|)
operator|&&
operator|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_0D
operator|)
condition|)
block|{
else|#
directive|else
comment|/* old check, only fall thru for SS_DONE and 0D mode, 2h45m wait for ticks */
if|if
condition|(
operator|(
name|instance
operator|->
name|site_survey
operator|!=
name|ONCORE_SS_DONE
operator|)
operator|||
operator|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_0D
operator|)
condition|)
block|{
endif|#
directive|endif
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
return|return;
block|}
comment|/* Don't do anything without an almanac to define the GPS->UTC delta */
if|if
condition|(
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
condition|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
return|return;
block|}
comment|/* Once the Almanac is valid, the M12+T does not produce valid UTC 	 * immediately. 	 * Wait for UTC offset decode valid, then wait one message more 	 * so we are not off by 13 seconds after  reset. 	 */
if|if
condition|(
name|instance
operator|->
name|count5
condition|)
block|{
name|instance
operator|->
name|count5
operator|--
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
return|return;
block|}
name|j
operator|=
name|instance
operator|->
name|ev_serial
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|time_pps_fetch
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
name|PPS_TSFMT_TSPEC
argument_list|,
operator|&
name|pps_i
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"time_pps_fetch failed"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
block|{
name|tsp
operator|=
operator|&
name|pps_i
operator|.
name|assert_timestamp
expr_stmt|;
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_GET_TIMESTAMP
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|u_long
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|u_long
operator|)
name|pps_i
operator|.
name|assert_sequence
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"serial/j (%lu, %lu) %ld.%09ld"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_nsec
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"serial/j (%lu, %lu) %ld.%06ld"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pps_i
operator|.
name|assert_sequence
operator|==
name|j
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"ONCORE: oncore_get_timestamp, error serial pps"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|pps_i
operator|.
name|assert_sequence
expr_stmt|;
block|}
else|else
block|{
name|tsp
operator|=
operator|&
name|pps_i
operator|.
name|clear_timestamp
expr_stmt|;
if|#
directive|if
literal|0
block|if (debug> 2) { 			u_long i;  			i = (u_long) pps_i.clear_sequence;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_TIMESPEC
block|snprintf(Msg, sizeof(Msg), 				 "serial/j (%lu, %lu) %ld.%09ld", i, j, 				 (long)tsp->tv_sec, (long)tsp->tv_nsec);
else|#
directive|else
block|snprintf(Msg. sizeof(Msg), 				 "serial/j (%lu, %lu) %ld.%06ld", i, j, 				 (long)tsp->tv_sec, (long)tsp->tv_usec);
endif|#
directive|endif
block|oncore_log(instance, LOG_DEBUG, Msg); 		}
endif|#
directive|endif
if|if
condition|(
name|pps_i
operator|.
name|clear_sequence
operator|==
name|j
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"oncore_get_timestamp, error serial pps"
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
return|return;
block|}
name|instance
operator|->
name|ev_serial
operator|=
name|pps_i
operator|.
name|clear_sequence
expr_stmt|;
block|}
comment|/* convert timespec -> ntp l_fp */
name|dmy
operator|=
name|tsp
operator|->
name|tv_nsec
expr_stmt|;
name|dmy
operator|/=
literal|1e9
expr_stmt|;
name|ts
operator|.
name|l_uf
operator|=
name|dmy
operator|*
literal|4294967296.0
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|=
name|tsp
operator|->
name|tv_sec
expr_stmt|;
if|#
directive|if
literal|0
block|alternate code for previous 4 lines is 	dmy = 1.0e-9*tsp->tv_nsec;
comment|/* fractional part */
block|DTOLFP(dmy,&ts); 	dmy = tsp->tv_sec;
comment|/* integer part */
block|DTOLFP(dmy,&ts_tmp); 	L_ADD(&ts,&ts_tmp);      or more simply 	dmy = 1.0e-9*tsp->tv_nsec;
comment|/* fractional part */
block|DTOLFP(dmy,&ts); 	ts.l_ui = tsp->tv_sec;
endif|#
directive|endif
comment|/* 0 */
comment|/* now have timestamp in ts */
comment|/* add in saw_tooth and offset, these will be ZERO if no TRAIM */
comment|/* they will be IGNORED if the PPSAPI cant do PPS_OFFSET/ASSERT/CLEAR */
comment|/* we just try to add them in and dont test for that here */
comment|/* saw_tooth not really necessary if using TIMEVAL */
comment|/* since its only precise to us, but do it anyway. */
comment|/* offset in ns, and is positive (late), we subtract */
comment|/* to put the PPS time transition back where it belongs */
comment|/* must hand the offset for the NEXT sec off to the Kernel to do */
comment|/* the addition, so that the Kernel PLL sees the offset too */
if|if
condition|(
name|instance
operator|->
name|assert
condition|)
name|instance
operator|->
name|pps_p
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
else|else
name|instance
operator|->
name|pps_p
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
comment|/* The following code is necessary, and not just a time_pps_setparams, 	 * using the saved instance->pps_p, since some other process on the 	 * machine may have diddled with the mode bits (say adding something 	 * that it needs).  We take what is there and ADD what we need. 	 * [[ The results from the time_pps_getcap is unlikely to change so 	 *    we could probably just save it, but I choose to do the call ]] 	 * Unfortunately, there is only ONE set of mode bits in the kernel per 	 * interface, and not one set for each open handle. 	 * 	 * There is still a race condition here where we might mess up someone 	 * elses mode, but if he is being careful too, he should survive. 	 */
if|if
condition|(
name|time_pps_getcap
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|current_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msnprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"time_pps_getcap failed: %m"
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|time_pps_getparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|current_params
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msnprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"time_pps_getparams failed: %m"
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
return|return;
block|}
comment|/* or current and mine */
name|current_params
operator|.
name|mode
operator||=
name|instance
operator|->
name|pps_p
operator|.
name|mode
expr_stmt|;
comment|/* but only set whats legal */
name|current_params
operator|.
name|mode
operator|&=
name|current_mode
expr_stmt|;
name|current_params
operator|.
name|assert_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|current_params
operator|.
name|assert_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
name|current_params
operator|.
name|clear_offset
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|current_params
operator|.
name|clear_offset
operator|.
name|tv_nsec
operator|=
operator|-
name|dt2
expr_stmt|;
if|if
condition|(
name|time_pps_setparams
argument_list|(
name|instance
operator|->
name|pps_h
argument_list|,
operator|&
name|current_params
argument_list|)
condition|)
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"ONCORE: Error doing time_pps_setparams"
argument_list|)
expr_stmt|;
comment|/* have time from UNIX origin, convert to NTP origin. */
name|ts
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|lastrec
operator|=
name|ts
expr_stmt|;
comment|/* print out information about this timestamp (long line) */
name|ts_tmp
operator|=
name|ts
expr_stmt|;
name|ts_tmp
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
comment|/* zero integer part */
name|LFPTOD
argument_list|(
operator|&
name|ts_tmp
argument_list|,
name|dmy
argument_list|)
expr_stmt|;
comment|/* convert fractional part to a double */
name|j
operator|=
literal|1.0e9
operator|*
name|dmy
expr_stmt|;
comment|/* then to integer ns */
name|Rsm
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|Rsm
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|Rsm
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|Rsm
operator|=
operator|(
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|129
index|]
operator|<<
literal|8
operator|)
operator||
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
operator|||
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
name|char
name|f1
index|[
literal|5
index|]
decl_stmt|,
name|f2
index|[
literal|5
index|]
decl_stmt|,
name|f3
index|[
literal|5
index|]
decl_stmt|,
name|f4
index|[
literal|5
index|]
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|traim
condition|)
block|{
name|snprintf
argument_list|(
name|f1
argument_list|,
sizeof|sizeof
argument_list|(
name|f1
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|instance
operator|->
name|BEHn
index|[
literal|21
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|f2
argument_list|,
sizeof|sizeof
argument_list|(
name|f2
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|instance
operator|->
name|BEHn
index|[
literal|22
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|f3
argument_list|,
sizeof|sizeof
argument_list|(
name|f3
argument_list|)
argument_list|,
literal|"%2d"
argument_list|,
name|instance
operator|->
name|BEHn
index|[
literal|23
index|]
operator|*
literal|256
operator|+
name|instance
operator|->
name|BEHn
index|[
literal|24
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|f4
argument_list|,
sizeof|sizeof
argument_list|(
name|f4
argument_list|)
argument_list|,
literal|"%3d"
argument_list|,
operator|(
name|s_char
operator|)
name|instance
operator|->
name|BEHn
index|[
literal|25
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|f1
argument_list|,
literal|"x"
argument_list|,
sizeof|sizeof
argument_list|(
name|f1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f2
argument_list|,
literal|"x"
argument_list|,
sizeof|sizeof
argument_list|(
name|f2
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f3
argument_list|,
literal|"xx"
argument_list|,
sizeof|sizeof
argument_list|(
name|f3
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f4
argument_list|,
literal|"xxx"
argument_list|,
sizeof|sizeof
argument_list|(
name|f4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
comment|/* MAX length 128, currently at 127 */
literal|"%u.%09lu %d %d %2d %2d %2d %2ld rstat   %02x dop %4.1f nsat %2d,%d traim %d,%s,%s sigma %s neg-sawtooth %s sat %d%d%d%d%d%d%d%d"
argument_list|,
name|ts
operator|.
name|l_ui
argument_list|,
name|j
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|year
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|day
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|hour
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|minute
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|second
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
operator|%
literal|60
argument_list|,
name|Rsm
argument_list|,
literal|0.1
operator|*
operator|(
literal|256
operator|*
name|instance
operator|->
name|BEHa
index|[
literal|35
index|]
operator|+
name|instance
operator|->
name|BEHa
index|[
literal|36
index|]
operator|)
argument_list|,
comment|/*rsat	dop */
name|instance
operator|->
name|BEHa
index|[
literal|38
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|39
index|]
argument_list|,
name|instance
operator|->
name|traim
argument_list|,
name|f1
argument_list|,
name|f2
argument_list|,
comment|/*	nsat visible,	  nsat tracked,     traim,traim,traim */
name|f3
argument_list|,
name|f4
argument_list|,
comment|/* sigma neg-sawtooth */
comment|/*sat*/
name|instance
operator|->
name|BEHa
index|[
literal|41
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|45
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|49
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|53
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|57
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|61
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|65
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|69
index|]
argument_list|)
expr_stmt|;
comment|/* will be 0 for 6 chan */
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|char
name|f1
index|[
literal|5
index|]
decl_stmt|,
name|f2
index|[
literal|5
index|]
decl_stmt|,
name|f3
index|[
literal|5
index|]
decl_stmt|,
name|f4
index|[
literal|5
index|]
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|traim
condition|)
block|{
name|snprintf
argument_list|(
name|f1
argument_list|,
sizeof|sizeof
argument_list|(
name|f1
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|instance
operator|->
name|BEHn
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|f2
argument_list|,
sizeof|sizeof
argument_list|(
name|f2
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|instance
operator|->
name|BEHn
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|f3
argument_list|,
sizeof|sizeof
argument_list|(
name|f3
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|instance
operator|->
name|BEHn
index|[
literal|12
index|]
operator|*
literal|256
operator|+
name|instance
operator|->
name|BEHn
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|f4
argument_list|,
sizeof|sizeof
argument_list|(
name|f4
argument_list|)
argument_list|,
literal|"%3d"
argument_list|,
operator|(
name|s_char
operator|)
name|instance
operator|->
name|BEHn
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|f1
argument_list|,
literal|"x"
argument_list|,
sizeof|sizeof
argument_list|(
name|f1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f2
argument_list|,
literal|"x"
argument_list|,
sizeof|sizeof
argument_list|(
name|f2
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f3
argument_list|,
literal|"xx"
argument_list|,
sizeof|sizeof
argument_list|(
name|f3
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f4
argument_list|,
literal|"xxx"
argument_list|,
sizeof|sizeof
argument_list|(
name|f4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"%u.%09lu %d %d %2d %2d %2d %2ld rstat %02x dop %4.1f nsat %2d,%d traim %d,%s,%s sigma %s neg-sawtooth %s sat %d%d%d%d%d%d%d%d%d%d%d%d"
argument_list|,
name|ts
operator|.
name|l_ui
argument_list|,
name|j
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|year
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|day
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|hour
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|minute
argument_list|,
name|instance
operator|->
name|pp
operator|->
name|second
argument_list|,
operator|(
name|long
operator|)
name|tsp
operator|->
name|tv_sec
operator|%
literal|60
argument_list|,
name|Rsm
argument_list|,
literal|0.1
operator|*
operator|(
literal|256
operator|*
name|instance
operator|->
name|BEHa
index|[
literal|53
index|]
operator|+
name|instance
operator|->
name|BEHa
index|[
literal|54
index|]
operator|)
argument_list|,
comment|/*rsat	dop */
name|instance
operator|->
name|BEHa
index|[
literal|55
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|56
index|]
argument_list|,
name|instance
operator|->
name|traim
argument_list|,
name|f1
argument_list|,
name|f2
argument_list|,
comment|/*	nsat visible,	  nsat tracked	 traim,traim,traim */
name|f3
argument_list|,
name|f4
argument_list|,
comment|/* sigma neg-sawtooth */
comment|/*sat*/
name|instance
operator|->
name|BEHa
index|[
literal|58
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|70
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|76
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|82
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|88
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|94
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|100
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|106
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|112
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|118
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|124
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* and some things I dont understand (magic ntp things) */
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|instance
operator|->
name|pp
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|instance
operator|->
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
return|return;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
comment|/* this is long message above */
name|instance
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|polled
condition|)
block|{
name|instance
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
comment|/* instance->pp->dispersion = instance->pp->skew = 0;	*/
name|instance
operator|->
name|pp
operator|->
name|lastref
operator|=
name|instance
operator|->
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_receive
argument_list|(
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|flags
operator||=
name|FLAG_PPS
expr_stmt|;
block|}
comment|/*************** oncore_msg_XX routines start here *******************/
comment|/*  * print Oncore response message.  */
specifier|static
name|void
name|oncore_msg_any
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_MSG_ANY
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|oncore_messages
index|[
name|idx
index|]
operator|.
name|fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|qlim
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
name|struct
name|timespec
name|ts
decl_stmt|;
endif|#
directive|endif
name|struct
name|timeval
name|tv
decl_stmt|;
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|,
name|Msg2
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"%ld.%06ld"
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|fmt
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|">>@@%c%c "
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|len
operator|&&
name|i
operator|<
literal|2400
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg2
argument_list|)
argument_list|,
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|Msg
argument_list|,
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|strncat
argument_list|(
name|Msg
argument_list|,
literal|"##"
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|)
expr_stmt|;
name|qlim
operator|=
name|Msg
operator|+
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
operator|-
literal|3
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fmt
operator|,
name|q
operator|=
name|Msg
operator|+
literal|2
init|;
name|q
operator|<
name|qlim
operator|&&
operator|*
name|p
condition|;
control|)
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'_'
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"%c%c"
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fmt
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|Msg2
argument_list|,
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|Msg
argument_list|,
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* Latitude, Longitude, Height */
specifier|static
name|void
name|oncore_msg_Adef
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{ }
comment|/* Mask Angle */
specifier|static
name|void
name|oncore_msg_Ag
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
literal|"set to"
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_RUN
condition|)
name|cp
operator|=
literal|"is"
expr_stmt|;
name|instance
operator|->
name|Ag
operator|=
name|buf
index|[
literal|4
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Satellite mask angle %s %d degrees"
argument_list|,
name|cp
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|Ag
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/*  * get Position hold position  */
specifier|static
name|void
name|oncore_msg_As
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|instance
operator|->
name|ss_lat
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
comment|/* Print out Position */
name|oncore_print_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
comment|/*  * Try to use Oncore UT+ Auto Survey Feature  *	If its not there (VP), set flag to do it ourselves.  */
specifier|static
name|void
name|oncore_msg_At
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|instance
operator|->
name|saw_At
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_TESTING
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|2
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"Initiating hardware 3D site survey"
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"SSstate = ONCORE_SS_HW"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_HW
expr_stmt|;
block|}
block|}
block|}
comment|/*  * get PPS Offset  * Nb. @@Ay is not supported for early UT (no plus) model  */
specifier|static
name|void
name|oncore_msg_Ay
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|saw_Ay
condition|)
return|return;
name|instance
operator|->
name|saw_Ay
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|offset
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"PPS Offset is set to %ld ns"
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/*  * get Cable Delay  */
specifier|static
name|void
name|oncore_msg_Az
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|saw_Az
condition|)
return|return;
name|instance
operator|->
name|saw_Az
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|delay
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Cable delay is set to %ld ns"
argument_list|,
name|instance
operator|->
name|delay
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/* Ba, Ea and Ha come here, these contain Position */
specifier|static
name|void
name|oncore_msg_BaEaHa
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* OK, we are close to the RUN state now. 	 * But we have a few more items to initialize first. 	 * 	 * At the beginning of this routine there are several 'timers'. 	 * We enter this routine 1/sec, and since the upper levels of NTP have usurped 	 * the use of timers, we use the 1/sec entry to do things that 	 * we would normally do with timers... 	 */
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_CHECK_CHAN
condition|)
block|{
comment|/* here while checking for the # chan */
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'B'
condition|)
block|{
comment|/* 6chan */
if|if
condition|(
name|instance
operator|->
name|chan_ck
operator|<
literal|6
condition|)
name|instance
operator|->
name|chan_ck
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* 8chan */
if|if
condition|(
name|instance
operator|->
name|chan_ck
operator|<
literal|8
condition|)
name|instance
operator|->
name|chan_ck
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'H'
condition|)
block|{
comment|/* 12chan */
if|if
condition|(
name|instance
operator|->
name|chan_ck
operator|<
literal|12
condition|)
name|instance
operator|->
name|chan_ck
operator|=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|->
name|count3
operator|++
operator|<
literal|5
condition|)
return|return;
name|instance
operator|->
name|count3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan_in
operator|!=
operator|-
literal|1
condition|)
comment|/* set in Input */
name|instance
operator|->
name|chan
operator|=
name|instance
operator|->
name|chan_in
expr_stmt|;
else|else
comment|/* set from test */
name|instance
operator|->
name|chan
operator|=
name|instance
operator|->
name|chan_ck
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Input   says chan = %d"
argument_list|,
name|instance
operator|->
name|chan_in
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Model # says chan = %d"
argument_list|,
name|instance
operator|->
name|chan_id
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Testing says chan = %d"
argument_list|,
name|instance
operator|->
name|chan_ck
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Using        chan = %d"
argument_list|,
name|instance
operator|->
name|chan
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_HAVE_CHAN
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_HAVE_CHAN"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|4
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_ALMANAC
operator|&&
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_RUN
condition|)
return|return;
comment|/* PAUSE 5sec - make sure results are stable, before using position */
if|if
condition|(
name|instance
operator|->
name|count
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|count
operator|++
operator|<
literal|5
condition|)
return|return;
name|instance
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|instance
operator|->
name|BEHa
argument_list|,
name|buf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|len
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ba, Ea or Ha */
comment|/* check the antenna (did it get unplugged) and almanac (is it ready) for changes. */
name|oncore_check_almanac
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|oncore_check_antenna
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* If we are in Almanac mode, waiting for Almanac, we can't do anything till we have it */
comment|/* When we have an almanac, we will start the Bn/En/@@Hn messages */
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_ALMANAC
condition|)
if|if
condition|(
name|oncore_wait_almanac
argument_list|(
name|instance
argument_list|)
condition|)
return|return;
comment|/* do some things once when we get this far in BaEaHa */
if|if
condition|(
name|instance
operator|->
name|once
condition|)
block|{
name|instance
operator|->
name|once
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|count2
operator|=
literal|1
expr_stmt|;
comment|/* Have we seen an @@At (position hold) command response */
comment|/* if not, message out */
if|if
condition|(
name|instance
operator|->
name|chan
operator|!=
literal|12
operator|&&
operator|!
name|instance
operator|->
name|saw_At
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"Not Good, no @@At command (no Position Hold), must be a GT/GT+"
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* have an Almanac, can start the SiteSurvey 		 * (actually only need to get past the almanac_load where we diddle with At 		 *  command,- we can't change it after we start the HW_SS below 		 */
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* NO initialization, don't change anything */
case|case
literal|1
case|:
comment|/* Use given Position */
case|case
literal|3
case|:
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"SSstate = ONCORE_SS_DONE"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|4
case|:
comment|/* Site Survey */
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"SSstate = ONCORE_SS_TESTING"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_TESTING
expr_stmt|;
name|instance
operator|->
name|count1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gd3
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* M12+T */
else|else
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_At2
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* not GT, arg not VP */
break|break;
block|}
comment|/* Read back PPS Offset for Output */
comment|/* Nb. This will fail silently for early UT (no plus) and M12 models */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ayx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ayx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read back Cable Delay for Output */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Azx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Azx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read back Satellite Mask Angle for Output */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Agx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Agx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Unfortunately, the Gd3 command returns '3' for the M12 v1.3 firmware where it is 	 * out-of-range and it should return 0-2. (v1.3 can't do a HW Site Survey) 	 * We must do the Gd3, and then wait a cycle or two for things to settle, 	 * then check Ha[130]&0x10 to see if a SS is in progress. 	 * We will set SW if HW has not been set after an appropriate delay. 	 */
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_TESTING
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|count1
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|count1
operator|++
operator|>
literal|5
operator|||
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
operator|&
literal|0x10
condition|)
block|{
name|instance
operator|->
name|count1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
operator|&
literal|0x10
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"Initiating hardware 3D site survey"
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"SSstate = ONCORE_SS_HW"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_HW
expr_stmt|;
block|}
else|else
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"SSstate = ONCORE_SS_SW"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_SW
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|count1
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|count1
operator|++
operator|>
literal|5
condition|)
block|{
name|instance
operator|->
name|count1
operator|=
literal|0
expr_stmt|;
comment|/* 					 * For instance->site_survey to still be ONCORE_SS_TESTING, then after a 5sec 					 * wait after the @@At2/@@Gd3 command we have not changed the state to 					 * ONCORE_SS_HW.  If the Hardware is capable of doing a Site Survey, then 					 * the variable would have been changed by now. 					 * There are three possibilities: 					 * 6/8chan 					 *   (a) We did not get a response to the @@At0 or @@At2 commands, 					 *	   and it must be a GT/GT+/SL with no position hold mode. 					 *	   We will have to do it ourselves. 					 *   (b) We saw the @@At0, @@At2 commands, but @@At2 failed, 					 *	   must be a VP or older UT which doesn't have Site Survey mode. 					 *	   We will have to do it ourselves. 					 * 12chan 					 *   (c) We saw the @@Gd command, and saw H[13]*0x10 					 *	   We will have to do it ourselves (done above) 					 */
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Initiating software 3D site survey (%d samples)"
argument_list|,
name|POS_HOLD_AVERAGE
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"SSstate = ONCORE_SS_SW"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_SW
expr_stmt|;
name|instance
operator|->
name|ss_lat
operator|=
name|instance
operator|->
name|ss_long
operator|=
name|instance
operator|->
name|ss_ht
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gd0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable */
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_At0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable */
block|}
block|}
block|}
block|}
block|}
comment|/* check the mode we are in 0/2/3D */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x8
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_0D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x10
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_2D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x20
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_3D
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x8
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_0D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x10
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_2D
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x20
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_3D
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|int
name|bits
decl_stmt|;
name|bits
operator|=
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|129
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
comment|/* actually Ha */
if|if
condition|(
name|bits
operator|==
literal|0x4
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_0D
expr_stmt|;
elseif|else
if|if
condition|(
name|bits
operator|==
literal|0x6
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_2D
expr_stmt|;
elseif|else
if|if
condition|(
name|bits
operator|==
literal|0x7
condition|)
name|instance
operator|->
name|mode
operator|=
name|MODE_3D
expr_stmt|;
block|}
comment|/* copy the record to the (extra) location in SHMEM */
if|if
condition|(
name|instance
operator|->
name|shmem
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|smp
decl_stmt|;
comment|/* pointer to start of shared mem for Ba/Ea/Ha */
switch|switch
condition|(
name|instance
operator|->
name|chan
condition|)
block|{
case|case
literal|6
case|:
name|smp
operator|=
operator|&
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Ba
index|]
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|smp
operator|=
operator|&
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Ea
index|]
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|smp
operator|=
operator|&
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Ha
index|]
expr_stmt|;
break|break;
default|default:
name|smp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|instance
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_0D
case|:
name|i
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 0D, Position Hold */
case|case
name|MODE_2D
case|:
name|i
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* 2D, Altitude Hold */
case|case
name|MODE_3D
case|:
name|i
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* 3D fix */
default|default:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|&&
name|smp
operator|!=
name|NULL
condition|)
block|{
name|i
operator|*=
operator|(
name|len
operator|+
literal|6
operator|)
expr_stmt|;
name|smp
index|[
name|i
operator|+
literal|2
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|smp
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|buf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|len
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * check if traim timer active 	 * if it hasn't been cleared, then @@Bn/@@En/@@Hn did not respond 	 */
if|if
condition|(
name|instance
operator|->
name|traim_delay
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|traim_delay
operator|++
operator|>
literal|5
condition|)
block|{
name|instance
operator|->
name|traim
operator|=
literal|0
expr_stmt|;
name|instance
operator|->
name|traim_delay
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
literal|"ONCORE: Did not detect TRAIM response, TRAIM = OFF"
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oncore_set_traim
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
block|}
comment|/* by now should have a @@Ba/@@Ea/@@Ha with good data in it */
if|if
condition|(
operator|!
name|instance
operator|->
name|have_dH
operator|&&
operator|!
name|instance
operator|->
name|traim_delay
condition|)
name|oncore_compute_dH
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* 	 * must be ONCORE_RUN if we are here. 	 * Have # chan and TRAIM by now. 	 */
name|instance
operator|->
name|pp
operator|->
name|year
operator|=
name|buf
index|[
literal|6
index|]
operator|*
literal|256
operator|+
name|buf
index|[
literal|7
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|day
operator|=
name|ymd2yd
argument_list|(
name|buf
index|[
literal|6
index|]
operator|*
literal|256
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|hour
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|minute
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|instance
operator|->
name|pp
operator|->
name|second
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
comment|/* 	 * Are we doing a Hardware or Software Site Survey? 	 */
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_HW
operator|||
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_SW
condition|)
name|oncore_ss
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* see if we ever saw a response from the @@Ayx above */
if|if
condition|(
name|instance
operator|->
name|count2
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|count2
operator|++
operator|>
literal|5
condition|)
block|{
comment|/* this delay to check on @@Ay command */
name|instance
operator|->
name|count2
operator|=
literal|0
expr_stmt|;
comment|/* Have we seen an Ay (1PPS time offset) command response */
comment|/* if not, and non-zero offset, zero the offset, and send message */
if|if
condition|(
operator|!
name|instance
operator|->
name|saw_Ay
operator|&&
name|instance
operator|->
name|offset
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
literal|"No @@Ay command, PPS OFFSET ignored"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Check the leap second status once per day. 	 */
name|oncore_check_leap_sec
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* 	 * if SHMEM active, every 15s, steal one 'tick' to get 2D or 3D posn. 	 */
if|if
condition|(
name|instance
operator|->
name|shmem
operator|&&
operator|!
name|instance
operator|->
name|shmem_bad_Ea
operator|&&
name|instance
operator|->
name|shmem_Posn
operator|&&
operator|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_DONE
operator|)
condition|)
name|oncore_shmem_get_3D
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|traim
condition|)
comment|/* NO traim, no BnEnHn, go get tick */
name|oncore_get_timestamp
argument_list|(
name|instance
argument_list|,
name|instance
operator|->
name|offset
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Almanac Status */
specifier|static
name|void
name|oncore_msg_Bd
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Bd: Almanac %s, week = %d, t = %d, %d SVs: %x"
argument_list|,
operator|(
operator|(
name|buf
index|[
literal|4
index|]
operator|)
condition|?
literal|"LOADED"
else|:
literal|"(NONE)"
operator|)
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
name|buf
index|[
literal|6
index|]
argument_list|,
name|buf
index|[
literal|7
index|]
argument_list|,
name|w32
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/* get leap-second warning message */
comment|/*  * @@Bj does NOT behave as documented in current Oncore firmware.  * It turns on the LEAP indicator when the data is set, and does not,  * as documented, wait until the beginning of the month when the  * leap second will occur.  * Since this firmware bug will never be fixed in all the outstanding Oncore receivers  * @@Bj is only called in June/December.  */
specifier|static
name|void
name|oncore_msg_Bj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|instance
operator|->
name|saw_Bj
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|4
index|]
condition|)
block|{
case|case
literal|1
case|:
name|instance
operator|->
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set pp.leap to LEAP_ADDSECOND"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instance
operator|->
name|pp
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set pp.leap to LEAP_DELSECOND"
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|instance
operator|->
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|cp
operator|=
literal|"Set pp.leap to LEAP_NOWARNING"
expr_stmt|;
break|break;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|oncore_msg_Bl
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|chan
decl_stmt|,
name|id
decl_stmt|,
name|subframe
decl_stmt|,
name|valid
decl_stmt|,
name|page
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tow
decl_stmt|;
name|int
name|day_now
decl_stmt|,
name|day_lsf
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|Msg
index|[
literal|120
index|]
decl_stmt|;
enum|enum
block|{
name|WARN_NOT_YET
block|,
name|WARN_0
block|,
name|WARN_PLUS
block|,
name|WARN_MINUS
block|}
name|warn
enum|;
name|day_now
operator|=
name|day_lsf
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
comment|/* keep gcc happy */
name|chan
operator|=
name|buf
index|[
literal|4
index|]
operator|&
literal|0377
expr_stmt|;
name|id
operator|=
name|buf
index|[
literal|5
index|]
operator|&
literal|0377
expr_stmt|;
name|subframe
operator|=
name|buf
index|[
literal|6
index|]
operator|&
literal|017
expr_stmt|;
name|valid
operator|=
operator|(
name|buf
index|[
literal|6
index|]
operator|>>
literal|4
operator|)
operator|&
literal|017
expr_stmt|;
name|page
operator|=
name|buf
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|instance
operator|->
name|Bl
operator|.
name|lsf_flg
operator|&&
operator|!
name|instance
operator|->
name|Bl
operator|.
name|wn_flg
operator|)
operator|&&
operator|(
name|subframe
operator|==
literal|4
operator|&&
name|page
operator|==
literal|18
operator|&&
name|valid
operator|==
literal|10
operator|)
condition|)
block|{
name|instance
operator|->
name|Bl
operator|.
name|dt_ls
operator|=
name|buf
index|[
literal|32
index|]
expr_stmt|;
name|instance
operator|->
name|Bl
operator|.
name|WN_lsf
operator|=
name|buf
index|[
literal|33
index|]
expr_stmt|;
name|instance
operator|->
name|Bl
operator|.
name|DN_lsf
operator|=
name|buf
index|[
literal|34
index|]
expr_stmt|;
name|instance
operator|->
name|Bl
operator|.
name|dt_lsf
operator|=
name|buf
index|[
literal|35
index|]
expr_stmt|;
name|instance
operator|->
name|Bl
operator|.
name|lsf_flg
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|instance
operator|->
name|Bl
operator|.
name|lsf_flg
operator|&&
operator|!
name|instance
operator|->
name|Bl
operator|.
name|wn_flg
operator|)
operator|&&
operator|(
name|subframe
operator|==
literal|1
operator|&&
name|valid
operator|==
literal|10
operator|)
condition|)
block|{
name|i
operator|=
operator|(
name|buf
index|[
literal|7
operator|+
literal|7
index|]
operator|<<
literal|8
operator|)
operator|+
name|buf
index|[
literal|7
operator|+
literal|8
index|]
expr_stmt|;
name|instance
operator|->
name|Bl
operator|.
name|WN
operator|=
name|i
operator|>>
literal|6
expr_stmt|;
name|tow
operator|=
operator|(
name|buf
index|[
literal|7
operator|+
literal|4
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|buf
index|[
literal|7
operator|+
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
name|buf
index|[
literal|7
operator|+
literal|6
index|]
expr_stmt|;
name|tow
operator|>>=
literal|7
expr_stmt|;
name|tow
operator|=
name|tow
operator|&
literal|0377777
expr_stmt|;
name|tow
operator|<<=
literal|2
expr_stmt|;
name|instance
operator|->
name|Bl
operator|.
name|DN
operator|=
name|tow
operator|/
literal|57600L
operator|+
literal|1
expr_stmt|;
name|instance
operator|->
name|Bl
operator|.
name|wn_flg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|->
name|Bl
operator|.
name|wn_flg
operator|&&
name|instance
operator|->
name|Bl
operator|.
name|lsf_flg
condition|)
block|{
name|instance
operator|->
name|Bl
operator|.
name|wn_flg
operator|=
name|instance
operator|->
name|Bl
operator|.
name|lsf_flg
operator|=
literal|0
expr_stmt|;
name|oncore_cmd_Bl
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bl
argument_list|,
sizeof|sizeof
name|oncore_cmd_Bl
argument_list|)
expr_stmt|;
name|oncore_cmd_Bl
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|instance
operator|->
name|Bl
operator|.
name|WN
operator|&
literal|01400
expr_stmt|;
name|instance
operator|->
name|Bl
operator|.
name|WN_lsf
operator||=
name|i
expr_stmt|;
comment|/* have everything I need, doit */
name|i
operator|=
operator|(
name|instance
operator|->
name|Bl
operator|.
name|WN_lsf
operator|-
name|instance
operator|->
name|Bl
operator|.
name|WN
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
literal|1024
expr_stmt|;
name|day_now
operator|=
name|instance
operator|->
name|Bl
operator|.
name|DN
expr_stmt|;
name|day_lsf
operator|=
literal|7
operator|*
name|i
operator|+
name|instance
operator|->
name|Bl
operator|.
name|DN_lsf
expr_stmt|;
comment|/* ignore if in past or more than a month in future */
name|warn
operator|=
name|WARN_NOT_YET
expr_stmt|;
if|if
condition|(
name|day_lsf
operator|>=
name|day_now
operator|&&
name|day_lsf
operator|-
name|day_now
operator|<
literal|32
condition|)
block|{
comment|/* if< 28d, doit, if 28-31, ck day-of-month< 20 (not at end of prev month) */
if|if
condition|(
name|day_lsf
operator|-
name|day_now
operator|<
literal|28
operator|||
name|instance
operator|->
name|BEHa
index|[
literal|5
index|]
operator|<
literal|20
condition|)
block|{
name|i
operator|=
name|instance
operator|->
name|Bl
operator|.
name|dt_lsf
operator|-
name|instance
operator|->
name|Bl
operator|.
name|dt_ls
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|warn
operator|=
name|WARN_MINUS
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|warn
operator|=
name|WARN_0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|warn
operator|=
name|WARN_PLUS
expr_stmt|;
break|break;
block|}
block|}
block|}
switch|switch
condition|(
name|warn
condition|)
block|{
case|case
name|WARN_0
case|:
case|case
name|WARN_NOT_YET
case|:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_NOWARNING"
expr_stmt|;
break|break;
case|case
name|WARN_MINUS
case|:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_DELSECOND"
expr_stmt|;
break|break;
case|case
name|WARN_PLUS
case|:
name|instance
operator|->
name|peer
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set peer.leap to LEAP_ADDSECOND"
expr_stmt|;
break|break;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|=
name|instance
operator|->
name|Bl
operator|.
name|dt_lsf
operator|-
name|instance
operator|->
name|Bl
operator|.
name|dt_ls
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|j
operator|=
operator|(
name|i
operator|>=
literal|0
operator|)
condition|?
name|i
else|:
operator|-
name|i
expr_stmt|;
comment|/* abs(i) */
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"see Leap_Second (%c%d) in %d days"
argument_list|,
operator|(
operator|(
name|i
operator|>=
literal|0
operator|)
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|j
argument_list|,
name|day_lsf
operator|-
name|day_now
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
block|}
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"dt_ls = %d  dt_lsf = %d  WN = %d  DN = %d  WN_lsf = %d  DNlsf = %d  wn_flg = %d  lsf_flg = %d  Bl_day = %d"
argument_list|,
name|instance
operator|->
name|Bl
operator|.
name|dt_ls
argument_list|,
name|instance
operator|->
name|Bl
operator|.
name|dt_lsf
argument_list|,
name|instance
operator|->
name|Bl
operator|.
name|WN
argument_list|,
name|instance
operator|->
name|Bl
operator|.
name|DN
argument_list|,
name|instance
operator|->
name|Bl
operator|.
name|WN_lsf
argument_list|,
name|instance
operator|->
name|Bl
operator|.
name|DN_lsf
argument_list|,
name|instance
operator|->
name|Bl
operator|.
name|wn_flg
argument_list|,
name|instance
operator|->
name|Bl
operator|.
name|lsf_flg
argument_list|,
name|instance
operator|->
name|Bl
operator|.
name|Bl_day
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|oncore_msg_BnEnHn
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|long
name|dt1
decl_stmt|,
name|dt2
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|!=
name|ONCORE_RUN
condition|)
return|return;
if|if
condition|(
name|instance
operator|->
name|traim_delay
condition|)
block|{
comment|/* flag that @@Bn/@@En/Hn returned */
name|instance
operator|->
name|traim_ck
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|traim_delay
operator|=
literal|0
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"ONCORE: Detected TRAIM, TRAIM = ON"
argument_list|)
expr_stmt|;
name|oncore_set_traim
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|instance
operator|->
name|BEHn
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
comment|/* Bn or En or Hn */
if|if
condition|(
operator|!
name|instance
operator|->
name|traim
condition|)
comment|/* BnEnHn will be turned off in any case */
return|return;
comment|/* If Time RAIM doesn't like it, don't trust it */
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'H'
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|BEHn
index|[
literal|6
index|]
condition|)
block|{
comment|/* bad TRAIM */
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_WARNING
argument_list|,
literal|"BAD TRAIM"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dt1
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt this time step */
name|instance
operator|->
name|saw_tooth
operator|=
operator|(
name|s_char
operator|)
name|instance
operator|->
name|BEHn
index|[
literal|14
index|]
expr_stmt|;
comment|/* update for next time Hn[14] */
name|dt2
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt next time step */
block|}
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|BEHn
index|[
literal|21
index|]
condition|)
comment|/* bad TRAIM */
return|return;
name|dt1
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt this time step */
name|instance
operator|->
name|saw_tooth
operator|=
operator|(
name|s_char
operator|)
name|instance
operator|->
name|BEHn
index|[
literal|25
index|]
expr_stmt|;
comment|/* update for next time Bn[25], En[25] */
name|dt2
operator|=
name|instance
operator|->
name|saw_tooth
operator|+
name|instance
operator|->
name|offset
expr_stmt|;
comment|/* dt next time step */
block|}
name|oncore_get_timestamp
argument_list|(
name|instance
argument_list|,
name|dt1
argument_list|,
name|dt2
argument_list|)
expr_stmt|;
block|}
comment|/* Here for @@Ca, @@Fa and @@Ia messages */
comment|/* These are Self test Commands for 6, 8, and 12 chan receivers.  * There are good reasons NOT to do a @@Ca, @@Fa or @@Ia command with the ONCORE.  * It was found that under some circumstances the following  * command would fail if issued immediately after the return from the  * @@Fa, but a 2sec delay seemed to fix things.  Since simply calling  * sleep(2) is wasteful, and may cause trouble for some OS's, repeating  * itimer, we set a flag, and test it at the next POLL.  If it hasn't  * been cleared, we reissue the @@Cj that is issued below.  * Note that we do a @@Cj at the beginning, and again here.  * The first is to get the info, the 2nd is just used as a safe command  * after the @@Fa for all Oncores (and it was in this posn in the  * original code).  */
specifier|static
name|void
name|oncore_msg_CaFaIa
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_TEST_SENT
condition|)
block|{
name|enum
name|antenna_state
name|antenna
decl_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|ONCORE_VERBOSE_SELF_TEST
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'I'
condition|)
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|">>@@%ca %x %x %x"
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
name|buf
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|">>@@%ca %x %x"
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|antenna
operator|=
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|&=
operator|~
literal|0xc0
expr_stmt|;
name|i
operator|=
name|buf
index|[
literal|4
index|]
operator|||
name|buf
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'I'
condition|)
name|i
operator|=
name|i
operator|||
name|buf
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'I'
condition|)
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"self test failed: result %02x %02x %02x"
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
name|buf
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"self test failed: result %02x %02x"
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"ONCORE: self test failed, shutting down driver"
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|instance
operator|->
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|oncore_shutdown
argument_list|(
name|instance
operator|->
name|unit
argument_list|,
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* report the current antenna state */
name|oncore_antenna_report
argument_list|(
name|instance
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_INIT
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_INIT"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|4
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Demultiplex the almanac into shmem  */
specifier|static
name|void
name|oncore_msg_Cb
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|5
operator|&&
name|buf
index|[
literal|5
index|]
operator|>
literal|0
operator|&&
name|buf
index|[
literal|5
index|]
operator|<
literal|26
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|<=
literal|5
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
operator|+
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|<=
literal|10
condition|)
name|i
operator|=
name|buf
index|[
literal|5
index|]
operator|+
literal|23
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|==
literal|4
operator|&&
name|buf
index|[
literal|5
index|]
operator|==
literal|25
condition|)
name|i
operator|=
literal|34
expr_stmt|;
else|else
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"Cb: Response is NO ALMANAC"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|*=
literal|36
expr_stmt|;
name|instance
operator|->
name|shmem
index|[
name|instance
operator|->
name|shmem_Cb
operator|+
name|i
operator|+
literal|2
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|instance
operator|->
name|shmem
operator|+
name|instance
operator|->
name|shmem_Cb
operator|+
name|i
operator|+
literal|3
argument_list|,
name|buf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|len
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_MSG_CB
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"See Cb [%d,%d]"
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/*  * Set to Factory Defaults (Reasonable for UT w/ no Battery Backup  *	not so for VP (eeprom) or any unit with a battery  */
specifier|static
name|void
name|oncore_msg_Cf
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_RESET_SENT
condition|)
block|{
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Cg
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return to  Posn Fix mode */
comment|/* Reset set VP to IDLE */
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_TEST_SENT
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_TEST_SENT"
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Cj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * This is the Grand Central Station for the Preliminary Initialization.  * Once done here we move on to oncore_msg_BaEaHa for final Initialization and Running.  *  * We do an @@Cj whenever we need a safe command for all Oncores.  * The @@Cj gets us back here where we can switch to the next phase of setup.  *  * o Once at the very beginning (in start) to get the Model number.  *   This info is printed, but no longer used.  * o Again after we have determined the number of Channels in the receiver.  * o And once later after we have done a reset and test, (which may hang),  *   as we are about to initialize the Oncore and start it running.  * o We have one routine below for each case.  */
specifier|static
name|void
name|oncore_msg_Cj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|memcpy
argument_list|(
name|instance
operator|->
name|Cj
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|instance
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_CHECK_ID
condition|)
block|{
name|oncore_msg_Cj_id
argument_list|(
name|instance
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|oncore_chan_test
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_HAVE_CHAN
condition|)
block|{
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|3
operator|||
name|mode
operator|==
literal|4
condition|)
block|{
comment|/* Cf will return here to check for TEST */
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_RESET_SENT
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_RESET_SENT"
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Cf
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_TEST_SENT
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_TEST_SENT"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_TEST_SENT
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ca
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ca
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Fa
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Fa
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ia
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ia
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|o_state
operator|==
name|ONCORE_INIT
condition|)
name|oncore_msg_Cj_init
argument_list|(
name|instance
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* The information on determining a Oncore 'Model', viz VP, UT, etc, from  *	the Model Number comes from "Richard M. Hambly"<rick@cnssys.com>  *	and from Motorola.  Until recently Rick was the only source of  *	this information as Motorola didn't give the information out.  *  * Determine the Type from the Model #, this determines #chan and if TRAIM is  *   available.  *  * The Information from this routine is NO LONGER USED.  * The RESULTS are PRINTED, BUT NOT USED, and the routine COULD BE DELETED  */
specifier|static
name|void
name|oncore_msg_Cj_id
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
name|Model
index|[
literal|21
index|]
decl_stmt|,
name|Msg
index|[
literal|160
index|]
decl_stmt|;
comment|/* Write Receiver ID message to clockstats file */
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|instance
operator|->
name|Cj
init|;
name|cp
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
condition|;
control|)
block|{
name|cp1
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp1
condition|)
name|cp1
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|294
index|]
expr_stmt|;
operator|*
name|cp1
operator|=
literal|'\0'
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|=
literal|'\r'
expr_stmt|;
name|cp
operator|=
name|cp1
operator|+
literal|2
expr_stmt|;
block|}
comment|/* next, the Firmware Version and Revision numbers */
name|instance
operator|->
name|version
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|83
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|revision
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|111
index|]
argument_list|)
expr_stmt|;
comment|/* from model number decide which Oncore this is, 		and then the number of channels */
for|for
control|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|instance
operator|->
name|Cj
index|[
literal|160
index|]
init|;
operator|*
name|cp
operator|==
literal|' '
condition|;
name|cp
operator|++
control|)
comment|/* start right after 'Model #' */
empty_stmt|;
name|cp1
operator|=
name|cp
expr_stmt|;
name|cp2
operator|=
name|Model
expr_stmt|;
for|for
control|(
init|;
operator|!
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
name|cp
operator|-
name|cp1
operator|<
literal|20
condition|;
name|cp
operator|++
operator|,
name|cp2
operator|++
control|)
operator|*
name|cp2
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|Model
argument_list|,
literal|"PVT6"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
block|{
name|cp
operator|=
literal|"PVT6"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_PVT6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'A'
condition|)
block|{
name|cp
operator|=
literal|"Basic"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_BASIC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'B'
operator|||
operator|!
name|strncmp
argument_list|(
name|Model
argument_list|,
literal|"T8"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
condition|)
block|{
name|cp
operator|=
literal|"VP"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_VP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
name|cp
operator|=
literal|"M12"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_M12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|0
index|]
operator|==
literal|'R'
operator|||
name|Model
index|[
literal|0
index|]
operator|==
literal|'D'
operator|||
name|Model
index|[
literal|0
index|]
operator|==
literal|'S'
condition|)
block|{
if|if
condition|(
name|Model
index|[
literal|5
index|]
operator|==
literal|'N'
condition|)
block|{
name|cp
operator|=
literal|"GT"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_GT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'3'
operator|||
name|Model
index|[
literal|1
index|]
operator|==
literal|'4'
operator|)
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'G'
condition|)
block|{
name|cp
operator|=
literal|"GT+"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_GTPLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'5'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'U'
operator|)
operator|||
operator|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'1'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'A'
operator|)
condition|)
block|{
name|cp
operator|=
literal|"UT"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'5'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'G'
condition|)
block|{
name|cp
operator|=
literal|"UT+"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UTPLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Model
index|[
literal|1
index|]
operator|==
literal|'6'
operator|&&
name|Model
index|[
literal|5
index|]
operator|==
literal|'G'
condition|)
block|{
name|cp
operator|=
literal|"SL"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_SL
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
literal|"Unknown"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UNKNOWN
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp
operator|=
literal|"Unknown"
expr_stmt|;
name|instance
operator|->
name|model
operator|=
name|ONCORE_UNKNOWN
expr_stmt|;
block|}
comment|/* use MODEL to set CHAN and TRAIM and possibly zero SHMEM */
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"This looks like an Oncore %s with version %d.%d firmware."
argument_list|,
name|cp
argument_list|,
name|instance
operator|->
name|version
argument_list|,
name|instance
operator|->
name|revision
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|instance
operator|->
name|chan_id
operator|=
literal|8
expr_stmt|;
comment|/* default */
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_BASIC
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_PVT6
condition|)
name|instance
operator|->
name|chan_id
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_VP
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UT
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UTPLUS
condition|)
name|instance
operator|->
name|chan_id
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_M12
condition|)
name|instance
operator|->
name|chan_id
operator|=
literal|12
expr_stmt|;
name|instance
operator|->
name|traim_id
operator|=
literal|0
expr_stmt|;
comment|/* default */
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_BASIC
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_PVT6
condition|)
name|instance
operator|->
name|traim_id
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_VP
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UT
operator|||
name|instance
operator|->
name|model
operator|==
name|ONCORE_UTPLUS
condition|)
name|instance
operator|->
name|traim_id
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|model
operator|==
name|ONCORE_M12
condition|)
name|instance
operator|->
name|traim_id
operator|=
operator|-
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Channels = %d, TRAIM = %s"
argument_list|,
name|instance
operator|->
name|chan_id
argument_list|,
operator|(
operator|(
name|instance
operator|->
name|traim_id
operator|<
literal|0
operator|)
condition|?
literal|"UNKNOWN"
else|:
operator|(
name|instance
operator|->
name|traim_id
operator|>
literal|0
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
operator|)
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/* OK, know type of Oncore, have possibly reset it, and have tested it.  * We know the number of channels.  * We will determine whether we have TRAIM before we actually start.  * Now initialize.  */
specifier|static
name|void
name|oncore_msg_Cj_init
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|u_char
name|Cmd
index|[
literal|20
index|]
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* The M12 with 1.3 or 2.0 Firmware, loses track of all Satellites and has to 	 * start again if we go from 0D -> 3D, then loses them again when we 	 * go from 3D -> 0D.  We do this to get a @@Ea message for SHMEM. 	 * For NOW we will turn this aspect of filling SHMEM off for the M12 	 */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|instance
operator|->
name|shmem_bad_Ea
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"*** SHMEM partially enabled for ONCORE M12 s/w v%d.%d ***"
argument_list|,
name|instance
operator|->
name|version
argument_list|,
name|instance
operator|->
name|revision
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Cg
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Cg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return to  Posn Fix mode */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bb
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* turn on for shmem (6/8/12) */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ek
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ek
argument_list|)
argument_list|)
expr_stmt|;
comment|/* turn off (VP) */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Aw
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Aw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* UTC time (6/8/12) */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_AB
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_AB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Appl type static (VP) */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Be
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Be
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell us the Almanac for shmem (6/8/12) */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell us when Almanac changes */
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
comment|/* If there is Position input in the Config file 	 * and mode = (1,3) set it as posn hold posn, goto 0D mode. 	 *  or mode = (2,4) set it as INITIAL position, and do Site Survey. 	 */
if|if
condition|(
name|instance
operator|->
name|posn_set
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
literal|"Setting Posn from input data"
argument_list|)
expr_stmt|;
name|oncore_set_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* this should print posn indirectly thru the As cmd */
block|}
elseif|else
comment|/* must issue an @@At here to check on 6/8 Position Hold, set_posn would have */
if|if
condition|(
name|instance
operator|->
name|chan
operator|!=
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Atx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Atx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|0
condition|)
block|{
comment|/* cable delay in ns */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Az
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Az
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
name|instance
operator|->
name|delay
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Az
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 6,8,12 */
comment|/* PPS offset in ns */
if|if
condition|(
name|instance
operator|->
name|offset
condition|)
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ay
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ay
argument_list|)
argument_list|)
expr_stmt|;
comment|/* some have it, some don't */
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
name|instance
operator|->
name|offset
argument_list|)
expr_stmt|;
comment|/* will check for hw response */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ay
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Satellite mask angle */
if|if
condition|(
name|instance
operator|->
name|Ag
operator|!=
literal|0xff
condition|)
block|{
comment|/* will have 0xff in it if not set by user */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ag
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ag
argument_list|)
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
operator|=
name|instance
operator|->
name|Ag
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ag
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 6, 8 12 chan - Position/Status/Data Output Message, 1/s 	 * now we're really running 	 * these were ALL started in the chan test, 	 * However, if we had mode=3,4 then commands got turned off, so we turn 	 * them on again here just in case 	 */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
block|{
comment|/* start 6chan, kill 8,12chan commands, possibly testing VP in 6chan mode */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ea0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_En0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_En0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ha0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ha0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Hn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Hn0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ba
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
comment|/* start 8chan, kill 6,12chan commands */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ba0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bn0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ha0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ha0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Hn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Hn0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ea
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
comment|/* start 12chan, kill 6,12chan commands */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ba0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bn0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ea0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_En0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_En0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ha
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ha
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|instance
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_ALMANAC
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_ALMANAC"
argument_list|)
expr_stmt|;
block|}
comment|/* 12chan position */
specifier|static
name|void
name|oncore_msg_Ga
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|long
name|lat
decl_stmt|,
name|lon
decl_stmt|,
name|ht
decl_stmt|;
name|double
name|Lat
decl_stmt|,
name|Lon
decl_stmt|,
name|Ht
decl_stmt|;
name|lat
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|lon
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|ht
operator|=
name|buf_w32
argument_list|(
operator|&
name|buf
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
comment|/* GPS ellipsoid */
name|Lat
operator|=
name|lat
expr_stmt|;
name|Lon
operator|=
name|lon
expr_stmt|;
name|Ht
operator|=
name|ht
expr_stmt|;
name|Lat
operator|/=
literal|3600000
expr_stmt|;
name|Lon
operator|/=
literal|3600000
expr_stmt|;
name|Ht
operator|/=
literal|100
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Ga Posn Lat = %.7f, Lon = %.7f, Ht  = %.2f"
argument_list|,
name|Lat
argument_list|,
name|Lon
argument_list|,
name|Ht
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_lat
operator|=
name|lat
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|=
name|lon
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
name|ht
expr_stmt|;
name|oncore_print_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
comment|/* 12 chan time/date */
specifier|static
name|void
name|oncore_msg_Gb
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|,
modifier|*
name|gmts
decl_stmt|;
name|int
name|mo
decl_stmt|,
name|d
decl_stmt|,
name|y
decl_stmt|,
name|h
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|,
name|gmth
decl_stmt|,
name|gmtm
decl_stmt|;
name|mo
operator|=
name|buf
index|[
literal|4
index|]
expr_stmt|;
name|d
operator|=
name|buf
index|[
literal|5
index|]
expr_stmt|;
name|y
operator|=
literal|256
operator|*
name|buf
index|[
literal|6
index|]
operator|+
name|buf
index|[
literal|7
index|]
expr_stmt|;
name|h
operator|=
name|buf
index|[
literal|8
index|]
expr_stmt|;
name|m
operator|=
name|buf
index|[
literal|9
index|]
expr_stmt|;
name|s
operator|=
name|buf
index|[
literal|10
index|]
expr_stmt|;
name|gmts
operator|=
operator|(
operator|(
name|buf
index|[
literal|11
index|]
operator|==
literal|0
operator|)
condition|?
literal|"+"
else|:
literal|"-"
operator|)
expr_stmt|;
name|gmth
operator|=
name|buf
index|[
literal|12
index|]
expr_stmt|;
name|gmtm
operator|=
name|buf
index|[
literal|13
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Date/Time set to: %d%s%d %2d:%02d:%02d GMT (GMT offset is %s%02d:%02d)"
argument_list|,
name|d
argument_list|,
name|Month
index|[
name|mo
operator|-
literal|1
index|]
argument_list|,
name|y
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|gmts
argument_list|,
name|gmth
argument_list|,
name|gmtm
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/* Leap Second for M12, gives all info from satellite message */
comment|/* also in UT v3.0 */
specifier|static
name|void
name|oncore_msg_Gj
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|dt
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|instance
operator|->
name|saw_Gj
operator|=
literal|1
expr_stmt|;
comment|/* flag, saw_Gj, dont need to try Bj in check_leap */
comment|/* print the message to verify whats there */
name|dt
operator|=
name|buf
index|[
literal|5
index|]
operator|-
name|buf
index|[
literal|4
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Leap Sec Msg: %d %d %d %d %d %d %d %d %d %d"
argument_list|,
name|buf
index|[
literal|4
index|]
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|,
literal|256
operator|*
name|buf
index|[
literal|6
index|]
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|8
index|]
argument_list|,
name|buf
index|[
literal|9
index|]
argument_list|,
name|buf
index|[
literal|10
index|]
argument_list|,
operator|(
name|buf
index|[
literal|14
index|]
operator|+
literal|256
operator|*
operator|(
name|buf
index|[
literal|13
index|]
operator|+
literal|256
operator|*
operator|(
name|buf
index|[
literal|12
index|]
operator|+
literal|256
operator|*
name|buf
index|[
literal|11
index|]
operator|)
operator|)
operator|)
argument_list|,
name|buf
index|[
literal|15
index|]
argument_list|,
name|buf
index|[
literal|16
index|]
argument_list|,
name|buf
index|[
literal|17
index|]
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Leap second (%d) scheduled for %d%s%d at %d:%d:%d"
argument_list|,
name|dt
argument_list|,
name|buf
index|[
literal|9
index|]
argument_list|,
name|Month
index|[
name|buf
index|[
literal|8
index|]
operator|-
literal|1
index|]
argument_list|,
literal|256
operator|*
name|buf
index|[
literal|6
index|]
operator|+
name|buf
index|[
literal|7
index|]
argument_list|,
name|buf
index|[
literal|15
index|]
argument_list|,
name|buf
index|[
literal|16
index|]
argument_list|,
name|buf
index|[
literal|17
index|]
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/* Only raise warning within a month of the leap second */
name|instance
operator|->
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|cp
operator|=
literal|"Set pp.leap to LEAP_NOWARNING"
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|6
index|]
operator|==
name|instance
operator|->
name|BEHa
index|[
literal|6
index|]
operator|&&
name|buf
index|[
literal|7
index|]
operator|==
name|instance
operator|->
name|BEHa
index|[
literal|7
index|]
operator|&&
comment|/* year */
name|buf
index|[
literal|8
index|]
operator|==
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
condition|)
block|{
comment|/* month */
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
name|dt
operator|<
literal|0
condition|)
block|{
name|instance
operator|->
name|pp
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set pp.leap to LEAP_DELSECOND"
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|->
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|cp
operator|=
literal|"Set pp.leap to LEAP_ADDSECOND"
expr_stmt|;
block|}
block|}
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* Power on failure */
specifier|static
name|void
name|oncore_msg_Sz
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|&&
name|instance
operator|->
name|peer
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_ERR
argument_list|,
literal|"Oncore: System Failure at Power On"
argument_list|)
expr_stmt|;
name|oncore_shutdown
argument_list|(
name|instance
operator|->
name|unit
argument_list|,
name|instance
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/************** Small Subroutines ***************/
specifier|static
name|void
name|oncore_antenna_report
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|enum
name|antenna_state
name|new_state
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|ant_state
operator|==
name|new_state
condition|)
return|return;
switch|switch
condition|(
name|new_state
condition|)
block|{
case|case
name|ONCORE_ANTENNA_OK
case|:
name|cp
operator|=
literal|"GPS antenna: OK"
expr_stmt|;
break|break;
case|case
name|ONCORE_ANTENNA_OC
case|:
name|cp
operator|=
literal|"GPS antenna: short (overcurrent)"
expr_stmt|;
break|break;
case|case
name|ONCORE_ANTENNA_UC
case|:
name|cp
operator|=
literal|"GPS antenna: open (not connected)"
expr_stmt|;
break|break;
case|case
name|ONCORE_ANTENNA_NV
case|:
name|cp
operator|=
literal|"GPS antenna: short (no voltage)"
expr_stmt|;
break|break;
default|default:
name|cp
operator|=
literal|"GPS antenna: ?"
expr_stmt|;
break|break;
block|}
name|instance
operator|->
name|ant_state
operator|=
name|new_state
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|oncore_chan_test
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
comment|/* subroutine oncore_Cj_id has determined the number of channels from the 	 * model number of the attached oncore.  This is not always correct since 	 * the oncore could have non-standard firmware.  Here we check (independently) by 	 * trying a 6, 8, and 12 chan command, and see which responds. 	 * Caution: more than one CAN respond. 	 * 	 * This #chan is used by the code rather than that calculated from the model number. 	 */
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_CHECK_CHAN
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_CHECK_CHAN"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|count3
operator|=
literal|1
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ba
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ba
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ea
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ea
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ha
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ha
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check for a GOOD Almanac, have we got one yet? */
specifier|static
name|void
name|oncore_check_almanac
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
block|{
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x1
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|64
index|]
operator|&
literal|0x52
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
block|{
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x1
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|72
index|]
operator|&
literal|0x52
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|int
name|bits1
decl_stmt|,
name|bits2
decl_stmt|,
name|bits3
decl_stmt|;
name|bits1
operator|=
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|129
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
comment|/* actually Ha */
name|bits2
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
operator|=
operator|(
name|bits2
operator|&
literal|0x80
operator|)
expr_stmt|;
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
operator|=
operator|(
name|bits2
operator|&
literal|0x8
operator|)
operator|||
operator|(
name|bits1
operator|==
literal|0x2
operator|)
expr_stmt|;
comment|/* too few sat     Bad Geom	  */
name|bits3
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|141
index|]
expr_stmt|;
comment|/* UTC parameters */
if|if
condition|(
operator|!
name|instance
operator|->
name|count5_set
operator|&&
operator|(
name|bits3
operator|&
literal|0xC0
operator|)
condition|)
block|{
name|instance
operator|->
name|count5
operator|=
literal|2
expr_stmt|;
name|instance
operator|->
name|count5_set
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_CHECK_ALMANAC
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"DEBUG BITS: (%x %x), (%x %x %x),  %x %x %x %x %x"
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|129
index|]
argument_list|,
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
argument_list|,
name|bits1
argument_list|,
name|bits2
argument_list|,
name|bits3
argument_list|,
name|instance
operator|->
name|mode
operator|==
name|MODE_0D
argument_list|,
name|instance
operator|->
name|mode
operator|==
name|MODE_2D
argument_list|,
name|instance
operator|->
name|mode
operator|==
name|MODE_3D
argument_list|,
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
argument_list|,
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
comment|/* check the antenna for changes (did it get unplugged?) */
specifier|static
name|void
name|oncore_check_antenna
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|enum
name|antenna_state
name|antenna
decl_stmt|;
comment|/* antenna state */
name|antenna
operator|=
name|instance
operator|->
name|ant_state
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|antenna
operator|=
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
operator|&
literal|0x6
operator|)
operator|>>
literal|1
expr_stmt|;
else|else
name|antenna
operator|=
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|37
index|]
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
expr_stmt|;
comment|/* prob unset 6, set GT, UT unset VP */
name|oncore_antenna_report
argument_list|(
name|instance
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
block|}
comment|/*  * Check the leap second status once per day.  *  * Note that the ONCORE firmware for the Bj command is wrong at  * least in the VP.  * It starts advertising a LEAP SECOND as soon as the GPS satellite  * data message (page 18, subframe 4) is updated to a date in the  * future, and does not wait for the month that it will occur.  * The event will usually be advertised several months in advance.  * Since there is a one bit flag, there is no way to tell if it is  * this month, or when...  *  * As such, we have the workaround below, of only checking for leap  * seconds with the Bj command in June/December.  *  * The Gj command gives more information, and we can tell in which  * month to apply the correction.  *  * Note that with the VP we COULD read the raw data message, and  * interpret it ourselves, but since this is specific to this receiver  * only, and the above workaround is adequate, we don't bother.  */
specifier|static
name|void
name|oncore_check_leap_sec
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|oncore_cmd_Bl
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
comment|/* just to be sure */
if|if
condition|(
name|instance
operator|->
name|Bj_day
operator|!=
name|instance
operator|->
name|BEHa
index|[
literal|5
index|]
condition|)
block|{
comment|/* do this 1/day */
name|instance
operator|->
name|Bj_day
operator|=
name|instance
operator|->
name|BEHa
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|saw_Gj
operator|<
literal|0
condition|)
block|{
comment|/* -1 DONT have Gj use Bj */
if|if
condition|(
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
operator|==
literal|6
operator|)
operator|||
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
operator|==
literal|12
operator|)
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bj
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bl
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|instance
operator|->
name|saw_Gj
operator|==
literal|0
condition|)
comment|/* 0 is dont know if we have Gj */
name|instance
operator|->
name|count4
operator|=
literal|1
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gj
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Gj works for some 6/8 chan UT and the M12	  */
comment|/* if no response from Gj in 5 sec, we try Bj	  */
comment|/* which isnt implemented in all the GT/UT either */
if|if
condition|(
name|instance
operator|->
name|count4
condition|)
block|{
comment|/* delay, waiting for Gj response */
if|if
condition|(
name|instance
operator|->
name|saw_Gj
operator|==
literal|1
condition|)
name|instance
operator|->
name|count4
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|count4
operator|++
operator|>
literal|5
condition|)
block|{
comment|/* delay, waiting for Gj response */
name|instance
operator|->
name|saw_Gj
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* didnt see it, will use Bj */
name|instance
operator|->
name|count4
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
operator|==
literal|6
operator|)
operator|||
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|4
index|]
operator|==
literal|12
operator|)
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bj
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bj
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bl
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* check the message checksum,  *  buf points to START of message ( @@ )  *  len is length WITH CR/LF.  */
specifier|static
name|int
name|oncore_checksum_ok
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|len
operator|-
literal|3
condition|;
name|i
operator|++
control|)
name|j
operator|^=
name|buf
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|j
operator|==
name|buf
index|[
name|len
operator|-
literal|3
index|]
operator|)
return|;
block|}
specifier|static
name|void
name|oncore_compute_dH
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|GPS
decl_stmt|,
name|MSL
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
comment|/* Here calculate dH = GPS - MSL for output message */
comment|/* also set Altitude Hold mode if GT */
name|instance
operator|->
name|have_dH
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|GPS
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|39
index|]
argument_list|)
expr_stmt|;
name|MSL
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|43
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GPS
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|23
index|]
argument_list|)
expr_stmt|;
name|MSL
operator|=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|27
index|]
argument_list|)
expr_stmt|;
block|}
name|instance
operator|->
name|dH
operator|=
name|GPS
operator|-
name|MSL
expr_stmt|;
name|instance
operator|->
name|dH
operator|/=
literal|100.
expr_stmt|;
comment|/* if MSL is not set, the calculation is meaningless */
if|if
condition|(
name|MSL
condition|)
block|{
comment|/* not set ! */
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"dH = (GPS - MSL) = %.2fm"
argument_list|,
name|instance
operator|->
name|dH
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * try loading Almanac from shmem (where it was copied from shmem_old  */
specifier|static
name|void
name|oncore_load_almanac
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|,
name|Cmd
index|[
literal|20
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|shmem
condition|)
return|return;
ifndef|#
directive|ifndef
name|ONCORE_VERBOSE_LOAD_ALMANAC
for|for
control|(
name|cp
operator|=
name|instance
operator|->
name|shmem
operator|+
literal|4
init|;
operator|(
name|n
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp
operator|-
literal|2
operator|)
operator|)
condition|;
name|cp
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"@@Cb"
argument_list|,
literal|4
argument_list|)
operator|&&
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|33
argument_list|)
operator|&&
operator|(
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
operator|==
literal|4
operator|||
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
operator|==
literal|5
operator|)
condition|)
block|{
name|write
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|oncore_print_Cb
argument_list|(
name|instance
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* ONCORE_VERBOSE_LOAD_ALMANAC follows */
for|for
control|(
name|cp
operator|=
name|instance
operator|->
name|shmem
operator|+
literal|4
init|;
operator|(
name|n
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp
operator|-
literal|2
operator|)
operator|)
condition|;
name|cp
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
control|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"See %c%c%c%c %d"
argument_list|,
operator|*
operator|(
name|cp
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"@@Cb"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|oncore_print_Cb
argument_list|(
name|instance
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|33
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
operator|==
literal|4
operator|||
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
operator|==
literal|5
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"GOOD SF"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|instance
operator|->
name|ttyfd
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"BAD SF"
argument_list|)
expr_stmt|;
block|}
else|else
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"BAD CHECKSUM"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Must load position and time or the Almanac doesn't do us any good */
if|if
condition|(
operator|!
name|instance
operator|->
name|posn_set
condition|)
block|{
comment|/* if we input a posn use it, else from SHMEM */
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"Loading Posn from SHMEM"
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|instance
operator|->
name|shmem
operator|+
literal|4
init|;
operator|(
name|n
operator|=
literal|256
operator|*
operator|(
operator|*
operator|(
name|cp
operator|-
literal|3
operator|)
operator|)
operator|+
operator|*
operator|(
name|cp
operator|-
literal|2
operator|)
operator|)
condition|;
name|cp
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
control|)
block|{
if|if
condition|(
operator|(
name|instance
operator|->
name|chan
operator|==
literal|6
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"@@Ba"
argument_list|,
literal|4
argument_list|)
operator|&&
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|68
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|instance
operator|->
name|chan
operator|==
literal|8
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"@@Ea"
argument_list|,
literal|4
argument_list|)
operator|&&
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|76
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|instance
operator|->
name|chan
operator|==
literal|12
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"@@Ha"
argument_list|,
literal|4
argument_list|)
operator|&&
name|oncore_checksum_ok
argument_list|(
name|cp
argument_list|,
literal|154
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|kk
decl_stmt|;
name|instance
operator|->
name|posn_set
operator|=
literal|1
expr_stmt|;
name|ii
operator|=
name|buf_w32
argument_list|(
name|cp
operator|+
literal|15
argument_list|)
expr_stmt|;
name|jj
operator|=
name|buf_w32
argument_list|(
name|cp
operator|+
literal|19
argument_list|)
expr_stmt|;
name|kk
operator|=
name|buf_w32
argument_list|(
name|cp
operator|+
literal|23
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_LOAD_ALMANAC
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"SHMEM posn = %ld (%d, %d, %d)"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cp
operator|-
name|instance
operator|->
name|shmem
argument_list|)
argument_list|,
name|ii
argument_list|,
name|jj
argument_list|,
name|kk
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ii
operator|!=
literal|0
operator|||
name|jj
operator|!=
literal|0
operator|||
name|kk
operator|!=
literal|0
condition|)
block|{
comment|/* phk asked for this test */
name|instance
operator|->
name|ss_lat
operator|=
name|ii
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|=
name|jj
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|=
name|kk
expr_stmt|;
block|}
block|}
block|}
block|}
name|oncore_set_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* and set time to time from Computer clock */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|(
specifier|const
name|time_t
operator|*
operator|)
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_LOAD_ALMANAC
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"DATE %d %d %d, %d %d %d"
argument_list|,
literal|1900
operator|+
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_mon
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Gb
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gb
argument_list|)
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
operator|=
name|tm
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|5
index|]
operator|=
name|tm
operator|->
name|tm_mday
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|6
index|]
operator|=
operator|(
literal|1900
operator|+
name|tm
operator|->
name|tm_year
operator|)
operator|/
literal|256
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|7
index|]
operator|=
operator|(
literal|1900
operator|+
name|tm
operator|->
name|tm_year
operator|)
operator|%
literal|256
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
operator|=
name|tm
operator|->
name|tm_hour
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|9
index|]
operator|=
name|tm
operator|->
name|tm_min
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|10
index|]
operator|=
name|tm
operator|->
name|tm_sec
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|11
index|]
operator|=
literal|0
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|12
index|]
operator|=
literal|0
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|13
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gb
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First set GMT offset to zero */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ab
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ab
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ac
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ac
argument_list|)
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
operator|=
name|tm
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|5
index|]
operator|=
name|tm
operator|->
name|tm_mday
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|6
index|]
operator|=
operator|(
literal|1900
operator|+
name|tm
operator|->
name|tm_year
operator|)
operator|/
literal|256
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|7
index|]
operator|=
operator|(
literal|1900
operator|+
name|tm
operator|->
name|tm_year
operator|)
operator|%
literal|256
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ac
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Aa
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Aa
argument_list|)
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
operator|=
name|tm
operator|->
name|tm_hour
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|5
index|]
operator|=
name|tm
operator|->
name|tm_min
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|6
index|]
operator|=
name|tm
operator|->
name|tm_sec
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Aa
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
literal|"Setting Posn and Time after Loading Almanac"
argument_list|)
expr_stmt|;
block|}
comment|/* Almanac data input */
specifier|static
name|void
name|oncore_print_Cb
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_CB
name|int
name|ii
decl_stmt|;
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|,
name|Msg2
index|[
literal|10
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"DEBUG: See: %c%c%c%c"
argument_list|,
operator|*
operator|(
name|cp
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"DEBUG: Cb: [%d,%d]"
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|5
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|33
condition|;
name|ii
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg2
argument_list|)
argument_list|,
literal|" %d"
argument_list|,
operator|*
operator|(
name|cp
operator|+
name|ii
operator|)
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|Msg
argument_list|,
name|Msg2
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Debug: Cb: [%d,%d]"
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|4
operator|)
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|5
operator|)
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
block|static void oncore_print_array( 	u_char *cp, 	int	n 	) { 	int	jj, i, j, nn;  	nn = 0; 	printf("\nTOP\n"); 	jj = n/16; 	for (j=0; j<jj; j++) { 		printf("%4d: ", nn); 		nn += 16; 		for (i=0; i<16; i++) 			printf(" %o", *cp++); 		printf("\n"); 	} }
endif|#
directive|endif
specifier|static
name|void
name|oncore_print_posn
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|,
name|ew
decl_stmt|,
name|ns
decl_stmt|;
name|double
name|xd
decl_stmt|,
name|xm
decl_stmt|,
name|xs
decl_stmt|,
name|yd
decl_stmt|,
name|ym
decl_stmt|,
name|ys
decl_stmt|,
name|hm
decl_stmt|,
name|hft
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|idy
decl_stmt|,
name|is
decl_stmt|,
name|imx
decl_stmt|,
name|imy
decl_stmt|;
name|long
name|lat
decl_stmt|,
name|lon
decl_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
literal|"Posn:"
argument_list|)
expr_stmt|;
name|ew
operator|=
literal|'E'
expr_stmt|;
name|lon
operator|=
name|instance
operator|->
name|ss_long
expr_stmt|;
if|if
condition|(
name|lon
operator|<
literal|0
condition|)
block|{
name|ew
operator|=
literal|'W'
expr_stmt|;
name|lon
operator|=
operator|-
name|lon
expr_stmt|;
block|}
name|ns
operator|=
literal|'N'
expr_stmt|;
name|lat
operator|=
name|instance
operator|->
name|ss_lat
expr_stmt|;
if|if
condition|(
name|lat
operator|<
literal|0
condition|)
block|{
name|ns
operator|=
literal|'S'
expr_stmt|;
name|lat
operator|=
operator|-
name|lat
expr_stmt|;
block|}
name|hm
operator|=
name|instance
operator|->
name|ss_ht
operator|/
literal|100.
expr_stmt|;
name|hft
operator|=
name|hm
operator|/
literal|0.3048
expr_stmt|;
name|xd
operator|=
name|lat
operator|/
literal|3600000.
expr_stmt|;
comment|/* lat, lon in int msec arc, ht in cm. */
name|yd
operator|=
name|lon
operator|/
literal|3600000.
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Lat = %c %11.7fdeg,    Long = %c %11.7fdeg,    Alt = %5.2fm (%5.2fft) GPS"
argument_list|,
name|ns
argument_list|,
name|xd
argument_list|,
name|ew
argument_list|,
name|yd
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|idx
operator|=
name|xd
expr_stmt|;
name|idy
operator|=
name|yd
expr_stmt|;
name|imx
operator|=
name|lat
operator|%
literal|3600000
expr_stmt|;
name|imy
operator|=
name|lon
operator|%
literal|3600000
expr_stmt|;
name|xm
operator|=
name|imx
operator|/
literal|60000.
expr_stmt|;
name|ym
operator|=
name|imy
operator|/
literal|60000.
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Lat = %c %3ddeg %7.4fm,   Long = %c %3ddeg %8.5fm,  Alt = %7.2fm (%7.2fft) GPS"
argument_list|,
name|ns
argument_list|,
name|idx
argument_list|,
name|xm
argument_list|,
name|ew
argument_list|,
name|idy
argument_list|,
name|ym
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|imx
operator|=
name|xm
expr_stmt|;
name|imy
operator|=
name|ym
expr_stmt|;
name|is
operator|=
name|lat
operator|%
literal|60000
expr_stmt|;
name|xs
operator|=
name|is
operator|/
literal|1000.
expr_stmt|;
name|is
operator|=
name|lon
operator|%
literal|60000
expr_stmt|;
name|ys
operator|=
name|is
operator|/
literal|1000.
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Lat = %c %3ddeg %2dm %5.2fs, Long = %c %3ddeg %2dm %5.2fs, Alt = %7.2fm (%7.2fft) GPS"
argument_list|,
name|ns
argument_list|,
name|idx
argument_list|,
name|imx
argument_list|,
name|xs
argument_list|,
name|ew
argument_list|,
name|idy
argument_list|,
name|imy
argument_list|,
name|ys
argument_list|,
name|hm
argument_list|,
name|hft
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
comment|/*  * write message to Oncore.  */
specifier|static
name|void
name|oncore_sendmsg
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|u_char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|u_char
name|cs
init|=
literal|0
decl_stmt|;
name|fd
operator|=
name|instance
operator|->
name|ttyfd
expr_stmt|;
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_SENDMSG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
block|{
name|char
name|Msg
index|[
literal|120
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"ONCORE: Send @@%c%c %d"
argument_list|,
name|ptr
index|[
literal|0
index|]
argument_list|,
name|ptr
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_DEBUG
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|write
argument_list|(
name|fd
argument_list|,
literal|"@@"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|cs
operator|^=
operator|*
name|ptr
operator|++
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|cs
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
literal|"\r\n"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|oncore_set_posn
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|u_char
name|Cmd
index|[
literal|20
index|]
decl_stmt|;
comment|/* Turn OFF position hold, it needs to be off to set position (for some units), 	   will get set ON in @@Ea later */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gd0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (12) */
else|else
block|{
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_At0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (6/8) */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (6/8) */
block|}
name|mode
operator|=
name|instance
operator|->
name|init_type
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|0
condition|)
block|{
comment|/* first set posn hold position */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_As
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_As
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't modify static variables */
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|12
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_As
argument_list|)
argument_list|)
expr_stmt|;
comment|/* posn hold 3D posn (6/8/12) */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Au
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Au
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Au
argument_list|)
argument_list|)
expr_stmt|;
comment|/* altitude hold (6/8/12 not UT, M12T) */
comment|/* next set current position */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ga
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ga
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|12
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ga
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 3d posn (12) */
block|}
else|else
block|{
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ad
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ad
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_lat
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lat (6/8) */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Ae
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ae
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_long
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ae
argument_list|)
argument_list|)
expr_stmt|;
comment|/* long (6/8) */
name|memcpy
argument_list|(
name|Cmd
argument_list|,
name|oncore_cmd_Af
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|oncore_cmd_Af
argument_list|)
argument_list|)
expr_stmt|;
name|w32_buf
argument_list|(
operator|&
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|4
index|]
argument_list|,
operator|(
name|int
operator|)
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|Cmd
index|[
operator|-
literal|2
operator|+
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|Cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Af
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ht (6/8) */
block|}
comment|/* Finally, turn on position hold */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gd1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_At1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|oncore_set_traim
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|traim_in
operator|!=
operator|-
literal|1
condition|)
comment|/* set in Input */
name|instance
operator|->
name|traim
operator|=
name|instance
operator|->
name|traim_in
expr_stmt|;
else|else
name|instance
operator|->
name|traim
operator|=
name|instance
operator|->
name|traim_ck
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Input   says TRAIM = %d"
argument_list|,
name|instance
operator|->
name|traim_in
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Model # says TRAIM = %d"
argument_list|,
name|instance
operator|->
name|traim_id
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Testing says TRAIM = %d"
argument_list|,
name|instance
operator|->
name|traim_ck
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Using        TRAIM = %d"
argument_list|,
name|instance
operator|->
name|traim
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|traim_ck
operator|==
literal|1
operator|&&
name|instance
operator|->
name|traim
operator|==
literal|0
condition|)
block|{
comment|/* if it should be off, and I turned it on during testing, 		   then turn it off again */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bnx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bnx
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Enx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Enx
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* chan == 12 */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ge0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ge0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Hn0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Hn0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * if SHMEM active, every 15s, steal one 'tick' to get 2D or 3D posn.  */
specifier|static
name|void
name|oncore_shmem_get_3D
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|->
name|pp
operator|->
name|second
operator|%
literal|15
operator|==
literal|3
condition|)
block|{
comment|/* start the sequence */
comment|/* by changing mode */
name|instance
operator|->
name|shmem_reset
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|shmem_Posn
operator|==
literal|2
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gd2
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 2D */
else|else
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gd0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 3D */
block|}
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|saw_At
condition|)
block|{
comment|/* out of 0D -> 3D mode */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_At0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|shmem_Posn
operator|==
literal|2
condition|)
comment|/* 3D -> 2D mode */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|shmem_reset
operator|||
operator|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_0D
operator|)
condition|)
block|{
name|instance
operator|->
name|shmem_reset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gd1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gd1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 0D */
else|else
block|{
if|if
condition|(
name|instance
operator|->
name|saw_At
condition|)
block|{
if|if
condition|(
name|instance
operator|->
name|mode
operator|==
name|MODE_2D
condition|)
comment|/* 2D -> 3D or 0D mode */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Av0
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av0
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_At1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_At1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* to 0D mode */
block|}
else|else
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Av1
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Av1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  * Here we do the Software SiteSurvey.  * We have to average our own position for the Position Hold Mode  *   We use Heights from the GPS ellipsoid.  * We check for the END of either HW or SW SiteSurvey.  */
specifier|static
name|void
name|oncore_ss
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
name|char
name|Msg
index|[
literal|160
index|]
decl_stmt|;
name|double
name|lat
decl_stmt|,
name|lon
decl_stmt|,
name|ht
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|site_survey
operator|==
name|ONCORE_SS_HW
condition|)
block|{
comment|/* 		 * Check to see if Hardware SiteSurvey has Finished. 		 */
if|if
condition|(
operator|(
name|instance
operator|->
name|chan
operator|==
literal|8
operator|&&
operator|!
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|37
index|]
operator|&
literal|0x20
operator|)
operator|)
operator|||
operator|(
name|instance
operator|->
name|chan
operator|==
literal|12
operator|&&
operator|!
operator|(
name|instance
operator|->
name|BEHa
index|[
literal|130
index|]
operator|&
literal|0x10
operator|)
operator|)
condition|)
block|{
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
literal|"Now in 0D mode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gax
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gax
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Asx
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Asx
argument_list|)
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"SSstate = ONCORE_SS_DONE"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Must be a Software Site Survey. 		 */
if|if
condition|(
name|instance
operator|->
name|rsm
operator|.
name|bad_fix
condition|)
comment|/* Not if poor geometry or less than 3 sats */
return|return;
if|if
condition|(
name|instance
operator|->
name|mode
operator|!=
name|MODE_3D
condition|)
comment|/* Use only 3D Fixes */
return|return;
name|instance
operator|->
name|ss_lat
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|19
index|]
argument_list|)
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|+=
name|buf_w32
argument_list|(
operator|&
name|instance
operator|->
name|BEHa
index|[
literal|23
index|]
argument_list|)
expr_stmt|;
comment|/* GPS ellipsoid */
name|instance
operator|->
name|ss_count
operator|++
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|ss_count
operator|!=
name|POS_HOLD_AVERAGE
condition|)
return|return;
name|instance
operator|->
name|ss_lat
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|instance
operator|->
name|ss_long
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|instance
operator|->
name|ss_ht
operator|/=
name|POS_HOLD_AVERAGE
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Surveyed posn: lat %.3f (mas) long %.3f (mas) ht %.3f (cm)"
argument_list|,
name|instance
operator|->
name|ss_lat
argument_list|,
name|instance
operator|->
name|ss_long
argument_list|,
name|instance
operator|->
name|ss_ht
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|lat
operator|=
name|instance
operator|->
name|ss_lat
operator|/
literal|3600000.
expr_stmt|;
name|lon
operator|=
name|instance
operator|->
name|ss_long
operator|/
literal|3600000.
expr_stmt|;
name|ht
operator|=
name|instance
operator|->
name|ss_ht
operator|/
literal|100
expr_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Surveyed posn: lat %.7f (deg) long %.7f (deg) ht %.2f (m)"
argument_list|,
name|lat
argument_list|,
name|lon
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|oncore_set_posn
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
literal|"Now in 0D mode"
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"SSstate = ONCORE_SS_DONE"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|site_survey
operator|=
name|ONCORE_SS_DONE
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|oncore_wait_almanac
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|)
block|{
if|if
condition|(
name|instance
operator|->
name|rsm
operator|.
name|bad_almanac
condition|)
block|{
name|instance
operator|->
name|counta
operator|++
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|counta
operator|%
literal|5
operator|==
literal|0
condition|)
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
literal|"Waiting for Almanac"
argument_list|)
expr_stmt|;
comment|/* 		 * If we get here (first time) then we don't have an almanac in memory. 		 * Check if we have a SHMEM, and if so try to load whatever is there. 		 */
if|if
condition|(
operator|!
name|instance
operator|->
name|almanac_from_shmem
condition|)
block|{
name|instance
operator|->
name|almanac_from_shmem
operator|=
literal|1
expr_stmt|;
name|oncore_load_almanac
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Here we have the Almanac, we will be starting the @@Bn/@@En/@@Hn 		     commands, and can finally check for TRAIM.  Again, we set a delay 		     (5sec) and wait for things to settle down */
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|6
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Bn
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Bn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|8
condition|)
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_En
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_En
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|->
name|chan
operator|==
literal|12
condition|)
block|{
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Gc
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Gc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1PPS on, continuous */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Ge
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Ge
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TRAIM on */
name|oncore_sendmsg
argument_list|(
name|instance
argument_list|,
name|oncore_cmd_Hn
argument_list|,
sizeof|sizeof
argument_list|(
name|oncore_cmd_Hn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TRAIM status 1/s */
block|}
name|instance
operator|->
name|traim_delay
operator|=
literal|1
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"Have now loaded an ALMANAC"
argument_list|)
expr_stmt|;
name|instance
operator|->
name|o_state
operator|=
name|ONCORE_RUN
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_NOTICE
argument_list|,
literal|"state = ONCORE_RUN"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|oncore_log
parameter_list|(
name|struct
name|instance
modifier|*
name|instance
parameter_list|,
name|int
name|log_level
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|Msg
index|[
literal|200
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"ONCORE[%d]: %s"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|log_level
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|127
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Internal Error: max error msg length exceeded in clockstats file (%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
literal|"Start of message was"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|Msg
argument_list|,
name|msg
argument_list|,
literal|120
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* now put ONCORE[n]: ahead of message if it will fit */
if|if
condition|(
name|i
operator|<
literal|110
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"ONCORE[%d]: %s"
argument_list|,
name|instance
operator|->
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
else|else
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|instance
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ONCORE_VERBOSE_ONCORE_LOG
name|instance
operator|->
name|max_len
operator|=
name|max
argument_list|(
name|i
argument_list|,
name|instance
operator|->
name|max_len
argument_list|)
expr_stmt|;
name|instance
operator|->
name|max_count
operator|++
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|max_count
operator|%
literal|100
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|Msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Msg
argument_list|)
argument_list|,
literal|"Max Message Length so far is %d"
argument_list|,
name|instance
operator|->
name|max_len
argument_list|)
expr_stmt|;
name|oncore_log
argument_list|(
name|instance
argument_list|,
name|LOG_INFO
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|#
directive|else
name|int
name|refclock_oncore_bs
decl_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK&& CLOCK_ONCORE */
end_comment

end_unit

