begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntp_scanner.c  *  * The source code for a simple lexical analyzer.   *  * Written By:	Sachin Kamboj  *		University of Delaware  *		Newark, DE 19711  * Copyright (c) 2006  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_config.h"
end_include

begin_include
include|#
directive|include
file|"ntpsim.h"
end_include

begin_include
include|#
directive|include
file|"ntp_scanner.h"
end_include

begin_include
include|#
directive|include
file|"ntp_parser.h"
end_include

begin_comment
comment|/* ntp_keyword.h declares finite state machine and token text */
end_comment

begin_include
include|#
directive|include
file|"ntp_keyword.h"
end_include

begin_comment
comment|/* SCANNER GLOBAL VARIABLES   * ------------------------  */
end_comment

begin_define
define|#
directive|define
name|MAX_LEXEME
value|(1024 + 1)
end_define

begin_comment
comment|/* The maximum size of a lexeme */
end_comment

begin_decl_stmt
name|char
name|yytext
index|[
name|MAX_LEXEME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for storing the input text/lexeme */
end_comment

begin_decl_stmt
name|u_int32
name|conf_file_sum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple sum of characters read */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|FILE_INFO
modifier|*
name|lex_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CONSTANTS   * ---------  */
end_comment

begin_comment
comment|/* SCANNER GLOBAL VARIABLES   * ------------------------  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|special_chars
index|[]
init|=
literal|"{}(),;|="
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTIONS  * ---------  */
end_comment

begin_function_decl
specifier|static
name|int
name|is_keyword
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|,
name|follby
modifier|*
name|pfollowedby
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * keyword() - Return the keyword associated with token T_ identifier.  *	       See also token_name() for the string-ized T_ identifier.  *	       Example: keyword(T_Server) returns "server"  *			token_name(T_Server) returns "T_Server"  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|keyword
parameter_list|(
name|int
name|token
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|i
operator|=
name|token
operator|-
name|LOWEST_KEYWORD_ID
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|COUNTOF
argument_list|(
name|keyword_text
argument_list|)
condition|)
name|text
operator|=
name|keyword_text
index|[
name|i
index|]
expr_stmt|;
else|else
name|text
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|text
operator|!=
name|NULL
operator|)
condition|?
name|text
else|:
literal|"(keyword not found)"
return|;
block|}
end_function

begin_comment
comment|/* FILE& STRING BUFFER INTERFACE  * ------------------------------  *  * This set out as a couple of wrapper functions around the standard C  * fgetc and ungetc functions in order to include positional  * bookkeeping. Alas, this is no longer a good solution with nested  * input files and the possibility to send configuration commands via  * 'ntpdc' and 'ntpq'.  *  * Now there are a few functions to maintain a stack of nested input  * sources (though nesting is only allowd for disk files) and from the  * scanner / parser point of view there's no difference between both  * types of sources.  *  * The 'fgetc()' / 'ungetc()' replacements now operate on a FILE_INFO  * structure. Instead of trying different 'ungetc()' strategies for file  * and buffer based parsing, we keep the backup char in our own  * FILE_INFO structure. This is sufficient, as the parser does *not*  * jump around via 'seek' or the like, and there's no need to  * check/clear the backup store in other places than 'lex_getch()'.  */
end_comment

begin_comment
comment|/*  * Allocate an info structure and attach it to a file.  *  * Note: When 'mode' is NULL, then the INFO block will be set up to  * contain a NULL file pointer, as suited for remote config command  * parsing. Otherwise having a NULL file pointer is considered an error,  * and a NULL info block pointer is returned to indicate failure!  *  * Note: We use a variable-sized structure to hold a copy of the file  * name (or, more proper, the input source description). This is more  * secure than keeping a reference to some other storage that might go  * out of scope.  */
end_comment

begin_function
specifier|static
name|struct
name|FILE_INFO
modifier|*
name|lex_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|FILE_INFO
modifier|*
name|stream
decl_stmt|;
name|size_t
name|nnambuf
decl_stmt|;
name|nnambuf
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|stream
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
operator|+
name|nnambuf
argument_list|)
expr_stmt|;
name|stream
operator|->
name|curpos
operator|.
name|nline
operator|=
literal|1
expr_stmt|;
name|stream
operator|->
name|backch
operator|=
name|EOF
expr_stmt|;
comment|/* copy name with memcpy -- trailing NUL already there! */
name|memcpy
argument_list|(
name|stream
operator|->
name|fname
argument_list|,
name|path
argument_list|,
name|nnambuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|mode
condition|)
block|{
name|stream
operator|->
name|fpi
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|stream
operator|->
name|fpi
condition|)
block|{
name|free
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|stream
return|;
block|}
end_function

begin_comment
comment|/* get next character from buffer or file. This will return any putback  * character first; it will also make sure the last line is at least  * virtually terminated with a '\n'.  */
end_comment

begin_function
specifier|static
name|int
name|lex_getch
parameter_list|(
name|struct
name|FILE_INFO
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|stream
operator|||
name|stream
operator|->
name|force_eof
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|EOF
operator|!=
name|stream
operator|->
name|backch
condition|)
block|{
name|ch
operator|=
name|stream
operator|->
name|backch
expr_stmt|;
name|stream
operator|->
name|backch
operator|=
name|EOF
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|fpi
condition|)
name|conf_file_sum
operator|+=
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stream
operator|->
name|fpi
condition|)
block|{
comment|/* fetch next 7-bit ASCII char (or EOF) from file */
while|while
condition|(
operator|(
name|ch
operator|=
name|fgetc
argument_list|(
name|stream
operator|->
name|fpi
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|>
name|SCHAR_MAX
condition|)
name|stream
operator|->
name|curpos
operator|.
name|ncol
operator|++
expr_stmt|;
if|if
condition|(
name|EOF
operator|!=
name|ch
condition|)
block|{
name|conf_file_sum
operator|+=
name|ch
expr_stmt|;
name|stream
operator|->
name|curpos
operator|.
name|ncol
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* fetch next 7-bit ASCII char from buffer */
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
name|scan
operator|=
operator|&
name|remote_config
operator|.
name|buffer
index|[
name|remote_config
operator|.
name|pos
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|(
name|u_char
operator|)
operator|*
name|scan
operator|)
operator|>
name|SCHAR_MAX
condition|)
block|{
name|scan
operator|++
expr_stmt|;
name|stream
operator|->
name|curpos
operator|.
name|ncol
operator|++
expr_stmt|;
block|}
if|if
condition|(
literal|'\0'
operator|!=
name|ch
condition|)
block|{
name|scan
operator|++
expr_stmt|;
name|stream
operator|->
name|curpos
operator|.
name|ncol
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
name|EOF
expr_stmt|;
block|}
name|remote_config
operator|.
name|pos
operator|=
call|(
name|int
call|)
argument_list|(
name|scan
operator|-
name|remote_config
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|/* If the last line ends without '\n', generate one. This 	 * happens most likely on Windows, where editors often have a 	 * sloppy concept of a line. 	 */
if|if
condition|(
name|EOF
operator|==
name|ch
operator|&&
name|stream
operator|->
name|curpos
operator|.
name|ncol
operator|!=
literal|0
condition|)
name|ch
operator|=
literal|'\n'
expr_stmt|;
comment|/* update scan position tallies */
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|stream
operator|->
name|bakpos
operator|=
name|stream
operator|->
name|curpos
expr_stmt|;
name|stream
operator|->
name|curpos
operator|.
name|nline
operator|++
expr_stmt|;
name|stream
operator|->
name|curpos
operator|.
name|ncol
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* Note: lex_ungetch will fail to track more than one line of push  * back. But since it guarantees only one char of back storage anyway,  * this should not be a problem.  */
end_comment

begin_function
specifier|static
name|int
name|lex_ungetch
parameter_list|(
name|int
name|ch
parameter_list|,
name|struct
name|FILE_INFO
modifier|*
name|stream
parameter_list|)
block|{
comment|/* check preconditions */
if|if
condition|(
name|NULL
operator|==
name|stream
operator|||
name|stream
operator|->
name|force_eof
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|EOF
operator|!=
name|stream
operator|->
name|backch
operator|||
name|EOF
operator|==
name|ch
condition|)
return|return
name|EOF
return|;
comment|/* keep for later reference and update checksum */
name|stream
operator|->
name|backch
operator|=
operator|(
name|u_char
operator|)
name|ch
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|fpi
condition|)
name|conf_file_sum
operator|-=
name|stream
operator|->
name|backch
expr_stmt|;
comment|/* update position */
if|if
condition|(
name|stream
operator|->
name|backch
operator|==
literal|'\n'
condition|)
block|{
name|stream
operator|->
name|curpos
operator|=
name|stream
operator|->
name|bakpos
expr_stmt|;
name|stream
operator|->
name|bakpos
operator|.
name|ncol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|stream
operator|->
name|curpos
operator|.
name|ncol
operator|--
expr_stmt|;
return|return
name|stream
operator|->
name|backch
return|;
block|}
end_function

begin_comment
comment|/* dispose of an input structure. If the file pointer is not NULL, close  * the file. This function does not check the result of 'fclose()'.  */
end_comment

begin_function
specifier|static
name|void
name|lex_close
parameter_list|(
name|struct
name|FILE_INFO
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|stream
condition|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|stream
operator|->
name|fpi
condition|)
name|fclose
argument_list|(
name|stream
operator|->
name|fpi
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* INPUT STACK  * -----------  *  * Nested input sources are a bit tricky at first glance. We deal with  * this problem using a stack of input sources, that is, a forward  * linked list of FILE_INFO structs.  *  * This stack is never empty during parsing; while an encounter with EOF  * can and will remove nested input sources, removing the last element  * in the stack will not work during parsing, and the EOF condition of  * the outermost input file remains until the parser folds up.  */
end_comment

begin_function
specifier|static
name|struct
name|FILE_INFO
modifier|*
name|_drop_stack_do
parameter_list|(
name|struct
name|FILE_INFO
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|FILE_INFO
modifier|*
name|tail
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|head
condition|)
block|{
name|tail
operator|=
name|head
operator|->
name|st_next
expr_stmt|;
name|lex_close
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|tail
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* Create a singleton input source on an empty lexer stack. This will  * fail if there is already an input source, or if the underlying disk  * file cannot be opened.  *  * Returns TRUE if a new input object was successfully created.  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|lex_init_stack
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|lex_stack
operator|||
name|NULL
operator|==
name|path
condition|)
return|return
name|FALSE
return|;
name|lex_stack
operator|=
name|lex_open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|!=
name|lex_stack
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This removes *all* input sources from the stack, leaving the head  * pointer as NULL. Any attempt to parse in that state is likely to bomb  * with segmentation faults or the like.  *  * In other words: Use this to clean up after parsing, and do not parse  * anything until the next 'lex_init_stack()' succeeded.  */
end_comment

begin_function
name|void
name|lex_drop_stack
parameter_list|()
block|{
name|lex_stack
operator|=
name|_drop_stack_do
argument_list|(
name|lex_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the lexer input stack: This will nip all input objects on the  * stack (but keeps the current top-of-stack) and marks the top-of-stack  * as inactive. Any further calls to lex_getch yield only EOF, and it's  * no longer possible to push something back.  *  * Returns TRUE if there is a head element (top-of-stack) that was not  * in the force-eof mode before this call.  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|lex_flush_stack
parameter_list|()
block|{
name|int
name|retv
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|lex_stack
condition|)
block|{
name|retv
operator|=
operator|!
name|lex_stack
operator|->
name|force_eof
expr_stmt|;
name|lex_stack
operator|->
name|force_eof
operator|=
name|TRUE
expr_stmt|;
name|lex_stack
operator|->
name|st_next
operator|=
name|_drop_stack_do
argument_list|(
name|lex_stack
operator|->
name|st_next
argument_list|)
expr_stmt|;
block|}
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/* Push another file on the parsing stack. If the mode is NULL, create a  * FILE_INFO suitable for in-memory parsing; otherwise, create a  * FILE_INFO that is bound to a local/disc file. Note that 'path' must  * not be NULL, or the function will fail.  *  * Returns TRUE if a new info record was pushed onto the stack.  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|lex_push_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|FILE_INFO
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|path
condition|)
block|{
name|next
operator|=
name|lex_open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|next
condition|)
block|{
name|next
operator|->
name|st_next
operator|=
name|lex_stack
expr_stmt|;
name|lex_stack
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|!=
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pop, close& free the top of the include stack, unless the stack  * contains only a singleton input object. In that case the function  * fails, because the parser does not expect the input stack to be  * empty.  *  * Returns TRUE if an object was successfuly popped from the stack.  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|lex_pop_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|FILE_INFO
modifier|*
name|head
init|=
name|lex_stack
decl_stmt|;
name|struct
name|FILE_INFO
modifier|*
name|tail
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|head
condition|)
block|{
name|tail
operator|=
name|head
operator|->
name|st_next
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|tail
condition|)
block|{
name|lex_stack
operator|=
name|tail
expr_stmt|;
name|lex_close
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|!=
name|tail
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get include nesting level. This currently loops over the stack and  * counts elements; but since this is of concern only with an include  * statement and the nesting depth has a small limit, there's no  * bottleneck expected here.  *  * Returns the nesting level of includes, that is, the current depth of  * the lexer input stack.  *  * Note:   */
end_comment

begin_function
name|size_t
name|lex_level
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|cnt
init|=
literal|0
decl_stmt|;
name|struct
name|FILE_INFO
modifier|*
name|ipf
init|=
name|lex_stack
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|ipf
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|ipf
operator|=
name|ipf
operator|->
name|st_next
expr_stmt|;
block|}
return|return
name|cnt
return|;
block|}
end_function

begin_comment
comment|/* check if the current input is from a file */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|lex_from_file
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|!=
name|lex_stack
operator|)
operator|&&
operator|(
name|NULL
operator|!=
name|lex_stack
operator|->
name|fpi
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|FILE_INFO
modifier|*
name|lex_current
parameter_list|()
block|{
comment|/* this became so simple, it could be a macro. But then, 	 * lex_stack needed to be global... 	 */
return|return
name|lex_stack
return|;
block|}
end_function

begin_comment
comment|/* STATE MACHINES   * --------------  */
end_comment

begin_comment
comment|/* Keywords */
end_comment

begin_function
specifier|static
name|int
name|is_keyword
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|,
name|follby
modifier|*
name|pfollowedby
parameter_list|)
block|{
name|follby
name|fb
decl_stmt|;
name|int
name|curr_s
decl_stmt|;
comment|/* current state index */
name|int
name|token
decl_stmt|;
name|int
name|i
decl_stmt|;
name|curr_s
operator|=
name|SCANNER_INIT_S
expr_stmt|;
name|token
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lexeme
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|curr_s
operator|&&
operator|(
name|lexeme
index|[
name|i
index|]
operator|!=
name|SS_CH
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
operator|)
condition|)
name|curr_s
operator|=
name|SS_OTHER_N
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_s
operator|&&
operator|(
name|lexeme
index|[
name|i
index|]
operator|==
name|SS_CH
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
literal|'\0'
operator|==
name|lexeme
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|FOLLBY_NON_ACCEPTING
operator|!=
name|SS_FB
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
condition|)
block|{
name|fb
operator|=
name|SS_FB
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
expr_stmt|;
operator|*
name|pfollowedby
operator|=
name|fb
expr_stmt|;
name|token
operator|=
name|curr_s
expr_stmt|;
break|break;
block|}
name|curr_s
operator|=
name|SS_MATCH_N
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Integer */
end_comment

begin_function
specifier|static
name|int
name|is_integer
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|is_neg
decl_stmt|;
name|u_int
name|u_val
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Allow a leading minus sign */
if|if
condition|(
name|lexeme
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|is_neg
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|is_neg
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Check that all the remaining characters are digits */
for|for
control|(
init|;
name|lexeme
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|is_neg
condition|)
return|return
name|TRUE
return|;
comment|/* Reject numbers that fit in unsigned but not in signed int */
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|lexeme
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|u_val
argument_list|)
condition|)
return|return
operator|(
name|u_val
operator|<=
name|INT_MAX
operator|)
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* U_int -- assumes is_integer() has returned FALSE */
end_comment

begin_function
specifier|static
name|int
name|is_u_int
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|is_hex
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|'0'
operator|==
name|lexeme
index|[
name|i
index|]
operator|&&
literal|'x'
operator|==
name|tolower
argument_list|(
operator|(
name|u_char
operator|)
name|lexeme
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
name|is_hex
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|is_hex
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Check that all the remaining characters are digits */
for|for
control|(
init|;
name|lexeme
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|is_hex
operator|&&
operator|!
name|isxdigit
argument_list|(
operator|(
name|u_char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|is_hex
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Double */
end_comment

begin_function
specifier|static
name|int
name|is_double
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|)
block|{
name|u_int
name|num_digits
init|=
literal|0
decl_stmt|;
comment|/* Number of digits read */
name|u_int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Check for an optional '+' or '-' */
if|if
condition|(
literal|'+'
operator|==
name|lexeme
index|[
name|i
index|]
operator|||
literal|'-'
operator|==
name|lexeme
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Read the integer part */
for|for
control|(
init|;
name|lexeme
index|[
name|i
index|]
operator|&&
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|num_digits
operator|++
expr_stmt|;
comment|/* Check for the optional decimal point */
if|if
condition|(
literal|'.'
operator|==
name|lexeme
index|[
name|i
index|]
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|/* Check for any digits after the decimal point */
for|for
control|(
init|;
name|lexeme
index|[
name|i
index|]
operator|&&
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|num_digits
operator|++
expr_stmt|;
block|}
comment|/* 	 * The number of digits in both the decimal part and the 	 * fraction part must not be zero at this point  	 */
if|if
condition|(
operator|!
name|num_digits
condition|)
return|return
literal|0
return|;
comment|/* Check if we are done */
if|if
condition|(
operator|!
name|lexeme
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
comment|/* There is still more input, read the exponent */
if|if
condition|(
literal|'e'
operator|==
name|tolower
argument_list|(
operator|(
name|u_char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* Read an optional Sign */
if|if
condition|(
literal|'+'
operator|==
name|lexeme
index|[
name|i
index|]
operator|||
literal|'-'
operator|==
name|lexeme
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Now read the exponent part */
while|while
condition|(
name|lexeme
index|[
name|i
index|]
operator|&&
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Check if we are done */
if|if
condition|(
operator|!
name|lexeme
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_special() - Test whether a character is a token */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_special
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
name|strchr
argument_list|(
name|special_chars
argument_list|,
name|ch
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_EOC
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|(
name|old_config_style
operator|&&
operator|(
name|ch
operator|==
literal|'\n'
operator|)
operator|)
operator|||
operator|(
operator|!
name|old_config_style
operator|&&
operator|(
name|ch
operator|==
literal|';'
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|quote_if_needed
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|octets
operator|=
name|len
operator|+
literal|2
operator|+
literal|1
expr_stmt|;
name|ret
operator|=
name|emalloc
argument_list|(
name|octets
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'"'
operator|!=
name|str
index|[
literal|0
index|]
operator|&&
operator|(
name|strcspn
argument_list|(
name|str
argument_list|,
name|special_chars
argument_list|)
operator|<
name|len
operator|||
name|strchr
argument_list|(
name|str
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|ret
argument_list|,
name|octets
argument_list|,
literal|"\"%s\""
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|strlcpy
argument_list|(
name|ret
argument_list|,
name|str
argument_list|,
name|octets
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_string_token
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|)
block|{
name|char
modifier|*
name|pch
decl_stmt|;
comment|/* 	 * ignore end of line whitespace 	 */
name|pch
operator|=
name|lexeme
expr_stmt|;
while|while
condition|(
operator|*
name|pch
operator|&&
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|pch
argument_list|)
condition|)
name|pch
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pch
condition|)
block|{
name|yylval
operator|.
name|Integer
operator|=
name|T_EOC
expr_stmt|;
return|return
name|yylval
operator|.
name|Integer
return|;
block|}
name|yylval
operator|.
name|String
operator|=
name|estrdup
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
return|return
name|T_String
return|;
block|}
end_function

begin_comment
comment|/*  * yylex() - function that does the actual scanning.  * Bison expects this function to be called yylex and for it to take no  * input and return an int.  * Conceptually yylex "returns" yylval as well as the actual return  * value representing the token or type.  */
end_comment

begin_function
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|follby
name|followedby
init|=
name|FOLLBY_TOKEN
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|instring
decl_stmt|;
name|int
name|yylval_was_set
decl_stmt|;
name|int
name|converted
decl_stmt|;
name|int
name|token
decl_stmt|;
comment|/* The return value */
name|int
name|ch
decl_stmt|;
name|instring
operator|=
name|FALSE
expr_stmt|;
name|yylval_was_set
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
comment|/* Ignore whitespace at the beginning */
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|lex_getch
argument_list|(
name|lex_stack
argument_list|)
operator|)
operator|&&
name|isspace
argument_list|(
name|ch
argument_list|)
operator|&&
operator|!
name|is_EOC
argument_list|(
name|ch
argument_list|)
condition|)
empty_stmt|;
comment|/* Null Statement */
if|if
condition|(
name|EOF
operator|==
name|ch
condition|)
block|{
if|if
condition|(
operator|!
name|lex_pop_file
argument_list|()
condition|)
return|return
literal|0
return|;
name|token
operator|=
name|T_EOC
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_EOC
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* end FOLLBY_STRINGS_TO_EOC effect */
name|followedby
operator|=
name|FOLLBY_TOKEN
expr_stmt|;
name|token
operator|=
name|T_EOC
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_special
argument_list|(
name|ch
argument_list|)
operator|&&
name|FOLLBY_TOKEN
operator|==
name|followedby
condition|)
block|{
comment|/* special chars are their own token values */
name|token
operator|=
name|ch
expr_stmt|;
comment|/* 			 * '=' outside simulator configuration implies 			 * a single string following as in: 			 * setvar Owner = "The Boss" default 			 */
if|if
condition|(
literal|'='
operator|==
name|ch
operator|&&
name|old_config_style
condition|)
name|followedby
operator|=
name|FOLLBY_STRING
expr_stmt|;
name|yytext
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
name|yytext
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
else|else
name|lex_ungetch
argument_list|(
name|ch
argument_list|,
name|lex_stack
argument_list|)
expr_stmt|;
comment|/* save the position of start of the token */
name|lex_stack
operator|->
name|tokpos
operator|=
name|lex_stack
operator|->
name|curpos
expr_stmt|;
comment|/* Read in the lexeme */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|lex_getch
argument_list|(
name|lex_stack
argument_list|)
operator|)
condition|)
block|{
name|yytext
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
comment|/* Break on whitespace or a special character */
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
operator|||
name|is_EOC
argument_list|(
name|ch
argument_list|)
operator|||
literal|'"'
operator|==
name|ch
operator|||
operator|(
name|FOLLBY_TOKEN
operator|==
name|followedby
operator|&&
name|is_special
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
break|break;
comment|/* Read the rest of the line on reading a start 			   of comment character */
if|if
condition|(
literal|'#'
operator|==
name|ch
condition|)
block|{
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|lex_getch
argument_list|(
name|lex_stack
argument_list|)
operator|)
operator|&&
literal|'\n'
operator|!=
name|ch
condition|)
empty_stmt|;
comment|/* Null Statement */
break|break;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|COUNTOF
argument_list|(
name|yytext
argument_list|)
condition|)
goto|goto
name|lex_too_long
goto|;
block|}
comment|/* Pick up all of the string inside between " marks, to 		 * end of line.  If we make it to EOL without a 		 * terminating " assume it for them. 		 * 		 * XXX - HMS: I'm not sure we want to assume the closing " 		 */
if|if
condition|(
literal|'"'
operator|==
name|ch
condition|)
block|{
name|instring
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|lex_getch
argument_list|(
name|lex_stack
argument_list|)
operator|)
operator|&&
name|ch
operator|!=
literal|'"'
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
block|{
name|yytext
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|COUNTOF
argument_list|(
name|yytext
argument_list|)
condition|)
goto|goto
name|lex_too_long
goto|;
block|}
comment|/* 			 * yytext[i] will be pushed back as not part of 			 * this lexeme, but any closing quote should 			 * not be pushed back, so we read another char. 			 */
if|if
condition|(
literal|'"'
operator|==
name|ch
condition|)
name|ch
operator|=
name|lex_getch
argument_list|(
name|lex_stack
argument_list|)
expr_stmt|;
block|}
comment|/* Pushback the last character read that is not a part 		 * of this lexeme. This fails silently if ch is EOF, 		 * but then the EOF condition persists and is handled on 		 * the next turn by the include stack mechanism. 		 */
name|lex_ungetch
argument_list|(
name|ch
argument_list|,
name|lex_stack
argument_list|)
expr_stmt|;
name|yytext
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|==
literal|0
condition|)
do|;
comment|/* Now return the desired token */
comment|/* First make sure that the parser is *not* expecting a string 	 * as the next token (based on the previous token that was 	 * returned) and that we haven't read a string. 	 */
if|if
condition|(
name|followedby
operator|==
name|FOLLBY_TOKEN
operator|&&
operator|!
name|instring
condition|)
block|{
name|token
operator|=
name|is_keyword
argument_list|(
name|yytext
argument_list|,
operator|&
name|followedby
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
condition|)
block|{
comment|/* 			 * T_Server is exceptional as it forces the 			 * following token to be a string in the 			 * non-simulator parts of the configuration, 			 * but in the simulator configuration section, 			 * "server" is followed by "=" which must be 			 * recognized as a token not a string. 			 */
if|if
condition|(
name|T_Server
operator|==
name|token
operator|&&
operator|!
name|old_config_style
condition|)
name|followedby
operator|=
name|FOLLBY_TOKEN
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_integer
argument_list|(
name|yytext
argument_list|)
condition|)
block|{
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|yylval
operator|.
name|Integer
operator|=
name|strtol
argument_list|(
name|yytext
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|errno
operator|==
name|EINVAL
operator|)
operator|||
operator|(
name|errno
operator|==
name|ERANGE
operator|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Integer cannot be represented: %s"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex_from_file
argument_list|()
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* force end of parsing */
name|yylval
operator|.
name|Integer
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|T_Integer
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_u_int
argument_list|(
name|yytext
argument_list|)
condition|)
block|{
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
literal|'0'
operator|==
name|yytext
index|[
literal|0
index|]
operator|&&
literal|'x'
operator|==
name|tolower
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|yytext
index|[
literal|1
index|]
argument_list|)
condition|)
name|converted
operator|=
name|sscanf
argument_list|(
operator|&
name|yytext
index|[
literal|2
index|]
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|yylval
operator|.
name|U_int
argument_list|)
expr_stmt|;
else|else
name|converted
operator|=
name|sscanf
argument_list|(
name|yytext
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|yylval
operator|.
name|U_int
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|converted
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"U_int cannot be represented: %s"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex_from_file
argument_list|()
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* force end of parsing */
name|yylval
operator|.
name|Integer
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|T_U_int
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_double
argument_list|(
name|yytext
argument_list|)
condition|)
block|{
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|yylval
operator|.
name|Double
operator|=
name|atof
argument_list|(
name|yytext
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Double too large to represent: %s"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|token
operator|=
name|T_Double
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
block|}
else|else
block|{
comment|/* Default: Everything is a string */
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
name|token
operator|=
name|create_string_token
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
block|}
comment|/* 	 * Either followedby is not FOLLBY_TOKEN or this lexeme is part 	 * of a string.  Hence, we need to return T_String. 	 *  	 * _Except_ we might have a -4 or -6 flag on a an association 	 * configuration line (server, peer, pool, etc.). 	 * 	 * This is a terrible hack, but the grammar is ambiguous so we 	 * don't have a choice.  [SK] 	 * 	 * The ambiguity is in the keyword scanner, not ntp_parser.y. 	 * We do not require server addresses be quoted in ntp.conf, 	 * complicating the scanner's job.  To avoid trying (and 	 * failing) to match an IP address or DNS name to a keyword, 	 * the association keywords use FOLLBY_STRING in the keyword 	 * table, which tells the scanner to force the next token to be 	 * a T_String, so it does not try to match a keyword but rather 	 * expects a string when -4/-6 modifiers to server, peer, etc. 	 * are encountered. 	 * restrict -4 and restrict -6 parsing works correctly without 	 * this hack, as restrict uses FOLLBY_TOKEN.  [DH] 	 */
if|if
condition|(
literal|'-'
operator|==
name|yytext
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
literal|'4'
operator|==
name|yytext
index|[
literal|1
index|]
condition|)
block|{
name|token
operator|=
name|T_Ipv4_flag
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
literal|'6'
operator|==
name|yytext
index|[
literal|1
index|]
condition|)
block|{
name|token
operator|=
name|T_Ipv6_flag
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
block|}
if|if
condition|(
name|FOLLBY_STRING
operator|==
name|followedby
condition|)
name|followedby
operator|=
name|FOLLBY_TOKEN
expr_stmt|;
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
name|token
operator|=
name|create_string_token
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
name|normal_return
label|:
if|if
condition|(
name|T_EOC
operator|==
name|token
condition|)
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"\t<end of command>\n"
operator|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"yylex: lexeme '%s' -> %s\n"
operator|,
name|yytext
operator|,
name|token_name
argument_list|(
name|token
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yylval_was_set
condition|)
name|yylval
operator|.
name|Integer
operator|=
name|token
expr_stmt|;
return|return
name|token
return|;
name|lex_too_long
label|:
name|yytext
index|[
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|yytext
argument_list|)
operator|-
literal|1
argument_list|,
literal|50
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"configuration item on line %d longer than limit of %lu, began with '%s'"
argument_list|,
name|lex_stack
operator|->
name|curpos
operator|.
name|nline
argument_list|,
operator|(
name|u_long
operator|)
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|yytext
argument_list|)
operator|-
literal|1
argument_list|,
literal|50
argument_list|)
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
comment|/* 	 * If we hit the length limit reading the startup configuration 	 * file, abort. 	 */
if|if
condition|(
name|lex_from_file
argument_list|()
condition|)
name|exit
argument_list|(
sizeof|sizeof
argument_list|(
name|yytext
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If it's runtime configuration via ntpq :config treat it as 	 * if the configuration text ended before the too-long lexeme, 	 * hostname, or string. 	 */
name|yylval
operator|.
name|Integer
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

