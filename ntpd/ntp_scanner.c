begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntp_scanner.c  *  * The source code for a simple lexical analyzer.   *  * Written By:	Sachin Kamboj  *		University of Delaware  *		Newark, DE 19711  * Copyright (c) 2006  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_config.h"
end_include

begin_include
include|#
directive|include
file|"ntpsim.h"
end_include

begin_include
include|#
directive|include
file|"ntp_scanner.h"
end_include

begin_include
include|#
directive|include
file|"ntp_parser.h"
end_include

begin_comment
comment|/* ntp_keyword.h declares finite state machine and token text */
end_comment

begin_include
include|#
directive|include
file|"ntp_keyword.h"
end_include

begin_comment
comment|/* SCANNER GLOBAL VARIABLES   * ------------------------  */
end_comment

begin_define
define|#
directive|define
name|MAX_LEXEME
value|(1024 + 1)
end_define

begin_comment
comment|/* The maximum size of a lexeme */
end_comment

begin_decl_stmt
name|char
name|yytext
index|[
name|MAX_LEXEME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for storing the input text/lexeme */
end_comment

begin_decl_stmt
name|u_int32
name|conf_file_sum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple sum of characters read */
end_comment

begin_comment
comment|/* CONSTANTS   * ---------  */
end_comment

begin_comment
comment|/* SCANNER GLOBAL VARIABLES   * ------------------------  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|special_chars
index|[]
init|=
literal|"{}(),;|="
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTIONS  * ---------  */
end_comment

begin_function_decl
specifier|static
name|int
name|is_keyword
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|,
name|follby
modifier|*
name|pfollowedby
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * keyword() - Return the keyword associated with token T_ identifier.  *	       See also token_name() for the string-ized T_ identifier.  *	       Example: keyword(T_Server) returns "server"  *			token_name(T_Server) returns "T_Server"  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|keyword
parameter_list|(
name|int
name|token
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|i
operator|=
name|token
operator|-
name|LOWEST_KEYWORD_ID
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|COUNTOF
argument_list|(
name|keyword_text
argument_list|)
condition|)
name|text
operator|=
name|keyword_text
index|[
name|i
index|]
expr_stmt|;
else|else
name|text
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|text
operator|!=
name|NULL
operator|)
condition|?
name|text
else|:
literal|"(keyword not found)"
return|;
block|}
end_function

begin_comment
comment|/* FILE INTERFACE  * --------------  * We define a couple of wrapper functions around the standard C fgetc  * and ungetc functions in order to include positional bookkeeping  */
end_comment

begin_function
name|struct
name|FILE_INFO
modifier|*
name|F_OPEN
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|FILE_INFO
modifier|*
name|my_info
decl_stmt|;
name|my_info
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|my_info
argument_list|)
expr_stmt|;
name|my_info
operator|->
name|line_no
operator|=
literal|1
expr_stmt|;
name|my_info
operator|->
name|col_no
operator|=
literal|0
expr_stmt|;
name|my_info
operator|->
name|prev_line_col_no
operator|=
literal|0
expr_stmt|;
name|my_info
operator|->
name|prev_token_col_no
operator|=
literal|0
expr_stmt|;
name|my_info
operator|->
name|fname
operator|=
name|path
expr_stmt|;
name|my_info
operator|->
name|fd
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|my_info
operator|->
name|fd
condition|)
block|{
name|free
argument_list|(
name|my_info
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|my_info
return|;
block|}
end_function

begin_function
name|int
name|FGETC
parameter_list|(
name|struct
name|FILE_INFO
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
do|do
name|ch
operator|=
name|fgetc
argument_list|(
name|stream
operator|->
name|fd
argument_list|)
expr_stmt|;
do|while
condition|(
name|EOF
operator|!=
name|ch
operator|&&
operator|(
name|CHAR_MIN
operator|>
name|ch
operator|||
name|ch
operator|>
name|CHAR_MAX
operator|)
condition|)
do|;
if|if
condition|(
name|EOF
operator|!=
name|ch
condition|)
block|{
if|if
condition|(
name|input_from_file
condition|)
name|conf_file_sum
operator|+=
operator|(
name|u_char
operator|)
name|ch
expr_stmt|;
operator|++
name|stream
operator|->
name|col_no
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|stream
operator|->
name|prev_line_col_no
operator|=
name|stream
operator|->
name|col_no
expr_stmt|;
operator|++
name|stream
operator|->
name|line_no
expr_stmt|;
name|stream
operator|->
name|col_no
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* BUGS: 1. Function will fail on more than one line of pushback  *       2. No error checking is done to see if ungetc fails  * SK: I don't think its worth fixing these bugs for our purposes ;-)  */
end_comment

begin_function
name|int
name|UNGETC
parameter_list|(
name|int
name|ch
parameter_list|,
name|struct
name|FILE_INFO
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|input_from_file
condition|)
name|conf_file_sum
operator|-=
operator|(
name|u_char
operator|)
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|stream
operator|->
name|col_no
operator|=
name|stream
operator|->
name|prev_line_col_no
expr_stmt|;
name|stream
operator|->
name|prev_line_col_no
operator|=
operator|-
literal|1
expr_stmt|;
operator|--
name|stream
operator|->
name|line_no
expr_stmt|;
block|}
operator|--
name|stream
operator|->
name|col_no
expr_stmt|;
return|return
name|ungetc
argument_list|(
name|ch
argument_list|,
name|stream
operator|->
name|fd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|FCLOSE
parameter_list|(
name|struct
name|FILE_INFO
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|ret_val
init|=
name|fclose
argument_list|(
name|stream
operator|->
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|free
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/* STREAM INTERFACE   * ----------------  * Provide a wrapper for the stream functions so that the  * stream can either read from a file or from a character  * array.   * NOTE: This is not very efficient for reading from character  * arrays, but needed to allow remote configuration where the  * configuration command is provided through ntpq.  *   * The behavior of there two functions is determined by the   * input_from_file flag.  */
end_comment

begin_function
specifier|static
name|int
name|get_next_char
parameter_list|(
name|struct
name|FILE_INFO
modifier|*
name|ip_file
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|input_from_file
condition|)
return|return
name|FGETC
argument_list|(
name|ip_file
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|remote_config
operator|.
name|buffer
index|[
name|remote_config
operator|.
name|pos
index|]
operator|==
literal|'\0'
condition|)
return|return
name|EOF
return|;
else|else
block|{
name|ip_file
operator|->
name|col_no
operator|++
expr_stmt|;
name|ch
operator|=
name|remote_config
operator|.
name|buffer
index|[
name|remote_config
operator|.
name|pos
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|ip_file
operator|->
name|prev_line_col_no
operator|=
name|ip_file
operator|->
name|col_no
expr_stmt|;
operator|++
name|ip_file
operator|->
name|line_no
expr_stmt|;
name|ip_file
operator|->
name|col_no
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ch
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|push_back_char
parameter_list|(
name|struct
name|FILE_INFO
modifier|*
name|ip_file
parameter_list|,
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|input_from_file
condition|)
name|UNGETC
argument_list|(
name|ch
argument_list|,
name|ip_file
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|ip_file
operator|->
name|col_no
operator|=
name|ip_file
operator|->
name|prev_line_col_no
expr_stmt|;
name|ip_file
operator|->
name|prev_line_col_no
operator|=
operator|-
literal|1
expr_stmt|;
operator|--
name|ip_file
operator|->
name|line_no
expr_stmt|;
block|}
operator|--
name|ip_file
operator|->
name|col_no
expr_stmt|;
name|remote_config
operator|.
name|pos
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* STATE MACHINES   * --------------  */
end_comment

begin_comment
comment|/* Keywords */
end_comment

begin_function
specifier|static
name|int
name|is_keyword
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|,
name|follby
modifier|*
name|pfollowedby
parameter_list|)
block|{
name|follby
name|fb
decl_stmt|;
name|int
name|curr_s
decl_stmt|;
comment|/* current state index */
name|int
name|token
decl_stmt|;
name|int
name|i
decl_stmt|;
name|curr_s
operator|=
name|SCANNER_INIT_S
expr_stmt|;
name|token
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lexeme
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|curr_s
operator|&&
operator|(
name|lexeme
index|[
name|i
index|]
operator|!=
name|SS_CH
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
operator|)
condition|)
name|curr_s
operator|=
name|SS_OTHER_N
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_s
operator|&&
operator|(
name|lexeme
index|[
name|i
index|]
operator|==
name|SS_CH
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
literal|'\0'
operator|==
name|lexeme
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|FOLLBY_NON_ACCEPTING
operator|!=
name|SS_FB
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
condition|)
block|{
name|fb
operator|=
name|SS_FB
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
expr_stmt|;
operator|*
name|pfollowedby
operator|=
name|fb
expr_stmt|;
name|token
operator|=
name|curr_s
expr_stmt|;
break|break;
block|}
name|curr_s
operator|=
name|SS_MATCH_N
argument_list|(
name|sst
index|[
name|curr_s
index|]
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Integer */
end_comment

begin_function
specifier|static
name|int
name|is_integer
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|is_neg
decl_stmt|;
name|u_int
name|u_val
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Allow a leading minus sign */
if|if
condition|(
name|lexeme
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|is_neg
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|is_neg
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Check that all the remaining characters are digits */
for|for
control|(
init|;
name|lexeme
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|is_neg
condition|)
return|return
name|TRUE
return|;
comment|/* Reject numbers that fit in unsigned but not in signed int */
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|lexeme
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|u_val
argument_list|)
condition|)
return|return
operator|(
name|u_val
operator|<=
name|INT_MAX
operator|)
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* U_int -- assumes is_integer() has returned FALSE */
end_comment

begin_function
specifier|static
name|int
name|is_u_int
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|is_hex
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|'0'
operator|==
name|lexeme
index|[
name|i
index|]
operator|&&
literal|'x'
operator|==
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|lexeme
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
name|is_hex
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|is_hex
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Check that all the remaining characters are digits */
for|for
control|(
init|;
name|lexeme
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|is_hex
operator|&&
operator|!
name|isxdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|is_hex
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Double */
end_comment

begin_function
specifier|static
name|int
name|is_double
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|)
block|{
name|u_int
name|num_digits
init|=
literal|0
decl_stmt|;
comment|/* Number of digits read */
name|u_int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Check for an optional '+' or '-' */
if|if
condition|(
literal|'+'
operator|==
name|lexeme
index|[
name|i
index|]
operator|||
literal|'-'
operator|==
name|lexeme
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Read the integer part */
for|for
control|(
init|;
name|lexeme
index|[
name|i
index|]
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|num_digits
operator|++
expr_stmt|;
comment|/* Check for the optional decimal point */
if|if
condition|(
literal|'.'
operator|==
name|lexeme
index|[
name|i
index|]
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|/* Check for any digits after the decimal point */
for|for
control|(
init|;
name|lexeme
index|[
name|i
index|]
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|num_digits
operator|++
expr_stmt|;
block|}
comment|/* 	 * The number of digits in both the decimal part and the 	 * fraction part must not be zero at this point  	 */
if|if
condition|(
operator|!
name|num_digits
condition|)
return|return
literal|0
return|;
comment|/* Check if we are done */
if|if
condition|(
operator|!
name|lexeme
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
comment|/* There is still more input, read the exponent */
if|if
condition|(
literal|'e'
operator|==
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* Read an optional Sign */
if|if
condition|(
literal|'+'
operator|==
name|lexeme
index|[
name|i
index|]
operator|||
literal|'-'
operator|==
name|lexeme
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Now read the exponent part */
while|while
condition|(
name|lexeme
index|[
name|i
index|]
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|lexeme
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Check if we are done */
if|if
condition|(
operator|!
name|lexeme
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_special() - Test whether a character is a token */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_special
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
name|strchr
argument_list|(
name|special_chars
argument_list|,
name|ch
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_EOC
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|(
name|old_config_style
operator|&&
operator|(
name|ch
operator|==
literal|'\n'
operator|)
operator|)
operator|||
operator|(
operator|!
name|old_config_style
operator|&&
operator|(
name|ch
operator|==
literal|';'
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|quote_if_needed
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|octets
operator|=
name|len
operator|+
literal|2
operator|+
literal|1
expr_stmt|;
name|ret
operator|=
name|emalloc
argument_list|(
name|octets
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'"'
operator|!=
name|str
index|[
literal|0
index|]
operator|&&
operator|(
name|strcspn
argument_list|(
name|str
argument_list|,
name|special_chars
argument_list|)
operator|<
name|len
operator|||
name|strchr
argument_list|(
name|str
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|ret
argument_list|,
name|octets
argument_list|,
literal|"\"%s\""
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|strlcpy
argument_list|(
name|ret
argument_list|,
name|str
argument_list|,
name|octets
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_string_token
parameter_list|(
name|char
modifier|*
name|lexeme
parameter_list|)
block|{
name|char
modifier|*
name|pch
decl_stmt|;
comment|/* 	 * ignore end of line whitespace 	 */
name|pch
operator|=
name|lexeme
expr_stmt|;
while|while
condition|(
operator|*
name|pch
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pch
argument_list|)
condition|)
name|pch
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pch
condition|)
block|{
name|yylval
operator|.
name|Integer
operator|=
name|T_EOC
expr_stmt|;
return|return
name|yylval
operator|.
name|Integer
return|;
block|}
name|yylval
operator|.
name|String
operator|=
name|estrdup
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
return|return
name|T_String
return|;
block|}
end_function

begin_comment
comment|/*  * yylex() - function that does the actual scanning.  * Bison expects this function to be called yylex and for it to take no  * input and return an int.  * Conceptually yylex "returns" yylval as well as the actual return  * value representing the token or type.  */
end_comment

begin_function
name|int
name|yylex
parameter_list|(
name|struct
name|FILE_INFO
modifier|*
name|ip_file
parameter_list|)
block|{
specifier|static
name|follby
name|followedby
init|=
name|FOLLBY_TOKEN
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|instring
decl_stmt|;
name|int
name|yylval_was_set
decl_stmt|;
name|int
name|converted
decl_stmt|;
name|int
name|token
decl_stmt|;
comment|/* The return value */
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|input_from_file
condition|)
name|ip_file
operator|=
name|fp
index|[
name|curr_include_level
index|]
expr_stmt|;
name|instring
operator|=
name|FALSE
expr_stmt|;
name|yylval_was_set
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
comment|/* Ignore whitespace at the beginning */
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_next_char
argument_list|(
name|ip_file
argument_list|)
operator|)
operator|&&
name|isspace
argument_list|(
name|ch
argument_list|)
operator|&&
operator|!
name|is_EOC
argument_list|(
name|ch
argument_list|)
condition|)
empty_stmt|;
comment|/* Null Statement */
if|if
condition|(
name|EOF
operator|==
name|ch
condition|)
block|{
if|if
condition|(
operator|!
name|input_from_file
operator|||
name|curr_include_level
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|FCLOSE
argument_list|(
name|fp
index|[
name|curr_include_level
index|]
argument_list|)
expr_stmt|;
name|ip_file
operator|=
name|fp
index|[
operator|--
name|curr_include_level
index|]
expr_stmt|;
name|token
operator|=
name|T_EOC
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_EOC
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* end FOLLBY_STRINGS_TO_EOC effect */
name|followedby
operator|=
name|FOLLBY_TOKEN
expr_stmt|;
name|token
operator|=
name|T_EOC
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_special
argument_list|(
name|ch
argument_list|)
operator|&&
name|FOLLBY_TOKEN
operator|==
name|followedby
condition|)
block|{
comment|/* special chars are their own token values */
name|token
operator|=
name|ch
expr_stmt|;
comment|/* 			 * '=' outside simulator configuration implies 			 * a single string following as in: 			 * setvar Owner = "The Boss" default 			 */
if|if
condition|(
literal|'='
operator|==
name|ch
operator|&&
name|old_config_style
condition|)
name|followedby
operator|=
name|FOLLBY_STRING
expr_stmt|;
name|yytext
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
name|yytext
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
else|else
name|push_back_char
argument_list|(
name|ip_file
argument_list|,
name|ch
argument_list|)
expr_stmt|;
comment|/* save the position of start of the token */
name|ip_file
operator|->
name|prev_token_line_no
operator|=
name|ip_file
operator|->
name|line_no
expr_stmt|;
name|ip_file
operator|->
name|prev_token_col_no
operator|=
name|ip_file
operator|->
name|col_no
expr_stmt|;
comment|/* Read in the lexeme */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_next_char
argument_list|(
name|ip_file
argument_list|)
operator|)
condition|)
block|{
name|yytext
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
comment|/* Break on whitespace or a special character */
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
operator|||
name|is_EOC
argument_list|(
name|ch
argument_list|)
operator|||
literal|'"'
operator|==
name|ch
operator|||
operator|(
name|FOLLBY_TOKEN
operator|==
name|followedby
operator|&&
name|is_special
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
break|break;
comment|/* Read the rest of the line on reading a start 			   of comment character */
if|if
condition|(
literal|'#'
operator|==
name|ch
condition|)
block|{
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_next_char
argument_list|(
name|ip_file
argument_list|)
operator|)
operator|&&
literal|'\n'
operator|!=
name|ch
condition|)
empty_stmt|;
comment|/* Null Statement */
break|break;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|COUNTOF
argument_list|(
name|yytext
argument_list|)
condition|)
goto|goto
name|lex_too_long
goto|;
block|}
comment|/* Pick up all of the string inside between " marks, to 		 * end of line.  If we make it to EOL without a 		 * terminating " assume it for them. 		 * 		 * XXX - HMS: I'm not sure we want to assume the closing " 		 */
if|if
condition|(
literal|'"'
operator|==
name|ch
condition|)
block|{
name|instring
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_next_char
argument_list|(
name|ip_file
argument_list|)
operator|)
operator|&&
name|ch
operator|!=
literal|'"'
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
block|{
name|yytext
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|COUNTOF
argument_list|(
name|yytext
argument_list|)
condition|)
goto|goto
name|lex_too_long
goto|;
block|}
comment|/* 			 * yytext[i] will be pushed back as not part of 			 * this lexeme, but any closing quote should 			 * not be pushed back, so we read another char. 			 */
if|if
condition|(
literal|'"'
operator|==
name|ch
condition|)
name|ch
operator|=
name|get_next_char
argument_list|(
name|ip_file
argument_list|)
expr_stmt|;
block|}
comment|/* Pushback the last character read that is not a part 		 * of this lexeme. 		 * If the last character read was an EOF, pushback a 		 * newline character. This is to prevent a parse error 		 * when there is no newline at the end of a file. 		 */
if|if
condition|(
name|EOF
operator|==
name|ch
condition|)
name|push_back_char
argument_list|(
name|ip_file
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|push_back_char
argument_list|(
name|ip_file
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|yytext
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|==
literal|0
condition|)
do|;
comment|/* Now return the desired token */
comment|/* First make sure that the parser is *not* expecting a string 	 * as the next token (based on the previous token that was 	 * returned) and that we haven't read a string. 	 */
if|if
condition|(
name|followedby
operator|==
name|FOLLBY_TOKEN
operator|&&
operator|!
name|instring
condition|)
block|{
name|token
operator|=
name|is_keyword
argument_list|(
name|yytext
argument_list|,
operator|&
name|followedby
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
condition|)
block|{
comment|/* 			 * T_Server is exceptional as it forces the 			 * following token to be a string in the 			 * non-simulator parts of the configuration, 			 * but in the simulator configuration section, 			 * "server" is followed by "=" which must be 			 * recognized as a token not a string. 			 */
if|if
condition|(
name|T_Server
operator|==
name|token
operator|&&
operator|!
name|old_config_style
condition|)
name|followedby
operator|=
name|FOLLBY_TOKEN
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_integer
argument_list|(
name|yytext
argument_list|)
condition|)
block|{
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|yylval
operator|.
name|Integer
operator|=
name|strtol
argument_list|(
name|yytext
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|errno
operator|==
name|EINVAL
operator|)
operator|||
operator|(
name|errno
operator|==
name|ERANGE
operator|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Integer cannot be represented: %s"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_from_file
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* force end of parsing */
name|yylval
operator|.
name|Integer
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|T_Integer
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_u_int
argument_list|(
name|yytext
argument_list|)
condition|)
block|{
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
literal|'0'
operator|==
name|yytext
index|[
literal|0
index|]
operator|&&
literal|'x'
operator|==
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|yytext
index|[
literal|1
index|]
argument_list|)
condition|)
name|converted
operator|=
name|sscanf
argument_list|(
operator|&
name|yytext
index|[
literal|2
index|]
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|yylval
operator|.
name|U_int
argument_list|)
expr_stmt|;
else|else
name|converted
operator|=
name|sscanf
argument_list|(
name|yytext
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|yylval
operator|.
name|U_int
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|converted
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"U_int cannot be represented: %s"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_from_file
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* force end of parsing */
name|yylval
operator|.
name|Integer
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|T_U_int
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
name|is_double
argument_list|(
name|yytext
argument_list|)
condition|)
block|{
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|yylval
operator|.
name|Double
operator|=
name|atof
argument_list|(
name|yytext
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Double too large to represent: %s"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|token
operator|=
name|T_Double
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
block|}
else|else
block|{
comment|/* Default: Everything is a string */
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
name|token
operator|=
name|create_string_token
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
block|}
comment|/* 	 * Either followedby is not FOLLBY_TOKEN or this lexeme is part 	 * of a string.  Hence, we need to return T_String. 	 *  	 * _Except_ we might have a -4 or -6 flag on a an association 	 * configuration line (server, peer, pool, etc.). 	 * 	 * This is a terrible hack, but the grammar is ambiguous so we 	 * don't have a choice.  [SK] 	 * 	 * The ambiguity is in the keyword scanner, not ntp_parser.y. 	 * We do not require server addresses be quoted in ntp.conf, 	 * complicating the scanner's job.  To avoid trying (and 	 * failing) to match an IP address or DNS name to a keyword, 	 * the association keywords use FOLLBY_STRING in the keyword 	 * table, which tells the scanner to force the next token to be 	 * a T_String, so it does not try to match a keyword but rather 	 * expects a string when -4/-6 modifiers to server, peer, etc. 	 * are encountered. 	 * restrict -4 and restrict -6 parsing works correctly without 	 * this hack, as restrict uses FOLLBY_TOKEN.  [DH] 	 */
if|if
condition|(
literal|'-'
operator|==
name|yytext
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
literal|'4'
operator|==
name|yytext
index|[
literal|1
index|]
condition|)
block|{
name|token
operator|=
name|T_Ipv4_flag
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
elseif|else
if|if
condition|(
literal|'6'
operator|==
name|yytext
index|[
literal|1
index|]
condition|)
block|{
name|token
operator|=
name|T_Ipv6_flag
expr_stmt|;
goto|goto
name|normal_return
goto|;
block|}
block|}
name|instring
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|FOLLBY_STRING
operator|==
name|followedby
condition|)
name|followedby
operator|=
name|FOLLBY_TOKEN
expr_stmt|;
name|yylval_was_set
operator|=
name|TRUE
expr_stmt|;
name|token
operator|=
name|create_string_token
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
name|normal_return
label|:
if|if
condition|(
name|T_EOC
operator|==
name|token
condition|)
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"\t<end of command>\n"
operator|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"yylex: lexeme '%s' -> %s\n"
operator|,
name|yytext
operator|,
name|token_name
argument_list|(
name|token
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yylval_was_set
condition|)
name|yylval
operator|.
name|Integer
operator|=
name|token
expr_stmt|;
return|return
name|token
return|;
name|lex_too_long
label|:
name|yytext
index|[
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|yytext
argument_list|)
operator|-
literal|1
argument_list|,
literal|50
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"configuration item on line %d longer than limit of %lu, began with '%s'"
argument_list|,
name|ip_file
operator|->
name|line_no
argument_list|,
operator|(
name|u_long
operator|)
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|yytext
argument_list|)
operator|-
literal|1
argument_list|,
literal|50
argument_list|)
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
comment|/* 	 * If we hit the length limit reading the startup configuration 	 * file, abort. 	 */
if|if
condition|(
name|input_from_file
condition|)
name|exit
argument_list|(
sizeof|sizeof
argument_list|(
name|yytext
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If it's runtime configuration via ntpq :config treat it as 	 * if the configuration text ended before the too-long lexeme, 	 * hostname, or string. 	 */
name|yylval
operator|.
name|Integer
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

