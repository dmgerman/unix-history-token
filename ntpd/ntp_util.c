begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_util.c - stuff I didn't have any other place for  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_filegen.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IEEEFP_H
end_ifdef

begin_include
include|#
directive|include
file|<ieeefp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MATH_H
end_ifdef

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DOSYNCTODR
end_ifdef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/*  * Defines used by the leapseconds stuff  */
end_comment

begin_define
define|#
directive|define
name|MAX_TAI
value|100
end_define

begin_comment
comment|/* max TAI offset (s) */
end_comment

begin_define
define|#
directive|define
name|L_DAY
value|86400UL
end_define

begin_comment
comment|/* seconds per day */
end_comment

begin_define
define|#
directive|define
name|L_YEAR
value|(L_DAY * 365)
end_define

begin_comment
comment|/* days per year */
end_comment

begin_define
define|#
directive|define
name|L_LYEAR
value|(L_YEAR + L_DAY)
end_define

begin_comment
comment|/* days per leap year */
end_comment

begin_define
define|#
directive|define
name|L_4YEAR
value|(L_LYEAR + 3 * L_YEAR)
end_define

begin_comment
comment|/* days per leap cycle */
end_comment

begin_define
define|#
directive|define
name|L_CENT
value|(L_4YEAR * 25)
end_define

begin_comment
comment|/* days per century */
end_comment

begin_comment
comment|/*  * This contains odds and ends, including the hourly stats, various  * configuration items, leapseconds stuff, etc.  */
end_comment

begin_comment
comment|/*  * File names  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|key_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys file name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|leapseconds_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* leapseconds file name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|stats_drift_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency file name */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stats_temp_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temp frequency file name */
end_comment

begin_decl_stmt
name|double
name|wander_resid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wander threshold */
end_comment

begin_decl_stmt
name|double
name|wander_threshold
init|=
literal|1e-7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial wander threshold */
end_comment

begin_decl_stmt
name|int
name|drift_file_sw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock update switch */
end_comment

begin_comment
comment|/*  * Statistics file stuff  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NTP_VAR
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_define
define|#
directive|define
name|NTP_VAR
value|"/var/NTP/"
end_define

begin_comment
comment|/* NOTE the trailing '/' */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NTP_VAR
value|"c:\\var\\ntp\\"
end_define

begin_comment
comment|/* NOTE the trailing '\\' */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHLEN
end_ifndef

begin_define
define|#
directive|define
name|MAXPATHLEN
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_TIMING
end_ifdef

begin_decl_stmt
specifier|static
name|FILEGEN
name|timingstats
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_decl_stmt
specifier|static
name|FILEGEN
name|cryptostats
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_decl_stmt
specifier|static
name|char
name|statsdir
index|[
name|MAXPATHLEN
index|]
init|=
name|NTP_VAR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILEGEN
name|peerstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILEGEN
name|loopstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILEGEN
name|clockstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILEGEN
name|rawstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILEGEN
name|sysstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILEGEN
name|protostats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This controls whether stats are written to the fileset. Provided  * so that ntpdc can turn off stats when the file system fills up.   */
end_comment

begin_decl_stmt
name|int
name|stats_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initial frequency offset later passed to the loopfilter.  */
end_comment

begin_decl_stmt
name|double
name|old_drift
init|=
literal|1e9
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current frequency */
end_comment

begin_decl_stmt
specifier|static
name|double
name|prev_drift_comp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last frequency update */
end_comment

begin_comment
comment|/*  * Static prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|leap_file
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_sys_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   * Prototypes  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
name|void
name|uninit_util
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * uninit_util - free memory allocated by init_util  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|uninit_util
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|_CrtCheckMemory
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stats_drift_file
condition|)
block|{
name|free
argument_list|(
name|stats_drift_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stats_temp_file
argument_list|)
expr_stmt|;
name|stats_drift_file
operator|=
name|NULL
expr_stmt|;
name|stats_temp_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|key_file_name
condition|)
block|{
name|free
argument_list|(
name|key_file_name
argument_list|)
expr_stmt|;
name|key_file_name
operator|=
name|NULL
expr_stmt|;
block|}
name|filegen_unregister
argument_list|(
literal|"peerstats"
argument_list|)
expr_stmt|;
name|filegen_unregister
argument_list|(
literal|"loopstats"
argument_list|)
expr_stmt|;
name|filegen_unregister
argument_list|(
literal|"clockstats"
argument_list|)
expr_stmt|;
name|filegen_unregister
argument_list|(
literal|"rawstats"
argument_list|)
expr_stmt|;
name|filegen_unregister
argument_list|(
literal|"sysstats"
argument_list|)
expr_stmt|;
name|filegen_unregister
argument_list|(
literal|"protostats"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|filegen_unregister
argument_list|(
literal|"cryptostats"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
ifdef|#
directive|ifdef
name|DEBUG_TIMING
name|filegen_unregister
argument_list|(
literal|"timingstats"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_TIMING */
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|_CrtCheckMemory
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * init_util - initialize the utilities (ntpd included)  */
end_comment

begin_function
name|void
name|init_util
parameter_list|(
name|void
parameter_list|)
block|{
name|stats_drift_file
operator|=
name|NULL
expr_stmt|;
name|stats_temp_file
operator|=
name|NULL
expr_stmt|;
name|key_file_name
operator|=
name|NULL
expr_stmt|;
name|filegen_register
argument_list|(
name|statsdir
argument_list|,
literal|"peerstats"
argument_list|,
operator|&
name|peerstats
argument_list|)
expr_stmt|;
name|filegen_register
argument_list|(
name|statsdir
argument_list|,
literal|"loopstats"
argument_list|,
operator|&
name|loopstats
argument_list|)
expr_stmt|;
name|filegen_register
argument_list|(
name|statsdir
argument_list|,
literal|"clockstats"
argument_list|,
operator|&
name|clockstats
argument_list|)
expr_stmt|;
name|filegen_register
argument_list|(
name|statsdir
argument_list|,
literal|"rawstats"
argument_list|,
operator|&
name|rawstats
argument_list|)
expr_stmt|;
name|filegen_register
argument_list|(
name|statsdir
argument_list|,
literal|"sysstats"
argument_list|,
operator|&
name|sysstats
argument_list|)
expr_stmt|;
name|filegen_register
argument_list|(
name|statsdir
argument_list|,
literal|"protostats"
argument_list|,
operator|&
name|protostats
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|filegen_register
argument_list|(
name|statsdir
argument_list|,
literal|"cryptostats"
argument_list|,
operator|&
name|cryptostats
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
ifdef|#
directive|ifdef
name|DEBUG_TIMING
name|filegen_register
argument_list|(
name|statsdir
argument_list|,
literal|"timingstats"
argument_list|,
operator|&
name|timingstats
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_TIMING */
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
name|uninit_util
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_comment
comment|/*  * hourly_stats - print some interesting stats  */
end_comment

begin_function
name|void
name|write_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|double
name|ftemp
decl_stmt|;
ifdef|#
directive|ifdef
name|DOSYNCTODR
name|struct
name|timeval
name|tv
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
name|int
name|prio_set
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
name|struct
name|timespec
name|ts
decl_stmt|;
endif|#
directive|endif
name|int
name|o_prio
decl_stmt|;
comment|/* 	 * Sometimes having a Sun can be a drag. 	 * 	 * The kernel variable dosynctodr controls whether the system's 	 * soft clock is kept in sync with the battery clock. If it 	 * is zero, then the soft clock is not synced, and the battery 	 * clock is simply left to rot. That means that when the system 	 * reboots, the battery clock (which has probably gone wacky) 	 * sets the soft clock. That means ntpd starts off with a very 	 * confused idea of what time it is. It then takes a large 	 * amount of time to figure out just how wacky the battery clock 	 * has made things drift, etc, etc. The solution is to make the 	 * battery clock sync up to system time. The way to do THAT is 	 * to simply set the time of day to the current time of day, but 	 * as quickly as possible. This may, or may not be a sensible 	 * thing to do. 	 * 	 * CAVEAT: settimeofday() steps the sun clock by about 800 us, 	 *         so setting DOSYNCTODR seems a bad idea in the 	 *         case of us resolution 	 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
comment|/* 	 * (prr) getpriority returns -1 on error, but -1 is also a valid 	 * return value (!), so instead we have to zero errno before the 	 * call and check it for non-zero afterwards. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
name|prio_set
operator|=
literal|0
expr_stmt|;
name|o_prio
operator|=
name|getpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save setting */
comment|/* 	 * (prr) if getpriority succeeded, call setpriority to raise 	 * scheduling priority as high as possible.  If that succeeds 	 * as well, set the prio_set flag so we remember to reset 	 * priority to its previous value below.  Note that on Solaris 	 * 2.6 (and beyond?), both getpriority and setpriority will fail 	 * with ESRCH, because sched_setscheduler (called from main) put 	 * us in the real-time scheduling class which setpriority 	 * doesn't know about. Being in the real-time class is better 	 * than anything setpriority can do, anyhow, so this error is 	 * silently ignored. 	 */
if|if
condition|(
operator|(
name|errno
operator|==
literal|0
operator|)
operator|&&
operator|(
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
operator|-
literal|20
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|prio_set
operator|=
literal|1
expr_stmt|;
comment|/* overdrive */
endif|#
directive|endif
comment|/* VMS */
ifdef|#
directive|ifdef
name|HAVE_GETCLOCK
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
comment|/*  not HAVE_GETCLOCK */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_GETCLOCK */
if|if
condition|(
name|ntp_set_tod
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't sync battery time: %m"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|prio_set
condition|)
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
name|o_prio
argument_list|)
expr_stmt|;
comment|/* downshift */
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* DOSYNCTODR */
name|record_sys_stats
argument_list|()
expr_stmt|;
name|ftemp
operator|=
name|fabs
argument_list|(
name|prev_drift_comp
operator|-
name|drift_comp
argument_list|)
expr_stmt|;
name|prev_drift_comp
operator|=
name|drift_comp
expr_stmt|;
if|if
condition|(
name|ftemp
operator|>
name|clock_phi
condition|)
return|return;
if|if
condition|(
name|stats_drift_file
operator|!=
literal|0
operator|&&
name|drift_file_sw
condition|)
block|{
comment|/* 		 * When the frequency file is written, initialize the 		 * wander threshold to a configured initial value. 		 * Thereafter reduce it by a factor of 0.5. When it 		 * drops below the frequency wander, write the frequency 		 * file. This adapts to the prevailing wander yet 		 * minimizes the file writes. 		 */
name|drift_file_sw
operator|=
name|FALSE
expr_stmt|;
name|wander_resid
operator|*=
literal|0.5
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"write_stats: wander %.6lf thresh %.6lf, freq %.6lf\n"
argument_list|,
name|clock_stability
operator|*
literal|1e6
argument_list|,
name|wander_resid
operator|*
literal|1e6
argument_list|,
name|drift_comp
operator|*
literal|1e6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
operator|&&
name|clock_stability
operator|>
name|wander_resid
condition|)
block|{
name|wander_resid
operator|=
name|wander_threshold
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|stats_temp_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"frequency file %s: %m"
argument_list|,
name|stats_temp_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%.3f\n"
argument_list|,
name|drift_comp
operator|*
literal|1e6
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* atomic */
ifdef|#
directive|ifdef
name|SYS_WINNT
if|if
condition|(
name|_unlink
argument_list|(
name|stats_drift_file
argument_list|)
condition|)
comment|/* rename semantics differ under NT */
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Unable to remove prior drift file %s, %m"
argument_list|,
name|stats_drift_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
ifndef|#
directive|ifndef
name|NO_RENAME
if|if
condition|(
name|rename
argument_list|(
name|stats_temp_file
argument_list|,
name|stats_drift_file
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Unable to rename temp drift file %s to %s, %m"
argument_list|,
name|stats_temp_file
argument_list|,
name|stats_drift_file
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* we have no rename NFS of ftp in use */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|stats_drift_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"frequency file %s: %m"
argument_list|,
name|stats_drift_file
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
comment|/* PURGE */
block|{
name|$DESCRIPTOR
argument_list|(
name|oldvers
argument_list|,
literal|";-1"
argument_list|)
expr_stmt|;
name|struct
name|dsc$descriptor
name|driftdsc
init|=
block|{
name|strlen
argument_list|(
name|stats_drift_file
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
name|stats_drift_file
block|}
decl_stmt|;
while|while
condition|(
name|lib$delete_file
argument_list|(
operator|&
name|oldvers
argument_list|,
operator|&
name|driftdsc
argument_list|)
operator|&
literal|1
condition|)
empty_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* XXX: Log a message at INFO level */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * stats_config - configure the stats operation  */
end_comment

begin_function
name|void
name|stats_config
parameter_list|(
name|int
name|item
parameter_list|,
specifier|const
name|char
modifier|*
name|invalue
comment|/* only one type so far */
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
name|char
name|str1
index|[
literal|20
index|]
decl_stmt|,
name|str2
index|[
literal|20
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|VMS
specifier|const
name|char
name|temp_ext
index|[]
init|=
literal|".TEMP"
decl_stmt|;
else|#
directive|else
specifier|const
name|char
name|temp_ext
index|[]
init|=
literal|"-TEMP"
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Expand environment strings under Windows NT, since the 	 * command interpreter doesn't do this, the program must. 	 */
ifdef|#
directive|ifdef
name|SYS_WINNT
name|char
name|newvalue
index|[
name|MAX_PATH
index|]
decl_stmt|,
name|parameter
index|[
name|MAX_PATH
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
name|invalue
argument_list|,
name|newvalue
argument_list|,
name|MAX_PATH
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|STATS_FREQ_FILE
case|:
name|strcpy
argument_list|(
name|parameter
argument_list|,
literal|"STATS_FREQ_FILE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATS_LEAP_FILE
case|:
name|strcpy
argument_list|(
name|parameter
argument_list|,
literal|"STATS_LEAP_FILE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATS_STATSDIR
case|:
name|strcpy
argument_list|(
name|parameter
argument_list|,
literal|"STATS_STATSDIR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATS_PID_FILE
case|:
name|strcpy
argument_list|(
name|parameter
argument_list|,
literal|"STATS_PID_FILE"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|parameter
argument_list|,
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
break|break;
block|}
name|value
operator|=
name|invalue
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings(%s) failed: %m\n"
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|newvalue
expr_stmt|;
block|}
else|#
directive|else
name|value
operator|=
name|invalue
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
switch|switch
condition|(
name|item
condition|)
block|{
comment|/* 	 * Open and read frequency file. 	 */
case|case
name|STATS_FREQ_FILE
case|:
if|if
condition|(
operator|!
name|value
operator|||
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|stats_drift_file
operator|=
name|erealloc
argument_list|(
name|stats_drift_file
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stats_temp_file
operator|=
name|erealloc
argument_list|(
name|stats_temp_file
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|".TEMP"
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stats_drift_file
argument_list|,
name|value
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stats_temp_file
argument_list|,
name|value
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stats_temp_file
operator|+
name|len
argument_list|,
name|temp_ext
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_ext
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Open drift file and read frequency. If the file is 		 * missing or contains errors, tell the loop to reset. 		 */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|stats_drift_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|old_drift
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"format error frequency file %s"
argument_list|,
name|stats_drift_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|old_drift
operator|/=
literal|1e6
expr_stmt|;
name|prev_drift_comp
operator|=
name|old_drift
expr_stmt|;
break|break;
comment|/* 	 * Specify statistics directory. 	 */
case|case
name|STATS_STATSDIR
case|:
comment|/* 		 * HMS: the following test is insufficient: 		 * - value may be missing the DIR_SEP 		 * - we still need the filename after it 		 */
if|if
condition|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|statsdir
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"statsdir too long (>%d, sigh)"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|statsdir
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_fp
name|now
decl_stmt|;
name|int
name|add_dir_sep
decl_stmt|;
name|int
name|value_l
init|=
name|strlen
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* Add a DIR_SEP unless we already have one. */
if|if
condition|(
name|value_l
operator|==
literal|0
condition|)
name|add_dir_sep
operator|=
literal|0
expr_stmt|;
else|else
name|add_dir_sep
operator|=
operator|(
name|DIR_SEP
operator|!=
name|value
index|[
name|value_l
operator|-
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|add_dir_sep
condition|)
name|snprintf
argument_list|(
name|statsdir
argument_list|,
sizeof|sizeof
argument_list|(
name|statsdir
argument_list|)
argument_list|,
literal|"%s%c"
argument_list|,
name|value
argument_list|,
name|DIR_SEP
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|statsdir
argument_list|,
sizeof|sizeof
argument_list|(
name|statsdir
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|peerstats
operator|.
name|prefix
operator|==
operator|&
name|statsdir
index|[
literal|0
index|]
operator|&&
name|peerstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|peerstats
operator|.
name|fp
argument_list|)
expr_stmt|;
name|peerstats
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|peerstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loopstats
operator|.
name|prefix
operator|==
operator|&
name|statsdir
index|[
literal|0
index|]
operator|&&
name|loopstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|loopstats
operator|.
name|fp
argument_list|)
expr_stmt|;
name|loopstats
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|loopstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clockstats
operator|.
name|prefix
operator|==
operator|&
name|statsdir
index|[
literal|0
index|]
operator|&&
name|clockstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|clockstats
operator|.
name|fp
argument_list|)
expr_stmt|;
name|clockstats
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|clockstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rawstats
operator|.
name|prefix
operator|==
operator|&
name|statsdir
index|[
literal|0
index|]
operator|&&
name|rawstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|rawstats
operator|.
name|fp
argument_list|)
expr_stmt|;
name|rawstats
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|rawstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sysstats
operator|.
name|prefix
operator|==
operator|&
name|statsdir
index|[
literal|0
index|]
operator|&&
name|sysstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|sysstats
operator|.
name|fp
argument_list|)
expr_stmt|;
name|sysstats
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|sysstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|protostats
operator|.
name|prefix
operator|==
operator|&
name|statsdir
index|[
literal|0
index|]
operator|&&
name|protostats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|protostats
operator|.
name|fp
argument_list|)
expr_stmt|;
name|protostats
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|protostats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|cryptostats
operator|.
name|prefix
operator|==
operator|&
name|statsdir
index|[
literal|0
index|]
operator|&&
name|cryptostats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|cryptostats
operator|.
name|fp
argument_list|)
expr_stmt|;
name|cryptostats
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|cryptostats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL */
ifdef|#
directive|ifdef
name|DEBUG_TIMING
if|if
condition|(
name|timingstats
operator|.
name|prefix
operator|==
operator|&
name|statsdir
index|[
literal|0
index|]
operator|&&
name|timingstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|timingstats
operator|.
name|fp
argument_list|)
expr_stmt|;
name|timingstats
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|timingstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG_TIMING */
block|}
break|break;
comment|/* 	 * Open pid file. 	 */
case|case
name|STATS_PID_FILE
case|:
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|value
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pid file %s: %m"
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
empty_stmt|;
break|break;
comment|/* 	 * Read leapseconds file. 	 */
case|case
name|STATS_LEAP_FILE
case|:
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|value
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"leapseconds file %s: %m"
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|leap_file
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"format error leapseconds file %s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|str1
argument_list|,
name|fstostr
argument_list|(
name|leap_sec
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str2
argument_list|,
name|fstostr
argument_list|(
name|leap_expire
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"%d leap %s expire %s"
argument_list|,
name|leap_tai
argument_list|,
name|str1
argument_list|,
name|str2
argument_list|)
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_TAI
argument_list|,
name|NULL
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* oh well */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * record_peer_stats - write peer statistics to file  *  * file format:  * day (MJD)  * time (s past UTC midnight)  * IP address  * status word (hex)  * offset  * delay  * dispersion  * jitter */
end_comment

begin_function
name|void
name|record_peer_stats
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|int
name|status
parameter_list|,
name|double
name|offset
parameter_list|,
comment|/* offset */
name|double
name|delay
parameter_list|,
comment|/* delay */
name|double
name|dispersion
parameter_list|,
comment|/* dispersion */
name|double
name|jitter
comment|/* jitter */
parameter_list|)
block|{
name|l_fp
name|now
decl_stmt|;
name|u_long
name|day
decl_stmt|;
if|if
condition|(
operator|!
name|stats_control
condition|)
return|return;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|peerstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|day
operator|=
name|now
operator|.
name|l_ui
operator|/
literal|86400
operator|+
name|MJD_1900
expr_stmt|;
name|now
operator|.
name|l_ui
operator|%=
literal|86400
expr_stmt|;
if|if
condition|(
name|peerstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|peerstats
operator|.
name|fp
argument_list|,
literal|"%lu %s %s %x %.9f %.9f %.9f %.9f\n"
argument_list|,
name|day
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|now
argument_list|,
literal|3
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|status
argument_list|,
name|offset
argument_list|,
name|delay
argument_list|,
name|dispersion
argument_list|,
name|jitter
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|peerstats
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * record_loop_stats - write loop filter statistics to file  *  * file format:  * day (MJD)  * time (s past midnight)  * offset  * frequency (PPM)  * jitter  * wnder (PPM)  * time constant (log2)  */
end_comment

begin_function
name|void
name|record_loop_stats
parameter_list|(
name|double
name|offset
parameter_list|,
comment|/* offset */
name|double
name|freq
parameter_list|,
comment|/* frequency (PPM) */
name|double
name|jitter
parameter_list|,
comment|/* jitter */
name|double
name|wander
parameter_list|,
comment|/* wander (PPM) */
name|int
name|spoll
parameter_list|)
block|{
name|l_fp
name|now
decl_stmt|;
name|u_long
name|day
decl_stmt|;
if|if
condition|(
operator|!
name|stats_control
condition|)
return|return;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|loopstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|day
operator|=
name|now
operator|.
name|l_ui
operator|/
literal|86400
operator|+
name|MJD_1900
expr_stmt|;
name|now
operator|.
name|l_ui
operator|%=
literal|86400
expr_stmt|;
if|if
condition|(
name|loopstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|loopstats
operator|.
name|fp
argument_list|,
literal|"%lu %s %.9f %.3f %.9f %.6f %d\n"
argument_list|,
name|day
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|now
argument_list|,
literal|3
argument_list|)
argument_list|,
name|offset
argument_list|,
name|freq
operator|*
literal|1e6
argument_list|,
name|jitter
argument_list|,
name|wander
operator|*
literal|1e6
argument_list|,
name|spoll
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|loopstats
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * record_clock_stats - write clock statistics to file  *  * file format:  * day (MJD)  * time (s past midnight)  * IP address  * text message  */
end_comment

begin_function
name|void
name|record_clock_stats
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|text
comment|/* timecode string */
parameter_list|)
block|{
name|l_fp
name|now
decl_stmt|;
name|u_long
name|day
decl_stmt|;
if|if
condition|(
operator|!
name|stats_control
condition|)
return|return;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|clockstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|day
operator|=
name|now
operator|.
name|l_ui
operator|/
literal|86400
operator|+
name|MJD_1900
expr_stmt|;
name|now
operator|.
name|l_ui
operator|%=
literal|86400
expr_stmt|;
if|if
condition|(
name|clockstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|clockstats
operator|.
name|fp
argument_list|,
literal|"%lu %s %s %s\n"
argument_list|,
name|day
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|now
argument_list|,
literal|3
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|clockstats
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * record_raw_stats - write raw timestamps to file  *  * file format  * day (MJD)  * time (s past midnight)  * peer ip address  * IP address  * t1 t2 t3 t4 timestamps  */
end_comment

begin_function
name|void
name|record_raw_stats
parameter_list|(
name|sockaddr_u
modifier|*
name|srcadr
parameter_list|,
name|sockaddr_u
modifier|*
name|dstadr
parameter_list|,
name|l_fp
modifier|*
name|t1
parameter_list|,
comment|/* originate timestamp */
name|l_fp
modifier|*
name|t2
parameter_list|,
comment|/* receive timestamp */
name|l_fp
modifier|*
name|t3
parameter_list|,
comment|/* transmit timestamp */
name|l_fp
modifier|*
name|t4
comment|/* destination timestamp */
parameter_list|)
block|{
name|l_fp
name|now
decl_stmt|;
name|u_long
name|day
decl_stmt|;
if|if
condition|(
operator|!
name|stats_control
condition|)
return|return;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|rawstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|day
operator|=
name|now
operator|.
name|l_ui
operator|/
literal|86400
operator|+
name|MJD_1900
expr_stmt|;
name|now
operator|.
name|l_ui
operator|%=
literal|86400
expr_stmt|;
if|if
condition|(
name|rawstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|rawstats
operator|.
name|fp
argument_list|,
literal|"%lu %s %s %s %s %s %s %s\n"
argument_list|,
name|day
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|now
argument_list|,
literal|3
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|srcadr
argument_list|)
argument_list|,
name|dstadr
condition|?
name|stoa
argument_list|(
name|dstadr
argument_list|)
else|:
literal|"-"
argument_list|,
name|ulfptoa
argument_list|(
name|t1
argument_list|,
literal|9
argument_list|)
argument_list|,
name|ulfptoa
argument_list|(
name|t2
argument_list|,
literal|9
argument_list|)
argument_list|,
name|ulfptoa
argument_list|(
name|t3
argument_list|,
literal|9
argument_list|)
argument_list|,
name|ulfptoa
argument_list|(
name|t4
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rawstats
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * record_sys_stats - write system statistics to file  *  * file format  * day (MJD)  * time (s past midnight)  * time since reset  * packets recieved  * packets for this host  * current version  * old version  * access denied  * bad length or format  * bad authentication  * declined  * rate exceeded  * KoD sent  */
end_comment

begin_function
name|void
name|record_sys_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|now
decl_stmt|;
name|u_long
name|day
decl_stmt|;
if|if
condition|(
operator|!
name|stats_control
condition|)
return|return;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|sysstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|day
operator|=
name|now
operator|.
name|l_ui
operator|/
literal|86400
operator|+
name|MJD_1900
expr_stmt|;
name|now
operator|.
name|l_ui
operator|%=
literal|86400
expr_stmt|;
if|if
condition|(
name|sysstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|sysstats
operator|.
name|fp
argument_list|,
literal|"%lu %s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n"
argument_list|,
name|day
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|now
argument_list|,
literal|3
argument_list|)
argument_list|,
name|current_time
operator|-
name|sys_stattime
argument_list|,
name|sys_received
argument_list|,
name|sys_processed
argument_list|,
name|sys_newversion
argument_list|,
name|sys_oldversion
argument_list|,
name|sys_restricted
argument_list|,
name|sys_badlength
argument_list|,
name|sys_badauth
argument_list|,
name|sys_declined
argument_list|,
name|sys_limitrejected
argument_list|,
name|sys_kodsent
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|sysstats
operator|.
name|fp
argument_list|)
expr_stmt|;
name|proto_clr_stats
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * record_proto_stats - write system statistics to file  *  * file format  * day (MJD)  * time (s past midnight)  * text message  */
end_comment

begin_function
name|void
name|record_proto_stats
parameter_list|(
name|char
modifier|*
name|str
comment|/* text string */
parameter_list|)
block|{
name|l_fp
name|now
decl_stmt|;
name|u_long
name|day
decl_stmt|;
if|if
condition|(
operator|!
name|stats_control
condition|)
return|return;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|protostats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|day
operator|=
name|now
operator|.
name|l_ui
operator|/
literal|86400
operator|+
name|MJD_1900
expr_stmt|;
name|now
operator|.
name|l_ui
operator|%=
literal|86400
expr_stmt|;
if|if
condition|(
name|protostats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|protostats
operator|.
name|fp
argument_list|,
literal|"%lu %s %s\n"
argument_list|,
name|day
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|now
argument_list|,
literal|3
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|protostats
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_comment
comment|/*  * record_crypto_stats - write crypto statistics to file  *  * file format:  * day (mjd)  * time (s past midnight)  * peer ip address  * text message  */
end_comment

begin_function
name|void
name|record_crypto_stats
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|text
comment|/* text message */
parameter_list|)
block|{
name|l_fp
name|now
decl_stmt|;
name|u_long
name|day
decl_stmt|;
if|if
condition|(
operator|!
name|stats_control
condition|)
return|return;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|cryptostats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|day
operator|=
name|now
operator|.
name|l_ui
operator|/
literal|86400
operator|+
name|MJD_1900
expr_stmt|;
name|now
operator|.
name|l_ui
operator|%=
literal|86400
expr_stmt|;
if|if
condition|(
name|cryptostats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|cryptostats
operator|.
name|fp
argument_list|,
literal|"%lu %s 0.0.0.0 %s\n"
argument_list|,
name|day
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|now
argument_list|,
literal|3
argument_list|)
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|cryptostats
operator|.
name|fp
argument_list|,
literal|"%lu %s %s %s\n"
argument_list|,
name|day
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|now
argument_list|,
literal|3
argument_list|)
argument_list|,
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|cryptostats
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_TIMING
end_ifdef

begin_comment
comment|/*  * record_timing_stats - write timing statistics to file  *  * file format:  * day (mjd)  * time (s past midnight)  * text message  */
end_comment

begin_function
name|void
name|record_timing_stats
parameter_list|(
specifier|const
name|char
modifier|*
name|text
comment|/* text message */
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
name|flshcnt
decl_stmt|;
name|l_fp
name|now
decl_stmt|;
name|u_long
name|day
decl_stmt|;
if|if
condition|(
operator|!
name|stats_control
condition|)
return|return;
name|get_systime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|filegen_setup
argument_list|(
operator|&
name|timingstats
argument_list|,
name|now
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|day
operator|=
name|now
operator|.
name|l_ui
operator|/
literal|86400
operator|+
name|MJD_1900
expr_stmt|;
name|now
operator|.
name|l_ui
operator|%=
literal|86400
expr_stmt|;
if|if
condition|(
name|timingstats
operator|.
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|timingstats
operator|.
name|fp
argument_list|,
literal|"%lu %s %s\n"
argument_list|,
name|day
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|now
argument_list|,
literal|3
argument_list|)
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|flshcnt
operator|%
literal|100
operator|==
literal|0
condition|)
name|fflush
argument_list|(
name|timingstats
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * leap_file - read leapseconds file  *  * Read the ERTS leapsecond file in NIST text format and extract the  * NTP seconds of the latest leap and TAI offset after the leap.  */
end_comment

begin_function
specifier|static
name|int
name|leap_file
parameter_list|(
name|FILE
modifier|*
name|fp
comment|/* file handle */
parameter_list|)
block|{
name|char
name|buf
index|[
name|NTP_MAXSTRLEN
index|]
decl_stmt|;
comment|/* file line buffer */
name|u_long
name|leap
decl_stmt|;
comment|/* NTP time at leap */
name|u_long
name|expire
decl_stmt|;
comment|/* NTP time when file expires */
name|int
name|offset
decl_stmt|;
comment|/* TAI offset at leap (s) */
name|int
name|i
decl_stmt|;
comment|/* 	 * Read and parse the leapseconds file. Empty lines and comments 	 * are ignored. A line beginning with #@ contains the file 	 * expiration time in NTP seconds. Other lines begin with two 	 * integers followed by junk or comments. The first integer is 	 * the NTP seconds at the leap, the second is the TAI offset 	 * after the leap.  	 */
name|offset
operator|=
literal|0
expr_stmt|;
name|leap
operator|=
literal|0
expr_stmt|;
name|expire
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|NTP_MAXSTRLEN
operator|-
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|<
literal|1
condition|)
continue|continue;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|<
literal|3
condition|)
continue|continue;
comment|/* 			 * Note the '@' flag was used only in the 2006 			 * table; previious to that the flag was '$'. 			 */
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'@'
operator|||
name|buf
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|expire
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
continue|continue;
block|}
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%lu %d"
argument_list|,
operator|&
name|leap
argument_list|,
operator|&
name|offset
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* 			 * Valid offsets must increase by one for each 			 * leap. 			 */
if|if
condition|(
name|i
operator|++
operator|!=
name|offset
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * There must be at least one leap. 	 */
if|if
condition|(
name|i
operator|==
literal|10
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|leap_tai
operator|=
name|offset
expr_stmt|;
name|leap_sec
operator|=
name|leap
expr_stmt|;
name|leap_expire
operator|=
name|expire
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * leap_month - returns seconds until the end of the month.  */
end_comment

begin_function
name|u_long
name|leap_month
parameter_list|(
name|u_long
name|sec
comment|/* current NTP second */
parameter_list|)
block|{
name|u_long
name|ltemp
decl_stmt|;
name|u_long
modifier|*
name|ptr
decl_stmt|;
name|u_long
name|year
index|[]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
name|u_long
name|lyear
index|[]
init|=
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
comment|/* 	 * Find current leap cycle. 	 */
name|ltemp
operator|=
name|sec
expr_stmt|;
while|while
condition|(
name|ltemp
operator|>=
name|L_CENT
condition|)
name|ltemp
operator|-=
name|L_CENT
expr_stmt|;
while|while
condition|(
name|ltemp
operator|>=
name|L_4YEAR
condition|)
name|ltemp
operator|-=
name|L_4YEAR
expr_stmt|;
comment|/* 	 * We are within four years of the target. If in leap year, use 	 * leap year month table; otherwise, use year month table. 	 */
if|if
condition|(
name|ltemp
operator|<
name|L_LYEAR
condition|)
block|{
name|ptr
operator|=
name|lyear
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|year
expr_stmt|;
name|ltemp
operator|-=
name|L_LYEAR
expr_stmt|;
while|while
condition|(
name|ltemp
operator|>=
name|L_YEAR
condition|)
name|ltemp
operator|-=
name|L_YEAR
expr_stmt|;
block|}
comment|/* 	 * We are within one year of the target. Find the month of the 	 * leap. 	 */
while|while
condition|(
name|ltemp
operator|>=
operator|*
name|ptr
operator|*
name|L_DAY
condition|)
name|ltemp
operator|-=
operator|*
name|ptr
operator|++
operator|*
name|L_DAY
expr_stmt|;
comment|/* 	 * The result is the number of seconds until the end of the 	 * month when the leap is to occur. 	 */
return|return
operator|(
operator|*
name|ptr
operator|*
name|L_DAY
operator|-
name|ltemp
operator|-
name|L_DAY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getauthkeys - read the authentication keys from the specified file  */
end_comment

begin_function
name|void
name|getauthkeys
parameter_list|(
specifier|const
name|char
modifier|*
name|keyfile
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|keyfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return;
ifndef|#
directive|ifndef
name|SYS_WINNT
name|key_file_name
operator|=
name|erealloc
argument_list|(
name|key_file_name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|key_file_name
argument_list|,
name|keyfile
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|key_file_name
operator|=
name|erealloc
argument_list|(
name|key_file_name
argument_list|,
name|_MAX_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|_MAX_PATH
condition|)
return|return;
if|if
condition|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
name|keyfile
argument_list|,
name|key_file_name
argument_list|,
name|_MAX_PATH
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings(KEY_FILE) failed: %m"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|key_file_name
argument_list|,
name|keyfile
argument_list|,
name|_MAX_PATH
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
name|authreadkeys
argument_list|(
name|key_file_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rereadkeys - read the authentication key file over again.  */
end_comment

begin_function
name|void
name|rereadkeys
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|key_file_name
condition|)
name|authreadkeys
argument_list|(
name|key_file_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sock_hash - hash a sockaddr_u structure  */
end_comment

begin_function
name|u_short
name|sock_hash
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
name|u_int
name|hashVal
decl_stmt|;
name|u_int
name|j
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_char
modifier|*
name|pch
decl_stmt|;
name|hashVal
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We can't just hash the whole thing because there are hidden 	 * fields in sockaddr_in6 that might be filled in by recvfrom(), 	 * so just use the family, port and address. 	 */
name|pch
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|AF
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|hashVal
operator|=
literal|37
operator|*
name|hashVal
operator|+
operator|*
name|pch
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|AF
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|pch
operator|++
expr_stmt|;
name|hashVal
operator|=
literal|37
operator|*
name|hashVal
operator|+
operator|*
name|pch
expr_stmt|;
block|}
switch|switch
condition|(
name|AF
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|AF_INET
case|:
name|pch
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|SOCK_ADDR4
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|SOCK_ADDR4
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|pch
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|SOCK_ADDR6
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|SOCK_ADDR6
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
name|hashVal
operator|=
literal|37
operator|*
name|hashVal
operator|+
name|pch
index|[
name|j
index|]
expr_stmt|;
name|hashVal
operator|=
name|hashVal
operator|&
name|NTP_HASH_MASK
expr_stmt|;
return|return
operator|(
name|u_short
operator|)
name|hashVal
return|;
block|}
end_function

begin_if
if|#
directive|if
name|notyet
end_if

begin_comment
comment|/*  * ntp_exit - document explicitly that ntpd has exited  */
end_comment

begin_function
name|void
name|ntp_exit
parameter_list|(
name|int
name|retval
parameter_list|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"EXITING with return code %d"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * fstostr - prettyprint NTP seconds  */
end_comment

begin_function
name|char
modifier|*
name|fstostr
parameter_list|(
name|time_t
name|ntp_stamp
parameter_list|)
block|{
specifier|static
name|char
name|str
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|unix_stamp
decl_stmt|;
name|unix_stamp
operator|=
name|ntp_stamp
operator|-
name|JAN_1970
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|unix_stamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|tm
condition|)
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%04d%02d%02d%02d%02d"
argument_list|,
name|tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|str
argument_list|,
literal|"gmtime() error"
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

end_unit

