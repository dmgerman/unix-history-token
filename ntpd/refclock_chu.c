begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_chu - clock driver for Canadian CHU time/frequency station  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_CHU
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_include
include|#
directive|include
file|"audio.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_define
define|#
directive|define
name|ICOM
value|1
end_define

begin_comment
comment|/* undefine to suppress ICOM code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_include
include|#
directive|include
file|"icom.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * Audio CHU demodulator/decoder  *  * This driver synchronizes the computer time using data encoded in  * radio transmissions from Canadian time/frequency station CHU in  * Ottawa, Ontario. Transmissions are made continuously on 3330 kHz,  * 7850 kHz and 14670 kHz in upper sideband, compatible AM mode. An  * ordinary shortwave receiver can be tuned manually to one of these  * frequencies or, in the case of ICOM receivers, the receiver can be  * tuned automatically as propagation conditions change throughout the  * day and season.  *  * The driver requires an audio codec or sound card with sampling rate 8  * kHz and mu-law companding. This is the same standard as used by the  * telephone industry and is supported by most hardware and operating  * systems, including Solaris, SunOS, FreeBSD, NetBSD and Linux. In this  * implementation, only one audio driver and codec can be supported on a  * single machine.  *  * The driver can be compiled to use a Bell 103 compatible modem or  * modem chip to receive the radio signal and demodulate the data.  * Alternatively, the driver can be compiled to use the audio codec of  * the workstation or another with compatible audio drivers. In the  * latter case, the driver implements the modem using DSP routines, so  * the radio can be connected directly to either the microphone on line  * input port. In either case, the driver decodes the data using a  * maximum-likelihood technique which exploits the considerable degree  * of redundancy available to maximize accuracy and minimize errors.  *  * The CHU time broadcast includes an audio signal compatible with the  * Bell 103 modem standard (mark = 2225 Hz, space = 2025 Hz). The signal  * consists of nine, ten-character bursts transmitted at 300 bps between  * seconds 31 and 39 of each minute. Each character consists of eight  * data bits plus one start bit and two stop bits to encode two hex  * digits. The burst data consist of five characters (ten hex digits)  * followed by a repeat of these characters. In format A, the characters  * are repeated in the same polarity; in format B, the characters are  * repeated in the opposite polarity.  *  * Format A bursts are sent at seconds 32 through 39 of the minute in  * hex digits (nibble swapped)  *  *	6dddhhmmss6dddhhmmss  *  * The first ten digits encode a frame marker (6) followed by the day  * (ddd), hour (hh in UTC), minute (mm) and the second (ss). Since  * format A bursts are sent during the third decade of seconds the tens  * digit of ss is always 3. The driver uses this to determine correct  * burst synchronization. These digits are then repeated with the same  * polarity.  *  * Format B bursts are sent at second 31 of the minute in hex digits  *  *	xdyyyyttaaxdyyyyttaa  *  * The first ten digits encode a code (x described below) followed by  * the DUT1 (d in deciseconds), Gregorian year (yyyy), difference TAI -  * UTC (tt) and daylight time indicator (aa) peculiar to Canada. These  * digits are then repeated with inverted polarity.  *  * The x is coded  *  * 1 Sign of DUT (0 = +)  * 2 Leap second warning. One second will be added.  * 4 Leap second warning. One second will be subtracted.  * 8 Even parity bit for this nibble.  *  * By design, the last stop bit of the last character in the burst  * coincides with 0.5 second. Since characters have 11 bits and are  * transmitted at 300 bps, the last stop bit of the first character  * coincides with 0.5 - 9 * 11/300 = 0.170 second. Depending on the  * UART, character interrupts can vary somewhere between the end of bit  * 9 and end of bit 11. These eccentricities can be corrected along with  * the radio propagation delay using fudge time 1.  *  * Debugging aids  *  * The timecode format used for debugging and data recording includes  * data helpful in diagnosing problems with the radio signal and serial  * connections. With debugging enabled (-d on the ntpd command line),  * the driver produces one line for each burst in two formats  * corresponding to format A and B.Each line begins with the format code  * chuA or chuB followed by the status code and signal level (0-9999).  * The remainder of the line is as follows.  *  * Following is format A:  *  *	n b f s m code  *  * where n is the number of characters in the burst (0-10), b the burst  * distance (0-40), f the field alignment (-1, 0, 1), s the  * synchronization distance (0-16), m the burst number (2-9) and code  * the burst characters as received. Note that the hex digits in each  * character are reversed, so the burst  *  *	10 38 0 16 9 06851292930685129293  *  * is interpreted as containing 10 characters with burst distance 38,  * field alignment 0, synchronization distance 16 and burst number 9.  * The nibble-swapped timecode shows day 58, hour 21, minute 29 and  * second 39.  *  * Following is format B:  *   *	n b s code  *  * where n is the number of characters in the burst (0-10), b the burst  * distance (0-40), s the synchronization distance (0-40) and code the  * burst characters as received. Note that the hex digits in each  * character are reversed and the last ten digits inverted, so the burst  *  *	10 40 1091891300ef6e76ec  *  * is interpreted as containing 10 characters with burst distance 40.  * The nibble-swapped timecode shows DUT1 +0.1 second, year 1998 and TAI  * - UTC 31 seconds.  *  * Each line is preceeded by the code chuA or chuB, as appropriate. If  * the audio driver is compiled, the current gain (0-255) and relative  * signal level (0-9999) follow the code. The receiver volume control  * should be set so that the gain is somewhere near the middle of the  * range 0-255, which results in a signal level near 1000.  *  * In addition to the above, the reference timecode is updated and  * written to the clockstats file and debug score after the last burst  * received in the minute. The format is  *  *	sq yyyy ddd hh:mm:ss l s dd t agc ident m b        *  * s	'?' before first synchronized and ' ' after that  * q	status code (see below)  * yyyy	year  * ddd	day of year  * hh:mm:ss time of day  * l	leap second indicator (space, L or D)  * dst	Canadian daylight code (opaque)  * t	number of minutes since last synchronized  * agc	audio gain (0 - 255)  * ident identifier (CHU0 3330 kHz, CHU1 7850 kHz, CHU2 14670 kHz)  * m	signal metric (0 - 100)  * b	number of timecodes for the previous minute (0 - 59)  *  * Fudge factors  *  * For accuracies better than the low millisceconds, fudge time1 can be  * set to the radio propagation delay from CHU to the receiver. This can  * be done conviently using the minimuf program.  *  * Fudge flag4 causes the dubugging output described above to be  * recorded in the clockstats file. When the audio driver is compiled,  * fudge flag2 selects the audio input port, where 0 is the mike port  * (default) and 1 is the line-in port. It does not seem useful to  * select the compact disc player port. Fudge flag3 enables audio  * monitoring of the input signal. For this purpose, the monitor gain is  * set to a default value.  *  * The audio codec code is normally compiled in the driver if the  * architecture supports it (HAVE_AUDIO defined), but is used only if  * the link /dev/chu_audio is defined and valid. The serial port code is  * always compiled in the driver, but is used only if the autdio codec  * is not available and the link /dev/chu%d is defined and valid.  *  * The ICOM code is normally compiled in the driver if selected (ICOM  * defined), but is used only if the link /dev/icom%d is defined and  * valid and the mode keyword on the server configuration command  * specifies a nonzero mode (ICOM ID select code). The C-IV speed is  * 9600 bps if the high order 0x80 bit of the mode is zero and 1200 bps  * if one. The C-IV trace is turned on if the debug level is greater  * than one.  *  * Alarm codes  *  * CEVNT_BADTIME	invalid date or time  * CEVNT_PROP		propagation failure - no stations heard  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B300
end_define

begin_comment
comment|/* uart speed (300 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"CHU"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/chu%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B300
end_define

begin_comment
comment|/* UART speed (300 baud) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_define
define|#
directive|define
name|TUNE
value|.001
end_define

begin_comment
comment|/* offset for narrow filter (MHz) */
end_comment

begin_define
define|#
directive|define
name|DWELL
value|5
end_define

begin_comment
comment|/* minutes in a dwell */
end_comment

begin_define
define|#
directive|define
name|NCHAN
value|3
end_define

begin_comment
comment|/* number of channels */
end_comment

begin_define
define|#
directive|define
name|ISTAGE
value|3
end_define

begin_comment
comment|/* number of integrator stages */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_comment
comment|/*  * Audio demodulator definitions  */
end_comment

begin_define
define|#
directive|define
name|SECOND
value|8000
end_define

begin_comment
comment|/* nominal sample rate (Hz) */
end_comment

begin_define
define|#
directive|define
name|BAUD
value|300
end_define

begin_comment
comment|/* modulation rate (bps) */
end_comment

begin_define
define|#
directive|define
name|OFFSET
value|128
end_define

begin_comment
comment|/* companded sample offset */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|256
end_define

begin_comment
comment|/* decompanding table size */
end_comment

begin_define
define|#
directive|define
name|MAXAMP
value|6000.
end_define

begin_comment
comment|/* maximum signal level */
end_comment

begin_define
define|#
directive|define
name|MAXCLP
value|100
end_define

begin_comment
comment|/* max clips above reference per s */
end_comment

begin_define
define|#
directive|define
name|SPAN
value|800.
end_define

begin_comment
comment|/* min envelope span */
end_comment

begin_define
define|#
directive|define
name|LIMIT
value|1000.
end_define

begin_comment
comment|/* soft limiter threshold */
end_comment

begin_define
define|#
directive|define
name|AGAIN
value|6.
end_define

begin_comment
comment|/* baseband gain */
end_comment

begin_define
define|#
directive|define
name|LAG
value|10
end_define

begin_comment
comment|/* discriminator lag */
end_comment

begin_define
define|#
directive|define
name|DEVICE_AUDIO
value|"/dev/audio"
end_define

begin_comment
comment|/* device name */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"CHU Audio/Modem Receiver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|AUDIO_BUFSIZ
value|240
end_define

begin_comment
comment|/* audio buffer size (30 ms) */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DESCRIPTION
value|"CHU Modem Receiver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_comment
comment|/*  * Decoder definitions  */
end_comment

begin_define
define|#
directive|define
name|CHAR
value|(11. / 300.)
end_define

begin_comment
comment|/* character time (s) */
end_comment

begin_define
define|#
directive|define
name|BURST
value|11
end_define

begin_comment
comment|/* max characters per burst */
end_comment

begin_define
define|#
directive|define
name|MINCHARS
value|9
end_define

begin_comment
comment|/* min characters per burst */
end_comment

begin_define
define|#
directive|define
name|MINDIST
value|28
end_define

begin_comment
comment|/* min burst distance (of 40)  */
end_comment

begin_define
define|#
directive|define
name|MINSYNC
value|8
end_define

begin_comment
comment|/* min sync distance (of 16) */
end_comment

begin_define
define|#
directive|define
name|MINSTAMP
value|20
end_define

begin_comment
comment|/* min timestamps (of 60) */
end_comment

begin_define
define|#
directive|define
name|MINMETRIC
value|50
end_define

begin_comment
comment|/* min channel metric (of 160) */
end_comment

begin_comment
comment|/*  * The on-time synchronization point for the driver is the last stop bit  * of the first character 170 ms. The modem delay is 0.8 ms, while the  * receiver delay is approxmately 4.7 ms at 2125 Hz. The fudge value 1.3  * ms due to the codec and other causes was determined by calibrating to  * a PPS signal from a GPS receiver. The additional propagation delay  * specific to each receiver location can be programmed in the fudge  * time1.   *  * The resulting offsets with a 2.4-GHz P4 running FreeBSD 6.1 are  * generally within 0.5 ms short term with 0.3 ms jitter. The long-term  * offsets vary up to 0.3 ms due to ionospheric layer height variations.  * The processor load due to the driver is 0.4 percent.  */
end_comment

begin_define
define|#
directive|define
name|PDELAY
value|((170 + .8 + 4.7 + 1.3) / 1000)
end_define

begin_comment
comment|/* system delay (s) */
end_comment

begin_comment
comment|/*  * Status bits (status)  */
end_comment

begin_define
define|#
directive|define
name|RUNT
value|0x0001
end_define

begin_comment
comment|/* runt burst */
end_comment

begin_define
define|#
directive|define
name|NOISE
value|0x0002
end_define

begin_comment
comment|/* noise burst */
end_comment

begin_define
define|#
directive|define
name|BFRAME
value|0x0004
end_define

begin_comment
comment|/* invalid format B frame sync */
end_comment

begin_define
define|#
directive|define
name|BFORMAT
value|0x0008
end_define

begin_comment
comment|/* invalid format B data */
end_comment

begin_define
define|#
directive|define
name|AFRAME
value|0x0010
end_define

begin_comment
comment|/* invalid format A frame sync */
end_comment

begin_define
define|#
directive|define
name|AFORMAT
value|0x0020
end_define

begin_comment
comment|/* invalid format A data */
end_comment

begin_define
define|#
directive|define
name|DECODE
value|0x0040
end_define

begin_comment
comment|/* invalid data decode */
end_comment

begin_define
define|#
directive|define
name|STAMP
value|0x0080
end_define

begin_comment
comment|/* too few timestamps */
end_comment

begin_define
define|#
directive|define
name|AVALID
value|0x0100
end_define

begin_comment
comment|/* valid A frame */
end_comment

begin_define
define|#
directive|define
name|BVALID
value|0x0200
end_define

begin_comment
comment|/* valid B frame */
end_comment

begin_define
define|#
directive|define
name|INSYNC
value|0x0400
end_define

begin_comment
comment|/* clock synchronized */
end_comment

begin_define
define|#
directive|define
name|METRIC
value|0x0800
end_define

begin_comment
comment|/* one or more stations heard */
end_comment

begin_comment
comment|/*  * Alarm status bits (alarm)  *  * These alarms are set at the end of a minute in which at least one  * burst was received. SYNERR is raised if the AFRAME or BFRAME status  * bits are set during the minute, FMTERR is raised if the AFORMAT or  * BFORMAT status bits are set, DECERR is raised if the DECODE status  * bit is set and TSPERR is raised if the STAMP status bit is set.  */
end_comment

begin_define
define|#
directive|define
name|SYNERR
value|0x01
end_define

begin_comment
comment|/* frame sync error */
end_comment

begin_define
define|#
directive|define
name|FMTERR
value|0x02
end_define

begin_comment
comment|/* data format error */
end_comment

begin_define
define|#
directive|define
name|DECERR
value|0x04
end_define

begin_comment
comment|/* data decoding error */
end_comment

begin_define
define|#
directive|define
name|TSPERR
value|0x08
end_define

begin_comment
comment|/* insufficient data */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_comment
comment|/*  * Maximum-likelihood UART structure. There are eight of these  * corresponding to the number of phases.  */
end_comment

begin_struct
struct|struct
name|surv
block|{
name|l_fp
name|cstamp
decl_stmt|;
comment|/* last bit timestamp */
name|double
name|shift
index|[
literal|12
index|]
decl_stmt|;
comment|/* sample shift register */
name|double
name|span
decl_stmt|;
comment|/* shift register envelope span */
name|double
name|dist
decl_stmt|;
comment|/* sample distance */
name|int
name|uart
decl_stmt|;
comment|/* decoded character */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_comment
comment|/*  * CHU station structure. There are three of these corresponding to the  * three frequencies.  */
end_comment

begin_struct
struct|struct
name|xmtr
block|{
name|double
name|integ
index|[
name|ISTAGE
index|]
decl_stmt|;
comment|/* circular integrator */
name|double
name|metric
decl_stmt|;
comment|/* integrator sum */
name|int
name|iptr
decl_stmt|;
comment|/* integrator pointer */
name|int
name|probe
decl_stmt|;
comment|/* dwells since last probe */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * CHU unit control structure  */
end_comment

begin_struct
struct|struct
name|chuunit
block|{
name|u_char
name|decode
index|[
literal|20
index|]
index|[
literal|16
index|]
decl_stmt|;
comment|/* maximum-likelihood decoding matrix */
name|l_fp
name|cstamp
index|[
name|BURST
index|]
decl_stmt|;
comment|/* character timestamps */
name|l_fp
name|tstamp
index|[
name|MAXSTAGE
index|]
decl_stmt|;
comment|/* timestamp samples */
name|l_fp
name|timestamp
decl_stmt|;
comment|/* current buffer timestamp */
name|l_fp
name|laststamp
decl_stmt|;
comment|/* last buffer timestamp */
name|l_fp
name|charstamp
decl_stmt|;
comment|/* character time as a l_fp */
name|int
name|second
decl_stmt|;
comment|/* counts the seconds of the minute */
name|int
name|errflg
decl_stmt|;
comment|/* error flags */
name|int
name|status
decl_stmt|;
comment|/* status bits */
name|char
name|ident
index|[
literal|5
index|]
decl_stmt|;
comment|/* station ID and channel */
ifdef|#
directive|ifdef
name|ICOM
name|int
name|fd_icom
decl_stmt|;
comment|/* ICOM file descriptor */
name|int
name|chan
decl_stmt|;
comment|/* radio channel */
name|int
name|dwell
decl_stmt|;
comment|/* dwell cycle */
name|struct
name|xmtr
name|xmtr
index|[
name|NCHAN
index|]
decl_stmt|;
comment|/* station metric */
endif|#
directive|endif
comment|/* ICOM */
comment|/* 	 * Character burst variables 	 */
name|int
name|cbuf
index|[
name|BURST
index|]
decl_stmt|;
comment|/* character buffer */
name|int
name|ntstamp
decl_stmt|;
comment|/* number of timestamp samples */
name|int
name|ndx
decl_stmt|;
comment|/* buffer start index */
name|int
name|prevsec
decl_stmt|;
comment|/* previous burst second */
name|int
name|burdist
decl_stmt|;
comment|/* burst distance */
name|int
name|syndist
decl_stmt|;
comment|/* sync distance */
name|int
name|burstcnt
decl_stmt|;
comment|/* format A bursts this minute */
name|double
name|maxsignal
decl_stmt|;
comment|/* signal level (modem only) */
name|int
name|gain
decl_stmt|;
comment|/* codec gain (modem only) */
comment|/* 	 * Format particulars 	 */
name|int
name|leap
decl_stmt|;
comment|/* leap/dut code */
name|int
name|dut
decl_stmt|;
comment|/* UTC1 correction */
name|int
name|tai
decl_stmt|;
comment|/* TAI - UTC correction */
name|int
name|dst
decl_stmt|;
comment|/* Canadian DST code */
ifdef|#
directive|ifdef
name|HAVE_AUDIO
comment|/* 	 * Audio codec variables 	 */
name|int
name|fd_audio
decl_stmt|;
comment|/* audio port file descriptor */
name|double
name|comp
index|[
name|SIZE
index|]
decl_stmt|;
comment|/* decompanding table */
name|int
name|port
decl_stmt|;
comment|/* codec port */
name|int
name|mongain
decl_stmt|;
comment|/* codec monitor gain */
name|int
name|clipcnt
decl_stmt|;
comment|/* sample clip count */
name|int
name|seccnt
decl_stmt|;
comment|/* second interval counter */
comment|/* 	 * Modem variables 	 */
name|l_fp
name|tick
decl_stmt|;
comment|/* audio sample increment */
name|double
name|bpf
index|[
literal|9
index|]
decl_stmt|;
comment|/* IIR bandpass filter */
name|double
name|disc
index|[
name|LAG
index|]
decl_stmt|;
comment|/* discriminator shift register */
name|double
name|lpf
index|[
literal|27
index|]
decl_stmt|;
comment|/* FIR lowpass filter */
name|double
name|monitor
decl_stmt|;
comment|/* audio monitor */
name|int
name|discptr
decl_stmt|;
comment|/* discriminator pointer */
comment|/* 	 * Maximum-likelihood UART variables 	 */
name|double
name|baud
decl_stmt|;
comment|/* baud interval */
name|struct
name|surv
name|surv
index|[
literal|8
index|]
decl_stmt|;
comment|/* UART survivor structures */
name|int
name|decptr
decl_stmt|;
comment|/* decode pointer */
name|int
name|decpha
decl_stmt|;
comment|/* decode phase */
name|int
name|dbrk
decl_stmt|;
comment|/* holdoff counter */
endif|#
directive|endif
comment|/* HAVE_AUDIO */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|chu_start
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_shutdown
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_second
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_poll
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * More function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|chu_decode
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|int
parameter_list|,
name|l_fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_burst
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_clear
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_a
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_b
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chu_dist
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|chu_major
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_function_decl
specifier|static
name|void
name|chu_uart
parameter_list|(
name|struct
name|surv
modifier|*
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_rf
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_gain
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chu_audio_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_function_decl
specifier|static
name|int
name|chu_newchan
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_function_decl
specifier|static
name|void
name|chu_serial_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hexchar
index|[]
init|=
literal|"0123456789abcdef_*="
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_comment
comment|/*  * Note the tuned frequencies are 1 kHz higher than the carrier. CHU  * transmits on USB with carrier so we can use AM and the narrow SSB  * filter.  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|qsy
index|[
name|NCHAN
index|]
init|=
block|{
literal|3.330
block|,
literal|7.850
block|,
literal|14.670
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* freq (MHz) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_chu
init|=
block|{
name|chu_start
block|,
comment|/* start up driver */
name|chu_shutdown
block|,
comment|/* shut down driver */
name|chu_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old chu_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old chu_buginfo) */
name|chu_second
comment|/* housekeeping timer */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * chu_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|chu_start
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* device name */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
ifdef|#
directive|ifdef
name|ICOM
name|int
name|temp
decl_stmt|;
endif|#
directive|endif
comment|/* ICOM */
ifdef|#
directive|ifdef
name|HAVE_AUDIO
name|int
name|fd_audio
decl_stmt|;
comment|/* audio port file descriptor */
name|int
name|i
decl_stmt|;
comment|/* index */
name|double
name|step
decl_stmt|;
comment|/* codec adjustment */
comment|/* 	 * Open audio device. Don't complain if not there. 	 */
name|fd_audio
operator|=
name|audio_init
argument_list|(
name|DEVICE_AUDIO
argument_list|,
name|AUDIO_BUFSIZ
argument_list|,
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|fd_audio
operator|>=
literal|0
operator|&&
name|debug
condition|)
name|audio_show
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If audio is unavailable, Open serial port in raw mode. 	 */
if|if
condition|(
name|fd_audio
operator|>=
literal|0
condition|)
block|{
name|fd
operator|=
name|fd_audio
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_RAW
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* HAVE_AUDIO */
comment|/* 	 * Open serial port in raw mode. 	 */
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_RAW
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUDIO */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
name|up
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|chu_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|strlcpy
argument_list|(
name|up
operator|->
name|ident
argument_list|,
literal|"CHU"
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|ident
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|up
operator|->
name|ident
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DTOLFP
argument_list|(
name|CHAR
argument_list|,
operator|&
name|up
operator|->
name|charstamp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AUDIO
comment|/* 	 * The companded samples are encoded sign-magnitude. The table 	 * contains all the 256 values in the interest of speed. We do 	 * this even if the audio codec is not available. C'est la lazy. 	 */
name|up
operator|->
name|fd_audio
operator|=
name|fd_audio
expr_stmt|;
name|up
operator|->
name|gain
operator|=
literal|127
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|0
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|OFFSET
index|]
operator|=
literal|0.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|1
index|]
operator|=
operator|-
literal|1.
expr_stmt|;
name|up
operator|->
name|comp
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
literal|2
index|]
operator|=
operator|-
literal|3.
expr_stmt|;
name|step
operator|=
literal|2.
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|OFFSET
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|comp
index|[
name|i
index|]
operator|=
name|up
operator|->
name|comp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|step
expr_stmt|;
name|up
operator|->
name|comp
index|[
name|OFFSET
operator|+
name|i
index|]
operator|=
operator|-
name|up
operator|->
name|comp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
name|step
operator|*=
literal|2.
expr_stmt|;
block|}
name|DTOLFP
argument_list|(
literal|1.
operator|/
name|SECOND
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUDIO */
ifdef|#
directive|ifdef
name|ICOM
name|temp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|temp
operator|=
name|P_TRACE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|ttl
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|ttl
operator|&
literal|0x80
condition|)
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B1200
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|fd_icom
operator|=
name|icom_init
argument_list|(
literal|"/dev/icom"
argument_list|,
name|B9600
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|chu_newchan
argument_list|(
name|peer
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"icom: radio not found"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
name|up
operator|->
name|fd_icom
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"icom: autotune enabled"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ICOM */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * chu_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|chu_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
comment|/* instance number (not used) */
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|==
name|NULL
condition|)
return|return;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICOM
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|>
literal|0
condition|)
name|close
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ICOM */
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_receive - receive data from the audio or serial device  */
end_comment

begin_function
specifier|static
name|void
name|chu_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_AUDIO
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|peer
operator|=
name|rbufp
operator|->
name|recv_peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * If the audio codec is warmed up, the buffer contains codec 	 * samples which need to be demodulated and decoded into CHU 	 * characters using the software UART. Otherwise, the buffer 	 * contains CHU characters from the serial port, so the software 	 * UART is bypassed. In this case the CPU will probably run a 	 * few degrees cooler. 	 */
if|if
condition|(
name|up
operator|->
name|fd_audio
operator|>
literal|0
condition|)
name|chu_audio_receive
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
else|else
name|chu_serial_receive
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
else|#
directive|else
name|chu_serial_receive
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AUDIO */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_comment
comment|/*  * chu_audio_receive - receive data from the audio device  */
end_comment

begin_function
specifier|static
name|void
name|chu_audio_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|double
name|sample
decl_stmt|;
comment|/* codec sample */
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* buffer pointer */
name|int
name|bufcnt
decl_stmt|;
comment|/* buffer counter */
name|l_fp
name|ltemp
decl_stmt|;
comment|/* l_fp temp */
name|peer
operator|=
name|rbufp
operator|->
name|recv_peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Main loop - read until there ain't no more. Note codec 	 * samples are bit-inverted. 	 */
name|DTOLFP
argument_list|(
operator|(
name|double
operator|)
name|rbufp
operator|->
name|recv_length
operator|/
name|SECOND
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|ltemp
argument_list|)
expr_stmt|;
name|up
operator|->
name|timestamp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|dpt
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
for|for
control|(
name|bufcnt
operator|=
literal|0
init|;
name|bufcnt
operator|<
name|rbufp
operator|->
name|recv_length
condition|;
name|bufcnt
operator|++
control|)
block|{
name|sample
operator|=
name|up
operator|->
name|comp
index|[
operator|~
operator|*
name|dpt
operator|++
operator|&
literal|0xff
index|]
expr_stmt|;
comment|/* 		 * Clip noise spikes greater than MAXAMP. If no clips, 		 * increase the gain a tad; if the clips are too high,  		 * decrease a tad. 		 */
if|if
condition|(
name|sample
operator|>
name|MAXAMP
condition|)
block|{
name|sample
operator|=
name|MAXAMP
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sample
operator|<
operator|-
name|MAXAMP
condition|)
block|{
name|sample
operator|=
operator|-
name|MAXAMP
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|++
expr_stmt|;
block|}
name|chu_rf
argument_list|(
name|peer
argument_list|,
name|sample
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|up
operator|->
name|timestamp
argument_list|,
operator|&
name|up
operator|->
name|tick
argument_list|)
expr_stmt|;
comment|/* 		 * Once each second ride gain. 		 */
name|up
operator|->
name|seccnt
operator|=
operator|(
name|up
operator|->
name|seccnt
operator|+
literal|1
operator|)
operator|%
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|seccnt
operator|==
literal|0
condition|)
block|{
name|chu_gain
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set the input port and monitor gain for the next buffer. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|up
operator|->
name|port
operator|=
literal|2
expr_stmt|;
else|else
name|up
operator|->
name|port
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
condition|)
name|up
operator|->
name|mongain
operator|=
name|MONGAIN
expr_stmt|;
else|else
name|up
operator|->
name|mongain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_rf - filter and demodulate the FSK signal  *  * This routine implements a 300-baud Bell 103 modem with mark 2225 Hz  * and space 2025 Hz. It uses a bandpass filter followed by a soft  * limiter, FM discriminator and lowpass filter. A maximum-likelihood  * decoder samples the baseband signal at eight times the baud rate and  * detects the start bit of each character.  *  * The filters are built for speed, which explains the rather clumsy  * code. Hopefully, the compiler will efficiently implement the move-  * and-muiltiply-and-add operations.  */
end_comment

begin_function
specifier|static
name|void
name|chu_rf
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|double
name|sample
comment|/* analog sample */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|surv
modifier|*
name|sp
decl_stmt|;
comment|/* 	 * Local variables 	 */
name|double
name|signal
decl_stmt|;
comment|/* bandpass signal */
name|double
name|limit
decl_stmt|;
comment|/* limiter signal */
name|double
name|disc
decl_stmt|;
comment|/* discriminator signal */
name|double
name|lpf
decl_stmt|;
comment|/* lowpass signal */
name|double
name|dist
decl_stmt|;
comment|/* UART signal distance */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Bandpass filter. 4th-order elliptic, 500-Hz bandpass centered 	 * at 2125 Hz. Passband ripple 0.3 dB, stopband ripple 50 dB, 	 * phase delay 0.24 ms. 	 */
name|signal
operator|=
operator|(
name|up
operator|->
name|bpf
index|[
literal|8
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|)
operator|*
literal|5.844676e-01
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|)
operator|*
literal|4.884860e-01
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|)
operator|*
literal|2.704384e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|)
operator|*
literal|1.645032e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|)
operator|*
literal|4.644557e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|)
operator|*
literal|1.879165e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|)
operator|*
literal|3.522634e+00
expr_stmt|;
name|signal
operator|+=
operator|(
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|)
operator|*
literal|7.315738e-01
expr_stmt|;
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|=
name|sample
operator|-
name|signal
expr_stmt|;
name|signal
operator|=
name|up
operator|->
name|bpf
index|[
literal|0
index|]
operator|*
literal|6.176213e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|1
index|]
operator|*
literal|3.156599e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|2
index|]
operator|*
literal|7.567487e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|3
index|]
operator|*
literal|4.344580e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|4
index|]
operator|*
literal|1.190128e-02
operator|+
name|up
operator|->
name|bpf
index|[
literal|5
index|]
operator|*
literal|4.344580e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|6
index|]
operator|*
literal|7.567487e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|7
index|]
operator|*
literal|3.156599e-03
operator|+
name|up
operator|->
name|bpf
index|[
literal|8
index|]
operator|*
literal|6.176213e-03
expr_stmt|;
name|up
operator|->
name|monitor
operator|=
name|signal
operator|/
literal|4.
expr_stmt|;
comment|/* note monitor after filter */
comment|/* 	 * Soft limiter/discriminator. The 11-sample discriminator lag 	 * interval corresponds to three cycles of 2125 Hz, which 	 * requires the sample frequency to be 2125 * 11 / 3 = 7791.7 	 * Hz. The discriminator output varies +-0.5 interval for input 	 * frequency 2025-2225 Hz. However, we don't get to sample at 	 * this frequency, so the discriminator output is biased. Life 	 * at 8000 Hz sucks. 	 */
name|limit
operator|=
name|signal
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|LIMIT
condition|)
name|limit
operator|=
name|LIMIT
expr_stmt|;
elseif|else
if|if
condition|(
name|limit
operator|<
operator|-
name|LIMIT
condition|)
name|limit
operator|=
operator|-
name|LIMIT
expr_stmt|;
name|disc
operator|=
name|up
operator|->
name|disc
index|[
name|up
operator|->
name|discptr
index|]
operator|*
operator|-
name|limit
expr_stmt|;
name|up
operator|->
name|disc
index|[
name|up
operator|->
name|discptr
index|]
operator|=
name|limit
expr_stmt|;
name|up
operator|->
name|discptr
operator|=
operator|(
name|up
operator|->
name|discptr
operator|+
literal|1
operator|)
operator|%
name|LAG
expr_stmt|;
if|if
condition|(
name|disc
operator|>=
literal|0
condition|)
name|disc
operator|=
name|SQRT
argument_list|(
name|disc
argument_list|)
expr_stmt|;
else|else
name|disc
operator|=
operator|-
name|SQRT
argument_list|(
operator|-
name|disc
argument_list|)
expr_stmt|;
comment|/* 	 * Lowpass filter. Raised cosine FIR, Ts = 1 / 300, beta = 0.1. 	 */
name|lpf
operator|=
operator|(
name|up
operator|->
name|lpf
index|[
literal|26
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|25
index|]
operator|)
operator|*
literal|2.538771e-02
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|25
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|24
index|]
operator|)
operator|*
literal|1.084671e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|24
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|23
index|]
operator|)
operator|*
literal|2.003159e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|23
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|22
index|]
operator|)
operator|*
literal|2.985303e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|22
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|21
index|]
operator|)
operator|*
literal|4.003697e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|21
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|20
index|]
operator|)
operator|*
literal|5.028552e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|20
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|19
index|]
operator|)
operator|*
literal|6.028795e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|19
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|18
index|]
operator|)
operator|*
literal|6.973249e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|18
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|17
index|]
operator|)
operator|*
literal|7.831828e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|17
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|16
index|]
operator|)
operator|*
literal|8.576717e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|16
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|15
index|]
operator|)
operator|*
literal|9.183463e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|15
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|14
index|]
operator|)
operator|*
literal|9.631951e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|14
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|13
index|]
operator|)
operator|*
literal|9.907208e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|13
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|12
index|]
operator|)
operator|*
literal|1.000000e+00
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|12
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|11
index|]
operator|)
operator|*
literal|9.907208e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|11
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|10
index|]
operator|)
operator|*
literal|9.631951e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|10
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|9
index|]
operator|)
operator|*
literal|9.183463e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|9
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|8
index|]
operator|)
operator|*
literal|8.576717e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|8
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|7
index|]
operator|)
operator|*
literal|7.831828e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|7
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|6
index|]
operator|)
operator|*
literal|6.973249e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|6
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|5
index|]
operator|)
operator|*
literal|6.028795e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|5
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|)
operator|*
literal|5.028552e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|4
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|)
operator|*
literal|4.003697e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|3
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|)
operator|*
literal|2.985303e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|2
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|)
operator|*
literal|2.003159e-01
expr_stmt|;
name|lpf
operator|+=
operator|(
name|up
operator|->
name|lpf
index|[
literal|1
index|]
operator|=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|)
operator|*
literal|1.084671e-01
expr_stmt|;
name|lpf
operator|+=
name|up
operator|->
name|lpf
index|[
literal|0
index|]
operator|=
name|disc
operator|*
literal|2.538771e-02
expr_stmt|;
comment|/* 	 * Maximum-likelihood decoder. The UART updates each of the 	 * eight survivors and determines the span, slice level and 	 * tentative decoded character. Valid 11-bit characters are 	 * framed so that bit 10 and bit 11 (stop bits) are mark and bit 	 * 1 (start bit) is space. When a valid character is found, the 	 * survivor with maximum distance determines the final decoded 	 * character. 	 */
name|up
operator|->
name|baud
operator|+=
literal|1.
operator|/
name|SECOND
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|baud
operator|>
literal|1.
operator|/
operator|(
name|BAUD
operator|*
literal|8.
operator|)
condition|)
block|{
name|up
operator|->
name|baud
operator|-=
literal|1.
operator|/
operator|(
name|BAUD
operator|*
literal|8.
operator|)
expr_stmt|;
name|up
operator|->
name|decptr
operator|=
operator|(
name|up
operator|->
name|decptr
operator|+
literal|1
operator|)
operator|%
literal|8
expr_stmt|;
name|sp
operator|=
operator|&
name|up
operator|->
name|surv
index|[
name|up
operator|->
name|decptr
index|]
expr_stmt|;
name|sp
operator|->
name|cstamp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|chu_uart
argument_list|(
name|sp
argument_list|,
operator|-
name|lpf
operator|*
name|AGAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|dbrk
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|dbrk
operator|--
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|dbrk
operator|>
literal|0
condition|)
return|return;
name|up
operator|->
name|decpha
operator|=
name|up
operator|->
name|decptr
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|decptr
operator|!=
name|up
operator|->
name|decpha
condition|)
return|return;
name|dist
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * The timestamp is taken at the last bit, so 			 * for correct decoding we reqire sufficient 			 * span and correct start bit and two stop bits. 			 */
if|if
condition|(
operator|(
name|up
operator|->
name|surv
index|[
name|i
index|]
operator|.
name|uart
operator|&
literal|0x601
operator|)
operator|!=
literal|0x600
operator|||
name|up
operator|->
name|surv
index|[
name|i
index|]
operator|.
name|span
operator|<
name|SPAN
condition|)
continue|continue;
if|if
condition|(
name|up
operator|->
name|surv
index|[
name|i
index|]
operator|.
name|dist
operator|>
name|dist
condition|)
block|{
name|dist
operator|=
name|up
operator|->
name|surv
index|[
name|i
index|]
operator|.
name|dist
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
literal|0
condition|)
return|return;
comment|/* 		 * Process the character, then blank the decoder until 		 * the end of the next character.This sets the decoding 		 * phase of the entire burst from the phase of the first 		 * character. 		 */
name|up
operator|->
name|maxsignal
operator|=
name|up
operator|->
name|surv
index|[
name|j
index|]
operator|.
name|span
expr_stmt|;
name|chu_decode
argument_list|(
name|peer
argument_list|,
operator|(
name|up
operator|->
name|surv
index|[
name|j
index|]
operator|.
name|uart
operator|>>
literal|1
operator|)
operator|&
literal|0xff
argument_list|,
name|up
operator|->
name|surv
index|[
name|j
index|]
operator|.
name|cstamp
argument_list|)
expr_stmt|;
name|up
operator|->
name|dbrk
operator|=
literal|88
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_uart - maximum-likelihood UART  *  * This routine updates a shift register holding the last 11 envelope  * samples. It then computes the slice level and span over these samples  * and determines the tentative data bits and distance. The calling  * program selects over the last eight survivors the one with maximum  * distance to determine the decoded character.  */
end_comment

begin_function
specifier|static
name|void
name|chu_uart
parameter_list|(
name|struct
name|surv
modifier|*
name|sp
parameter_list|,
comment|/* survivor structure pointer */
name|double
name|sample
comment|/* baseband signal */
parameter_list|)
block|{
name|double
name|es_max
decl_stmt|,
name|es_min
decl_stmt|;
comment|/* max/min envelope */
name|double
name|slice
decl_stmt|;
comment|/* slice level */
name|double
name|dist
decl_stmt|;
comment|/* distance */
name|double
name|dtemp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Save the sample and shift right. At the same time, measure 	 * the maximum and minimum over all eleven samples. 	 */
name|es_max
operator|=
operator|-
literal|1e6
expr_stmt|;
name|es_min
operator|=
literal|1e6
expr_stmt|;
name|sp
operator|->
name|shift
index|[
literal|0
index|]
operator|=
name|sample
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|11
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sp
operator|->
name|shift
index|[
name|i
index|]
operator|=
name|sp
operator|->
name|shift
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|shift
index|[
name|i
index|]
operator|>
name|es_max
condition|)
name|es_max
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|shift
index|[
name|i
index|]
operator|<
name|es_min
condition|)
name|es_min
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* 	 * Determine the span as the maximum less the minimum and the 	 * slice level as the minimum plus a fraction of the span. Note 	 * the slight bias toward mark to correct for the modem tendency 	 * to make more mark than space errors. Compute the distance on 	 * the assumption the last two bits must be mark, the first 	 * space and the rest either mark or space.  	 */
name|sp
operator|->
name|span
operator|=
name|es_max
operator|-
name|es_min
expr_stmt|;
name|slice
operator|=
name|es_min
operator|+
literal|.45
operator|*
name|sp
operator|->
name|span
expr_stmt|;
name|dist
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|uart
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|->
name|uart
operator|<<=
literal|1
expr_stmt|;
name|dtemp
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|slice
condition|)
name|sp
operator|->
name|uart
operator||=
literal|0x1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
operator|||
name|i
operator|==
literal|2
condition|)
block|{
name|dist
operator|+=
name|dtemp
operator|-
name|es_min
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|11
condition|)
block|{
name|dist
operator|+=
name|es_max
operator|-
name|dtemp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dtemp
operator|>
name|slice
condition|)
name|dist
operator|+=
name|dtemp
operator|-
name|es_min
expr_stmt|;
else|else
name|dist
operator|+=
name|es_max
operator|-
name|dtemp
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|dist
operator|=
name|dist
operator|/
operator|(
literal|11
operator|*
name|sp
operator|->
name|span
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_comment
comment|/*  * chu_serial_receive - receive data from the serial device  */
end_comment

begin_function
specifier|static
name|void
name|chu_serial_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
comment|/* receive buffer structure pointer */
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* receive buffer pointer */
name|peer
operator|=
name|rbufp
operator|->
name|recv_peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
name|dpt
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|chu_decode
argument_list|(
name|peer
argument_list|,
operator|*
name|dpt
argument_list|,
name|rbufp
operator|->
name|recv_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_decode - decode the character data  */
end_comment

begin_function
specifier|static
name|void
name|chu_decode
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
name|int
name|hexhex
parameter_list|,
comment|/* data character */
name|l_fp
name|cstamp
comment|/* data character timestamp */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|l_fp
name|tstmp
decl_stmt|;
comment|/* timestamp temp */
name|double
name|dtemp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * If the interval since the last character is greater than the 	 * longest burst, process the last burst and start a new one. If 	 * the interval is less than this but greater than two 	 * characters, consider this a noise burst and reject it. 	 */
name|tstmp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|up
operator|->
name|laststamp
argument_list|)
condition|)
name|up
operator|->
name|laststamp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tstmp
argument_list|,
operator|&
name|up
operator|->
name|laststamp
argument_list|)
expr_stmt|;
name|up
operator|->
name|laststamp
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|tstmp
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>
name|BURST
operator|*
name|CHAR
condition|)
block|{
name|chu_burst
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|up
operator|->
name|ndx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtemp
operator|>
literal|2.5
operator|*
name|CHAR
condition|)
block|{
name|up
operator|->
name|ndx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Append the character to the current burst and append the 	 * character timestamp to the timestamp list. 	 */
if|if
condition|(
name|up
operator|->
name|ndx
operator|<
name|BURST
condition|)
block|{
name|up
operator|->
name|cbuf
index|[
name|up
operator|->
name|ndx
index|]
operator|=
name|hexhex
operator|&
literal|0xff
expr_stmt|;
name|up
operator|->
name|cstamp
index|[
name|up
operator|->
name|ndx
index|]
operator|=
name|cstamp
expr_stmt|;
name|up
operator|->
name|ndx
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_burst - search for valid burst format  */
end_comment

begin_function
specifier|static
name|void
name|chu_burst
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Correlate a block of five characters with the next block of 	 * five characters. The burst distance is defined as the number 	 * of bits that match in the two blocks for format A and that 	 * match the inverse for format B. 	 */
if|if
condition|(
name|up
operator|->
name|ndx
operator|<
name|MINCHARS
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|RUNT
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|burdist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
operator|&&
name|i
operator|<
name|up
operator|->
name|ndx
operator|-
literal|5
condition|;
name|i
operator|++
control|)
name|up
operator|->
name|burdist
operator|+=
name|chu_dist
argument_list|(
name|up
operator|->
name|cbuf
index|[
name|i
index|]
argument_list|,
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If the burst distance is at least MINDIST, this must be a 	 * format A burst; if the value is not greater than -MINDIST, it 	 * must be a format B burst. If the B burst is perfect, we 	 * believe it; otherwise, it is a noise burst and of no use to 	 * anybody. 	 */
if|if
condition|(
name|up
operator|->
name|burdist
operator|>=
name|MINDIST
condition|)
block|{
name|chu_a
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|ndx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|burdist
operator|<=
operator|-
name|MINDIST
condition|)
block|{
name|chu_b
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|ndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|status
operator||=
name|NOISE
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is a valid burst, wait a guard time of ten seconds to 	 * allow for more bursts, then arm the poll update routine to 	 * process the minute. Don't do this if this is called from the 	 * timer interrupt routine. 	 */
if|if
condition|(
name|peer
operator|->
name|outdate
operator|!=
name|current_time
condition|)
name|peer
operator|->
name|nextdate
operator|=
name|current_time
operator|+
literal|10
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_b - decode format B burst  */
end_comment

begin_function
specifier|static
name|void
name|chu_b
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|nchar
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|u_char
name|code
index|[
literal|11
index|]
decl_stmt|;
comment|/* decoded timecode */
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* trace buffer */
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|chars
decl_stmt|;
name|size_t
name|cb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * In a format B burst, a character is considered valid only if 	 * the first occurence matches the last occurence. The burst is 	 * considered valid only if all characters are valid; that is, 	 * only if the distance is 40. Note that once a valid frame has 	 * been found errors are ignored. 	 */
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"chuB %04x %4.0f %2d %2d "
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|maxsignal
argument_list|,
name|nchar
argument_list|,
operator|-
name|up
operator|->
name|burdist
argument_list|)
expr_stmt|;
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|tbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchar
condition|;
name|i
operator|++
control|)
block|{
name|chars
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|<
name|chars
operator|+
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_b() fatal out buffer"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cb
operator|-=
name|chars
expr_stmt|;
name|p
operator|+=
name|chars
expr_stmt|;
name|snprintf
argument_list|(
name|p
argument_list|,
name|cb
argument_list|,
literal|"%02x"
argument_list|,
name|up
operator|->
name|cbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|up
operator|->
name|burdist
operator|>
operator|-
literal|40
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|BFRAME
expr_stmt|;
return|return;
block|}
comment|/* 	 * Convert the burst data to internal format. Don't bother with 	 * the timestamps. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|code
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|hexchar
index|[
name|up
operator|->
name|cbuf
index|[
name|i
index|]
operator|&
literal|0xf
index|]
expr_stmt|;
name|code
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|hexchar
index|[
operator|(
name|up
operator|->
name|cbuf
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|code
argument_list|,
literal|"%1x%1d%4d%2d%2x"
argument_list|,
operator|&
name|up
operator|->
name|leap
argument_list|,
operator|&
name|up
operator|->
name|dut
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|up
operator|->
name|tai
argument_list|,
operator|&
name|up
operator|->
name|dst
argument_list|)
operator|!=
literal|5
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|BFORMAT
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|status
operator||=
name|BVALID
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|leap
operator|&
literal|0x8
condition|)
name|up
operator|->
name|dut
operator|=
operator|-
name|up
operator|->
name|dut
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_a - decode format A burst  */
end_comment

begin_function
specifier|static
name|void
name|chu_a
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|int
name|nchar
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
comment|/* trace buffer */
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|chars
decl_stmt|;
name|size_t
name|cb
decl_stmt|;
name|l_fp
name|offset
decl_stmt|;
comment|/* timestamp offset */
name|int
name|val
decl_stmt|;
comment|/* distance */
name|int
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Determine correct burst phase. There are three cases 	 * corresponding to in-phase, one character early or one 	 * character late. These cases are distinguished by the position 	 * of the framing digits 0x6 at positions 0 and 5 and 0x3 at 	 * positions 4 and 9. The correct phase is when the distance 	 * relative to the framing digits is maximum. The burst is valid 	 * only if the maximum distance is at least MINSYNC. 	 */
name|up
operator|->
name|syndist
operator|=
name|k
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|-
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|4
index|]
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|temp
operator||=
operator|(
name|up
operator|->
name|cbuf
index|[
name|i
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
name|val
operator|=
name|chu_dist
argument_list|(
name|temp
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|5
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|9
operator|<
name|nchar
condition|)
name|temp
operator||=
name|up
operator|->
name|cbuf
index|[
name|i
operator|+
literal|9
index|]
operator|&
literal|0xf
expr_stmt|;
name|val
operator|+=
name|chu_dist
argument_list|(
name|temp
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|up
operator|->
name|syndist
condition|)
block|{
name|up
operator|->
name|syndist
operator|=
name|val
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * Extract the second number; it must be in the range 2 through 	 * 9 and the two repititions must be the same. 	 */
name|temp
operator|=
operator|(
name|up
operator|->
name|cbuf
index|[
name|k
operator|+
literal|4
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|2
operator|||
name|temp
operator|>
literal|9
operator|||
name|k
operator|+
literal|9
operator|>=
name|nchar
operator|||
name|temp
operator|!=
operator|(
operator|(
name|up
operator|->
name|cbuf
index|[
name|k
operator|+
literal|9
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"chuA %04x %4.0f %2d %2d %2d %2d %1d "
argument_list|,
name|up
operator|->
name|status
argument_list|,
name|up
operator|->
name|maxsignal
argument_list|,
name|nchar
argument_list|,
name|up
operator|->
name|burdist
argument_list|,
name|k
argument_list|,
name|up
operator|->
name|syndist
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|tbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchar
condition|;
name|i
operator|++
control|)
block|{
name|chars
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|<
name|chars
operator|+
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_a() fatal out buffer"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cb
operator|-=
name|chars
expr_stmt|;
name|p
operator|+=
name|chars
expr_stmt|;
name|snprintf
argument_list|(
name|p
argument_list|,
name|cb
argument_list|,
literal|"%02x"
argument_list|,
name|up
operator|->
name|cbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|up
operator|->
name|syndist
operator|<
name|MINSYNC
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|AFRAME
expr_stmt|;
return|return;
block|}
comment|/* 	 * A valid burst requires the first seconds number to match the 	 * last seconds number. If so, the burst timestamps are 	 * corrected to the current minute and saved for later 	 * processing. In addition, the seconds decode is advanced from 	 * the previous burst to the current one. 	 */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|AFORMAT
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|status
operator||=
name|AVALID
expr_stmt|;
name|up
operator|->
name|second
operator|=
name|pp
operator|->
name|second
operator|=
literal|30
operator|+
name|temp
expr_stmt|;
name|offset
operator|.
name|l_ui
operator|=
literal|30
operator|+
name|temp
expr_stmt|;
name|offset
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|offset
operator|=
name|up
operator|->
name|charstamp
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nchar
operator|&&
name|i
operator|<
name|k
operator|+
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
operator|=
name|up
operator|->
name|cstamp
index|[
name|i
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|tstamp
index|[
name|up
operator|->
name|ntstamp
index|]
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|up
operator|->
name|charstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ntstamp
operator|<
name|MAXSTAGE
operator|-
literal|1
condition|)
name|up
operator|->
name|ntstamp
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|temp
operator|>
name|up
operator|->
name|prevsec
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|up
operator|->
name|decode
index|[
literal|9
index|]
index|[
name|j
index|]
operator|=
name|up
operator|->
name|decode
index|[
literal|9
index|]
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|up
operator|->
name|decode
index|[
literal|19
index|]
index|[
name|j
index|]
operator|=
name|up
operator|->
name|decode
index|[
literal|19
index|]
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|up
operator|->
name|decode
index|[
literal|9
index|]
index|[
name|j
index|]
operator|=
name|up
operator|->
name|decode
index|[
literal|19
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|prevsec
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Stash the data in the decoding matrix. 	 */
name|i
operator|=
operator|-
operator|(
literal|2
operator|*
name|k
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nchar
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|18
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
name|up
operator|->
name|cbuf
index|[
name|j
index|]
operator|&
literal|0xf
index|]
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
operator|(
name|up
operator|->
name|cbuf
index|[
name|j
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|up
operator|->
name|burstcnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|chu_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_second - process minute data  */
end_comment

begin_function
specifier|static
name|void
name|chu_second
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|l_fp
name|offset
decl_stmt|;
name|char
name|synchar
decl_stmt|,
name|qual
decl_stmt|,
name|leapchar
decl_stmt|;
name|int
name|minset
decl_stmt|,
name|i
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * This routine is called once per minute to process the 	 * accumulated burst data. We do a bit of fancy footwork so that 	 * this doesn't run while burst data are being accumulated. 	 */
name|up
operator|->
name|second
operator|=
operator|(
name|up
operator|->
name|second
operator|+
literal|1
operator|)
operator|%
literal|60
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|second
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Process the last burst, if still in the burst buffer. 	 * If the minute contains a valid B frame with sufficient A 	 * frame metric, it is considered valid. However, the timecode 	 * is sent to clockstats even if invalid. 	 */
name|chu_burst
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|minset
operator|=
operator|(
operator|(
name|current_time
operator|-
name|peer
operator|->
name|update
operator|)
operator|+
literal|30
operator|)
operator|/
literal|60
expr_stmt|;
name|dtemp
operator|=
name|chu_major
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|qual
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
operator|(
name|BFRAME
operator||
name|AFRAME
operator|)
condition|)
name|qual
operator||=
name|SYNERR
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
operator|(
name|BFORMAT
operator||
name|AFORMAT
operator|)
condition|)
name|qual
operator||=
name|FMTERR
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|DECODE
condition|)
name|qual
operator||=
name|DECERR
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|STAMP
condition|)
name|qual
operator||=
name|TSPERR
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|BVALID
operator|&&
name|dtemp
operator|>=
name|MINMETRIC
condition|)
name|up
operator|->
name|status
operator||=
name|INSYNC
expr_stmt|;
name|synchar
operator|=
name|leapchar
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|)
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|synchar
operator|=
literal|'?'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|leap
operator|&
literal|0x2
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|leapchar
operator|=
literal|'L'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|leap
operator|&
literal|0x4
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|leapchar
operator|=
literal|'l'
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
argument_list|,
literal|"%c%1X %04d %03d %02d:%02d:%02d %c%x %+d %d %d %s %.0f %d"
argument_list|,
name|synchar
argument_list|,
name|qual
argument_list|,
name|pp
operator|->
name|year
argument_list|,
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|leapchar
argument_list|,
name|up
operator|->
name|dst
argument_list|,
name|up
operator|->
name|dut
argument_list|,
name|minset
argument_list|,
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|ident
argument_list|,
name|dtemp
argument_list|,
name|up
operator|->
name|ntstamp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
comment|/* 	 * If in sync and the signal metric is above threshold, the 	 * timecode is ipso fatso valid and can be selected to 	 * discipline the clock. 	 */
if|if
condition|(
name|up
operator|->
name|status
operator|&
name|INSYNC
operator|&&
operator|!
operator|(
name|up
operator|->
name|status
operator|&
operator|(
name|DECODE
operator||
name|STAMP
operator|)
operator|)
operator|&&
name|dtemp
operator|>
name|MINMETRIC
condition|)
block|{
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
literal|0
argument_list|,
name|GMT
argument_list|,
name|up
operator|->
name|tstamp
index|[
literal|0
index|]
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|offset
operator|.
name|l_ui
argument_list|)
condition|)
block|{
name|up
operator|->
name|errflg
operator|=
name|CEVNT_BADTIME
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|up
operator|->
name|ntstamp
condition|;
name|i
operator|++
control|)
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|offset
argument_list|,
name|up
operator|->
name|tstamp
index|[
name|i
index|]
argument_list|,
name|PDELAY
operator|+
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lastref
operator|=
name|up
operator|->
name|timestamp
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dtemp
operator|>
literal|0
condition|)
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"chu: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ICOM
name|chu_newchan
argument_list|(
name|peer
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ICOM */
name|chu_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|errflg
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|errflg
argument_list|)
expr_stmt|;
name|up
operator|->
name|errflg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_major - majority decoder  */
end_comment

begin_function
specifier|static
name|double
name|chu_major
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|u_char
name|code
index|[
literal|11
index|]
decl_stmt|;
comment|/* decoded timecode */
name|int
name|metric
decl_stmt|;
comment|/* distance metric */
name|int
name|val1
decl_stmt|;
comment|/* maximum distance */
name|int
name|synchar
decl_stmt|;
comment|/* stray cat */
name|int
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Majority decoder. Each burst encodes two replications at each 	 * digit position in the timecode. Each row of the decoding 	 * matrix encodes the number of occurences of each digit found 	 * at the corresponding position. The maximum over all 	 * occurrences at each position is the distance for this 	 * position and the corresponding digit is the maximum- 	 * likelihood candidate. If the distance is not more than half 	 * the total number of occurences, a majority has not been found 	 * and the data are discarded. The decoding distance is defined 	 * as the sum of the distances over the first nine digits. The 	 * tenth digit varies over the seconds, so we don't count it. 	 */
name|metric
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|val1
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
name|temp
operator|=
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|up
operator|->
name|decode
index|[
name|i
operator|+
literal|10
index|]
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|val1
condition|)
block|{
name|val1
operator|=
name|temp
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val1
operator|<=
name|up
operator|->
name|burstcnt
condition|)
name|up
operator|->
name|status
operator||=
name|DECODE
expr_stmt|;
name|metric
operator|+=
name|val1
expr_stmt|;
name|code
index|[
name|i
index|]
operator|=
name|hexchar
index|[
name|k
index|]
expr_stmt|;
block|}
comment|/* 	 * Compute the timecode timestamp from the days, hours and 	 * minutes of the timecode. Use clocktime() for the aggregate 	 * minutes and the minute offset computed from the burst 	 * seconds. Note that this code relies on the filesystem time 	 * for the years and does not use the years of the timecode. 	 */
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|code
argument_list|,
literal|"%1x%3d%2d%2d"
argument_list|,
operator|&
name|synchar
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|)
operator|!=
literal|4
condition|)
name|up
operator|->
name|status
operator||=
name|DECODE
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ntstamp
operator|<
name|MINSTAMP
condition|)
name|up
operator|->
name|status
operator||=
name|STAMP
expr_stmt|;
return|return
operator|(
name|metric
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * chu_clear - clear decoding matrix  */
end_comment

begin_function
specifier|static
name|void
name|chu_clear
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Clear stuff for the minute. 	 */
name|up
operator|->
name|ndx
operator|=
name|up
operator|->
name|prevsec
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|burstcnt
operator|=
name|up
operator|->
name|ntstamp
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|status
operator|&=
name|INSYNC
operator||
name|METRIC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
name|up
operator|->
name|decode
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ICOM
end_ifdef

begin_comment
comment|/*  * chu_newchan - called once per minute to find the best channel;  * returns zero on success, nonzero if ICOM error.  */
end_comment

begin_function
specifier|static
name|int
name|chu_newchan
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|double
name|met
parameter_list|)
block|{
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|xmtr
modifier|*
name|sp
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|double
name|metric
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * The radio can be tuned to three channels: 0 (3330 kHz), 1 	 * (7850 kHz) and 2 (14670 kHz). There are five one-minute 	 * dwells in each cycle. During the first dwell the radio is 	 * tuned to one of the three channels to measure the channel 	 * metric. The channel is selected as the one least recently 	 * measured. During the remaining four dwells the radio is tuned 	 * to the channel with the highest channel metric.  	 */
if|if
condition|(
name|up
operator|->
name|fd_icom
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Update the current channel metric and age of all channels. 	 * Scan all channels for the highest metric. 	 */
name|sp
operator|=
operator|&
name|up
operator|->
name|xmtr
index|[
name|up
operator|->
name|chan
index|]
expr_stmt|;
name|sp
operator|->
name|metric
operator|-=
name|sp
operator|->
name|integ
index|[
name|sp
operator|->
name|iptr
index|]
expr_stmt|;
name|sp
operator|->
name|integ
index|[
name|sp
operator|->
name|iptr
index|]
operator|=
name|met
expr_stmt|;
name|sp
operator|->
name|metric
operator|+=
name|sp
operator|->
name|integ
index|[
name|sp
operator|->
name|iptr
index|]
expr_stmt|;
name|sp
operator|->
name|probe
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|iptr
operator|=
operator|(
name|sp
operator|->
name|iptr
operator|+
literal|1
operator|)
operator|%
name|ISTAGE
expr_stmt|;
name|metric
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|->
name|xmtr
index|[
name|i
index|]
operator|.
name|probe
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|xmtr
index|[
name|i
index|]
operator|.
name|metric
operator|>
name|metric
condition|)
block|{
name|up
operator|->
name|status
operator||=
name|METRIC
expr_stmt|;
name|metric
operator|=
name|up
operator|->
name|xmtr
index|[
name|i
index|]
operator|.
name|metric
expr_stmt|;
name|up
operator|->
name|chan
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * Start the next dwell. If the first dwell or no stations have 	 * been heard, continue round-robin scan. 	 */
name|up
operator|->
name|dwell
operator|=
operator|(
name|up
operator|->
name|dwell
operator|+
literal|1
operator|)
operator|%
name|DWELL
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|dwell
operator|==
literal|0
operator|||
name|metric
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|up
operator|->
name|xmtr
index|[
name|i
index|]
operator|.
name|probe
operator|>
name|rval
condition|)
block|{
name|rval
operator|=
name|up
operator|->
name|xmtr
index|[
name|i
index|]
operator|.
name|probe
expr_stmt|;
name|up
operator|->
name|chan
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
comment|/* Retune the radio at each dwell in case somebody nudges the 	 * tuning knob. 	 */
name|rval
operator|=
name|icom_freq
argument_list|(
name|up
operator|->
name|fd_icom
argument_list|,
name|peer
operator|->
name|ttl
operator|&
literal|0x7f
argument_list|,
name|qsy
index|[
name|up
operator|->
name|chan
index|]
operator|+
name|TUNE
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|up
operator|->
name|ident
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|ident
argument_list|)
argument_list|,
literal|"CHU%d"
argument_list|,
name|up
operator|->
name|chan
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|up
operator|->
name|ident
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|up
operator|->
name|ident
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|metric
operator|==
literal|0
operator|&&
name|up
operator|->
name|status
operator|&
name|METRIC
condition|)
block|{
name|up
operator|->
name|status
operator|&=
operator|~
name|METRIC
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_PROP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICOM */
end_comment

begin_comment
comment|/*  * chu_dist - determine the distance of two octet arguments  */
end_comment

begin_function
specifier|static
name|int
name|chu_dist
parameter_list|(
name|int
name|x
parameter_list|,
comment|/* an octet of bits */
name|int
name|y
comment|/* another octet of bits */
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
comment|/* bit count */
name|int
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * The distance is determined as the weight of the exclusive OR 	 * of the two arguments. The weight is determined by the number 	 * of one bits in the result. Each one bit increases the weight, 	 * while each zero bit decreases it. 	 */
name|temp
operator|=
name|x
operator|^
name|y
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|temp
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
name|val
operator|++
expr_stmt|;
else|else
name|val
operator|--
expr_stmt|;
name|temp
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AUDIO
end_ifdef

begin_comment
comment|/*  * chu_gain - adjust codec gain  *  * This routine is called at the end of each second. During the second  * the number of signal clips above the MAXAMP threshold (6000). If  * there are no clips, the gain is bumped up; if there are more than  * MAXCLP clips (100), it is bumped down. The decoder is relatively  * insensitive to amplitude, so this crudity works just peachy. The  * routine also jiggles the input port and selectively mutes the  */
end_comment

begin_function
specifier|static
name|void
name|chu_gain
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
comment|/* peer structure pointer */
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Apparently, the codec uses only the high order bits of the 	 * gain control field. Thus, it may take awhile for changes to 	 * wiggle the hardware bits. 	 */
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|gain
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|>
name|MAXGAIN
condition|)
name|up
operator|->
name|gain
operator|=
name|MAXGAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|clipcnt
operator|>
name|MAXCLP
condition|)
block|{
name|up
operator|->
name|gain
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|gain
operator|<
literal|0
condition|)
name|up
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
name|audio_gain
argument_list|(
name|up
operator|->
name|gain
argument_list|,
name|up
operator|->
name|mongain
argument_list|,
name|up
operator|->
name|port
argument_list|)
expr_stmt|;
name|up
operator|->
name|clipcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AUDIO */
end_comment

begin_else
else|#
directive|else
end_else

begin_macro
name|NONEMPTY_TRANSLATION_UNIT
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

