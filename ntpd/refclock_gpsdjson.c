begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_gpsdjson.c - clock driver as GPSD JSON client  *	Juergen Perlinger (perlinger@ntp.org)  *	Feb 11, 2014 for the NTP project.  *      The contents of 'html/copyright.html' apply.  *  *	Heavily inspired by refclock_nmea.c  *  * Note: This will currently NOT work with Windows due to some  * limitations:  *  *  - There is no GPSD for Windows. (There is an unofficial port to  *    cygwin, but Windows is not officially supported.)  *  *  - To work properly, this driver needs PPS and TPV sentences from  *    GPSD. I don't see how the cygwin port should deal with that.  *  *  - The device name matching must be done in a different way for  *    Windows. (Can be done with COMxx matching, as done for NMEA.)  *  * Apart from those minor hickups, once GPSD has been fully ported to  * Windows, there's no reason why this should not work there ;-)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_GPSDJSON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_comment
comment|/* =====================================================================  * get the little JSMN library directly into our guts  */
end_comment

begin_include
include|#
directive|include
file|"../libjsmn/jsmn.c"
end_include

begin_comment
comment|/* =====================================================================  * header stuff we need  */
end_comment

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_POLL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_SLECET_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|need poll() or select()
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"timespecops.h"
end_include

begin_define
define|#
directive|define
name|PRECISION
value|(-9)
end_define

begin_comment
comment|/* precision assumed (about 2 ms) */
end_comment

begin_define
define|#
directive|define
name|PPS_PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"GPSD"
end_define

begin_comment
comment|/* reference id */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"GPSD JSON client clock"
end_define

begin_comment
comment|/* who we are */
end_comment

begin_define
define|#
directive|define
name|MAX_PDU_LEN
value|1600
end_define

begin_define
define|#
directive|define
name|TICKOVER_LOW
value|10
end_define

begin_define
define|#
directive|define
name|TICKOVER_HIGH
value|120
end_define

begin_define
define|#
directive|define
name|LOGTHROTTLE
value|3600
end_define

begin_define
define|#
directive|define
name|PPS_MAXCOUNT
value|30
end_define

begin_define
define|#
directive|define
name|PPS_HIWAT
value|20
end_define

begin_define
define|#
directive|define
name|PPS_LOWAT
value|10
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|BOOL
end_ifndef

begin_define
define|#
directive|define
name|BOOL
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* some local typedefs : The NTPD formatting style cries for short type  * names, and we provide them locally. Note:the suffix '_t' is reserved  * for the standard; I use a capital T instead.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|peer
name|peerT
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|refclockproc
name|clockprocT
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|addrinfo
name|addrinfoT
typedef|;
end_typedef

begin_comment
comment|/* =====================================================================  * We use the same device name scheme as does the NMEA driver; since  * GPSD supports the same links, we can select devices by a fixed name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s_dev_stem
init|=
literal|"/dev/gps"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* =====================================================================  * forward declarations for transfer vector and the vector itself  */
end_comment

begin_function_decl
specifier|static
name|void
name|gpsd_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gpsd_start
parameter_list|(
name|int
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_shutdown
parameter_list|(
name|int
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_poll
parameter_list|(
name|int
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_control
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|refclockstat
modifier|*
parameter_list|,
name|struct
name|refclockstat
modifier|*
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_timer
parameter_list|(
name|int
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_clockstats
parameter_list|(
name|int
parameter_list|,
name|peerT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|myasprintf
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|refclock
name|refclock_gpsdjson
init|=
block|{
name|gpsd_start
block|,
comment|/* start up driver */
name|gpsd_shutdown
block|,
comment|/* shut down driver */
name|gpsd_poll
block|,
comment|/* transmit poll message */
name|gpsd_control
block|,
comment|/* fudge control */
name|gpsd_init
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* buginfo */
name|gpsd_timer
comment|/* called once per second */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* =====================================================================  * our local clock unit and data  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gpsd_unit
block|{
name|int
name|unit
decl_stmt|;
comment|/* current line protocol version */
name|uint16_t
name|proto_major
decl_stmt|;
name|uint16_t
name|proto_minor
decl_stmt|;
comment|/* PPS time stamps */
name|l_fp
name|pps_local
decl_stmt|;
comment|/* when we received the PPS message */
name|l_fp
name|pps_stamp
decl_stmt|;
comment|/* related reference time */
name|l_fp
name|pps_recvt
decl_stmt|;
comment|/* when GPSD detected the pulse */
comment|/* TPV (GPS data) time stamps */
name|l_fp
name|tpv_local
decl_stmt|;
comment|/* when we received the TPV message */
name|l_fp
name|tpv_stamp
decl_stmt|;
comment|/* effective GPS time stamp */
name|l_fp
name|tpv_recvt
decl_stmt|;
comment|/* when GPSD got the fix */
comment|/* fudge values for correction, mirrored as 'l_fp' */
name|l_fp
name|pps_fudge
decl_stmt|;
name|l_fp
name|tpv_fudge
decl_stmt|;
comment|/* Flags to indicate available data */
name|int
name|fl_tpv
range|:
literal|1
decl_stmt|;
comment|/* valid TPV seen (have time) */
name|int
name|fl_pps
range|:
literal|1
decl_stmt|;
comment|/* valid pulse seen */
name|int
name|fl_vers
range|:
literal|1
decl_stmt|;
comment|/* have protocol version */
name|int
name|fl_watch
range|:
literal|1
decl_stmt|;
comment|/* watch reply seen */
name|int
name|fl_nsec
range|:
literal|1
decl_stmt|;
comment|/* have nanosec PPS info */
comment|/* admin stuff for sockets and device selection */
name|int
name|fdt
decl_stmt|;
comment|/* current connecting socket */
name|addrinfoT
modifier|*
name|addr
decl_stmt|;
comment|/* next address to try */
name|u_int
name|tickover
decl_stmt|;
comment|/* timeout countdown */
name|u_int
name|tickpres
decl_stmt|;
comment|/* timeout preset */
name|u_int
name|ppscount
decl_stmt|;
comment|/* PPS mode up/down count */
name|char
modifier|*
name|device
decl_stmt|;
comment|/* device name of unit */
comment|/* tallies for the various events */
name|u_int
name|tc_good
decl_stmt|;
comment|/* good samples received */
name|u_int
name|tc_btime
decl_stmt|;
comment|/* bad time stamps */
name|u_int
name|tc_bdate
decl_stmt|;
comment|/* bad date strings */
name|u_int
name|tc_breply
decl_stmt|;
comment|/* bad replies */
name|u_int
name|tc_recv
decl_stmt|;
comment|/* received known records */
comment|/* log bloat throttle */
name|u_int
name|logthrottle
decl_stmt|;
comment|/* seconds to next log slot */
comment|/* record assemby buffer and saved length */
name|int
name|buflen
decl_stmt|;
name|char
name|buffer
index|[
name|MAX_PDU_LEN
index|]
decl_stmt|;
block|}
name|gpsd_unitT
typedef|;
end_typedef

begin_comment
comment|/* =====================================================================  * static local helpers forward decls  */
end_comment

begin_function_decl
specifier|static
name|void
name|gpsd_init_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_test_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_stop_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gpsd_parse
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|convert_ascii_time
parameter_list|(
name|l_fp
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|gps_time
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_ltc
parameter_list|(
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|tc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|syslogok
parameter_list|(
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* =====================================================================  * local / static stuff  */
end_comment

begin_comment
comment|/* The logon string is actually the ?WATCH command of GPSD, using JSON  * data and selecting the GPS device name we created from our unit  * number. [Note: This is a format string!]  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s_logon
init|=
literal|"?WATCH={\"enable\":true,\"json\":true,\"device\":\"%s\"};\r\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We keep a static list of network addresses for 'localhost:gpsd', and  * we try to connect to them in round-robin fashion.  */
end_comment

begin_decl_stmt
specifier|static
name|addrinfoT
modifier|*
name|s_gpsd_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* =====================================================================  * log throttling  */
end_comment

begin_function
specifier|static
name|int
comment|/*BOOL*/
name|syslogok
parameter_list|(
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
name|gpsd_unitT
modifier|*
specifier|const
name|up
parameter_list|)
block|{
name|int
name|res
init|=
operator|(
literal|0
operator|!=
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG3
operator|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|up
operator|->
name|logthrottle
operator|)
operator|||
operator|(
name|LOGTHROTTLE
operator|==
name|up
operator|->
name|logthrottle
operator|)
decl_stmt|;
if|if
condition|(
name|res
condition|)
name|up
operator|->
name|logthrottle
operator|=
name|LOGTHROTTLE
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * the clock functions  */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------  * Init: This currently just gets the socket address for the GPS daemon  */
end_comment

begin_function
specifier|static
name|void
name|gpsd_init
parameter_list|(
name|void
parameter_list|)
block|{
name|addrinfoT
name|hints
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
comment|/* just take the first configured address of localhost... */
if|if
condition|(
name|getaddrinfo
argument_list|(
literal|"localhost"
argument_list|,
literal|"gpsd"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|s_gpsd_addr
argument_list|)
condition|)
name|s_gpsd_addr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------  * Start: allocate a unit pointer and set up the runtime data  */
end_comment

begin_function
specifier|static
name|int
name|gpsd_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* initialize the unit structure */
name|up
operator|->
name|fdt
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|addr
operator|=
name|s_gpsd_addr
expr_stmt|;
name|up
operator|->
name|tickpres
operator|=
name|TICKOVER_LOW
expr_stmt|;
comment|/* setup refclock processing */
name|up
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|gpsd_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|a_lastcode
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Initialize miscellaneous variables */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
comment|/* Create the device name and check for a Character Device. It's 	 * assumed that GPSD was started with the same link, so the 	 * names match. (If this is not practicable, we will have to 	 * read the symlink, if any, so we can get the true device 	 * file.) 	 */
if|if
condition|(
operator|-
literal|1
operator|==
name|myasprintf
argument_list|(
operator|&
name|up
operator|->
name|device
argument_list|,
literal|"%s%u"
argument_list|,
name|s_dev_stem
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s clock device name too long"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|dev_fail
goto|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|stat
argument_list|(
name|up
operator|->
name|device
argument_list|,
operator|&
name|sb
argument_list|)
operator|||
operator|!
name|S_ISCHR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: '%s' is not a character device"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|up
operator|->
name|device
argument_list|)
expr_stmt|;
goto|goto
name|dev_fail
goto|;
block|}
name|LOGIF
argument_list|(
name|CLOCKINFO
argument_list|,
operator|(
name|LOG_NOTICE
operator|,
literal|"%s: startup, device is '%s'"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|,
name|up
operator|->
name|device
operator|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|dev_fail
label|:
comment|/* On failure, remove all UNIT ressources and declare defeat. */
name|INSIST
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
operator|->
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
condition|)
block|{
name|free
argument_list|(
name|up
operator|->
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|LOGIF
argument_list|(
name|CLOCKINFO
argument_list|,
operator|(
name|LOG_NOTICE
operator|,
literal|"%s: shutdown"
operator|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
comment|/* declare& init control structure ptrs */
name|peerT
modifier|*
specifier|const
name|peer
init|=
name|rbufp
operator|->
name|recv_peer
decl_stmt|;
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|psrc
decl_stmt|,
modifier|*
name|esrc
decl_stmt|;
name|char
modifier|*
name|pdst
decl_stmt|,
modifier|*
name|edst
decl_stmt|,
name|ch
decl_stmt|;
comment|/* Since we're getting a raw stream data, we must assemble lines 	 * in our receive buffer. We can't use neither 'refclock_gtraw' 	 * not 'refclock_gtlin' here...  We process chars until we reach 	 * an EoL (that is, line feed) but we truncate the message if it 	 * does not fit the buffer.  GPSD might truncate messages, too, 	 * so dealing with truncated buffers is necessary anyway. 	 */
name|psrc
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
name|esrc
operator|=
name|psrc
operator|+
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|pdst
operator|=
name|up
operator|->
name|buffer
operator|+
name|up
operator|->
name|buflen
expr_stmt|;
name|edst
operator|=
name|pdst
operator|+
sizeof|sizeof
argument_list|(
name|up
operator|->
name|buffer
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* for trailing NUL */
while|while
condition|(
name|psrc
operator|!=
name|esrc
condition|)
block|{
name|ch
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
comment|/* trim trailing whitespace& terminate buffer */
while|while
condition|(
name|pdst
operator|!=
name|up
operator|->
name|buffer
operator|&&
name|pdst
index|[
operator|-
literal|1
index|]
operator|<=
literal|' '
condition|)
operator|--
name|pdst
expr_stmt|;
operator|*
name|pdst
operator|=
literal|'\0'
expr_stmt|;
comment|/* process data and reset buffer */
name|gpsd_parse
argument_list|(
name|peer
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|)
expr_stmt|;
name|pdst
operator|=
name|up
operator|->
name|buffer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdst
operator|!=
name|edst
condition|)
block|{
comment|/* add next char, ignoring leading whitespace */
if|if
condition|(
name|ch
operator|>
literal|' '
operator|||
name|pdst
operator|!=
name|up
operator|->
name|buffer
condition|)
operator|*
name|pdst
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
name|up
operator|->
name|buflen
operator|=
name|pdst
operator|-
name|up
operator|->
name|buffer
expr_stmt|;
name|up
operator|->
name|tickover
operator|=
name|TICKOVER_LOW
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|u_int
name|tc_max
decl_stmt|;
operator|++
name|pp
operator|->
name|polls
expr_stmt|;
comment|/* find the dominant error */
name|tc_max
operator|=
name|max
argument_list|(
name|up
operator|->
name|tc_btime
argument_list|,
name|up
operator|->
name|tc_bdate
argument_list|)
expr_stmt|;
name|tc_max
operator|=
name|max
argument_list|(
name|tc_max
argument_list|,
name|up
operator|->
name|tc_breply
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|!=
name|pp
operator|->
name|codeproc
condition|)
block|{
comment|/* all is well */
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* not working properly, admit to it */
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
block|{
comment|/* not connected to GPSD: clearly not working! */
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tc_max
operator|==
name|up
operator|->
name|tc_breply
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tc_max
operator|==
name|up
operator|->
name|tc_btime
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tc_max
operator|==
name|up
operator|->
name|tc_bdate
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
name|gpsd_clockstats
argument_list|(
name|unit
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* clear tallies for next round */
name|up
operator|->
name|tc_good
operator|=
name|up
operator|->
name|tc_btime
operator|=
name|up
operator|->
name|tc_bdate
operator|=
name|up
operator|->
name|tc_breply
operator|=
name|up
operator|->
name|tc_recv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_control
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|const
name|struct
name|refclockstat
modifier|*
name|in_st
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out_st
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
comment|/* save preprocessed fudge times */
name|DTOLFP
argument_list|(
name|pp
operator|->
name|fudgetime1
argument_list|,
operator|&
name|up
operator|->
name|pps_fudge
argument_list|)
expr_stmt|;
name|DTOLFP
argument_list|(
name|pp
operator|->
name|fudgetime2
argument_list|,
operator|&
name|up
operator|->
name|tpv_fudge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_timer
parameter_list|(
name|int
name|unit
parameter_list|,
name|peerT
modifier|*
name|peer
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|query
index|[]
init|=
literal|"?VERSION;"
decl_stmt|;
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* This is used for timeout handling. Nothing that needs 	 * sub-second precison happens here, so receive/connect/retry 	 * timeouts are simply handled by a count down, and then we 	 * decide what to do by the socket values. 	 * 	 * Note that the timer stays at zero here, unless some of the 	 * functions set it to another value. 	 */
if|if
condition|(
name|up
operator|->
name|logthrottle
condition|)
operator|--
name|up
operator|->
name|logthrottle
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|tickover
condition|)
operator|--
name|up
operator|->
name|tickover
expr_stmt|;
switch|switch
condition|(
name|up
operator|->
name|tickover
condition|)
block|{
case|case
literal|4
case|:
comment|/* try to get a live signal 		 * If the device is not yet present, we will most likely 		 * get an error. We put out a new version request, 		 * because the reply will initiate a new watch request 		 * cycle. 		 */
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
block|{
if|if
condition|(
operator|!
name|up
operator|->
name|fl_watch
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"GPSD_JSON(%d): timer livecheck: '%s'\n"
operator|,
name|up
operator|->
name|unit
operator|,
name|query
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|query
argument_list|,
sizeof|sizeof
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
block|{
name|gpsd_test_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|gpsd_stop_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
name|gpsd_test_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
operator|!=
name|s_gpsd_addr
condition|)
name|gpsd_init_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|-
literal|1
operator|==
name|pp
operator|->
name|io
operator|.
name|fd
operator|&&
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
name|gpsd_test_socket
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|ppscount
operator|>
name|PPS_HIWAT
operator|&&
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PPS
operator|)
condition|)
name|peer
operator|->
name|flags
operator||=
name|FLAG_PPS
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ppscount
operator|<
name|PPS_LOWAT
operator|&&
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PPS
operator|)
condition|)
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_PPS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * JSON parsing stuff  */
end_comment

begin_define
define|#
directive|define
name|JSMN_MAXTOK
value|100
end_define

begin_define
define|#
directive|define
name|INVALID_TOKEN
value|(-1)
end_define

begin_typedef
typedef|typedef
struct|struct
name|json_ctx
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|ntok
decl_stmt|;
name|jsmntok_t
name|tok
index|[
name|JSMN_MAXTOK
index|]
decl_stmt|;
block|}
name|json_ctx
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|tok_ref
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LONG_LONG
end_ifdef

begin_typedef
typedef|typedef
name|long
name|long
name|json_int
typedef|;
end_typedef

begin_define
define|#
directive|define
name|JSON_STRING_TO_INT
value|strtoll
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|long
name|json_int
typedef|;
end_typedef

begin_define
define|#
directive|define
name|JSON_STRING_TO_INT
value|strtol
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|tok_ref
name|json_token_skip
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|size
expr_stmt|;
for|for
control|(
operator|++
name|tid
init|;
name|len
condition|;
operator|--
name|len
control|)
if|if
condition|(
name|tid
operator|<
name|ctx
operator|->
name|ntok
condition|)
name|tid
operator|=
name|json_token_skip
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|tid
operator|>
name|ctx
operator|->
name|ntok
condition|)
name|tid
operator|=
name|ctx
operator|->
name|ntok
expr_stmt|;
return|return
name|tid
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|json_object_lookup
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|tid
operator|>=
name|ctx
operator|->
name|ntok
operator|||
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|type
operator|!=
name|JSMN_OBJECT
condition|)
return|return
name|INVALID_TOKEN
return|;
name|len
operator|=
name|ctx
operator|->
name|ntok
operator|-
name|tid
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|size
condition|)
name|len
operator|=
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|size
expr_stmt|;
for|for
control|(
name|tid
operator|+=
literal|1
init|;
name|len
operator|>
literal|1
condition|;
name|len
operator|-=
literal|2
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|type
operator|!=
name|JSMN_STRING
condition|)
continue|continue;
comment|/* hmmm... that's an error, strictly speaking */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|ctx
operator|->
name|buf
operator|+
name|ctx
operator|->
name|tok
index|[
name|tid
index|]
operator|.
name|start
argument_list|)
condition|)
return|return
name|tid
operator|+
literal|1
return|;
name|tid
operator|=
name|json_token_skip
argument_list|(
name|ctx
argument_list|,
name|tid
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|INVALID_TOKEN
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* currently unused */
end_comment

begin_endif
unit|static const char* json_object_lookup_string( 	const json_ctx * ctx, 	tok_ref          tid, 	const char     * key) { 	tok_ref val_ref; 	val_ref = json_object_lookup(ctx, tid, key); 	if (INVALID_TOKEN == val_ref               || 	    JSMN_STRING   != ctx->tok[val_ref].type ) 		goto cvt_error; 	return ctx->buf + ctx->tok[val_ref].start;    cvt_error: 	errno = EINVAL; 	return NULL; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|json_object_lookup_string_default
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|)
block|{
name|tok_ref
name|val_ref
decl_stmt|;
name|val_ref
operator|=
name|json_object_lookup
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_TOKEN
operator|==
name|val_ref
operator|||
name|JSMN_STRING
operator|!=
name|ctx
operator|->
name|tok
index|[
name|val_ref
index|]
operator|.
name|type
condition|)
return|return
name|def
return|;
return|return
name|ctx
operator|->
name|buf
operator|+
name|ctx
operator|->
name|tok
index|[
name|val_ref
index|]
operator|.
name|start
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|json_int
name|json_object_lookup_int
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|json_int
name|ret
decl_stmt|;
name|tok_ref
name|val_ref
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|val_ref
operator|=
name|json_object_lookup
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_TOKEN
operator|==
name|val_ref
operator|||
name|JSMN_PRIMITIVE
operator|!=
name|ctx
operator|->
name|tok
index|[
name|val_ref
index|]
operator|.
name|type
condition|)
goto|goto
name|cvt_error
goto|;
name|ret
operator|=
name|JSON_STRING_TO_INT
argument_list|(
name|ctx
operator|->
name|buf
operator|+
name|ctx
operator|->
name|tok
index|[
name|val_ref
index|]
operator|.
name|start
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
goto|goto
name|cvt_error
goto|;
return|return
name|ret
return|;
name|cvt_error
label|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|json_int
name|json_object_lookup_int_default
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|json_int
name|def
parameter_list|)
block|{
name|json_int
name|retv
decl_stmt|;
name|int
name|esave
decl_stmt|;
name|esave
operator|=
name|errno
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|retv
operator|=
name|json_object_lookup_int
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|errno
condition|)
name|retv
operator|=
name|def
expr_stmt|;
name|errno
operator|=
name|esave
expr_stmt|;
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|double
name|json_object_lookup_float
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|double
name|ret
decl_stmt|;
name|tok_ref
name|val_ref
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|val_ref
operator|=
name|json_object_lookup
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_TOKEN
operator|==
name|val_ref
operator|||
name|JSMN_PRIMITIVE
operator|!=
name|ctx
operator|->
name|tok
index|[
name|val_ref
index|]
operator|.
name|type
condition|)
goto|goto
name|cvt_error
goto|;
name|ret
operator|=
name|strtod
argument_list|(
name|ctx
operator|->
name|buf
operator|+
name|ctx
operator|->
name|tok
index|[
name|val_ref
index|]
operator|.
name|start
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
goto|goto
name|cvt_error
goto|;
return|return
name|ret
return|;
name|cvt_error
label|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0.0
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|json_object_lookup_float_default
parameter_list|(
specifier|const
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|tok_ref
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|double
name|def
parameter_list|)
block|{
name|double
name|retv
decl_stmt|;
name|int
name|esave
decl_stmt|;
name|esave
operator|=
name|errno
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|retv
operator|=
name|json_object_lookup_float
argument_list|(
name|ctx
argument_list|,
name|tid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|errno
condition|)
name|retv
operator|=
name|def
expr_stmt|;
name|errno
operator|=
name|esave
expr_stmt|;
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|BOOL
name|json_parse_record
parameter_list|(
name|json_ctx
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|jsmn_parser
name|jsm
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rc
decl_stmt|;
name|jsmn_init
argument_list|(
operator|&
name|jsm
argument_list|)
expr_stmt|;
name|rc
operator|=
name|jsmn_parse
argument_list|(
operator|&
name|jsm
argument_list|,
name|buf
argument_list|,
name|ctx
operator|->
name|tok
argument_list|,
name|JSMN_MAXTOK
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|ctx
operator|->
name|ntok
operator|=
name|jsm
operator|.
name|toknext
expr_stmt|;
comment|/* Make all tokens NUL terminated by overwriting the 	 * terminator symbol 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|jsm
operator|.
name|toknext
condition|;
operator|++
name|idx
control|)
if|if
condition|(
name|ctx
operator|->
name|tok
index|[
name|idx
index|]
operator|.
name|end
operator|>
name|ctx
operator|->
name|tok
index|[
name|idx
index|]
operator|.
name|start
condition|)
name|ctx
operator|->
name|buf
index|[
name|ctx
operator|->
name|tok
index|[
name|idx
index|]
operator|.
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|JSMN_ERROR_PART
operator|!=
name|rc
operator|&&
name|JSMN_ERROR_NOMEM
operator|!=
name|rc
operator|&&
name|JSMN_SUCCESS
operator|!=
name|rc
condition|)
return|return
name|FALSE
return|;
comment|/* not parseable - bail out */
if|if
condition|(
literal|0
operator|>=
name|jsm
operator|.
name|toknext
operator|||
name|JSMN_OBJECT
operator|!=
name|ctx
operator|->
name|tok
index|[
literal|0
index|]
operator|.
name|type
condition|)
return|return
name|FALSE
return|;
comment|/* not object or no data!?! */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * static local helpers  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Process a WATCH record  *  * Currently this is only used to recognise that the device is present  * and that we're listed subscribers.  */
end_comment

begin_function
specifier|static
name|void
name|process_watch
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|up
operator|->
name|fl_watch
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|process_version
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|release
decl_stmt|;
comment|/* get protocol version number */
name|revision
operator|=
name|json_object_lookup_string_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"rev"
argument_list|,
literal|"(unknown)"
argument_list|)
expr_stmt|;
name|release
operator|=
name|json_object_lookup_string_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"release"
argument_list|,
literal|"(unknown)"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|proto_major
operator|=
operator|(
name|uint16_t
operator|)
name|json_object_lookup_int
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"proto_major"
argument_list|)
expr_stmt|;
name|up
operator|->
name|proto_minor
operator|=
operator|(
name|uint16_t
operator|)
name|json_object_lookup_int
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"proto_minor"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|errno
condition|)
block|{
name|up
operator|->
name|fl_vers
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: GPSD revision=%s release=%s protocol=%u.%u"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|revision
argument_list|,
name|release
argument_list|,
name|up
operator|->
name|proto_major
argument_list|,
name|up
operator|->
name|proto_minor
argument_list|)
expr_stmt|;
block|}
comment|/* With the 3.9 GPSD protocol, '*_musec' vanished and was 	 * replace by '*_nsec'. Dispatch properly. 	 */
if|if
condition|(
name|up
operator|->
name|proto_major
operator|>
literal|3
operator|||
operator|(
name|up
operator|->
name|proto_major
operator|==
literal|3
operator|&&
name|up
operator|->
name|proto_minor
operator|>=
literal|9
operator|)
condition|)
name|up
operator|->
name|fl_nsec
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|up
operator|->
name|fl_nsec
operator|=
literal|0
expr_stmt|;
comment|/*TODO: validate protocol version! */
comment|/* request watch for our GPS device 	 * Reuse the input buffer, which is no longer needed in the 	 * current cycle. Also assume that we can write the watch 	 * request in one sweep into the socket; since we do not do 	 * output otherwise, this should always work.  (Unless the 	 * TCP/IP window size gets lower than the length of the 	 * request. We handle that when it happens.) 	 */
name|snprintf
argument_list|(
name|up
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|buffer
argument_list|)
argument_list|,
name|s_logon
argument_list|,
name|up
operator|->
name|device
argument_list|)
expr_stmt|;
name|buf
operator|=
name|up
operator|->
name|buffer
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/*Note: if the server fails to read our request, the 		 * resulting data timeout will take care of the 		 * connection! 		 */
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: failed to write watch request (%m)"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|process_tpv
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|gps_time
decl_stmt|;
name|int
name|gps_mode
decl_stmt|;
name|double
name|ept
decl_stmt|,
name|epp
decl_stmt|,
name|epx
decl_stmt|,
name|epy
decl_stmt|,
name|epv
decl_stmt|;
name|int
name|log2
decl_stmt|;
name|gps_mode
operator|=
operator|(
name|int
operator|)
name|json_object_lookup_int_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"mode"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gps_time
operator|=
name|json_object_lookup_string_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"time"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gps_mode
operator|<
literal|1
operator|||
name|NULL
operator|==
name|gps_time
condition|)
block|{
comment|/* receiver has no fix; tell about and avoid stale data */
name|up
operator|->
name|tc_breply
operator|+=
literal|1
expr_stmt|;
name|up
operator|->
name|fl_tpv
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_pps
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* save last time code to clock data */
name|save_ltc
argument_list|(
name|pp
argument_list|,
name|gps_time
argument_list|)
expr_stmt|;
comment|/* convert clock and set resulting ref time */
if|if
condition|(
name|convert_ascii_time
argument_list|(
operator|&
name|up
operator|->
name|tpv_stamp
argument_list|,
name|gps_time
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"GPSD_JSON(%d): process_tpv, stamp='%s', recvt='%s' mode=%u\n"
operator|,
name|up
operator|->
name|unit
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|tpv_stamp
argument_list|)
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|tpv_recvt
argument_list|)
operator|,
name|gps_mode
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|tpv_local
operator|=
operator|*
name|rtime
expr_stmt|;
name|up
operator|->
name|tpv_recvt
operator|=
operator|*
name|rtime
expr_stmt|;
comment|/*TODO: hack until we get it remote from GPSD */
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|tpv_recvt
argument_list|,
operator|&
name|up
operator|->
name|tpv_fudge
argument_list|)
expr_stmt|;
name|up
operator|->
name|fl_tpv
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|tc_btime
operator|+=
literal|1
expr_stmt|;
name|up
operator|->
name|fl_tpv
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set the precision from the GPSD data 	 * 	 * Since EPT has some issues, we use EPT and a home-brewed error 	 * estimation base on a sphere derived from EPX/Y/V and the 	 * speed of light. Use the better one of those two. 	 */
name|ept
operator|=
name|json_object_lookup_float_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"ept"
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|epx
operator|=
name|json_object_lookup_float_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"epx"
argument_list|,
literal|1000.0
argument_list|)
expr_stmt|;
name|epy
operator|=
name|json_object_lookup_float_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"epy"
argument_list|,
literal|1000.0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|gps_mode
condition|)
block|{
comment|/* 2d-fix: extend bounding rectangle to cuboid */
name|epv
operator|=
name|max
argument_list|(
name|epx
argument_list|,
name|epy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 3d-fix: get bounding cuboid */
name|epv
operator|=
name|json_object_lookup_float_default
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"epv"
argument_list|,
literal|1000.0
argument_list|)
expr_stmt|;
block|}
comment|/* get diameter of enclosing sphere of bounding cuboid as spatial 	 * error, then divide spatial error by speed of light to get 	 * another time error estimate. Add extra 100 meters as 	 * optimistic lower bound. Then use the better one of the two 	 * estimations. 	 */
name|epp
operator|=
literal|2.0
operator|*
name|sqrt
argument_list|(
name|epx
operator|*
name|epx
operator|+
name|epy
operator|*
name|epy
operator|+
name|epv
operator|*
name|epv
argument_list|)
expr_stmt|;
name|epp
operator|=
operator|(
name|epp
operator|+
literal|100.0
operator|)
operator|/
literal|299792458.0
expr_stmt|;
name|ept
operator|=
name|min
argument_list|(
name|ept
argument_list|,
name|epp
argument_list|)
expr_stmt|;
name|ept
operator|=
name|min
argument_list|(
name|ept
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
name|ept
operator|=
name|max
argument_list|(
name|ept
argument_list|,
literal|1.0
operator|-
literal|9
argument_list|)
expr_stmt|;
name|ept
operator|=
name|frexp
argument_list|(
name|ept
argument_list|,
operator|&
name|log2
argument_list|)
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|log2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|process_pps
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
name|json_ctx
modifier|*
specifier|const
name|jctx
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|json_object_lookup_int
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"clock_sec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fl_nsec
condition|)
name|ts
operator|.
name|tv_nsec
operator|=
name|json_object_lookup_int
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"clock_nsec"
argument_list|)
expr_stmt|;
else|else
name|ts
operator|.
name|tv_nsec
operator|=
name|json_object_lookup_int
argument_list|(
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"clock_musec"
argument_list|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|errno
condition|)
goto|goto
name|fail
goto|;
name|up
operator|->
name|pps_local
operator|=
operator|*
name|rtime
expr_stmt|;
comment|/* get fudged receive time */
name|up
operator|->
name|pps_recvt
operator|=
name|tspec_stamp_to_lfp
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|up
operator|->
name|pps_recvt
argument_list|,
operator|&
name|up
operator|->
name|pps_fudge
argument_list|)
expr_stmt|;
comment|/* map to next full second as reference time stamp */
name|up
operator|->
name|pps_stamp
operator|=
name|up
operator|->
name|pps_recvt
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|up
operator|->
name|pps_stamp
argument_list|,
literal|0x80000000u
argument_list|)
expr_stmt|;
name|up
operator|->
name|pps_stamp
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|pps_stamp
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"GPSD_JSON(%d): process_pps, stamp='%s', recvt='%s'\n"
operator|,
name|up
operator|->
name|unit
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|pps_stamp
argument_list|)
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|pps_recvt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* When we have a time pulse, clear the TPV flag: the 	 * PPS is only valid for the>NEXT< TPV value! 	 */
name|up
operator|->
name|fl_pps
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|fl_tpv
operator|=
literal|0
expr_stmt|;
return|return;
name|fail
label|:
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"GPSD_JSON(%d): process_pps FAILED, nsec=%d stamp='%s', recvt='%s'\n"
operator|,
name|up
operator|->
name|unit
operator|,
name|up
operator|->
name|fl_nsec
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|pps_stamp
argument_list|)
operator|,
name|gmprettydate
argument_list|(
operator|&
name|up
operator|->
name|pps_recvt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|tc_breply
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_parse
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|,
specifier|const
name|l_fp
modifier|*
specifier|const
name|rtime
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|json_ctx
name|jctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|clsid
decl_stmt|;
name|l_fp
name|tmpfp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"GPSD_JSON(%d): gpsd_parse: time %s '%s'\n"
operator|,
name|up
operator|->
name|unit
operator|,
name|ulfptoa
argument_list|(
name|rtime
argument_list|,
literal|6
argument_list|)
operator|,
name|up
operator|->
name|buffer
operator|)
argument_list|)
expr_stmt|;
comment|/* See if we can grab anything potentially useful */
if|if
condition|(
operator|!
name|json_parse_record
argument_list|(
operator|&
name|jctx
argument_list|,
name|up
operator|->
name|buffer
argument_list|)
condition|)
return|return;
comment|/* Now dispatch over the objects we know */
name|clsid
operator|=
name|json_object_lookup_string_default
argument_list|(
operator|&
name|jctx
argument_list|,
literal|0
argument_list|,
literal|"class"
argument_list|,
literal|"-bad-repy-"
argument_list|)
expr_stmt|;
name|up
operator|->
name|tc_recv
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"VERSION"
argument_list|,
name|clsid
argument_list|)
condition|)
name|process_version
argument_list|(
name|peer
argument_list|,
operator|&
name|jctx
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"TPV"
argument_list|,
name|clsid
argument_list|)
condition|)
name|process_tpv
argument_list|(
name|peer
argument_list|,
operator|&
name|jctx
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"PPS"
argument_list|,
name|clsid
argument_list|)
condition|)
name|process_pps
argument_list|(
name|peer
argument_list|,
operator|&
name|jctx
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"WATCH"
argument_list|,
name|clsid
argument_list|)
condition|)
name|process_watch
argument_list|(
name|peer
argument_list|,
operator|&
name|jctx
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
else|else
return|return;
comment|/* nothing we know about... */
comment|/* now aggregate TPV and PPS -- no PPS? just use TPV...*/
if|if
condition|(
name|up
operator|->
name|fl_tpv
condition|)
block|{
comment|/* TODO: also check remote receive time stamps */
name|tmpfp
operator|=
name|up
operator|->
name|tpv_local
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tmpfp
argument_list|,
operator|&
name|up
operator|->
name|pps_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fl_pps
operator|&&
literal|0
operator|==
name|tmpfp
operator|.
name|l_ui
condition|)
block|{
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|up
operator|->
name|tpv_stamp
argument_list|,
name|up
operator|->
name|pps_recvt
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ppscount
operator|<
name|PPS_MAXCOUNT
condition|)
name|up
operator|->
name|ppscount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|refclock_process_offset
argument_list|(
name|pp
argument_list|,
name|up
operator|->
name|tpv_stamp
argument_list|,
name|up
operator|->
name|tpv_recvt
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|ppscount
operator|>
literal|0
condition|)
name|up
operator|->
name|ppscount
operator|-=
literal|1
expr_stmt|;
block|}
name|up
operator|->
name|fl_pps
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_tpv
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|tc_good
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_stop_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: closing socket to GPSD"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|tickover
operator|=
name|up
operator|->
name|tickpres
expr_stmt|;
name|up
operator|->
name|tickpres
operator|=
name|min
argument_list|(
name|up
operator|->
name|tickpres
operator|+
literal|5
argument_list|,
name|TICKOVER_HIGH
argument_list|)
expr_stmt|;
name|up
operator|->
name|fl_vers
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_tpv
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_pps
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|fl_watch
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_init_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|addrinfoT
modifier|*
name|ai
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|ov
decl_stmt|;
comment|/* draw next address to try */
if|if
condition|(
name|NULL
operator|==
name|up
operator|->
name|addr
condition|)
name|up
operator|->
name|addr
operator|=
name|s_gpsd_addr
expr_stmt|;
name|ai
operator|=
name|up
operator|->
name|addr
expr_stmt|;
name|up
operator|->
name|addr
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
comment|/* try to create a matching socket */
name|up
operator|->
name|fdt
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|up
operator|->
name|fdt
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: cannot create GPSD socket: %m"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
comment|/* make sure the socket is non-blocking */
name|rc
operator|=
name|fcntl
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: cannot set GPSD socket to non-blocking: %m"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
comment|/* disable nagling */
name|ov
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|setsockopt
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_NODELAY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ov
argument_list|,
sizeof|sizeof
argument_list|(
name|ov
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: cannot disable TCP nagle: %m"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* start a non-blocking connect */
name|rc
operator|=
name|connect
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
operator|&&
name|errno
operator|!=
name|EINPROGRESS
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: cannot connect GPSD socket: %m"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
return|return;
name|no_socket
label|:
if|if
condition|(
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
name|close
argument_list|(
name|up
operator|->
name|fdt
argument_list|)
expr_stmt|;
name|up
operator|->
name|fdt
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|tickover
operator|=
name|up
operator|->
name|tickpres
expr_stmt|;
name|up
operator|->
name|tickpres
operator|=
name|min
argument_list|(
name|up
operator|->
name|tickpres
operator|+
literal|5
argument_list|,
name|TICKOVER_HIGH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|gpsd_test_socket
parameter_list|(
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|int
name|ec
decl_stmt|,
name|rc
decl_stmt|;
name|socklen_t
name|lc
decl_stmt|;
comment|/* Check if the non-blocking connect was finished by testing the 	 * socket for writeability. Use the 'poll()' API if available 	 * and 'select()' otherwise. 	 */
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"GPSD_JSON(%d): check connect, fd=%d\n"
operator|,
name|up
operator|->
name|unit
operator|,
name|up
operator|->
name|fdt
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_POLL_H
argument_list|)
block|{
name|struct
name|pollfd
name|pfd
decl_stmt|;
name|pfd
operator|.
name|events
operator|=
name|POLLOUT
expr_stmt|;
name|pfd
operator|.
name|fd
operator|=
name|up
operator|->
name|fdt
expr_stmt|;
name|rc
operator|=
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|rc
operator|||
operator|!
operator|(
name|pfd
operator|.
name|revents
operator|&
name|POLLOUT
operator|)
condition|)
return|return;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_SELECT_H
argument_list|)
block|{
name|struct
name|timeval
name|tout
decl_stmt|;
name|fd_set
name|wset
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tout
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tout
argument_list|)
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|wset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
operator|&
name|wset
argument_list|)
expr_stmt|;
name|rc
operator|=
name|select
argument_list|(
name|up
operator|->
name|fdt
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|wset
argument_list|,
name|NULL
argument_list|,
operator|&
name|tout
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|rc
operator|||
operator|!
operator|(
name|FD_ISSET
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
operator|&
name|wset
argument_list|)
operator|)
condition|)
return|return;
block|}
else|#
directive|else
error|#
directive|error
error|Blooper! That should have been found earlier!
endif|#
directive|endif
comment|/* next timeout is a full one... */
name|up
operator|->
name|tickover
operator|=
name|TICKOVER_LOW
expr_stmt|;
comment|/* check for socket error */
name|ec
operator|=
literal|0
expr_stmt|;
name|lc
operator|=
sizeof|sizeof
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|rc
operator|=
name|getsockopt
argument_list|(
name|up
operator|->
name|fdt
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|&
name|ec
argument_list|,
operator|&
name|lc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"GPSD_JSON(%d): connect finshed, fd=%d, ec=%d(%s)\n"
operator|,
name|up
operator|->
name|unit
operator|,
name|up
operator|->
name|fdt
operator|,
name|ec
operator|,
name|strerror
argument_list|(
name|ec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
operator|||
literal|0
operator|!=
name|ec
condition|)
block|{
name|errno
operator|=
name|ec
expr_stmt|;
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: (async)cannot connect GPSD socket: %m"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
comment|/* swap socket FDs, and make sure the clock was added */
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|up
operator|->
name|fdt
expr_stmt|;
name|up
operator|->
name|fdt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|syslogok
argument_list|(
name|pp
argument_list|,
name|up
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: failed to register with I/O engine"
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|no_socket
goto|;
block|}
return|return;
name|no_socket
label|:
if|if
condition|(
operator|-
literal|1
operator|!=
name|up
operator|->
name|fdt
condition|)
name|close
argument_list|(
name|up
operator|->
name|fdt
argument_list|)
expr_stmt|;
name|up
operator|->
name|fdt
operator|=
operator|-
literal|1
expr_stmt|;
name|up
operator|->
name|tickover
operator|=
name|up
operator|->
name|tickpres
expr_stmt|;
name|up
operator|->
name|tickpres
operator|=
name|min
argument_list|(
name|up
operator|->
name|tickpres
operator|+
literal|5
argument_list|,
name|TICKOVER_HIGH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * helper stuff  */
end_comment

begin_comment
comment|/*  * shm_clockstats - dump and reset counters  */
end_comment

begin_function
specifier|static
name|void
name|gpsd_clockstats
parameter_list|(
name|int
name|unit
parameter_list|,
name|peerT
modifier|*
specifier|const
name|peer
parameter_list|)
block|{
name|clockprocT
modifier|*
specifier|const
name|pp
init|=
name|peer
operator|->
name|procptr
decl_stmt|;
name|gpsd_unitT
modifier|*
specifier|const
name|up
init|=
operator|(
name|gpsd_unitT
operator|*
operator|)
name|pp
operator|->
name|unitptr
decl_stmt|;
name|char
name|logbuf
index|[
literal|128
index|]
decl_stmt|;
name|unsigned
name|int
name|llen
decl_stmt|;
comment|/* if snprintf() returns a negative values on errors (some older 	* ones do) make sure we are NUL terminated. Using an unsigned 	* result does the trick. 	*/
name|llen
operator|=
name|snprintf
argument_list|(
name|logbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|logbuf
argument_list|)
argument_list|,
literal|"good=%-3u badtime=%-3u baddate=%-3u badreply=%-3u recv=%-3u"
argument_list|,
name|up
operator|->
name|tc_good
argument_list|,
name|up
operator|->
name|tc_btime
argument_list|,
name|up
operator|->
name|tc_bdate
argument_list|,
name|up
operator|->
name|tc_breply
argument_list|,
name|up
operator|->
name|tc_recv
argument_list|)
expr_stmt|;
name|logbuf
index|[
name|min
argument_list|(
name|llen
argument_list|,
sizeof|sizeof
argument_list|(
name|logbuf
argument_list|)
operator|-
literal|1
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|logbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * Convert a GPSD timestam (ISO8601 Format) to an l_fp  */
end_comment

begin_function
specifier|static
name|BOOL
name|convert_ascii_time
parameter_list|(
name|l_fp
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|gps_time
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|struct
name|tm
name|gd
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|long
name|dw
decl_stmt|;
comment|/* Use 'strptime' to take the brunt of the work, then parse 	 * the fractional part manually, starting with a digit weight of 	 * 10^8 nanoseconds. 	 */
name|ts
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|ep
operator|=
name|strptime
argument_list|(
name|gps_time
argument_list|,
literal|"%Y-%m-%dT%H:%M:%S"
argument_list|,
operator|&
name|gd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'.'
condition|)
block|{
name|dw
operator|=
literal|100000000
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ep
argument_list|)
condition|)
block|{
name|ts
operator|.
name|tv_nsec
operator|+=
operator|(
operator|*
name|ep
operator|-
literal|'0'
operator|)
operator|*
name|dw
expr_stmt|;
name|dw
operator|/=
literal|10
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ep
index|[
literal|0
index|]
operator|!=
literal|'Z'
operator|||
name|ep
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
comment|/* now convert the whole thing into a 'l_fp' */
name|ts
operator|.
name|tv_sec
operator|=
operator|(
name|ntpcal_tm_to_rd
argument_list|(
operator|&
name|gd
argument_list|)
operator|-
name|DAY_NTP_STARTS
operator|)
operator|*
name|SECSPERDAY
operator|+
name|ntpcal_tm_to_daysec
argument_list|(
operator|&
name|gd
argument_list|)
expr_stmt|;
operator|*
name|fp
operator|=
name|tspec_intv_to_lfp
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * Save the last timecode string, making sure it's properly truncated  * if necessary and NUL terminated in any case.  */
end_comment

begin_function
specifier|static
name|void
name|save_ltc
parameter_list|(
name|clockprocT
modifier|*
specifier|const
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|tc
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
operator|(
name|tc
operator|)
condition|?
name|strlen
argument_list|(
name|tc
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
operator|(
name|u_short
operator|)
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
name|tc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pp
operator|->
name|a_lastcode
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * asprintf replacement... it's not available everywhere...  */
end_comment

begin_function
specifier|static
name|int
name|myasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|spp
parameter_list|,
name|char
specifier|const
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|size_t
name|alen
decl_stmt|,
name|plen
decl_stmt|;
name|alen
operator|=
literal|32
expr_stmt|;
operator|*
name|spp
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|va_list
name|va
decl_stmt|;
name|alen
operator|+=
name|alen
expr_stmt|;
name|free
argument_list|(
operator|*
name|spp
argument_list|)
expr_stmt|;
operator|*
name|spp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|alen
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|*
name|spp
condition|)
return|return
operator|-
literal|1
return|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|plen
operator|=
operator|(
name|size_t
operator|)
name|vsnprintf
argument_list|(
operator|*
name|spp
argument_list|,
name|alen
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|plen
operator|>=
name|alen
condition|)
do|;
return|return
operator|(
name|int
operator|)
name|plen
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_macro
name|NONEMPTY_TRANSLATION_UNIT
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK&& CLOCK_GPSDJSON */
end_comment

end_unit

