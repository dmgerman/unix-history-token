begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_as2201 - clock driver for the Austron 2201A GPS  *	Timing Receiver  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_AS2201
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  * This driver supports the Austron 2200A/2201A GPS Receiver with  * Buffered RS-232-C Interface Module. Note that the original 2200/2201  * receivers will not work reliably with this driver, since the older  * design cannot accept input commands at any reasonable data rate.  *  * The program sends a "*toc\r" to the radio and expects a response of  * the form "yy:ddd:hh:mm:ss.mmm\r" where yy = year of century, ddd =  * day of year, hh:mm:ss = second of day and mmm = millisecond of  * second. Then, it sends statistics commands to the radio and expects  * a multi-line reply showing the corresponding statistics or other  * selected data. Statistics commands are sent in order as determined by  * a vector of commands; these might have to be changed with different  * radio options. If flag4 of the fudge configuration command is set to  * 1, the statistics data are written to the clockstats file for later  * processing.  *  * In order for this code to work, the radio must be placed in non-  * interactive mode using the "off" command and with a single<cr>  * response using the "term cr" command. The setting of the "echo"  * and "df" commands does not matter. The radio should select UTC  * timescale using the "ts utc" command.  *  * There are two modes of operation for this driver. The first with  * default configuration is used with stock kernels and serial-line  * drivers and works with almost any machine. In this mode the driver  * assumes the radio captures a timestamp upon receipt of the "*" that  * begins the driver query. Accuracies in this mode are in the order of  * a millisecond or two and the receiver can be connected to only one  * host.  *  * The second mode of operation can be used for SunOS kernels that have  * been modified with the ppsclock streams module included in this  * distribution. The mode is enabled if flag3 of the fudge configuration  * command has been set to 1. In this mode a precise timestamp is  * available using a gadget box and 1-pps signal from the receiver. This  * improves the accuracy to the order of a few tens of microseconds. In  * addition, the serial output and 1-pps signal can be bussed to more  * than one hosts, but only one of them should be connected to the  * radio input data line.   */
end_comment

begin_comment
comment|/*  * GPS Definitions  */
end_comment

begin_define
define|#
directive|define
name|SMAX
value|200
end_define

begin_comment
comment|/* statistics buffer length */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/gps%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B9600
end_define

begin_comment
comment|/* uart speed (9600 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 us) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"GPS\0"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Austron 2201A GPS Receiver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|LENTOC
value|19
end_define

begin_comment
comment|/* yy:ddd:hh:mm:ss.mmm timecode lngth */
end_comment

begin_comment
comment|/*  * AS2201 unit control structure.  */
end_comment

begin_struct
struct|struct
name|as2201unit
block|{
name|char
modifier|*
name|lastptr
decl_stmt|;
comment|/* statistics buffer pointer */
name|char
name|stats
index|[
name|SMAX
index|]
decl_stmt|;
comment|/* statistics buffer */
name|int
name|linect
decl_stmt|;
comment|/* count of lines remaining */
name|int
name|index
decl_stmt|;
comment|/* current statistics command */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Radio commands to extract statitistics  *  * A command consists of an ASCII string terminated by a<cr> (\r). The  * command list consist of a sequence of commands terminated by a null  * string ("\0"). One command from the list is sent immediately  * following each received timecode (*toc\r command) and the ASCII  * strings received from the radio are saved along with the timecode in  * the clockstats file. Subsequent commands are sent at each timecode,  * with the last one in the list followed by the first one. The data  * received from the radio consist of ASCII strings, each terminated by  * a<cr> (\r) character. The number of strings for each command is  * specified as the first line of output as an ASCII-encode number. Note  * that the ETF command requires the Input Buffer Module and the LORAN  * commands require the LORAN Assist Module. However, if these modules  * are not installed, the radio and this driver will continue to operate  * successfuly, but no data will be captured for these commands.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|stat_command
index|[]
index|[
literal|30
index|]
init|=
block|{
literal|"ITF\r"
block|,
comment|/* internal time/frequency */
literal|"ETF\r"
block|,
comment|/* external time/frequency */
literal|"LORAN ENSEMBLE\r"
block|,
comment|/* GPS/LORAN ensemble statistics */
literal|"LORAN TDATA\r"
block|,
comment|/* LORAN signal data */
literal|"ID;OPT;VER\r"
block|,
comment|/* model; options; software version */
literal|"ITF\r"
block|,
comment|/* internal time/frequency */
literal|"ETF\r"
block|,
comment|/* external time/frequency */
literal|"LORAN ENSEMBLE\r"
block|,
comment|/* GPS/LORAN ensemble statistics */
literal|"TRSTAT\r"
block|,
comment|/* satellite tracking status */
literal|"POS;PPS;PPSOFF\r"
block|,
comment|/* position, pps source, offsets */
literal|"ITF\r"
block|,
comment|/* internal time/frequency */
literal|"ETF\r"
block|,
comment|/* external time/frequency */
literal|"LORAN ENSEMBLE\r"
block|,
comment|/* GPS/LORAN ensemble statistics */
literal|"LORAN TDATA\r"
block|,
comment|/* LORAN signal data */
literal|"UTC\r"
block|,
comment|/* UTC leap info */
literal|"ITF\r"
block|,
comment|/* internal time/frequency */
literal|"ETF\r"
block|,
comment|/* external time/frequency */
literal|"LORAN ENSEMBLE\r"
block|,
comment|/* GPS/LORAN ensemble statistics */
literal|"TRSTAT\r"
block|,
comment|/* satellite tracking status */
literal|"OSC;ET;TEMP\r"
block|,
comment|/* osc type; tune volts; oven temp */
literal|"\0"
comment|/* end of table */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|as2201_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|as2201_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|as2201_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|as2201_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_as2201
init|=
block|{
name|as2201_start
block|,
comment|/* start up driver */
name|as2201_shutdown
block|,
comment|/* shut down driver */
name|as2201_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old as2201_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old as2201_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * as2201_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|as2201_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|as2201unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|gpsdev
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Open serial port. Use CLK line discipline, if available. 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|gpsdev
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|gpsdev
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_CLK
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|as2201unit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|as2201unit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|as2201unit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|as2201_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|NSTAGE
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|lastptr
operator|=
name|up
operator|->
name|stats
expr_stmt|;
name|up
operator|->
name|index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * as2201_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|as2201_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
specifier|register
name|struct
name|as2201unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|as2201unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * as2201__receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|as2201_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|as2201unit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
name|trtmp
decl_stmt|;
comment|/* 	 * Initialize pointers and read the timecode and timestamp. 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|as2201unit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|trtmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"gps: timecode %d %d %s\n"
argument_list|,
name|up
operator|->
name|linect
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pp
operator|->
name|lencode
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If linect is greater than zero, we must be in the middle of a 	 * statistics operation, so simply tack the received data at the 	 * end of the statistics string. If not, we could either have 	 * just received the timecode itself or a decimal number 	 * indicating the number of following lines of the statistics 	 * reply. In the former case, write the accumulated statistics 	 * data to the clockstats file and continue onward to process 	 * the timecode; in the later case, save the number of lines and 	 * quietly return. 	 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
name|pp
operator|->
name|lastrec
operator|=
name|trtmp
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|linect
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|linect
operator|--
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|up
operator|->
name|lastptr
operator|-
name|up
operator|->
name|stats
operator|+
name|pp
operator|->
name|lencode
argument_list|)
operator|>
name|SMAX
operator|-
literal|2
condition|)
return|return;
operator|*
name|up
operator|->
name|lastptr
operator|++
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|up
operator|->
name|lastptr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|up
operator|->
name|lastptr
operator|+=
name|pp
operator|->
name|lencode
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|pp
operator|->
name|lencode
operator|==
literal|1
condition|)
block|{
name|up
operator|->
name|linect
operator|=
name|atoi
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|up
operator|->
name|stats
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"gps: stat %s\n"
argument_list|,
name|up
operator|->
name|stats
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|up
operator|->
name|lastptr
operator|=
name|up
operator|->
name|stats
expr_stmt|;
operator|*
name|up
operator|->
name|lastptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * We get down to business, check the timecode format and decode 	 * its contents. If the timecode has invalid length or is not in 	 * proper format, we declare bad format and exit. 	 */
if|if
condition|(
name|pp
operator|->
name|lencode
operator|<
name|LENTOC
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Timecode format: "yy:ddd:hh:mm:ss.mmm" 	 */
if|if
condition|(
name|sscanf
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
literal|"%2d:%3d:%2d:%2d:%2d.%3ld"
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|pp
operator|->
name|nsec
argument_list|)
operator|!=
literal|6
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|nsec
operator|*=
literal|1000000
expr_stmt|;
comment|/* 	 * Test for synchronization (this is a temporary crock). 	 */
if|if
condition|(
name|pp
operator|->
name|a_lastcode
index|[
literal|2
index|]
operator|!=
literal|':'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
comment|/* 	 * Process the new sample in the median filter and determine the 	 * timecode timestamp. 	 */
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If CLK_FLAG4 is set, initialize the statistics buffer and 	 * send the next command. If not, simply write the timecode to 	 * the clockstats file. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|up
operator|->
name|lastptr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|up
operator|->
name|lastptr
operator|+=
name|pp
operator|->
name|lencode
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG4
condition|)
block|{
operator|*
name|up
operator|->
name|lastptr
operator|++
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|up
operator|->
name|lastptr
argument_list|,
name|stat_command
index|[
name|up
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|up
operator|->
name|lastptr
operator|+=
name|strlen
argument_list|(
name|stat_command
index|[
name|up
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|up
operator|->
name|lastptr
operator|--
expr_stmt|;
operator|*
name|up
operator|->
name|lastptr
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|stat_command
index|[
name|up
operator|->
name|index
index|]
argument_list|,
name|strlen
argument_list|(
name|stat_command
index|[
name|up
operator|->
name|index
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|index
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|stat_command
index|[
name|up
operator|->
name|index
index|]
operator|==
literal|'\0'
condition|)
name|up
operator|->
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * as2201_poll - called by the transmit procedure  *  * We go to great pains to avoid changing state here, since there may be  * more than one eavesdropper receiving the same timecode.  */
end_comment

begin_function
specifier|static
name|void
name|as2201_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Send a "\r*toc\r" to get things going. We go to great pains 	 * to avoid changing state, since there may be more than one 	 * eavesdropper watching the radio. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"\r*toc\r"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|6
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
operator|)
condition|)
name|get_systime
argument_list|(
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|burst
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
name|pp
operator|->
name|codeproc
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|burst
operator|=
name|NSTAGE
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_as2201_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

