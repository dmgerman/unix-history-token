begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntp_config.c  *  * This file contains the ntpd configuration code.  *  * Written By:	Sachin Kamboj  *		University of Delaware  *		Newark, DE 19711  * Some parts borrowed from the older ntp_config.c  * Copyright (c) 2006  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_include
include|#
directive|include
file|<netinfo/ni.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_filegen.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntpd-opts.h"
end_include

begin_comment
comment|/*  * Sim header. Currently unconditionally included  * PDMXXX This needs to be a conditional include  */
end_comment

begin_include
include|#
directive|include
file|"ntpsim.h"
end_include

begin_include
include|#
directive|include
file|<ntp_random.h>
end_include

begin_include
include|#
directive|include
file|"ntp_intres.h"
end_include

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SIGCHLD
end_ifndef

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_decl_stmt
name|HANDLE
name|ResolverEventHandle
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|resolver_pipe_fd
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to let the resolver process alert the parent process */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * [Bug 467]: Some linux headers collide with CONFIG_PHONE and CONFIG_KEYS  * so #include these later.  */
end_comment

begin_include
include|#
directive|include
file|"ntp_config.h"
end_include

begin_include
include|#
directive|include
file|"ntp_cmdargs.h"
end_include

begin_include
include|#
directive|include
file|"ntp_scanner.h"
end_include

begin_include
include|#
directive|include
file|"ntp_parser.h"
end_include

begin_include
include|#
directive|include
file|"ntp_data_structures.h"
end_include

begin_comment
comment|/*  * "logconfig" building blocks  */
end_comment

begin_struct
struct|struct
name|masks
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|u_int32
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_class
index|[]
init|=
block|{
block|{
literal|"clock"
block|,
name|NLOG_OCLOCK
block|}
block|,
block|{
literal|"peer"
block|,
name|NLOG_OPEER
block|}
block|,
block|{
literal|"sync"
block|,
name|NLOG_OSYNC
block|}
block|,
block|{
literal|"sys"
block|,
name|NLOG_OSYS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logcfg_noclass_items[] masks are complete and must not be shifted */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_noclass_items
index|[]
init|=
block|{
block|{
literal|"allall"
block|,
name|NLOG_SYSMASK
operator||
name|NLOG_PEERMASK
operator||
name|NLOG_CLOCKMASK
operator||
name|NLOG_SYNCMASK
block|}
block|,
block|{
literal|"allinfo"
block|,
name|NLOG_SYSINFO
operator||
name|NLOG_PEERINFO
operator||
name|NLOG_CLOCKINFO
operator||
name|NLOG_SYNCINFO
block|}
block|,
block|{
literal|"allevents"
block|,
name|NLOG_SYSEVENT
operator||
name|NLOG_PEEREVENT
operator||
name|NLOG_CLOCKEVENT
operator||
name|NLOG_SYNCEVENT
block|}
block|,
block|{
literal|"allstatus"
block|,
name|NLOG_SYSSTATUS
operator||
name|NLOG_PEERSTATUS
operator||
name|NLOG_CLOCKSTATUS
operator||
name|NLOG_SYNCSTATUS
block|}
block|,
block|{
literal|"allstatistics"
block|,
name|NLOG_SYSSTATIST
operator||
name|NLOG_PEERSTATIST
operator||
name|NLOG_CLOCKSTATIST
operator||
name|NLOG_SYNCSTATIST
block|}
block|,
comment|/* the remainder are misspellings of clockall, peerall, sysall, and syncall. */
block|{
literal|"allclock"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OCLOCK
block|}
block|,
block|{
literal|"allpeer"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OPEER
block|}
block|,
block|{
literal|"allsys"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OSYS
block|}
block|,
block|{
literal|"allsync"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OSYNC
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logcfg_class_items[] masks are shiftable by NLOG_O* counts */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_class_items
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|NLOG_INFO
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator||
name|NLOG_STATIST
block|}
block|,
block|{
literal|"info"
block|,
name|NLOG_INFO
block|}
block|,
block|{
literal|"events"
block|,
name|NLOG_EVENT
block|}
block|,
block|{
literal|"status"
block|,
name|NLOG_STATUS
block|}
block|,
block|{
literal|"statistics"
block|,
name|NLOG_STATIST
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Limits */
end_comment

begin_define
define|#
directive|define
name|MAXPHONE
value|10
end_define

begin_comment
comment|/* maximum number of phone strings */
end_comment

begin_define
define|#
directive|define
name|MAXPPS
value|20
end_define

begin_comment
comment|/* maximum length of PPS device string */
end_comment

begin_comment
comment|/*  * Miscellaneous macros  */
end_comment

begin_define
define|#
directive|define
name|STRSAME
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(*(s1) == *(s2)&& strcmp((s1), (s2)) == 0)
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '#' || (c) == '\n' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * File descriptor used by the resolver save routines, and temporary file  * name.  */
end_comment

begin_decl_stmt
name|int
name|call_resolver
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ntp-genkeys sets this to 0, for example */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|res_file
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enough for /tmp/ntpXXXXXX\0 */
end_comment

begin_define
define|#
directive|define
name|RES_TEMPFILE
value|"/tmp/ntpXXXXXX"
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|res_file
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * Definitions of things either imported from or exported to outside  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ntp_parser.c (.y) */
end_comment

begin_decl_stmt
name|int
name|curr_include_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current include level */
end_comment

begin_decl_stmt
name|struct
name|FILE_INFO
modifier|*
name|fp
index|[
name|MAXINCLUDELEVEL
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|res_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|config_tree
name|cfgt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parser output stored here */
end_comment

begin_decl_stmt
name|struct
name|config_tree
modifier|*
name|cfg_tree_history
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* History of configs */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sys_phone
index|[
name|MAXPHONE
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ACTS phone numbers */
end_comment

begin_decl_stmt
name|char
name|default_keysdir
index|[]
init|=
name|NTP_KEYSDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|keysdir
init|=
name|default_keysdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crypto keys directory */
end_comment

begin_decl_stmt
name|char
modifier|*
name|saveconfigdir
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SCHED_SETSCHEDULER
argument_list|)
end_if

begin_decl_stmt
name|int
name|config_priority_override
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|config_priority
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|config_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|default_ntp_signd_socket
index|[]
init|=
ifdef|#
directive|ifdef
name|NTP_SIGND_PATH
name|NTP_SIGND_PATH
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|""
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|ntp_signd_socket
init|=
name|default_ntp_signd_socket
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_decl_stmt
name|struct
name|netinfo_config_state
modifier|*
name|config_netinfo
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|check_netinfo
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|alt_config_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LPTSTR
name|temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|config_file_storage
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|alt_config_file_storage
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_comment
comment|/*  * NetInfo configuration state  */
end_comment

begin_struct
struct|struct
name|netinfo_config_state
block|{
name|void
modifier|*
name|domain
decl_stmt|;
comment|/* domain with config */
name|ni_id
name|config_dir
decl_stmt|;
comment|/* ID config dir      */
name|int
name|prop_index
decl_stmt|;
comment|/* current property   */
name|int
name|val_index
decl_stmt|;
comment|/* current value      */
name|char
modifier|*
modifier|*
name|val_list
decl_stmt|;
comment|/* value list         */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|REMOTE_CONFIG_INFO
name|remote_config
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remote configuration buffer and 					     pointer info */
end_comment

begin_decl_stmt
name|int
name|input_from_file
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A boolean flag, which when set, indicates that 			        the input is to be taken from the configuration 			        file, instead of the remote-configuration buffer 			     */
end_comment

begin_decl_stmt
name|int
name|old_config_style
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A boolean flag, which when set, 			      * indicates that the old configuration 			      * format with a newline at the end of 			      * every command is being used 			      */
end_comment

begin_decl_stmt
name|int
name|cryptosw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crypto command called */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sys_maxclock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|stats_drift_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the driftfile */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|leapseconds_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*name of the leapseconds file */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IPTOS_SUPPORT
end_ifdef

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|qos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* QoS setting */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_IPTOS_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BC_LIST_FRAMEWORK_NOT_YET_USED
end_ifdef

begin_comment
comment|/*  * backwards compatibility flags  */
end_comment

begin_decl_stmt
name|bc_entry
name|bc_list
index|[]
init|=
block|{
block|{
name|T_Bc_bugXXXX
block|,
literal|1
block|}
comment|/* default enabled */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * declare an int pointer for each flag for quick testing without  * walking bc_list.  If the pointer is consumed by libntp rather  * than ntpd, declare it in a libntp source file pointing to storage  * initialized with the appropriate value for other libntp clients, and  * redirect it to point into bc_list during ntpd startup.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|p_bcXXXX_enabled
init|=
operator|&
name|bc_list
index|[
literal|0
index|]
operator|.
name|enabled
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FUNCTION PROTOTYPES */
end_comment

begin_function_decl
specifier|static
name|void
name|apply_enable_disable
parameter_list|(
name|queue
modifier|*
name|q
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_syntax_tree
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_auth_node
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_other_modes
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_auth
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_tos
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_monitor
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_access
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_tinker
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_system_opts
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_logconfig
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_phone
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_qos
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_setvar
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_ttl
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_trap
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_fudge
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_vars
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_peers
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_unpeers
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_nic_rules
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_config_sim
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|free_all_config_trees
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* atexit() */
end_comment

begin_function_decl
specifier|static
name|void
name|free_config_tree
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function_decl
name|double
modifier|*
name|create_dval
parameter_list|(
name|double
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|destroy_restrict_node
parameter_list|(
name|struct
name|restrict_node
modifier|*
name|my_node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_sane_resolved_address
parameter_list|(
name|sockaddr_u
modifier|*
name|peeraddr
parameter_list|,
name|int
name|hmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_correct_host_mode
parameter_list|(
name|int
name|hmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_and_apply_config_tree
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|getconfig
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIM
argument_list|)
end_if

begin_function_decl
specifier|static
name|sockaddr_u
modifier|*
name|get_next_address
parameter_list|(
name|struct
name|address_node
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|config_other_modes
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_auth
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_tos
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_monitor
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_access
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_tinker
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_system_opts
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_logconfig
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_phone
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_qos
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_setvar
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_ttl
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_trap
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_fudge
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_vars
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_peers
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_unpeers
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_nic_rules
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function_decl
specifier|static
name|void
name|config_sim
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_ntpdsim
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|config_ntpd
parameter_list|(
name|struct
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|gnn_type
block|{
name|t_UNK
block|,
comment|/* Unknown */
name|t_REF
block|,
comment|/* Refclock */
name|t_MSK
comment|/* Network Mask */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|DESTROY_QUEUE
parameter_list|(
name|q
parameter_list|)
define|\
value|do {					\ 	if (q) {			\ 		destroy_queue(q);	\ 		(q) = NULL;		\ 	}				\ } while (0)
end_define

begin_function_decl
name|void
name|ntpd_set_tod_using
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|get_pfxmatch
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|masks
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|get_match
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|masks
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|get_logmask
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|num
parameter_list|,
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|int
name|complain
parameter_list|,
name|enum
name|gnn_type
name|a_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_multiple_netnums
parameter_list|(
specifier|const
name|char
modifier|*
name|num
parameter_list|,
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|,
name|int
name|complain
parameter_list|,
name|enum
name|gnn_type
name|a_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_resolve
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|no_needed
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|minpoll
parameter_list|,
name|int
name|maxpoll
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int
name|ttl
parameter_list|,
name|keyid_t
name|keyid
parameter_list|,
name|u_char
modifier|*
name|keystr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|abort_resolve
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_resolve_internal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FUNCTIONS FOR INITIALIZATION  * ----------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_auth_node
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keys
condition|)
block|{
name|free
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|keys
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|keys
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keysdir
condition|)
block|{
name|free
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|keysdir
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|keysdir
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
condition|)
block|{
name|free
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function
specifier|static
name|void
name|init_syntax_tree
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|memset
argument_list|(
name|ptree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ptree
argument_list|)
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|peers
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|unpeers
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|orphan_cmds
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|manycastserver
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|multicastclient
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|stats_list
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|filegen_opts
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|discard_opts
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|restrict_opts
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|enable_opts
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|disable_opts
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|tinker
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|fudge
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|logconfig
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|phone
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|qos
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|setvar
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|ttl
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|trap
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|vars
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|nic_rules
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|crypto_cmd_list
operator|=
name|create_queue
argument_list|()
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|trusted_key_list
operator|=
name|create_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
name|void
name|free_all_config_trees
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|config_tree
modifier|*
name|ptree
decl_stmt|;
name|struct
name|config_tree
modifier|*
name|pnext
decl_stmt|;
name|ptree
operator|=
name|cfg_tree_history
expr_stmt|;
while|while
condition|(
name|ptree
operator|!=
name|NULL
condition|)
block|{
name|pnext
operator|=
name|ptree
operator|->
name|link
expr_stmt|;
name|free_config_tree
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|ptree
operator|=
name|pnext
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_config_tree
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|_CrtCheckMemory
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptree
operator|->
name|source
operator|.
name|value
operator|.
name|s
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ptree
operator|->
name|source
operator|.
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|free_config_other_modes
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_auth
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_tos
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_monitor
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_access
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_tinker
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_system_opts
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_logconfig
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_phone
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_qos
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_setvar
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_ttl
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_trap
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_fudge
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_vars
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_peers
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_unpeers
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_nic_rules
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIM
name|free_config_sim
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Most of these DESTROY_QUEUE()s are handled already by the 	 * free_config_*() routines above but it's safe to use twice. 	 * Please feel free to remove ones you verified are handled 	 * in a free_config_*() routine. 	 */
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|peers
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|unpeers
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|orphan_cmds
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|manycastserver
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|multicastclient
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|stats_list
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|filegen_opts
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|discard_opts
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|restrict_opts
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|enable_opts
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|disable_opts
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|tinker
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|fudge
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|logconfig
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|phone
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|qos
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|setvar
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|trap
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|vars
argument_list|)
expr_stmt|;
name|free_auth_node
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|_CrtCheckMemory
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SAVECONFIG
end_ifdef

begin_comment
comment|/* Dump all trees */
end_comment

begin_function
name|int
name|dump_all_config_trees
parameter_list|(
name|FILE
modifier|*
name|df
parameter_list|,
name|int
name|comment
parameter_list|)
block|{
name|struct
name|config_tree
modifier|*
name|cfg_ptr
init|=
name|cfg_tree_history
decl_stmt|;
name|int
name|return_value
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cfg_ptr
operator|=
name|cfg_tree_history
init|;
name|cfg_ptr
operator|!=
name|NULL
condition|;
name|cfg_ptr
operator|=
name|cfg_ptr
operator|->
name|link
control|)
name|return_value
operator||=
name|dump_config_tree
argument_list|(
name|cfg_ptr
argument_list|,
name|df
argument_list|,
name|comment
argument_list|)
expr_stmt|;
return|return
name|return_value
return|;
block|}
end_function

begin_comment
comment|/* The config dumper */
end_comment

begin_function
name|int
name|dump_config_tree
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|,
name|FILE
modifier|*
name|df
parameter_list|,
name|int
name|comment
parameter_list|)
block|{
name|struct
name|peer_node
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|struct
name|unpeer_node
modifier|*
name|unpeers
init|=
name|NULL
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|atrv
init|=
name|NULL
decl_stmt|;
name|struct
name|address_node
modifier|*
name|addr
init|=
name|NULL
decl_stmt|;
name|struct
name|address_node
modifier|*
name|peer_addr
decl_stmt|;
name|struct
name|address_node
modifier|*
name|fudge_addr
decl_stmt|;
name|struct
name|filegen_node
modifier|*
name|fgen_node
init|=
name|NULL
decl_stmt|;
name|struct
name|restrict_node
modifier|*
name|rest_node
init|=
name|NULL
decl_stmt|;
name|struct
name|addr_opts_node
modifier|*
name|addr_opts
init|=
name|NULL
decl_stmt|;
name|struct
name|setvar_node
modifier|*
name|setv_node
init|=
name|NULL
decl_stmt|;
name|nic_rule_node
modifier|*
name|rule_node
decl_stmt|;
name|char
modifier|*
modifier|*
name|pstr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
name|int
modifier|*
name|intp
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|fudge_ptr
decl_stmt|;
name|void
modifier|*
name|list_ptr
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|opt_ptr
init|=
name|NULL
decl_stmt|;
name|int
modifier|*
name|flags
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|opts
init|=
name|NULL
decl_stmt|;
name|char
name|timestamp
index|[
literal|80
index|]
decl_stmt|;
name|int
name|enable
decl_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"dump_config_tree(%p)\n"
operator|,
name|ptree
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comment
condition|)
block|{
if|if
condition|(
operator|!
name|strftime
argument_list|(
name|timestamp
argument_list|,
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|,
literal|"%Y-%m-%d %H:%M:%S"
argument_list|,
name|localtime
argument_list|(
operator|&
name|ptree
operator|->
name|timestamp
argument_list|)
argument_list|)
condition|)
name|timestamp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"# %s %s %s\n"
argument_list|,
name|timestamp
argument_list|,
operator|(
name|CONF_SOURCE_NTPQ
operator|==
name|ptree
operator|->
name|source
operator|.
name|attr
operator|)
condition|?
literal|"ntpq remote config from"
else|:
literal|"startup configuration file"
argument_list|,
name|ptree
operator|->
name|source
operator|.
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* For options I didn't find documentation I'll just output its name and the cor. value */
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|vars
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|atrv
operator|=
operator|(
expr|struct
name|attr_val
operator|*
operator|)
name|list_ptr
expr_stmt|;
switch|switch
condition|(
name|atrv
operator|->
name|attr
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown vars token %s\n"
argument_list|,
name|token_name
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* doubles */
case|case
name|T_Broadcastdelay
case|:
case|case
name|T_Tick
case|:
case|case
name|T_WanderThreshold
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s %g\n"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* ints */
case|case
name|T_Calldelay
case|:
ifdef|#
directive|ifdef
name|OPENSSL
case|case
name|T_Automax
case|:
endif|#
directive|endif
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s %d\n"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
comment|/* strings */
case|case
name|T_Driftfile
case|:
case|case
name|T_Leapfile
case|:
case|case
name|T_Logfile
case|:
case|case
name|T_Pidfile
case|:
case|case
name|T_Saveconfigdir
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s \"%s\"\n"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|logconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"logconfig"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|atrv
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %c%s"
argument_list|,
name|atrv
operator|->
name|attr
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|stats_dir
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"statsdir \"%s\"\n"
argument_list|,
name|ptree
operator|->
name|stats_dir
argument_list|)
expr_stmt|;
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|stats_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"statistics"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|intp
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
operator|*
name|intp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|filegen_opts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|fgen_node
operator|=
name|list_ptr
expr_stmt|;
name|opt_ptr
operator|=
name|queue_head
argument_list|(
name|fgen_node
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_ptr
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"filegen %s"
argument_list|,
name|keyword
argument_list|(
name|fgen_node
operator|->
name|filegen_token
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|opt_ptr
operator|!=
name|NULL
condition|;
name|opt_ptr
operator|=
name|next_node
argument_list|(
name|opt_ptr
argument_list|)
control|)
block|{
name|atrv
operator|=
name|opt_ptr
expr_stmt|;
switch|switch
condition|(
name|atrv
operator|->
name|attr
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown filegen option token %s\n"
literal|"filegen %s"
argument_list|,
name|token_name
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|keyword
argument_list|(
name|fgen_node
operator|->
name|filegen_token
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_File
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" file %s"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Type
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" type %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Flag
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|crypto_cmd_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"crypto"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|atrv
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|revoke
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"revoke %d\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|revoke
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|ptree
operator|->
name|auth
operator|.
name|keysdir
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"keysdir \"%s\"\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|keysdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|ptree
operator|->
name|auth
operator|.
name|keys
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"keys \"%s\"\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|keys
argument_list|)
expr_stmt|;
name|atrv
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|trusted_key_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"trustedkey"
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
literal|'i'
operator|==
name|atrv
operator|->
name|attr
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %d"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|'-'
operator|==
name|atrv
operator|->
name|attr
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" (%u ... %u)"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|u
operator|>>
literal|16
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|u
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown trustedkey attr %d\n"
literal|"trustedkey"
argument_list|,
name|atrv
operator|->
name|attr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|NULL
operator|!=
operator|(
name|atrv
operator|=
name|next_node
argument_list|(
name|atrv
argument_list|)
operator|)
condition|)
do|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|control_key
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"controlkey %d\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|control_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|request_key
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"requestkey %d\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|request_key
argument_list|)
expr_stmt|;
comment|/* dump enable list, then disable list */
for|for
control|(
name|enable
operator|=
literal|1
init|;
name|enable
operator|>=
literal|0
condition|;
name|enable
operator|--
control|)
block|{
name|list_ptr
operator|=
operator|(
name|enable
operator|)
condition|?
name|queue_head
argument_list|(
name|ptree
operator|->
name|enable_opts
argument_list|)
else|:
name|queue_head
argument_list|(
name|ptree
operator|->
name|disable_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
operator|(
name|enable
operator|)
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|atrv
operator|=
operator|(
expr|struct
name|attr_val
operator|*
operator|)
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|orphan_cmds
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"tos"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|atrv
operator|=
name|list_ptr
expr_stmt|;
switch|switch
condition|(
name|atrv
operator|->
name|attr
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown tos token %s\n"
literal|"tos"
argument_list|,
name|token_name
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* ints */
case|case
name|T_Ceiling
case|:
case|case
name|T_Floor
case|:
case|case
name|T_Cohort
case|:
case|case
name|T_Orphan
case|:
case|case
name|T_Minclock
case|:
case|case
name|T_Maxclock
case|:
case|case
name|T_Minsane
case|:
case|case
name|T_Beacon
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %d"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* doubles */
case|case
name|T_Mindist
case|:
case|case
name|T_Maxdist
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %g"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|queue_head
argument_list|(
name|ptree
operator|->
name|orphan_cmds
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|tinker
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"tinker"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|atrv
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %g"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|broadcastclient
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"broadcastclient\n"
argument_list|)
expr_stmt|;
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|peers
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|peer
operator|=
name|list_ptr
expr_stmt|;
name|addr
operator|=
name|peer
operator|->
name|addr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s"
argument_list|,
name|keyword
argument_list|(
name|peer
operator|->
name|host_mode
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|type
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"# dump error:\n"
literal|"# unknown peer family %d for:\n"
literal|"peer"
argument_list|,
name|addr
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_UNSPEC
case|:
break|break;
case|case
name|AF_INET
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" -4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" -6"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|minpoll
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" minpoll %d"
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|maxpoll
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" maxpoll %d"
argument_list|,
name|peer
operator|->
name|maxpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|ttl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|addr
operator|->
name|address
argument_list|)
operator|>
literal|8
operator|&&
operator|!
name|memcmp
argument_list|(
name|addr
operator|->
name|address
argument_list|,
literal|"127.127."
argument_list|,
literal|8
argument_list|)
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" mode %d"
argument_list|,
name|peer
operator|->
name|ttl
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" ttl %d"
argument_list|,
name|peer
operator|->
name|ttl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|peerversion
operator|!=
name|NTP_VERSION
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" version %d"
argument_list|,
name|peer
operator|->
name|peerversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|peerkey
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" key %d"
argument_list|,
name|peer
operator|->
name|peerkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|bias
operator|!=
literal|0.
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" bias %g"
argument_list|,
name|peer
operator|->
name|bias
argument_list|)
expr_stmt|;
for|for
control|(
name|atrv
operator|=
name|queue_head
argument_list|(
name|peer
operator|->
name|peerflags
argument_list|)
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|next_node
argument_list|(
name|atrv
argument_list|)
control|)
block|{
name|NTP_INSIST
argument_list|(
name|T_Flag
operator|==
name|atrv
operator|->
name|attr
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|T_Integer
operator|==
name|atrv
operator|->
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fudge_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|fudge
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fudge_ptr
operator|!=
name|NULL
condition|;
name|fudge_ptr
operator|=
name|next_node
argument_list|(
name|fudge_ptr
argument_list|)
control|)
block|{
name|addr_opts
operator|=
operator|(
expr|struct
name|addr_opts_node
operator|*
operator|)
name|fudge_ptr
expr_stmt|;
name|peer_addr
operator|=
name|peer
operator|->
name|addr
expr_stmt|;
name|fudge_addr
operator|=
name|addr_opts
operator|->
name|addr
expr_stmt|;
name|s1
operator|=
name|peer_addr
operator|->
name|address
expr_stmt|;
name|s2
operator|=
name|fudge_addr
operator|->
name|address
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"fudge %s"
argument_list|,
name|addr_opts
operator|->
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|opts
operator|=
name|queue_head
argument_list|(
name|addr_opts
operator|->
name|options
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|opts
operator|!=
name|NULL
condition|;
name|opts
operator|=
name|next_node
argument_list|(
name|opts
argument_list|)
control|)
block|{
name|atrv
operator|=
operator|(
expr|struct
name|attr_val
operator|*
operator|)
name|opts
expr_stmt|;
switch|switch
condition|(
name|atrv
operator|->
name|attr
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown fudge option %s\n"
literal|"fudge %s"
argument_list|,
name|token_name
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|addr_opts
operator|->
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
comment|/* doubles */
case|case
name|T_Time1
case|:
case|case
name|T_Time2
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %g"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* ints */
case|case
name|T_Stratum
case|:
case|case
name|T_Flag1
case|:
case|case
name|T_Flag2
case|:
case|case
name|T_Flag3
case|:
case|case
name|T_Flag4
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %d"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
comment|/* strings */
case|case
name|T_Refid
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|manycastserver
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|addr
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"manycastserver %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|next_node
argument_list|(
name|addr
argument_list|)
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|next_node
argument_list|(
name|addr
argument_list|)
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|multicastclient
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|addr
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"multicastclient %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|next_node
argument_list|(
name|addr
argument_list|)
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|next_node
argument_list|(
name|addr
argument_list|)
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|unpeers
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|unpeers
operator|=
operator|(
expr|struct
name|unpeer_node
operator|*
operator|)
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"unpeer %s\n"
argument_list|,
operator|(
name|unpeers
operator|->
name|addr
operator|)
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|discard_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"discard"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|atrv
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %d"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|restrict_opts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|rest_node
operator|=
name|list_ptr
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|rest_node
operator|->
name|addr
condition|)
name|s1
operator|=
literal|"default"
expr_stmt|;
else|else
name|s1
operator|=
name|rest_node
operator|->
name|addr
operator|->
name|address
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"restrict %s"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest_node
operator|->
name|mask
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" mask %s"
argument_list|,
name|rest_node
operator|->
name|mask
operator|->
name|address
argument_list|)
expr_stmt|;
name|flags
operator|=
name|queue_head
argument_list|(
name|rest_node
operator|->
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|flags
operator|!=
name|NULL
condition|;
name|flags
operator|=
name|next_node
argument_list|(
name|flags
argument_list|)
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
operator|*
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|nic_rules
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|rule_node
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"interface %s %s\n"
argument_list|,
name|keyword
argument_list|(
name|rule_node
operator|->
name|action
argument_list|)
argument_list|,
operator|(
name|rule_node
operator|->
name|match_class
operator|)
condition|?
name|keyword
argument_list|(
name|rule_node
operator|->
name|match_class
argument_list|)
else|:
name|rule_node
operator|->
name|if_name
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|phone
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"phone"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|pstr
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|pstr
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|qos
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"qos"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|atrv
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|setvar
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|setv_node
operator|=
name|list_ptr
expr_stmt|;
name|s1
operator|=
name|quote_if_needed
argument_list|(
name|setv_node
operator|->
name|var
argument_list|)
expr_stmt|;
name|s2
operator|=
name|quote_if_needed
argument_list|(
name|setv_node
operator|->
name|val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"setvar %s = %s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|setv_node
operator|->
name|isdefault
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" default"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_ptr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"ttl"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|intp
operator|=
name|list_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %d"
argument_list|,
operator|*
name|intp
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_ptr
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|trap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list_ptr
operator|!=
name|NULL
condition|;
name|list_ptr
operator|=
name|next_node
argument_list|(
name|list_ptr
argument_list|)
control|)
block|{
name|addr_opts
operator|=
name|list_ptr
expr_stmt|;
name|addr
operator|=
name|addr_opts
operator|->
name|addr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"trap %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|options
operator|=
name|queue_head
argument_list|(
name|addr_opts
operator|->
name|options
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|options
operator|!=
name|NULL
condition|;
name|options
operator|=
name|next_node
argument_list|(
name|options
argument_list|)
control|)
block|{
name|atrv
operator|=
name|options
expr_stmt|;
switch|switch
condition|(
name|atrv
operator|->
name|attr
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown trap token %d\n"
literal|"trap %s"
argument_list|,
name|atrv
operator|->
name|attr
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Port
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" port %d"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Interface
case|:
name|addr
operator|=
operator|(
expr|struct
name|address_node
operator|*
operator|)
name|atrv
operator|->
name|value
operator|.
name|p
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" interface %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SAVECONFIG */
end_comment

begin_comment
comment|/* FUNCTIONS FOR CREATING NODES ON THE SYNTAX TREE  * -----------------------------------------------  */
end_comment

begin_function
name|queue
modifier|*
name|enqueue_in_new_queue
parameter_list|(
name|void
modifier|*
name|my_node
parameter_list|)
block|{
name|queue
modifier|*
name|my_queue
init|=
name|create_queue
argument_list|()
decl_stmt|;
name|enqueue
argument_list|(
name|my_queue
argument_list|,
name|my_node
argument_list|)
expr_stmt|;
return|return
name|my_queue
return|;
block|}
end_function

begin_function
name|struct
name|attr_val
modifier|*
name|create_attr_dval
parameter_list|(
name|int
name|attr
parameter_list|,
name|double
name|value
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_val
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|d
operator|=
name|value
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_Double
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|struct
name|attr_val
modifier|*
name|create_attr_ival
parameter_list|(
name|int
name|attr
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_val
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|i
operator|=
name|value
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_Integer
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|struct
name|attr_val
modifier|*
name|create_attr_shorts
parameter_list|(
name|int
name|attr
parameter_list|,
name|ntp_u_int16_t
name|val1
parameter_list|,
name|ntp_u_int16_t
name|val2
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_val
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|u
operator|=
operator|(
name|val1
operator|<<
literal|16
operator|)
operator||
name|val2
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_Integer
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|struct
name|attr_val
modifier|*
name|create_attr_sval
parameter_list|(
name|int
name|attr
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_val
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s
condition|)
comment|/* free() hates NULL */
name|s
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_String
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|struct
name|attr_val
modifier|*
name|create_attr_pval
parameter_list|(
name|int
name|attr
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_val
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_Void
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|int
modifier|*
name|create_ival
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|int
modifier|*
name|p
init|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
name|val
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|double
modifier|*
name|create_dval
parameter_list|(
name|double
name|val
parameter_list|)
block|{
name|double
modifier|*
name|p
init|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
name|val
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
modifier|*
modifier|*
name|create_pval
parameter_list|(
name|void
modifier|*
name|val
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|p
init|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
name|val
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|struct
name|address_node
modifier|*
name|create_address_node
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|address_node
modifier|*
name|my_node
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|addr
argument_list|)
expr_stmt|;
name|my_node
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_node
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|address
operator|=
name|addr
expr_stmt|;
name|my_node
operator|->
name|type
operator|=
name|type
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|void
name|destroy_address_node
parameter_list|(
name|struct
name|address_node
modifier|*
name|my_node
parameter_list|)
block|{
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|my_node
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|my_node
operator|->
name|address
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|my_node
operator|->
name|address
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|peer_node
modifier|*
name|create_peer_node
parameter_list|(
name|int
name|hmode
parameter_list|,
name|struct
name|address_node
modifier|*
name|addr
parameter_list|,
name|queue
modifier|*
name|options
parameter_list|)
block|{
name|struct
name|peer_node
modifier|*
name|my_node
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|option
decl_stmt|;
name|int
name|freenode
decl_stmt|;
name|int
name|errflag
init|=
literal|0
decl_stmt|;
name|my_node
operator|=
name|get_node
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize node values to default */
name|my_node
operator|->
name|minpoll
operator|=
literal|0
expr_stmt|;
name|my_node
operator|->
name|maxpoll
operator|=
literal|0
expr_stmt|;
name|my_node
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|my_node
operator|->
name|peerversion
operator|=
name|NTP_VERSION
expr_stmt|;
name|my_node
operator|->
name|peerkey
operator|=
literal|0
expr_stmt|;
name|my_node
operator|->
name|bias
operator|=
literal|0
expr_stmt|;
name|my_node
operator|->
name|peerflags
operator|=
name|create_queue
argument_list|()
expr_stmt|;
comment|/* Now set the node to the read values */
name|my_node
operator|->
name|host_mode
operator|=
name|hmode
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
comment|/* 	 * the options list mixes items that will be saved in the 	 * peer_node as explicit members, such as minpoll, and 	 * those that are moved from the options queue intact 	 * to the peer_node's peerflags queue.  The options 	 * queue is consumed and destroyed here. 	 */
while|while
condition|(
name|options
operator|&&
name|NULL
operator|!=
operator|(
name|option
operator|=
name|dequeue
argument_list|(
name|options
argument_list|)
operator|)
condition|)
block|{
name|freenode
operator|=
literal|1
expr_stmt|;
comment|/* Check the kind of option being set */
switch|switch
condition|(
name|option
operator|->
name|attr
condition|)
block|{
case|case
name|T_Flag
case|:
name|enqueue
argument_list|(
name|my_node
operator|->
name|peerflags
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|freenode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_Minpoll
case|:
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|i
operator|<
name|NTP_MINPOLL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"minpoll: provided value (%d) is below minimum (%d)"
argument_list|,
name|option
operator|->
name|value
operator|.
name|i
argument_list|,
name|NTP_MINPOLL
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|minpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
block|}
else|else
name|my_node
operator|->
name|minpoll
operator|=
name|option
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Maxpoll
case|:
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|i
operator|>
name|NTP_MAXPOLL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"maxpoll: provided value (%d) is above maximum (%d)"
argument_list|,
name|option
operator|->
name|value
operator|.
name|i
argument_list|,
name|NTP_MAXPOLL
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|maxpoll
operator|=
name|NTP_MAXPOLL
expr_stmt|;
block|}
else|else
name|my_node
operator|->
name|maxpoll
operator|=
name|option
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Ttl
case|:
if|if
condition|(
name|my_node
operator|->
name|ttl
operator|>=
name|MAX_TTL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ttl: invalid argument"
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|my_node
operator|->
name|ttl
operator|=
name|option
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Mode
case|:
name|my_node
operator|->
name|ttl
operator|=
name|option
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Key
case|:
name|my_node
operator|->
name|peerkey
operator|=
name|option
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Version
case|:
name|my_node
operator|->
name|peerversion
operator|=
name|option
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Bias
case|:
name|my_node
operator|->
name|bias
operator|=
name|option
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown peer/server option token %s"
argument_list|,
name|token_name
argument_list|(
name|option
operator|->
name|attr
argument_list|)
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|freenode
condition|)
name|free_node
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
name|DESTROY_QUEUE
argument_list|(
name|options
argument_list|)
expr_stmt|;
comment|/* Check if errors were reported. If yes, ignore the node */
if|if
condition|(
name|errflag
condition|)
block|{
name|free_node
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
name|my_node
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|struct
name|unpeer_node
modifier|*
name|create_unpeer_node
parameter_list|(
name|struct
name|address_node
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|unpeer_node
modifier|*
name|my_node
decl_stmt|;
name|char
modifier|*
name|pch
decl_stmt|;
name|my_node
operator|=
name|get_node
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * From the parser's perspective an association ID fits into 	 * its generic T_String definition of a name/address "address". 	 * We treat all valid 16-bit numbers as association IDs. 	 */
name|pch
operator|=
name|addr
operator|->
name|address
expr_stmt|;
while|while
condition|(
operator|*
name|pch
operator|&&
name|isdigit
argument_list|(
operator|*
name|pch
argument_list|)
condition|)
name|pch
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pch
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|addr
operator|->
name|address
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|my_node
operator|->
name|assocID
argument_list|)
operator|&&
name|my_node
operator|->
name|assocID
operator|<=
name|USHRT_MAX
condition|)
block|{
name|destroy_address_node
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|my_node
operator|->
name|assocID
operator|=
literal|0
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
block|}
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|struct
name|filegen_node
modifier|*
name|create_filegen_node
parameter_list|(
name|int
name|filegen_token
parameter_list|,
name|queue
modifier|*
name|options
parameter_list|)
block|{
name|struct
name|filegen_node
modifier|*
name|my_node
decl_stmt|;
name|my_node
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_node
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|filegen_token
operator|=
name|filegen_token
expr_stmt|;
name|my_node
operator|->
name|options
operator|=
name|options
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|struct
name|restrict_node
modifier|*
name|create_restrict_node
parameter_list|(
name|struct
name|address_node
modifier|*
name|addr
parameter_list|,
name|struct
name|address_node
modifier|*
name|mask
parameter_list|,
name|queue
modifier|*
name|flags
parameter_list|,
name|int
name|line_no
parameter_list|)
block|{
name|struct
name|restrict_node
modifier|*
name|my_node
decl_stmt|;
name|my_node
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_node
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|my_node
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|my_node
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|my_node
operator|->
name|line_no
operator|=
name|line_no
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|void
name|destroy_restrict_node
parameter_list|(
name|struct
name|restrict_node
modifier|*
name|my_node
parameter_list|)
block|{
comment|/* With great care, free all the memory occupied by 	 * the restrict node 	 */
if|if
condition|(
name|my_node
operator|->
name|addr
condition|)
name|destroy_address_node
argument_list|(
name|my_node
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_node
operator|->
name|mask
condition|)
name|destroy_address_node
argument_list|(
name|my_node
operator|->
name|mask
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|my_node
operator|->
name|flags
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|setvar_node
modifier|*
name|create_setvar_node
parameter_list|(
name|char
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|int
name|isdefault
parameter_list|)
block|{
name|char
modifier|*
name|pch
decl_stmt|;
name|struct
name|setvar_node
modifier|*
name|my_node
decl_stmt|;
comment|/* do not allow = in the variable name */
if|if
condition|(
name|NULL
operator|!=
operator|(
name|pch
operator|=
name|strchr
argument_list|(
name|var
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
operator|*
name|pch
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now store the string into a setvar_node */
name|my_node
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_node
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|var
operator|=
name|var
expr_stmt|;
name|my_node
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|my_node
operator|->
name|isdefault
operator|=
name|isdefault
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|nic_rule_node
modifier|*
name|create_nic_rule_node
parameter_list|(
name|int
name|match_class
parameter_list|,
name|char
modifier|*
name|if_name
parameter_list|,
comment|/* interface name or numeric address */
name|int
name|action
parameter_list|)
block|{
name|nic_rule_node
modifier|*
name|my_node
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|match_class
operator|!=
literal|0
operator|||
name|if_name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|my_node
operator|=
name|get_node
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|match_class
operator|=
name|match_class
expr_stmt|;
name|my_node
operator|->
name|if_name
operator|=
name|if_name
expr_stmt|;
name|my_node
operator|->
name|action
operator|=
name|action
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|struct
name|addr_opts_node
modifier|*
name|create_addr_opts_node
parameter_list|(
name|struct
name|address_node
modifier|*
name|addr
parameter_list|,
name|queue
modifier|*
name|options
parameter_list|)
block|{
name|struct
name|addr_opts_node
modifier|*
name|my_node
decl_stmt|;
name|my_node
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_node
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|my_node
operator|->
name|options
operator|=
name|options
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|script_info
modifier|*
name|create_sim_script_info
parameter_list|(
name|double
name|duration
parameter_list|,
name|queue
modifier|*
name|script_queue
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SIM
return|return
name|NULL
return|;
else|#
directive|else
name|script_info
modifier|*
name|my_info
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|my_attr_val
decl_stmt|;
name|my_info
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_info
argument_list|)
expr_stmt|;
comment|/* Initialize Script Info with default values*/
name|my_info
operator|->
name|duration
operator|=
name|duration
expr_stmt|;
name|my_info
operator|->
name|freq_offset
operator|=
literal|0
expr_stmt|;
name|my_info
operator|->
name|wander
operator|=
literal|0
expr_stmt|;
name|my_info
operator|->
name|jitter
operator|=
literal|0
expr_stmt|;
name|my_info
operator|->
name|prop_delay
operator|=
name|NET_DLY
expr_stmt|;
name|my_info
operator|->
name|proc_delay
operator|=
name|PROC_DLY
expr_stmt|;
comment|/* Traverse the script_queue and fill out non-default values */
name|my_attr_val
operator|=
name|queue_head
argument_list|(
name|script_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|my_attr_val
operator|!=
name|NULL
condition|)
block|{
comment|/* Set the desired value */
switch|switch
condition|(
name|my_attr_val
operator|->
name|attr
condition|)
block|{
case|case
name|T_Freq_Offset
case|:
name|my_info
operator|->
name|freq_offset
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Wander
case|:
name|my_info
operator|->
name|wander
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Jitter
case|:
name|my_info
operator|->
name|jitter
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Prop_Delay
case|:
name|my_info
operator|->
name|prop_delay
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Proc_Delay
case|:
name|my_info
operator|->
name|proc_delay
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown script token %d"
argument_list|,
name|my_attr_val
operator|->
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|my_info
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIM
argument_list|)
end_if

begin_define
define|#
directive|define
name|ADDR_LENGTH
value|16 + 1
end_define

begin_function
specifier|static
name|sockaddr_u
modifier|*
name|get_next_address
parameter_list|(
name|struct
name|address_node
modifier|*
name|addr
parameter_list|)
block|{
specifier|const
name|char
name|addr_prefix
index|[]
init|=
literal|"192.168.0."
decl_stmt|;
specifier|static
name|int
name|curr_addr_no
init|=
literal|1
decl_stmt|;
name|char
name|addr_string
index|[
name|ADDR_LENGTH
index|]
decl_stmt|;
name|sockaddr_u
modifier|*
name|final_addr
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ptr
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|final_addr
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|final_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|type
operator|==
name|T_String
condition|)
block|{
name|snprintf
argument_list|(
name|addr_string
argument_list|,
name|ADDR_LENGTH
argument_list|,
literal|"%s%d"
argument_list|,
name|addr_prefix
argument_list|,
name|curr_addr_no
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Selecting ip address %s for hostname %s\n"
argument_list|,
name|addr_string
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|retval
operator|=
name|getaddrinfo
argument_list|(
name|addr_string
argument_list|,
literal|"ntp"
argument_list|,
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|getaddrinfo
argument_list|(
name|addr
operator|->
name|address
argument_list|,
literal|"ntp"
argument_list|,
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|memcpy
argument_list|(
name|final_addr
argument_list|,
name|ptr
operator|->
name|ai_addr
argument_list|,
name|ptr
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Successful in setting ip address of simulated server to: %s\n"
argument_list|,
name|stoa
argument_list|(
name|final_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR!! Could not get a new address\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|final_addr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_function
name|server_info
modifier|*
name|create_sim_server
parameter_list|(
name|struct
name|address_node
modifier|*
name|addr
parameter_list|,
name|double
name|server_offset
parameter_list|,
name|queue
modifier|*
name|script
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SIM
return|return
name|NULL
return|;
else|#
directive|else
name|server_info
modifier|*
name|my_info
decl_stmt|;
name|my_info
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_info
argument_list|)
expr_stmt|;
name|my_info
operator|->
name|server_time
operator|=
name|server_offset
expr_stmt|;
name|my_info
operator|->
name|addr
operator|=
name|get_next_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|my_info
operator|->
name|script
operator|=
name|script
expr_stmt|;
name|my_info
operator|->
name|curr_script
operator|=
name|dequeue
argument_list|(
name|my_info
operator|->
name|script
argument_list|)
expr_stmt|;
return|return
name|my_info
return|;
endif|#
directive|endif
comment|/* SIM */
block|}
end_function

begin_function
name|struct
name|sim_node
modifier|*
name|create_sim_node
parameter_list|(
name|queue
modifier|*
name|init_opts
parameter_list|,
name|queue
modifier|*
name|servers
parameter_list|)
block|{
name|struct
name|sim_node
modifier|*
name|my_node
decl_stmt|;
name|my_node
operator|=
name|get_node
argument_list|(
sizeof|sizeof
expr|*
name|my_node
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|init_opts
operator|=
name|init_opts
expr_stmt|;
name|my_node
operator|->
name|servers
operator|=
name|servers
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_comment
comment|/* FUNCTIONS FOR PERFORMING THE CONFIGURATION  * ------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|config_other_modes
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|sockaddr_u
name|addr_sock
decl_stmt|;
name|struct
name|address_node
modifier|*
name|addr_node
decl_stmt|;
if|if
condition|(
name|ptree
operator|->
name|broadcastclient
condition|)
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
name|ptree
operator|->
name|broadcastclient
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Configure the many-cast servers */
name|addr_node
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|manycastserver
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_node
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
operator|(
name|u_short
operator|)
name|addr_node
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|addr_node
operator|->
name|address
argument_list|,
operator|&
name|addr_sock
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|==
literal|1
condition|)
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|,
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
name|addr_node
operator|=
name|next_node
argument_list|(
name|addr_node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|addr_node
operator|!=
name|NULL
condition|)
do|;
name|sys_manycastserver
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Configure the multicast clients */
name|addr_node
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|multicastclient
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_node
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
operator|(
name|u_short
operator|)
name|addr_node
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|addr_node
operator|->
name|address
argument_list|,
operator|&
name|addr_sock
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|==
literal|1
condition|)
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|,
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
name|addr_node
operator|=
name|next_node
argument_list|(
name|addr_node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|addr_node
operator|!=
name|NULL
condition|)
do|;
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_other_modes
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|address_node
modifier|*
name|addr_node
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|addr_node
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|manycastserver
argument_list|)
operator|)
condition|)
name|destroy_address_node
argument_list|(
name|addr_node
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|addr_node
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|multicastclient
argument_list|)
operator|)
condition|)
name|destroy_address_node
argument_list|(
name|addr_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_auth
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|ntp_u_int16_t
name|ufirst
decl_stmt|;
name|ntp_u_int16_t
name|ulast
decl_stmt|;
name|ntp_u_int16_t
name|u
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|my_val
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
ifndef|#
directive|ifndef
name|NO_INTRES
name|u_char
name|digest
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|u_int
name|digest_len
decl_stmt|;
name|EVP_MD_CTX
name|ctx
decl_stmt|;
endif|#
directive|endif
name|int
name|item
decl_stmt|;
endif|#
directive|endif
comment|/* Crypto Command */
ifdef|#
directive|ifdef
name|OPENSSL
name|item
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* quiet warning */
name|my_val
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|crypto_cmd_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|my_val
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|my_val
operator|->
name|attr
condition|)
block|{
default|default:
name|NTP_INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Host
case|:
name|item
operator|=
name|CRYPTO_CONF_PRIV
expr_stmt|;
break|break;
case|case
name|T_Ident
case|:
name|item
operator|=
name|CRYPTO_CONF_IDENT
expr_stmt|;
break|break;
case|case
name|T_Pw
case|:
name|item
operator|=
name|CRYPTO_CONF_PW
expr_stmt|;
break|break;
case|case
name|T_Randfile
case|:
name|item
operator|=
name|CRYPTO_CONF_RAND
expr_stmt|;
break|break;
case|case
name|T_Sign
case|:
name|item
operator|=
name|CRYPTO_CONF_SIGN
expr_stmt|;
break|break;
case|case
name|T_Digest
case|:
name|item
operator|=
name|CRYPTO_CONF_NID
expr_stmt|;
break|break;
block|}
name|crypto_config
argument_list|(
name|item
argument_list|,
name|my_val
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|my_val
operator|=
name|next_node
argument_list|(
name|my_val
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* Keysdir Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keysdir
condition|)
block|{
if|if
condition|(
name|keysdir
operator|!=
name|default_keysdir
condition|)
name|free
argument_list|(
name|keysdir
argument_list|)
expr_stmt|;
name|keysdir
operator|=
name|estrdup
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|keysdir
argument_list|)
expr_stmt|;
block|}
comment|/* ntp_signd_socket Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
condition|)
block|{
if|if
condition|(
name|ntp_signd_socket
operator|!=
name|default_ntp_signd_socket
condition|)
name|free
argument_list|(
name|ntp_signd_socket
argument_list|)
expr_stmt|;
name|ntp_signd_socket
operator|=
name|estrdup
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|cryptosw
operator|&&
operator|!
name|cryptosw
condition|)
block|{
name|crypto_setup
argument_list|()
expr_stmt|;
name|cryptosw
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* Keys Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keys
condition|)
name|getauthkeys
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|keys
argument_list|)
expr_stmt|;
comment|/* Control Key Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|control_key
condition|)
name|ctl_auth_keyid
operator|=
operator|(
name|keyid_t
operator|)
name|ptree
operator|->
name|auth
operator|.
name|control_key
expr_stmt|;
comment|/* Requested Key Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|request_key
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"set info_auth_keyid to %08lx\n"
operator|,
operator|(
name|u_long
operator|)
name|ptree
operator|->
name|auth
operator|.
name|request_key
operator|)
argument_list|)
expr_stmt|;
name|info_auth_keyid
operator|=
operator|(
name|keyid_t
operator|)
name|ptree
operator|->
name|auth
operator|.
name|request_key
expr_stmt|;
block|}
comment|/* Trusted Key Command */
name|my_val
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|trusted_key_list
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_val
operator|!=
name|NULL
condition|;
name|my_val
operator|=
name|next_node
argument_list|(
name|my_val
argument_list|)
control|)
block|{
if|if
condition|(
literal|'i'
operator|==
name|my_val
operator|->
name|attr
condition|)
name|authtrust
argument_list|(
name|my_val
operator|->
name|value
operator|.
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|'-'
operator|==
name|my_val
operator|->
name|attr
condition|)
block|{
name|ufirst
operator|=
name|my_val
operator|->
name|value
operator|.
name|u
operator|>>
literal|16
expr_stmt|;
name|ulast
operator|=
name|my_val
operator|->
name|value
operator|.
name|u
operator|&
literal|0xffff
expr_stmt|;
for|for
control|(
name|u
operator|=
name|ufirst
init|;
name|u
operator|<=
name|ulast
condition|;
name|u
operator|++
control|)
name|authtrust
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* crypto revoke command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|revoke
condition|)
name|sys_revoke
operator|=
name|ptree
operator|->
name|auth
operator|.
name|revoke
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
ifndef|#
directive|ifndef
name|NO_INTRES
comment|/* find a keyid */
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
name|req_keyid
operator|=
literal|65535
expr_stmt|;
else|else
name|req_keyid
operator|=
name|info_auth_keyid
expr_stmt|;
comment|/* if doesn't exist, make up one at random */
if|if
condition|(
name|authhavekey
argument_list|(
name|req_keyid
argument_list|)
condition|)
block|{
name|req_keytype
operator|=
name|cache_type
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL
name|req_hashlen
operator|=
literal|16
expr_stmt|;
else|#
directive|else
comment|/* OPENSSL follows */
name|EVP_DigestInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_get_digestbynid
argument_list|(
name|req_keytype
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|digest
argument_list|,
operator|&
name|digest_len
argument_list|)
expr_stmt|;
name|req_hashlen
operator|=
name|digest_len
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|int
name|rankey
decl_stmt|;
name|rankey
operator|=
name|ntp_random
argument_list|()
expr_stmt|;
name|req_keytype
operator|=
name|NID_md5
expr_stmt|;
name|req_hashlen
operator|=
literal|16
expr_stmt|;
name|MD5auth_setkey
argument_list|(
name|req_keyid
argument_list|,
name|req_keytype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rankey
argument_list|,
sizeof|sizeof
argument_list|(
name|rankey
argument_list|)
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|req_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* save keyid so we will accept config requests with it */
name|info_auth_keyid
operator|=
name|req_keyid
expr_stmt|;
endif|#
directive|endif
comment|/* !NO_INTRES */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_auth
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_val
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|my_val
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|crypto_cmd_list
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|my_val
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|my_val
argument_list|)
expr_stmt|;
block|}
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|crypto_cmd_list
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|trusted_key_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_tos
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|tos
decl_stmt|;
name|int
name|item
decl_stmt|;
name|item
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* quiet warning */
name|tos
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|orphan_cmds
argument_list|)
expr_stmt|;
while|while
condition|(
name|tos
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|tos
operator|->
name|attr
condition|)
block|{
default|default:
name|NTP_INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Ceiling
case|:
name|item
operator|=
name|PROTO_CEILING
expr_stmt|;
break|break;
case|case
name|T_Floor
case|:
name|item
operator|=
name|PROTO_FLOOR
expr_stmt|;
break|break;
case|case
name|T_Cohort
case|:
name|item
operator|=
name|PROTO_COHORT
expr_stmt|;
break|break;
case|case
name|T_Orphan
case|:
name|item
operator|=
name|PROTO_ORPHAN
expr_stmt|;
break|break;
case|case
name|T_Mindist
case|:
name|item
operator|=
name|PROTO_MINDISP
expr_stmt|;
break|break;
case|case
name|T_Maxdist
case|:
name|item
operator|=
name|PROTO_MAXDIST
expr_stmt|;
break|break;
case|case
name|T_Minclock
case|:
name|item
operator|=
name|PROTO_MINCLOCK
expr_stmt|;
break|break;
case|case
name|T_Maxclock
case|:
name|item
operator|=
name|PROTO_MAXCLOCK
expr_stmt|;
break|break;
case|case
name|T_Minsane
case|:
name|item
operator|=
name|PROTO_MINSANE
expr_stmt|;
break|break;
case|case
name|T_Beacon
case|:
name|item
operator|=
name|PROTO_BEACON
expr_stmt|;
break|break;
block|}
name|proto_config
argument_list|(
name|item
argument_list|,
literal|0
argument_list|,
name|tos
operator|->
name|value
operator|.
name|d
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tos
operator|=
name|next_node
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_tos
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|tos
decl_stmt|;
while|while
condition|(
operator|!
name|empty
argument_list|(
name|ptree
operator|->
name|orphan_cmds
argument_list|)
condition|)
block|{
name|tos
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|orphan_cmds
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_monitor
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|int
modifier|*
name|pfilegen_token
decl_stmt|;
specifier|const
name|char
modifier|*
name|filegen_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|filegen_file
decl_stmt|;
name|FILEGEN
modifier|*
name|filegen
decl_stmt|;
name|struct
name|filegen_node
modifier|*
name|my_node
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|my_opts
decl_stmt|;
name|int
name|filegen_type
decl_stmt|;
name|int
name|filegen_flag
decl_stmt|;
comment|/* Set the statistics directory */
if|if
condition|(
name|ptree
operator|->
name|stats_dir
condition|)
name|stats_config
argument_list|(
name|STATS_STATSDIR
argument_list|,
name|ptree
operator|->
name|stats_dir
argument_list|)
expr_stmt|;
comment|/* NOTE: 	 * Calling filegen_get is brain dead. Doing a string 	 * comparison to find the relavant filegen structure is 	 * expensive. 	 * 	 * Through the parser, we already know which filegen is 	 * being specified. Hence, we should either store a 	 * pointer to the specified structure in the syntax tree 	 * or an index into a filegen array. 	 * 	 * Need to change the filegen code to reflect the above. 	 */
comment|/* Turn on the specified statistics */
name|pfilegen_token
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|stats_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|pfilegen_token
operator|!=
name|NULL
condition|)
block|{
name|filegen_string
operator|=
name|keyword
argument_list|(
operator|*
name|pfilegen_token
argument_list|)
expr_stmt|;
name|filegen
operator|=
name|filegen_get
argument_list|(
name|filegen_string
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"enabling filegen for %s statistics '%s%s'\n"
operator|,
name|filegen_string
operator|,
name|filegen
operator|->
name|prefix
operator|,
name|filegen
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
name|filegen
operator|->
name|flag
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
name|pfilegen_token
operator|=
name|next_node
argument_list|(
name|pfilegen_token
argument_list|)
expr_stmt|;
block|}
comment|/* Configure the statistics with the options */
name|my_node
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|filegen_opts
argument_list|)
expr_stmt|;
while|while
condition|(
name|my_node
operator|!=
name|NULL
condition|)
block|{
name|filegen_file
operator|=
name|keyword
argument_list|(
name|my_node
operator|->
name|filegen_token
argument_list|)
expr_stmt|;
name|filegen
operator|=
name|filegen_get
argument_list|(
name|filegen_file
argument_list|)
expr_stmt|;
comment|/* Initialize the filegen variables to their pre-configurtion states */
name|filegen_flag
operator|=
name|filegen
operator|->
name|flag
expr_stmt|;
name|filegen_type
operator|=
name|filegen
operator|->
name|type
expr_stmt|;
comment|/* "filegen ... enabled" is the default (when filegen is used) */
name|filegen_flag
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
name|my_opts
operator|=
name|queue_head
argument_list|(
name|my_node
operator|->
name|options
argument_list|)
expr_stmt|;
while|while
condition|(
name|my_opts
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|my_opts
operator|->
name|attr
condition|)
block|{
case|case
name|T_File
case|:
name|filegen_file
operator|=
name|my_opts
operator|->
name|value
operator|.
name|p
expr_stmt|;
break|break;
case|case
name|T_Type
case|:
switch|switch
condition|(
name|my_opts
operator|->
name|value
operator|.
name|i
condition|)
block|{
default|default:
name|NTP_INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_None
case|:
name|filegen_type
operator|=
name|FILEGEN_NONE
expr_stmt|;
break|break;
case|case
name|T_Pid
case|:
name|filegen_type
operator|=
name|FILEGEN_PID
expr_stmt|;
break|break;
case|case
name|T_Day
case|:
name|filegen_type
operator|=
name|FILEGEN_DAY
expr_stmt|;
break|break;
case|case
name|T_Week
case|:
name|filegen_type
operator|=
name|FILEGEN_WEEK
expr_stmt|;
break|break;
case|case
name|T_Month
case|:
name|filegen_type
operator|=
name|FILEGEN_MONTH
expr_stmt|;
break|break;
case|case
name|T_Year
case|:
name|filegen_type
operator|=
name|FILEGEN_YEAR
expr_stmt|;
break|break;
case|case
name|T_Age
case|:
name|filegen_type
operator|=
name|FILEGEN_AGE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|T_Flag
case|:
switch|switch
condition|(
name|my_opts
operator|->
name|value
operator|.
name|i
condition|)
block|{
case|case
name|T_Link
case|:
name|filegen_flag
operator||=
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|T_Nolink
case|:
name|filegen_flag
operator|&=
operator|~
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|T_Enable
case|:
name|filegen_flag
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
case|case
name|T_Disable
case|:
name|filegen_flag
operator|&=
operator|~
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown filegen flag token %d"
argument_list|,
name|my_opts
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown filegen option token %d"
argument_list|,
name|my_opts
operator|->
name|attr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|my_opts
operator|=
name|next_node
argument_list|(
name|my_opts
argument_list|)
expr_stmt|;
block|}
name|filegen_config
argument_list|(
name|filegen
argument_list|,
name|filegen_file
argument_list|,
name|filegen_type
argument_list|,
name|filegen_flag
argument_list|)
expr_stmt|;
name|my_node
operator|=
name|next_node
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_monitor
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|filegen_string
decl_stmt|;
name|struct
name|filegen_node
modifier|*
name|my_node
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|my_opts
decl_stmt|;
if|if
condition|(
name|ptree
operator|->
name|stats_dir
condition|)
block|{
name|free
argument_list|(
name|ptree
operator|->
name|stats_dir
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|stats_dir
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|NULL
operator|!=
operator|(
name|filegen_string
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|stats_list
argument_list|)
operator|)
condition|)
name|free_node
argument_list|(
name|filegen_string
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|my_node
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|filegen_opts
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|NULL
operator|!=
operator|(
name|my_opts
operator|=
name|dequeue
argument_list|(
name|my_node
operator|->
name|options
argument_list|)
operator|)
condition|)
name|free_node
argument_list|(
name|my_opts
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_access
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
specifier|static
name|int
name|warned_signd
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|my_opt
decl_stmt|;
name|struct
name|restrict_node
modifier|*
name|my_node
decl_stmt|;
name|int
modifier|*
name|curr_flag
decl_stmt|;
name|sockaddr_u
name|addr_sock
decl_stmt|;
name|sockaddr_u
name|addr_mask
decl_stmt|;
name|u_short
name|flags
decl_stmt|;
name|u_short
name|mflags
decl_stmt|;
name|int
name|restrict_default
decl_stmt|;
specifier|const
name|char
modifier|*
name|signd_warning
init|=
ifdef|#
directive|ifdef
name|HAVE_NTP_SIGND
literal|"MS-SNTP signd operations currently block ntpd degrading service to all clients."
decl_stmt|;
else|#
directive|else
literal|"mssntp restrict bit ignored, this ntpd was configured without --enable-ntp-signd."
expr_stmt|;
endif|#
directive|endif
comment|/* Configure the discard options */
name|my_opt
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|discard_opts
argument_list|)
expr_stmt|;
while|while
condition|(
name|my_opt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|my_opt
operator|->
name|attr
condition|)
block|{
case|case
name|T_Average
case|:
name|ntp_minpoll
operator|=
name|my_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Minimum
case|:
name|ntp_minpkt
operator|=
name|my_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Monitor
case|:
name|mon_age
operator|=
name|my_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown discard option token %d"
argument_list|,
name|my_opt
operator|->
name|attr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|my_opt
operator|=
name|next_node
argument_list|(
name|my_opt
argument_list|)
expr_stmt|;
block|}
comment|/* Configure the restrict options */
for|for
control|(
name|my_node
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|restrict_opts
argument_list|)
init|;
name|my_node
operator|!=
name|NULL
condition|;
name|my_node
operator|=
name|next_node
argument_list|(
name|my_node
argument_list|)
control|)
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|my_node
operator|->
name|addr
condition|)
block|{
comment|/* 			 * The user specified a default rule without a 			 * -4 / -6 qualifier, add to both lists 			 */
name|restrict_default
operator|=
literal|1
expr_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|restrict_default
operator|=
literal|0
expr_stmt|;
comment|/* Resolve the specified address */
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
operator|(
name|u_short
operator|)
name|my_node
operator|->
name|addr
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|my_node
operator|->
name|addr
operator|->
name|address
argument_list|,
operator|&
name|addr_sock
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"restrict: error in address '%s' on line %d. Ignoring..."
argument_list|,
name|my_node
operator|->
name|addr
operator|->
name|address
argument_list|,
name|my_node
operator|->
name|line_no
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SET_HOSTMASK
argument_list|(
operator|&
name|addr_mask
argument_list|,
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Resolve the mask */
if|if
condition|(
name|my_node
operator|->
name|mask
condition|)
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_mask
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|addr_mask
argument_list|)
operator|=
operator|(
name|u_short
operator|)
name|my_node
operator|->
name|mask
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|my_node
operator|->
name|mask
operator|->
name|address
argument_list|,
operator|&
name|addr_mask
argument_list|,
literal|1
argument_list|,
name|t_MSK
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"restrict: error in mask '%s' on line %d. Ignoring..."
argument_list|,
name|my_node
operator|->
name|mask
operator|->
name|address
argument_list|,
name|my_node
operator|->
name|line_no
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* Parse the flags */
name|flags
operator|=
literal|0
expr_stmt|;
name|mflags
operator|=
literal|0
expr_stmt|;
name|curr_flag
operator|=
name|queue_head
argument_list|(
name|my_node
operator|->
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_flag
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|curr_flag
condition|)
block|{
default|default:
name|NTP_INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Ntpport
case|:
name|mflags
operator||=
name|RESM_NTPONLY
expr_stmt|;
break|break;
case|case
name|T_Flake
case|:
name|flags
operator||=
name|RES_TIMEOUT
expr_stmt|;
break|break;
case|case
name|T_Ignore
case|:
name|flags
operator||=
name|RES_IGNORE
expr_stmt|;
break|break;
case|case
name|T_Kod
case|:
name|flags
operator||=
name|RES_KOD
expr_stmt|;
break|break;
case|case
name|T_Mssntp
case|:
name|flags
operator||=
name|RES_MSSNTP
expr_stmt|;
break|break;
case|case
name|T_Limited
case|:
name|flags
operator||=
name|RES_LIMITED
expr_stmt|;
break|break;
case|case
name|T_Lowpriotrap
case|:
name|flags
operator||=
name|RES_LPTRAP
expr_stmt|;
break|break;
case|case
name|T_Nomodify
case|:
name|flags
operator||=
name|RES_NOMODIFY
expr_stmt|;
break|break;
case|case
name|T_Nopeer
case|:
name|flags
operator||=
name|RES_NOPEER
expr_stmt|;
break|break;
case|case
name|T_Noquery
case|:
name|flags
operator||=
name|RES_NOQUERY
expr_stmt|;
break|break;
case|case
name|T_Noserve
case|:
name|flags
operator||=
name|RES_DONTSERVE
expr_stmt|;
break|break;
case|case
name|T_Notrap
case|:
name|flags
operator||=
name|RES_NOTRAP
expr_stmt|;
break|break;
case|case
name|T_Notrust
case|:
name|flags
operator||=
name|RES_DONTTRUST
expr_stmt|;
break|break;
case|case
name|T_Version
case|:
name|flags
operator||=
name|RES_VERSION
expr_stmt|;
break|break;
block|}
name|curr_flag
operator|=
name|next_node
argument_list|(
name|curr_flag
argument_list|)
expr_stmt|;
block|}
comment|/* Set the flags */
if|if
condition|(
name|restrict_default
condition|)
block|{
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|addr_sock
argument_list|,
operator|&
name|addr_mask
argument_list|,
name|mflags
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
name|AF_INET6
expr_stmt|;
block|}
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|addr_sock
argument_list|,
operator|&
name|addr_mask
argument_list|,
name|mflags
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|RES_MSSNTP
operator|&
name|flags
operator|)
operator|&&
operator|!
name|warned_signd
condition|)
block|{
name|warned_signd
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|signd_warning
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|signd_warning
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_access
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_opt
decl_stmt|;
name|struct
name|restrict_node
modifier|*
name|my_node
decl_stmt|;
name|int
modifier|*
name|curr_flag
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|my_opt
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|discard_opts
argument_list|)
operator|)
condition|)
name|free_node
argument_list|(
name|my_opt
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|my_node
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|restrict_opts
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|NULL
operator|!=
operator|(
name|curr_flag
operator|=
name|dequeue
argument_list|(
name|my_node
operator|->
name|flags
argument_list|)
operator|)
condition|)
name|free_node
argument_list|(
name|curr_flag
argument_list|)
expr_stmt|;
name|destroy_restrict_node
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_tinker
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|tinker
decl_stmt|;
name|int
name|item
decl_stmt|;
name|item
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* quiet warning */
name|tinker
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|tinker
argument_list|)
expr_stmt|;
while|while
condition|(
name|tinker
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|tinker
operator|->
name|attr
condition|)
block|{
default|default:
name|NTP_INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Allan
case|:
name|item
operator|=
name|LOOP_ALLAN
expr_stmt|;
break|break;
case|case
name|T_Dispersion
case|:
name|item
operator|=
name|LOOP_PHI
expr_stmt|;
break|break;
case|case
name|T_Freq
case|:
name|item
operator|=
name|LOOP_FREQ
expr_stmt|;
break|break;
case|case
name|T_Huffpuff
case|:
name|item
operator|=
name|LOOP_HUFFPUFF
expr_stmt|;
break|break;
case|case
name|T_Panic
case|:
name|item
operator|=
name|LOOP_PANIC
expr_stmt|;
break|break;
case|case
name|T_Step
case|:
name|item
operator|=
name|LOOP_MAX
expr_stmt|;
break|break;
case|case
name|T_Stepout
case|:
name|item
operator|=
name|LOOP_MINSTEP
expr_stmt|;
break|break;
block|}
name|loop_config
argument_list|(
name|item
argument_list|,
name|tinker
operator|->
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
name|tinker
operator|=
name|next_node
argument_list|(
name|tinker
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_tinker
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|tinker
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|tinker
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|tinker
argument_list|)
operator|)
condition|)
name|free_node
argument_list|(
name|tinker
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_comment
comment|/*  * config_nic_rules - apply interface listen/ignore/drop items  */
end_comment

begin_function
name|void
name|config_nic_rules
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|nic_rule_node
modifier|*
name|curr_node
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|nic_rule_match
name|match_type
decl_stmt|;
name|nic_rule_action
name|action
decl_stmt|;
name|char
modifier|*
name|if_name
decl_stmt|;
name|char
modifier|*
name|pchSlash
decl_stmt|;
name|int
name|prefixlen
decl_stmt|;
name|int
name|addrbits
decl_stmt|;
name|curr_node
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|nic_rules
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_node
operator|!=
name|NULL
operator|&&
operator|(
name|HAVE_OPT
argument_list|(
name|NOVIRTUALIPS
argument_list|)
operator|||
name|HAVE_OPT
argument_list|(
name|INTERFACE
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"interface/nic rules are not allowed with --interface (-I) or --novirtualips (-L)%s"
argument_list|,
operator|(
name|input_from_file
operator|)
condition|?
literal|", exiting"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_from_file
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
for|for
control|(
init|;
name|curr_node
operator|!=
name|NULL
condition|;
name|curr_node
operator|=
name|next_node
argument_list|(
name|curr_node
argument_list|)
control|)
block|{
name|prefixlen
operator|=
operator|-
literal|1
expr_stmt|;
name|if_name
operator|=
name|curr_node
operator|->
name|if_name
expr_stmt|;
if|if
condition|(
name|if_name
operator|!=
name|NULL
condition|)
name|if_name
operator|=
name|estrdup
argument_list|(
name|if_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curr_node
operator|->
name|match_class
condition|)
block|{
default|default:
comment|/* 			 * this assignment quiets a gcc "may be used 			 * uninitialized" warning and is here for no 			 * other reason. 			 */
name|match_type
operator|=
name|MATCH_ALL
expr_stmt|;
name|NTP_INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 			 * 0 is out of range for valid token T_... 			 * and in a nic_rules_node indicates the 			 * interface descriptor is either a name or 			 * address, stored in if_name in either case. 			 */
name|NTP_INSIST
argument_list|(
name|if_name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pchSlash
operator|=
name|strchr
argument_list|(
name|if_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pchSlash
operator|!=
name|NULL
condition|)
operator|*
name|pchSlash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|is_ip_address
argument_list|(
name|if_name
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|match_type
operator|=
name|MATCH_IFADDR
expr_stmt|;
if|if
condition|(
name|pchSlash
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
name|pchSlash
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|prefixlen
argument_list|)
expr_stmt|;
name|addrbits
operator|=
literal|8
operator|*
name|SIZEOF_INADDR
argument_list|(
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|prefixlen
operator|=
name|max
argument_list|(
operator|-
literal|1
argument_list|,
name|prefixlen
argument_list|)
expr_stmt|;
name|prefixlen
operator|=
name|min
argument_list|(
name|prefixlen
argument_list|,
name|addrbits
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|match_type
operator|=
name|MATCH_IFNAME
expr_stmt|;
if|if
condition|(
name|pchSlash
operator|!=
name|NULL
condition|)
operator|*
name|pchSlash
operator|=
literal|'/'
expr_stmt|;
block|}
break|break;
case|case
name|T_All
case|:
name|match_type
operator|=
name|MATCH_ALL
expr_stmt|;
break|break;
case|case
name|T_Ipv4
case|:
name|match_type
operator|=
name|MATCH_IPV4
expr_stmt|;
break|break;
case|case
name|T_Ipv6
case|:
name|match_type
operator|=
name|MATCH_IPV6
expr_stmt|;
break|break;
case|case
name|T_Wildcard
case|:
name|match_type
operator|=
name|MATCH_WILDCARD
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|curr_node
operator|->
name|action
condition|)
block|{
default|default:
comment|/* 			 * this assignment quiets a gcc "may be used 			 * uninitialized" warning and is here for no 			 * other reason. 			 */
name|action
operator|=
name|ACTION_LISTEN
expr_stmt|;
name|NTP_INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Listen
case|:
name|action
operator|=
name|ACTION_LISTEN
expr_stmt|;
break|break;
case|case
name|T_Ignore
case|:
name|action
operator|=
name|ACTION_IGNORE
expr_stmt|;
break|break;
case|case
name|T_Drop
case|:
name|action
operator|=
name|ACTION_DROP
expr_stmt|;
break|break;
block|}
name|add_nic_rule
argument_list|(
name|match_type
argument_list|,
name|if_name
argument_list|,
name|prefixlen
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|timer_interfacetimeout
argument_list|(
name|current_time
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|if_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_nic_rules
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|nic_rule_node
modifier|*
name|curr_node
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|curr_node
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|nic_rules
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|curr_node
operator|->
name|if_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|curr_node
operator|->
name|if_name
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|curr_node
argument_list|)
expr_stmt|;
block|}
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|nic_rules
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|apply_enable_disable
parameter_list|(
name|queue
modifier|*
name|q
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|curr_flag
decl_stmt|;
name|int
name|option
decl_stmt|;
ifdef|#
directive|ifdef
name|BC_LIST_FRAMEWORK_NOT_YET_USED
name|bc_entry
modifier|*
name|pentry
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|curr_flag
operator|=
name|queue_head
argument_list|(
name|q
argument_list|)
init|;
name|curr_flag
operator|!=
name|NULL
condition|;
name|curr_flag
operator|=
name|next_node
argument_list|(
name|curr_flag
argument_list|)
control|)
block|{
name|option
operator|=
name|curr_flag
operator|->
name|value
operator|.
name|i
expr_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can not apply enable/disable token %d, unknown"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Auth
case|:
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Bclient
case|:
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Calibrate
case|:
name|proto_config
argument_list|(
name|PROTO_CAL
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Kernel
case|:
name|proto_config
argument_list|(
name|PROTO_KERNEL
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Monitor
case|:
name|proto_config
argument_list|(
name|PROTO_MONITOR
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Ntp
case|:
name|proto_config
argument_list|(
name|PROTO_NTP
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Stats
case|:
name|proto_config
argument_list|(
name|PROTO_FILEGEN
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BC_LIST_FRAMEWORK_NOT_YET_USED
case|case
name|T_Bc_bugXXXX
case|:
name|pentry
operator|=
name|bc_list
expr_stmt|;
while|while
condition|(
name|pentry
operator|->
name|token
condition|)
block|{
if|if
condition|(
name|pentry
operator|->
name|token
operator|==
name|option
condition|)
break|break;
name|pentry
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pentry
operator|->
name|token
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"compat token %d not in bc_list[]"
argument_list|,
name|option
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pentry
operator|->
name|enabled
operator|=
name|enable
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|config_system_opts
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|apply_enable_disable
argument_list|(
name|ptree
operator|->
name|enable_opts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_enable_disable
argument_list|(
name|ptree
operator|->
name|disable_opts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_system_opts
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|flag
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|flag
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|enable_opts
argument_list|)
operator|)
condition|)
name|free_node
argument_list|(
name|flag
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|flag
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|disable_opts
argument_list|)
operator|)
condition|)
name|free_node
argument_list|(
name|flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_logconfig
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_logconfig
decl_stmt|;
name|my_logconfig
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|logconfig
argument_list|)
expr_stmt|;
while|while
condition|(
name|my_logconfig
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|my_logconfig
operator|->
name|attr
condition|)
block|{
case|case
literal|'+'
case|:
name|ntp_syslogmask
operator||=
name|get_logmask
argument_list|(
name|my_logconfig
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|ntp_syslogmask
operator|&=
operator|~
name|get_logmask
argument_list|(
name|my_logconfig
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ntp_syslogmask
operator|=
name|get_logmask
argument_list|(
name|my_logconfig
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|my_logconfig
operator|=
name|next_node
argument_list|(
name|my_logconfig
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_logconfig
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_logconfig
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|my_logconfig
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|logconfig
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|my_logconfig
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|my_logconfig
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_phone
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|phone
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|COUNTOF
argument_list|(
name|sys_phone
argument_list|)
operator|-
literal|1
condition|)
block|{
name|sys_phone
index|[
name|i
operator|++
index|]
operator|=
name|estrdup
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|sys_phone
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"phone: Number of phone entries exceeds %lu. Ignoring phone %s..."
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|COUNTOF
argument_list|(
name|sys_phone
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|next_node
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_phone
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|s
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|phone
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_qos
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_qosconfig
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IPTOS_SUPPORT
name|unsigned
name|int
name|qtos
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|my_qosconfig
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|qos
argument_list|)
expr_stmt|;
while|while
condition|(
name|my_qosconfig
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|my_qosconfig
operator|->
name|value
operator|.
name|s
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IPTOS_SUPPORT
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"lowdelay"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_LOWDELAY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"throughput"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_THROUGHPUT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"reliability"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_RELIABILITY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"mincost"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_MINCOST
expr_stmt|;
ifdef|#
directive|ifdef
name|IPTOS_PREC_INTERNETCONTROL
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"routine"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cs0"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_CS0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"priority"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cs1"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_CS1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"immediate"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cs2"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_CS2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"flash"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cs3"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_CS3
expr_stmt|;
comment|/* overlapping prefix on keyword */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"flashoverride"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cs4"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_CS4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"critical"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cs5"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_CS5
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"internetcontrol"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cs6"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_CS6
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"netcontrol"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cs7"
argument_list|)
condition|)
name|qtos
operator|=
name|CONF_QOS_CS7
expr_stmt|;
endif|#
directive|endif
comment|/* IPTOS_PREC_INTERNETCONTROL */
if|if
condition|(
name|qtos
operator|==
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse error, qos %s not accepted\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|qos
operator|=
name|qtos
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE IPTOS_SUPPORT */
comment|/* 		 * value is set, but not being effective. Need code to 		 * change   the current connections to notice. Might 		 * also  consider logging a message about the action. 		 * XXX msyslog(LOG_INFO, "QoS %s requested by config\n", s); 		 */
name|my_qosconfig
operator|=
name|next_node
argument_list|(
name|my_qosconfig
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_qos
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|my_qosconfig
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|my_qosconfig
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|qos
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|my_qosconfig
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|my_qosconfig
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_setvar
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|setvar_node
modifier|*
name|my_node
decl_stmt|;
name|size_t
name|varlen
decl_stmt|,
name|vallen
decl_stmt|,
name|octets
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|NULL
expr_stmt|;
name|my_node
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|setvar
argument_list|)
expr_stmt|;
while|while
condition|(
name|my_node
operator|!=
name|NULL
condition|)
block|{
name|varlen
operator|=
name|strlen
argument_list|(
name|my_node
operator|->
name|var
argument_list|)
expr_stmt|;
name|vallen
operator|=
name|strlen
argument_list|(
name|my_node
operator|->
name|val
argument_list|)
expr_stmt|;
name|octets
operator|=
name|varlen
operator|+
name|vallen
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|str
operator|=
name|erealloc
argument_list|(
name|str
argument_list|,
name|octets
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
name|octets
argument_list|,
literal|"%s=%s"
argument_list|,
name|my_node
operator|->
name|var
argument_list|,
name|my_node
operator|->
name|val
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|str
argument_list|,
name|octets
argument_list|,
operator|(
name|my_node
operator|->
name|isdefault
operator|)
condition|?
name|DEF
else|:
literal|0
argument_list|)
expr_stmt|;
name|my_node
operator|=
name|next_node
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_setvar
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|setvar_node
modifier|*
name|my_node
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|my_node
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|setvar
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|my_node
operator|->
name|var
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|my_node
operator|->
name|val
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_ttl
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|curr_ttl
decl_stmt|;
name|curr_ttl
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|ttl
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_ttl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|COUNTOF
argument_list|(
name|sys_ttl
argument_list|)
condition|)
name|sys_ttl
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|u_char
operator|)
operator|*
name|curr_ttl
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ttl: Number of TTL entries exceeds %lu. Ignoring TTL %d..."
argument_list|,
operator|(
name|u_long
operator|)
name|COUNTOF
argument_list|(
name|sys_ttl
argument_list|)
argument_list|,
operator|*
name|curr_ttl
argument_list|)
expr_stmt|;
name|curr_ttl
operator|=
name|next_node
argument_list|(
name|curr_ttl
argument_list|)
expr_stmt|;
block|}
name|sys_ttlmax
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_ttl
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
comment|/* coming DESTROY_QUEUE(ptree->ttl) is enough */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_trap
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|addr_opts_node
modifier|*
name|curr_trap
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|curr_opt
decl_stmt|;
name|sockaddr_u
name|addr_sock
decl_stmt|;
name|sockaddr_u
name|peeraddr
decl_stmt|;
name|struct
name|address_node
modifier|*
name|addr_node
decl_stmt|;
name|struct
name|interface
modifier|*
name|localaddr
decl_stmt|;
name|u_short
name|port_no
decl_stmt|;
name|int
name|err_flag
decl_stmt|;
comment|/* silence warning about addr_sock potentially uninitialized */
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
name|AF_UNSPEC
expr_stmt|;
for|for
control|(
name|curr_trap
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|trap
argument_list|)
init|;
name|curr_trap
operator|!=
name|NULL
condition|;
name|curr_trap
operator|=
name|next_node
argument_list|(
name|curr_trap
argument_list|)
control|)
block|{
name|err_flag
operator|=
literal|0
expr_stmt|;
name|port_no
operator|=
literal|0
expr_stmt|;
name|localaddr
operator|=
name|NULL
expr_stmt|;
name|curr_opt
operator|=
name|queue_head
argument_list|(
name|curr_trap
operator|->
name|options
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_opt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|T_Port
operator|==
name|curr_opt
operator|->
name|attr
condition|)
block|{
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
operator|<
literal|1
operator|||
name|curr_opt
operator|->
name|value
operator|.
name|i
operator|>
name|USHRT_MAX
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid port number "
literal|"%d, trap ignored"
argument_list|,
name|curr_opt
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
name|err_flag
operator|=
literal|1
expr_stmt|;
block|}
name|port_no
operator|=
operator|(
name|u_short
operator|)
name|curr_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|T_Interface
operator|==
name|curr_opt
operator|->
name|attr
condition|)
block|{
name|addr_node
operator|=
name|curr_opt
operator|->
name|value
operator|.
name|p
expr_stmt|;
comment|/* Resolve the interface address */
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
operator|(
name|u_short
operator|)
name|addr_node
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|addr_node
operator|->
name|address
argument_list|,
operator|&
name|addr_sock
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|err_flag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|localaddr
operator|=
name|findinterface
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|localaddr
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't find interface with address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr_sock
argument_list|)
argument_list|)
expr_stmt|;
name|err_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|curr_opt
operator|=
name|next_node
argument_list|(
name|curr_opt
argument_list|)
expr_stmt|;
block|}
comment|/* Now process the trap for the specified interface 		 * and port number 		 */
if|if
condition|(
operator|!
name|err_flag
condition|)
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|getnetnum
argument_list|(
name|curr_trap
operator|->
name|addr
operator|->
name|address
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
condition|)
continue|continue;
comment|/* port is at same location for v4 and v6 */
name|SET_PORT
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|port_no
condition|?
name|port_no
else|:
name|TRAPPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|localaddr
condition|)
name|localaddr
operator|=
name|ANY_INTERFACE_CHOOSE
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
else|else
name|AF
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|=
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctlsettrap
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|localaddr
argument_list|,
literal|0
argument_list|,
name|NTP_VERSION
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't set trap for %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_trap
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|addr_opts_node
modifier|*
name|curr_trap
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|curr_opt
decl_stmt|;
name|struct
name|address_node
modifier|*
name|addr_node
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|curr_trap
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|trap
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|curr_trap
operator|->
name|options
operator|!=
name|NULL
operator|&&
name|NULL
operator|!=
operator|(
name|curr_opt
operator|=
name|dequeue
argument_list|(
name|curr_trap
operator|->
name|options
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|T_Interface
operator|==
name|curr_opt
operator|->
name|attr
condition|)
block|{
name|addr_node
operator|=
name|curr_opt
operator|->
name|value
operator|.
name|p
expr_stmt|;
name|destroy_address_node
argument_list|(
name|addr_node
argument_list|)
expr_stmt|;
block|}
name|free_node
argument_list|(
name|curr_opt
argument_list|)
expr_stmt|;
block|}
name|DESTROY_QUEUE
argument_list|(
name|curr_trap
operator|->
name|options
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|curr_trap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_fudge
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|addr_opts_node
modifier|*
name|curr_fudge
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|curr_opt
decl_stmt|;
name|sockaddr_u
name|addr_sock
decl_stmt|;
name|struct
name|address_node
modifier|*
name|addr_node
decl_stmt|;
name|struct
name|refclockstat
name|clock_stat
decl_stmt|;
name|int
name|err_flag
decl_stmt|;
name|curr_fudge
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|fudge
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_fudge
operator|!=
name|NULL
condition|)
block|{
name|err_flag
operator|=
literal|0
expr_stmt|;
comment|/* Get the reference clock address and 		 * ensure that it is sane 		 */
name|addr_node
operator|=
name|curr_fudge
operator|->
name|addr
expr_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|addr_node
operator|->
name|address
argument_list|,
operator|&
name|addr_sock
argument_list|,
literal|1
argument_list|,
name|t_REF
argument_list|)
operator|!=
literal|1
condition|)
name|err_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|addr_sock
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"inappropriate address %s for the fudge command, line ignored"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr_sock
argument_list|)
argument_list|)
expr_stmt|;
name|err_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Parse all the options to the fudge command */
name|memset
argument_list|(
operator|&
name|clock_stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|clock_stat
argument_list|)
argument_list|)
expr_stmt|;
name|curr_opt
operator|=
name|queue_head
argument_list|(
name|curr_fudge
operator|->
name|options
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_opt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|curr_opt
operator|->
name|attr
condition|)
block|{
case|case
name|T_Time1
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME1
expr_stmt|;
name|clock_stat
operator|.
name|fudgetime1
operator|=
name|curr_opt
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Time2
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME2
expr_stmt|;
name|clock_stat
operator|.
name|fudgetime2
operator|=
name|curr_opt
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Stratum
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL1
expr_stmt|;
name|clock_stat
operator|.
name|fudgeval1
operator|=
name|curr_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Refid
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL2
expr_stmt|;
name|clock_stat
operator|.
name|fudgeval2
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|clock_stat
operator|.
name|fudgeval2
argument_list|,
name|curr_opt
operator|->
name|value
operator|.
name|s
argument_list|,
name|min
argument_list|(
name|strlen
argument_list|(
name|curr_opt
operator|->
name|value
operator|.
name|s
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Flag1
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG1
expr_stmt|;
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
condition|)
name|clock_stat
operator|.
name|flags
operator||=
name|CLK_FLAG1
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|CLK_FLAG1
expr_stmt|;
break|break;
case|case
name|T_Flag2
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG2
expr_stmt|;
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
condition|)
name|clock_stat
operator|.
name|flags
operator||=
name|CLK_FLAG2
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|CLK_FLAG2
expr_stmt|;
break|break;
case|case
name|T_Flag3
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG3
expr_stmt|;
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
condition|)
name|clock_stat
operator|.
name|flags
operator||=
name|CLK_FLAG3
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|CLK_FLAG3
expr_stmt|;
break|break;
case|case
name|T_Flag4
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG4
expr_stmt|;
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
condition|)
name|clock_stat
operator|.
name|flags
operator||=
name|CLK_FLAG4
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|CLK_FLAG4
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected fudge internal flag 0x%x for %s\n"
argument_list|,
name|curr_opt
operator|->
name|attr
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr_sock
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|curr_opt
operator|->
name|attr
condition|?
name|curr_opt
operator|->
name|attr
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
name|curr_opt
operator|=
name|next_node
argument_list|(
name|curr_opt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
operator|!
name|err_flag
condition|)
name|refclock_control
argument_list|(
operator|&
name|addr_sock
argument_list|,
operator|&
name|clock_stat
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curr_fudge
operator|=
name|next_node
argument_list|(
name|curr_fudge
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_fudge
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|addr_opts_node
modifier|*
name|curr_fudge
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|curr_opt
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|curr_fudge
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|fudge
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|NULL
operator|!=
operator|(
name|curr_opt
operator|=
name|dequeue
argument_list|(
name|curr_fudge
operator|->
name|options
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|curr_opt
operator|->
name|attr
condition|)
block|{
case|case
name|CLK_HAVEVAL2
case|:
name|free
argument_list|(
name|curr_opt
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|free_node
argument_list|(
name|curr_opt
argument_list|)
expr_stmt|;
block|}
name|DESTROY_QUEUE
argument_list|(
name|curr_fudge
operator|->
name|options
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|curr_fudge
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_vars
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|curr_var
decl_stmt|;
name|FILE
modifier|*
name|new_file
decl_stmt|;
name|int
name|len
decl_stmt|;
name|curr_var
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|vars
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_var
operator|!=
name|NULL
condition|)
block|{
comment|/* Determine which variable to set and set it */
switch|switch
condition|(
name|curr_var
operator|->
name|attr
condition|)
block|{
case|case
name|T_Broadcastdelay
case|:
name|proto_config
argument_list|(
name|PROTO_BROADDELAY
argument_list|,
literal|0
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|d
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Calldelay
case|:
name|proto_config
argument_list|(
name|PROTO_CALLDELAY
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|i
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Tick
case|:
name|proto_config
argument_list|(
name|PROTO_ADJ
argument_list|,
literal|0
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|d
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Driftfile
case|:
if|if
condition|(
literal|'\0'
operator|==
name|curr_var
operator|->
name|value
operator|.
name|s
index|[
literal|0
index|]
condition|)
block|{
name|stats_drift_file
operator|=
literal|0
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"config: driftfile disabled\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_WanderThreshold
case|:
name|wander_threshold
operator|=
name|curr_var
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Leapfile
case|:
name|stats_config
argument_list|(
name|STATS_LEAP_FILE
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Pidfile
case|:
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Logfile
case|:
name|new_file
operator|=
name|fopen
argument_list|(
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
comment|/* conditional if clause for conditional syslog */
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"logging to file %s"
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
operator|&&
name|fileno
argument_list|(
name|syslog_file
argument_list|)
operator|!=
name|fileno
argument_list|(
name|new_file
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
name|syslog_file
operator|=
name|new_file
expr_stmt|;
name|syslogit
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot open log file %s"
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Saveconfigdir
case|:
if|if
condition|(
name|saveconfigdir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|saveconfigdir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|len
condition|)
name|saveconfigdir
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|DIR_SEP
operator|!=
name|curr_var
operator|->
name|value
operator|.
name|s
index|[
name|len
operator|-
literal|1
index|]
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* slash is also a dir. sep. on Windows */
operator|&&
literal|'/'
operator|!=
name|curr_var
operator|->
name|value
operator|.
name|s
index|[
name|len
operator|-
literal|1
index|]
endif|#
directive|endif
condition|)
block|{
name|len
operator|++
expr_stmt|;
name|saveconfigdir
operator|=
name|emalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|saveconfigdir
argument_list|,
name|len
operator|+
literal|1
argument_list|,
literal|"%s%c"
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|,
name|DIR_SEP
argument_list|)
expr_stmt|;
block|}
else|else
name|saveconfigdir
operator|=
name|estrdup
argument_list|(
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Automax
case|:
ifdef|#
directive|ifdef
name|OPENSSL
name|sys_automax
operator|=
name|curr_var
operator|->
name|value
operator|.
name|i
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"config_vars(): unexpected token %d"
argument_list|,
name|curr_var
operator|->
name|attr
argument_list|)
expr_stmt|;
block|}
name|curr_var
operator|=
name|next_node
argument_list|(
name|curr_var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_vars
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|attr_val
modifier|*
name|curr_var
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|curr_var
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|vars
argument_list|)
operator|)
condition|)
block|{
comment|/* Determine which variable to set and set it */
switch|switch
condition|(
name|curr_var
operator|->
name|attr
condition|)
block|{
case|case
name|T_Driftfile
case|:
case|case
name|T_Leapfile
case|:
case|case
name|T_Pidfile
case|:
case|case
name|T_Logfile
case|:
name|free
argument_list|(
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|free_node
argument_list|(
name|curr_var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_comment
comment|/* Define a function to check if a resolved address is sane.  * If yes, return 1, else return 0;  */
end_comment

begin_function
specifier|static
name|int
name|is_sane_resolved_address
parameter_list|(
name|sockaddr_u
modifier|*
name|peeraddr
parameter_list|,
name|int
name|hmode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
name|peeraddr
argument_list|)
operator|&&
name|ISBADADR
argument_list|(
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|stoa
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Shouldn't be able to specify multicast 	 * address for server/peer! 	 * and unicast address for manycastclient! 	 */
if|if
condition|(
operator|(
name|T_Server
operator|==
name|hmode
operator|||
name|T_Peer
operator|==
name|hmode
operator|||
name|T_Pool
operator|==
name|hmode
operator|)
operator|&&
name|IS_MCAST
argument_list|(
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|stoa
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|T_Manycastclient
operator|==
name|hmode
operator|&&
operator|!
name|IS_MCAST
argument_list|(
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|stoa
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|IS_IPV6
argument_list|(
name|peeraddr
argument_list|)
operator|&&
operator|!
name|ipv6_works
condition|)
return|return
literal|0
return|;
comment|/* Ok, all tests succeeded, now we can return 1 */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_correct_host_mode
parameter_list|(
name|int
name|hmode
parameter_list|)
block|{
switch|switch
condition|(
name|hmode
condition|)
block|{
case|case
name|T_Server
case|:
case|case
name|T_Pool
case|:
case|case
name|T_Manycastclient
case|:
return|return
name|MODE_CLIENT
return|;
break|break;
case|case
name|T_Peer
case|:
return|return
name|MODE_ACTIVE
return|;
break|break;
case|case
name|T_Broadcast
case|:
return|return
name|MODE_BROADCAST
return|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|config_peers
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|res
decl_stmt|,
modifier|*
name|res_bak
decl_stmt|;
name|sockaddr_u
name|peeraddr
decl_stmt|;
name|struct
name|peer_node
modifier|*
name|curr_peer
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|option
decl_stmt|;
name|int
name|hmode
decl_stmt|;
name|int
name|peerflags
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|no_needed
decl_stmt|;
name|int
name|i
decl_stmt|;
name|curr_peer
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|peers
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_peer
operator|!=
name|NULL
condition|)
block|{
comment|/* Find the number of associations needed. 		 * If a pool coomand is specified, then sys_maxclock needed 		 * else, only one is needed 		 */
name|no_needed
operator|=
operator|(
name|T_Pool
operator|==
name|curr_peer
operator|->
name|host_mode
operator|)
condition|?
name|sys_maxclock
else|:
literal|1
expr_stmt|;
comment|/* Find the correct host-mode */
name|hmode
operator|=
name|get_correct_host_mode
argument_list|(
name|curr_peer
operator|->
name|host_mode
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|hmode
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* translate peerflags options to bits */
name|peerflags
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|queue_head
argument_list|(
name|curr_peer
operator|->
name|peerflags
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|option
operator|!=
name|NULL
condition|;
name|option
operator|=
name|next_node
argument_list|(
name|option
argument_list|)
control|)
switch|switch
condition|(
name|option
operator|->
name|value
operator|.
name|i
condition|)
block|{
default|default:
name|NTP_INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Autokey
case|:
name|peerflags
operator||=
name|FLAG_SKEY
expr_stmt|;
break|break;
case|case
name|T_Burst
case|:
name|peerflags
operator||=
name|FLAG_BURST
expr_stmt|;
break|break;
case|case
name|T_Iburst
case|:
name|peerflags
operator||=
name|FLAG_IBURST
expr_stmt|;
break|break;
case|case
name|T_Noselect
case|:
name|peerflags
operator||=
name|FLAG_NOSELECT
expr_stmt|;
break|break;
case|case
name|T_Preempt
case|:
name|peerflags
operator||=
name|FLAG_PREEMPT
expr_stmt|;
break|break;
case|case
name|T_Prefer
case|:
name|peerflags
operator||=
name|FLAG_PREFER
expr_stmt|;
break|break;
case|case
name|T_True
case|:
name|peerflags
operator||=
name|FLAG_TRUE
expr_stmt|;
break|break;
case|case
name|T_Xleave
case|:
name|peerflags
operator||=
name|FLAG_XLEAVE
expr_stmt|;
break|break;
block|}
comment|/* Attempt to resolve the address */
name|ZERO_SOCK
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|=
operator|(
name|u_short
operator|)
name|curr_peer
operator|->
name|addr
operator|->
name|type
expr_stmt|;
name|status
operator|=
name|get_multiple_netnums
argument_list|(
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|,
operator|&
name|peeraddr
argument_list|,
operator|&
name|res
argument_list|,
literal|0
argument_list|,
name|t_UNK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORCE_DEFER_DNS
comment|/* Hack for debugging Deferred DNS 		 * Pretend working names didn't work. 		 */
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
comment|/* Deferring everything breaks refclocks. */
name|memcpy
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
comment|/* force deferred DNS path */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Forcing Deferred DNS for %s, %s"
argument_list|,
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NOT Deferring DNS for %s, %s"
argument_list|,
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* I don't know why getnetnum would return -1. 		 * The old code had this test, so I guess it must be 		 * useful 		 */
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Do nothing, apparently we found an IPv6 			 * address and can't do anything about it */
block|}
comment|/* Check if name resolution failed. If yes, store the 		 * peer information in a file for asynchronous 		 * resolution later 		 */
elseif|else
if|if
condition|(
name|status
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Deferring DNS for %s %d"
argument_list|,
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|,
name|no_needed
argument_list|)
expr_stmt|;
name|save_resolve
argument_list|(
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|,
name|no_needed
argument_list|,
name|curr_peer
operator|->
name|addr
operator|->
name|type
argument_list|,
name|hmode
argument_list|,
name|curr_peer
operator|->
name|peerversion
argument_list|,
name|curr_peer
operator|->
name|minpoll
argument_list|,
name|curr_peer
operator|->
name|maxpoll
argument_list|,
name|peerflags
argument_list|,
name|curr_peer
operator|->
name|ttl
argument_list|,
name|curr_peer
operator|->
name|peerkey
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"*"
argument_list|)
expr_stmt|;
block|}
comment|/* Yippie!! Name resolution has succeeded!!! 		 * Now we can proceed to some more sanity checks on 		 * the resolved address before we start to configure 		 * the peer 		 */
else|else
block|{
name|res_bak
operator|=
name|res
expr_stmt|;
comment|/* 			 * Loop to configure the desired number of 			 * associations 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|no_needed
operator|)
operator|&&
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
operator|++
name|i
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sane_resolved_address
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|curr_peer
operator|->
name|host_mode
argument_list|)
condition|)
name|peer_config
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|NULL
argument_list|,
name|hmode
argument_list|,
name|curr_peer
operator|->
name|peerversion
argument_list|,
name|curr_peer
operator|->
name|minpoll
argument_list|,
name|curr_peer
operator|->
name|maxpoll
argument_list|,
name|peerflags
argument_list|,
name|curr_peer
operator|->
name|ttl
argument_list|,
name|curr_peer
operator|->
name|peerkey
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"*"
argument_list|)
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|res_bak
argument_list|)
expr_stmt|;
block|}
name|curr_peer
operator|=
name|next_node
argument_list|(
name|curr_peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_peers
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|peer_node
modifier|*
name|curr_peer
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|curr_peer
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|peers
argument_list|)
operator|)
condition|)
block|{
name|destroy_address_node
argument_list|(
name|curr_peer
operator|->
name|addr
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|curr_peer
operator|->
name|peerflags
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|curr_peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_unpeers
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|res
decl_stmt|,
modifier|*
name|res_bak
decl_stmt|;
name|sockaddr_u
name|peeraddr
decl_stmt|;
name|struct
name|unpeer_node
modifier|*
name|curr_unpeer
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|found
decl_stmt|;
for|for
control|(
name|curr_unpeer
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|unpeers
argument_list|)
init|;
name|curr_unpeer
operator|!=
name|NULL
condition|;
name|curr_unpeer
operator|=
name|next_node
argument_list|(
name|curr_unpeer
argument_list|)
control|)
block|{
comment|/* 		 * Either AssocID will be zero, and we unpeer by name/ 		 * address addr, or it is nonzero and addr NULL. 		 */
if|if
condition|(
name|curr_unpeer
operator|->
name|assocID
condition|)
block|{
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
operator|(
name|u_int
operator|)
name|curr_unpeer
operator|->
name|assocID
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"GONE"
argument_list|)
expr_stmt|;
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Attempt to resolve the name or address */
name|ZERO_SOCK
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|=
operator|(
name|u_short
operator|)
name|curr_unpeer
operator|->
name|addr
operator|->
name|type
expr_stmt|;
name|status
operator|=
name|get_multiple_netnums
argument_list|(
name|curr_unpeer
operator|->
name|addr
operator|->
name|address
argument_list|,
operator|&
name|peeraddr
argument_list|,
operator|&
name|res
argument_list|,
literal|0
argument_list|,
name|t_UNK
argument_list|)
expr_stmt|;
comment|/* I don't know why getnetnum would return -1. 		 * The old code had this test, so I guess it must be 		 * useful 		 */
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Do nothing, apparently we found an IPv6 			 * address and can't do anything about it */
block|}
comment|/* Check if name resolution failed. If yes, throw 		 * up our hands. 		 */
elseif|else
if|if
condition|(
name|status
operator|!=
literal|1
condition|)
block|{
comment|/* Do nothing */
block|}
comment|/* Yippie!! Name resolution has succeeded!!! 		 */
else|else
block|{
name|res_bak
operator|=
name|res
expr_stmt|;
comment|/* 			 * Loop through the addresses found 			 */
while|while
condition|(
name|res
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|peer
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"searching for %s\n"
operator|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|found
condition|)
block|{
name|peer
operator|=
name|findexistingpeer
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|peer
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|peer
condition|)
break|break;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"GONE"
argument_list|)
expr_stmt|;
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|res
operator|->
name|ai_next
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|res_bak
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_unpeers
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|struct
name|unpeer_node
modifier|*
name|curr_unpeer
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|curr_unpeer
operator|=
name|dequeue
argument_list|(
name|ptree
operator|->
name|unpeers
argument_list|)
operator|)
condition|)
block|{
name|destroy_address_node
argument_list|(
name|curr_unpeer
operator|->
name|addr
argument_list|)
expr_stmt|;
name|free_node
argument_list|(
name|curr_unpeer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function
specifier|static
name|void
name|config_sim
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|server_info
modifier|*
name|serv_info
decl_stmt|;
name|struct
name|attr_val
modifier|*
name|init_stmt
decl_stmt|;
comment|/* Check if a simulate block was found in the configuration code. 	 * If not, return an error and exit 	 */
if|if
condition|(
name|NULL
operator|==
name|ptree
operator|->
name|sim_details
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR!! I couldn't find a \"simulate\" block for configuring the simulator.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tCheck your configuration file.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Process the initialization statements 	 * ------------------------------------- 	 */
name|init_stmt
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|sim_details
operator|->
name|init_opts
argument_list|)
expr_stmt|;
while|while
condition|(
name|init_stmt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|init_stmt
operator|->
name|attr
condition|)
block|{
case|case
name|T_Beep_Delay
case|:
name|simulation
operator|.
name|beep_delay
operator|=
name|init_stmt
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Sim_Duration
case|:
name|simulation
operator|.
name|end_time
operator|=
name|init_stmt
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown simulator init token %d\n"
argument_list|,
name|init_stmt
operator|->
name|attr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|init_stmt
operator|=
name|next_node
argument_list|(
name|init_stmt
argument_list|)
expr_stmt|;
block|}
comment|/* Process the server list 	 * ----------------------- 	 */
name|simulation
operator|.
name|num_of_servers
operator|=
name|get_no_of_elements
argument_list|(
name|ptree
operator|->
name|sim_details
operator|->
name|servers
argument_list|)
expr_stmt|;
name|simulation
operator|.
name|servers
operator|=
name|emalloc
argument_list|(
name|simulation
operator|.
name|num_of_servers
operator|*
sizeof|sizeof
argument_list|(
name|server_info
argument_list|)
argument_list|)
expr_stmt|;
name|serv_info
operator|=
name|queue_head
argument_list|(
name|ptree
operator|->
name|sim_details
operator|->
name|servers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|simulation
operator|.
name|num_of_servers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|==
name|serv_info
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Simulator server list is corrupt\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
operator|&
name|simulation
operator|.
name|servers
index|[
name|i
index|]
argument_list|,
name|serv_info
argument_list|,
sizeof|sizeof
argument_list|(
name|server_info
argument_list|)
argument_list|)
expr_stmt|;
name|serv_info
operator|=
name|next_node
argument_list|(
name|serv_info
argument_list|)
expr_stmt|;
block|}
comment|/* Create server associations */
name|printf
argument_list|(
literal|"Creating server associations\n"
argument_list|)
expr_stmt|;
name|create_server_associations
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tServer associations successfully created!!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_sim
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|ptree
operator|->
name|sim_details
condition|)
return|return;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|sim_details
operator|->
name|init_opts
argument_list|)
expr_stmt|;
name|DESTROY_QUEUE
argument_list|(
name|ptree
operator|->
name|sim_details
operator|->
name|servers
argument_list|)
expr_stmt|;
comment|/* Free the sim_node memory and set the sim_details as NULL */
name|free_node
argument_list|(
name|ptree
operator|->
name|sim_details
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|sim_details
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIM */
end_comment

begin_comment
comment|/* Define two different config functions. One for the daemon and the other for  * the simulator. The simulator ignores a lot of the standard ntpd configuration  * options  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_ntpd
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|config_nic_rules
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|io_open_sockets
argument_list|()
expr_stmt|;
name|config_monitor
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_auth
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_tos
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_access
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_tinker
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_system_opts
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_logconfig
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_phone
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_setvar
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_ttl
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_trap
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_vars
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_other_modes
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_peers
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_unpeers
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_fudge
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_qos
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function
specifier|static
name|void
name|config_ntpdsim
parameter_list|(
name|struct
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Configuring Simulator...\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Some ntpd-specific commands in the configuration file will be ignored.\n"
argument_list|)
expr_stmt|;
name|config_tos
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_monitor
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_tinker
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_system_opts
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_logconfig
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_vars
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_sim
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIM */
end_comment

begin_comment
comment|/*  * config_remotely() - implements ntpd side of ntpq :config  */
end_comment

begin_function
name|void
name|config_remotely
parameter_list|(
name|sockaddr_u
modifier|*
name|remote_addr
parameter_list|)
block|{
name|struct
name|FILE_INFO
name|remote_cuckoo
decl_stmt|;
name|char
name|origin
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|,
literal|"remote config from %s"
argument_list|,
name|stoa
argument_list|(
name|remote_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|remote_cuckoo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_cuckoo
argument_list|)
argument_list|)
expr_stmt|;
name|remote_cuckoo
operator|.
name|fname
operator|=
name|origin
expr_stmt|;
name|remote_cuckoo
operator|.
name|line_no
operator|=
literal|1
expr_stmt|;
name|remote_cuckoo
operator|.
name|col_no
operator|=
literal|1
expr_stmt|;
name|ip_file
operator|=
operator|&
name|remote_cuckoo
expr_stmt|;
name|input_from_file
operator|=
literal|0
expr_stmt|;
name|init_syntax_tree
argument_list|(
operator|&
name|cfgt
argument_list|)
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|cfgt
operator|.
name|source
operator|.
name|attr
operator|=
name|CONF_SOURCE_NTPQ
expr_stmt|;
name|cfgt
operator|.
name|timestamp
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|cfgt
operator|.
name|source
operator|.
name|value
operator|.
name|s
operator|=
name|estrdup
argument_list|(
name|stoa
argument_list|(
name|remote_addr
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Finished Parsing!!\n"
operator|)
argument_list|)
expr_stmt|;
name|save_and_apply_config_tree
argument_list|()
expr_stmt|;
name|input_from_file
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * getconfig() - process startup configuration file e.g /etc/ntp.conf  */
end_comment

begin_function
name|void
name|getconfig
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|line
index|[
name|MAXLINE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
name|free_all_config_trees
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SYS_WINNT
name|config_file
operator|=
name|CONFIG_FILE
expr_stmt|;
else|#
directive|else
name|temp
operator|=
name|CONFIG_FILE
expr_stmt|;
if|if
condition|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
operator|(
name|LPCTSTR
operator|)
name|temp
argument_list|,
operator|(
name|LPTSTR
operator|)
name|config_file_storage
argument_list|,
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|config_file_storage
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings CONFIG_FILE failed: %m\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|config_file
operator|=
name|config_file_storage
expr_stmt|;
name|temp
operator|=
name|ALT_CONFIG_FILE
expr_stmt|;
if|if
condition|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
operator|(
name|LPCTSTR
operator|)
name|temp
argument_list|,
operator|(
name|LPTSTR
operator|)
name|alt_config_file_storage
argument_list|,
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|alt_config_file_storage
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings ALT_CONFIG_FILE failed: %m\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|alt_config_file
operator|=
name|alt_config_file_storage
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
name|res_fp
operator|=
name|NULL
expr_stmt|;
name|ntp_syslogmask
operator|=
name|NLOG_SYNCMASK
expr_stmt|;
comment|/* set more via logconfig */
comment|/* 	 * install a non default variable with this daemon version 	 */
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"daemon_version=\"%s\""
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
expr_stmt|;
comment|/* 	 * Set up for the first time step to install a variable showing 	 * which syscall is being used to step. 	 */
name|set_tod_using
operator|=
operator|&
name|ntpd_set_tod_using
expr_stmt|;
comment|/* 	 * On Windows, the variable has already been set, on the rest, 	 * initialize it to "UNKNOWN". 	 */
ifndef|#
directive|ifndef
name|SYS_WINNT
name|strncpy
argument_list|(
name|line
argument_list|,
literal|"settimeofday=\"UNKNOWN\""
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize the loop. 	 */
name|loop_config
argument_list|(
name|LOOP_DRIFTINIT
argument_list|,
literal|0.
argument_list|)
expr_stmt|;
name|getCmdOpts
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|init_syntax_tree
argument_list|(
operator|&
name|cfgt
argument_list|)
expr_stmt|;
name|curr_include_level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fp
index|[
name|curr_include_level
index|]
operator|=
name|F_OPEN
argument_list|(
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
ifdef|#
directive|ifdef
name|HAVE_NETINFO
comment|/* If there is no config_file, try NetInfo. */
operator|&&
name|check_netinfo
operator|&&
operator|!
operator|(
name|config_netinfo
operator|=
name|get_netinfo_config
argument_list|()
operator|)
endif|#
directive|endif
comment|/* HAVE_NETINFO */
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
name|io_open_sockets
argument_list|()
expr_stmt|;
return|return;
else|#
directive|else
comment|/* Under WinNT try alternate_config_file name, first NTP.CONF, then NTP.INI */
if|if
condition|(
operator|(
name|fp
index|[
name|curr_include_level
index|]
operator|=
name|F_OPEN
argument_list|(
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Broadcast clients can sometimes run without 			 * a configuration file. 			 */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|)
expr_stmt|;
name|io_open_sockets
argument_list|()
expr_stmt|;
return|return;
block|}
name|cfgt
operator|.
name|source
operator|.
name|value
operator|.
name|s
operator|=
name|estrdup
argument_list|(
name|alt_config_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
else|else
name|cfgt
operator|.
name|source
operator|.
name|value
operator|.
name|s
operator|=
name|estrdup
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
comment|/*** BULK OF THE PARSER ***/
ifdef|#
directive|ifdef
name|DEBUG
name|yydebug
operator|=
operator|!
operator|!
operator|(
name|debug
operator|>=
literal|5
operator|)
expr_stmt|;
endif|#
directive|endif
name|ip_file
operator|=
name|fp
index|[
name|curr_include_level
index|]
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Finished Parsing!!\n"
operator|)
argument_list|)
expr_stmt|;
name|cfgt
operator|.
name|source
operator|.
name|attr
operator|=
name|CONF_SOURCE_FILE
expr_stmt|;
name|cfgt
operator|.
name|timestamp
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|save_and_apply_config_tree
argument_list|()
expr_stmt|;
while|while
condition|(
name|curr_include_level
operator|!=
operator|-
literal|1
condition|)
name|FCLOSE
argument_list|(
name|fp
index|[
name|curr_include_level
operator|--
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NETINFO
if|if
condition|(
name|config_netinfo
condition|)
name|free_netinfo_config
argument_list|(
name|config_netinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NETINFO */
comment|/* 	printf("getconfig: res_fp<%p> call_resolver: %d", res_fp, call_resolver); 	*/
if|if
condition|(
name|res_fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|call_resolver
condition|)
block|{
comment|/* 			 * Need name resolution 			 */
name|do_resolve_internal
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|save_and_apply_config_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|config_tree
modifier|*
name|ptree
decl_stmt|;
ifndef|#
directive|ifndef
name|SAVECONFIG
name|struct
name|config_tree
modifier|*
name|punlinked
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Keep all the configuration trees applied since startup in 	 * a list that can be used to dump the configuration back to 	 * a text file. 	 */
name|ptree
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ptree
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptree
argument_list|,
operator|&
name|cfgt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ptree
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cfgt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfgt
argument_list|)
argument_list|)
expr_stmt|;
name|LINK_TAIL_SLIST
argument_list|(
name|cfg_tree_history
argument_list|,
name|ptree
argument_list|,
name|link
argument_list|,
expr|struct
name|config_tree
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVECONFIG
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|dumpfailed
decl_stmt|;
name|dumpfile
operator|=
name|fopen
argument_list|(
name|OPT_ARG
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|dumpfile
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can not create save file %s, error %d %s\n"
argument_list|,
name|OPT_ARG
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
argument_list|,
name|err
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|dumpfailed
operator|=
name|dump_all_config_trees
argument_list|(
name|dumpfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumpfailed
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--saveconfigquit %s error %d\n"
argument_list|,
name|OPT_ARG
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
argument_list|,
name|dumpfailed
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"configuration saved to %s\n"
argument_list|,
name|OPT_ARG
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|dumpfailed
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SAVECONFIG */
comment|/* The actual configuration done depends on whether we are configuring the 	 * simulator or the daemon. Perform a check and call the appropriate 	 * function as needed. 	 */
ifndef|#
directive|ifndef
name|SIM
name|config_ntpd
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
else|#
directive|else
name|config_ntpdsim
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * With configure --disable-saveconfig, there's no use keeping 	 * the config tree around after application, so free it. 	 */
ifndef|#
directive|ifndef
name|SAVECONFIG
name|UNLINK_SLIST
argument_list|(
name|punlinked
argument_list|,
name|cfg_tree_history
argument_list|,
name|ptree
argument_list|,
name|link
argument_list|,
expr|struct
name|config_tree
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|punlinked
operator|==
name|ptree
argument_list|)
expr_stmt|;
name|free_config_tree
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ntpd_set_tod_using
parameter_list|(
specifier|const
name|char
modifier|*
name|which
parameter_list|)
block|{
name|char
name|line
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"settimeofday=\"%s\""
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTIONS COPIED FROM THE OLDER ntp_config.c  * --------------------------------------------  */
end_comment

begin_comment
comment|/*  * get_pfxmatch - find value for prefixmatch  * and update char * accordingly  */
end_comment

begin_function
specifier|static
name|u_int32
name|get_pfxmatch
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pstr
parameter_list|,
name|struct
name|masks
modifier|*
name|m
parameter_list|)
block|{
while|while
condition|(
name|m
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|pstr
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|m
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pstr
operator|+=
name|strlen
argument_list|(
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|m
operator|->
name|mask
return|;
block|}
else|else
block|{
name|m
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_match - find logmask value  */
end_comment

begin_function
specifier|static
name|u_int32
name|get_match
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|masks
modifier|*
name|m
parameter_list|)
block|{
while|while
condition|(
name|m
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|m
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|m
operator|->
name|mask
return|;
else|else
name|m
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_logmask - build bitmask for ntp_syslogmask  */
end_comment

begin_function
specifier|static
name|u_int32
name|get_logmask
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
name|u_int32
name|offset
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
name|mask
operator|=
name|get_match
argument_list|(
name|str
argument_list|,
name|logcfg_noclass_items
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
return|return
name|mask
return|;
name|t
operator|=
name|str
expr_stmt|;
name|offset
operator|=
name|get_pfxmatch
argument_list|(
operator|&
name|t
argument_list|,
name|logcfg_class
argument_list|)
expr_stmt|;
name|mask
operator|=
name|get_match
argument_list|(
name|t
argument_list|,
name|logcfg_class_items
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
return|return
name|mask
operator|<<
name|offset
return|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"logconfig: '%s' not recognized - ignored"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_comment
comment|/*  * get_netinfo_config - find the nearest NetInfo domain with an ntp  * configuration and initialize the configuration state.  */
end_comment

begin_function
specifier|static
name|struct
name|netinfo_config_state
modifier|*
name|get_netinfo_config
parameter_list|(
name|void
parameter_list|)
block|{
name|ni_status
name|status
decl_stmt|;
name|void
modifier|*
name|domain
decl_stmt|;
name|ni_id
name|config_dir
decl_stmt|;
name|struct
name|netinfo_config_state
modifier|*
name|config
decl_stmt|;
if|if
condition|(
name|ni_open
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|,
operator|&
name|domain
argument_list|)
operator|!=
name|NI_OK
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|(
name|status
operator|=
name|ni_pathsearch
argument_list|(
name|domain
argument_list|,
operator|&
name|config_dir
argument_list|,
name|NETINFO_CONFIG_DIR
argument_list|)
operator|)
operator|==
name|NI_NODIR
condition|)
block|{
name|void
modifier|*
name|next_domain
decl_stmt|;
if|if
condition|(
name|ni_open
argument_list|(
name|domain
argument_list|,
literal|".."
argument_list|,
operator|&
name|next_domain
argument_list|)
operator|!=
name|NI_OK
condition|)
block|{
name|ni_free
argument_list|(
name|next_domain
argument_list|)
expr_stmt|;
break|break;
block|}
name|ni_free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|domain
operator|=
name|next_domain
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|NI_OK
condition|)
block|{
name|ni_free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|config
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
name|config
operator|->
name|config_dir
operator|=
name|config_dir
expr_stmt|;
name|config
operator|->
name|prop_index
operator|=
literal|0
expr_stmt|;
name|config
operator|->
name|val_index
operator|=
literal|0
expr_stmt|;
name|config
operator|->
name|val_list
operator|=
name|NULL
expr_stmt|;
return|return
name|config
return|;
block|}
end_function

begin_comment
comment|/*  * free_netinfo_config - release NetInfo configuration state  */
end_comment

begin_function
specifier|static
name|void
name|free_netinfo_config
parameter_list|(
name|struct
name|netinfo_config_state
modifier|*
name|config
parameter_list|)
block|{
name|ni_free
argument_list|(
name|config
operator|->
name|domain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * gettokens_netinfo - return tokens from NetInfo  */
end_comment

begin_function
specifier|static
name|int
name|gettokens_netinfo
parameter_list|(
name|struct
name|netinfo_config_state
modifier|*
name|config
parameter_list|,
name|char
modifier|*
modifier|*
name|tokenlist
parameter_list|,
name|int
modifier|*
name|ntokens
parameter_list|)
block|{
name|int
name|prop_index
init|=
name|config
operator|->
name|prop_index
decl_stmt|;
name|int
name|val_index
init|=
name|config
operator|->
name|val_index
decl_stmt|;
name|char
modifier|*
modifier|*
name|val_list
init|=
name|config
operator|->
name|val_list
decl_stmt|;
comment|/* 	 * Iterate through each keyword and look for a property that matches it. 	 */
name|again
label|:
if|if
condition|(
operator|!
name|val_list
condition|)
block|{
for|for
control|(
init|;
name|prop_index
operator|<
name|COUNTOF
argument_list|(
name|keywords
argument_list|)
condition|;
name|prop_index
operator|++
control|)
block|{
name|ni_namelist
name|namelist
decl_stmt|;
name|struct
name|keyword
name|current_prop
init|=
name|keywords
index|[
name|prop_index
index|]
decl_stmt|;
name|ni_index
name|index
decl_stmt|;
comment|/* 			 * For each value associated in the property, we're going to return 			 * a separate line. We squirrel away the values in the config state 			 * so the next time through, we don't need to do this lookup. 			 */
name|NI_INIT
argument_list|(
operator|&
name|namelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|NI_OK
operator|==
name|ni_lookupprop
argument_list|(
name|config
operator|->
name|domain
argument_list|,
operator|&
name|config
operator|->
name|config_dir
argument_list|,
name|current_prop
operator|.
name|text
argument_list|,
operator|&
name|namelist
argument_list|)
condition|)
block|{
comment|/* Found the property, but it has no values */
if|if
condition|(
name|namelist
operator|.
name|ni_namelist_len
operator|==
literal|0
condition|)
continue|continue;
name|config
operator|->
name|val_list
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|namelist
operator|.
name|ni_namelist_len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|val_list
operator|=
name|config
operator|->
name|val_list
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|namelist
operator|.
name|ni_namelist_len
condition|;
name|index
operator|++
control|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|namelist
operator|.
name|ni_namelist_val
index|[
name|index
index|]
expr_stmt|;
name|val_list
index|[
name|index
index|]
operator|=
name|estrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|val_list
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|ni_namelist_free
argument_list|(
operator|&
name|namelist
argument_list|)
expr_stmt|;
block|}
name|config
operator|->
name|prop_index
operator|=
name|prop_index
expr_stmt|;
block|}
comment|/* No list; we're done here. */
if|if
condition|(
operator|!
name|val_list
condition|)
return|return
name|CONFIG_UNKNOWN
return|;
comment|/* 	 * We have a list of values for the current property. 	 * Iterate through them and return each in order. 	 */
if|if
condition|(
name|val_list
index|[
name|val_index
index|]
condition|)
block|{
name|int
name|ntok
init|=
literal|1
decl_stmt|;
name|int
name|quoted
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tokens
init|=
name|val_list
index|[
name|val_index
index|]
decl_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s %s"
argument_list|,
name|keywords
index|[
name|prop_index
index|]
operator|.
name|text
argument_list|,
name|val_list
index|[
name|val_index
index|]
argument_list|)
expr_stmt|;
operator|(
specifier|const
name|char
operator|*
operator|)
name|tokenlist
index|[
literal|0
index|]
operator|=
name|keywords
index|[
name|prop_index
index|]
operator|.
name|text
expr_stmt|;
for|for
control|(
name|ntok
operator|=
literal|1
init|;
name|ntok
operator|<
name|MAXTOKENS
condition|;
name|ntok
operator|++
control|)
block|{
name|tokenlist
index|[
name|ntok
index|]
operator|=
name|tokens
expr_stmt|;
while|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|tokens
argument_list|)
operator|||
name|quoted
operator|)
condition|)
name|quoted
operator|^=
operator|(
operator|*
name|tokens
operator|++
operator|==
literal|'"'
operator|)
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
block|{
operator|*
name|tokens
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* must be space */
operator|*
name|tokens
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
name|tokens
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|ntok
operator|==
name|MAXTOKENS
condition|)
block|{
comment|/* HMS: chomp it to lose the EOL? */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettokens_netinfo: too many tokens.  Ignoring: %s"
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ntokens
operator|=
name|ntok
operator|+
literal|1
expr_stmt|;
block|}
name|config
operator|->
name|val_index
operator|++
expr_stmt|;
comment|/* HMS: Should this be in the 'else'? */
return|return
name|keywords
index|[
name|prop_index
index|]
operator|.
name|keytype
return|;
block|}
comment|/* We're done with the current property. */
name|prop_index
operator|=
operator|++
name|config
operator|->
name|prop_index
expr_stmt|;
comment|/* Free val_list and reset counters. */
for|for
control|(
name|val_index
operator|=
literal|0
init|;
name|val_list
index|[
name|val_index
index|]
condition|;
name|val_index
operator|++
control|)
name|free
argument_list|(
name|val_list
index|[
name|val_index
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val_list
argument_list|)
expr_stmt|;
name|val_list
operator|=
name|config
operator|->
name|val_list
operator|=
name|NULL
expr_stmt|;
name|val_index
operator|=
name|config
operator|->
name|val_index
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_comment
comment|/*  * getnetnum - return a net number (this is crude, but careful)  *  * returns 1 for success, and mysteriously, 0 or -1 for failure  */
end_comment

begin_function
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|num
parameter_list|,
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|int
name|complain
parameter_list|,
name|enum
name|gnn_type
name|a_type
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|res
decl_stmt|;
comment|/* Get all the addresses that resolve to this name */
name|retval
operator|=
name|get_multiple_netnums
argument_list|(
name|num
argument_list|,
name|addr
argument_list|,
operator|&
name|res
argument_list|,
name|complain
argument_list|,
name|a_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|1
condition|)
block|{
comment|/* Name resolution failed */
return|return
name|retval
return|;
block|}
name|memcpy
argument_list|(
name|addr
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"getnetnum given %s, got %s\n"
operator|,
name|num
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * get_multiple_netnums  *  * returns 1 for success, and mysteriously, 0 or -1 for failure  */
end_comment

begin_function
specifier|static
name|int
name|get_multiple_netnums
parameter_list|(
specifier|const
name|char
modifier|*
name|nameornum
parameter_list|,
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|,
name|int
name|complain
parameter_list|,
name|enum
name|gnn_type
name|a_type
parameter_list|)
block|{
name|char
name|lookbuf
index|[
literal|1024
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|lookup
decl_stmt|;
name|char
modifier|*
name|pch
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ptr
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|sockaddr_u
name|ipaddr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|nameornum
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|lookbuf
argument_list|)
condition|)
block|{
name|NTP_INSIST
argument_list|(
name|strlen
argument_list|(
name|nameornum
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|lookbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lookup
operator|=
name|nameornum
expr_stmt|;
if|if
condition|(
name|is_ip_address
argument_list|(
name|nameornum
argument_list|,
operator|&
name|ipaddr
argument_list|)
condition|)
block|{
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF
argument_list|(
operator|&
name|ipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'['
operator|==
name|nameornum
index|[
literal|0
index|]
condition|)
block|{
name|lookup
operator|=
name|lookbuf
expr_stmt|;
name|strncpy
argument_list|(
name|lookbuf
argument_list|,
operator|&
name|nameornum
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|lookbuf
argument_list|)
argument_list|)
expr_stmt|;
name|pch
operator|=
name|strchr
argument_list|(
name|lookbuf
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch
operator|!=
name|NULL
condition|)
operator|*
name|pch
operator|=
literal|'\0'
expr_stmt|;
block|}
name|pch
operator|=
name|strchr
argument_list|(
name|lookup
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lookup
operator|!=
name|lookbuf
condition|)
block|{
name|lookup
operator|=
name|lookbuf
expr_stmt|;
name|strncpy
argument_list|(
name|lookbuf
argument_list|,
name|nameornum
argument_list|,
sizeof|sizeof
argument_list|(
name|lookbuf
argument_list|)
argument_list|)
expr_stmt|;
name|pch
operator|=
name|strchr
argument_list|(
name|lookup
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
block|}
operator|*
name|pch
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|AF_INET6
operator|==
name|hints
operator|.
name|ai_family
operator|&&
operator|!
name|ipv6_works
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|AF_UNSPEC
operator|==
name|hints
operator|.
name|ai_family
condition|)
block|{
if|if
condition|(
operator|!
name|ipv6_works
condition|)
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ipv4_works
condition|)
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_IPV4
argument_list|(
name|addr
argument_list|)
operator|||
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
condition|)
name|hints
operator|.
name|ai_family
operator|=
name|AF
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* Get host address. Looking for UDP datagram connection */
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"getaddrinfo %s%s\n"
operator|,
operator|(
name|AF_UNSPEC
operator|==
name|hints
operator|.
name|ai_family
operator|)
condition|?
literal|""
else|:
operator|(
name|AF_INET
operator|==
name|hints
operator|.
name|ai_family
operator|)
condition|?
literal|"v4 "
else|:
literal|"v6 "
operator|,
name|lookup
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|getaddrinfo
argument_list|(
name|lookup
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|||
operator|(
name|AF_INET6
operator|==
name|ptr
operator|->
name|ai_family
operator|&&
operator|!
name|ipv6_works
operator|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getaddrinfo: \"%s\" invalid host address, ignored"
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"getaddrinfo: \"%s\" invalid host address.\n"
operator|,
name|lookup
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
operator|*
name|res
operator|=
name|ptr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_comment
comment|/*  * catchchild - receive the resolver's exit status  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|catchchild
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
comment|/* 	 * We only start up one child, and if we're here 	 * it should have already exited.  Hence the following 	 * shouldn't hang.  If it does, please tell me. 	 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
operator|(
name|void
operator|)
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT&& VXWORKS*/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/*  * save_resolve - save configuration info into a file for later name resolution  */
end_comment

begin_function
specifier|static
name|void
name|save_resolve
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|no_needed
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|minpoll
parameter_list|,
name|int
name|maxpoll
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int
name|ttl
parameter_list|,
name|keyid_t
name|keyid
parameter_list|,
name|u_char
modifier|*
name|keystr
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SYS_VXWORKS
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
name|strcpy
argument_list|(
name|res_file
argument_list|,
name|RES_TEMPFILE
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|len
decl_stmt|;
comment|/* no /tmp directory under NT */
if|if
condition|(
operator|!
name|GetTempPath
argument_list|(
sizeof|sizeof
name|res_file
argument_list|,
name|res_file
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can not get temp dir: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
name|res_file
operator|<
name|len
operator|+
sizeof|sizeof
expr|"ntpdXXXXXX"
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"temporary directory path %s too long"
argument_list|,
name|res_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
name|res_file
operator|+
name|len
argument_list|,
literal|"ntpdXXXXXX"
argument_list|,
sizeof|sizeof
expr|"ntpdXXXXXX"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
ifdef|#
directive|ifdef
name|HAVE_MKSTEMP
block|{
name|int
name|fd
decl_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|res_file
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|res_fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|mktemp
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|fopen
argument_list|(
name|res_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open failed for %s: %m"
argument_list|,
name|res_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"resolving %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|res_fp
argument_list|,
literal|"%s %d %d %d %d %d %d %d %d %u %s\n"
argument_list|,
name|name
argument_list|,
name|no_needed
argument_list|,
name|type
argument_list|,
name|mode
argument_list|,
name|version
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|flags
argument_list|,
name|ttl
argument_list|,
name|keyid
argument_list|,
name|keystr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"config: %s %d %d %d %d %d %d %x %d %u %s\n"
argument_list|,
name|name
argument_list|,
name|no_needed
argument_list|,
name|type
argument_list|,
name|mode
argument_list|,
name|version
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|flags
argument_list|,
name|ttl
argument_list|,
name|keyid
argument_list|,
name|keystr
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* SYS_VXWORKS */
comment|/* save resolve info to a struct */
endif|#
directive|endif
comment|/* SYS_VXWORKS */
block|}
end_function

begin_comment
comment|/*  * abort_resolve - terminate the resolver stuff and delete the file  */
end_comment

begin_function
specifier|static
name|void
name|abort_resolve
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * In an ideal world we would might reread the file and 	 * log the hosts which aren't getting configured.  Since 	 * this is too much work, however, just close and delete 	 * the temp file. 	 */
if|if
condition|(
name|res_fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|res_fp
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_VXWORKS
comment|/* we don't open the file to begin with */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
if|if
condition|(
name|unlink
argument_list|(
name|res_file
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Unable to remove temporary resolver file %s, %m"
argument_list|,
name|res_file
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|delete
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* SYS_VXWORKS */
block|}
end_function

begin_comment
comment|/*  * do_resolve_internal - start up the resolver function (not program)  *  * On VMS, VxWorks, and Unix-like systems lacking fork(), this routine  * will simply refuse to resolve anything.  *  * Possible implementation: keep `res_file' in memory, do async  * name resolution via QIO, update from within completion AST.  * I'm unlikely to find the time for doing this, though. -wjm  */
end_comment

begin_function
specifier|static
name|void
name|do_resolve_internal
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
name|int
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
comment|/* belch */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"do_resolve_internal: Fatal: res_fp == NULL"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* we are done with this now */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|res_fp
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_INTRES
name|req_file
operator|=
name|res_file
expr_stmt|;
comment|/* set up pointer to res file */
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|catchchild
argument_list|)
expr_stmt|;
comment|/* the parent process will write to the pipe 	 * in order to wake up to child process 	 * which may be waiting in a select() call 	 * on the read fd */
if|if
condition|(
name|pipe
argument_list|(
name|resolver_pipe_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to open resolver pipe"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
comment|/* Shouldn't the code below be re-ordered? 	 * I.e. first check if the fork() returned an error, then 	 * check whether we're parent or child. 	 *     Martin Burnicki 	 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 		 * this used to close everything 		 * I don't think this is necessary 		 */
comment|/* 		 * To the unknown commenter above: 		 * Well, I think it's better to clean up 		 * after oneself. I have had problems with 		 * refclock-io when intres was running - things 		 * where fine again when ntpintres was gone. 		 * So some systems react erratic at least. 		 * 		 *			Frank Kardel 		 * 		 * 94-11-16: 		 * Further debugging has proven that the above is 		 * absolutely harmful. The internal resolver 		 * is still in the SIGIO process group and the lingering 		 * async io information causes it to process requests from 		 * all file decriptor causing a race between the NTP daemon 		 * and the resolver. which then eats data when it wins 8-(. 		 * It is absolutly necessary to kill any IO associations 		 * shared with the NTP daemon. 		 * 		 * We also block SIGIO (currently no ports means to 		 * disable the signal handle for IO). 		 * 		 * Thanks to wgstuken@informatik.uni-erlangen.de to notice 		 * that it is the ntp-resolver child running into trouble. 		 * 		 * THUS: 		 */
comment|/* 		msyslog(LOG_INFO, "do_resolve_internal: pre-closelog"); 		*/
name|closelog
argument_list|()
expr_stmt|;
name|kill_asyncio
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|init_logging
argument_list|(
literal|"ntpd_intres"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setup_logfile
argument_list|()
expr_stmt|;
comment|/* 		msyslog(LOG_INFO, "do_resolve_internal: post-closelog"); 		*/
name|ntp_intres
argument_list|()
expr_stmt|;
comment|/* 		 * If we got here, the intres code screwed up. 		 * Print something so we don't die without complaint 		 */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"call to ntp_intres lost"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork() failed, can't start ntp_intres: %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* This is the parent process who will write to the pipe, 		 * so we close the read fd */
name|close
argument_list|(
name|resolver_pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SYS_WINNT */
block|{
comment|/* NT's equivalent of fork() is _spawn(), but the start point 		 * of the new process is an executable filename rather than 		 * a function name as desired here. 		 */
name|unsigned
name|thread_id
decl_stmt|;
name|uintptr_t
name|res_thd_handle
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ResolverEventHandle
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResolverEventHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to create resolver event object, can't start ntp_intres"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
name|res_thd_handle
operator|=
name|_beginthreadex
argument_list|(
name|NULL
argument_list|,
comment|/* no security attributes	*/
literal|0
argument_list|,
comment|/* use default stack size	*/
name|ntp_intres_thread
argument_list|,
comment|/* thread function		*/
name|NULL
argument_list|,
comment|/* argument to thread function	*/
literal|0
argument_list|,
comment|/* use default creation flags	*/
operator|&
name|thread_id
argument_list|)
expr_stmt|;
comment|/* receives thread identifier	*/
if|if
condition|(
operator|!
name|res_thd_handle
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"_beginthreadex ntp_intres_thread failed %m"
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|ResolverEventHandle
argument_list|)
expr_stmt|;
name|ResolverEventHandle
operator|=
name|NULL
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
else|#
directive|else
comment|/* NO_INTRES follows */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Deferred DNS not implemented - use numeric addresses"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

