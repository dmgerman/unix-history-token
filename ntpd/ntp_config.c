begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntp_config.c  *  * This file contains the ntpd configuration code.  *  * Written By:	Sachin Kamboj  *		University of Delaware  *		Newark, DE 19711  * Some parts borrowed from the older ntp_config.c  * Copyright (c) 2006  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_include
include|#
directive|include
file|<netinfo/ni.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SIGCHLD
end_ifndef

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_filegen.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"lib_strbuf.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_random.h"
end_include

begin_comment
comment|/*  * [Bug 467]: Some linux headers collide with CONFIG_PHONE and CONFIG_KEYS  * so #include these later.  */
end_comment

begin_include
include|#
directive|include
file|"ntp_config.h"
end_include

begin_include
include|#
directive|include
file|"ntp_cmdargs.h"
end_include

begin_include
include|#
directive|include
file|"ntp_scanner.h"
end_include

begin_include
include|#
directive|include
file|"ntp_parser.h"
end_include

begin_include
include|#
directive|include
file|"ntpd-opts.h"
end_include

begin_comment
comment|/* Bison still(!) does not emit usable prototypes for the calling code */
end_comment

begin_function_decl
name|int
name|yyparse
parameter_list|(
name|struct
name|FILE_INFO
modifier|*
name|ip_file
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* list of servers from command line for config_peers() */
end_comment

begin_decl_stmt
name|int
name|cmdline_server_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|cmdline_servers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to zero if admin doesn't want memory locked */
end_comment

begin_decl_stmt
name|int
name|do_memlock
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "logconfig" building blocks  */
end_comment

begin_struct
struct|struct
name|masks
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|u_int32
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_class
index|[]
init|=
block|{
block|{
literal|"clock"
block|,
name|NLOG_OCLOCK
block|}
block|,
block|{
literal|"peer"
block|,
name|NLOG_OPEER
block|}
block|,
block|{
literal|"sync"
block|,
name|NLOG_OSYNC
block|}
block|,
block|{
literal|"sys"
block|,
name|NLOG_OSYS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logcfg_noclass_items[] masks are complete and must not be shifted */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_noclass_items
index|[]
init|=
block|{
block|{
literal|"allall"
block|,
name|NLOG_SYSMASK
operator||
name|NLOG_PEERMASK
operator||
name|NLOG_CLOCKMASK
operator||
name|NLOG_SYNCMASK
block|}
block|,
block|{
literal|"allinfo"
block|,
name|NLOG_SYSINFO
operator||
name|NLOG_PEERINFO
operator||
name|NLOG_CLOCKINFO
operator||
name|NLOG_SYNCINFO
block|}
block|,
block|{
literal|"allevents"
block|,
name|NLOG_SYSEVENT
operator||
name|NLOG_PEEREVENT
operator||
name|NLOG_CLOCKEVENT
operator||
name|NLOG_SYNCEVENT
block|}
block|,
block|{
literal|"allstatus"
block|,
name|NLOG_SYSSTATUS
operator||
name|NLOG_PEERSTATUS
operator||
name|NLOG_CLOCKSTATUS
operator||
name|NLOG_SYNCSTATUS
block|}
block|,
block|{
literal|"allstatistics"
block|,
name|NLOG_SYSSTATIST
operator||
name|NLOG_PEERSTATIST
operator||
name|NLOG_CLOCKSTATIST
operator||
name|NLOG_SYNCSTATIST
block|}
block|,
comment|/* the remainder are misspellings of clockall, peerall, sysall, and syncall. */
block|{
literal|"allclock"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OCLOCK
block|}
block|,
block|{
literal|"allpeer"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OPEER
block|}
block|,
block|{
literal|"allsys"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OSYS
block|}
block|,
block|{
literal|"allsync"
block|,
operator|(
name|NLOG_INFO
operator||
name|NLOG_STATIST
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator|)
operator|<<
name|NLOG_OSYNC
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logcfg_class_items[] masks are shiftable by NLOG_O* counts */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|masks
name|logcfg_class_items
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|NLOG_INFO
operator||
name|NLOG_EVENT
operator||
name|NLOG_STATUS
operator||
name|NLOG_STATIST
block|}
block|,
block|{
literal|"info"
block|,
name|NLOG_INFO
block|}
block|,
block|{
literal|"events"
block|,
name|NLOG_EVENT
block|}
block|,
block|{
literal|"status"
block|,
name|NLOG_STATUS
block|}
block|,
block|{
literal|"statistics"
block|,
name|NLOG_STATIST
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|peer_resolved_ctx_tag
block|{
name|int
name|flags
decl_stmt|;
name|int
name|host_mode
decl_stmt|;
comment|/* T_* token identifier */
name|u_short
name|family
decl_stmt|;
name|keyid_t
name|keyid
decl_stmt|;
name|u_char
name|hmode
decl_stmt|;
comment|/* MODE_* */
name|u_char
name|version
decl_stmt|;
name|u_char
name|minpoll
decl_stmt|;
name|u_char
name|maxpoll
decl_stmt|;
name|u_int32
name|ttl
decl_stmt|;
specifier|const
name|char
modifier|*
name|group
decl_stmt|;
block|}
name|peer_resolved_ctx
typedef|;
end_typedef

begin_comment
comment|/* Limits */
end_comment

begin_define
define|#
directive|define
name|MAXPHONE
value|10
end_define

begin_comment
comment|/* maximum number of phone strings */
end_comment

begin_define
define|#
directive|define
name|MAXPPS
value|20
end_define

begin_comment
comment|/* maximum length of PPS device string */
end_comment

begin_comment
comment|/*  * Miscellaneous macros  */
end_comment

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '#' || (c) == '\n' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_comment
comment|/*  * Definitions of things either imported from or exported to outside  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ntp_parser.c (.y) */
end_comment

begin_decl_stmt
name|int
name|curr_include_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current include level */
end_comment

begin_decl_stmt
name|struct
name|FILE_INFO
modifier|*
name|fp
index|[
name|MAXINCLUDELEVEL
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|config_tree
name|cfgt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parser output stored here */
end_comment

begin_decl_stmt
name|struct
name|config_tree_tag
modifier|*
name|cfg_tree_history
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* History of configs */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sys_phone
index|[
name|MAXPHONE
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ACTS phone numbers */
end_comment

begin_decl_stmt
name|char
name|default_keysdir
index|[]
init|=
name|NTP_KEYSDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|keysdir
init|=
name|default_keysdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crypto keys directory */
end_comment

begin_decl_stmt
name|char
modifier|*
name|saveconfigdir
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SCHED_SETSCHEDULER
argument_list|)
end_if

begin_decl_stmt
name|int
name|config_priority_override
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|config_priority
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|config_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|default_ntp_signd_socket
index|[]
init|=
ifdef|#
directive|ifdef
name|NTP_SIGND_PATH
name|NTP_SIGND_PATH
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|""
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|ntp_signd_socket
init|=
name|default_ntp_signd_socket
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_decl_stmt
name|struct
name|netinfo_config_state
modifier|*
name|config_netinfo
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|check_netinfo
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|alt_config_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LPTSTR
name|temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|config_file_storage
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|alt_config_file_storage
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_comment
comment|/*  * NetInfo configuration state  */
end_comment

begin_struct
struct|struct
name|netinfo_config_state
block|{
name|void
modifier|*
name|domain
decl_stmt|;
comment|/* domain with config */
name|ni_id
name|config_dir
decl_stmt|;
comment|/* ID config dir      */
name|int
name|prop_index
decl_stmt|;
comment|/* current property   */
name|int
name|val_index
decl_stmt|;
comment|/* current value      */
name|char
modifier|*
modifier|*
name|val_list
decl_stmt|;
comment|/* value list         */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|REMOTE_CONFIG_INFO
name|remote_config
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remote configuration buffer and 					     pointer info */
end_comment

begin_decl_stmt
name|int
name|input_from_file
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A boolean flag, which when set, indicates that 			        the input is to be taken from the configuration 			        file, instead of the remote-configuration buffer 			     */
end_comment

begin_decl_stmt
name|int
name|old_config_style
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A boolean flag, which when set, 			      * indicates that the old configuration 			      * format with a newline at the end of 			      * every command is being used 			      */
end_comment

begin_decl_stmt
name|int
name|cryptosw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crypto command called */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|stats_drift_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the driftfile */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BC_LIST_FRAMEWORK_NOT_YET_USED
end_ifdef

begin_comment
comment|/*  * backwards compatibility flags  */
end_comment

begin_decl_stmt
name|bc_entry
name|bc_list
index|[]
init|=
block|{
block|{
name|T_Bc_bugXXXX
block|,
literal|1
block|}
comment|/* default enabled */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * declare an int pointer for each flag for quick testing without  * walking bc_list.  If the pointer is consumed by libntp rather  * than ntpd, declare it in a libntp source file pointing to storage  * initialized with the appropriate value for other libntp clients, and  * redirect it to point into bc_list during ntpd startup.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|p_bcXXXX_enabled
init|=
operator|&
name|bc_list
index|[
literal|0
index|]
operator|.
name|enabled
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FUNCTION PROTOTYPES */
end_comment

begin_function_decl
specifier|static
name|void
name|init_syntax_tree
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|apply_enable_disable
parameter_list|(
name|attr_val_fifo
modifier|*
name|q
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_auth_node
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_all_config_trees
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_access
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_auth
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_fudge
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_logconfig
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_monitor
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_nic_rules
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_other_modes
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_peers
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_phone
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_reset_counters
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_rlimit
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_setvar
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_system_opts
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_tinker
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_tos
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_trap
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_ttl
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_unpeers
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_config_vars
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_config_sim
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|destroy_address_fifo
parameter_list|(
name|address_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FREE_ADDRESS_FIFO
parameter_list|(
name|pf
parameter_list|)
define|\
value|do {					\ 		destroy_address_fifo(pf);	\ 		(pf) = NULL;			\ 	} while (0)
end_define

begin_function_decl
name|void
name|free_all_config_trees
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* atexit() */
end_comment

begin_function_decl
specifier|static
name|void
name|free_config_tree
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function_decl
specifier|static
name|void
name|destroy_restrict_node
parameter_list|(
name|restrict_node
modifier|*
name|my_node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_sane_resolved_address
parameter_list|(
name|sockaddr_u
modifier|*
name|peeraddr
parameter_list|,
name|int
name|hmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_and_apply_config_tree
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_int_fifo
parameter_list|(
name|int_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FREE_INT_FIFO
parameter_list|(
name|pf
parameter_list|)
define|\
value|do {					\ 		destroy_int_fifo(pf);		\ 		(pf) = NULL;			\ 	} while (0)
end_define

begin_function_decl
specifier|static
name|void
name|destroy_string_fifo
parameter_list|(
name|string_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FREE_STRING_FIFO
parameter_list|(
name|pf
parameter_list|)
define|\
value|do {					\ 		destroy_string_fifo(pf);		\ 		(pf) = NULL;			\ 	} while (0)
end_define

begin_function_decl
specifier|static
name|void
name|destroy_attr_val_fifo
parameter_list|(
name|attr_val_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FREE_ATTR_VAL_FIFO
parameter_list|(
name|pf
parameter_list|)
define|\
value|do {					\ 		destroy_attr_val_fifo(pf);	\ 		(pf) = NULL;			\ 	} while (0)
end_define

begin_function_decl
specifier|static
name|void
name|destroy_filegen_fifo
parameter_list|(
name|filegen_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FREE_FILEGEN_FIFO
parameter_list|(
name|pf
parameter_list|)
define|\
value|do {					\ 		destroy_filegen_fifo(pf);	\ 		(pf) = NULL;			\ 	} while (0)
end_define

begin_function_decl
specifier|static
name|void
name|destroy_restrict_fifo
parameter_list|(
name|restrict_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FREE_RESTRICT_FIFO
parameter_list|(
name|pf
parameter_list|)
define|\
value|do {					\ 		destroy_restrict_fifo(pf);	\ 		(pf) = NULL;			\ 	} while (0)
end_define

begin_function_decl
specifier|static
name|void
name|destroy_setvar_fifo
parameter_list|(
name|setvar_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FREE_SETVAR_FIFO
parameter_list|(
name|pf
parameter_list|)
define|\
value|do {					\ 		destroy_setvar_fifo(pf);	\ 		(pf) = NULL;			\ 	} while (0)
end_define

begin_function_decl
specifier|static
name|void
name|destroy_addr_opts_fifo
parameter_list|(
name|addr_opts_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FREE_ADDR_OPTS_FIFO
parameter_list|(
name|pf
parameter_list|)
define|\
value|do {					\ 		destroy_addr_opts_fifo(pf);	\ 		(pf) = NULL;			\ 	} while (0)
end_define

begin_function_decl
specifier|static
name|void
name|config_logconfig
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_monitor
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_rlimit
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_system_opts
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_tinker
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_tos
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_vars
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function_decl
specifier|static
name|sockaddr_u
modifier|*
name|get_next_address
parameter_list|(
name|address_node
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_sim
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_ntpdsim
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SIM follows */
end_comment

begin_function_decl
specifier|static
name|void
name|config_ntpd
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_other_modes
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_auth
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_access
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_phone
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_setvar
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_ttl
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_trap
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_fudge
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_peers
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_unpeers
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_nic_rules
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|config_reset_counters
parameter_list|(
name|config_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
name|get_correct_host_mode
parameter_list|(
name|int
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|peerflag_bits
parameter_list|(
name|peer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WORKER
end_ifdef

begin_function_decl
specifier|static
name|void
name|peer_name_resolved
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unpeer_name_resolved
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trap_name_resolved
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|gnn_type
block|{
name|t_UNK
block|,
comment|/* Unknown */
name|t_REF
block|,
comment|/* Refclock */
name|t_MSK
comment|/* Network Mask */
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|ntpd_set_tod_using
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|normal_dtoa
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|get_pfxmatch
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|masks
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|get_match
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|masks
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|get_logmask
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function_decl
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|num
parameter_list|,
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|int
name|complain
parameter_list|,
name|enum
name|gnn_type
name|a_type
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FUNCTIONS FOR INITIALIZATION  * ----------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_auth_node
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keys
condition|)
block|{
name|free
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|keys
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|keys
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keysdir
condition|)
block|{
name|free
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|keysdir
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|keysdir
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
condition|)
block|{
name|free
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function
specifier|static
name|void
name|init_syntax_tree
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|ZERO
argument_list|(
operator|*
name|ptree
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_all_config_trees
parameter_list|(
name|void
parameter_list|)
block|{
name|config_tree
modifier|*
name|ptree
decl_stmt|;
name|config_tree
modifier|*
name|pnext
decl_stmt|;
name|ptree
operator|=
name|cfg_tree_history
expr_stmt|;
while|while
condition|(
name|ptree
operator|!=
name|NULL
condition|)
block|{
name|pnext
operator|=
name|ptree
operator|->
name|link
expr_stmt|;
name|free_config_tree
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|ptree
operator|=
name|pnext
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_config_tree
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|_CrtCheckMemory
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptree
operator|->
name|source
operator|.
name|value
operator|.
name|s
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ptree
operator|->
name|source
operator|.
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|free_config_other_modes
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_auth
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_tos
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_monitor
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_access
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_tinker
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_rlimit
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_system_opts
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_logconfig
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_phone
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_setvar
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_ttl
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_trap
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_fudge
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_vars
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_peers
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_unpeers
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_nic_rules
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free_config_reset_counters
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIM
name|free_config_sim
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_auth_node
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|_CrtCheckMemory
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SAVECONFIG
end_ifdef

begin_comment
comment|/* Dump all trees */
end_comment

begin_function
name|int
name|dump_all_config_trees
parameter_list|(
name|FILE
modifier|*
name|df
parameter_list|,
name|int
name|comment
parameter_list|)
block|{
name|config_tree
modifier|*
name|cfg_ptr
decl_stmt|;
name|int
name|return_value
decl_stmt|;
name|return_value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cfg_ptr
operator|=
name|cfg_tree_history
init|;
name|cfg_ptr
operator|!=
name|NULL
condition|;
name|cfg_ptr
operator|=
name|cfg_ptr
operator|->
name|link
control|)
name|return_value
operator||=
name|dump_config_tree
argument_list|(
name|cfg_ptr
argument_list|,
name|df
argument_list|,
name|comment
argument_list|)
expr_stmt|;
return|return
name|return_value
return|;
block|}
end_function

begin_comment
comment|/* The config dumper */
end_comment

begin_function
name|int
name|dump_config_tree
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|,
name|FILE
modifier|*
name|df
parameter_list|,
name|int
name|comment
parameter_list|)
block|{
name|peer_node
modifier|*
name|peern
decl_stmt|;
name|unpeer_node
modifier|*
name|unpeern
decl_stmt|;
name|attr_val
modifier|*
name|atrv
decl_stmt|;
name|address_node
modifier|*
name|addr
decl_stmt|;
name|address_node
modifier|*
name|peer_addr
decl_stmt|;
name|address_node
modifier|*
name|fudge_addr
decl_stmt|;
name|filegen_node
modifier|*
name|fgen_node
decl_stmt|;
name|restrict_node
modifier|*
name|rest_node
decl_stmt|;
name|addr_opts_node
modifier|*
name|addr_opts
decl_stmt|;
name|setvar_node
modifier|*
name|setv_node
decl_stmt|;
name|nic_rule_node
modifier|*
name|rule_node
decl_stmt|;
name|int_node
modifier|*
name|i_n
decl_stmt|;
name|int_node
modifier|*
name|flags
decl_stmt|;
name|int_node
modifier|*
name|counter_set
decl_stmt|;
name|string_node
modifier|*
name|str_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
name|char
name|timestamp
index|[
literal|80
index|]
decl_stmt|;
name|int
name|enable
decl_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"dump_config_tree(%p)\n"
operator|,
name|ptree
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comment
condition|)
block|{
if|if
condition|(
operator|!
name|strftime
argument_list|(
name|timestamp
argument_list|,
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|,
literal|"%Y-%m-%d %H:%M:%S"
argument_list|,
name|localtime
argument_list|(
operator|&
name|ptree
operator|->
name|timestamp
argument_list|)
argument_list|)
condition|)
name|timestamp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"# %s %s %s\n"
argument_list|,
name|timestamp
argument_list|,
operator|(
name|CONF_SOURCE_NTPQ
operator|==
name|ptree
operator|->
name|source
operator|.
name|attr
operator|)
condition|?
literal|"ntpq remote config from"
else|:
literal|"startup configuration file"
argument_list|,
name|ptree
operator|->
name|source
operator|.
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* For options I didn't find documentation I'll just output its name and the cor. value */
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|vars
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|atrv
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown vars type %d (%s) for %s\n"
argument_list|,
name|atrv
operator|->
name|type
argument_list|,
name|token_name
argument_list|(
name|atrv
operator|->
name|type
argument_list|)
argument_list|,
name|token_name
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_Double
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s %s\n"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|normal_dtoa
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Integer
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s %d\n"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_String
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s \"%s\""
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|T_Driftfile
operator|==
name|atrv
operator|->
name|attr
operator|&&
name|atrv
operator|->
name|link
operator|!=
name|NULL
operator|&&
name|T_WanderThreshold
operator|==
name|atrv
operator|->
name|link
operator|->
name|attr
condition|)
block|{
name|atrv
operator|=
name|atrv
operator|->
name|link
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s\n"
argument_list|,
name|normal_dtoa
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|logconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"logconfig"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %c%s"
argument_list|,
name|atrv
operator|->
name|attr
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|stats_dir
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"statsdir \"%s\"\n"
argument_list|,
name|ptree
operator|->
name|stats_dir
argument_list|)
expr_stmt|;
name|i_n
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|stats_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_n
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"statistics"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i_n
operator|!=
name|NULL
condition|;
name|i_n
operator|=
name|i_n
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
name|i_n
operator|->
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fgen_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|filegen_opts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fgen_node
operator|!=
name|NULL
condition|;
name|fgen_node
operator|=
name|fgen_node
operator|->
name|link
control|)
block|{
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|fgen_node
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"filegen %s"
argument_list|,
name|keyword
argument_list|(
name|fgen_node
operator|->
name|filegen_token
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|atrv
operator|->
name|attr
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown filegen option token %s\n"
literal|"filegen %s"
argument_list|,
name|token_name
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|keyword
argument_list|(
name|fgen_node
operator|->
name|filegen_token
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_File
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" file %s"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Type
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" type %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Flag
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|crypto_cmd_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"crypto"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|revoke
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"revoke %d\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|revoke
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keysdir
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"keysdir \"%s\"\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|keysdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keys
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"keys \"%s\"\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|keys
argument_list|)
expr_stmt|;
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|trusted_key_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"trustedkey"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
if|if
condition|(
name|T_Integer
operator|==
name|atrv
operator|->
name|type
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %d"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|T_Intrange
operator|==
name|atrv
operator|->
name|type
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" (%d ... %d)"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|r
operator|.
name|first
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|r
operator|.
name|last
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
else|else
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown trustedkey attr type %d\n"
literal|"trustedkey"
argument_list|,
name|atrv
operator|->
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|control_key
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"controlkey %d\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|control_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|request_key
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"requestkey %d\n"
argument_list|,
name|ptree
operator|->
name|auth
operator|.
name|request_key
argument_list|)
expr_stmt|;
comment|/* dump enable list, then disable list */
for|for
control|(
name|enable
operator|=
literal|1
init|;
name|enable
operator|>=
literal|0
condition|;
name|enable
operator|--
control|)
block|{
name|atrv
operator|=
operator|(
name|enable
operator|)
condition|?
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|enable_opts
argument_list|)
else|:
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|disable_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|enable
operator|)
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|orphan_cmds
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"tos"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|atrv
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown tos attr type %d %s\n"
literal|"tos"
argument_list|,
name|atrv
operator|->
name|type
argument_list|,
name|token_name
argument_list|(
name|atrv
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_Double
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|normal_dtoa
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|rlimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"rlimit"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
name|INSIST
argument_list|(
name|T_Integer
operator|==
name|atrv
operator|->
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %d"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|tinker
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"tinker"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
name|INSIST
argument_list|(
name|T_Double
operator|==
name|atrv
operator|->
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|normal_dtoa
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptree
operator|->
name|broadcastclient
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"broadcastclient\n"
argument_list|)
expr_stmt|;
name|peern
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|peers
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|peern
operator|!=
name|NULL
condition|;
name|peern
operator|=
name|peern
operator|->
name|link
control|)
block|{
name|addr
operator|=
name|peern
operator|->
name|addr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s"
argument_list|,
name|keyword
argument_list|(
name|peern
operator|->
name|host_mode
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"# dump error:\n"
literal|"# unknown peer family %d for:\n"
literal|"%s"
argument_list|,
name|addr
operator|->
name|type
argument_list|,
name|keyword
argument_list|(
name|peern
operator|->
name|host_mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_UNSPEC
case|:
break|break;
case|case
name|AF_INET
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" -4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" -6"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|peern
operator|->
name|minpoll
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" minpoll %u"
argument_list|,
name|peern
operator|->
name|minpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|peern
operator|->
name|maxpoll
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" maxpoll %u"
argument_list|,
name|peern
operator|->
name|maxpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|peern
operator|->
name|ttl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|addr
operator|->
name|address
argument_list|)
operator|>
literal|8
operator|&&
operator|!
name|memcmp
argument_list|(
name|addr
operator|->
name|address
argument_list|,
literal|"127.127."
argument_list|,
literal|8
argument_list|)
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" mode %u"
argument_list|,
name|peern
operator|->
name|ttl
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" ttl %u"
argument_list|,
name|peern
operator|->
name|ttl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peern
operator|->
name|peerversion
operator|!=
name|NTP_VERSION
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" version %u"
argument_list|,
name|peern
operator|->
name|peerversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|peern
operator|->
name|peerkey
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" key %u"
argument_list|,
name|peern
operator|->
name|peerkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|peern
operator|->
name|group
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" ident \"%s\""
argument_list|,
name|peern
operator|->
name|group
argument_list|)
expr_stmt|;
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|peern
operator|->
name|peerflags
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
name|INSIST
argument_list|(
name|T_Flag
operator|==
name|atrv
operator|->
name|attr
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|T_Integer
operator|==
name|atrv
operator|->
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|addr_opts
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|fudge
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|addr_opts
operator|!=
name|NULL
condition|;
name|addr_opts
operator|=
name|addr_opts
operator|->
name|link
control|)
block|{
name|peer_addr
operator|=
name|peern
operator|->
name|addr
expr_stmt|;
name|fudge_addr
operator|=
name|addr_opts
operator|->
name|addr
expr_stmt|;
name|s1
operator|=
name|peer_addr
operator|->
name|address
expr_stmt|;
name|s2
operator|=
name|fudge_addr
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"fudge %s"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
for|for
control|(
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|addr_opts
operator|->
name|options
argument_list|)
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|atrv
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown fudge atrv->type %d\n"
literal|"fudge %s"
argument_list|,
name|atrv
operator|->
name|type
argument_list|,
name|s1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_Double
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|normal_dtoa
argument_list|(
name|atrv
operator|->
name|value
operator|.
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Integer
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %d"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_String
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %s"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|addr
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|manycastserver
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"manycastserver"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|addr
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|multicastclient
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"multicastclient"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|addr
operator|!=
name|NULL
condition|;
name|addr
operator|=
name|addr
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unpeern
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|unpeers
argument_list|)
init|;
name|unpeern
operator|!=
name|NULL
condition|;
name|unpeern
operator|=
name|unpeern
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"unpeer %s\n"
argument_list|,
name|unpeern
operator|->
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|mru_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"mru"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %d"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|discard_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|atrv
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"discard"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s %d"
argument_list|,
name|keyword
argument_list|(
name|atrv
operator|->
name|attr
argument_list|)
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rest_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|restrict_opts
argument_list|)
init|;
name|rest_node
operator|!=
name|NULL
condition|;
name|rest_node
operator|=
name|rest_node
operator|->
name|link
control|)
block|{
if|if
condition|(
name|NULL
operator|==
name|rest_node
operator|->
name|addr
condition|)
block|{
name|s
operator|=
literal|"default"
expr_stmt|;
name|flags
operator|=
name|HEAD_PFIFO
argument_list|(
name|rest_node
operator|->
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|flags
operator|!=
name|NULL
condition|;
name|flags
operator|=
name|flags
operator|->
name|link
control|)
if|if
condition|(
name|T_Source
operator|==
name|flags
operator|->
name|i
condition|)
block|{
name|s
operator|=
literal|"source"
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|s
operator|=
name|rest_node
operator|->
name|addr
operator|->
name|address
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"restrict %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest_node
operator|->
name|mask
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" mask %s"
argument_list|,
name|rest_node
operator|->
name|mask
operator|->
name|address
argument_list|)
expr_stmt|;
name|flags
operator|=
name|HEAD_PFIFO
argument_list|(
name|rest_node
operator|->
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|flags
operator|!=
name|NULL
condition|;
name|flags
operator|=
name|flags
operator|->
name|link
control|)
if|if
condition|(
name|T_Source
operator|!=
name|flags
operator|->
name|i
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
name|flags
operator|->
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|rule_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|nic_rules
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|rule_node
operator|!=
name|NULL
condition|;
name|rule_node
operator|=
name|rule_node
operator|->
name|link
control|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"interface %s %s\n"
argument_list|,
name|keyword
argument_list|(
name|rule_node
operator|->
name|action
argument_list|)
argument_list|,
operator|(
name|rule_node
operator|->
name|match_class
operator|)
condition|?
name|keyword
argument_list|(
name|rule_node
operator|->
name|match_class
argument_list|)
else|:
name|rule_node
operator|->
name|if_name
argument_list|)
expr_stmt|;
block|}
name|str_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|phone
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_node
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"phone"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|str_node
operator|!=
name|NULL
condition|;
name|str_node
operator|=
name|str_node
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" \"%s\""
argument_list|,
name|str_node
operator|->
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|setv_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|setvar
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|setv_node
operator|!=
name|NULL
condition|;
name|setv_node
operator|=
name|setv_node
operator|->
name|link
control|)
block|{
name|s1
operator|=
name|quote_if_needed
argument_list|(
name|setv_node
operator|->
name|var
argument_list|)
expr_stmt|;
name|s2
operator|=
name|quote_if_needed
argument_list|(
name|setv_node
operator|->
name|val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"setvar %s = %s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|setv_node
operator|->
name|isdefault
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" default"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|i_n
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_n
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"ttl"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i_n
operator|!=
name|NULL
condition|;
name|i_n
operator|=
name|i_n
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %d"
argument_list|,
name|i_n
operator|->
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|addr_opts
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|trap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|addr_opts
operator|!=
name|NULL
condition|;
name|addr_opts
operator|=
name|addr_opts
operator|->
name|link
control|)
block|{
name|addr
operator|=
name|addr_opts
operator|->
name|addr
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"trap %s"
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|atrv
operator|=
name|HEAD_PFIFO
argument_list|(
name|addr_opts
operator|->
name|options
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|atrv
operator|!=
name|NULL
condition|;
name|atrv
operator|=
name|atrv
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|atrv
operator|->
name|attr
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n# dump error:\n"
literal|"# unknown trap token %d\n"
literal|"trap %s"
argument_list|,
name|atrv
operator|->
name|attr
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_Port
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" port %d"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Interface
case|:
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" interface %s"
argument_list|,
name|atrv
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|counter_set
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|reset_counters
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter_set
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"reset"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|counter_set
operator|!=
name|NULL
condition|;
name|counter_set
operator|=
name|counter_set
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|" %s"
argument_list|,
name|keyword
argument_list|(
name|counter_set
operator|->
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SAVECONFIG */
end_comment

begin_comment
comment|/* generic fifo routines for structs linked by 1st member */
end_comment

begin_function
name|void
modifier|*
name|append_gen_fifo
parameter_list|(
name|void
modifier|*
name|fifo
parameter_list|,
name|void
modifier|*
name|entry
parameter_list|)
block|{
name|gen_fifo
modifier|*
name|pf
decl_stmt|;
name|gen_node
modifier|*
name|pe
decl_stmt|;
name|pf
operator|=
name|fifo
expr_stmt|;
name|pe
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pf
condition|)
name|pf
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CHECK_FIFO_CONSISTENCY
argument_list|(
operator|*
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|!=
name|NULL
condition|)
name|LINK_FIFO
argument_list|(
operator|*
name|pf
argument_list|,
name|pe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|CHECK_FIFO_CONSISTENCY
argument_list|(
operator|*
name|pf
argument_list|)
expr_stmt|;
return|return
name|pf
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|concat_gen_fifos
parameter_list|(
name|void
modifier|*
name|first
parameter_list|,
name|void
modifier|*
name|second
parameter_list|)
block|{
name|gen_fifo
modifier|*
name|pf1
decl_stmt|;
name|gen_fifo
modifier|*
name|pf2
decl_stmt|;
name|pf1
operator|=
name|first
expr_stmt|;
name|pf2
operator|=
name|second
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pf1
condition|)
return|return
name|pf2
return|;
if|if
condition|(
name|NULL
operator|==
name|pf2
condition|)
return|return
name|pf1
return|;
name|CONCAT_FIFO
argument_list|(
operator|*
name|pf1
argument_list|,
operator|*
name|pf2
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pf2
argument_list|)
expr_stmt|;
return|return
name|pf1
return|;
block|}
end_function

begin_comment
comment|/* FUNCTIONS FOR CREATING NODES ON THE SYNTAX TREE  * -----------------------------------------------  */
end_comment

begin_function
name|attr_val
modifier|*
name|create_attr_dval
parameter_list|(
name|int
name|attr
parameter_list|,
name|double
name|value
parameter_list|)
block|{
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_val
argument_list|)
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|d
operator|=
name|value
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_Double
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|attr_val
modifier|*
name|create_attr_ival
parameter_list|(
name|int
name|attr
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_val
argument_list|)
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|i
operator|=
name|value
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_Integer
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|attr_val
modifier|*
name|create_attr_uval
parameter_list|(
name|int
name|attr
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_val
argument_list|)
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|u
operator|=
name|value
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_U_int
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|attr_val
modifier|*
name|create_attr_rangeval
parameter_list|(
name|int
name|attr
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_val
argument_list|)
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|r
operator|.
name|first
operator|=
name|first
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|r
operator|.
name|last
operator|=
name|last
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_Intrange
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|attr_val
modifier|*
name|create_attr_sval
parameter_list|(
name|int
name|attr
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|my_val
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_val
argument_list|)
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s
condition|)
comment|/* free() hates NULL */
name|s
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|my_val
operator|->
name|value
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|my_val
operator|->
name|type
operator|=
name|T_String
expr_stmt|;
return|return
name|my_val
return|;
block|}
end_function

begin_function
name|int_node
modifier|*
name|create_int_node
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|int_node
modifier|*
name|i_n
decl_stmt|;
name|i_n
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|i_n
argument_list|)
argument_list|)
expr_stmt|;
name|i_n
operator|->
name|i
operator|=
name|val
expr_stmt|;
return|return
name|i_n
return|;
block|}
end_function

begin_function
name|string_node
modifier|*
name|create_string_node
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|string_node
modifier|*
name|sn
decl_stmt|;
name|sn
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sn
argument_list|)
argument_list|)
expr_stmt|;
name|sn
operator|->
name|s
operator|=
name|str
expr_stmt|;
return|return
name|sn
return|;
block|}
end_function

begin_function
name|address_node
modifier|*
name|create_address_node
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|address_node
modifier|*
name|my_node
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|addr
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|AF_INET
operator|==
name|type
operator|||
name|AF_INET6
operator|==
name|type
operator|||
name|AF_UNSPEC
operator|==
name|type
argument_list|)
expr_stmt|;
name|my_node
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|address
operator|=
name|addr
expr_stmt|;
name|my_node
operator|->
name|type
operator|=
operator|(
name|u_short
operator|)
name|type
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|void
name|destroy_address_node
parameter_list|(
name|address_node
modifier|*
name|my_node
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|my_node
condition|)
return|return;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|my_node
operator|->
name|address
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|my_node
operator|->
name|address
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|peer_node
modifier|*
name|create_peer_node
parameter_list|(
name|int
name|hmode
parameter_list|,
name|address_node
modifier|*
name|addr
parameter_list|,
name|attr_val_fifo
modifier|*
name|options
parameter_list|)
block|{
name|peer_node
modifier|*
name|my_node
decl_stmt|;
name|attr_val
modifier|*
name|option
decl_stmt|;
name|int
name|freenode
decl_stmt|;
name|int
name|errflag
init|=
literal|0
decl_stmt|;
name|my_node
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize node values to default */
name|my_node
operator|->
name|peerversion
operator|=
name|NTP_VERSION
expr_stmt|;
comment|/* Now set the node to the read values */
name|my_node
operator|->
name|host_mode
operator|=
name|hmode
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
comment|/* 	 * the options FIFO mixes items that will be saved in the 	 * peer_node as explicit members, such as minpoll, and 	 * those that are moved intact to the peer_node's peerflags 	 * FIFO.  The options FIFO is consumed and reclaimed here. 	 */
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
name|CHECK_FIFO_CONSISTENCY
argument_list|(
operator|*
name|options
argument_list|)
expr_stmt|;
while|while
condition|(
name|options
operator|!=
name|NULL
condition|)
block|{
name|UNLINK_FIFO
argument_list|(
name|option
argument_list|,
operator|*
name|options
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|option
condition|)
block|{
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
break|break;
block|}
name|freenode
operator|=
literal|1
expr_stmt|;
comment|/* Check the kind of option being set */
switch|switch
condition|(
name|option
operator|->
name|attr
condition|)
block|{
case|case
name|T_Flag
case|:
name|APPEND_G_FIFO
argument_list|(
name|my_node
operator|->
name|peerflags
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|freenode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_Minpoll
case|:
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|i
operator|<
name|NTP_MINPOLL
operator|||
name|option
operator|->
name|value
operator|.
name|i
operator|>
name|UCHAR_MAX
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"minpoll: provided value (%d) is out of range [%d-%d])"
argument_list|,
name|option
operator|->
name|value
operator|.
name|i
argument_list|,
name|NTP_MINPOLL
argument_list|,
name|UCHAR_MAX
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|minpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
block|}
else|else
block|{
name|my_node
operator|->
name|minpoll
operator|=
operator|(
name|u_char
operator|)
name|option
operator|->
name|value
operator|.
name|u
expr_stmt|;
block|}
break|break;
case|case
name|T_Maxpoll
case|:
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|i
operator|<
literal|0
operator|||
name|option
operator|->
name|value
operator|.
name|i
operator|>
name|NTP_MAXPOLL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"maxpoll: provided value (%d) is out of range [0-%d])"
argument_list|,
name|option
operator|->
name|value
operator|.
name|i
argument_list|,
name|NTP_MAXPOLL
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|maxpoll
operator|=
name|NTP_MAXPOLL
expr_stmt|;
block|}
else|else
block|{
name|my_node
operator|->
name|maxpoll
operator|=
operator|(
name|u_char
operator|)
name|option
operator|->
name|value
operator|.
name|u
expr_stmt|;
block|}
break|break;
case|case
name|T_Ttl
case|:
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|u
operator|>=
name|MAX_TTL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ttl: invalid argument"
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|my_node
operator|->
name|ttl
operator|=
operator|(
name|u_char
operator|)
name|option
operator|->
name|value
operator|.
name|u
expr_stmt|;
block|}
break|break;
case|case
name|T_Mode
case|:
name|my_node
operator|->
name|ttl
operator|=
name|option
operator|->
name|value
operator|.
name|u
expr_stmt|;
break|break;
case|case
name|T_Key
case|:
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|u
operator|>=
name|KEYID_T_MAX
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"key: invalid argument"
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|my_node
operator|->
name|peerkey
operator|=
operator|(
name|keyid_t
operator|)
name|option
operator|->
name|value
operator|.
name|u
expr_stmt|;
block|}
break|break;
case|case
name|T_Version
case|:
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|u
operator|>=
name|UCHAR_MAX
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"version: invalid argument"
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|my_node
operator|->
name|peerversion
operator|=
operator|(
name|u_char
operator|)
name|option
operator|->
name|value
operator|.
name|u
expr_stmt|;
block|}
break|break;
case|case
name|T_Ident
case|:
name|my_node
operator|->
name|group
operator|=
name|option
operator|->
name|value
operator|.
name|s
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown peer/server option token %s"
argument_list|,
name|token_name
argument_list|(
name|option
operator|->
name|attr
argument_list|)
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|freenode
condition|)
name|free
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
comment|/* Check if errors were reported. If yes, ignore the node */
if|if
condition|(
name|errflag
condition|)
block|{
name|free
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
name|my_node
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|unpeer_node
modifier|*
name|create_unpeer_node
parameter_list|(
name|address_node
modifier|*
name|addr
parameter_list|)
block|{
name|unpeer_node
modifier|*
name|my_node
decl_stmt|;
name|u_int
name|u
decl_stmt|;
name|char
modifier|*
name|pch
decl_stmt|;
name|my_node
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * From the parser's perspective an association ID fits into 	 * its generic T_String definition of a name/address "address". 	 * We treat all valid 16-bit numbers as association IDs. 	 */
name|pch
operator|=
name|addr
operator|->
name|address
expr_stmt|;
while|while
condition|(
operator|*
name|pch
operator|&&
name|isdigit
argument_list|(
operator|*
name|pch
argument_list|)
condition|)
name|pch
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pch
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|addr
operator|->
name|address
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|u
argument_list|)
operator|&&
name|u
operator|<=
name|ASSOCID_MAX
condition|)
block|{
name|my_node
operator|->
name|assocID
operator|=
operator|(
name|associd_t
operator|)
name|u
expr_stmt|;
name|destroy_address_node
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|my_node
operator|->
name|assocID
operator|=
literal|0
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
block|}
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|filegen_node
modifier|*
name|create_filegen_node
parameter_list|(
name|int
name|filegen_token
parameter_list|,
name|attr_val_fifo
modifier|*
name|options
parameter_list|)
block|{
name|filegen_node
modifier|*
name|my_node
decl_stmt|;
name|my_node
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|filegen_token
operator|=
name|filegen_token
expr_stmt|;
name|my_node
operator|->
name|options
operator|=
name|options
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|restrict_node
modifier|*
name|create_restrict_node
parameter_list|(
name|address_node
modifier|*
name|addr
parameter_list|,
name|address_node
modifier|*
name|mask
parameter_list|,
name|int_fifo
modifier|*
name|flags
parameter_list|,
name|int
name|line_no
parameter_list|)
block|{
name|restrict_node
modifier|*
name|my_node
decl_stmt|;
name|my_node
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|my_node
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|my_node
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|my_node
operator|->
name|line_no
operator|=
name|line_no
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_restrict_node
parameter_list|(
name|restrict_node
modifier|*
name|my_node
parameter_list|)
block|{
comment|/* With great care, free all the memory occupied by 	 * the restrict node 	 */
name|destroy_address_node
argument_list|(
name|my_node
operator|->
name|addr
argument_list|)
expr_stmt|;
name|destroy_address_node
argument_list|(
name|my_node
operator|->
name|mask
argument_list|)
expr_stmt|;
name|destroy_int_fifo
argument_list|(
name|my_node
operator|->
name|flags
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|my_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_int_fifo
parameter_list|(
name|int_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|int_node
modifier|*
name|i_n
decl_stmt|;
if|if
condition|(
name|fifo
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|i_n
argument_list|,
operator|*
name|fifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_n
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|i_n
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_string_fifo
parameter_list|(
name|string_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|string_node
modifier|*
name|sn
decl_stmt|;
if|if
condition|(
name|fifo
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|sn
argument_list|,
operator|*
name|fifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|sn
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|sn
operator|->
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_attr_val_fifo
parameter_list|(
name|attr_val_fifo
modifier|*
name|av_fifo
parameter_list|)
block|{
name|attr_val
modifier|*
name|av
decl_stmt|;
if|if
condition|(
name|av_fifo
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|av
argument_list|,
operator|*
name|av_fifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|T_String
operator|==
name|av
operator|->
name|type
condition|)
name|free
argument_list|(
name|av
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|av_fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_filegen_fifo
parameter_list|(
name|filegen_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|filegen_node
modifier|*
name|fg
decl_stmt|;
if|if
condition|(
name|fifo
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|fg
argument_list|,
operator|*
name|fifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|==
name|NULL
condition|)
break|break;
name|destroy_attr_val_fifo
argument_list|(
name|fg
operator|->
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fg
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_restrict_fifo
parameter_list|(
name|restrict_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|restrict_node
modifier|*
name|rn
decl_stmt|;
if|if
condition|(
name|fifo
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|rn
argument_list|,
operator|*
name|fifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|==
name|NULL
condition|)
break|break;
name|destroy_restrict_node
argument_list|(
name|rn
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_setvar_fifo
parameter_list|(
name|setvar_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|setvar_node
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|fifo
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|sv
argument_list|,
operator|*
name|fifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|sv
operator|->
name|var
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sv
operator|->
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_addr_opts_fifo
parameter_list|(
name|addr_opts_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|addr_opts_node
modifier|*
name|aon
decl_stmt|;
if|if
condition|(
name|fifo
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|aon
argument_list|,
operator|*
name|fifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|aon
operator|==
name|NULL
condition|)
break|break;
name|destroy_address_node
argument_list|(
name|aon
operator|->
name|addr
argument_list|)
expr_stmt|;
name|destroy_attr_val_fifo
argument_list|(
name|aon
operator|->
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aon
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|setvar_node
modifier|*
name|create_setvar_node
parameter_list|(
name|char
modifier|*
name|var
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|int
name|isdefault
parameter_list|)
block|{
name|setvar_node
modifier|*
name|my_node
decl_stmt|;
name|char
modifier|*
name|pch
decl_stmt|;
comment|/* do not allow = in the variable name */
name|pch
operator|=
name|strchr
argument_list|(
name|var
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|pch
condition|)
operator|*
name|pch
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now store the string into a setvar_node */
name|my_node
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|var
operator|=
name|var
expr_stmt|;
name|my_node
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|my_node
operator|->
name|isdefault
operator|=
name|isdefault
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|nic_rule_node
modifier|*
name|create_nic_rule_node
parameter_list|(
name|int
name|match_class
parameter_list|,
name|char
modifier|*
name|if_name
parameter_list|,
comment|/* interface name or numeric address */
name|int
name|action
parameter_list|)
block|{
name|nic_rule_node
modifier|*
name|my_node
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|match_class
operator|!=
literal|0
operator|||
name|if_name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|my_node
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|match_class
operator|=
name|match_class
expr_stmt|;
name|my_node
operator|->
name|if_name
operator|=
name|if_name
expr_stmt|;
name|my_node
operator|->
name|action
operator|=
name|action
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_function
name|addr_opts_node
modifier|*
name|create_addr_opts_node
parameter_list|(
name|address_node
modifier|*
name|addr
parameter_list|,
name|attr_val_fifo
modifier|*
name|options
parameter_list|)
block|{
name|addr_opts_node
modifier|*
name|my_node
decl_stmt|;
name|my_node
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|my_node
operator|->
name|options
operator|=
name|options
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function
name|script_info
modifier|*
name|create_sim_script_info
parameter_list|(
name|double
name|duration
parameter_list|,
name|attr_val_fifo
modifier|*
name|script_queue
parameter_list|)
block|{
name|script_info
modifier|*
name|my_info
decl_stmt|;
name|attr_val
modifier|*
name|my_attr_val
decl_stmt|;
name|my_info
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize Script Info with default values*/
name|my_info
operator|->
name|duration
operator|=
name|duration
expr_stmt|;
name|my_info
operator|->
name|prop_delay
operator|=
name|NET_DLY
expr_stmt|;
name|my_info
operator|->
name|proc_delay
operator|=
name|PROC_DLY
expr_stmt|;
comment|/* Traverse the script_queue and fill out non-default values */
for|for
control|(
name|my_attr_val
operator|=
name|HEAD_PFIFO
argument_list|(
name|script_queue
argument_list|)
init|;
name|my_attr_val
operator|!=
name|NULL
condition|;
name|my_attr_val
operator|=
name|my_attr_val
operator|->
name|link
control|)
block|{
comment|/* Set the desired value */
switch|switch
condition|(
name|my_attr_val
operator|->
name|attr
condition|)
block|{
case|case
name|T_Freq_Offset
case|:
name|my_info
operator|->
name|freq_offset
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Wander
case|:
name|my_info
operator|->
name|wander
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Jitter
case|:
name|my_info
operator|->
name|jitter
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Prop_Delay
case|:
name|my_info
operator|->
name|prop_delay
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Proc_Delay
case|:
name|my_info
operator|->
name|proc_delay
operator|=
name|my_attr_val
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown script token %d"
argument_list|,
name|my_attr_val
operator|->
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|my_info
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function
specifier|static
name|sockaddr_u
modifier|*
name|get_next_address
parameter_list|(
name|address_node
modifier|*
name|addr
parameter_list|)
block|{
specifier|const
name|char
name|addr_prefix
index|[]
init|=
literal|"192.168.0."
decl_stmt|;
specifier|static
name|int
name|curr_addr_num
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|ADDR_LENGTH
value|16 + 1
comment|/* room for 192.168.1.255 */
name|char
name|addr_string
index|[
name|ADDR_LENGTH
index|]
decl_stmt|;
name|sockaddr_u
modifier|*
name|final_addr
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ptr
decl_stmt|;
name|int
name|gai_err
decl_stmt|;
name|final_addr
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|final_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|type
operator|==
name|T_String
condition|)
block|{
name|snprintf
argument_list|(
name|addr_string
argument_list|,
sizeof|sizeof
argument_list|(
name|addr_string
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|addr_prefix
argument_list|,
name|curr_addr_num
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Selecting ip address %s for hostname %s\n"
argument_list|,
name|addr_string
argument_list|,
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
name|gai_err
operator|=
name|getaddrinfo
argument_list|(
name|addr_string
argument_list|,
literal|"ntp"
argument_list|,
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gai_err
operator|=
name|getaddrinfo
argument_list|(
name|addr
operator|->
name|address
argument_list|,
literal|"ntp"
argument_list|,
name|NULL
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gai_err
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR!! Could not get a new address\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|final_addr
argument_list|,
name|ptr
operator|->
name|ai_addr
argument_list|,
name|ptr
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Successful in setting ip address of simulated server to: %s\n"
argument_list|,
name|stoa
argument_list|(
name|final_addr
argument_list|)
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|final_addr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function
name|server_info
modifier|*
name|create_sim_server
parameter_list|(
name|address_node
modifier|*
name|addr
parameter_list|,
name|double
name|server_offset
parameter_list|,
name|script_info_fifo
modifier|*
name|script
parameter_list|)
block|{
name|server_info
modifier|*
name|my_info
decl_stmt|;
name|my_info
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_info
argument_list|)
argument_list|)
expr_stmt|;
name|my_info
operator|->
name|server_time
operator|=
name|server_offset
expr_stmt|;
name|my_info
operator|->
name|addr
operator|=
name|get_next_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|my_info
operator|->
name|script
operator|=
name|script
expr_stmt|;
name|UNLINK_FIFO
argument_list|(
name|my_info
operator|->
name|curr_script
argument_list|,
operator|*
name|my_info
operator|->
name|script
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
name|my_info
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIM */
end_comment

begin_function
name|sim_node
modifier|*
name|create_sim_node
parameter_list|(
name|attr_val_fifo
modifier|*
name|init_opts
parameter_list|,
name|server_info_fifo
modifier|*
name|servers
parameter_list|)
block|{
name|sim_node
modifier|*
name|my_node
decl_stmt|;
name|my_node
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|my_node
argument_list|)
argument_list|)
expr_stmt|;
name|my_node
operator|->
name|init_opts
operator|=
name|init_opts
expr_stmt|;
name|my_node
operator|->
name|servers
operator|=
name|servers
expr_stmt|;
return|return
name|my_node
return|;
block|}
end_function

begin_comment
comment|/* FUNCTIONS FOR PERFORMING THE CONFIGURATION  * ------------------------------------------  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_other_modes
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|sockaddr_u
name|addr_sock
decl_stmt|;
name|address_node
modifier|*
name|addr_node
decl_stmt|;
if|if
condition|(
name|ptree
operator|->
name|broadcastclient
condition|)
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
name|ptree
operator|->
name|broadcastclient
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addr_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|manycastserver
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr_node
operator|!=
name|NULL
condition|)
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
name|addr_node
operator|->
name|type
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|getnetnum
argument_list|(
name|addr_node
operator|->
name|address
argument_list|,
operator|&
name|addr_sock
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
condition|)
block|{
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|,
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
name|sys_manycastserver
operator|=
literal|1
expr_stmt|;
block|}
name|addr_node
operator|=
name|addr_node
operator|->
name|link
expr_stmt|;
block|}
comment|/* Configure the multicast clients */
name|addr_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|multicastclient
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_node
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
name|addr_node
operator|->
name|type
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|getnetnum
argument_list|(
name|addr_node
operator|->
name|address
argument_list|,
operator|&
name|addr_sock
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
condition|)
block|{
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
literal|0
argument_list|,
literal|0.
argument_list|,
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
block|}
name|addr_node
operator|=
name|addr_node
operator|->
name|link
expr_stmt|;
block|}
do|while
condition|(
name|addr_node
operator|!=
name|NULL
condition|)
do|;
name|proto_config
argument_list|(
name|PROTO_MULTICAST_ADD
argument_list|,
literal|1
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|destroy_address_fifo
parameter_list|(
name|address_fifo
modifier|*
name|pfifo
parameter_list|)
block|{
name|address_node
modifier|*
name|addr_node
decl_stmt|;
if|if
condition|(
name|pfifo
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|addr_node
argument_list|,
operator|*
name|pfifo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_node
operator|==
name|NULL
condition|)
break|break;
name|destroy_address_node
argument_list|(
name|addr_node
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pfifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_config_other_modes
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ADDRESS_FIFO
argument_list|(
name|ptree
operator|->
name|manycastserver
argument_list|)
expr_stmt|;
name|FREE_ADDRESS_FIFO
argument_list|(
name|ptree
operator|->
name|multicastclient
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_auth
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|attr_val
modifier|*
name|my_val
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
name|int
name|item
decl_stmt|;
endif|#
directive|endif
comment|/* Crypto Command */
ifdef|#
directive|ifdef
name|AUTOKEY
name|item
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* quiet warning */
name|my_val
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|crypto_cmd_list
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_val
operator|!=
name|NULL
condition|;
name|my_val
operator|=
name|my_val
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|my_val
operator|->
name|attr
condition|)
block|{
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Host
case|:
name|item
operator|=
name|CRYPTO_CONF_PRIV
expr_stmt|;
break|break;
case|case
name|T_Ident
case|:
name|item
operator|=
name|CRYPTO_CONF_IDENT
expr_stmt|;
break|break;
case|case
name|T_Pw
case|:
name|item
operator|=
name|CRYPTO_CONF_PW
expr_stmt|;
break|break;
case|case
name|T_Randfile
case|:
name|item
operator|=
name|CRYPTO_CONF_RAND
expr_stmt|;
break|break;
case|case
name|T_Digest
case|:
name|item
operator|=
name|CRYPTO_CONF_NID
expr_stmt|;
break|break;
block|}
name|crypto_config
argument_list|(
name|item
argument_list|,
name|my_val
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* Keysdir Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keysdir
condition|)
block|{
if|if
condition|(
name|keysdir
operator|!=
name|default_keysdir
condition|)
name|free
argument_list|(
name|keysdir
argument_list|)
expr_stmt|;
name|keysdir
operator|=
name|estrdup
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|keysdir
argument_list|)
expr_stmt|;
block|}
comment|/* ntp_signd_socket Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
condition|)
block|{
if|if
condition|(
name|ntp_signd_socket
operator|!=
name|default_ntp_signd_socket
condition|)
name|free
argument_list|(
name|ntp_signd_socket
argument_list|)
expr_stmt|;
name|ntp_signd_socket
operator|=
name|estrdup
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|ntp_signd_socket
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|cryptosw
operator|&&
operator|!
name|cryptosw
condition|)
block|{
name|crypto_setup
argument_list|()
expr_stmt|;
name|cryptosw
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * Count the number of trusted keys to preallocate storage and 	 * size the hash table. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|my_val
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|trusted_key_list
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_val
operator|!=
name|NULL
condition|;
name|my_val
operator|=
name|my_val
operator|->
name|link
control|)
block|{
if|if
condition|(
name|T_Integer
operator|==
name|my_val
operator|->
name|type
condition|)
block|{
name|first
operator|=
name|my_val
operator|->
name|value
operator|.
name|i
expr_stmt|;
if|if
condition|(
name|first
operator|>
literal|1
operator|&&
name|first
operator|<=
name|NTP_MAXKEY
condition|)
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|REQUIRE
argument_list|(
name|T_Intrange
operator|==
name|my_val
operator|->
name|type
argument_list|)
expr_stmt|;
name|first
operator|=
name|my_val
operator|->
name|value
operator|.
name|r
operator|.
name|first
expr_stmt|;
name|last
operator|=
name|my_val
operator|->
name|value
operator|.
name|r
operator|.
name|last
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|first
operator|>
name|last
operator|||
name|first
operator|<
literal|1
operator|||
name|last
operator|>
name|NTP_MAXKEY
operator|)
condition|)
block|{
name|count
operator|+=
literal|1
operator|+
name|last
operator|-
name|first
expr_stmt|;
block|}
block|}
block|}
name|auth_prealloc_symkeys
argument_list|(
name|count
argument_list|)
expr_stmt|;
comment|/* Keys Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|keys
condition|)
name|getauthkeys
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|keys
argument_list|)
expr_stmt|;
comment|/* Control Key Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|control_key
condition|)
name|ctl_auth_keyid
operator|=
operator|(
name|keyid_t
operator|)
name|ptree
operator|->
name|auth
operator|.
name|control_key
expr_stmt|;
comment|/* Requested Key Command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|request_key
condition|)
block|{
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"set info_auth_keyid to %08lx\n"
operator|,
operator|(
name|u_long
operator|)
name|ptree
operator|->
name|auth
operator|.
name|request_key
operator|)
argument_list|)
expr_stmt|;
name|info_auth_keyid
operator|=
operator|(
name|keyid_t
operator|)
name|ptree
operator|->
name|auth
operator|.
name|request_key
expr_stmt|;
block|}
comment|/* Trusted Key Command */
name|my_val
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|trusted_key_list
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_val
operator|!=
name|NULL
condition|;
name|my_val
operator|=
name|my_val
operator|->
name|link
control|)
block|{
if|if
condition|(
name|T_Integer
operator|==
name|my_val
operator|->
name|type
condition|)
block|{
name|first
operator|=
name|my_val
operator|->
name|value
operator|.
name|i
expr_stmt|;
if|if
condition|(
name|first
operator|>=
literal|1
operator|&&
name|first
operator|<=
name|NTP_MAXKEY
condition|)
block|{
name|authtrust
argument_list|(
name|first
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Ignoring invalid trustedkey %d, min 1 max %d."
argument_list|,
name|first
argument_list|,
name|NTP_MAXKEY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|first
operator|=
name|my_val
operator|->
name|value
operator|.
name|r
operator|.
name|first
expr_stmt|;
name|last
operator|=
name|my_val
operator|->
name|value
operator|.
name|r
operator|.
name|last
expr_stmt|;
if|if
condition|(
name|first
operator|>
name|last
operator|||
name|first
operator|<
literal|1
operator|||
name|last
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Ignoring invalid trustedkey range %d ... %d, min 1 max %d."
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|NTP_MAXKEY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<=
name|last
condition|;
name|i
operator|++
control|)
block|{
name|authtrust
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* crypto revoke command */
if|if
condition|(
name|ptree
operator|->
name|auth
operator|.
name|revoke
condition|)
name|sys_revoke
operator|=
literal|1UL
operator|<<
name|ptree
operator|->
name|auth
operator|.
name|revoke
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_auth
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|destroy_attr_val_fifo
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|crypto_cmd_list
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|crypto_cmd_list
operator|=
name|NULL
expr_stmt|;
name|destroy_attr_val_fifo
argument_list|(
name|ptree
operator|->
name|auth
operator|.
name|trusted_key_list
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|auth
operator|.
name|trusted_key_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_tos
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|attr_val
modifier|*
name|tos
decl_stmt|;
name|int
name|item
decl_stmt|;
name|double
name|val
decl_stmt|;
name|item
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* quiet warning */
name|tos
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|orphan_cmds
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|tos
operator|!=
name|NULL
condition|;
name|tos
operator|=
name|tos
operator|->
name|link
control|)
block|{
name|val
operator|=
name|tos
operator|->
name|value
operator|.
name|d
expr_stmt|;
switch|switch
condition|(
name|tos
operator|->
name|attr
condition|)
block|{
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Ceiling
case|:
if|if
condition|(
name|val
operator|>
name|STRATUM_UNSPEC
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Using maximum tos ceiling %d, %g requested"
argument_list|,
name|STRATUM_UNSPEC
operator|-
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|STRATUM_UNSPEC
operator|-
literal|1
expr_stmt|;
block|}
name|item
operator|=
name|PROTO_CEILING
expr_stmt|;
break|break;
case|case
name|T_Floor
case|:
name|item
operator|=
name|PROTO_FLOOR
expr_stmt|;
break|break;
case|case
name|T_Cohort
case|:
name|item
operator|=
name|PROTO_COHORT
expr_stmt|;
break|break;
case|case
name|T_Orphan
case|:
name|item
operator|=
name|PROTO_ORPHAN
expr_stmt|;
break|break;
case|case
name|T_Orphanwait
case|:
name|item
operator|=
name|PROTO_ORPHWAIT
expr_stmt|;
break|break;
case|case
name|T_Mindist
case|:
name|item
operator|=
name|PROTO_MINDISP
expr_stmt|;
break|break;
case|case
name|T_Maxdist
case|:
name|item
operator|=
name|PROTO_MAXDIST
expr_stmt|;
break|break;
case|case
name|T_Minclock
case|:
name|item
operator|=
name|PROTO_MINCLOCK
expr_stmt|;
break|break;
case|case
name|T_Maxclock
case|:
name|item
operator|=
name|PROTO_MAXCLOCK
expr_stmt|;
break|break;
case|case
name|T_Minsane
case|:
name|item
operator|=
name|PROTO_MINSANE
expr_stmt|;
break|break;
case|case
name|T_Beacon
case|:
name|item
operator|=
name|PROTO_BEACON
expr_stmt|;
break|break;
block|}
name|proto_config
argument_list|(
name|item
argument_list|,
literal|0
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_tos
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|ptree
operator|->
name|orphan_cmds
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_monitor
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|int_node
modifier|*
name|pfilegen_token
decl_stmt|;
specifier|const
name|char
modifier|*
name|filegen_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|filegen_file
decl_stmt|;
name|FILEGEN
modifier|*
name|filegen
decl_stmt|;
name|filegen_node
modifier|*
name|my_node
decl_stmt|;
name|attr_val
modifier|*
name|my_opts
decl_stmt|;
name|int
name|filegen_type
decl_stmt|;
name|int
name|filegen_flag
decl_stmt|;
comment|/* Set the statistics directory */
if|if
condition|(
name|ptree
operator|->
name|stats_dir
condition|)
name|stats_config
argument_list|(
name|STATS_STATSDIR
argument_list|,
name|ptree
operator|->
name|stats_dir
argument_list|)
expr_stmt|;
comment|/* NOTE: 	 * Calling filegen_get is brain dead. Doing a string 	 * comparison to find the relavant filegen structure is 	 * expensive. 	 * 	 * Through the parser, we already know which filegen is 	 * being specified. Hence, we should either store a 	 * pointer to the specified structure in the syntax tree 	 * or an index into a filegen array. 	 * 	 * Need to change the filegen code to reflect the above. 	 */
comment|/* Turn on the specified statistics */
name|pfilegen_token
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|stats_list
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pfilegen_token
operator|!=
name|NULL
condition|;
name|pfilegen_token
operator|=
name|pfilegen_token
operator|->
name|link
control|)
block|{
name|filegen_string
operator|=
name|keyword
argument_list|(
name|pfilegen_token
operator|->
name|i
argument_list|)
expr_stmt|;
name|filegen
operator|=
name|filegen_get
argument_list|(
name|filegen_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|filegen
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"stats %s unrecognized"
argument_list|,
name|filegen_string
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"enabling filegen for %s statistics '%s%s'\n"
operator|,
name|filegen_string
operator|,
name|filegen
operator|->
name|dir
operator|,
name|filegen
operator|->
name|fname
operator|)
argument_list|)
expr_stmt|;
name|filegen_flag
operator|=
name|filegen
operator|->
name|flag
expr_stmt|;
name|filegen_flag
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
name|filegen_config
argument_list|(
name|filegen
argument_list|,
name|statsdir
argument_list|,
name|filegen_string
argument_list|,
name|filegen
operator|->
name|type
argument_list|,
name|filegen_flag
argument_list|)
expr_stmt|;
block|}
comment|/* Configure the statistics with the options */
name|my_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|filegen_opts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_node
operator|!=
name|NULL
condition|;
name|my_node
operator|=
name|my_node
operator|->
name|link
control|)
block|{
name|filegen_string
operator|=
name|keyword
argument_list|(
name|my_node
operator|->
name|filegen_token
argument_list|)
expr_stmt|;
name|filegen
operator|=
name|filegen_get
argument_list|(
name|filegen_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|filegen
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen category '%s' unrecognized"
argument_list|,
name|filegen_string
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|filegen_file
operator|=
name|filegen_string
expr_stmt|;
comment|/* Initialize the filegen variables to their pre-configuration states */
name|filegen_flag
operator|=
name|filegen
operator|->
name|flag
expr_stmt|;
name|filegen_type
operator|=
name|filegen
operator|->
name|type
expr_stmt|;
comment|/* "filegen ... enabled" is the default (when filegen is used) */
name|filegen_flag
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
name|my_opts
operator|=
name|HEAD_PFIFO
argument_list|(
name|my_node
operator|->
name|options
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_opts
operator|!=
name|NULL
condition|;
name|my_opts
operator|=
name|my_opts
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|my_opts
operator|->
name|attr
condition|)
block|{
case|case
name|T_File
case|:
name|filegen_file
operator|=
name|my_opts
operator|->
name|value
operator|.
name|s
expr_stmt|;
break|break;
case|case
name|T_Type
case|:
switch|switch
condition|(
name|my_opts
operator|->
name|value
operator|.
name|i
condition|)
block|{
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_None
case|:
name|filegen_type
operator|=
name|FILEGEN_NONE
expr_stmt|;
break|break;
case|case
name|T_Pid
case|:
name|filegen_type
operator|=
name|FILEGEN_PID
expr_stmt|;
break|break;
case|case
name|T_Day
case|:
name|filegen_type
operator|=
name|FILEGEN_DAY
expr_stmt|;
break|break;
case|case
name|T_Week
case|:
name|filegen_type
operator|=
name|FILEGEN_WEEK
expr_stmt|;
break|break;
case|case
name|T_Month
case|:
name|filegen_type
operator|=
name|FILEGEN_MONTH
expr_stmt|;
break|break;
case|case
name|T_Year
case|:
name|filegen_type
operator|=
name|FILEGEN_YEAR
expr_stmt|;
break|break;
case|case
name|T_Age
case|:
name|filegen_type
operator|=
name|FILEGEN_AGE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|T_Flag
case|:
switch|switch
condition|(
name|my_opts
operator|->
name|value
operator|.
name|i
condition|)
block|{
case|case
name|T_Link
case|:
name|filegen_flag
operator||=
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|T_Nolink
case|:
name|filegen_flag
operator|&=
operator|~
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|T_Enable
case|:
name|filegen_flag
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
case|case
name|T_Disable
case|:
name|filegen_flag
operator|&=
operator|~
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown filegen flag token %d"
argument_list|,
name|my_opts
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown filegen option token %d"
argument_list|,
name|my_opts
operator|->
name|attr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|filegen_config
argument_list|(
name|filegen
argument_list|,
name|statsdir
argument_list|,
name|filegen_file
argument_list|,
name|filegen_type
argument_list|,
name|filegen_flag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_monitor
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
if|if
condition|(
name|ptree
operator|->
name|stats_dir
condition|)
block|{
name|free
argument_list|(
name|ptree
operator|->
name|stats_dir
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|stats_dir
operator|=
name|NULL
expr_stmt|;
block|}
name|FREE_INT_FIFO
argument_list|(
name|ptree
operator|->
name|stats_list
argument_list|)
expr_stmt|;
name|FREE_FILEGEN_FIFO
argument_list|(
name|ptree
operator|->
name|filegen_opts
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_access
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
specifier|static
name|int
name|warned_signd
decl_stmt|;
name|attr_val
modifier|*
name|my_opt
decl_stmt|;
name|restrict_node
modifier|*
name|my_node
decl_stmt|;
name|int_node
modifier|*
name|curr_flag
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|sockaddr_u
name|mask
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai_list
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|restrict_default
decl_stmt|;
name|u_short
name|flags
decl_stmt|;
name|u_short
name|mflags
decl_stmt|;
name|int
name|range_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|signd_warning
init|=
ifdef|#
directive|ifdef
name|HAVE_NTP_SIGND
literal|"MS-SNTP signd operations currently block ntpd degrading service to all clients."
decl_stmt|;
else|#
directive|else
literal|"mssntp restrict bit ignored, this ntpd was configured without --enable-ntp-signd."
expr_stmt|;
endif|#
directive|endif
comment|/* Configure the mru options */
name|my_opt
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|mru_opts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_opt
operator|!=
name|NULL
condition|;
name|my_opt
operator|=
name|my_opt
operator|->
name|link
control|)
block|{
name|range_err
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|my_opt
operator|->
name|attr
condition|)
block|{
case|case
name|T_Incalloc
case|:
if|if
condition|(
literal|0
operator|<=
name|my_opt
operator|->
name|value
operator|.
name|i
condition|)
name|mru_incalloc
operator|=
name|my_opt
operator|->
name|value
operator|.
name|u
expr_stmt|;
else|else
name|range_err
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|T_Incmem
case|:
if|if
condition|(
literal|0
operator|<=
name|my_opt
operator|->
name|value
operator|.
name|i
condition|)
name|mru_incalloc
operator|=
operator|(
name|my_opt
operator|->
name|value
operator|.
name|u
operator|*
literal|1024U
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|mon_entry
argument_list|)
expr_stmt|;
else|else
name|range_err
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|T_Initalloc
case|:
if|if
condition|(
literal|0
operator|<=
name|my_opt
operator|->
name|value
operator|.
name|i
condition|)
name|mru_initalloc
operator|=
name|my_opt
operator|->
name|value
operator|.
name|u
expr_stmt|;
else|else
name|range_err
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|T_Initmem
case|:
if|if
condition|(
literal|0
operator|<=
name|my_opt
operator|->
name|value
operator|.
name|i
condition|)
name|mru_initalloc
operator|=
operator|(
name|my_opt
operator|->
name|value
operator|.
name|u
operator|*
literal|1024U
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|mon_entry
argument_list|)
expr_stmt|;
else|else
name|range_err
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|T_Mindepth
case|:
if|if
condition|(
literal|0
operator|<=
name|my_opt
operator|->
name|value
operator|.
name|i
condition|)
name|mru_mindepth
operator|=
name|my_opt
operator|->
name|value
operator|.
name|u
expr_stmt|;
else|else
name|range_err
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|T_Maxage
case|:
name|mru_maxage
operator|=
name|my_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Maxdepth
case|:
if|if
condition|(
literal|0
operator|<=
name|my_opt
operator|->
name|value
operator|.
name|i
condition|)
name|mru_maxdepth
operator|=
name|my_opt
operator|->
name|value
operator|.
name|u
expr_stmt|;
else|else
name|mru_maxdepth
operator|=
name|UINT_MAX
expr_stmt|;
break|break;
case|case
name|T_Maxmem
case|:
if|if
condition|(
literal|0
operator|<=
name|my_opt
operator|->
name|value
operator|.
name|i
condition|)
name|mru_maxdepth
operator|=
operator|(
name|my_opt
operator|->
name|value
operator|.
name|u
operator|*
literal|1024U
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|mon_entry
argument_list|)
expr_stmt|;
else|else
name|mru_maxdepth
operator|=
name|UINT_MAX
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown mru option %s (%d)"
argument_list|,
name|keyword
argument_list|(
name|my_opt
operator|->
name|attr
argument_list|)
argument_list|,
name|my_opt
operator|->
name|attr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|range_err
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mru %s %d out of range, ignored."
argument_list|,
name|keyword
argument_list|(
name|my_opt
operator|->
name|attr
argument_list|)
argument_list|,
name|my_opt
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Configure the discard options */
name|my_opt
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|discard_opts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_opt
operator|!=
name|NULL
condition|;
name|my_opt
operator|=
name|my_opt
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|my_opt
operator|->
name|attr
condition|)
block|{
case|case
name|T_Average
case|:
if|if
condition|(
literal|0
operator|<=
name|my_opt
operator|->
name|value
operator|.
name|i
operator|&&
name|my_opt
operator|->
name|value
operator|.
name|i
operator|<=
name|UCHAR_MAX
condition|)
name|ntp_minpoll
operator|=
operator|(
name|u_char
operator|)
name|my_opt
operator|->
name|value
operator|.
name|u
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"discard average %d out of range, ignored."
argument_list|,
name|my_opt
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Minimum
case|:
name|ntp_minpkt
operator|=
name|my_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Monitor
case|:
name|mon_age
operator|=
name|my_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown discard option %s (%d)"
argument_list|,
name|keyword
argument_list|(
name|my_opt
operator|->
name|attr
argument_list|)
argument_list|,
name|my_opt
operator|->
name|attr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Configure the restrict options */
name|my_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|restrict_opts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_node
operator|!=
name|NULL
condition|;
name|my_node
operator|=
name|my_node
operator|->
name|link
control|)
block|{
comment|/* Parse the flags */
name|flags
operator|=
literal|0
expr_stmt|;
name|mflags
operator|=
literal|0
expr_stmt|;
name|curr_flag
operator|=
name|HEAD_PFIFO
argument_list|(
name|my_node
operator|->
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|curr_flag
operator|!=
name|NULL
condition|;
name|curr_flag
operator|=
name|curr_flag
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|curr_flag
operator|->
name|i
condition|)
block|{
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Ntpport
case|:
name|mflags
operator||=
name|RESM_NTPONLY
expr_stmt|;
break|break;
case|case
name|T_Source
case|:
name|mflags
operator||=
name|RESM_SOURCE
expr_stmt|;
break|break;
case|case
name|T_Flake
case|:
name|flags
operator||=
name|RES_FLAKE
expr_stmt|;
break|break;
case|case
name|T_Ignore
case|:
name|flags
operator||=
name|RES_IGNORE
expr_stmt|;
break|break;
case|case
name|T_Kod
case|:
name|flags
operator||=
name|RES_KOD
expr_stmt|;
break|break;
case|case
name|T_Mssntp
case|:
name|flags
operator||=
name|RES_MSSNTP
expr_stmt|;
break|break;
case|case
name|T_Limited
case|:
name|flags
operator||=
name|RES_LIMITED
expr_stmt|;
break|break;
case|case
name|T_Lowpriotrap
case|:
name|flags
operator||=
name|RES_LPTRAP
expr_stmt|;
break|break;
case|case
name|T_Nomodify
case|:
name|flags
operator||=
name|RES_NOMODIFY
expr_stmt|;
break|break;
case|case
name|T_Nomrulist
case|:
name|flags
operator||=
name|RES_NOMRULIST
expr_stmt|;
break|break;
case|case
name|T_Nopeer
case|:
name|flags
operator||=
name|RES_NOPEER
expr_stmt|;
break|break;
case|case
name|T_Noquery
case|:
name|flags
operator||=
name|RES_NOQUERY
expr_stmt|;
break|break;
case|case
name|T_Noserve
case|:
name|flags
operator||=
name|RES_DONTSERVE
expr_stmt|;
break|break;
case|case
name|T_Notrap
case|:
name|flags
operator||=
name|RES_NOTRAP
expr_stmt|;
break|break;
case|case
name|T_Notrust
case|:
name|flags
operator||=
name|RES_DONTTRUST
expr_stmt|;
break|break;
case|case
name|T_Version
case|:
name|flags
operator||=
name|RES_VERSION
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|RES_MSSNTP
operator|&
name|flags
operator|)
operator|&&
operator|!
name|warned_signd
condition|)
block|{
name|warned_signd
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|signd_warning
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s"
argument_list|,
name|signd_warning
argument_list|)
expr_stmt|;
block|}
comment|/* It would be swell if we could identify the line number */
if|if
condition|(
operator|(
name|RES_KOD
operator|&
name|flags
operator|)
operator|&&
operator|!
operator|(
name|RES_LIMITED
operator|&
name|flags
operator|)
condition|)
block|{
name|char
modifier|*
name|kod_where
init|=
operator|(
name|my_node
operator|->
name|addr
operator|)
condition|?
name|my_node
operator|->
name|addr
operator|->
name|address
else|:
operator|(
name|mflags
operator|&
name|RESM_SOURCE
operator|)
condition|?
literal|"source"
else|:
literal|"default"
decl_stmt|;
name|char
modifier|*
name|kod_warn
init|=
literal|"KOD does nothing without LIMITED."
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"restrict %s: %s\n"
argument_list|,
name|kod_where
argument_list|,
name|kod_warn
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"restrict %s: %s"
argument_list|,
name|kod_where
argument_list|,
name|kod_warn
argument_list|)
expr_stmt|;
block|}
name|ZERO_SOCK
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
name|ai_list
operator|=
name|NULL
expr_stmt|;
name|pai
operator|=
name|NULL
expr_stmt|;
name|restrict_default
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|my_node
operator|->
name|addr
condition|)
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|RESM_SOURCE
operator|&
name|mflags
operator|)
condition|)
block|{
comment|/* 				 * The user specified a default rule 				 * without a -4 / -6 qualifier, add to 				 * both lists 				 */
name|restrict_default
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* apply "restrict source ..." */
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"restrict source template mflags %x flags %x\n"
operator|,
name|mflags
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mflags
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* Resolve the specified address */
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
operator|=
operator|(
name|u_short
operator|)
name|my_node
operator|->
name|addr
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|my_node
operator|->
name|addr
operator|->
name|address
argument_list|,
operator|&
name|addr
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* 				 * Attempt a blocking lookup.  This 				 * is in violation of the nonblocking 				 * design of ntpd's mainline code.  The 				 * alternative of running without the 				 * restriction until the name resolved 				 * seems worse. 				 * Ideally some scheme could be used for 				 * restrict directives in the startup 				 * ntp.conf to delay starting up the 				 * protocol machinery until after all 				 * restrict hosts have been resolved. 				 */
name|ai_list
operator|=
name|NULL
expr_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|my_node
operator|->
name|addr
operator|->
name|type
expr_stmt|;
name|rc
operator|=
name|getaddrinfo
argument_list|(
name|my_node
operator|->
name|addr
operator|->
name|address
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"restrict: ignoring line %d, address/host '%s' unusable."
argument_list|,
name|my_node
operator|->
name|line_no
argument_list|,
name|my_node
operator|->
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|INSIST
argument_list|(
name|ai_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pai
operator|=
name|ai_list
expr_stmt|;
name|INSIST
argument_list|(
name|pai
operator|->
name|ai_addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
operator|>=
name|pai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
name|pai
operator|->
name|ai_addr
argument_list|,
name|pai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|AF_INET
operator|==
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
operator|||
name|AF_INET6
operator|==
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SET_HOSTMASK
argument_list|(
operator|&
name|mask
argument_list|,
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Resolve the mask */
if|if
condition|(
name|my_node
operator|->
name|mask
condition|)
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|mask
argument_list|)
operator|=
name|my_node
operator|->
name|mask
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|my_node
operator|->
name|mask
operator|->
name|address
argument_list|,
operator|&
name|mask
argument_list|,
literal|1
argument_list|,
name|t_MSK
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"restrict: ignoring line %d, mask '%s' unusable."
argument_list|,
name|my_node
operator|->
name|line_no
argument_list|,
name|my_node
operator|->
name|mask
operator|->
name|address
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* Set the flags */
if|if
condition|(
name|restrict_default
condition|)
block|{
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|AF
argument_list|(
operator|&
name|mask
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|mask
argument_list|,
name|mflags
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
operator|=
name|AF_INET6
expr_stmt|;
name|AF
argument_list|(
operator|&
name|mask
argument_list|)
operator|=
name|AF_INET6
expr_stmt|;
block|}
do|do
block|{
name|hack_restrict
argument_list|(
name|RESTRICT_FLAGS
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|mask
argument_list|,
name|mflags
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pai
operator|!=
name|NULL
operator|&&
name|NULL
operator|!=
operator|(
name|pai
operator|=
name|pai
operator|->
name|ai_next
operator|)
condition|)
block|{
name|INSIST
argument_list|(
name|pai
operator|->
name|ai_addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
operator|>=
name|pai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
name|pai
operator|->
name|ai_addr
argument_list|,
name|pai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|AF_INET
operator|==
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
operator|||
name|AF_INET6
operator|==
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|SET_HOSTMASK
argument_list|(
operator|&
name|mask
argument_list|,
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pai
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|ai_list
operator|!=
name|NULL
condition|)
name|freeaddrinfo
argument_list|(
name|ai_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_access
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|ptree
operator|->
name|mru_opts
argument_list|)
expr_stmt|;
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|ptree
operator|->
name|discard_opts
argument_list|)
expr_stmt|;
name|FREE_RESTRICT_FIFO
argument_list|(
name|ptree
operator|->
name|restrict_opts
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_rlimit
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|attr_val
modifier|*
name|rlimit_av
decl_stmt|;
name|rlimit_av
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|rlimit
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|rlimit_av
operator|!=
name|NULL
condition|;
name|rlimit_av
operator|=
name|rlimit_av
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|rlimit_av
operator|->
name|attr
condition|)
block|{
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Memlock
case|:
if|if
condition|(
name|rlimit_av
operator|->
name|value
operator|.
name|i
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|RLIMIT_MEMLOCK
argument_list|)
name|ntp_rlimit
argument_list|(
name|RLIMIT_MEMLOCK
argument_list|,
call|(
name|rlim_t
call|)
argument_list|(
name|rlimit_av
operator|->
name|value
operator|.
name|i
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|,
literal|1024
operator|*
literal|1024
argument_list|,
literal|"MB"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* STDERR as well would be fine... */
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"'rlimit memlock' specified but is not available on this system."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RLIMIT_MEMLOCK */
block|}
else|else
block|{
name|do_memlock
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|T_Stacksize
case|:
if|#
directive|if
name|defined
argument_list|(
name|RLIMIT_STACK
argument_list|)
name|ntp_rlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
call|(
name|rlim_t
call|)
argument_list|(
name|rlimit_av
operator|->
name|value
operator|.
name|i
operator|*
literal|4096
argument_list|)
argument_list|,
literal|4096
argument_list|,
literal|"4k"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* STDERR as well would be fine... */
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"'rlimit stacksize' specified but is not available on this system."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RLIMIT_STACK */
break|break;
case|case
name|T_Filenum
case|:
if|#
directive|if
name|defined
argument_list|(
name|RLIMIT_NOFILE
argument_list|)
name|ntp_rlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
call|(
name|rlim_t
call|)
argument_list|(
name|rlimit_av
operator|->
name|value
operator|.
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* STDERR as well would be fine... */
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"'rlimit filenum' specified but is not available on this system."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RLIMIT_NOFILE */
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|config_tinker
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|attr_val
modifier|*
name|tinker
decl_stmt|;
name|int
name|item
decl_stmt|;
name|item
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* quiet warning */
name|tinker
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|tinker
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|tinker
operator|!=
name|NULL
condition|;
name|tinker
operator|=
name|tinker
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|tinker
operator|->
name|attr
condition|)
block|{
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Allan
case|:
name|item
operator|=
name|LOOP_ALLAN
expr_stmt|;
break|break;
case|case
name|T_Dispersion
case|:
name|item
operator|=
name|LOOP_PHI
expr_stmt|;
break|break;
case|case
name|T_Freq
case|:
name|item
operator|=
name|LOOP_FREQ
expr_stmt|;
break|break;
case|case
name|T_Huffpuff
case|:
name|item
operator|=
name|LOOP_HUFFPUFF
expr_stmt|;
break|break;
case|case
name|T_Panic
case|:
name|item
operator|=
name|LOOP_PANIC
expr_stmt|;
break|break;
case|case
name|T_Step
case|:
name|item
operator|=
name|LOOP_MAX
expr_stmt|;
break|break;
case|case
name|T_Stepout
case|:
name|item
operator|=
name|LOOP_MINSTEP
expr_stmt|;
break|break;
case|case
name|T_Tick
case|:
name|item
operator|=
name|LOOP_TICK
expr_stmt|;
break|break;
block|}
name|loop_config
argument_list|(
name|item
argument_list|,
name|tinker
operator|->
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_rlimit
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|ptree
operator|->
name|rlimit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_config_tinker
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|ptree
operator|->
name|tinker
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_comment
comment|/*  * config_nic_rules - apply interface listen/ignore/drop items  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_nic_rules
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|nic_rule_node
modifier|*
name|curr_node
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|nic_rule_match
name|match_type
decl_stmt|;
name|nic_rule_action
name|action
decl_stmt|;
name|char
modifier|*
name|if_name
decl_stmt|;
name|char
modifier|*
name|pchSlash
decl_stmt|;
name|int
name|prefixlen
decl_stmt|;
name|int
name|addrbits
decl_stmt|;
name|curr_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|nic_rules
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_node
operator|!=
name|NULL
operator|&&
operator|(
name|HAVE_OPT
argument_list|(
name|NOVIRTUALIPS
argument_list|)
operator|||
name|HAVE_OPT
argument_list|(
name|INTERFACE
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"interface/nic rules are not allowed with --interface (-I) or --novirtualips (-L)%s"
argument_list|,
operator|(
name|input_from_file
operator|)
condition|?
literal|", exiting"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_from_file
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
for|for
control|(
init|;
name|curr_node
operator|!=
name|NULL
condition|;
name|curr_node
operator|=
name|curr_node
operator|->
name|link
control|)
block|{
name|prefixlen
operator|=
operator|-
literal|1
expr_stmt|;
name|if_name
operator|=
name|curr_node
operator|->
name|if_name
expr_stmt|;
if|if
condition|(
name|if_name
operator|!=
name|NULL
condition|)
name|if_name
operator|=
name|estrdup
argument_list|(
name|if_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curr_node
operator|->
name|match_class
condition|)
block|{
default|default:
comment|/* 			 * this assignment quiets a gcc "may be used 			 * uninitialized" warning and is here for no 			 * other reason. 			 */
name|match_type
operator|=
name|MATCH_ALL
expr_stmt|;
name|INSIST
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 			 * 0 is out of range for valid token T_... 			 * and in a nic_rules_node indicates the 			 * interface descriptor is either a name or 			 * address, stored in if_name in either case. 			 */
name|INSIST
argument_list|(
name|if_name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pchSlash
operator|=
name|strchr
argument_list|(
name|if_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pchSlash
operator|!=
name|NULL
condition|)
operator|*
name|pchSlash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|is_ip_address
argument_list|(
name|if_name
argument_list|,
name|AF_UNSPEC
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|match_type
operator|=
name|MATCH_IFADDR
expr_stmt|;
if|if
condition|(
name|pchSlash
operator|!=
name|NULL
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|pchSlash
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|prefixlen
argument_list|)
condition|)
block|{
name|addrbits
operator|=
literal|8
operator|*
name|SIZEOF_INADDR
argument_list|(
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|prefixlen
operator|=
name|max
argument_list|(
operator|-
literal|1
argument_list|,
name|prefixlen
argument_list|)
expr_stmt|;
name|prefixlen
operator|=
name|min
argument_list|(
name|prefixlen
argument_list|,
name|addrbits
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|match_type
operator|=
name|MATCH_IFNAME
expr_stmt|;
if|if
condition|(
name|pchSlash
operator|!=
name|NULL
condition|)
operator|*
name|pchSlash
operator|=
literal|'/'
expr_stmt|;
block|}
break|break;
case|case
name|T_All
case|:
name|match_type
operator|=
name|MATCH_ALL
expr_stmt|;
break|break;
case|case
name|T_Ipv4
case|:
name|match_type
operator|=
name|MATCH_IPV4
expr_stmt|;
break|break;
case|case
name|T_Ipv6
case|:
name|match_type
operator|=
name|MATCH_IPV6
expr_stmt|;
break|break;
case|case
name|T_Wildcard
case|:
name|match_type
operator|=
name|MATCH_WILDCARD
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|curr_node
operator|->
name|action
condition|)
block|{
default|default:
comment|/* 			 * this assignment quiets a gcc "may be used 			 * uninitialized" warning and is here for no 			 * other reason. 			 */
name|action
operator|=
name|ACTION_LISTEN
expr_stmt|;
name|INSIST
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Listen
case|:
name|action
operator|=
name|ACTION_LISTEN
expr_stmt|;
break|break;
case|case
name|T_Ignore
case|:
name|action
operator|=
name|ACTION_IGNORE
expr_stmt|;
break|break;
case|case
name|T_Drop
case|:
name|action
operator|=
name|ACTION_DROP
expr_stmt|;
break|break;
block|}
name|add_nic_rule
argument_list|(
name|match_type
argument_list|,
name|if_name
argument_list|,
name|prefixlen
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|timer_interfacetimeout
argument_list|(
name|current_time
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|if_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_nic_rules
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|nic_rule_node
modifier|*
name|curr_node
decl_stmt|;
if|if
condition|(
name|ptree
operator|->
name|nic_rules
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|curr_node
argument_list|,
operator|*
name|ptree
operator|->
name|nic_rules
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|curr_node
condition|)
break|break;
name|free
argument_list|(
name|curr_node
operator|->
name|if_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curr_node
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ptree
operator|->
name|nic_rules
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|nic_rules
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|apply_enable_disable
parameter_list|(
name|attr_val_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|attr_val
modifier|*
name|curr_flag
decl_stmt|;
name|int
name|option
decl_stmt|;
ifdef|#
directive|ifdef
name|BC_LIST_FRAMEWORK_NOT_YET_USED
name|bc_entry
modifier|*
name|pentry
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|curr_flag
operator|=
name|HEAD_PFIFO
argument_list|(
name|fifo
argument_list|)
init|;
name|curr_flag
operator|!=
name|NULL
condition|;
name|curr_flag
operator|=
name|curr_flag
operator|->
name|link
control|)
block|{
name|option
operator|=
name|curr_flag
operator|->
name|value
operator|.
name|i
expr_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can not apply enable/disable token %d, unknown"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Auth
case|:
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Bclient
case|:
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Calibrate
case|:
name|proto_config
argument_list|(
name|PROTO_CAL
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Kernel
case|:
name|proto_config
argument_list|(
name|PROTO_KERNEL
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Monitor
case|:
name|proto_config
argument_list|(
name|PROTO_MONITOR
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Ntp
case|:
name|proto_config
argument_list|(
name|PROTO_NTP
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Mode7
case|:
name|proto_config
argument_list|(
name|PROTO_MODE7
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Stats
case|:
name|proto_config
argument_list|(
name|PROTO_FILEGEN
argument_list|,
name|enable
argument_list|,
literal|0.
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BC_LIST_FRAMEWORK_NOT_YET_USED
case|case
name|T_Bc_bugXXXX
case|:
name|pentry
operator|=
name|bc_list
expr_stmt|;
while|while
condition|(
name|pentry
operator|->
name|token
condition|)
block|{
if|if
condition|(
name|pentry
operator|->
name|token
operator|==
name|option
condition|)
break|break;
name|pentry
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pentry
operator|->
name|token
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"compat token %d not in bc_list[]"
argument_list|,
name|option
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pentry
operator|->
name|enabled
operator|=
name|enable
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|config_system_opts
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|apply_enable_disable
argument_list|(
name|ptree
operator|->
name|enable_opts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|apply_enable_disable
argument_list|(
name|ptree
operator|->
name|disable_opts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_system_opts
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|ptree
operator|->
name|enable_opts
argument_list|)
expr_stmt|;
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|ptree
operator|->
name|disable_opts
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_logconfig
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|attr_val
modifier|*
name|my_lc
decl_stmt|;
name|my_lc
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|logconfig
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_lc
operator|!=
name|NULL
condition|;
name|my_lc
operator|=
name|my_lc
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|my_lc
operator|->
name|attr
condition|)
block|{
case|case
literal|'+'
case|:
name|ntp_syslogmask
operator||=
name|get_logmask
argument_list|(
name|my_lc
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|ntp_syslogmask
operator|&=
operator|~
name|get_logmask
argument_list|(
name|my_lc
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|ntp_syslogmask
operator|=
name|get_logmask
argument_list|(
name|my_lc
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_logconfig
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|ptree
operator|->
name|logconfig
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_phone
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|string_node
modifier|*
name|sn
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|sn
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|phone
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sn
operator|!=
name|NULL
condition|;
name|sn
operator|=
name|sn
operator|->
name|link
control|)
block|{
comment|/* need to leave array entry for NULL terminator */
if|if
condition|(
name|i
operator|<
name|COUNTOF
argument_list|(
name|sys_phone
argument_list|)
operator|-
literal|1
condition|)
block|{
name|sys_phone
index|[
name|i
operator|++
index|]
operator|=
name|estrdup
argument_list|(
name|sn
operator|->
name|s
argument_list|)
expr_stmt|;
name|sys_phone
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"phone: Number of phone entries exceeds %lu. Ignoring phone %s..."
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|COUNTOF
argument_list|(
name|sys_phone
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|sn
operator|->
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_phone
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_STRING_FIFO
argument_list|(
name|ptree
operator|->
name|phone
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_setvar
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|setvar_node
modifier|*
name|my_node
decl_stmt|;
name|size_t
name|varlen
decl_stmt|,
name|vallen
decl_stmt|,
name|octets
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|NULL
expr_stmt|;
name|my_node
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|setvar
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|my_node
operator|!=
name|NULL
condition|;
name|my_node
operator|=
name|my_node
operator|->
name|link
control|)
block|{
name|varlen
operator|=
name|strlen
argument_list|(
name|my_node
operator|->
name|var
argument_list|)
expr_stmt|;
name|vallen
operator|=
name|strlen
argument_list|(
name|my_node
operator|->
name|val
argument_list|)
expr_stmt|;
name|octets
operator|=
name|varlen
operator|+
name|vallen
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|str
operator|=
name|erealloc
argument_list|(
name|str
argument_list|,
name|octets
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
name|octets
argument_list|,
literal|"%s=%s"
argument_list|,
name|my_node
operator|->
name|var
argument_list|,
name|my_node
operator|->
name|val
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|str
argument_list|,
name|octets
argument_list|,
operator|(
name|my_node
operator|->
name|isdefault
operator|)
condition|?
name|DEF
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_setvar
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_SETVAR_FIFO
argument_list|(
name|ptree
operator|->
name|setvar
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_ttl
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int_node
modifier|*
name|curr_ttl
decl_stmt|;
name|curr_ttl
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|ttl
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|curr_ttl
operator|!=
name|NULL
condition|;
name|curr_ttl
operator|=
name|curr_ttl
operator|->
name|link
control|)
block|{
if|if
condition|(
name|i
operator|<
name|COUNTOF
argument_list|(
name|sys_ttl
argument_list|)
condition|)
name|sys_ttl
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|u_char
operator|)
name|curr_ttl
operator|->
name|i
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ttl: Number of TTL entries exceeds %lu. Ignoring TTL %d..."
argument_list|,
operator|(
name|u_long
operator|)
name|COUNTOF
argument_list|(
name|sys_ttl
argument_list|)
argument_list|,
name|curr_ttl
operator|->
name|i
argument_list|)
expr_stmt|;
block|}
name|sys_ttlmax
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_ttl
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_INT_FIFO
argument_list|(
name|ptree
operator|->
name|ttl
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_trap
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|addr_opts_node
modifier|*
name|curr_trap
decl_stmt|;
name|attr_val
modifier|*
name|curr_opt
decl_stmt|;
name|sockaddr_u
name|addr_sock
decl_stmt|;
name|sockaddr_u
name|peeraddr
decl_stmt|;
name|struct
name|interface
modifier|*
name|localaddr
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|char
name|port_text
index|[
literal|8
index|]
decl_stmt|;
name|settrap_parms
modifier|*
name|pstp
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|int
name|err_flag
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* silence warning about addr_sock potentially uninitialized */
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
operator|=
name|AF_UNSPEC
expr_stmt|;
name|curr_trap
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|trap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|curr_trap
operator|!=
name|NULL
condition|;
name|curr_trap
operator|=
name|curr_trap
operator|->
name|link
control|)
block|{
name|err_flag
operator|=
literal|0
expr_stmt|;
name|port
operator|=
literal|0
expr_stmt|;
name|localaddr
operator|=
name|NULL
expr_stmt|;
name|curr_opt
operator|=
name|HEAD_PFIFO
argument_list|(
name|curr_trap
operator|->
name|options
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|curr_opt
operator|!=
name|NULL
condition|;
name|curr_opt
operator|=
name|curr_opt
operator|->
name|link
control|)
block|{
if|if
condition|(
name|T_Port
operator|==
name|curr_opt
operator|->
name|attr
condition|)
block|{
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
operator|<
literal|1
operator|||
name|curr_opt
operator|->
name|value
operator|.
name|i
operator|>
name|USHRT_MAX
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid port number "
literal|"%d, trap ignored"
argument_list|,
name|curr_opt
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
name|err_flag
operator|=
literal|1
expr_stmt|;
block|}
name|port
operator|=
operator|(
name|u_short
operator|)
name|curr_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|T_Interface
operator|==
name|curr_opt
operator|->
name|attr
condition|)
block|{
comment|/* Resolve the interface address */
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|curr_opt
operator|->
name|value
operator|.
name|s
argument_list|,
operator|&
name|addr_sock
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|err_flag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|localaddr
operator|=
name|findinterface
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|localaddr
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't find interface with address %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr_sock
argument_list|)
argument_list|)
expr_stmt|;
name|err_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Now process the trap for the specified interface 		 * and port number 		 */
if|if
condition|(
operator|!
name|err_flag
condition|)
block|{
if|if
condition|(
operator|!
name|port
condition|)
name|port
operator|=
name|TRAPPORT
expr_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|getnetnum
argument_list|(
name|curr_trap
operator|->
name|addr
operator|->
name|address
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|,
name|t_UNK
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|rc
condition|)
block|{
ifndef|#
directive|ifndef
name|WORKER
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trap: unable to use IP address %s."
argument_list|,
name|curr_trap
operator|->
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* WORKER follows */
comment|/* 				 * save context and hand it off 				 * for name resolution. 				 */
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|snprintf
argument_list|(
name|port_text
argument_list|,
sizeof|sizeof
argument_list|(
name|port_text
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|Z_AI_NUMERICSERV
expr_stmt|;
name|pstp
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pstp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|localaddr
operator|!=
name|NULL
condition|)
block|{
name|hints
operator|.
name|ai_family
operator|=
name|localaddr
operator|->
name|family
expr_stmt|;
name|pstp
operator|->
name|ifaddr_nonnull
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pstp
operator|->
name|ifaddr
argument_list|,
operator|&
name|localaddr
operator|->
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|pstp
operator|->
name|ifaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|getaddrinfo_sometime
argument_list|(
name|curr_trap
operator|->
name|addr
operator|->
name|address
argument_list|,
name|port_text
argument_list|,
operator|&
name|hints
argument_list|,
name|INITIAL_DNS_RETRY
argument_list|,
operator|&
name|trap_name_resolved
argument_list|,
name|pstp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"config_trap: getaddrinfo_sometime(%s,%s): %m"
argument_list|,
name|curr_trap
operator|->
name|addr
operator|->
name|address
argument_list|,
name|port_text
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WORKER */
continue|continue;
block|}
comment|/* port is at same location for v4 and v6 */
name|SET_PORT
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|localaddr
condition|)
name|localaddr
operator|=
name|ANY_INTERFACE_CHOOSE
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
else|else
name|AF
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|=
name|AF
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctlsettrap
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|localaddr
argument_list|,
literal|0
argument_list|,
name|NTP_VERSION
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"set trap %s -> %s failed."
argument_list|,
name|latoa
argument_list|(
name|localaddr
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * trap_name_resolved()  *  * Callback invoked when config_trap()'s DNS lookup completes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WORKER
end_ifdef

begin_function
specifier|static
name|void
name|trap_name_resolved
parameter_list|(
name|int
name|rescode
parameter_list|,
name|int
name|gai_errno
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|res
parameter_list|)
block|{
name|settrap_parms
modifier|*
name|pstp
decl_stmt|;
name|struct
name|interface
modifier|*
name|localaddr
decl_stmt|;
name|sockaddr_u
name|peeraddr
decl_stmt|;
operator|(
name|void
operator|)
name|gai_errno
expr_stmt|;
operator|(
name|void
operator|)
name|service
expr_stmt|;
operator|(
name|void
operator|)
name|hints
expr_stmt|;
name|pstp
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|rescode
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"giving up resolving trap host %s: %s (%d)"
argument_list|,
name|name
argument_list|,
name|gai_strerror
argument_list|(
name|rescode
argument_list|)
argument_list|,
name|rescode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pstp
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|peeraddr
argument_list|)
operator|>=
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|peeraddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|localaddr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pstp
operator|->
name|ifaddr_nonnull
condition|)
name|localaddr
operator|=
name|findinterface
argument_list|(
operator|&
name|pstp
operator|->
name|ifaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|localaddr
condition|)
name|localaddr
operator|=
name|ANY_INTERFACE_CHOOSE
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctlsettrap
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|localaddr
argument_list|,
literal|0
argument_list|,
name|NTP_VERSION
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"set trap %s -> %s failed."
argument_list|,
name|latoa
argument_list|(
name|localaddr
argument_list|)
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pstp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WORKER */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_trap
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ADDR_OPTS_FIFO
argument_list|(
name|ptree
operator|->
name|trap
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_fudge
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|addr_opts_node
modifier|*
name|curr_fudge
decl_stmt|;
name|attr_val
modifier|*
name|curr_opt
decl_stmt|;
name|sockaddr_u
name|addr_sock
decl_stmt|;
name|address_node
modifier|*
name|addr_node
decl_stmt|;
name|struct
name|refclockstat
name|clock_stat
decl_stmt|;
name|int
name|err_flag
decl_stmt|;
name|curr_fudge
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|fudge
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|curr_fudge
operator|!=
name|NULL
condition|;
name|curr_fudge
operator|=
name|curr_fudge
operator|->
name|link
control|)
block|{
name|err_flag
operator|=
literal|0
expr_stmt|;
comment|/* Get the reference clock address and 		 * ensure that it is sane 		 */
name|addr_node
operator|=
name|curr_fudge
operator|->
name|addr
expr_stmt|;
name|ZERO_SOCK
argument_list|(
operator|&
name|addr_sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnetnum
argument_list|(
name|addr_node
operator|->
name|address
argument_list|,
operator|&
name|addr_sock
argument_list|,
literal|1
argument_list|,
name|t_REF
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|err_flag
operator|=
literal|1
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unrecognized fudge reference clock address %s, line ignored"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr_sock
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|addr_sock
argument_list|)
condition|)
block|{
name|err_flag
operator|=
literal|1
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"inappropriate address %s for the fudge command, line ignored"
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr_sock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Parse all the options to the fudge command */
name|ZERO
argument_list|(
name|clock_stat
argument_list|)
expr_stmt|;
name|curr_opt
operator|=
name|HEAD_PFIFO
argument_list|(
name|curr_fudge
operator|->
name|options
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|curr_opt
operator|!=
name|NULL
condition|;
name|curr_opt
operator|=
name|curr_opt
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|curr_opt
operator|->
name|attr
condition|)
block|{
case|case
name|T_Time1
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME1
expr_stmt|;
name|clock_stat
operator|.
name|fudgetime1
operator|=
name|curr_opt
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Time2
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME2
expr_stmt|;
name|clock_stat
operator|.
name|fudgetime2
operator|=
name|curr_opt
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Stratum
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL1
expr_stmt|;
name|clock_stat
operator|.
name|fudgeval1
operator|=
name|curr_opt
operator|->
name|value
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|T_Refid
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL2
expr_stmt|;
name|clock_stat
operator|.
name|fudgeval2
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|clock_stat
operator|.
name|fudgeval2
argument_list|,
name|curr_opt
operator|->
name|value
operator|.
name|s
argument_list|,
name|min
argument_list|(
name|strlen
argument_list|(
name|curr_opt
operator|->
name|value
operator|.
name|s
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Flag1
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG1
expr_stmt|;
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
condition|)
name|clock_stat
operator|.
name|flags
operator||=
name|CLK_FLAG1
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|CLK_FLAG1
expr_stmt|;
break|break;
case|case
name|T_Flag2
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG2
expr_stmt|;
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
condition|)
name|clock_stat
operator|.
name|flags
operator||=
name|CLK_FLAG2
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|CLK_FLAG2
expr_stmt|;
break|break;
case|case
name|T_Flag3
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG3
expr_stmt|;
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
condition|)
name|clock_stat
operator|.
name|flags
operator||=
name|CLK_FLAG3
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|CLK_FLAG3
expr_stmt|;
break|break;
case|case
name|T_Flag4
case|:
name|clock_stat
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG4
expr_stmt|;
if|if
condition|(
name|curr_opt
operator|->
name|value
operator|.
name|i
condition|)
name|clock_stat
operator|.
name|flags
operator||=
name|CLK_FLAG4
expr_stmt|;
else|else
name|clock_stat
operator|.
name|flags
operator|&=
operator|~
name|CLK_FLAG4
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unexpected fudge flag %s (%d) for %s"
argument_list|,
name|token_name
argument_list|(
name|curr_opt
operator|->
name|attr
argument_list|)
argument_list|,
name|curr_opt
operator|->
name|attr
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr_sock
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|curr_opt
operator|->
name|attr
condition|?
name|curr_opt
operator|->
name|attr
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
operator|!
name|err_flag
condition|)
name|refclock_control
argument_list|(
operator|&
name|addr_sock
argument_list|,
operator|&
name|clock_stat
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_fudge
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ADDR_OPTS_FIFO
argument_list|(
name|ptree
operator|->
name|fudge
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_function
specifier|static
name|void
name|config_vars
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|attr_val
modifier|*
name|curr_var
decl_stmt|;
name|int
name|len
decl_stmt|;
name|curr_var
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|vars
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|curr_var
operator|!=
name|NULL
condition|;
name|curr_var
operator|=
name|curr_var
operator|->
name|link
control|)
block|{
comment|/* Determine which variable to set and set it */
switch|switch
condition|(
name|curr_var
operator|->
name|attr
condition|)
block|{
case|case
name|T_Broadcastdelay
case|:
name|proto_config
argument_list|(
name|PROTO_BROADDELAY
argument_list|,
literal|0
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|d
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Tick
case|:
name|loop_config
argument_list|(
name|LOOP_TICK
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Driftfile
case|:
if|if
condition|(
literal|'\0'
operator|==
name|curr_var
operator|->
name|value
operator|.
name|s
index|[
literal|0
index|]
condition|)
block|{
name|stats_drift_file
operator|=
literal|0
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"config: driftfile disabled"
argument_list|)
expr_stmt|;
block|}
else|else
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Ident
case|:
name|sys_ident
operator|=
name|curr_var
operator|->
name|value
operator|.
name|s
expr_stmt|;
break|break;
case|case
name|T_WanderThreshold
case|:
comment|/* FALLTHROUGH */
case|case
name|T_Nonvolatile
case|:
name|wander_threshold
operator|=
name|curr_var
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Leapfile
case|:
name|stats_config
argument_list|(
name|STATS_LEAP_FILE
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Pidfile
case|:
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Logfile
case|:
if|if
condition|(
operator|-
literal|1
operator|==
name|change_logfile
argument_list|(
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|,
name|TRUE
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot open logfile %s: %m"
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Saveconfigdir
case|:
if|if
condition|(
name|saveconfigdir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|saveconfigdir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|len
condition|)
block|{
name|saveconfigdir
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DIR_SEP
operator|!=
name|curr_var
operator|->
name|value
operator|.
name|s
index|[
name|len
operator|-
literal|1
index|]
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* slash is also a dir. sep. on Windows */
operator|&&
literal|'/'
operator|!=
name|curr_var
operator|->
name|value
operator|.
name|s
index|[
name|len
operator|-
literal|1
index|]
endif|#
directive|endif
condition|)
block|{
name|len
operator|++
expr_stmt|;
name|saveconfigdir
operator|=
name|emalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|saveconfigdir
argument_list|,
name|len
operator|+
literal|1
argument_list|,
literal|"%s%c"
argument_list|,
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|,
name|DIR_SEP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saveconfigdir
operator|=
name|estrdup
argument_list|(
name|curr_var
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_Automax
case|:
ifdef|#
directive|ifdef
name|AUTOKEY
name|sys_automax
operator|=
name|curr_var
operator|->
name|value
operator|.
name|i
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"config_vars(): unexpected token %d"
argument_list|,
name|curr_var
operator|->
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_vars
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|ptree
operator|->
name|vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_comment
comment|/* Define a function to check if a resolved address is sane.  * If yes, return 1, else return 0;  */
end_comment

begin_function
specifier|static
name|int
name|is_sane_resolved_address
parameter_list|(
name|sockaddr_u
modifier|*
name|peeraddr
parameter_list|,
name|int
name|hmode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
name|peeraddr
argument_list|)
operator|&&
name|ISBADADR
argument_list|(
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|stoa
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Shouldn't be able to specify multicast 	 * address for server/peer! 	 * and unicast address for manycastclient! 	 */
if|if
condition|(
operator|(
name|T_Server
operator|==
name|hmode
operator|||
name|T_Peer
operator|==
name|hmode
operator|||
name|T_Pool
operator|==
name|hmode
operator|)
operator|&&
name|IS_MCAST
argument_list|(
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|stoa
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|T_Manycastclient
operator|==
name|hmode
operator|&&
operator|!
name|IS_MCAST
argument_list|(
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|stoa
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|IS_IPV6
argument_list|(
name|peeraddr
argument_list|)
operator|&&
operator|!
name|ipv6_works
condition|)
return|return
literal|0
return|;
comment|/* Ok, all tests succeeded, now we can return 1 */
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|u_char
name|get_correct_host_mode
parameter_list|(
name|int
name|token
parameter_list|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|T_Server
case|:
case|case
name|T_Pool
case|:
case|case
name|T_Manycastclient
case|:
return|return
name|MODE_CLIENT
return|;
case|case
name|T_Peer
case|:
return|return
name|MODE_ACTIVE
return|;
case|case
name|T_Broadcast
case|:
return|return
name|MODE_BROADCAST
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * peerflag_bits()	get config_peers() peerflags value from a  *			peer_node's queue of flag attr_val entries.  */
end_comment

begin_function
specifier|static
name|int
name|peerflag_bits
parameter_list|(
name|peer_node
modifier|*
name|pn
parameter_list|)
block|{
name|int
name|peerflags
decl_stmt|;
name|attr_val
modifier|*
name|option
decl_stmt|;
comment|/* translate peerflags options to bits */
name|peerflags
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|HEAD_PFIFO
argument_list|(
name|pn
operator|->
name|peerflags
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|option
operator|!=
name|NULL
condition|;
name|option
operator|=
name|option
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|option
operator|->
name|value
operator|.
name|i
condition|)
block|{
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Autokey
case|:
name|peerflags
operator||=
name|FLAG_SKEY
expr_stmt|;
break|break;
case|case
name|T_Burst
case|:
name|peerflags
operator||=
name|FLAG_BURST
expr_stmt|;
break|break;
case|case
name|T_Iburst
case|:
name|peerflags
operator||=
name|FLAG_IBURST
expr_stmt|;
break|break;
case|case
name|T_Noselect
case|:
name|peerflags
operator||=
name|FLAG_NOSELECT
expr_stmt|;
break|break;
case|case
name|T_Preempt
case|:
name|peerflags
operator||=
name|FLAG_PREEMPT
expr_stmt|;
break|break;
case|case
name|T_Prefer
case|:
name|peerflags
operator||=
name|FLAG_PREFER
expr_stmt|;
break|break;
case|case
name|T_True
case|:
name|peerflags
operator||=
name|FLAG_TRUE
expr_stmt|;
break|break;
case|case
name|T_Xleave
case|:
name|peerflags
operator||=
name|FLAG_XLEAVE
expr_stmt|;
break|break;
block|}
block|}
return|return
name|peerflags
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|config_peers
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|sockaddr_u
name|peeraddr
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|peer_node
modifier|*
name|curr_peer
decl_stmt|;
name|peer_resolved_ctx
modifier|*
name|ctx
decl_stmt|;
name|u_char
name|hmode
decl_stmt|;
comment|/* add servers named on the command line with iburst implied */
for|for
control|(
init|;
name|cmdline_server_count
operator|>
literal|0
condition|;
name|cmdline_server_count
operator|--
operator|,
name|cmdline_servers
operator|++
control|)
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
comment|/* 		 * If we have a numeric address, we can safely 		 * proceed in the mainline with it.  Otherwise, hand 		 * the hostname off to the blocking child. 		 */
if|if
condition|(
name|is_ip_address
argument_list|(
operator|*
name|cmdline_servers
argument_list|,
name|AF_UNSPEC
argument_list|,
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|SET_PORT
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|NTP_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sane_resolved_address
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|T_Server
argument_list|)
condition|)
name|peer_config
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MODE_CLIENT
argument_list|,
name|NTP_VERSION
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FLAG_IBURST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we have a hostname to resolve */
ifdef|#
directive|ifdef
name|WORKER
name|ctx
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ctx
operator|->
name|host_mode
operator|=
name|T_Server
expr_stmt|;
name|ctx
operator|->
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
name|ctx
operator|->
name|version
operator|=
name|NTP_VERSION
expr_stmt|;
name|ctx
operator|->
name|flags
operator|=
name|FLAG_IBURST
expr_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
operator|(
name|u_short
operator|)
name|ctx
operator|->
name|family
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|getaddrinfo_sometime
argument_list|(
operator|*
name|cmdline_servers
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
name|INITIAL_DNS_RETRY
argument_list|,
operator|&
name|peer_name_resolved
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ctx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !WORKER follows */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hostname %s can not be used, please use IP address instead."
argument_list|,
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* add associations from the configuration file */
name|curr_peer
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|peers
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|curr_peer
operator|!=
name|NULL
condition|;
name|curr_peer
operator|=
name|curr_peer
operator|->
name|link
control|)
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
comment|/* Find the correct host-mode */
name|hmode
operator|=
name|get_correct_host_mode
argument_list|(
name|curr_peer
operator|->
name|host_mode
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|hmode
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|T_Pool
operator|==
name|curr_peer
operator|->
name|host_mode
condition|)
block|{
name|AF
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|=
name|curr_peer
operator|->
name|addr
operator|->
name|type
expr_stmt|;
name|peer_config
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|,
name|NULL
argument_list|,
name|hmode
argument_list|,
name|curr_peer
operator|->
name|peerversion
argument_list|,
name|curr_peer
operator|->
name|minpoll
argument_list|,
name|curr_peer
operator|->
name|maxpoll
argument_list|,
name|peerflag_bits
argument_list|(
name|curr_peer
argument_list|)
argument_list|,
name|curr_peer
operator|->
name|ttl
argument_list|,
name|curr_peer
operator|->
name|peerkey
argument_list|,
name|curr_peer
operator|->
name|group
argument_list|)
expr_stmt|;
comment|/* 		 * If we have a numeric address, we can safely 		 * proceed in the mainline with it.  Otherwise, hand 		 * the hostname off to the blocking child. 		 */
block|}
elseif|else
if|if
condition|(
name|is_ip_address
argument_list|(
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|,
name|curr_peer
operator|->
name|addr
operator|->
name|type
argument_list|,
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|SET_PORT
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|NTP_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sane_resolved_address
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|curr_peer
operator|->
name|host_mode
argument_list|)
condition|)
name|peer_config
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|hmode
argument_list|,
name|curr_peer
operator|->
name|peerversion
argument_list|,
name|curr_peer
operator|->
name|minpoll
argument_list|,
name|curr_peer
operator|->
name|maxpoll
argument_list|,
name|peerflag_bits
argument_list|(
name|curr_peer
argument_list|)
argument_list|,
name|curr_peer
operator|->
name|ttl
argument_list|,
name|curr_peer
operator|->
name|peerkey
argument_list|,
name|curr_peer
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we have a hostname to resolve */
ifdef|#
directive|ifdef
name|WORKER
name|ctx
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|family
operator|=
name|curr_peer
operator|->
name|addr
operator|->
name|type
expr_stmt|;
name|ctx
operator|->
name|host_mode
operator|=
name|curr_peer
operator|->
name|host_mode
expr_stmt|;
name|ctx
operator|->
name|hmode
operator|=
name|hmode
expr_stmt|;
name|ctx
operator|->
name|version
operator|=
name|curr_peer
operator|->
name|peerversion
expr_stmt|;
name|ctx
operator|->
name|minpoll
operator|=
name|curr_peer
operator|->
name|minpoll
expr_stmt|;
name|ctx
operator|->
name|maxpoll
operator|=
name|curr_peer
operator|->
name|maxpoll
expr_stmt|;
name|ctx
operator|->
name|flags
operator|=
name|peerflag_bits
argument_list|(
name|curr_peer
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ttl
operator|=
name|curr_peer
operator|->
name|ttl
expr_stmt|;
name|ctx
operator|->
name|keyid
operator|=
name|curr_peer
operator|->
name|peerkey
expr_stmt|;
name|ctx
operator|->
name|group
operator|=
name|curr_peer
operator|->
name|group
expr_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|ctx
operator|->
name|family
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|getaddrinfo_sometime
argument_list|(
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
name|INITIAL_DNS_RETRY
argument_list|,
operator|&
name|peer_name_resolved
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !WORKER follows */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hostname %s can not be used, please use IP address instead."
argument_list|,
name|curr_peer
operator|->
name|addr
operator|->
name|address
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_comment
comment|/*  * peer_name_resolved()  *  * Callback invoked when config_peers()'s DNS lookup completes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WORKER
end_ifdef

begin_function
specifier|static
name|void
name|peer_name_resolved
parameter_list|(
name|int
name|rescode
parameter_list|,
name|int
name|gai_errno
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|res
parameter_list|)
block|{
name|sockaddr_u
name|peeraddr
decl_stmt|;
name|peer_resolved_ctx
modifier|*
name|ctx
decl_stmt|;
name|u_short
name|af
decl_stmt|;
specifier|const
name|char
modifier|*
name|fam_spec
decl_stmt|;
operator|(
name|void
operator|)
name|gai_errno
expr_stmt|;
operator|(
name|void
operator|)
name|service
expr_stmt|;
operator|(
name|void
operator|)
name|hints
expr_stmt|;
name|ctx
operator|=
name|context
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"peer_name_resolved(%s) rescode %d\n"
operator|,
name|name
operator|,
name|rescode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rescode
condition|)
block|{
ifndef|#
directive|ifndef
name|IGNORE_DNS_ERRORS
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"giving up resolving host %s: %s (%d)"
argument_list|,
name|name
argument_list|,
name|gai_strerror
argument_list|(
name|rescode
argument_list|)
argument_list|,
name|rescode
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IGNORE_DNS_ERRORS follows */
name|getaddrinfo_sometime
argument_list|(
name|name
argument_list|,
name|service
argument_list|,
name|hints
argument_list|,
name|INITIAL_DNS_RETRY
argument_list|,
operator|&
name|peer_name_resolved
argument_list|,
name|context
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* Loop to configure a single association */
for|for
control|(
init|;
name|res
operator|!=
name|NULL
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sane_resolved_address
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|ctx
operator|->
name|host_mode
argument_list|)
condition|)
block|{
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
block|{
name|af
operator|=
name|ctx
operator|->
name|family
expr_stmt|;
name|fam_spec
operator|=
operator|(
name|AF_INET6
operator|==
name|af
operator|)
condition|?
literal|"(AAAA) "
else|:
operator|(
name|AF_INET
operator|==
name|af
operator|)
condition|?
literal|"(A) "
else|:
literal|""
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DNS %s %s-> %s"
argument_list|,
name|name
argument_list|,
name|fam_spec
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|peer_config
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|hmode
argument_list|,
name|ctx
operator|->
name|version
argument_list|,
name|ctx
operator|->
name|minpoll
argument_list|,
name|ctx
operator|->
name|maxpoll
argument_list|,
name|ctx
operator|->
name|flags
argument_list|,
name|ctx
operator|->
name|ttl
argument_list|,
name|ctx
operator|->
name|keyid
argument_list|,
name|ctx
operator|->
name|group
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WORKER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_peers
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|peer_node
modifier|*
name|curr_peer
decl_stmt|;
if|if
condition|(
name|ptree
operator|->
name|peers
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|curr_peer
argument_list|,
operator|*
name|ptree
operator|->
name|peers
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|curr_peer
condition|)
break|break;
name|destroy_address_node
argument_list|(
name|curr_peer
operator|->
name|addr
argument_list|)
expr_stmt|;
name|destroy_attr_val_fifo
argument_list|(
name|curr_peer
operator|->
name|peerflags
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curr_peer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ptree
operator|->
name|peers
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|peers
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_unpeers
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|sockaddr_u
name|peeraddr
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|unpeer_node
modifier|*
name|curr_unpeer
decl_stmt|;
name|struct
name|peer
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|curr_unpeer
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|unpeers
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|curr_unpeer
operator|!=
name|NULL
condition|;
name|curr_unpeer
operator|=
name|curr_unpeer
operator|->
name|link
control|)
block|{
comment|/* 		 * Either AssocID will be zero, and we unpeer by name/ 		 * address addr, or it is nonzero and addr NULL. 		 */
if|if
condition|(
name|curr_unpeer
operator|->
name|assocID
condition|)
block|{
name|p
operator|=
name|findpeerbyassoc
argument_list|(
name|curr_unpeer
operator|->
name|assocID
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"unpeered %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|p
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|peer_clear
argument_list|(
name|p
argument_list|,
literal|"GONE"
argument_list|)
expr_stmt|;
name|unpeer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|ZERO
argument_list|(
name|peeraddr
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|=
name|curr_unpeer
operator|->
name|addr
operator|->
name|type
expr_stmt|;
name|name
operator|=
name|curr_unpeer
operator|->
name|addr
operator|->
name|address
expr_stmt|;
name|rc
operator|=
name|getnetnum
argument_list|(
name|name
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|,
name|t_UNK
argument_list|)
expr_stmt|;
comment|/* Do we have a numeric address? */
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"unpeer: searching for %s\n"
operator|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|findexistingpeer
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"unpeered %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|peer_clear
argument_list|(
name|p
argument_list|,
literal|"GONE"
argument_list|)
expr_stmt|;
name|unpeer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * It's not a numeric IP address, it's a hostname. 		 * Check for associations with a matching hostname. 		 */
for|for
control|(
name|p
operator|=
name|peer_list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|p_link
control|)
if|if
condition|(
name|p
operator|->
name|hostname
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|p
operator|->
name|hostname
argument_list|,
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"unpeered %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|peer_clear
argument_list|(
name|p
argument_list|,
literal|"GONE"
argument_list|)
expr_stmt|;
name|unpeer
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Resolve the hostname to address(es). */
ifdef|#
directive|ifdef
name|WORKER
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|curr_unpeer
operator|->
name|addr
operator|->
name|type
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|getaddrinfo_sometime
argument_list|(
name|name
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
name|INITIAL_DNS_RETRY
argument_list|,
operator|&
name|unpeer_name_resolved
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !WORKER follows */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hostname %s can not be used, please use IP address instead."
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_comment
comment|/*  * unpeer_name_resolved()  *  * Callback invoked when config_unpeers()'s DNS lookup completes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WORKER
end_ifdef

begin_function
specifier|static
name|void
name|unpeer_name_resolved
parameter_list|(
name|int
name|rescode
parameter_list|,
name|int
name|gai_errno
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|res
parameter_list|)
block|{
name|sockaddr_u
name|peeraddr
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|u_short
name|af
decl_stmt|;
specifier|const
name|char
modifier|*
name|fam_spec
decl_stmt|;
operator|(
name|void
operator|)
name|context
expr_stmt|;
operator|(
name|void
operator|)
name|hints
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"unpeer_name_resolved(%s) rescode %d\n"
operator|,
name|name
operator|,
name|rescode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rescode
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"giving up resolving unpeer %s: %s (%d)"
argument_list|,
name|name
argument_list|,
name|gai_strerror
argument_list|(
name|rescode
argument_list|)
argument_list|,
name|rescode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Loop through the addresses found 	 */
for|for
control|(
init|;
name|res
operator|!=
name|NULL
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
name|INSIST
argument_list|(
name|res
operator|->
name|ai_addrlen
operator|<=
sizeof|sizeof
argument_list|(
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"unpeer: searching for peer %s\n"
operator|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|peer
operator|=
name|findexistingpeer
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
block|{
name|af
operator|=
name|AF
argument_list|(
operator|&
name|peeraddr
argument_list|)
expr_stmt|;
name|fam_spec
operator|=
operator|(
name|AF_INET6
operator|==
name|af
operator|)
condition|?
literal|"(AAAA) "
else|:
operator|(
name|AF_INET
operator|==
name|af
operator|)
condition|?
literal|"(A) "
else|:
literal|""
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"unpeered %s %s-> %s"
argument_list|,
name|name
argument_list|,
name|fam_spec
argument_list|,
name|stoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|peer_clear
argument_list|(
name|peer
argument_list|,
literal|"GONE"
argument_list|)
expr_stmt|;
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WORKER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_unpeers
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|unpeer_node
modifier|*
name|curr_unpeer
decl_stmt|;
if|if
condition|(
name|ptree
operator|->
name|unpeers
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|curr_unpeer
argument_list|,
operator|*
name|ptree
operator|->
name|unpeers
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|curr_unpeer
condition|)
break|break;
name|destroy_address_node
argument_list|(
name|curr_unpeer
operator|->
name|addr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curr_unpeer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ptree
operator|->
name|unpeers
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_reset_counters
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|int_node
modifier|*
name|counter_set
decl_stmt|;
for|for
control|(
name|counter_set
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|reset_counters
argument_list|)
init|;
name|counter_set
operator|!=
name|NULL
condition|;
name|counter_set
operator|=
name|counter_set
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|counter_set
operator|->
name|i
condition|)
block|{
default|default:
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"config_reset_counters %s (%d) invalid\n"
operator|,
name|keyword
argument_list|(
name|counter_set
operator|->
name|i
argument_list|)
operator|,
name|counter_set
operator|->
name|i
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_Allpeers
case|:
name|peer_all_reset
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_Auth
case|:
name|reset_auth_stats
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_Ctl
case|:
name|ctl_clr_stats
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_Io
case|:
name|io_clr_stats
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_Mem
case|:
name|peer_clr_stats
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_Sys
case|:
name|proto_clr_stats
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_Timer
case|:
name|timer_clr_stats
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_reset_counters
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|FREE_INT_FIFO
argument_list|(
name|ptree
operator|->
name|reset_counters
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function
specifier|static
name|void
name|config_sim
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|server_info
modifier|*
name|serv_info
decl_stmt|;
name|attr_val
modifier|*
name|init_stmt
decl_stmt|;
name|sim_node
modifier|*
name|sim_n
decl_stmt|;
comment|/* Check if a simulate block was found in the configuration code. 	 * If not, return an error and exit 	 */
name|sim_n
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|sim_details
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|sim_n
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR!! I couldn't find a \"simulate\" block for configuring the simulator.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tCheck your configuration file.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Process the initialization statements 	 * ------------------------------------- 	 */
name|init_stmt
operator|=
name|HEAD_PFIFO
argument_list|(
name|sim_n
operator|->
name|init_opts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|init_stmt
operator|!=
name|NULL
condition|;
name|init_stmt
operator|=
name|init_stmt
operator|->
name|link
control|)
block|{
switch|switch
condition|(
name|init_stmt
operator|->
name|attr
condition|)
block|{
case|case
name|T_Beep_Delay
case|:
name|simulation
operator|.
name|beep_delay
operator|=
name|init_stmt
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
case|case
name|T_Sim_Duration
case|:
name|simulation
operator|.
name|end_time
operator|=
name|init_stmt
operator|->
name|value
operator|.
name|d
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown simulator init token %d\n"
argument_list|,
name|init_stmt
operator|->
name|attr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the server list 	 * ----------------------- 	 */
name|simulation
operator|.
name|num_of_servers
operator|=
literal|0
expr_stmt|;
name|serv_info
operator|=
name|HEAD_PFIFO
argument_list|(
name|sim_n
operator|->
name|servers
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|serv_info
operator|!=
name|NULL
condition|;
name|serv_info
operator|=
name|serv_info
operator|->
name|link
control|)
name|simulation
operator|.
name|num_of_servers
operator|++
expr_stmt|;
name|simulation
operator|.
name|servers
operator|=
name|emalloc
argument_list|(
name|simulation
operator|.
name|num_of_servers
operator|*
sizeof|sizeof
argument_list|(
name|simulation
operator|.
name|servers
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|serv_info
operator|=
name|HEAD_PFIFO
argument_list|(
name|sim_n
operator|->
name|servers
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|serv_info
operator|!=
name|NULL
condition|;
name|serv_info
operator|=
name|serv_info
operator|->
name|link
control|)
block|{
if|if
condition|(
name|NULL
operator|==
name|serv_info
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Simulator server list is corrupt\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|=
operator|*
name|serv_info
expr_stmt|;
name|simulation
operator|.
name|servers
index|[
name|i
index|]
operator|.
name|link
operator|=
name|NULL
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"Creating server associations\n"
argument_list|)
expr_stmt|;
name|create_server_associations
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tServer associations successfully created!!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FREE_CFG_T
end_ifdef

begin_function
specifier|static
name|void
name|free_config_sim
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|sim_node
modifier|*
name|sim_n
decl_stmt|;
name|server_info
modifier|*
name|serv_n
decl_stmt|;
name|script_info
modifier|*
name|script_n
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ptree
operator|->
name|sim_details
condition|)
return|return;
name|sim_n
operator|=
name|HEAD_PFIFO
argument_list|(
name|ptree
operator|->
name|sim_details
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptree
operator|->
name|sim_details
argument_list|)
expr_stmt|;
name|ptree
operator|->
name|sim_details
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|sim_n
condition|)
return|return;
name|FREE_ATTR_VAL_FIFO
argument_list|(
name|sim_n
operator|->
name|init_opts
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|serv_n
argument_list|,
operator|*
name|sim_n
operator|->
name|servers
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|serv_n
condition|)
break|break;
name|free
argument_list|(
name|serv_n
operator|->
name|curr_script
argument_list|)
expr_stmt|;
if|if
condition|(
name|serv_n
operator|->
name|script
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNLINK_FIFO
argument_list|(
name|script_n
argument_list|,
operator|*
name|serv_n
operator|->
name|script
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|script_n
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|script_n
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|serv_n
operator|->
name|script
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|serv_n
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sim_n
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FREE_CFG_T */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIM */
end_comment

begin_comment
comment|/* Define two different config functions. One for the daemon and the other for  * the simulator. The simulator ignores a lot of the standard ntpd configuration  * options  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|void
name|config_ntpd
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|config_nic_rules
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|io_open_sockets
argument_list|()
expr_stmt|;
name|config_monitor
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_auth
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_tos
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_access
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_tinker
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_rlimit
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_system_opts
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_logconfig
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_phone
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_setvar
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_ttl
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_trap
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_vars
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_other_modes
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_peers
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_unpeers
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_fudge
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_reset_counters
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TEST_BLOCKING_WORKER
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|getaddrinfo_sometime
argument_list|(
literal|"www.cnn.com"
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
name|INITIAL_DNS_RETRY
argument_list|,
name|gai_test_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
name|getaddrinfo_sometime
argument_list|(
literal|"ipv6.google.com"
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
name|INITIAL_DNS_RETRY
argument_list|,
name|gai_test_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0x600
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIM
end_ifdef

begin_function
specifier|static
name|void
name|config_ntpdsim
parameter_list|(
name|config_tree
modifier|*
name|ptree
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Configuring Simulator...\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Some ntpd-specific commands in the configuration file will be ignored.\n"
argument_list|)
expr_stmt|;
name|config_tos
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_monitor
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_tinker
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|config_rlimit
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
comment|/* not needed for the simulator */
name|config_system_opts
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_logconfig
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_vars
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
name|config_sim
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIM */
end_comment

begin_comment
comment|/*  * config_remotely() - implements ntpd side of ntpq :config  */
end_comment

begin_function
name|void
name|config_remotely
parameter_list|(
name|sockaddr_u
modifier|*
name|remote_addr
parameter_list|)
block|{
name|struct
name|FILE_INFO
name|remote_cuckoo
decl_stmt|;
name|char
name|origin
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|,
literal|"remote config from %s"
argument_list|,
name|stoa
argument_list|(
name|remote_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|remote_cuckoo
argument_list|)
expr_stmt|;
name|remote_cuckoo
operator|.
name|fname
operator|=
name|origin
expr_stmt|;
name|remote_cuckoo
operator|.
name|line_no
operator|=
literal|1
expr_stmt|;
name|remote_cuckoo
operator|.
name|col_no
operator|=
literal|1
expr_stmt|;
name|input_from_file
operator|=
literal|0
expr_stmt|;
name|init_syntax_tree
argument_list|(
operator|&
name|cfgt
argument_list|)
expr_stmt|;
name|yyparse
argument_list|(
operator|&
name|remote_cuckoo
argument_list|)
expr_stmt|;
name|cfgt
operator|.
name|source
operator|.
name|attr
operator|=
name|CONF_SOURCE_NTPQ
expr_stmt|;
name|cfgt
operator|.
name|timestamp
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|cfgt
operator|.
name|source
operator|.
name|value
operator|.
name|s
operator|=
name|estrdup
argument_list|(
name|stoa
argument_list|(
name|remote_addr
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Finished Parsing!!\n"
operator|)
argument_list|)
expr_stmt|;
name|save_and_apply_config_tree
argument_list|()
expr_stmt|;
name|input_from_file
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * getconfig() - process startup configuration file e.g /etc/ntp.conf  */
end_comment

begin_function
name|void
name|getconfig
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
name|free_all_config_trees
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SYS_WINNT
name|config_file
operator|=
name|CONFIG_FILE
expr_stmt|;
else|#
directive|else
name|temp
operator|=
name|CONFIG_FILE
expr_stmt|;
if|if
condition|(
operator|!
name|ExpandEnvironmentStringsA
argument_list|(
name|temp
argument_list|,
name|config_file_storage
argument_list|,
sizeof|sizeof
argument_list|(
name|config_file_storage
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings CONFIG_FILE failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|config_file
operator|=
name|config_file_storage
expr_stmt|;
name|temp
operator|=
name|ALT_CONFIG_FILE
expr_stmt|;
if|if
condition|(
operator|!
name|ExpandEnvironmentStringsA
argument_list|(
name|temp
argument_list|,
name|alt_config_file_storage
argument_list|,
sizeof|sizeof
argument_list|(
name|alt_config_file_storage
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings ALT_CONFIG_FILE failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|alt_config_file
operator|=
name|alt_config_file_storage
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * install a non default variable with this daemon version 	 */
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"daemon_version=\"%s\""
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
expr_stmt|;
comment|/* 	 * Set up for the first time step to install a variable showing 	 * which syscall is being used to step. 	 */
name|set_tod_using
operator|=
operator|&
name|ntpd_set_tod_using
expr_stmt|;
name|getCmdOpts
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|init_syntax_tree
argument_list|(
operator|&
name|cfgt
argument_list|)
expr_stmt|;
name|curr_include_level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fp
index|[
name|curr_include_level
index|]
operator|=
name|F_OPEN
argument_list|(
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
ifdef|#
directive|ifdef
name|HAVE_NETINFO
comment|/* If there is no config_file, try NetInfo. */
operator|&&
name|check_netinfo
operator|&&
operator|!
operator|(
name|config_netinfo
operator|=
name|get_netinfo_config
argument_list|()
operator|)
endif|#
directive|endif
comment|/* HAVE_NETINFO */
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
name|io_open_sockets
argument_list|()
expr_stmt|;
return|return;
else|#
directive|else
comment|/* Under WinNT try alternate_config_file name, first NTP.CONF, then NTP.INI */
if|if
condition|(
operator|(
name|fp
index|[
name|curr_include_level
index|]
operator|=
name|F_OPEN
argument_list|(
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Broadcast clients can sometimes run without 			 * a configuration file. 			 */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|)
expr_stmt|;
name|io_open_sockets
argument_list|()
expr_stmt|;
return|return;
block|}
name|cfgt
operator|.
name|source
operator|.
name|value
operator|.
name|s
operator|=
name|estrdup
argument_list|(
name|alt_config_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
else|else
name|cfgt
operator|.
name|source
operator|.
name|value
operator|.
name|s
operator|=
name|estrdup
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
comment|/*** BULK OF THE PARSER ***/
ifdef|#
directive|ifdef
name|DEBUG
name|yydebug
operator|=
operator|!
operator|!
operator|(
name|debug
operator|>=
literal|5
operator|)
expr_stmt|;
endif|#
directive|endif
name|yyparse
argument_list|(
name|fp
index|[
name|curr_include_level
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Finished Parsing!!\n"
operator|)
argument_list|)
expr_stmt|;
name|cfgt
operator|.
name|source
operator|.
name|attr
operator|=
name|CONF_SOURCE_FILE
expr_stmt|;
name|cfgt
operator|.
name|timestamp
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|save_and_apply_config_tree
argument_list|()
expr_stmt|;
while|while
condition|(
name|curr_include_level
operator|!=
operator|-
literal|1
condition|)
name|FCLOSE
argument_list|(
name|fp
index|[
name|curr_include_level
operator|--
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NETINFO
if|if
condition|(
name|config_netinfo
condition|)
name|free_netinfo_config
argument_list|(
name|config_netinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NETINFO */
block|}
end_function

begin_function
name|void
name|save_and_apply_config_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|config_tree
modifier|*
name|ptree
decl_stmt|;
ifndef|#
directive|ifndef
name|SAVECONFIG
name|config_tree
modifier|*
name|punlinked
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Keep all the configuration trees applied since startup in 	 * a list that can be used to dump the configuration back to 	 * a text file. 	 */
name|ptree
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ptree
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptree
argument_list|,
operator|&
name|cfgt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ptree
argument_list|)
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|cfgt
argument_list|)
expr_stmt|;
name|LINK_TAIL_SLIST
argument_list|(
name|cfg_tree_history
argument_list|,
name|ptree
argument_list|,
name|link
argument_list|,
name|config_tree
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVECONFIG
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|dumpfailed
decl_stmt|;
name|dumpfile
operator|=
name|fopen
argument_list|(
name|OPT_ARG
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|dumpfile
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|mfprintf
argument_list|(
name|stderr
argument_list|,
literal|"can not create save file %s, error %d %m\n"
argument_list|,
name|OPT_ARG
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|dumpfailed
operator|=
name|dump_all_config_trees
argument_list|(
name|dumpfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumpfailed
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--saveconfigquit %s error %d\n"
argument_list|,
name|OPT_ARG
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
argument_list|,
name|dumpfailed
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"configuration saved to %s\n"
argument_list|,
name|OPT_ARG
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|dumpfailed
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SAVECONFIG */
comment|/* The actual configuration done depends on whether we are configuring the 	 * simulator or the daemon. Perform a check and call the appropriate 	 * function as needed. 	 */
ifndef|#
directive|ifndef
name|SIM
name|config_ntpd
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
else|#
directive|else
name|config_ntpdsim
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * With configure --disable-saveconfig, there's no use keeping 	 * the config tree around after application, so free it. 	 */
ifndef|#
directive|ifndef
name|SAVECONFIG
name|UNLINK_SLIST
argument_list|(
name|punlinked
argument_list|,
name|cfg_tree_history
argument_list|,
name|ptree
argument_list|,
name|link
argument_list|,
name|config_tree
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|punlinked
operator|==
name|ptree
argument_list|)
expr_stmt|;
name|free_config_tree
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ntpd_set_tod_using
parameter_list|(
specifier|const
name|char
modifier|*
name|which
parameter_list|)
block|{
name|char
name|line
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"settimeofday=\"%s\""
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|normal_dtoa
parameter_list|(
name|double
name|d
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|pch_e
decl_stmt|;
name|char
modifier|*
name|pch_nz
decl_stmt|;
name|LIB_GETBUF
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
literal|"%g"
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* use lowercase 'e', strip any leading zeroes in exponent */
name|pch_e
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pch_e
condition|)
block|{
name|pch_e
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pch_e
condition|)
return|return
name|buf
return|;
operator|*
name|pch_e
operator|=
literal|'e'
expr_stmt|;
block|}
name|pch_e
operator|++
expr_stmt|;
if|if
condition|(
literal|'-'
operator|==
operator|*
name|pch_e
condition|)
name|pch_e
operator|++
expr_stmt|;
name|pch_nz
operator|=
name|pch_e
expr_stmt|;
while|while
condition|(
literal|'0'
operator|==
operator|*
name|pch_nz
condition|)
name|pch_nz
operator|++
expr_stmt|;
if|if
condition|(
name|pch_nz
operator|==
name|pch_e
condition|)
return|return
name|buf
return|;
name|strlcpy
argument_list|(
name|pch_e
argument_list|,
name|pch_nz
argument_list|,
name|LIB_BUFLENGTH
operator|-
operator|(
name|pch_e
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* FUNCTIONS COPIED FROM THE OLDER ntp_config.c  * --------------------------------------------  */
end_comment

begin_comment
comment|/*  * get_pfxmatch - find value for prefixmatch  * and update char * accordingly  */
end_comment

begin_function
specifier|static
name|u_int32
name|get_pfxmatch
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pstr
parameter_list|,
name|struct
name|masks
modifier|*
name|m
parameter_list|)
block|{
while|while
condition|(
name|m
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|pstr
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|m
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pstr
operator|+=
name|strlen
argument_list|(
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|m
operator|->
name|mask
return|;
block|}
else|else
block|{
name|m
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_match - find logmask value  */
end_comment

begin_function
specifier|static
name|u_int32
name|get_match
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|masks
modifier|*
name|m
parameter_list|)
block|{
while|while
condition|(
name|m
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|m
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|m
operator|->
name|mask
return|;
else|else
name|m
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_logmask - build bitmask for ntp_syslogmask  */
end_comment

begin_function
specifier|static
name|u_int32
name|get_logmask
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
name|u_int32
name|offset
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
name|mask
operator|=
name|get_match
argument_list|(
name|str
argument_list|,
name|logcfg_noclass_items
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
return|return
name|mask
return|;
name|t
operator|=
name|str
expr_stmt|;
name|offset
operator|=
name|get_pfxmatch
argument_list|(
operator|&
name|t
argument_list|,
name|logcfg_class
argument_list|)
expr_stmt|;
name|mask
operator|=
name|get_match
argument_list|(
name|t
argument_list|,
name|logcfg_class_items
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
return|return
name|mask
operator|<<
name|offset
return|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"logconfig: '%s' not recognized - ignored"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_comment
comment|/*  * get_netinfo_config - find the nearest NetInfo domain with an ntp  * configuration and initialize the configuration state.  */
end_comment

begin_function
specifier|static
name|struct
name|netinfo_config_state
modifier|*
name|get_netinfo_config
parameter_list|(
name|void
parameter_list|)
block|{
name|ni_status
name|status
decl_stmt|;
name|void
modifier|*
name|domain
decl_stmt|;
name|ni_id
name|config_dir
decl_stmt|;
name|struct
name|netinfo_config_state
modifier|*
name|config
decl_stmt|;
if|if
condition|(
name|ni_open
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|,
operator|&
name|domain
argument_list|)
operator|!=
name|NI_OK
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|(
name|status
operator|=
name|ni_pathsearch
argument_list|(
name|domain
argument_list|,
operator|&
name|config_dir
argument_list|,
name|NETINFO_CONFIG_DIR
argument_list|)
operator|)
operator|==
name|NI_NODIR
condition|)
block|{
name|void
modifier|*
name|next_domain
decl_stmt|;
if|if
condition|(
name|ni_open
argument_list|(
name|domain
argument_list|,
literal|".."
argument_list|,
operator|&
name|next_domain
argument_list|)
operator|!=
name|NI_OK
condition|)
block|{
name|ni_free
argument_list|(
name|next_domain
argument_list|)
expr_stmt|;
break|break;
block|}
name|ni_free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|domain
operator|=
name|next_domain
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|NI_OK
condition|)
block|{
name|ni_free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|config
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
name|config
operator|->
name|config_dir
operator|=
name|config_dir
expr_stmt|;
name|config
operator|->
name|prop_index
operator|=
literal|0
expr_stmt|;
name|config
operator|->
name|val_index
operator|=
literal|0
expr_stmt|;
name|config
operator|->
name|val_list
operator|=
name|NULL
expr_stmt|;
return|return
name|config
return|;
block|}
end_function

begin_comment
comment|/*  * free_netinfo_config - release NetInfo configuration state  */
end_comment

begin_function
specifier|static
name|void
name|free_netinfo_config
parameter_list|(
name|struct
name|netinfo_config_state
modifier|*
name|config
parameter_list|)
block|{
name|ni_free
argument_list|(
name|config
operator|->
name|domain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * gettokens_netinfo - return tokens from NetInfo  */
end_comment

begin_function
specifier|static
name|int
name|gettokens_netinfo
parameter_list|(
name|struct
name|netinfo_config_state
modifier|*
name|config
parameter_list|,
name|char
modifier|*
modifier|*
name|tokenlist
parameter_list|,
name|int
modifier|*
name|ntokens
parameter_list|)
block|{
name|int
name|prop_index
init|=
name|config
operator|->
name|prop_index
decl_stmt|;
name|int
name|val_index
init|=
name|config
operator|->
name|val_index
decl_stmt|;
name|char
modifier|*
modifier|*
name|val_list
init|=
name|config
operator|->
name|val_list
decl_stmt|;
comment|/* 	 * Iterate through each keyword and look for a property that matches it. 	 */
name|again
label|:
if|if
condition|(
operator|!
name|val_list
condition|)
block|{
for|for
control|(
init|;
name|prop_index
operator|<
name|COUNTOF
argument_list|(
name|keywords
argument_list|)
condition|;
name|prop_index
operator|++
control|)
block|{
name|ni_namelist
name|namelist
decl_stmt|;
name|struct
name|keyword
name|current_prop
init|=
name|keywords
index|[
name|prop_index
index|]
decl_stmt|;
name|ni_index
name|index
decl_stmt|;
comment|/* 			 * For each value associated in the property, we're going to return 			 * a separate line. We squirrel away the values in the config state 			 * so the next time through, we don't need to do this lookup. 			 */
name|NI_INIT
argument_list|(
operator|&
name|namelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|NI_OK
operator|==
name|ni_lookupprop
argument_list|(
name|config
operator|->
name|domain
argument_list|,
operator|&
name|config
operator|->
name|config_dir
argument_list|,
name|current_prop
operator|.
name|text
argument_list|,
operator|&
name|namelist
argument_list|)
condition|)
block|{
comment|/* Found the property, but it has no values */
if|if
condition|(
name|namelist
operator|.
name|ni_namelist_len
operator|==
literal|0
condition|)
continue|continue;
name|config
operator|->
name|val_list
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|namelist
operator|.
name|ni_namelist_len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|val_list
operator|=
name|config
operator|->
name|val_list
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|namelist
operator|.
name|ni_namelist_len
condition|;
name|index
operator|++
control|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|namelist
operator|.
name|ni_namelist_val
index|[
name|index
index|]
expr_stmt|;
name|val_list
index|[
name|index
index|]
operator|=
name|estrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|val_list
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|ni_namelist_free
argument_list|(
operator|&
name|namelist
argument_list|)
expr_stmt|;
block|}
name|config
operator|->
name|prop_index
operator|=
name|prop_index
expr_stmt|;
block|}
comment|/* No list; we're done here. */
if|if
condition|(
operator|!
name|val_list
condition|)
return|return
name|CONFIG_UNKNOWN
return|;
comment|/* 	 * We have a list of values for the current property. 	 * Iterate through them and return each in order. 	 */
if|if
condition|(
name|val_list
index|[
name|val_index
index|]
condition|)
block|{
name|int
name|ntok
init|=
literal|1
decl_stmt|;
name|int
name|quoted
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tokens
init|=
name|val_list
index|[
name|val_index
index|]
decl_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s %s"
argument_list|,
name|keywords
index|[
name|prop_index
index|]
operator|.
name|text
argument_list|,
name|val_list
index|[
name|val_index
index|]
argument_list|)
expr_stmt|;
operator|(
specifier|const
name|char
operator|*
operator|)
name|tokenlist
index|[
literal|0
index|]
operator|=
name|keywords
index|[
name|prop_index
index|]
operator|.
name|text
expr_stmt|;
for|for
control|(
name|ntok
operator|=
literal|1
init|;
name|ntok
operator|<
name|MAXTOKENS
condition|;
name|ntok
operator|++
control|)
block|{
name|tokenlist
index|[
name|ntok
index|]
operator|=
name|tokens
expr_stmt|;
while|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|tokens
argument_list|)
operator|||
name|quoted
operator|)
condition|)
name|quoted
operator|^=
operator|(
operator|*
name|tokens
operator|++
operator|==
literal|'"'
operator|)
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
block|{
operator|*
name|tokens
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* must be space */
operator|*
name|tokens
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
name|tokens
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|tokens
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|ntok
operator|==
name|MAXTOKENS
condition|)
block|{
comment|/* HMS: chomp it to lose the EOL? */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettokens_netinfo: too many tokens.  Ignoring: %s"
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ntokens
operator|=
name|ntok
operator|+
literal|1
expr_stmt|;
block|}
name|config
operator|->
name|val_index
operator|++
expr_stmt|;
comment|/* HMS: Should this be in the 'else'? */
return|return
name|keywords
index|[
name|prop_index
index|]
operator|.
name|keytype
return|;
block|}
comment|/* We're done with the current property. */
name|prop_index
operator|=
operator|++
name|config
operator|->
name|prop_index
expr_stmt|;
comment|/* Free val_list and reset counters. */
for|for
control|(
name|val_index
operator|=
literal|0
init|;
name|val_list
index|[
name|val_index
index|]
condition|;
name|val_index
operator|++
control|)
name|free
argument_list|(
name|val_list
index|[
name|val_index
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val_list
argument_list|)
expr_stmt|;
name|val_list
operator|=
name|config
operator|->
name|val_list
operator|=
name|NULL
expr_stmt|;
name|val_index
operator|=
name|config
operator|->
name|val_index
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_comment
comment|/*  * getnetnum - return a net number (this is crude, but careful)  *  * returns 1 for success, and mysteriously, 0 for most failures, and  * -1 if the address found is IPv6 and we believe IPv6 isn't working.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_function
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|num
parameter_list|,
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|int
name|complain
parameter_list|,
name|enum
name|gnn_type
name|a_type
comment|/* ignored */
parameter_list|)
block|{
name|NTP_REQUIRE
argument_list|(
name|AF_UNSPEC
operator|==
name|AF
argument_list|(
name|addr
argument_list|)
operator|||
name|AF_INET
operator|==
name|AF
argument_list|(
name|addr
argument_list|)
operator|||
name|AF_INET6
operator|==
name|AF
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_ip_address
argument_list|(
name|num
argument_list|,
name|AF
argument_list|(
name|addr
argument_list|)
argument_list|,
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|IS_IPV6
argument_list|(
name|addr
argument_list|)
operator|&&
operator|!
name|ipv6_works
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESALEN
name|addr
operator|->
name|sa
operator|.
name|sa_len
operator|=
name|SIZEOF_SOCKADDR
argument_list|(
name|AF
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SET_PORT
argument_list|(
name|addr
argument_list|,
name|NTP_PORT
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"getnetnum given %s, got %s\n"
operator|,
name|num
operator|,
name|stoa
argument_list|(
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SIM */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETRLIMIT
argument_list|)
end_if

begin_function
name|void
name|ntp_rlimit
parameter_list|(
name|int
name|rl_what
parameter_list|,
name|rlim_t
name|rl_value
parameter_list|,
name|int
name|rl_scale
parameter_list|,
name|char
modifier|*
name|rl_sstr
parameter_list|)
block|{
name|struct
name|rlimit
name|rl
decl_stmt|;
switch|switch
condition|(
name|rl_what
condition|)
block|{
ifdef|#
directive|ifdef
name|RLIMIT_MEMLOCK
case|case
name|RLIMIT_MEMLOCK
case|:
comment|/* 		 * The default RLIMIT_MEMLOCK is very low on Linux systems. 		 * Unless we increase this limit malloc calls are likely to 		 * fail if we drop root privilege.  To be useful the value 		 * has to be larger than the largest ntpd resident set size. 		 */
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ntp_rlimit: MEMLOCK: %d %s\n"
operator|,
call|(
name|int
call|)
argument_list|(
name|rl_value
operator|/
name|rl_scale
argument_list|)
operator|,
name|rl_sstr
operator|)
argument_list|)
expr_stmt|;
name|rl
operator|.
name|rlim_cur
operator|=
name|rl
operator|.
name|rlim_max
operator|=
name|rl_value
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_MEMLOCK
argument_list|,
operator|&
name|rl
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot set RLIMIT_MEMLOCK: %m"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* RLIMIT_MEMLOCK */
ifdef|#
directive|ifdef
name|RLIMIT_NOFILE
case|case
name|RLIMIT_NOFILE
case|:
comment|/* 		 * For large systems the default file descriptor limit may 		 * not be enough.  		 */
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ntp_rlimit: NOFILE: %d %s\n"
operator|,
call|(
name|int
call|)
argument_list|(
name|rl_value
operator|/
name|rl_scale
argument_list|)
operator|,
name|rl_sstr
operator|)
argument_list|)
expr_stmt|;
name|rl
operator|.
name|rlim_cur
operator|=
name|rl
operator|.
name|rlim_max
operator|=
name|rl_value
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rl
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot set RLIMIT_NOFILE: %m"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* RLIMIT_NOFILE */
ifdef|#
directive|ifdef
name|RLIMIT_STACK
case|case
name|RLIMIT_STACK
case|:
comment|/* 		 * Provide a way to set the stack limit to something 		 * smaller, so that we don't lock a lot of unused 		 * stack memory. 		 */
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"ntp_rlimit: STACK: %d %s pages\n"
operator|,
call|(
name|int
call|)
argument_list|(
name|rl_value
operator|/
name|rl_scale
argument_list|)
operator|,
name|rl_sstr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rl
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getrlimit() failed: %m"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rl_value
operator|>
name|rl
operator|.
name|rlim_max
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ntp_rlimit: using maximum allowed stack limit %lu instead of %lu."
argument_list|,
operator|(
name|u_long
operator|)
name|rl
operator|.
name|rlim_max
argument_list|,
operator|(
name|u_long
operator|)
name|rl_value
argument_list|)
expr_stmt|;
name|rl_value
operator|=
name|rl
operator|.
name|rlim_max
expr_stmt|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rl
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ntp_rlimit: Cannot adjust stack limit: %m"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* RLIMIT_STACK */
default|default:
name|INSIST
argument_list|(
operator|!
literal|"Unexpected setrlimit() case!"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SETRLIMIT */
end_comment

end_unit

