begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_leapsec.c - leap second processing for NTPD  *  * Written by Juergen Perlinger (perlinger@ntp.org) for the NTP project.  * The contents of 'html/copyright.html' apply.  * ----------------------------------------------------------------------  * This is an attempt to get the leap second handling into a dedicated  * module to make the somewhat convoluted logic testable.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_leapsec.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"vint64ops.h"
end_include

begin_include
include|#
directive|include
file|"lib_strbuf.h"
end_include

begin_include
include|#
directive|include
file|"isc/sha1.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|logPrefix
init|=
literal|"leapsecond file"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ---------------------------------------------------------------------  * GCC is rather sticky with its 'const' attribute. We have to do it more  * explicit than with a cast if we want to get rid of a CONST qualifier.  * Greetings from the PASCAL world, where casting was only possible via  * untagged unions...  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|noconst
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
union|union
block|{
specifier|const
name|void
modifier|*
name|cp
decl_stmt|;
name|void
modifier|*
name|vp
decl_stmt|;
block|}
name|tmp
union|;
name|tmp
operator|.
name|cp
operator|=
name|ptr
expr_stmt|;
return|return
name|tmp
operator|.
name|vp
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------  * Our internal data structure  */
end_comment

begin_define
define|#
directive|define
name|MAX_HIST
value|10
end_define

begin_comment
comment|/* history of leap seconds */
end_comment

begin_struct
struct|struct
name|leap_info
block|{
name|vint64
name|ttime
decl_stmt|;
comment|/* transition time (after the step, ntp scale) */
name|uint32_t
name|stime
decl_stmt|;
comment|/* schedule limit (a month before transition)  */
name|int16_t
name|taiof
decl_stmt|;
comment|/* TAI offset on and after the transition      */
name|uint8_t
name|dynls
decl_stmt|;
comment|/* dynamic: inserted on peer/clock request     */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|leap_info
name|leap_info_t
typedef|;
end_typedef

begin_struct
struct|struct
name|leap_head
block|{
name|vint64
name|update
decl_stmt|;
comment|/* time of information update                 */
name|vint64
name|expire
decl_stmt|;
comment|/* table expiration time                      */
name|uint16_t
name|size
decl_stmt|;
comment|/* number of infos in table	               */
name|int16_t
name|base_tai
decl_stmt|;
comment|/* total leaps before first entry      */
name|int16_t
name|this_tai
decl_stmt|;
comment|/* current TAI offset	               */
name|int16_t
name|next_tai
decl_stmt|;
comment|/* TAI offset after 'when'             */
name|vint64
name|dtime
decl_stmt|;
comment|/* due time (current era end)                 */
name|vint64
name|ttime
decl_stmt|;
comment|/* nominal transition time (next era start)   */
name|vint64
name|stime
decl_stmt|;
comment|/* schedule time (when we take notice)        */
name|vint64
name|ebase
decl_stmt|;
comment|/* base time of this leap era                 */
name|uint8_t
name|dynls
decl_stmt|;
comment|/* next leap is dynamic (by peer request)     */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|leap_head
name|leap_head_t
typedef|;
end_typedef

begin_struct
struct|struct
name|leap_table
block|{
name|leap_signature_t
name|lsig
decl_stmt|;
name|leap_head_t
name|head
decl_stmt|;
name|leap_info_t
name|info
index|[
name|MAX_HIST
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Where we store our tables */
end_comment

begin_decl_stmt
specifier|static
name|leap_table_t
name|_ltab
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|_lptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
comment|/*BOOL*/
name|_electric
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decls of local helpers */
end_comment

begin_function_decl
specifier|static
name|int
name|add_range
parameter_list|(
name|leap_table_t
modifier|*
parameter_list|,
specifier|const
name|leap_info_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_line
parameter_list|(
name|leapsec_reader
parameter_list|,
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|skipws
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parsefail
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reload_limits
parameter_list|(
name|leap_table_t
modifier|*
parameter_list|,
specifier|const
name|vint64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|betweenu32
parameter_list|(
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reset_times
parameter_list|(
name|leap_table_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|leapsec_add
parameter_list|(
name|leap_table_t
modifier|*
parameter_list|,
specifier|const
name|vint64
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|leapsec_raw
parameter_list|(
name|leap_table_t
modifier|*
parameter_list|,
specifier|const
name|vint64
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|lstostr
parameter_list|(
specifier|const
name|vint64
modifier|*
name|ts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* =====================================================================  * Get& Set the current leap table  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|leap_table_t
modifier|*
name|leapsec_get_table
parameter_list|(
name|int
name|alternate
parameter_list|)
block|{
name|leap_table_t
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p1
operator|=
name|_lptr
expr_stmt|;
name|p1
operator|=
operator|&
name|_ltab
index|[
name|p1
operator|==
operator|&
name|_ltab
index|[
literal|1
index|]
index|]
expr_stmt|;
name|p2
operator|=
operator|&
name|_ltab
index|[
name|p1
operator|==
operator|&
name|_ltab
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|alternate
condition|)
block|{
name|memcpy
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|,
sizeof|sizeof
argument_list|(
name|leap_table_t
argument_list|)
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p2
expr_stmt|;
block|}
return|return
name|p1
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_set_table
parameter_list|(
name|leap_table_t
modifier|*
name|pt
parameter_list|)
block|{
if|if
condition|(
name|pt
operator|==
operator|&
name|_ltab
index|[
literal|0
index|]
operator|||
name|pt
operator|==
operator|&
name|_ltab
index|[
literal|1
index|]
condition|)
name|_lptr
operator|=
name|pt
expr_stmt|;
return|return
name|_lptr
operator|==
name|pt
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_electric
parameter_list|(
name|int
comment|/*BOOL*/
name|on
parameter_list|)
block|{
name|int
name|res
init|=
name|_electric
decl_stmt|;
if|if
condition|(
name|on
operator|<
literal|0
condition|)
return|return
name|res
return|;
name|_electric
operator|=
operator|(
name|on
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|_electric
operator|==
name|res
condition|)
return|return
name|res
return|;
if|if
condition|(
name|_lptr
operator|==
operator|&
name|_ltab
index|[
literal|0
index|]
operator|||
name|_lptr
operator|==
operator|&
name|_ltab
index|[
literal|1
index|]
condition|)
name|reset_times
argument_list|(
name|_lptr
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * API functions that operate on tables  */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------  * Clear all leap second data. Use it for init& cleanup  */
end_comment

begin_function
name|void
name|leapsec_clear
parameter_list|(
name|leap_table_t
modifier|*
name|pt
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|pt
operator|->
name|lsig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pt
operator|->
name|lsig
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pt
operator|->
name|head
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pt
operator|->
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|reset_times
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------  * Load a leap second file and check expiration on the go  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_load
parameter_list|(
name|leap_table_t
modifier|*
name|pt
parameter_list|,
name|leapsec_reader
name|func
parameter_list|,
name|void
modifier|*
name|farg
parameter_list|,
name|int
name|use_build_limit
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
name|linebuf
index|[
literal|50
index|]
decl_stmt|;
name|vint64
name|ttime
decl_stmt|,
name|limit
decl_stmt|;
name|long
name|taiof
decl_stmt|;
name|struct
name|calendar
name|build
decl_stmt|;
name|leapsec_clear
argument_list|(
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_build_limit
operator|&&
name|ntpcal_get_build_date
argument_list|(
operator|&
name|build
argument_list|)
condition|)
name|limit
operator|=
name|ntpcal_date_to_ntp64
argument_list|(
operator|&
name|build
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|limit
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|limit
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|get_line
argument_list|(
name|func
argument_list|,
name|farg
argument_list|,
name|linebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
argument_list|)
condition|)
block|{
name|cp
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'#'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|cp
operator|=
name|skipws
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|expire
operator|=
name|strtouv64
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsefail
argument_list|(
name|cp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|fail_read
goto|;
name|pt
operator|->
name|lsig
operator|.
name|etime
operator|=
name|pt
operator|->
name|head
operator|.
name|expire
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
name|cp
operator|=
name|skipws
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|update
operator|=
name|strtouv64
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsefail
argument_list|(
name|cp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|fail_read
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|ttime
operator|=
name|strtouv64
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsefail
argument_list|(
name|cp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|fail_read
goto|;
name|cp
operator|=
name|skipws
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|taiof
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsefail
argument_list|(
name|cp
argument_list|,
name|ep
argument_list|)
operator|||
name|taiof
operator|>
name|SHRT_MAX
operator|||
name|taiof
operator|<
name|SHRT_MIN
condition|)
goto|goto
name|fail_read
goto|;
if|if
condition|(
name|ucmpv64
argument_list|(
operator|&
name|ttime
argument_list|,
operator|&
name|limit
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|leapsec_raw
argument_list|(
name|pt
argument_list|,
operator|&
name|ttime
argument_list|,
name|taiof
argument_list|,
name|FALSE
argument_list|)
condition|)
goto|goto
name|fail_insn
goto|;
block|}
else|else
block|{
name|pt
operator|->
name|head
operator|.
name|base_tai
operator|=
operator|(
name|int16_t
operator|)
name|taiof
expr_stmt|;
block|}
name|pt
operator|->
name|lsig
operator|.
name|ttime
operator|=
name|ttime
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
name|pt
operator|->
name|lsig
operator|.
name|taiof
operator|=
operator|(
name|int16_t
operator|)
name|taiof
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
name|fail_read
label|:
name|errno
operator|=
name|EILSEQ
expr_stmt|;
name|fail_insn
label|:
name|leapsec_clear
argument_list|(
name|pt
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------  * Dump a table in human-readable format. Use 'fprintf' and a FILE  * pointer if you want to get it printed into a stream.  */
end_comment

begin_function
name|void
name|leapsec_dump
parameter_list|(
specifier|const
name|leap_table_t
modifier|*
name|pt
parameter_list|,
name|leapsec_dumper
name|func
parameter_list|,
name|void
modifier|*
name|farg
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|vint64
name|ts
decl_stmt|;
name|struct
name|calendar
name|atb
decl_stmt|,
name|ttb
decl_stmt|;
name|ntpcal_ntp64_to_date
argument_list|(
operator|&
name|ttb
argument_list|,
operator|&
name|pt
operator|->
name|head
operator|.
name|expire
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|farg
argument_list|,
literal|"leap table (%u entries) expires at %04u-%02u-%02u:\n"
argument_list|,
name|pt
operator|->
name|head
operator|.
name|size
argument_list|,
name|ttb
operator|.
name|year
argument_list|,
name|ttb
operator|.
name|month
argument_list|,
name|ttb
operator|.
name|monthday
argument_list|)
expr_stmt|;
name|idx
operator|=
name|pt
operator|->
name|head
operator|.
name|size
expr_stmt|;
while|while
condition|(
name|idx
operator|--
operator|!=
literal|0
condition|)
block|{
name|ts
operator|=
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|ttime
expr_stmt|;
name|ntpcal_ntp64_to_date
argument_list|(
operator|&
name|ttb
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|=
name|subv64u32
argument_list|(
operator|&
name|ts
argument_list|,
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|stime
argument_list|)
expr_stmt|;
name|ntpcal_ntp64_to_date
argument_list|(
operator|&
name|atb
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|farg
argument_list|,
literal|"%04u-%02u-%02u [%c] (%04u-%02u-%02u) - %d\n"
argument_list|,
name|ttb
operator|.
name|year
argument_list|,
name|ttb
operator|.
name|month
argument_list|,
name|ttb
operator|.
name|monthday
argument_list|,
literal|"-*"
index|[
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|dynls
operator|!=
literal|0
index|]
argument_list|,
name|atb
operator|.
name|year
argument_list|,
name|atb
operator|.
name|month
argument_list|,
name|atb
operator|.
name|monthday
argument_list|,
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|taiof
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* =====================================================================  * usecase driven API functions  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_query
parameter_list|(
name|leap_result_t
modifier|*
name|qr
parameter_list|,
name|uint32_t
name|ts32
parameter_list|,
specifier|const
name|time_t
modifier|*
name|pivot
parameter_list|)
block|{
name|leap_table_t
modifier|*
name|pt
decl_stmt|;
name|vint64
name|ts64
decl_stmt|,
name|last
decl_stmt|,
name|next
decl_stmt|;
name|uint32_t
name|due32
decl_stmt|;
name|int
name|fired
decl_stmt|;
comment|/* preset things we use later on... */
name|fired
operator|=
name|FALSE
expr_stmt|;
name|ts64
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|ts32
argument_list|,
name|pivot
argument_list|)
expr_stmt|;
name|pt
operator|=
name|leapsec_get_table
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|qr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|leap_result_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucmpv64
argument_list|(
operator|&
name|ts64
argument_list|,
operator|&
name|pt
operator|->
name|head
operator|.
name|ebase
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Most likely after leap frame reset. Could also be a 		 * backstep of the system clock. Anyway, get the new 		 * leap era frame. 		 */
name|reload_limits
argument_list|(
name|pt
argument_list|,
operator|&
name|ts64
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucmpv64
argument_list|(
operator|&
name|ts64
argument_list|,
operator|&
name|pt
operator|->
name|head
operator|.
name|dtime
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Boundary crossed in forward direction. This might 		 * indicate a leap transition, so we prepare for that 		 * case. 		 * 		 * Some operations below are actually NOPs in electric 		 * mode, but having only one code path that works for 		 * both modes is easier to maintain. 		 */
name|last
operator|=
name|pt
operator|->
name|head
operator|.
name|ttime
expr_stmt|;
name|qr
operator|->
name|warped
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|last
operator|.
name|D_s
operator|.
name|lo
operator|-
name|pt
operator|->
name|head
operator|.
name|dtime
operator|.
name|D_s
operator|.
name|lo
argument_list|)
expr_stmt|;
name|next
operator|=
name|addv64i32
argument_list|(
operator|&
name|ts64
argument_list|,
name|qr
operator|->
name|warped
argument_list|)
expr_stmt|;
name|reload_limits
argument_list|(
name|pt
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
name|fired
operator|=
name|ucmpv64
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|ebase
argument_list|,
operator|&
name|last
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|fired
condition|)
block|{
name|ts64
operator|=
name|next
expr_stmt|;
name|ts32
operator|=
name|next
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
block|}
else|else
block|{
name|qr
operator|->
name|warped
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|qr
operator|->
name|tai_offs
operator|=
name|pt
operator|->
name|head
operator|.
name|this_tai
expr_stmt|;
comment|/* If before the next scheduling alert, we're done. */
if|if
condition|(
name|ucmpv64
argument_list|(
operator|&
name|ts64
argument_list|,
operator|&
name|pt
operator|->
name|head
operator|.
name|stime
argument_list|)
operator|<
literal|0
condition|)
return|return
name|fired
return|;
comment|/* now start to collect the remaing data */
name|due32
operator|=
name|pt
operator|->
name|head
operator|.
name|dtime
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
name|qr
operator|->
name|tai_diff
operator|=
name|pt
operator|->
name|head
operator|.
name|next_tai
operator|-
name|pt
operator|->
name|head
operator|.
name|this_tai
expr_stmt|;
name|qr
operator|->
name|ttime
operator|=
name|pt
operator|->
name|head
operator|.
name|ttime
expr_stmt|;
name|qr
operator|->
name|ddist
operator|=
name|due32
operator|-
name|ts32
expr_stmt|;
name|qr
operator|->
name|dynamic
operator|=
name|pt
operator|->
name|head
operator|.
name|dynls
expr_stmt|;
name|qr
operator|->
name|proximity
operator|=
name|LSPROX_SCHEDULE
expr_stmt|;
comment|/* if not in the last day before transition, we're done. */
if|if
condition|(
operator|!
name|betweenu32
argument_list|(
name|due32
operator|-
name|SECSPERDAY
argument_list|,
name|ts32
argument_list|,
name|due32
argument_list|)
condition|)
return|return
name|fired
return|;
name|qr
operator|->
name|proximity
operator|=
name|LSPROX_ANNOUNCE
expr_stmt|;
if|if
condition|(
operator|!
name|betweenu32
argument_list|(
name|due32
operator|-
literal|10
argument_list|,
name|ts32
argument_list|,
name|due32
argument_list|)
condition|)
return|return
name|fired
return|;
comment|/* The last 10s before the transition. Prepare for action! */
name|qr
operator|->
name|proximity
operator|=
name|LSPROX_ALERT
expr_stmt|;
return|return
name|fired
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_frame
parameter_list|(
name|leap_result_t
modifier|*
name|qr
parameter_list|)
block|{
specifier|const
name|leap_table_t
modifier|*
name|pt
decl_stmt|;
name|memset
argument_list|(
name|qr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|leap_result_t
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|=
name|leapsec_get_table
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucmpv64
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|ttime
argument_list|,
operator|&
name|pt
operator|->
name|head
operator|.
name|stime
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|FALSE
return|;
name|qr
operator|->
name|tai_offs
operator|=
name|pt
operator|->
name|head
operator|.
name|this_tai
expr_stmt|;
name|qr
operator|->
name|tai_diff
operator|=
name|pt
operator|->
name|head
operator|.
name|next_tai
operator|-
name|pt
operator|->
name|head
operator|.
name|this_tai
expr_stmt|;
name|qr
operator|->
name|ttime
operator|=
name|pt
operator|->
name|head
operator|.
name|ttime
expr_stmt|;
name|qr
operator|->
name|dynamic
operator|=
name|pt
operator|->
name|head
operator|.
name|dynls
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Reset the current leap frame */
end_comment

begin_function
name|void
name|leapsec_reset_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|reset_times
argument_list|(
name|leapsec_get_table
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* load a file from a FILE pointer. Note: If hcheck is true, load  * only after successful signature check. The stream must be seekable  * or this will fail.  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_load_stream
parameter_list|(
name|FILE
modifier|*
name|ifp
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
comment|/*BOOL*/
name|logall
parameter_list|)
block|{
name|leap_table_t
modifier|*
name|pt
decl_stmt|;
name|int
name|rcheck
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|fname
condition|)
name|fname
operator|=
literal|"<unknown>"
expr_stmt|;
name|rcheck
operator|=
name|leapsec_validate
argument_list|(
operator|(
name|leapsec_reader
operator|)
name|getc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|logall
condition|)
switch|switch
condition|(
name|rcheck
condition|)
block|{
case|case
name|LSVALID_GOODHASH
case|:
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s ('%s'): good hash signature"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSVALID_NOHASH
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s ('%s'): no hash signature"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSVALID_BADHASH
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s ('%s'): signature mismatch"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSVALID_BADFORMAT
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s ('%s'): malformed hash signature"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s ('%s'): unknown error code %d"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|,
name|rcheck
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rcheck
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|rewind
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|pt
operator|=
name|leapsec_get_table
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leapsec_load
argument_list|(
name|pt
argument_list|,
operator|(
name|leapsec_reader
operator|)
name|getc
argument_list|,
name|ifp
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINVAL
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s ('%s'): bad transition time"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERANGE
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s ('%s'): times not ascending"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s ('%s'): parsing error"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|pt
operator|->
name|head
operator|.
name|size
condition|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s ('%s'): loaded, expire=%s last=%s ofs=%d"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|,
name|lstostr
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|expire
argument_list|)
argument_list|,
name|lstostr
argument_list|(
operator|&
name|pt
operator|->
name|info
index|[
literal|0
index|]
operator|.
name|ttime
argument_list|)
argument_list|,
name|pt
operator|->
name|info
index|[
literal|0
index|]
operator|.
name|taiof
argument_list|)
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s ('%s'): loaded, expire=%s ofs=%d (no entries after build date)"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|,
name|lstostr
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|expire
argument_list|)
argument_list|,
name|pt
operator|->
name|head
operator|.
name|base_tai
argument_list|)
expr_stmt|;
return|return
name|leapsec_set_table
argument_list|(
name|pt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_load_file
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|struct
name|stat
modifier|*
name|sb_old
parameter_list|,
name|int
comment|/*BOOL*/
name|force
parameter_list|,
name|int
comment|/*BOOL*/
name|logall
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|sb_new
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* just do nothing if there is no leap file */
if|if
condition|(
operator|!
operator|(
name|fname
operator|&&
operator|*
name|fname
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* try to stat the leapfile */
if|if
condition|(
literal|0
operator|!=
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sb_new
argument_list|)
condition|)
block|{
if|if
condition|(
name|logall
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s ('%s'): stat failed: %m"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* silently skip to postcheck if no new file found */
if|if
condition|(
name|NULL
operator|!=
name|sb_old
condition|)
block|{
if|if
condition|(
operator|!
name|force
operator|&&
name|sb_old
operator|->
name|st_mtime
operator|==
name|sb_new
operator|.
name|st_mtime
operator|&&
name|sb_old
operator|->
name|st_ctime
operator|==
name|sb_new
operator|.
name|st_ctime
condition|)
return|return
name|FALSE
return|;
operator|*
name|sb_old
operator|=
name|sb_new
expr_stmt|;
block|}
comment|/* try to open the leap file, complain if that fails 	 * 	 * [perlinger@ntp.org] 	 * coverity raises a TOCTOU (time-of-check/time-of-use) issue 	 * here, which is not entirely helpful: While there is indeed a 	 * possible race condition between the 'stat()' call above and 	 * the 'fopen)' call below, I intentionally want to omit the 	 * overhead of opening the file and calling 'fstat()', because 	 * in most cases the file would have be to closed anyway without 	 * reading the contents.  I chose to disable the coverity 	 * warning instead. 	 * 	 * So unless someone comes up with a reasonable argument why 	 * this could be a real issue, I'll just try to silence coverity 	 * on that topic. 	 */
comment|/* coverity[toctou] */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|logall
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s ('%s'): open failed: %m"
argument_list|,
name|logPrefix
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rc
operator|=
name|leapsec_load_stream
argument_list|(
name|fp
argument_list|,
name|fname
argument_list|,
name|logall
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|leapsec_getsig
parameter_list|(
name|leap_signature_t
modifier|*
name|psig
parameter_list|)
block|{
specifier|const
name|leap_table_t
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|leapsec_get_table
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|psig
argument_list|,
operator|&
name|pt
operator|->
name|lsig
argument_list|,
sizeof|sizeof
argument_list|(
name|leap_signature_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_expired
parameter_list|(
name|uint32_t
name|when
parameter_list|,
specifier|const
name|time_t
modifier|*
name|tpiv
parameter_list|)
block|{
specifier|const
name|leap_table_t
modifier|*
name|pt
decl_stmt|;
name|vint64
name|limit
decl_stmt|;
name|pt
operator|=
name|leapsec_get_table
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|limit
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|when
argument_list|,
name|tpiv
argument_list|)
expr_stmt|;
return|return
name|ucmpv64
argument_list|(
operator|&
name|limit
argument_list|,
operator|&
name|pt
operator|->
name|head
operator|.
name|expire
argument_list|)
operator|>=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|int32_t
name|leapsec_daystolive
parameter_list|(
name|uint32_t
name|when
parameter_list|,
specifier|const
name|time_t
modifier|*
name|tpiv
parameter_list|)
block|{
specifier|const
name|leap_table_t
modifier|*
name|pt
decl_stmt|;
name|vint64
name|limit
decl_stmt|;
name|pt
operator|=
name|leapsec_get_table
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|limit
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|when
argument_list|,
name|tpiv
argument_list|)
expr_stmt|;
name|limit
operator|=
name|subv64
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|expire
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
return|return
name|ntpcal_daysplit
argument_list|(
operator|&
name|limit
argument_list|)
operator|.
name|hi
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_add_fix
parameter_list|(
name|int
name|total
parameter_list|,
name|uint32_t
name|ttime
parameter_list|,
name|uint32_t
name|etime
parameter_list|,
specifier|const
name|time_t
modifier|*
name|pivot
parameter_list|)
block|{
name|time_t
name|tpiv
decl_stmt|;
name|leap_table_t
modifier|*
name|pt
decl_stmt|;
name|vint64
name|tt64
decl_stmt|,
name|et64
decl_stmt|;
if|if
condition|(
name|pivot
operator|==
name|NULL
condition|)
block|{
name|time
argument_list|(
operator|&
name|tpiv
argument_list|)
expr_stmt|;
name|pivot
operator|=
operator|&
name|tpiv
expr_stmt|;
block|}
name|et64
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|etime
argument_list|,
name|pivot
argument_list|)
expr_stmt|;
name|tt64
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|ttime
argument_list|,
name|pivot
argument_list|)
expr_stmt|;
name|pt
operator|=
name|leapsec_get_table
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucmpv64
argument_list|(
operator|&
name|et64
argument_list|,
operator|&
name|pt
operator|->
name|head
operator|.
name|expire
argument_list|)
operator|<=
literal|0
operator|||
operator|!
name|leapsec_raw
argument_list|(
name|pt
argument_list|,
operator|&
name|tt64
argument_list|,
name|total
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|pt
operator|->
name|lsig
operator|.
name|etime
operator|=
name|etime
expr_stmt|;
name|pt
operator|->
name|lsig
operator|.
name|ttime
operator|=
name|ttime
expr_stmt|;
name|pt
operator|->
name|lsig
operator|.
name|taiof
operator|=
operator|(
name|int16_t
operator|)
name|total
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|expire
operator|=
name|et64
expr_stmt|;
return|return
name|leapsec_set_table
argument_list|(
name|pt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_add_dyn
parameter_list|(
name|int
name|insert
parameter_list|,
name|uint32_t
name|ntpnow
parameter_list|,
specifier|const
name|time_t
modifier|*
name|pivot
parameter_list|)
block|{
name|leap_table_t
modifier|*
name|pt
decl_stmt|;
name|vint64
name|now64
decl_stmt|;
name|pt
operator|=
name|leapsec_get_table
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|now64
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|ntpnow
argument_list|,
name|pivot
argument_list|)
expr_stmt|;
return|return
operator|(
name|leapsec_add
argument_list|(
name|pt
argument_list|,
operator|&
name|now64
argument_list|,
operator|(
name|insert
operator|!=
literal|0
operator|)
argument_list|)
operator|&&
name|leapsec_set_table
argument_list|(
name|pt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * internal helpers  */
end_comment

begin_comment
comment|/* [internal] Reset / init the time window in the leap processor to  * force reload on next query. Since a leap transition cannot take place  * at an odd second, the value chosen avoids spurious leap transition  * triggers. Making all three times equal forces a reload. Using the  * maximum value for unsigned 64 bits makes finding the next leap frame  * a bit easier.  */
end_comment

begin_function
specifier|static
name|void
name|reset_times
parameter_list|(
name|leap_table_t
modifier|*
name|pt
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|ebase
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|vint64
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|stime
operator|=
name|pt
operator|->
name|head
operator|.
name|ebase
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|ttime
operator|=
name|pt
operator|->
name|head
operator|.
name|ebase
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|dtime
operator|=
name|pt
operator|->
name|head
operator|.
name|ebase
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [internal] Add raw data to the table, removing old entries on the  * fly. This cannot fail currently.  */
end_comment

begin_function
specifier|static
name|int
comment|/*BOOL*/
name|add_range
parameter_list|(
name|leap_table_t
modifier|*
name|pt
parameter_list|,
specifier|const
name|leap_info_t
modifier|*
name|pi
parameter_list|)
block|{
comment|/* If the table is full, make room by throwing out the oldest 	 * entry. But remember the accumulated leap seconds! 	 */
if|if
condition|(
name|pt
operator|->
name|head
operator|.
name|size
operator|>=
name|MAX_HIST
condition|)
block|{
name|pt
operator|->
name|head
operator|.
name|size
operator|=
name|MAX_HIST
operator|-
literal|1
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|base_tai
operator|=
name|pt
operator|->
name|info
index|[
name|pt
operator|->
name|head
operator|.
name|size
index|]
operator|.
name|taiof
expr_stmt|;
block|}
comment|/* make room in lower end and insert item */
name|memmove
argument_list|(
name|pt
operator|->
name|info
operator|+
literal|1
argument_list|,
name|pt
operator|->
name|info
argument_list|,
name|pt
operator|->
name|head
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pt
operator|->
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|->
name|info
index|[
literal|0
index|]
operator|=
operator|*
name|pi
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|size
operator|++
expr_stmt|;
comment|/* invalidate the cached limit data -- we might have news ;-) 	 * 	 * This blocks a spurious transition detection. OTOH, if you add 	 * a value after the last query before a leap transition was 	 * expected to occur, this transition trigger is lost. But we 	 * can probably live with that. 	 */
name|reset_times
argument_list|(
name|pt
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* [internal] given a reader function, read characters into a buffer  * until either EOL or EOF is reached. Makes sure that the buffer is  * always NUL terminated, but silently truncates excessive data. The  * EOL-marker ('\n') is *not* stored in the buffer.  *  * Returns the pointer to the buffer, unless EOF was reached when trying  * to read the first character of a line.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_line
parameter_list|(
name|leapsec_reader
name|func
parameter_list|,
name|void
modifier|*
name|farg
parameter_list|,
name|char
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* if we cannot even store the delimiter, declare failure */
if|if
condition|(
name|buff
operator|==
name|NULL
operator|||
name|size
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|ptr
operator|=
name|buff
expr_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|farg
argument_list|)
operator|)
operator|&&
literal|'\n'
operator|!=
name|ch
condition|)
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
name|size
operator|--
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
comment|/* discard trailing whitespace */
while|while
condition|(
name|ptr
operator|!=
name|buff
operator|&&
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|ptr
operator|--
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ptr
operator|==
name|buff
operator|&&
name|ch
operator|==
name|EOF
operator|)
condition|?
name|NULL
else|:
name|buff
return|;
block|}
end_function

begin_comment
comment|/* [internal] skips whitespace characters from a character buffer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skipws
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|ptr
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|noconst
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* [internal] check if a strtoXYZ ended at EOL or whistespace and  * converted something at all. Return TRUE if something went wrong.  */
end_comment

begin_function
specifier|static
name|int
comment|/*BOOL*/
name|parsefail
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|)
block|{
return|return
operator|(
name|cp
operator|==
name|ep
operator|)
operator|||
operator|(
operator|*
name|ep
operator|&&
operator|*
name|ep
operator|!=
literal|'#'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|ep
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* [internal] reload the table limits around the given time stamp. This  * is where the real work is done when it comes to table lookup and  * evaluation. Some care has been taken to have correct code for dealing  * with boundary conditions and empty tables.  *  * In electric mode, transition and trip time are the same. In dumb  * mode, the difference of the TAI offsets must be taken into account  * and trip time and transition time become different. The difference  * becomes the warping distance when the trip time is reached.  */
end_comment

begin_function
specifier|static
name|void
name|reload_limits
parameter_list|(
name|leap_table_t
modifier|*
name|pt
parameter_list|,
specifier|const
name|vint64
modifier|*
name|ts
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
comment|/* Get full time and search the true lower bound. Use a 	 * simple loop here, since the number of entries does 	 * not warrant a binary search. This also works for an empty 	 * table, so there is no shortcut for that case. 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|!=
name|pt
operator|->
name|head
operator|.
name|size
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|ucmpv64
argument_list|(
name|ts
argument_list|,
operator|&
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|ttime
argument_list|)
operator|>=
literal|0
condition|)
break|break;
comment|/* get time limits with proper bound conditions. Note that the 	 * bounds of the table will be observed even if the table is 	 * empty -- no undefined condition must arise from this code. 	 */
if|if
condition|(
name|idx
operator|>=
name|pt
operator|->
name|head
operator|.
name|size
condition|)
block|{
name|memset
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|ebase
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
name|vint64
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|this_tai
operator|=
name|pt
operator|->
name|head
operator|.
name|base_tai
expr_stmt|;
block|}
else|else
block|{
name|pt
operator|->
name|head
operator|.
name|ebase
operator|=
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|ttime
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|this_tai
operator|=
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|taiof
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|idx
operator|>=
literal|0
condition|)
block|{
name|pt
operator|->
name|head
operator|.
name|next_tai
operator|=
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|taiof
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|dynls
operator|=
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|dynls
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|ttime
operator|=
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|ttime
expr_stmt|;
if|if
condition|(
name|_electric
condition|)
name|pt
operator|->
name|head
operator|.
name|dtime
operator|=
name|pt
operator|->
name|head
operator|.
name|ttime
expr_stmt|;
else|else
name|pt
operator|->
name|head
operator|.
name|dtime
operator|=
name|addv64i32
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|ttime
argument_list|,
name|pt
operator|->
name|head
operator|.
name|next_tai
operator|-
name|pt
operator|->
name|head
operator|.
name|this_tai
argument_list|)
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|stime
operator|=
name|subv64u32
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|ttime
argument_list|,
name|pt
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|stime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|pt
operator|->
name|head
operator|.
name|ttime
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|vint64
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|stime
operator|=
name|pt
operator|->
name|head
operator|.
name|ttime
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|dtime
operator|=
name|pt
operator|->
name|head
operator|.
name|ttime
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|next_tai
operator|=
name|pt
operator|->
name|head
operator|.
name|this_tai
expr_stmt|;
name|pt
operator|->
name|head
operator|.
name|dynls
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* [internal] Take a time stamp and create a leap second frame for  * it. This will schedule a leap second for the beginning of the next  * month, midnight UTC. The 'insert' argument tells if a leap second is  * added (!=0) or removed (==0). We do not handle multiple inserts  * (yet?)  *  * Returns 1 if the insert worked, 0 otherwise. (It's not possible to  * insert a leap second into the current history -- only appending  * towards the future is allowed!)  */
end_comment

begin_function
specifier|static
name|int
comment|/*BOOL*/
name|leapsec_add
parameter_list|(
name|leap_table_t
modifier|*
name|pt
parameter_list|,
specifier|const
name|vint64
modifier|*
name|now64
parameter_list|,
name|int
name|insert
parameter_list|)
block|{
name|vint64
name|ttime
decl_stmt|,
name|stime
decl_stmt|;
name|struct
name|calendar
name|fts
decl_stmt|;
name|leap_info_t
name|li
decl_stmt|;
comment|/* Check against the table expiration and the lates available 	 * leap entry. Do not permit inserts, only appends, and only if 	 * the extend the table beyond the expiration! 	 */
if|if
condition|(
name|ucmpv64
argument_list|(
name|now64
argument_list|,
operator|&
name|pt
operator|->
name|head
operator|.
name|expire
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|pt
operator|->
name|head
operator|.
name|size
operator|&&
name|ucmpv64
argument_list|(
name|now64
argument_list|,
operator|&
name|pt
operator|->
name|info
index|[
literal|0
index|]
operator|.
name|ttime
argument_list|)
operator|<=
literal|0
operator|)
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ntpcal_ntp64_to_date
argument_list|(
operator|&
name|fts
argument_list|,
name|now64
argument_list|)
expr_stmt|;
comment|/* To guard against dangling leap flags: do not accept leap 	 * second request on the 1st hour of the 1st day of the month. 	 */
if|if
condition|(
name|fts
operator|.
name|monthday
operator|==
literal|1
operator|&&
name|fts
operator|.
name|hour
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Ok, do the remaining calculations */
name|fts
operator|.
name|monthday
operator|=
literal|1
expr_stmt|;
name|fts
operator|.
name|hour
operator|=
literal|0
expr_stmt|;
name|fts
operator|.
name|minute
operator|=
literal|0
expr_stmt|;
name|fts
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|stime
operator|=
name|ntpcal_date_to_ntp64
argument_list|(
operator|&
name|fts
argument_list|)
expr_stmt|;
name|fts
operator|.
name|month
operator|++
expr_stmt|;
name|ttime
operator|=
name|ntpcal_date_to_ntp64
argument_list|(
operator|&
name|fts
argument_list|)
expr_stmt|;
name|li
operator|.
name|ttime
operator|=
name|ttime
expr_stmt|;
name|li
operator|.
name|stime
operator|=
name|ttime
operator|.
name|D_s
operator|.
name|lo
operator|-
name|stime
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
name|li
operator|.
name|taiof
operator|=
operator|(
name|pt
operator|->
name|head
operator|.
name|size
condition|?
name|pt
operator|->
name|info
index|[
literal|0
index|]
operator|.
name|taiof
else|:
name|pt
operator|->
name|head
operator|.
name|base_tai
operator|)
operator|+
operator|(
name|insert
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
name|li
operator|.
name|dynls
operator|=
literal|1
expr_stmt|;
return|return
name|add_range
argument_list|(
name|pt
argument_list|,
operator|&
name|li
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* [internal] Given a time stamp for a leap insertion (the exact begin  * of the new leap era), create new leap frame and put it into the  * table. This is the work horse for reading a leap file and getting a  * leap second update via authenticated network packet.  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|leapsec_raw
parameter_list|(
name|leap_table_t
modifier|*
name|pt
parameter_list|,
specifier|const
name|vint64
modifier|*
name|ttime
parameter_list|,
name|int
name|taiof
parameter_list|,
name|int
name|dynls
parameter_list|)
block|{
name|vint64
name|stime
decl_stmt|;
name|struct
name|calendar
name|fts
decl_stmt|;
name|leap_info_t
name|li
decl_stmt|;
comment|/* Check that we only extend the table. Paranoia rulez! */
if|if
condition|(
name|pt
operator|->
name|head
operator|.
name|size
operator|&&
name|ucmpv64
argument_list|(
name|ttime
argument_list|,
operator|&
name|pt
operator|->
name|info
index|[
literal|0
index|]
operator|.
name|ttime
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ntpcal_ntp64_to_date
argument_list|(
operator|&
name|fts
argument_list|,
name|ttime
argument_list|)
expr_stmt|;
comment|/* If this does not match the exact month start, bail out. */
if|if
condition|(
name|fts
operator|.
name|monthday
operator|!=
literal|1
operator|||
name|fts
operator|.
name|hour
operator|||
name|fts
operator|.
name|minute
operator|||
name|fts
operator|.
name|second
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fts
operator|.
name|month
operator|--
expr_stmt|;
comment|/* was in range 1..12, no overflow here! */
name|stime
operator|=
name|ntpcal_date_to_ntp64
argument_list|(
operator|&
name|fts
argument_list|)
expr_stmt|;
name|li
operator|.
name|ttime
operator|=
operator|*
name|ttime
expr_stmt|;
name|li
operator|.
name|stime
operator|=
name|ttime
operator|->
name|D_s
operator|.
name|lo
operator|-
name|stime
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
name|li
operator|.
name|taiof
operator|=
operator|(
name|int16_t
operator|)
name|taiof
expr_stmt|;
name|li
operator|.
name|dynls
operator|=
operator|(
name|dynls
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|add_range
argument_list|(
name|pt
argument_list|,
operator|&
name|li
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* [internal] Do a wrap-around save range inclusion check.  * Returns TRUE if x in [lo,hi[ (intervall open on right side) with full  * handling of an overflow / wrap-around.  */
end_comment

begin_function
specifier|static
name|int
comment|/*BOOL*/
name|betweenu32
parameter_list|(
name|uint32_t
name|lo
parameter_list|,
name|uint32_t
name|x
parameter_list|,
name|uint32_t
name|hi
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|lo
operator|<=
name|hi
condition|)
name|rc
operator|=
operator|(
name|lo
operator|<=
name|x
operator|)
operator|&&
operator|(
name|x
operator|<
name|hi
operator|)
expr_stmt|;
else|else
name|rc
operator|=
operator|(
name|lo
operator|<=
name|x
operator|)
operator|||
operator|(
name|x
operator|<
name|hi
operator|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* =====================================================================  * validation stuff  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|hv
index|[
name|ISC_SHA1_DIGESTLENGTH
index|]
decl_stmt|;
block|}
name|sha1_digest
typedef|;
end_typedef

begin_comment
comment|/* [internal] parse a digest line to get the hash signature  * The NIST code creating the hash writes them out as 5 hex integers  * without leading zeros. This makes reading them back as hex-encoded  * BLOB impossible, because there might be less than 40 hex digits.  *  * The solution is to read the values back as integers, and then do the  * byte twiddle necessary to get it into an array of 20 chars. The  * drawback is that it permits any acceptable number syntax provided by  * 'scanf()' and 'strtoul()', including optional signs and '0x'  * prefixes.  */
end_comment

begin_function
specifier|static
name|int
comment|/*BOOL*/
name|do_leap_hash
parameter_list|(
name|sha1_digest
modifier|*
name|mac
parameter_list|,
name|char
specifier|const
modifier|*
name|cp
parameter_list|)
block|{
name|int
name|wi
decl_stmt|,
name|di
decl_stmt|,
name|num
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|long
name|tmp
index|[
literal|5
index|]
decl_stmt|;
name|memset
argument_list|(
name|mac
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mac
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|" %lx %lx %lx %lx %lx%n"
argument_list|,
operator|&
name|tmp
index|[
literal|0
index|]
argument_list|,
operator|&
name|tmp
index|[
literal|1
index|]
argument_list|,
operator|&
name|tmp
index|[
literal|2
index|]
argument_list|,
operator|&
name|tmp
index|[
literal|3
index|]
argument_list|,
operator|&
name|tmp
index|[
literal|4
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|!=
literal|5
operator|||
name|cp
index|[
name|len
index|]
operator|>
literal|' '
condition|)
return|return
name|FALSE
return|;
comment|/* now do the byte twiddle */
for|for
control|(
name|wi
operator|=
literal|0
init|;
name|wi
operator|<
literal|5
condition|;
operator|++
name|wi
control|)
for|for
control|(
name|di
operator|=
literal|3
init|;
name|di
operator|>=
literal|0
condition|;
operator|--
name|di
control|)
block|{
name|mac
operator|->
name|hv
index|[
name|wi
operator|*
literal|4
operator|+
name|di
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|tmp
index|[
name|wi
index|]
expr_stmt|;
name|tmp
index|[
name|wi
index|]
operator|>>=
literal|8
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* [internal] add the digits of a data line to the hash, stopping at the  * next hash ('#') character.  */
end_comment

begin_function
specifier|static
name|void
name|do_hash_data
parameter_list|(
name|isc_sha1_t
modifier|*
name|mdctx
parameter_list|,
name|char
specifier|const
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|char
name|text
index|[
literal|32
index|]
decl_stmt|;
comment|// must be power of two!
name|unsigned
name|int
name|tlen
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
while|while
condition|(
literal|'\0'
operator|!=
operator|(
name|ch
operator|=
operator|*
name|cp
operator|++
operator|)
operator|&&
literal|'#'
operator|!=
name|ch
condition|)
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|text
index|[
name|tlen
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|tlen
operator|&=
operator|(
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|tlen
condition|)
name|isc_sha1_update
argument_list|(
name|mdctx
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<
name|tlen
condition|)
name|isc_sha1_update
argument_list|(
name|mdctx
argument_list|,
name|text
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* given a reader and a reader arg, calculate and validate the the hash  * signature of a NIST leap second file.  */
end_comment

begin_function
name|int
name|leapsec_validate
parameter_list|(
name|leapsec_reader
name|func
parameter_list|,
name|void
modifier|*
name|farg
parameter_list|)
block|{
name|isc_sha1_t
name|mdctx
decl_stmt|;
name|sha1_digest
name|rdig
decl_stmt|,
name|ldig
decl_stmt|;
comment|/* remote / local digests */
name|char
name|line
index|[
literal|50
index|]
decl_stmt|;
name|int
name|hlseen
init|=
operator|-
literal|1
decl_stmt|;
name|isc_sha1_init
argument_list|(
operator|&
name|mdctx
argument_list|)
expr_stmt|;
while|while
condition|(
name|get_line
argument_list|(
name|func
argument_list|,
name|farg
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"#h"
argument_list|,
literal|2
argument_list|)
condition|)
name|hlseen
operator|=
name|do_leap_hash
argument_list|(
operator|&
name|rdig
argument_list|,
name|line
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"#@"
argument_list|,
literal|2
argument_list|)
condition|)
name|do_hash_data
argument_list|(
operator|&
name|mdctx
argument_list|,
name|line
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"#$"
argument_list|,
literal|2
argument_list|)
condition|)
name|do_hash_data
argument_list|(
operator|&
name|mdctx
argument_list|,
name|line
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
condition|)
name|do_hash_data
argument_list|(
operator|&
name|mdctx
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|isc_sha1_final
argument_list|(
operator|&
name|mdctx
argument_list|,
name|ldig
operator|.
name|hv
argument_list|)
expr_stmt|;
name|isc_sha1_invalidate
argument_list|(
operator|&
name|mdctx
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|hlseen
condition|)
return|return
name|LSVALID_NOHASH
return|;
if|if
condition|(
literal|0
operator|==
name|hlseen
condition|)
return|return
name|LSVALID_BADFORMAT
return|;
if|if
condition|(
literal|0
operator|!=
name|memcmp
argument_list|(
operator|&
name|rdig
argument_list|,
operator|&
name|ldig
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1_digest
argument_list|)
argument_list|)
condition|)
return|return
name|LSVALID_BADHASH
return|;
return|return
name|LSVALID_GOODHASH
return|;
block|}
end_function

begin_comment
comment|/*  * lstostr - prettyprint NTP seconds  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lstostr
parameter_list|(
specifier|const
name|vint64
modifier|*
name|ts
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|calendar
name|tm
decl_stmt|;
name|LIB_GETBUF
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ntpcal_ntp64_to_date
argument_list|(
operator|&
name|tm
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
literal|"%04d-%02d-%02dT%02d:%02dZ"
argument_list|,
name|tm
operator|.
name|year
argument_list|,
name|tm
operator|.
name|month
argument_list|,
name|tm
operator|.
name|monthday
argument_list|,
name|tm
operator|.
name|hour
argument_list|,
name|tm
operator|.
name|minute
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* -*- that's all folks! -*- */
end_comment

end_unit

