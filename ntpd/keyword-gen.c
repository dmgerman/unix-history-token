begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * keyword-gen.c -- generate keyword scanner finite state machine and  *		    keyword_text array.  *		    This program is run to generate ntp_keyword.h  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<ntp_stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ntp_config.h>
end_include

begin_include
include|#
directive|include
file|<lib_strbuf.h>
end_include

begin_include
include|#
directive|include
file|"ntp_scanner.h"
end_include

begin_include
include|#
directive|include
file|"ntp_parser.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_USES_VOID_P
end_ifdef

begin_typedef
typedef|typedef
specifier|const
name|void
modifier|*
name|QSORTP
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|char
modifier|*
name|QSORTP
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define a structure to hold a (keyword, token) pair */
end_comment

begin_struct
struct|struct
name|key_tok
block|{
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Keyword */
name|int
name|token
decl_stmt|;
comment|/* Associated Token */
name|follby
name|followedby
decl_stmt|;
comment|/* nonzero indicates the next token(s) 				   forced to be string(s) */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|key_tok
name|ntp_keywords
index|[]
init|=
block|{
block|{
literal|"..."
block|,
name|T_Ellipsis
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"automax"
block|,
name|T_Automax
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"broadcast"
block|,
name|T_Broadcast
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"broadcastclient"
block|,
name|T_Broadcastclient
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"broadcastdelay"
block|,
name|T_Broadcastdelay
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"calldelay"
block|,
name|T_Calldelay
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"disable"
block|,
name|T_Disable
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"driftfile"
block|,
name|T_Driftfile
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"enable"
block|,
name|T_Enable
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"end"
block|,
name|T_End
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"filegen"
block|,
name|T_Filegen
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"fudge"
block|,
name|T_Fudge
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"includefile"
block|,
name|T_Includefile
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"leapfile"
block|,
name|T_Leapfile
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"logconfig"
block|,
name|T_Logconfig
block|,
name|FOLLBY_STRINGS_TO_EOC
block|}
block|,
block|{
literal|"logfile"
block|,
name|T_Logfile
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"manycastclient"
block|,
name|T_Manycastclient
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"manycastserver"
block|,
name|T_Manycastserver
block|,
name|FOLLBY_STRINGS_TO_EOC
block|}
block|,
block|{
literal|"multicastclient"
block|,
name|T_Multicastclient
block|,
name|FOLLBY_STRINGS_TO_EOC
block|}
block|,
block|{
literal|"peer"
block|,
name|T_Peer
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"phone"
block|,
name|T_Phone
block|,
name|FOLLBY_STRINGS_TO_EOC
block|}
block|,
block|{
literal|"pidfile"
block|,
name|T_Pidfile
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"pool"
block|,
name|T_Pool
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"discard"
block|,
name|T_Discard
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"restrict"
block|,
name|T_Restrict
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"server"
block|,
name|T_Server
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"setvar"
block|,
name|T_Setvar
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"statistics"
block|,
name|T_Statistics
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"statsdir"
block|,
name|T_Statsdir
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"tick"
block|,
name|T_Tick
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"tinker"
block|,
name|T_Tinker
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"tos"
block|,
name|T_Tos
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"trap"
block|,
name|T_Trap
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"unconfig"
block|,
name|T_Unconfig
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"unpeer"
block|,
name|T_Unpeer
block|,
name|FOLLBY_STRING
block|}
block|,
comment|/* authentication_command */
block|{
literal|"controlkey"
block|,
name|T_ControlKey
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"crypto"
block|,
name|T_Crypto
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"keys"
block|,
name|T_Keys
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"keysdir"
block|,
name|T_Keysdir
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"ntpsigndsocket"
block|,
name|T_NtpSignDsocket
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"requestkey"
block|,
name|T_Requestkey
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"revoke"
block|,
name|T_Revoke
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"trustedkey"
block|,
name|T_Trustedkey
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* IPv4/IPv6 protocol override flag */
block|{
literal|"-4"
block|,
name|T_Ipv4_flag
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"-6"
block|,
name|T_Ipv6_flag
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* option */
block|{
literal|"autokey"
block|,
name|T_Autokey
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"bias"
block|,
name|T_Bias
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"burst"
block|,
name|T_Burst
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"iburst"
block|,
name|T_Iburst
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"key"
block|,
name|T_Key
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"maxpoll"
block|,
name|T_Maxpoll
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"minpoll"
block|,
name|T_Minpoll
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"mode"
block|,
name|T_Mode
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"noselect"
block|,
name|T_Noselect
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"preempt"
block|,
name|T_Preempt
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"true"
block|,
name|T_True
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"prefer"
block|,
name|T_Prefer
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"ttl"
block|,
name|T_Ttl
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"version"
block|,
name|T_Version
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"xleave"
block|,
name|T_Xleave
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* crypto_command */
block|{
literal|"host"
block|,
name|T_Host
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"ident"
block|,
name|T_Ident
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"pw"
block|,
name|T_Pw
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"randfile"
block|,
name|T_Randfile
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"sign"
block|,
name|T_Sign
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"digest"
block|,
name|T_Digest
block|,
name|FOLLBY_STRING
block|}
block|,
comment|/*** MONITORING COMMANDS ***/
comment|/* stat */
block|{
literal|"clockstats"
block|,
name|T_Clockstats
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"cryptostats"
block|,
name|T_Cryptostats
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"loopstats"
block|,
name|T_Loopstats
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"peerstats"
block|,
name|T_Peerstats
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"rawstats"
block|,
name|T_Rawstats
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"sysstats"
block|,
name|T_Sysstats
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"protostats"
block|,
name|T_Protostats
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"timingstats"
block|,
name|T_Timingstats
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* filegen_option */
block|{
literal|"file"
block|,
name|T_File
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"link"
block|,
name|T_Link
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"nolink"
block|,
name|T_Nolink
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"type"
block|,
name|T_Type
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* filegen_type */
block|{
literal|"age"
block|,
name|T_Age
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"day"
block|,
name|T_Day
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"month"
block|,
name|T_Month
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"none"
block|,
name|T_None
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"pid"
block|,
name|T_Pid
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"week"
block|,
name|T_Week
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"year"
block|,
name|T_Year
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/*** ORPHAN MODE COMMANDS ***/
comment|/* tos_option */
block|{
literal|"minclock"
block|,
name|T_Minclock
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"maxclock"
block|,
name|T_Maxclock
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"minsane"
block|,
name|T_Minsane
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"floor"
block|,
name|T_Floor
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"ceiling"
block|,
name|T_Ceiling
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"cohort"
block|,
name|T_Cohort
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"mindist"
block|,
name|T_Mindist
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"maxdist"
block|,
name|T_Maxdist
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"beacon"
block|,
name|T_Beacon
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"orphan"
block|,
name|T_Orphan
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* access_control_flag */
block|{
literal|"default"
block|,
name|T_Default
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"flake"
block|,
name|T_Flake
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"ignore"
block|,
name|T_Ignore
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"limited"
block|,
name|T_Limited
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"mssntp"
block|,
name|T_Mssntp
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"kod"
block|,
name|T_Kod
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"lowpriotrap"
block|,
name|T_Lowpriotrap
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"mask"
block|,
name|T_Mask
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"nomodify"
block|,
name|T_Nomodify
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"nopeer"
block|,
name|T_Nopeer
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"noquery"
block|,
name|T_Noquery
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"noserve"
block|,
name|T_Noserve
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"notrap"
block|,
name|T_Notrap
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"notrust"
block|,
name|T_Notrust
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"ntpport"
block|,
name|T_Ntpport
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* discard_option */
block|{
literal|"average"
block|,
name|T_Average
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"minimum"
block|,
name|T_Minimum
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"monitor"
block|,
name|T_Monitor
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* fudge_factor */
block|{
literal|"flag1"
block|,
name|T_Flag1
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"flag2"
block|,
name|T_Flag2
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"flag3"
block|,
name|T_Flag3
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"flag4"
block|,
name|T_Flag4
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"refid"
block|,
name|T_Refid
block|,
name|FOLLBY_STRING
block|}
block|,
block|{
literal|"stratum"
block|,
name|T_Stratum
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"time1"
block|,
name|T_Time1
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"time2"
block|,
name|T_Time2
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* system_option */
block|{
literal|"auth"
block|,
name|T_Auth
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"bclient"
block|,
name|T_Bclient
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"calibrate"
block|,
name|T_Calibrate
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"kernel"
block|,
name|T_Kernel
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"ntp"
block|,
name|T_Ntp
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"stats"
block|,
name|T_Stats
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* tinker_option */
block|{
literal|"step"
block|,
name|T_Step
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"panic"
block|,
name|T_Panic
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"dispersion"
block|,
name|T_Dispersion
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"stepout"
block|,
name|T_Stepout
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"allan"
block|,
name|T_Allan
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"huffpuff"
block|,
name|T_Huffpuff
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"freq"
block|,
name|T_Freq
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* miscellaneous_command */
block|{
literal|"port"
block|,
name|T_Port
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"interface"
block|,
name|T_Interface
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"qos"
block|,
name|T_Qos
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"saveconfigdir"
block|,
name|T_Saveconfigdir
block|,
name|FOLLBY_STRING
block|}
block|,
comment|/* interface_command (ignore and interface already defined) */
block|{
literal|"nic"
block|,
name|T_Nic
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"all"
block|,
name|T_All
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"ipv4"
block|,
name|T_Ipv4
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"ipv6"
block|,
name|T_Ipv6
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"wildcard"
block|,
name|T_Wildcard
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"listen"
block|,
name|T_Listen
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"drop"
block|,
name|T_Drop
block|,
name|FOLLBY_TOKEN
block|}
block|,
comment|/* simulator commands */
block|{
literal|"simulate"
block|,
name|T_Simulate
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"simulation_duration"
block|,
name|T_Sim_Duration
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"beep_delay"
block|,
name|T_Beep_Delay
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"duration"
block|,
name|T_Duration
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"server_offset"
block|,
name|T_Server_Offset
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"freq_offset"
block|,
name|T_Freq_Offset
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"wander"
block|,
name|T_Wander
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"jitter"
block|,
name|T_Jitter
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"prop_delay"
block|,
name|T_Prop_Delay
block|,
name|FOLLBY_TOKEN
block|}
block|,
block|{
literal|"proc_delay"
block|,
name|T_Proc_Delay
block|,
name|FOLLBY_TOKEN
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|big_scan_state_tag
block|{
name|char
name|ch
decl_stmt|;
comment|/* Character this state matches on */
name|char
name|followedby
decl_stmt|;
comment|/* Forces next token(s) to T_String */
name|u_short
name|finishes_token
decl_stmt|;
comment|/* nonzero ID if last keyword char */
name|u_short
name|match_next_s
decl_stmt|;
comment|/* next state to check matching ch */
name|u_short
name|other_next_s
decl_stmt|;
comment|/* next state to check if not ch */
block|}
name|big_scan_state
typedef|;
end_typedef

begin_comment
comment|/*  * Note: to increase MAXSTATES beyond 2048, be aware it is currently  * crammed into 11 bits in scan_state form.  Raising to 4096 would be  * relatively easy by storing the followedby value in a separate  * array with one entry per token, and shrinking the char value to  * 7 bits to free a bit for accepting/non-accepting.  More than 4096  * states will require expanding scan_state beyond 32 bits each.  */
end_comment

begin_define
define|#
directive|define
name|MAXSTATES
value|2048
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|current_keyword
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for error reporting */
end_comment

begin_decl_stmt
name|big_scan_state
name|sst
index|[
name|MAXSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanner FSM state entries */
end_comment

begin_decl_stmt
name|int
name|sst_highwater
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next entry index to consider */
end_comment

begin_decl_stmt
name|char
modifier|*
name|symb
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map token ID to symbolic name */
end_comment

begin_comment
comment|/* for libntp */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|progname
init|=
literal|"keyword-gen"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|int
name|debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_preamble
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_fsm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_token_text
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_keyword_scanner
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_scan_states
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|follby
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_key_tok_id
parameter_list|(
name|QSORTP
parameter_list|,
name|QSORTP
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_key_tok_text
parameter_list|(
name|QSORTP
parameter_list|,
name|QSORTP
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|populate_symb
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|symbname
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:\n%s t_header.h\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|populate_symb
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|generate_preamble
argument_list|()
expr_stmt|;
name|generate_token_text
argument_list|()
expr_stmt|;
name|generate_fsm
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_preamble
parameter_list|(
name|void
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
name|char
name|timestamp
index|[
literal|128
index|]
decl_stmt|;
name|char
name|preamble
index|[]
init|=
literal|"/*\n"
literal|" * ntp_keyword.h\n"
literal|" * \n"
literal|" * NOTE: edit this file with caution, it is generated by keyword-gen.c\n"
literal|" *\t Generated %s UTC	  diff_ignore_line\n"
literal|" *\n"
literal|" */\n"
literal|"#include \"ntp_scanner.h\"\n"
literal|"#include \"ntp_parser.h\"\n"
literal|"\n"
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strftime
argument_list|(
name|timestamp
argument_list|,
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|,
literal|"%Y-%m-%d %H:%M:%S"
argument_list|,
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
condition|)
name|timestamp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
name|preamble
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_fsm
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|token_id_comment
index|[
literal|128
index|]
decl_stmt|;
name|int
name|initial_state
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|token
decl_stmt|;
comment|/*  	 * Sort ntp_keywords in alphabetical keyword order.  This is 	 * not necessary, but minimizes nonfunctional changes in the 	 * generated finite state machine when keywords are modified. 	 */
name|qsort
argument_list|(
name|ntp_keywords
argument_list|,
name|COUNTOF
argument_list|(
name|ntp_keywords
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ntp_keywords
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_key_tok_text
argument_list|)
expr_stmt|;
comment|/* 	 * To save space, reserve the state array entry matching each  	 * token number for its terminal state, so the token identifier 	 * does not need to be stored in each state, but can be 	 * recovered trivially.  To mark the entry reserved, 	 * finishes_token is nonzero. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|ntp_keywords
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|token
operator|=
name|ntp_keywords
index|[
name|i
index|]
operator|.
name|token
expr_stmt|;
if|if
condition|(
literal|1
operator|>
name|token
operator|||
name|token
operator|>=
name|COUNTOF
argument_list|(
name|sst
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"keyword-gen sst[%u] too small "
literal|"for keyword '%s' id %d\n"
argument_list|,
name|COUNTOF
argument_list|(
name|sst
argument_list|)
argument_list|,
name|ntp_keywords
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|sst
index|[
name|token
index|]
operator|.
name|finishes_token
operator|=
name|token
expr_stmt|;
block|}
name|initial_state
operator|=
name|create_keyword_scanner
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d keywords consumed %d states of %d max.\n"
argument_list|,
operator|(
name|int
operator|)
name|COUNTOF
argument_list|(
name|ntp_keywords
argument_list|)
argument_list|,
name|sst_highwater
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|COUNTOF
argument_list|(
name|sst
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define SCANNER_INIT_S %d\n\n"
argument_list|,
name|initial_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"const scan_state sst[%d] = {\n"
literal|"/*SS_T( ch,\tf-by, match, other ),\t\t\t\t */\n"
literal|"  0,\t\t\t\t      /* %5d %-17s */\n"
argument_list|,
name|sst_highwater
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sst_highwater
condition|;
name|i
operator|++
control|)
block|{
comment|/* verify fields will fit */
if|if
condition|(
name|sst
index|[
name|i
index|]
operator|.
name|followedby
operator|&
operator|~
literal|0x3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"keyword-gen internal error "
literal|"sst[%d].followedby %d too big\n"
argument_list|,
name|i
argument_list|,
name|sst
index|[
name|i
index|]
operator|.
name|followedby
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sst_highwater
operator|<=
name|sst
index|[
name|i
index|]
operator|.
name|match_next_s
operator|||
name|sst
index|[
name|i
index|]
operator|.
name|match_next_s
operator|&
operator|~
literal|0x7ff
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"keyword-gen internal error "
literal|"sst[%d].match_next_s %d too big\n"
argument_list|,
name|i
argument_list|,
name|sst
index|[
name|i
index|]
operator|.
name|match_next_s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sst_highwater
operator|<=
name|sst
index|[
name|i
index|]
operator|.
name|other_next_s
operator|||
name|sst
index|[
name|i
index|]
operator|.
name|other_next_s
operator|&
operator|~
literal|0x7ff
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"keyword-gen internal error "
literal|"sst[%d].other_next_s %d too big\n"
argument_list|,
name|i
argument_list|,
name|sst
index|[
name|i
index|]
operator|.
name|other_next_s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sst
index|[
name|i
index|]
operator|.
name|finishes_token
condition|)
name|snprintf
argument_list|(
name|token_id_comment
argument_list|,
sizeof|sizeof
argument_list|(
name|token_id_comment
argument_list|)
argument_list|,
literal|"%5d %-17s"
argument_list|,
name|i
argument_list|,
operator|(
name|initial_state
operator|==
name|i
operator|)
condition|?
literal|"initial state"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
name|snprintf
argument_list|(
name|token_id_comment
argument_list|,
sizeof|sizeof
argument_list|(
name|token_id_comment
argument_list|)
argument_list|,
literal|"%5d %-17s"
argument_list|,
name|i
argument_list|,
name|symbname
argument_list|(
name|sst
index|[
name|i
index|]
operator|.
name|finishes_token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|sst
index|[
name|i
index|]
operator|.
name|finishes_token
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"keyword-gen internal error "
literal|"entry %d finishes token %d\n"
argument_list|,
name|i
argument_list|,
name|sst
index|[
name|i
index|]
operator|.
name|finishes_token
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"  S_ST( '%c',\t%d,    %5u, %5u )%s /* %s */\n"
argument_list|,
name|sst
index|[
name|i
index|]
operator|.
name|ch
argument_list|,
name|sst
index|[
name|i
index|]
operator|.
name|followedby
argument_list|,
name|sst
index|[
name|i
index|]
operator|.
name|match_next_s
argument_list|,
name|sst
index|[
name|i
index|]
operator|.
name|other_next_s
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|<
name|sst_highwater
operator|)
condition|?
literal|","
else|:
literal|" "
argument_list|,
name|token_id_comment
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a function to create the states of the scanner. This function  * is used by the create_keyword_scanner function below.  *  * This function takes a suffix of a keyword, the token to be returned on  * recognizing the complete keyword, and any pre-existing state that exists  * for some other keyword that has the same prefix as the current one.  */
end_comment

begin_function
specifier|static
name|int
name|create_scan_states
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|int
name|token
parameter_list|,
name|follby
name|followedby
parameter_list|,
name|int
name|prev_state
parameter_list|)
block|{
name|int
name|my_state
decl_stmt|;
name|int
name|return_state
decl_stmt|;
name|int
name|prev_char_s
decl_stmt|;
name|int
name|curr_char_s
decl_stmt|;
name|return_state
operator|=
name|prev_state
expr_stmt|;
name|curr_char_s
operator|=
name|prev_state
expr_stmt|;
name|prev_char_s
operator|=
literal|0
expr_stmt|;
comment|/* Find the correct position to insert the state.  	 * All states should be in alphabetical order 	 */
while|while
condition|(
name|curr_char_s
operator|&&
operator|(
name|text
index|[
literal|0
index|]
operator|<
name|sst
index|[
name|curr_char_s
index|]
operator|.
name|ch
operator|)
condition|)
block|{
name|prev_char_s
operator|=
name|curr_char_s
expr_stmt|;
name|curr_char_s
operator|=
name|sst
index|[
name|curr_char_s
index|]
operator|.
name|other_next_s
expr_stmt|;
block|}
comment|/*  	 * Check if a previously seen keyword has the same prefix as 	 * the current keyword.  If so, simply use the state for that 	 * keyword as my_state, otherwise, allocate a new state. 	 */
if|if
condition|(
name|curr_char_s
operator|&&
operator|(
name|text
index|[
literal|0
index|]
operator|==
name|sst
index|[
name|curr_char_s
index|]
operator|.
name|ch
operator|)
condition|)
block|{
name|my_state
operator|=
name|curr_char_s
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|text
index|[
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate entries for keyword '%s' in"
literal|" keyword_gen.c ntp_keywords[].\n"
argument_list|,
name|current_keyword
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
name|my_state
operator|=
name|sst_highwater
operator|++
expr_stmt|;
do|while
condition|(
name|my_state
operator|<
name|COUNTOF
argument_list|(
name|sst
argument_list|)
operator|&&
name|sst
index|[
name|my_state
index|]
operator|.
name|finishes_token
condition|)
do|;
if|if
condition|(
name|my_state
operator|>=
name|COUNTOF
argument_list|(
name|sst
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fatal, keyword scanner state array "
literal|"sst[%d] is too small, modify\n"
literal|"keyword-gen.c to increase.\n"
argument_list|,
operator|(
name|int
operator|)
name|COUNTOF
argument_list|(
name|sst
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Store the next character of the keyword */
name|sst
index|[
name|my_state
index|]
operator|.
name|ch
operator|=
name|text
index|[
literal|0
index|]
expr_stmt|;
name|sst
index|[
name|my_state
index|]
operator|.
name|other_next_s
operator|=
name|curr_char_s
expr_stmt|;
name|sst
index|[
name|my_state
index|]
operator|.
name|followedby
operator|=
name|FOLLBY_NON_ACCEPTING
expr_stmt|;
if|if
condition|(
name|prev_char_s
condition|)
name|sst
index|[
name|prev_char_s
index|]
operator|.
name|other_next_s
operator|=
name|my_state
expr_stmt|;
else|else
name|return_state
operator|=
name|my_state
expr_stmt|;
block|}
comment|/* Check if the next character is '\0'. 	 * If yes, we are done with the recognition and this is an accepting 	 * state. 	 * If not, we need to continue scanning 	 */
if|if
condition|(
literal|'\0'
operator|==
name|text
index|[
literal|1
index|]
condition|)
block|{
name|sst
index|[
name|my_state
index|]
operator|.
name|finishes_token
operator|=
operator|(
name|u_short
operator|)
name|token
expr_stmt|;
name|sst
index|[
name|my_state
index|]
operator|.
name|followedby
operator|=
operator|(
name|char
operator|)
name|followedby
expr_stmt|;
if|if
condition|(
name|sst
index|[
name|token
index|]
operator|.
name|finishes_token
operator|!=
operator|(
name|u_short
operator|)
name|token
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fatal, sst[%d] not reserved for %s.\n"
argument_list|,
name|token
argument_list|,
name|symbname
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
comment|/* relocate so token id is sst[] index */
if|if
condition|(
name|my_state
operator|!=
name|token
condition|)
block|{
name|sst
index|[
name|token
index|]
operator|=
name|sst
index|[
name|my_state
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sst
index|[
name|my_state
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sst
index|[
name|my_state
index|]
argument_list|)
argument_list|)
expr_stmt|;
do|do
name|sst_highwater
operator|--
expr_stmt|;
do|while
condition|(
name|sst
index|[
name|sst_highwater
index|]
operator|.
name|finishes_token
condition|)
do|;
name|my_state
operator|=
name|token
expr_stmt|;
if|if
condition|(
name|prev_char_s
condition|)
name|sst
index|[
name|prev_char_s
index|]
operator|.
name|other_next_s
operator|=
name|my_state
expr_stmt|;
else|else
name|return_state
operator|=
name|my_state
expr_stmt|;
block|}
block|}
else|else
name|sst
index|[
name|my_state
index|]
operator|.
name|match_next_s
operator|=
name|create_scan_states
argument_list|(
operator|&
name|text
index|[
literal|1
index|]
argument_list|,
name|token
argument_list|,
name|followedby
argument_list|,
name|sst
index|[
name|my_state
index|]
operator|.
name|match_next_s
argument_list|)
expr_stmt|;
return|return
name|return_state
return|;
block|}
end_function

begin_comment
comment|/* Define a function that takes a list of (keyword, token) values and  * creates a keywords scanner out of it.  */
end_comment

begin_function
specifier|static
name|int
name|create_keyword_scanner
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|scanner
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sst_highwater
operator|=
literal|1
expr_stmt|;
comment|/* index 0 invalid, unused */
name|scanner
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|ntp_keywords
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|current_keyword
operator|=
name|ntp_keywords
index|[
name|i
index|]
operator|.
name|key
expr_stmt|;
name|scanner
operator|=
name|create_scan_states
argument_list|(
name|ntp_keywords
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|ntp_keywords
index|[
name|i
index|]
operator|.
name|token
argument_list|,
name|ntp_keywords
index|[
name|i
index|]
operator|.
name|followedby
argument_list|,
name|scanner
argument_list|)
expr_stmt|;
block|}
return|return
name|scanner
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_token_text
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|lowest_id
decl_stmt|;
name|int
name|highest_id
decl_stmt|;
name|int
name|id_count
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* sort ntp_keywords in token ID order */
name|qsort
argument_list|(
name|ntp_keywords
argument_list|,
name|COUNTOF
argument_list|(
name|ntp_keywords
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ntp_keywords
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_key_tok_id
argument_list|)
expr_stmt|;
name|lowest_id
operator|=
name|ntp_keywords
index|[
literal|0
index|]
operator|.
name|token
expr_stmt|;
name|highest_id
operator|=
name|ntp_keywords
index|[
name|COUNTOF
argument_list|(
name|ntp_keywords
argument_list|)
operator|-
literal|1
index|]
operator|.
name|token
expr_stmt|;
name|id_count
operator|=
name|highest_id
operator|-
name|lowest_id
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"#define LOWEST_KEYWORD_ID %d\n\n"
argument_list|,
name|lowest_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"const char * const keyword_text[%d] = {"
argument_list|,
name|id_count
argument_list|)
expr_stmt|;
name|id
operator|=
name|lowest_id
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|COUNTOF
argument_list|(
name|ntp_keywords
argument_list|)
condition|)
block|{
while|while
condition|(
name|id
operator|<
name|ntp_keywords
index|[
name|i
index|]
operator|.
name|token
condition|)
block|{
name|printf
argument_list|(
literal|",\n\t/* %-5d %5d %20s */\tNULL"
argument_list|,
name|id
operator|-
name|lowest_id
argument_list|,
name|id
argument_list|,
name|symbname
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t/* %-5d %5d %20s */\t\"%s\""
argument_list|,
name|id
operator|-
name|lowest_id
argument_list|,
name|id
argument_list|,
name|symbname
argument_list|(
name|id
argument_list|)
argument_list|,
name|ntp_keywords
index|[
name|i
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|id
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n};\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|compare_key_tok_id
parameter_list|(
name|QSORTP
name|a1
parameter_list|,
name|QSORTP
name|a2
parameter_list|)
block|{
specifier|const
name|struct
name|key_tok
modifier|*
name|p1
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|a1
decl_stmt|;
specifier|const
name|struct
name|key_tok
modifier|*
name|p2
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|a2
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|token
operator|==
name|p2
operator|->
name|token
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p1
operator|->
name|token
operator|<
name|p2
operator|->
name|token
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|compare_key_tok_text
parameter_list|(
name|QSORTP
name|a1
parameter_list|,
name|QSORTP
name|a2
parameter_list|)
block|{
specifier|const
name|struct
name|key_tok
modifier|*
name|p1
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|a1
decl_stmt|;
specifier|const
name|struct
name|key_tok
modifier|*
name|p2
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|a2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|p1
operator|->
name|key
argument_list|,
name|p2
operator|->
name|key
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * populate_symb() - populate symb[] lookup array with symbolic token  *		     names such that symb[T_Age] == "T_Age", etc.  */
end_comment

begin_function
name|void
name|populate_symb
parameter_list|(
name|char
modifier|*
name|header_file
parameter_list|)
block|{
name|FILE
modifier|*
name|yh
decl_stmt|;
name|char
name|line
index|[
literal|128
index|]
decl_stmt|;
name|char
name|name
index|[
literal|128
index|]
decl_stmt|;
name|int
name|token
decl_stmt|;
name|yh
operator|=
name|fopen
argument_list|(
name|header_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|yh
condition|)
block|{
name|perror
argument_list|(
literal|"unable to open yacc/bison header file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|NULL
operator|!=
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|yh
argument_list|)
condition|)
if|if
condition|(
literal|2
operator|==
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"#define %s %d"
argument_list|,
name|name
argument_list|,
operator|&
name|token
argument_list|)
operator|&&
literal|'T'
operator|==
name|name
index|[
literal|0
index|]
operator|&&
literal|'_'
operator|==
name|name
index|[
literal|1
index|]
operator|&&
name|token
operator|>=
literal|0
operator|&&
name|token
operator|<
name|COUNTOF
argument_list|(
name|symb
argument_list|)
condition|)
name|symb
index|[
name|token
index|]
operator|=
name|estrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|yh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|symbname
parameter_list|(
name|int
name|token
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|token
operator|>=
literal|0
operator|&&
name|token
operator|<
name|COUNTOF
argument_list|(
name|symb
argument_list|)
operator|&&
name|symb
index|[
name|token
index|]
operator|!=
name|NULL
condition|)
return|return
name|symb
index|[
name|token
index|]
return|;
name|LIB_GETBUF
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
literal|"%d"
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

end_unit

