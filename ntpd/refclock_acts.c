begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_acts - clock driver for the NIST/USNO/PTB/NPL Computer Time  *	Services  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_ACTS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_IOCTL_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_comment
comment|/* ports/winnt/include/config.h: #define write _write */
end_comment

begin_function_decl
specifier|extern
name|int
name|async_write
parameter_list|(
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|write
parameter_list|(
name|fd
parameter_list|,
name|data
parameter_list|,
name|octets
parameter_list|)
value|async_write(fd, data, octets)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This driver supports the US (NIST, USNO) and European (PTB, NPL,  * etc.) modem time services, as well as Spectracom GPS and WWVB  * receivers connected via a modem. The driver periodically dials a  * number from a telephone list, receives the timecode data and  * calculates the local clock correction. It is designed primarily for  * use as backup when neither a radio clock nor connectivity to Internet  * time servers is available.  *  * This driver requires a modem with a Hayes-compatible command set and  * control over the modem data terminal ready (DTR) control line. The  * modem setup string is hard-coded in the driver and may require  * changes for nonstandard modems or special circumstances.  *  * When enabled, the calling program dials the first number in the  * phones file. If that call fails, it dials the second number and  * so on. The phone number is specified by the Hayes ATDT prefix  * followed by the number itself, including the long-distance prefix  * and delay code, if necessary. The calling program is enabled  * when (a) fudge flag1 is set by ntpdc, (b) at each poll interval  * when no other synchronization sources are present, and (c) at each  * poll interval whether or not other synchronization sources are   * present. The calling program disconnects if (a) the called party  * is busy or does not answer, (b) the called party disconnects  * before a sufficient nuimber of timecodes have been received.   *  * The driver is transparent to each of the modem time services and  * Spectracom radios. It selects the parsing algorithm depending on the  * message length. There is some hazard should the message be corrupted.  * However, the data format is checked carefully and only if all checks  * succeed is the message accepted. Corrupted lines are discarded  * without complaint.  *  * Fudge controls  *  * flag1	force a call in manual mode  * flag2	enable port locking (not verified)  * flag3	not used  * flag4	not used  *  * time1	offset adjustment (s)  *  * Ordinarily, the serial port is connected to a modem and the phones  * list is defined. If no phones list is defined, the port can be   * connected directly to a device or another computer. In this case the  * driver will send a single character 'T' at each poll event. If  * fudge flag2 is enabled, port locking allows the modem to be shared  * when not in use by this driver.  */
end_comment

begin_comment
comment|/*  * National Institute of Science and Technology (NIST)  *  * Phone: (303) 494-4774 (Boulder, CO); (808) 335-4721 (Hawaii)  *  * Data Format  *  * National Institute of Standards and Technology  * Telephone Time Service, Generator 3B  * Enter question mark "?" for HELP  *                         D  L D  *  MJD  YR MO DA H  M  S  ST S UT1 msADV<OTM>  * 47999 90-04-18 21:39:15 50 0 +.1 045.0 UTC(NIST) *<CR><LF>  * ...  *  * MJD, DST, DUT1 and UTC are not used by this driver. The "*" or "#" is  * the on-time markers echoed by the driver and used by NIST to measure  * and correct for the propagation delay. Note: the ACTS timecode has  * recently been changed to eliminate the * on-time indicator. The  * reason for this and the long term implications are not clear.  *  * US Naval Observatory (USNO)  *  * Phone: (202) 762-1594 (Washington, DC); (719) 567-6742 (Boulder, CO)  *  * Data Format (two lines, repeating at one-second intervals)  *  * jjjjj nnn hhmmss UTC<CR><LF>  * *<CR><LF>  *  * jjjjj	modified Julian day number (not used)  * nnn		day of year  * hhmmss	second of day  * *		on-time marker for previous timecode  * ...  *  * USNO does not correct for the propagation delay. A fudge time1 of  * about .06 s is advisable.  *  * European Services (PTB, NPL, etc.)  *  * PTB: +49 531 512038 (Germany)  * NPL: 0906 851 6333 (UK only)  *  * Data format (see the documentation for phone numbers and formats.)  *  * 1995-01-23 20:58:51 MEZ  10402303260219950123195849740+40000500<CR><LF>  *  * Spectracom GPS and WWVB Receivers  *  * If a modem is connected to a Spectracom receiver, this driver will  * call it up and retrieve the time in one of two formats. As this  * driver does not send anything, the radio will have to either be  * configured in continuous mode or be polled by another local driver.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/acts%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B19200
end_define

begin_comment
comment|/* uart speed (19200 bps) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|LOCKFILE
value|"/var/spool/lock/LCK..cua%d"
end_define

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Automated Computer Time Service"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"NONE"
end_define

begin_comment
comment|/* default reference ID */
end_comment

begin_define
define|#
directive|define
name|MSGCNT
value|20
end_define

begin_comment
comment|/* max message count */
end_comment

begin_define
define|#
directive|define
name|MAXPHONE
value|10
end_define

begin_comment
comment|/* max number of phone numbers */
end_comment

begin_comment
comment|/*  * Calling program modes (mode)  */
end_comment

begin_define
define|#
directive|define
name|MODE_BACKUP
value|0
end_define

begin_comment
comment|/* backup mode */
end_comment

begin_define
define|#
directive|define
name|MODE_AUTO
value|1
end_define

begin_comment
comment|/* automatic mode */
end_comment

begin_define
define|#
directive|define
name|MODE_MANUAL
value|2
end_define

begin_comment
comment|/* manual mode */
end_comment

begin_comment
comment|/*  * Service identifiers (message length)  */
end_comment

begin_define
define|#
directive|define
name|REFACTS
value|"NIST"
end_define

begin_comment
comment|/* NIST reference ID */
end_comment

begin_define
define|#
directive|define
name|LENACTS
value|50
end_define

begin_comment
comment|/* NIST format A */
end_comment

begin_define
define|#
directive|define
name|REFUSNO
value|"USNO"
end_define

begin_comment
comment|/* USNO reference ID */
end_comment

begin_define
define|#
directive|define
name|LENUSNO
value|20
end_define

begin_comment
comment|/* USNO */
end_comment

begin_define
define|#
directive|define
name|REFPTB
value|"PTB\0"
end_define

begin_comment
comment|/* PTB/NPL reference ID */
end_comment

begin_define
define|#
directive|define
name|LENPTB
value|78
end_define

begin_comment
comment|/* PTB/NPL format */
end_comment

begin_define
define|#
directive|define
name|REFWWVB
value|"WWVB"
end_define

begin_comment
comment|/* WWVB reference ID */
end_comment

begin_define
define|#
directive|define
name|LENWWVB0
value|22
end_define

begin_comment
comment|/* WWVB format 0 */
end_comment

begin_define
define|#
directive|define
name|LENWWVB2
value|24
end_define

begin_comment
comment|/* WWVB format 2 */
end_comment

begin_define
define|#
directive|define
name|LF
value|0x0a
end_define

begin_comment
comment|/* ASCII LF */
end_comment

begin_comment
comment|/*  * Modem setup strings. These may have to be changed for  * some modems.  *  * AT	command prefix  * B1	US answer tone  *&C0	disable carrier detect  *&D2	hang up and return to command mode on DTR transition  * E0	modem command echo disabled  * L1	set modem speaker volume to low level  * M1	speaker enabled until carrier detect  * Q0	return result codes  * V1	return result codes as English words  * Y1	enable long-space disconnect  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|def_modem_setup
index|[]
init|=
literal|"ATB1&C0&D2E0L1M1Q0V1Y1"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|modem_setup
init|=
name|def_modem_setup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Timeouts (all in seconds)  */
end_comment

begin_define
define|#
directive|define
name|SETUP
value|3
end_define

begin_comment
comment|/* setup timeout */
end_comment

begin_define
define|#
directive|define
name|REDIAL
value|30
end_define

begin_comment
comment|/* redial timeout */
end_comment

begin_define
define|#
directive|define
name|ANSWER
value|60
end_define

begin_comment
comment|/* answer timeout */
end_comment

begin_define
define|#
directive|define
name|TIMECODE
value|60
end_define

begin_comment
comment|/* message timeout */
end_comment

begin_define
define|#
directive|define
name|MAXCODE
value|20
end_define

begin_comment
comment|/* max timecodes */
end_comment

begin_comment
comment|/*  * State machine codes  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|S_IDLE
block|,
comment|/* wait for poll */
name|S_SETUP
block|,
comment|/* send modem setup */
name|S_CONNECT
block|,
comment|/* wait for answer */
name|S_MSG
comment|/* wait for timecode */
block|}
name|teModemState
typedef|;
end_typedef

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|actsunit
block|{
name|int
name|unit
decl_stmt|;
comment|/* unit number */
name|int
name|state
decl_stmt|;
comment|/* the first one was Delaware */
name|int
name|timer
decl_stmt|;
comment|/* timeout counter */
name|int
name|retry
decl_stmt|;
comment|/* retry index */
name|int
name|msgcnt
decl_stmt|;
comment|/* count of messages received */
name|l_fp
name|tstamp
decl_stmt|;
comment|/* on-time timestamp */
name|char
modifier|*
name|bufptr
decl_stmt|;
comment|/* next incoming char stored here */
name|char
name|buf
index|[
name|BMAX
index|]
decl_stmt|;
comment|/* bufptr roams within buf[] */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|acts_start
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acts_shutdown
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acts_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acts_message
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acts_timecode
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acts_poll
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acts_timeout
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|,
name|teModemState
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acts_timer
parameter_list|(
name|int
parameter_list|,
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acts_close
parameter_list|(
name|struct
name|peer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Transfer vector (conditional structure name)  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_acts
init|=
block|{
name|acts_start
block|,
comment|/* start up driver */
name|acts_shutdown
block|,
comment|/* shut down driver */
name|acts_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used */
name|noentry
block|,
comment|/* not used */
name|noentry
block|,
comment|/* not used */
name|acts_timer
comment|/* housekeeping timer */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|acts_start
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
specifier|const
name|char
modifier|*
name|setup
decl_stmt|;
comment|/* 	 * Allocate and initialize unit structure 	 */
name|up
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|actsunit
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
name|up
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|acts_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|peer
operator|->
name|sstclktype
operator|=
name|CTL_SST_TS_TELEPHONE
expr_stmt|;
name|up
operator|->
name|bufptr
operator|=
name|up
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|def_modem_setup
operator|==
name|modem_setup
condition|)
block|{
name|setup
operator|=
name|get_ext_sys_var
argument_list|(
literal|"modemsetup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup
operator|!=
name|NULL
condition|)
name|modem_setup
operator|=
name|estrdup
argument_list|(
name|setup
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * acts_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|acts_shutdown
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Warning: do this only when a call is not in progress. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
name|acts_close
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * acts_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|acts_receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|char
name|tbuf
index|[
sizeof|sizeof
argument_list|(
name|up
operator|->
name|buf
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|tptr
decl_stmt|;
name|int
name|octets
decl_stmt|;
comment|/* 	 * Initialize pointers and read the timecode and timestamp. Note 	 * we are in raw mode and victim of whatever the terminal 	 * interface kicks up; so, we have to reassemble messages from 	 * arbitrary fragments. Capture the timecode at the beginning of 	 * the message and at the '*' and '#' on-time characters. 	 */
name|peer
operator|=
name|rbufp
operator|->
name|recv_peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
name|octets
operator|=
sizeof|sizeof
argument_list|(
name|up
operator|->
name|buf
argument_list|)
operator|-
operator|(
name|up
operator|->
name|bufptr
operator|-
name|up
operator|->
name|buf
operator|)
expr_stmt|;
name|refclock_gtraw
argument_list|(
name|rbufp
argument_list|,
name|tbuf
argument_list|,
name|octets
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
for|for
control|(
name|tptr
operator|=
name|tbuf
init|;
operator|*
name|tptr
operator|!=
literal|'\0'
condition|;
name|tptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|tptr
operator|==
name|LF
condition|)
block|{
if|if
condition|(
name|up
operator|->
name|bufptr
operator|==
name|up
operator|->
name|buf
condition|)
block|{
name|up
operator|->
name|tstamp
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|*
name|up
operator|->
name|bufptr
operator|=
literal|'\0'
expr_stmt|;
name|up
operator|->
name|bufptr
operator|=
name|up
operator|->
name|buf
expr_stmt|;
name|acts_message
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|iscntrl
argument_list|(
operator|*
name|tptr
argument_list|)
condition|)
block|{
operator|*
name|up
operator|->
name|bufptr
operator|++
operator|=
operator|*
name|tptr
expr_stmt|;
if|if
condition|(
operator|*
name|tptr
operator|==
literal|'*'
operator|||
operator|*
name|tptr
operator|==
literal|'#'
condition|)
block|{
name|up
operator|->
name|tstamp
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|tptr
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"acts: write echo fails %m"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * acts_message - process message  */
end_comment

begin_function
name|void
name|acts_message
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|char
name|tbuf
index|[
name|BMAX
index|]
decl_stmt|;
name|int
name|dtr
init|=
name|TIOCM_DTR
decl_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"acts: %d %s\n"
operator|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|msg
argument_list|)
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * What to do depends on the state and the first token in the 	 * message. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Extract the first token in the line. 	 */
name|strlcpy
argument_list|(
name|tbuf
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
name|strtok
argument_list|(
name|tbuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|up
operator|->
name|state
condition|)
block|{
comment|/* 	 * We are waiting for the OK response to the modem setup 	 * command. When this happens, dial the number followed. 	 * If anything other than OK is received, just ignore it 	 * and wait for timeoue. 	 */
case|case
name|S_SETUP
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|tbuf
argument_list|,
literal|"OK"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We disable echo with MODEM_SETUP's E0 but 			 * if the modem was previously E1, we will 			 * see MODEM_SETUP echoed before the OK/ERROR. 			 * Ignore it. 			 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tbuf
argument_list|,
name|modem_setup
argument_list|)
condition|)
return|return;
break|break;
block|}
name|mprintf_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
literal|"DIAL #%d %s"
argument_list|,
name|up
operator|->
name|retry
argument_list|,
name|sys_phone
index|[
name|up
operator|->
name|retry
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|&
name|dtr
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"acts: ioctl(TIOCMBIS) failed: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|sys_phone
index|[
name|up
operator|->
name|retry
index|]
argument_list|,
name|strlen
argument_list|(
name|sys_phone
index|[
name|up
operator|->
name|retry
index|]
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"acts: write DIAL fails %m"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|up
operator|->
name|retry
operator|++
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|S_CONNECT
expr_stmt|;
name|up
operator|->
name|timer
operator|=
name|ANSWER
expr_stmt|;
return|return;
comment|/* 	 * We are waiting for the CONNECT response to the dial 	 * command. When this happens, listen for timecodes. If 	 * somthing other than CONNECT is received, like BUSY 	 * or NO CARRIER, abort the call. 	 */
case|case
name|S_CONNECT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|tbuf
argument_list|,
literal|"CONNECT"
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|report_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|S_MSG
expr_stmt|;
name|up
operator|->
name|timer
operator|=
name|TIMECODE
expr_stmt|;
return|return;
comment|/* 	 * We are waiting for a timecode response. Pass it to 	 * the parser. If NO CARRIER is received, save the 	 * messages and abort the call. 	 */
case|case
name|S_MSG
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|tbuf
argument_list|,
literal|"NO"
argument_list|)
operator|==
literal|0
condition|)
name|report_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|msgcnt
operator|<
name|MAXCODE
condition|)
name|acts_timecode
argument_list|(
name|peer
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|acts_timeout
argument_list|(
name|peer
argument_list|,
name|S_MSG
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Other response. Tell us about it. 	 */
name|report_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|acts_close
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * acts_timeout - called on timeout  */
end_comment

begin_function
specifier|static
name|void
name|acts_timeout
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
name|teModemState
name|dstate
parameter_list|)
block|{
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
name|char
name|lockfile
index|[
literal|128
index|]
decl_stmt|,
name|pidbuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* 	 * The state machine is driven by messages from the modem, 	 * when first started and at timeout. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
switch|switch
condition|(
name|dstate
condition|)
block|{
comment|/* 	 * System poll event. Lock the modem port, open the device 	 * and send the setup command. 	 */
case|case
name|S_IDLE
case|:
if|if
condition|(
operator|-
literal|1
operator|!=
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
return|return;
comment|/* port is already open */
comment|/* 		 * Lock the modem port. If busy, retry later. Note: if 		 * something fails between here and the close, the lock 		 * file may not be removed. 		 */
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
block|{
name|snprintf
argument_list|(
name|lockfile
argument_list|,
sizeof|sizeof
argument_list|(
name|lockfile
argument_list|)
argument_list|,
name|LOCKFILE
argument_list|,
name|up
operator|->
name|unit
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|lockfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
literal|"acts: port busy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|snprintf
argument_list|(
name|pidbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pidbuf
argument_list|)
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|u_int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|pidbuf
argument_list|,
name|strlen
argument_list|(
name|pidbuf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"acts: write lock fails %m"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Open the device in raw mode and link the I/O. 		 */
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
name|DEVICE
argument_list|,
name|up
operator|->
name|unit
argument_list|)
expr_stmt|;
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_ACTS
operator||
name|LDISC_RAW
operator||
name|LDISC_REMOTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"acts: open fails %m"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"acts: addclock fails"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|msgcnt
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|bufptr
operator|=
name|up
operator|->
name|buf
expr_stmt|;
comment|/* 		 * If the port is directly connected to the device, skip 		 * the modem business and send 'T' for Spectrabum. 		 */
if|if
condition|(
name|sys_phone
index|[
name|up
operator|->
name|retry
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"T"
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"acts: write T fails %m"
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|S_MSG
expr_stmt|;
name|up
operator|->
name|timer
operator|=
name|TIMECODE
expr_stmt|;
return|return;
block|}
comment|/* 		 * Initialize the modem. This works with Hayes- 		 * compatible modems. 		 */
name|mprintf_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
literal|"SETUP %s"
argument_list|,
name|modem_setup
argument_list|)
expr_stmt|;
name|rc
operator|=
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|modem_setup
argument_list|,
name|strlen
argument_list|(
name|modem_setup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"acts: write SETUP fails %m"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
name|S_SETUP
expr_stmt|;
name|up
operator|->
name|timer
operator|=
name|SETUP
expr_stmt|;
return|return;
comment|/* 	 * In SETUP state the modem did not respond OK to setup string. 	 */
case|case
name|S_SETUP
case|:
name|report_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
literal|"no modem"
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * In CONNECT state the call did not complete. Abort the call. 	 */
case|case
name|S_CONNECT
case|:
name|report_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
literal|"no answer"
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * In MSG states no further timecodes are expected. If any 	 * timecodes have arrived, update the clock. In any case, 	 * terminate the call. 	 */
case|case
name|S_MSG
case|:
if|if
condition|(
name|up
operator|->
name|msgcnt
operator|==
literal|0
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
literal|"no timecodes"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|acts_close
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * acts_close - close and prepare for next call.  *  * In ClOSE state no further protocol actions are required  * other than to close and release the device and prepare to  * dial the next number if necessary.  */
end_comment

begin_function
name|void
name|acts_close
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|char
name|lockfile
index|[
literal|128
index|]
decl_stmt|;
name|int
name|dtr
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|io
operator|.
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|report_event
argument_list|(
name|PEVNT_CLOCK
argument_list|,
name|peer
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
name|dtr
operator|=
name|TIOCM_DTR
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|dtr
argument_list|)
operator|<
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"acts: ioctl(TIOCMBIC) failed: %m"
argument_list|)
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
condition|)
block|{
name|snprintf
argument_list|(
name|lockfile
argument_list|,
sizeof|sizeof
argument_list|(
name|lockfile
argument_list|)
argument_list|,
name|LOCKFILE
argument_list|,
name|up
operator|->
name|unit
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|msgcnt
operator|==
literal|0
operator|&&
name|up
operator|->
name|retry
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sys_phone
index|[
name|up
operator|->
name|retry
index|]
operator|!=
name|NULL
condition|)
block|{
name|up
operator|->
name|state
operator|=
name|S_IDLE
expr_stmt|;
name|up
operator|->
name|timer
operator|=
name|REDIAL
expr_stmt|;
return|return;
block|}
block|}
name|up
operator|->
name|state
operator|=
name|S_IDLE
expr_stmt|;
name|up
operator|->
name|timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * acts_poll - called by the transmit routine  */
end_comment

begin_function
specifier|static
name|void
name|acts_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * This routine is called at every system poll. All it does is 	 * set flag1 under certain conditions. The real work is done by 	 * the timeout routine and state machine. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
switch|switch
condition|(
name|peer
operator|->
name|ttl
condition|)
block|{
comment|/* 	 * In manual mode the calling program is activated by the ntpdc 	 * program using the enable flag (fudge flag1), either manually 	 * or by a cron job. 	 */
case|case
name|MODE_MANUAL
case|:
return|return;
comment|/* 	 * In automatic mode the calling program runs continuously at 	 * intervals determined by the poll event or specified timeout. 	 */
case|case
name|MODE_AUTO
case|:
break|break;
comment|/* 	 * In backup mode the calling program runs continuously as long 	 * as either no peers are available or this peer is selected. 	 */
case|case
name|MODE_BACKUP
case|:
if|if
condition|(
operator|!
operator|(
name|sys_peer
operator|==
name|NULL
operator|||
name|sys_peer
operator|==
name|peer
operator|)
condition|)
return|return;
break|break;
block|}
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
if|if
condition|(
name|S_IDLE
operator|==
name|up
operator|->
name|state
condition|)
block|{
name|up
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
name|acts_timeout
argument_list|(
name|peer
argument_list|,
name|S_IDLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * acts_timer - called at one-second intervals  */
end_comment

begin_function
specifier|static
name|void
name|acts_timer
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|peer
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * This routine implments a timeout which runs for a programmed 	 * interval. The counter is initialized by the state machine and 	 * counts down to zero. Upon reaching zero, the state machine is 	 * called. If flag1 is set while timer is zero, force a call. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|timer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG1
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG1
expr_stmt|;
name|acts_timeout
argument_list|(
name|peer
argument_list|,
name|S_IDLE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|up
operator|->
name|timer
operator|--
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|timer
operator|==
literal|0
condition|)
name|acts_timeout
argument_list|(
name|peer
argument_list|,
name|up
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * acts_timecode - identify the service and parse the timecode message  */
end_comment

begin_function
name|void
name|acts_timecode
parameter_list|(
name|struct
name|peer
modifier|*
name|peer
parameter_list|,
comment|/* peer structure pointer */
specifier|const
name|char
modifier|*
name|str
comment|/* timecode string */
parameter_list|)
block|{
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|day
decl_stmt|;
comment|/* day of the month */
name|int
name|month
decl_stmt|;
comment|/* month of the year */
name|u_long
name|mjd
decl_stmt|;
comment|/* Modified Julian Day */
name|double
name|dut1
decl_stmt|;
comment|/* DUT adjustment */
name|u_int
name|dst
decl_stmt|;
comment|/* ACTS daylight/standard time */
name|u_int
name|leap
decl_stmt|;
comment|/* ACTS leap indicator */
name|double
name|msADV
decl_stmt|;
comment|/* ACTS transmit advance (ms) */
name|char
name|utc
index|[
literal|10
index|]
decl_stmt|;
comment|/* ACTS timescale */
name|char
name|flag
decl_stmt|;
comment|/* ACTS on-time character (* or #) */
name|char
name|synchar
decl_stmt|;
comment|/* WWVB synchronized indicator */
name|char
name|qualchar
decl_stmt|;
comment|/* WWVB quality indicator */
name|char
name|leapchar
decl_stmt|;
comment|/* WWVB leap indicator */
name|char
name|dstchar
decl_stmt|;
comment|/* WWVB daylight/savings indicator */
name|int
name|tz
decl_stmt|;
comment|/* WWVB timezone */
name|int
name|leapmonth
decl_stmt|;
comment|/* PTB/NPL month of leap */
name|char
name|leapdir
decl_stmt|;
comment|/* PTB/NPL leap direction */
comment|/* 	 * The parser selects the modem format based on the message 	 * length. Since the data are checked carefully, occasional 	 * errors due noise are forgivable. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|nsec
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
condition|)
block|{
comment|/* 	 * For USNO format on-time character '*', which is on a line by 	 * itself. Be sure a timecode has been received. 	 */
case|case
literal|1
case|:
if|if
condition|(
operator|*
name|str
operator|==
literal|'*'
operator|&&
name|up
operator|->
name|msgcnt
operator|>
literal|0
condition|)
break|break;
return|return;
comment|/* 	 * ACTS format A: "jjjjj yy-mm-dd hh:mm:ss ds l uuu aaaaa 	 * UTC(NIST) *". 	 */
case|case
name|LENACTS
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%5ld %2d-%2d-%2d %2d:%2d:%2d %2d %1d %3lf %5lf %9s %c"
argument_list|,
operator|&
name|mjd
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|leap
argument_list|,
operator|&
name|dut1
argument_list|,
operator|&
name|msADV
argument_list|,
name|utc
argument_list|,
operator|&
name|flag
argument_list|)
operator|!=
literal|13
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|day
operator|=
name|ymd2yd
argument_list|(
name|pp
operator|->
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
if|if
condition|(
name|leap
operator|==
literal|1
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
elseif|else
if|if
condition|(
name|leap
operator|==
literal|2
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFACTS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|msgcnt
operator|++
expr_stmt|;
if|if
condition|(
name|flag
operator|!=
literal|'#'
operator|&&
name|up
operator|->
name|msgcnt
operator|<
literal|10
condition|)
return|return;
break|break;
comment|/* 	 * USNO format: "jjjjj nnn hhmmss UTC" 	 */
case|case
name|LENUSNO
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%5ld %3d %2d%2d%2d %3s"
argument_list|,
operator|&
name|mjd
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
name|utc
argument_list|)
operator|!=
literal|6
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Wait for the on-time character, which follows in a 		 * separate message. There is no provision for leap 		 * warning. 		 */
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFUSNO
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|msgcnt
operator|++
expr_stmt|;
break|break;
comment|/* 	 * PTB/NPL format: "yyyy-mm-dd hh:mm:ss MEZ"  	 */
case|case
name|LENPTB
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%*4d-%*2d-%*2d %*2d:%*2d:%2d %*5c%*12c%4d%2d%2d%2d%2d%5ld%2lf%c%2d%3lf%*15c%c"
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|mjd
argument_list|,
operator|&
name|dut1
argument_list|,
operator|&
name|leapdir
argument_list|,
operator|&
name|leapmonth
argument_list|,
operator|&
name|msADV
argument_list|,
operator|&
name|flag
argument_list|)
operator|!=
literal|12
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
if|if
condition|(
name|leapmonth
operator|==
name|month
condition|)
block|{
if|if
condition|(
name|leapdir
operator|==
literal|'+'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
elseif|else
if|if
condition|(
name|leapdir
operator|==
literal|'-'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
block|}
name|pp
operator|->
name|day
operator|=
name|ymd2yd
argument_list|(
name|pp
operator|->
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFPTB
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|msgcnt
operator|++
expr_stmt|;
break|break;
comment|/* 	 * WWVB format 0: "I  ddd hh:mm:ss DTZ=nn" 	 */
case|case
name|LENWWVB0
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%c %3d %2d:%2d:%2d %cTZ=%2d"
argument_list|,
operator|&
name|synchar
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|dstchar
argument_list|,
operator|&
name|tz
argument_list|)
operator|!=
literal|7
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
if|if
condition|(
name|synchar
operator|!=
literal|' '
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFWWVB
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|msgcnt
operator|++
expr_stmt|;
break|break;
comment|/* 	 * WWVB format 2: "IQyy ddd hh:mm:ss.mmm LD" 	 */
case|case
name|LENWWVB2
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%c%c%2d %3d %2d:%2d:%2d.%3ld%c%c%c"
argument_list|,
operator|&
name|synchar
argument_list|,
operator|&
name|qualchar
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|pp
operator|->
name|nsec
argument_list|,
operator|&
name|dstchar
argument_list|,
operator|&
name|leapchar
argument_list|,
operator|&
name|dstchar
argument_list|)
operator|!=
literal|11
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|nsec
operator|*=
literal|1000000
expr_stmt|;
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
if|if
condition|(
name|synchar
operator|!=
literal|' '
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
elseif|else
if|if
condition|(
name|leapchar
operator|==
literal|'L'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFWWVB
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|msgcnt
operator|++
expr_stmt|;
break|break;
comment|/* 	 * None of the above. Just forget about it and wait for the next 	 * message or timeout. 	 */
default|default:
return|return;
block|}
comment|/* 	 * We have a valid timecode. The fudge time1 value is added to 	 * each sample by the main line routines. Note that in current 	 * telephone networks the propatation time can be different for 	 * each call and can reach 200 ms for some calls. 	 */
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|tstamp
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|msgcnt
operator|==
literal|0
condition|)
return|return;
name|strlcpy
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|a_lastcode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|lastref
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|refclock_acts_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

