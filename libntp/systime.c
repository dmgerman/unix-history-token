begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * systime -- routines to fiddle a UNIX clock.  *  * ATTENTION: Get approval from Dave Mills on all changes to this file!  *  */
end_comment

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_random.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_comment
comment|/* for sys_precision */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
end_ifdef

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTMP_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
end_ifdef

begin_include
include|#
directive|include
file|<utmpx.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTMPX_H */
end_comment

begin_define
define|#
directive|define
name|FUZZ
value|500e-6
end_define

begin_comment
comment|/* fuzz pivot */
end_comment

begin_comment
comment|/*  * These routines (get_systime, step_systime, adj_systime) implement an  * interface between the system independent NTP clock and the Unix  * system clock in various architectures and operating systems. Time is  * a precious quantity in these routines and every effort is made to  * minimize errors by unbiased rounding and amortizing adjustment  * residues.  *  * In order to improve the apparent resolution, provide unbiased  * rounding and insure that the readings cannot be predicted, the low-  * order unused portion of the time below the resolution limit is filled  * with an unbiased random fuzz.  *  * The sys_tick variable secifies the system clock tick interval in  * seconds. For systems that can interpolate between timer interrupts,  * the resolution is presumed much less than the time to read the system  * clock, which is the value of sys_tick after the precision has been  * determined. For those systems that cannot interpolate between timer  * interrupts, sys_tick will be much larger in the order of 10 ms, so the  * fuzz should be that value. For Sunses the tick is not interpolated, but  * the system clock is derived from a 2-MHz oscillator, so the resolution  * is 500 ns and sys_tick is 500 ns.  */
end_comment

begin_decl_stmt
name|double
name|sys_tick
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* precision (time to read the clock) */
end_comment

begin_decl_stmt
name|double
name|sys_residual
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adjustment residue (s) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIM
end_ifndef

begin_comment
comment|/*  * get_systime - return system time in NTP timestamp format.  */
end_comment

begin_function
name|void
name|get_systime
parameter_list|(
name|l_fp
modifier|*
name|now
comment|/* system time */
parameter_list|)
block|{
name|double
name|dtemp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CLOCK_GETTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETCLOCK
argument_list|)
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* seconds and nanoseconds */
comment|/* 	 * Convert Unix timespec from seconds and nanoseconds to NTP 	 * seconds and fraction. 	 */
ifdef|#
directive|ifdef
name|HAVE_CLOCK_GETTIME
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|now
operator|->
name|l_i
operator|=
operator|(
name|int32
operator|)
name|ts
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sys_tick
operator|>
name|FUZZ
condition|)
name|dtemp
operator|=
name|ntp_random
argument_list|()
operator|*
literal|2.
operator|/
name|FRAC
operator|*
name|sys_tick
operator|*
literal|1e9
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_tick
operator|>
literal|0
condition|)
name|dtemp
operator|=
name|ntp_random
argument_list|()
operator|*
literal|2.
operator|/
name|FRAC
expr_stmt|;
name|dtemp
operator|=
operator|(
name|ts
operator|.
name|tv_nsec
operator|+
name|dtemp
operator|)
operator|*
literal|1e-9
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
literal|1.
condition|)
block|{
name|dtemp
operator|-=
literal|1.
expr_stmt|;
name|now
operator|->
name|l_i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|dtemp
operator|+=
literal|1.
expr_stmt|;
name|now
operator|->
name|l_i
operator|--
expr_stmt|;
block|}
name|now
operator|->
name|l_uf
operator|=
call|(
name|u_int32
call|)
argument_list|(
name|dtemp
operator|*
name|FRAC
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_CLOCK_GETTIME || HAVE_GETCLOCK */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* seconds and microseconds */
comment|/* 	 * Convert Unix timeval from seconds and microseconds to NTP 	 * seconds and fraction. 	 */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|now
operator|->
name|l_i
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sys_tick
operator|>
name|FUZZ
condition|)
name|dtemp
operator|=
name|ntp_random
argument_list|()
operator|*
literal|2.
operator|/
name|FRAC
operator|*
name|sys_tick
operator|*
literal|1e6
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_tick
operator|>
literal|0
condition|)
name|dtemp
operator|=
name|ntp_random
argument_list|()
operator|*
literal|2.
operator|/
name|FRAC
expr_stmt|;
name|dtemp
operator|=
operator|(
name|tv
operator|.
name|tv_usec
operator|+
name|dtemp
operator|)
operator|*
literal|1e-6
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
literal|1.
condition|)
block|{
name|dtemp
operator|-=
literal|1.
expr_stmt|;
name|now
operator|->
name|l_i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|dtemp
operator|+=
literal|1.
expr_stmt|;
name|now
operator|->
name|l_i
operator|--
expr_stmt|;
block|}
name|now
operator|->
name|l_uf
operator|=
call|(
name|u_int32
call|)
argument_list|(
name|dtemp
operator|*
name|FRAC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_CLOCK_GETTIME || HAVE_GETCLOCK */
block|}
end_function

begin_comment
comment|/*  * adj_systime - adjust system time by the argument.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|SYS_WINNT
end_if

begin_function
name|int
comment|/* 0 okay, 1 error */
name|adj_systime
parameter_list|(
name|double
name|now
comment|/* adjustment (s) */
parameter_list|)
block|{
name|struct
name|timeval
name|adjtv
decl_stmt|;
comment|/* new adjustment */
name|struct
name|timeval
name|oadjtv
decl_stmt|;
comment|/* residual adjustment */
name|double
name|dtemp
decl_stmt|;
name|long
name|ticks
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
comment|/* 	 * Most Unix adjtime() implementations adjust the system clock 	 * in microsecond quanta, but some adjust in 10-ms quanta. We 	 * carefully round the adjustment to the nearest quantum, then 	 * adjust in quanta and keep the residue for later. 	 */
name|dtemp
operator|=
name|now
operator|+
name|sys_residual
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|=
operator|-
name|dtemp
expr_stmt|;
block|}
name|adjtv
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|dtemp
expr_stmt|;
name|dtemp
operator|-=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|ticks
operator|=
call|(
name|long
call|)
argument_list|(
name|dtemp
operator|/
name|sys_tick
operator|+
literal|.5
argument_list|)
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|ticks
operator|*
name|sys_tick
operator|*
literal|1e6
argument_list|)
expr_stmt|;
name|dtemp
operator|-=
name|adjtv
operator|.
name|tv_usec
operator|/
literal|1e6
expr_stmt|;
name|sys_residual
operator|=
name|dtemp
expr_stmt|;
comment|/* 	 * Convert to signed seconds and microseconds for the Unix 	 * adjtime() system call. Note we purposely lose the adjtime() 	 * leftover. 	 */
if|if
condition|(
name|isneg
condition|)
block|{
name|adjtv
operator|.
name|tv_sec
operator|=
operator|-
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
operator|-
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
name|sys_residual
operator|=
operator|-
name|sys_residual
expr_stmt|;
block|}
if|if
condition|(
name|adjtv
operator|.
name|tv_sec
operator|!=
literal|0
operator|||
name|adjtv
operator|.
name|tv_usec
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|adjtime
argument_list|(
operator|&
name|adjtv
argument_list|,
operator|&
name|oadjtv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"adj_systime: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * step_systime - step the system clock.  */
end_comment

begin_function
name|int
name|step_systime
parameter_list|(
name|double
name|now
parameter_list|)
block|{
name|struct
name|timeval
name|timetv
decl_stmt|,
name|adjtv
decl_stmt|,
name|oldtimetv
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CLOCK_GETTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETCLOCK
argument_list|)
name|struct
name|timespec
name|ts
decl_stmt|;
endif|#
directive|endif
name|dtemp
operator|=
name|sys_residual
operator|+
name|now
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|dtemp
operator|=
operator|-
name|dtemp
expr_stmt|;
name|adjtv
operator|.
name|tv_sec
operator|=
operator|(
name|int32
operator|)
name|dtemp
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
call|(
name|u_int32
call|)
argument_list|(
operator|(
name|dtemp
operator|-
operator|(
name|double
operator|)
name|adjtv
operator|.
name|tv_sec
operator|)
operator|*
literal|1e6
operator|+
literal|.5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adjtv
operator|.
name|tv_sec
operator|=
operator|(
name|int32
operator|)
name|dtemp
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
call|(
name|u_int32
call|)
argument_list|(
operator|(
name|dtemp
operator|-
operator|(
name|double
operator|)
name|adjtv
operator|.
name|tv_sec
operator|)
operator|*
literal|1e6
operator|+
literal|.5
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CLOCK_GETTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETCLOCK
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_CLOCK_GETTIME
operator|(
name|void
operator|)
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timetv
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
comment|/*  not HAVE_GETCLOCK */
operator|(
name|void
operator|)
name|GETTIMEOFDAY
argument_list|(
operator|&
name|timetv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_GETCLOCK */
name|oldtimetv
operator|=
name|timetv
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"step_systime: step %.6f residual %.6f\n"
argument_list|,
name|now
argument_list|,
name|sys_residual
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isneg
condition|)
block|{
name|timetv
operator|.
name|tv_sec
operator|-=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|-=
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timetv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|timetv
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
block|}
else|else
block|{
name|timetv
operator|.
name|tv_sec
operator|+=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|+=
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timetv
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|timetv
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ntp_set_tod
argument_list|(
operator|&
name|timetv
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"step-systime: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sys_residual
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_HPUX_ADJTIME
comment|/* 	 * CHECKME: is this correct when called by ntpdate????? 	 */
name|_clear_adjtime
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * FreeBSD, for example, has: 	 * struct utmp { 	 *	   char    ut_line[UT_LINESIZE]; 	 *	   char    ut_name[UT_NAMESIZE]; 	 *	   char    ut_host[UT_HOSTSIZE]; 	 *	   long    ut_time; 	 * }; 	 * and appends line="|", name="date", host="", time for the OLD 	 * and appends line="{", name="date", host="", time for the NEW 	 * to _PATH_WTMP . 	 * 	 * Some OSes have utmp, some have utmpx. 	 */
comment|/* 	 * Write old and new time entries in utmp and wtmp if step 	 * adjustment is greater than one second. 	 * 	 * This might become even Uglier... 	 */
if|if
condition|(
name|oldtimetv
operator|.
name|tv_sec
operator|!=
name|timetv
operator|.
name|tv_sec
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
name|struct
name|utmp
name|ut
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
name|struct
name|utmpx
name|utx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UTMP_H
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ut
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UTMPX_H
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|utx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|utx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UTMP */
ifdef|#
directive|ifdef
name|UPDATE_UTMP
ifdef|#
directive|ifdef
name|HAVE_PUTUTLINE
name|ut
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|oldtimetv
operator|.
name|tv_sec
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|timetv
operator|.
name|tv_sec
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* UPDATE_UTMP */
comment|/* UTMPX */
ifdef|#
directive|ifdef
name|UPDATE_UTMPX
ifdef|#
directive|ifdef
name|HAVE_PUTUTXLINE
name|utx
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|oldtimetv
expr_stmt|;
name|pututxline
argument_list|(
operator|&
name|utx
argument_list|)
expr_stmt|;
name|setutxent
argument_list|()
expr_stmt|;
name|utx
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|timetv
expr_stmt|;
name|pututxline
argument_list|(
operator|&
name|utx
argument_list|)
expr_stmt|;
name|endutxent
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* UPDATE_UTMPX */
comment|/* WTMP */
ifdef|#
directive|ifdef
name|UPDATE_WTMP
ifdef|#
directive|ifdef
name|HAVE_PUTUTLINE
name|utmpname
argument_list|(
name|WTMP_FILE
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|oldtimetv
operator|.
name|tv_sec
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|timetv
operator|.
name|tv_sec
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTLINE */
endif|#
directive|endif
comment|/* UPDATE_WTMP */
comment|/* WTMPX */
ifdef|#
directive|ifdef
name|UPDATE_WTMPX
ifdef|#
directive|ifdef
name|HAVE_PUTUTXLINE
name|utx
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|oldtimetv
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UPDWTMPX
name|updwtmpx
argument_list|(
name|WTMPX_FILE
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_UPDWTMPX */
endif|#
directive|endif
comment|/* not HAVE_UPDWTMPX */
else|#
directive|else
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTXLINE */
ifdef|#
directive|ifdef
name|HAVE_PUTUTXLINE
name|utx
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
name|utx
operator|.
name|ut_tv
operator|=
name|timetv
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|utx
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_UPDWTMPX
name|updwtmpx
argument_list|(
name|WTMPX_FILE
argument_list|,
operator|&
name|utx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_UPDWTMPX */
endif|#
directive|endif
comment|/* not HAVE_UPDWTMPX */
else|#
directive|else
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* not HAVE_PUTUTXLINE */
endif|#
directive|endif
comment|/* UPDATE_WTMPX */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SIM */
end_comment

begin_comment
comment|/*  * Clock routines for the simulator - Harish Nair, with help  */
end_comment

begin_comment
comment|/* SK:   * The code that used to be here has been moved to ntpsim.c,  * where, IMHO, it rightfully belonged.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

