begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_intres.c - Implements a generic blocking worker child or thread,  *		  initially to provide a nonblocking solution for DNS  *		  name to address lookups available with getaddrinfo().  *  * This is a new implementation as of 2009 sharing the filename and  * very little else with the prior implementation, which used a  * temporary file to receive a single set of requests from the parent,  * and a NTP mode 7 authenticated request to push back responses.  *  * A primary goal in rewriting this code was the need to support the  * pool configuration directive's requirement to retrieve multiple  * addresses resolving a single name, which has previously been  * satisfied with blocking resolver calls from the ntpd mainline code.  *  * A secondary goal is to provide a generic mechanism for other  * blocking operations to be delegated to a worker using a common  * model for both Unix and Windows ntpd.  ntp_worker.c, work_fork.c,  * and work_thread.c implement the generic mechanism.  This file  * implements the two current consumers, getaddrinfo_sometime() and the  * presently unused getnameinfo_sometime().  *  * Both routines deliver results to a callback and manage memory  * allocation, meaning there is no freeaddrinfo_sometime().  *  * The initial implementation for Unix uses a pair of unidirectional  * pipes, one each for requests and responses, connecting the forked  * blocking child worker with the ntpd mainline.  The threaded code  * uses arrays of pointers to queue requests and responses.  *  * The parent drives the process, including scheduling sleeps between  * retries.  *  * Memory is managed differently for a child process, which mallocs  * request buffers to read from the pipe into, whereas the threaded  * code mallocs a copy of the request to hand off to the worker via  * the queueing array.  The resulting request buffer is free()d by  * platform-independent code.  A wrinkle is the request needs to be  * available to the requestor during response processing.  *  * Response memory allocation is also platform-dependent.  With a  * separate process and pipes, the response is free()d after being  * written to the pipe.  With threads, the same memory is handed  * over and the requestor frees it after processing is completed.  *  * The code should be generalized to support threads on Unix using  * much of the same code used for Windows initially.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_workimpl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WORKER
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/**/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/**/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_RES_INIT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE___RES_INIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_RES_INIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_RESOLV_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_RES_INIT
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ARPA_NAMESER_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_comment
comment|/* DNS HEADER struct */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_INT32_ONLY_WITH_DNS
end_ifdef

begin_define
define|#
directive|define
name|HAVE_INT32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_U_INT32_ONLY_WITH_DNS
end_ifdef

begin_define
define|#
directive|define
name|HAVE_U_INT32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_debug.h"
end_include

begin_include
include|#
directive|include
file|"ntp_malloc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_intres.h"
end_include

begin_include
include|#
directive|include
file|"intreswork.h"
end_include

begin_comment
comment|/*  * Following are implementations of getaddrinfo_sometime() and  * getnameinfo_sometime().  Each is implemented in three routines:  *  * getaddrinfo_sometime()		getnameinfo_sometime()  * blocking_getaddrinfo()		blocking_getnameinfo()  * getaddrinfo_sometime_complete()	getnameinfo_sometime_complete()  *  * The first runs in the parent and marshalls (or serializes) request  * parameters into a request blob which is processed in the child by  * the second routine, blocking_*(), which serializes the results into  * a response blob unpacked by the third routine, *_complete(), which  * calls the callback routine provided with the request and frees  * _request_ memory allocated by the first routine.  Response memory  * is managed by the code which calls the *_complete routines.  */
end_comment

begin_comment
comment|/* === typedefs === */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|blocking_gai_req_tag
block|{
comment|/* marshalled args */
name|size_t
name|octets
decl_stmt|;
name|u_int
name|dns_idx
decl_stmt|;
name|time_t
name|scheduled
decl_stmt|;
name|time_t
name|earliest
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|gai_sometime_callback
name|callback
decl_stmt|;
name|void
modifier|*
name|context
decl_stmt|;
name|size_t
name|nodesize
decl_stmt|;
name|size_t
name|servsize
decl_stmt|;
block|}
name|blocking_gai_req
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|blocking_gai_resp_tag
block|{
name|size_t
name|octets
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|int
name|gai_errno
decl_stmt|;
comment|/* for EAI_SYSTEM case */
name|int
name|ai_count
decl_stmt|;
comment|/* 	 * Followed by ai_count struct addrinfo and then ai_count 	 * sockaddr_u and finally the canonical name strings. 	 */
block|}
name|blocking_gai_resp
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|blocking_gni_req_tag
block|{
name|size_t
name|octets
decl_stmt|;
name|u_int
name|dns_idx
decl_stmt|;
name|time_t
name|scheduled
decl_stmt|;
name|time_t
name|earliest
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|size_t
name|hostoctets
decl_stmt|;
name|size_t
name|servoctets
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|gni_sometime_callback
name|callback
decl_stmt|;
name|void
modifier|*
name|context
decl_stmt|;
name|sockaddr_u
name|socku
decl_stmt|;
block|}
name|blocking_gni_req
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|blocking_gni_resp_tag
block|{
name|size_t
name|octets
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|int
name|gni_errno
decl_stmt|;
comment|/* for EAI_SYSTEM case */
name|int
name|retry
decl_stmt|;
name|size_t
name|hostoctets
decl_stmt|;
name|size_t
name|servoctets
decl_stmt|;
comment|/* 	 * Followed by hostoctets bytes of null-terminated host, 	 * then servoctets bytes of null-terminated service. 	 */
block|}
name|blocking_gni_resp
typedef|;
end_typedef

begin_comment
comment|/* per-DNS-worker state in parent */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dnschild_ctx_tag
block|{
name|u_int
name|index
decl_stmt|;
name|time_t
name|next_dns_timeslot
decl_stmt|;
block|}
name|dnschild_ctx
typedef|;
end_typedef

begin_comment
comment|/* per-DNS-worker state in worker */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dnsworker_ctx_tag
block|{
name|blocking_child
modifier|*
name|c
decl_stmt|;
name|time_t
name|ignore_scheduled_before
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RES_INIT
name|time_t
name|next_res_init
decl_stmt|;
endif|#
directive|endif
block|}
name|dnsworker_ctx
typedef|;
end_typedef

begin_comment
comment|/* === variables === */
end_comment

begin_decl_stmt
name|dnschild_ctx
modifier|*
modifier|*
name|dnschild_contexts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parent */
end_comment

begin_decl_stmt
name|u_int
name|dnschild_contexts_alloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dnsworker_ctx
modifier|*
modifier|*
name|dnsworker_contexts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* child */
end_comment

begin_decl_stmt
name|u_int
name|dnsworker_contexts_alloc
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_RES_INIT
end_ifdef

begin_decl_stmt
specifier|static
name|time_t
name|next_res_init
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* === forward declarations === */
end_comment

begin_function_decl
specifier|static
name|u_int
name|reserve_dnschild_ctx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|get_dnschild_ctx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_dnsworker_context
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static	void		free_dnsworker_context(u_int); */
end_comment

begin_function_decl
specifier|static
name|dnsworker_ctx
modifier|*
name|get_worker_context
parameter_list|(
name|blocking_child
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scheduled_sleep
parameter_list|(
name|time_t
parameter_list|,
name|time_t
parameter_list|,
name|dnsworker_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|manage_dns_retry_interval
parameter_list|(
name|time_t
modifier|*
parameter_list|,
name|time_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|time_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|should_retry_dns
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_RES_INIT
end_ifdef

begin_function_decl
specifier|static
name|void
name|reload_resolv_conf
parameter_list|(
name|dnsworker_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|reload_resolv_conf
parameter_list|(
name|wc
parameter_list|)
define|\
value|do {						\ 		(void)(wc);				\ 	} while (FALSE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|getaddrinfo_sometime_complete
parameter_list|(
name|blocking_work_req
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getnameinfo_sometime_complete
parameter_list|(
name|blocking_work_req
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* === functions === */
end_comment

begin_comment
comment|/*  * getaddrinfo_sometime - uses blocking child to call getaddrinfo then  *			  invokes provided callback completion function.  */
end_comment

begin_function
name|int
name|getaddrinfo_sometime
parameter_list|(
specifier|const
name|char
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
name|int
name|retry
parameter_list|,
name|gai_sometime_callback
name|callback
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|blocking_gai_req
modifier|*
name|gai_req
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|dnschild_ctx
modifier|*
name|child_ctx
decl_stmt|;
name|size_t
name|req_size
decl_stmt|;
name|size_t
name|nodesize
decl_stmt|;
name|size_t
name|servsize
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|hints
condition|)
block|{
name|NTP_REQUIRE
argument_list|(
literal|0
operator|==
name|hints
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|==
name|hints
operator|->
name|ai_addr
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|==
name|hints
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|==
name|hints
operator|->
name|ai_next
argument_list|)
expr_stmt|;
block|}
name|idx
operator|=
name|get_dnschild_ctx
argument_list|()
expr_stmt|;
name|child_ctx
operator|=
name|dnschild_contexts
index|[
name|idx
index|]
expr_stmt|;
name|nodesize
operator|=
name|strlen
argument_list|(
name|node
argument_list|)
operator|+
literal|1
expr_stmt|;
name|servsize
operator|=
name|strlen
argument_list|(
name|service
argument_list|)
operator|+
literal|1
expr_stmt|;
name|req_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|gai_req
argument_list|)
operator|+
name|nodesize
operator|+
name|servsize
expr_stmt|;
name|gai_req
operator|=
name|emalloc_zero
argument_list|(
name|req_size
argument_list|)
expr_stmt|;
name|gai_req
operator|->
name|octets
operator|=
name|req_size
expr_stmt|;
name|gai_req
operator|->
name|dns_idx
operator|=
name|idx
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|gai_req
operator|->
name|scheduled
operator|=
name|now
expr_stmt|;
name|gai_req
operator|->
name|earliest
operator|=
name|max
argument_list|(
name|now
argument_list|,
name|child_ctx
operator|->
name|next_dns_timeslot
argument_list|)
expr_stmt|;
name|child_ctx
operator|->
name|next_dns_timeslot
operator|=
name|gai_req
operator|->
name|earliest
expr_stmt|;
if|if
condition|(
name|hints
operator|!=
name|NULL
condition|)
name|gai_req
operator|->
name|hints
operator|=
operator|*
name|hints
expr_stmt|;
name|gai_req
operator|->
name|retry
operator|=
name|retry
expr_stmt|;
name|gai_req
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|gai_req
operator|->
name|context
operator|=
name|context
expr_stmt|;
name|gai_req
operator|->
name|nodesize
operator|=
name|nodesize
expr_stmt|;
name|gai_req
operator|->
name|servsize
operator|=
name|servsize
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gai_req
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gai_req
argument_list|)
argument_list|,
name|node
argument_list|,
name|nodesize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gai_req
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gai_req
argument_list|)
operator|+
name|nodesize
argument_list|,
name|service
argument_list|,
name|servsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue_blocking_request
argument_list|(
name|BLOCKING_GETADDRINFO
argument_list|,
name|gai_req
argument_list|,
name|req_size
argument_list|,
operator|&
name|getaddrinfo_sometime_complete
argument_list|,
name|gai_req
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to queue getaddrinfo request"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|blocking_getaddrinfo
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|blocking_pipe_header
modifier|*
name|req
parameter_list|)
block|{
name|blocking_gai_req
modifier|*
name|gai_req
decl_stmt|;
name|dnsworker_ctx
modifier|*
name|worker_ctx
decl_stmt|;
name|blocking_pipe_header
modifier|*
name|resp
decl_stmt|;
name|blocking_gai_resp
modifier|*
name|gai_resp
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|service
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai_res
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|serialized_ai
decl_stmt|;
name|size_t
name|canons_octets
decl_stmt|;
name|size_t
name|this_octets
decl_stmt|;
name|size_t
name|resp_octets
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|time_t
name|time_now
decl_stmt|;
name|gai_req
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|req
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|)
expr_stmt|;
name|node
operator|=
operator|(
name|char
operator|*
operator|)
name|gai_req
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gai_req
argument_list|)
expr_stmt|;
name|service
operator|=
name|node
operator|+
name|gai_req
operator|->
name|nodesize
expr_stmt|;
name|worker_ctx
operator|=
name|get_worker_context
argument_list|(
name|c
argument_list|,
name|gai_req
operator|->
name|dns_idx
argument_list|)
expr_stmt|;
name|scheduled_sleep
argument_list|(
name|gai_req
operator|->
name|scheduled
argument_list|,
name|gai_req
operator|->
name|earliest
argument_list|,
name|worker_ctx
argument_list|)
expr_stmt|;
name|reload_resolv_conf
argument_list|(
name|worker_ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Take a shot at the final size, better to overestimate 	 * at first and then realloc to a smaller size. 	 */
name|resp_octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gai_resp
argument_list|)
operator|+
literal|16
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sockaddr_u
argument_list|)
operator|)
operator|+
literal|256
expr_stmt|;
name|resp
operator|=
name|emalloc_zero
argument_list|(
name|resp_octets
argument_list|)
expr_stmt|;
name|gai_resp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"blocking_getaddrinfo given node %s serv %s fam %d flags %x\n"
operator|,
name|node
operator|,
name|service
operator|,
name|gai_req
operator|->
name|hints
operator|.
name|ai_family
operator|,
name|gai_req
operator|->
name|hints
operator|.
name|ai_flags
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ai_res
operator|=
name|NULL
expr_stmt|;
name|gai_resp
operator|->
name|retcode
operator|=
name|getaddrinfo
argument_list|(
name|node
argument_list|,
name|service
argument_list|,
operator|&
name|gai_req
operator|->
name|hints
argument_list|,
operator|&
name|ai_res
argument_list|)
expr_stmt|;
name|gai_resp
operator|->
name|retry
operator|=
name|gai_req
operator|->
name|retry
expr_stmt|;
ifdef|#
directive|ifdef
name|EAI_SYSTEM
if|if
condition|(
name|EAI_SYSTEM
operator|==
name|gai_resp
operator|->
name|retcode
condition|)
name|gai_resp
operator|->
name|gai_errno
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
name|canons_octets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|gai_resp
operator|->
name|retcode
condition|)
block|{
name|ai
operator|=
name|ai_res
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|ai
condition|)
block|{
name|gai_resp
operator|->
name|ai_count
operator|++
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
condition|)
name|canons_octets
operator|+=
name|strlen
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
block|}
comment|/* 		 * If this query succeeded only after retrying, DNS may have 		 * just become responsive.  Ignore previously-scheduled 		 * retry sleeps once for each pending request, similar to 		 * the way scheduled_sleep() does when its worker_sleep() 		 * is interrupted. 		 */
if|if
condition|(
name|gai_resp
operator|->
name|retry
operator|>
name|INITIAL_DNS_RETRY
condition|)
block|{
name|time_now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|worker_ctx
operator|->
name|ignore_scheduled_before
operator|=
name|time_now
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"DNS success after retry, ignoring sleeps scheduled before now (%s)\n"
operator|,
name|humantime
argument_list|(
name|time_now
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Our response consists of a header, followed by ai_count  	 * addrinfo structs followed by ai_count sockaddr_storage  	 * structs followed by the canonical names. 	 */
name|gai_resp
operator|->
name|octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|gai_resp
argument_list|)
operator|+
name|gai_resp
operator|->
name|ai_count
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|gai_req
operator|->
name|hints
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sockaddr_u
argument_list|)
operator|)
operator|+
name|canons_octets
expr_stmt|;
name|resp_octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
operator|+
name|gai_resp
operator|->
name|octets
expr_stmt|;
name|resp
operator|=
name|erealloc
argument_list|(
name|resp
argument_list|,
name|resp_octets
argument_list|)
expr_stmt|;
name|gai_resp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* cp serves as our current pointer while serializing */
name|cp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|gai_resp
operator|+
literal|1
operator|)
expr_stmt|;
name|canons_octets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|gai_resp
operator|->
name|retcode
condition|)
block|{
name|ai
operator|=
name|ai_res
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|ai
condition|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|ai
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
argument_list|)
expr_stmt|;
name|serialized_ai
operator|=
operator|(
name|void
operator|*
operator|)
name|cp
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
expr_stmt|;
comment|/* transform ai_canonname into offset */
if|if
condition|(
name|NULL
operator|!=
name|serialized_ai
operator|->
name|ai_canonname
condition|)
block|{
name|serialized_ai
operator|->
name|ai_canonname
operator|=
operator|(
name|char
operator|*
operator|)
name|canons_octets
expr_stmt|;
name|canons_octets
operator|+=
name|strlen
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* leave fixup of ai_addr pointer for receiver */
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
block|}
name|ai
operator|=
name|ai_res
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|ai
condition|)
block|{
name|NTP_INSIST
argument_list|(
name|ai
operator|->
name|ai_addrlen
operator|<=
sizeof|sizeof
argument_list|(
name|sockaddr_u
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|sockaddr_u
argument_list|)
expr_stmt|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
block|}
name|ai
operator|=
name|ai_res
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|ai
condition|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|ai
operator|->
name|ai_canonname
condition|)
block|{
name|this_octets
operator|=
name|strlen
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|ai
operator|->
name|ai_canonname
argument_list|,
name|this_octets
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|this_octets
expr_stmt|;
block|}
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|ai_res
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * make sure our walk and earlier calc match 	 */
name|DEBUG_INSIST
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|resp
argument_list|)
operator|==
name|resp_octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue_blocking_response
argument_list|(
name|c
argument_list|,
name|resp
argument_list|,
name|resp_octets
argument_list|,
name|req
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"blocking_getaddrinfo can not queue response"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|getaddrinfo_sometime_complete
parameter_list|(
name|blocking_work_req
name|rtype
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|size_t
name|respsize
parameter_list|,
name|void
modifier|*
name|resp
parameter_list|)
block|{
name|blocking_gai_req
modifier|*
name|gai_req
decl_stmt|;
name|blocking_gai_resp
modifier|*
name|gai_resp
decl_stmt|;
name|dnschild_ctx
modifier|*
name|child_ctx
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|next_ai
decl_stmt|;
name|sockaddr_u
modifier|*
name|psau
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|service
decl_stmt|;
name|char
modifier|*
name|canon_start
decl_stmt|;
name|time_t
name|time_now
decl_stmt|;
name|int
name|again
decl_stmt|;
name|int
name|af
decl_stmt|;
specifier|const
name|char
modifier|*
name|fam_spec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gai_req
operator|=
name|context
expr_stmt|;
name|gai_resp
operator|=
name|resp
expr_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|BLOCKING_GETADDRINFO
operator|==
name|rtype
argument_list|)
expr_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|respsize
operator|==
name|gai_resp
operator|->
name|octets
argument_list|)
expr_stmt|;
name|node
operator|=
operator|(
name|char
operator|*
operator|)
name|gai_req
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gai_req
argument_list|)
expr_stmt|;
name|service
operator|=
name|node
operator|+
name|gai_req
operator|->
name|nodesize
expr_stmt|;
name|child_ctx
operator|=
name|dnschild_contexts
index|[
name|gai_req
operator|->
name|dns_idx
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|gai_resp
operator|->
name|retcode
condition|)
block|{
comment|/* 		 * If this query succeeded only after retrying, DNS may have 		 * just become responsive. 		 */
if|if
condition|(
name|gai_resp
operator|->
name|retry
operator|>
name|INITIAL_DNS_RETRY
condition|)
block|{
name|time_now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|child_ctx
operator|->
name|next_dns_timeslot
operator|=
name|time_now
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"DNS success after retry, %u next_dns_timeslot reset (%s)\n"
operator|,
name|gai_req
operator|->
name|dns_idx
operator|,
name|humantime
argument_list|(
name|time_now
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|again
operator|=
name|should_retry_dns
argument_list|(
name|gai_resp
operator|->
name|retcode
argument_list|,
name|gai_resp
operator|->
name|gai_errno
argument_list|)
expr_stmt|;
comment|/* 		 * exponential backoff of DNS retries to 64s 		 */
if|if
condition|(
name|gai_req
operator|->
name|retry
operator|>
literal|0
operator|&&
name|again
condition|)
block|{
comment|/* log the first retry only */
if|if
condition|(
name|INITIAL_DNS_RETRY
operator|==
name|gai_req
operator|->
name|retry
condition|)
name|NLOG
argument_list|(
argument|NLOG_SYSINFO
argument_list|)
block|{
name|af
operator|=
name|gai_req
operator|->
name|hints
operator|.
name|ai_family
expr_stmt|;
name|fam_spec
operator|=
operator|(
name|AF_INET6
operator|==
name|af
operator|)
condition|?
literal|" (AAAA)"
else|:
operator|(
name|AF_INET
operator|==
name|af
operator|)
condition|?
literal|" (A)"
else|:
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|EAI_SYSTEM
if|if
condition|(
name|EAI_SYSTEM
operator|==
name|gai_resp
operator|->
name|retcode
condition|)
block|{
name|errno
operator|=
name|gai_resp
operator|->
name|gai_errno
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"retrying DNS %s%s: EAI_SYSTEM %d: %m"
argument_list|,
name|node
argument_list|,
name|fam_spec
argument_list|,
name|gai_resp
operator|->
name|gai_errno
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"retrying DNS %s%s: %s (%d)"
argument_list|,
name|node
argument_list|,
name|fam_spec
argument_list|,
name|gai_strerror
argument_list|(
name|gai_resp
operator|->
name|retcode
argument_list|)
argument_list|,
name|gai_resp
operator|->
name|retcode
argument_list|)
expr_stmt|;
block|}
name|manage_dns_retry_interval
argument_list|(
operator|&
name|gai_req
operator|->
name|scheduled
argument_list|,
operator|&
name|gai_req
operator|->
name|earliest
argument_list|,
operator|&
name|gai_req
operator|->
name|retry
argument_list|,
operator|&
name|child_ctx
operator|->
name|next_dns_timeslot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|queue_blocking_request
argument_list|(
name|BLOCKING_GETADDRINFO
argument_list|,
name|gai_req
argument_list|,
name|gai_req
operator|->
name|octets
argument_list|,
operator|&
name|getaddrinfo_sometime_complete
argument_list|,
name|gai_req
argument_list|)
condition|)
return|return;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to retry hostname %s"
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * fixup pointers in returned addrinfo array 	 */
name|ai
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|gai_resp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gai_resp
argument_list|)
operator|)
expr_stmt|;
name|next_ai
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|gai_resp
operator|->
name|ai_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ai
index|[
name|i
index|]
operator|.
name|ai_next
operator|=
name|next_ai
expr_stmt|;
name|next_ai
operator|=
operator|&
name|ai
index|[
name|i
index|]
expr_stmt|;
block|}
name|psau
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ai
operator|+
name|gai_resp
operator|->
name|ai_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
operator|)
expr_stmt|;
name|canon_start
operator|=
operator|(
name|char
operator|*
operator|)
name|psau
operator|+
name|gai_resp
operator|->
name|ai_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|psau
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gai_resp
operator|->
name|ai_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|ai
index|[
name|i
index|]
operator|.
name|ai_addr
condition|)
name|ai
index|[
name|i
index|]
operator|.
name|ai_addr
operator|=
operator|&
name|psau
operator|->
name|sa
expr_stmt|;
name|psau
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|ai
index|[
name|i
index|]
operator|.
name|ai_canonname
condition|)
name|ai
index|[
name|i
index|]
operator|.
name|ai_canonname
operator|+=
operator|(
name|size_t
operator|)
name|canon_start
expr_stmt|;
block|}
name|NTP_ENSURE
argument_list|(
operator|(
name|char
operator|*
operator|)
name|psau
operator|==
name|canon_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gai_resp
operator|->
name|ai_count
condition|)
name|ai
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|gai_req
operator|->
name|callback
call|)
argument_list|(
name|gai_resp
operator|->
name|retcode
argument_list|,
name|gai_resp
operator|->
name|gai_errno
argument_list|,
name|gai_req
operator|->
name|context
argument_list|,
name|node
argument_list|,
name|service
argument_list|,
operator|&
name|gai_req
operator|->
name|hints
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gai_req
argument_list|)
expr_stmt|;
comment|/* gai_resp is part of block freed by process_blocking_resp() */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_BLOCKING_WORKER
end_ifdef

begin_function
name|void
name|gai_test_callback
parameter_list|(
name|int
name|rescode
parameter_list|,
name|int
name|gai_errno
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai_res
parameter_list|)
block|{
name|sockaddr_u
name|addr
decl_stmt|;
if|if
condition|(
name|rescode
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"gai_test_callback context %p error rescode %d %s serv %s\n"
operator|,
name|context
operator|,
name|rescode
operator|,
name|name
operator|,
name|service
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|!
name|rescode
operator|&&
name|NULL
operator|!=
name|ai_res
condition|)
block|{
name|ZERO_SOCK
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
name|ai_res
operator|->
name|ai_addr
argument_list|,
name|ai_res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ctx %p fam %d addr %s canon '%s' type %s at %p ai_addr %p ai_next %p\n"
operator|,
name|context
operator|,
name|AF
argument_list|(
operator|&
name|addr
argument_list|)
operator|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
operator|,
operator|(
name|ai_res
operator|->
name|ai_canonname
operator|)
condition|?
name|ai_res
operator|->
name|ai_canonname
else|:
literal|""
operator|,
operator|(
name|SOCK_DGRAM
operator|==
name|ai_res
operator|->
name|ai_socktype
operator|)
condition|?
literal|"DGRAM"
else|:
operator|(
name|SOCK_STREAM
operator|==
name|ai_res
operator|->
name|ai_socktype
operator|)
condition|?
literal|"STREAM"
else|:
literal|"(other)"
operator|,
name|ai_res
operator|,
name|ai_res
operator|->
name|ai_addr
operator|,
name|ai_res
operator|->
name|ai_next
operator|)
argument_list|)
expr_stmt|;
name|getnameinfo_sometime
argument_list|(
operator|(
name|sockaddr_u
operator|*
operator|)
name|ai_res
operator|->
name|ai_addr
argument_list|,
literal|128
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
name|gni_test_callback
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|ai_res
operator|=
name|ai_res
operator|->
name|ai_next
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_BLOCKING_WORKER */
end_comment

begin_function
name|int
name|getnameinfo_sometime
parameter_list|(
name|sockaddr_u
modifier|*
name|psau
parameter_list|,
name|size_t
name|hostoctets
parameter_list|,
name|size_t
name|servoctets
parameter_list|,
name|int
name|flags
parameter_list|,
name|gni_sometime_callback
name|callback
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|blocking_gni_req
modifier|*
name|gni_req
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|dnschild_ctx
modifier|*
name|child_ctx
decl_stmt|;
name|time_t
name|time_now
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|hostoctets
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|hostoctets
operator|+
name|servoctets
operator|<
literal|1024
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_dnschild_ctx
argument_list|()
expr_stmt|;
name|child_ctx
operator|=
name|dnschild_contexts
index|[
name|idx
index|]
expr_stmt|;
name|gni_req
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gni_req
argument_list|)
argument_list|)
expr_stmt|;
name|gni_req
operator|->
name|octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|gni_req
argument_list|)
expr_stmt|;
name|gni_req
operator|->
name|dns_idx
operator|=
name|idx
expr_stmt|;
name|time_now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|gni_req
operator|->
name|scheduled
operator|=
name|time_now
expr_stmt|;
name|gni_req
operator|->
name|earliest
operator|=
name|max
argument_list|(
name|time_now
argument_list|,
name|child_ctx
operator|->
name|next_dns_timeslot
argument_list|)
expr_stmt|;
name|child_ctx
operator|->
name|next_dns_timeslot
operator|=
name|gni_req
operator|->
name|earliest
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|gni_req
operator|->
name|socku
argument_list|,
name|psau
argument_list|,
name|SOCKLEN
argument_list|(
name|psau
argument_list|)
argument_list|)
expr_stmt|;
name|gni_req
operator|->
name|hostoctets
operator|=
name|hostoctets
expr_stmt|;
name|gni_req
operator|->
name|servoctets
operator|=
name|servoctets
expr_stmt|;
name|gni_req
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|gni_req
operator|->
name|retry
operator|=
name|INITIAL_DNS_RETRY
expr_stmt|;
name|gni_req
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|gni_req
operator|->
name|context
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|queue_blocking_request
argument_list|(
name|BLOCKING_GETNAMEINFO
argument_list|,
name|gni_req
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gni_req
argument_list|)
argument_list|,
operator|&
name|getnameinfo_sometime_complete
argument_list|,
name|gni_req
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to queue getnameinfo request"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|blocking_getnameinfo
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|blocking_pipe_header
modifier|*
name|req
parameter_list|)
block|{
name|blocking_gni_req
modifier|*
name|gni_req
decl_stmt|;
name|dnsworker_ctx
modifier|*
name|worker_ctx
decl_stmt|;
name|blocking_pipe_header
modifier|*
name|resp
decl_stmt|;
name|blocking_gni_resp
modifier|*
name|gni_resp
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|size_t
name|resp_octets
decl_stmt|;
name|char
modifier|*
name|service
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|time_t
name|time_now
decl_stmt|;
name|char
name|host
index|[
literal|1024
index|]
decl_stmt|;
name|gni_req
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|req
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|)
expr_stmt|;
name|octets
operator|=
name|gni_req
operator|->
name|hostoctets
operator|+
name|gni_req
operator|->
name|servoctets
expr_stmt|;
comment|/* 	 * Some alloca() implementations are fragile regarding 	 * large allocations.  We only need room for the host 	 * and service names. 	 */
name|NTP_REQUIRE
argument_list|(
name|octets
operator|<
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
name|service
operator|=
name|host
operator|+
name|gni_req
operator|->
name|hostoctets
expr_stmt|;
name|worker_ctx
operator|=
name|get_worker_context
argument_list|(
name|c
argument_list|,
name|gni_req
operator|->
name|dns_idx
argument_list|)
expr_stmt|;
name|scheduled_sleep
argument_list|(
name|gni_req
operator|->
name|scheduled
argument_list|,
name|gni_req
operator|->
name|earliest
argument_list|,
name|worker_ctx
argument_list|)
expr_stmt|;
name|reload_resolv_conf
argument_list|(
name|worker_ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Take a shot at the final size, better to overestimate 	 * then realloc to a smaller size. 	 */
name|resp_octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gni_resp
argument_list|)
operator|+
name|octets
expr_stmt|;
name|resp
operator|=
name|emalloc_zero
argument_list|(
name|resp_octets
argument_list|)
expr_stmt|;
name|gni_resp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|resp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
operator|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"blocking_getnameinfo given addr %s flags 0x%x hostlen %lu servlen %lu\n"
operator|,
name|stoa
argument_list|(
operator|&
name|gni_req
operator|->
name|socku
argument_list|)
operator|,
name|gni_req
operator|->
name|flags
operator|,
operator|(
name|u_long
operator|)
name|gni_req
operator|->
name|hostoctets
operator|,
operator|(
name|u_long
operator|)
name|gni_req
operator|->
name|servoctets
operator|)
argument_list|)
expr_stmt|;
name|gni_resp
operator|->
name|retcode
operator|=
name|getnameinfo
argument_list|(
operator|&
name|gni_req
operator|->
name|socku
operator|.
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
operator|&
name|gni_req
operator|->
name|socku
argument_list|)
argument_list|,
name|host
argument_list|,
name|gni_req
operator|->
name|hostoctets
argument_list|,
name|service
argument_list|,
name|gni_req
operator|->
name|servoctets
argument_list|,
name|gni_req
operator|->
name|flags
argument_list|)
expr_stmt|;
name|gni_resp
operator|->
name|retry
operator|=
name|gni_req
operator|->
name|retry
expr_stmt|;
ifdef|#
directive|ifdef
name|EAI_SYSTEM
if|if
condition|(
name|EAI_SYSTEM
operator|==
name|gni_resp
operator|->
name|retcode
condition|)
name|gni_resp
operator|->
name|gni_errno
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
literal|0
operator|!=
name|gni_resp
operator|->
name|retcode
condition|)
block|{
name|gni_resp
operator|->
name|hostoctets
operator|=
literal|0
expr_stmt|;
name|gni_resp
operator|->
name|servoctets
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|gni_resp
operator|->
name|hostoctets
operator|=
name|strlen
argument_list|(
name|host
argument_list|)
operator|+
literal|1
expr_stmt|;
name|gni_resp
operator|->
name|servoctets
operator|=
name|strlen
argument_list|(
name|service
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 		 * If this query succeeded only after retrying, DNS may have 		 * just become responsive.  Ignore previously-scheduled 		 * retry sleeps once for each pending request, similar to 		 * the way scheduled_sleep() does when its worker_sleep() 		 * is interrupted. 		 */
if|if
condition|(
name|gni_req
operator|->
name|retry
operator|>
name|INITIAL_DNS_RETRY
condition|)
block|{
name|time_now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|worker_ctx
operator|->
name|ignore_scheduled_before
operator|=
name|time_now
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"DNS success after retrying, ignoring sleeps scheduled before now (%s)\n"
operator|,
name|humantime
argument_list|(
name|time_now
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|octets
operator|=
name|gni_resp
operator|->
name|hostoctets
operator|+
name|gni_resp
operator|->
name|servoctets
expr_stmt|;
comment|/* 	 * Our response consists of a header, followed by the host and 	 * service strings, each null-terminated. 	 */
name|resp_octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gni_resp
argument_list|)
operator|+
name|octets
expr_stmt|;
name|resp
operator|=
name|erealloc
argument_list|(
name|resp
argument_list|,
name|resp_octets
argument_list|)
expr_stmt|;
name|gni_resp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
name|gni_resp
operator|->
name|octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|gni_resp
argument_list|)
operator|+
name|octets
expr_stmt|;
comment|/* cp serves as our current pointer while serializing */
name|cp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|gni_resp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|gni_resp
operator|->
name|retcode
condition|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|host
argument_list|,
name|gni_resp
operator|->
name|hostoctets
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|gni_resp
operator|->
name|hostoctets
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|service
argument_list|,
name|gni_resp
operator|->
name|servoctets
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|gni_resp
operator|->
name|servoctets
expr_stmt|;
block|}
name|NTP_INSIST
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|resp
argument_list|)
operator|==
name|resp_octets
argument_list|)
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|resp_octets
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
operator|==
name|gni_resp
operator|->
name|octets
argument_list|)
expr_stmt|;
name|rc
operator|=
name|queue_blocking_response
argument_list|(
name|c
argument_list|,
name|resp
argument_list|,
name|resp_octets
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"blocking_getnameinfo unable to queue response"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|getnameinfo_sometime_complete
parameter_list|(
name|blocking_work_req
name|rtype
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|size_t
name|respsize
parameter_list|,
name|void
modifier|*
name|resp
parameter_list|)
block|{
name|blocking_gni_req
modifier|*
name|gni_req
decl_stmt|;
name|blocking_gni_resp
modifier|*
name|gni_resp
decl_stmt|;
name|dnschild_ctx
modifier|*
name|child_ctx
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|service
decl_stmt|;
name|time_t
name|time_now
decl_stmt|;
name|int
name|again
decl_stmt|;
name|gni_req
operator|=
name|context
expr_stmt|;
name|gni_resp
operator|=
name|resp
expr_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|BLOCKING_GETNAMEINFO
operator|==
name|rtype
argument_list|)
expr_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|respsize
operator|==
name|gni_resp
operator|->
name|octets
argument_list|)
expr_stmt|;
name|child_ctx
operator|=
name|dnschild_contexts
index|[
name|gni_req
operator|->
name|dns_idx
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|gni_resp
operator|->
name|retcode
condition|)
block|{
comment|/* 		 * If this query succeeded only after retrying, DNS may have 		 * just become responsive. 		 */
if|if
condition|(
name|gni_resp
operator|->
name|retry
operator|>
name|INITIAL_DNS_RETRY
condition|)
block|{
name|time_now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|child_ctx
operator|->
name|next_dns_timeslot
operator|=
name|time_now
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"DNS success after retry, %u next_dns_timeslot reset (%s)\n"
operator|,
name|gni_req
operator|->
name|dns_idx
operator|,
name|humantime
argument_list|(
name|time_now
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|again
operator|=
name|should_retry_dns
argument_list|(
name|gni_resp
operator|->
name|retcode
argument_list|,
name|gni_resp
operator|->
name|gni_errno
argument_list|)
expr_stmt|;
comment|/* 		 * exponential backoff of DNS retries to 64s 		 */
if|if
condition|(
name|gni_req
operator|->
name|retry
operator|>
literal|0
condition|)
name|manage_dns_retry_interval
argument_list|(
operator|&
name|gni_req
operator|->
name|scheduled
argument_list|,
operator|&
name|gni_req
operator|->
name|earliest
argument_list|,
operator|&
name|gni_req
operator|->
name|retry
argument_list|,
operator|&
name|child_ctx
operator|->
name|next_dns_timeslot
argument_list|)
expr_stmt|;
if|if
condition|(
name|gni_req
operator|->
name|retry
operator|>
literal|0
operator|&&
name|again
condition|)
block|{
if|if
condition|(
operator|!
name|queue_blocking_request
argument_list|(
name|BLOCKING_GETNAMEINFO
argument_list|,
name|gni_req
argument_list|,
name|gni_req
operator|->
name|octets
argument_list|,
operator|&
name|getnameinfo_sometime_complete
argument_list|,
name|gni_req
argument_list|)
condition|)
return|return;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to retry reverse lookup of %s"
argument_list|,
name|stoa
argument_list|(
operator|&
name|gni_req
operator|->
name|socku
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|gni_resp
operator|->
name|hostoctets
condition|)
block|{
name|host
operator|=
name|NULL
expr_stmt|;
name|service
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
operator|(
name|char
operator|*
operator|)
name|gni_resp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gni_resp
argument_list|)
expr_stmt|;
name|service
operator|=
operator|(
name|gni_resp
operator|->
name|servoctets
operator|)
condition|?
name|host
operator|+
name|gni_resp
operator|->
name|hostoctets
else|:
name|NULL
expr_stmt|;
block|}
call|(
modifier|*
name|gni_req
operator|->
name|callback
call|)
argument_list|(
name|gni_resp
operator|->
name|retcode
argument_list|,
name|gni_resp
operator|->
name|gni_errno
argument_list|,
operator|&
name|gni_req
operator|->
name|socku
argument_list|,
name|gni_req
operator|->
name|flags
argument_list|,
name|host
argument_list|,
name|service
argument_list|,
name|gni_req
operator|->
name|context
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gni_req
argument_list|)
expr_stmt|;
comment|/* gni_resp is part of block freed by process_blocking_resp() */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_BLOCKING_WORKER
end_ifdef

begin_function
name|void
name|gni_test_callback
parameter_list|(
name|int
name|rescode
parameter_list|,
name|int
name|gni_errno
parameter_list|,
name|sockaddr_u
modifier|*
name|psau
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|host
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rescode
condition|)
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"gni_test_callback got host '%s' serv '%s' for addr %s context %p\n"
operator|,
name|host
operator|,
name|service
operator|,
name|stoa
argument_list|(
name|psau
argument_list|)
operator|,
name|context
operator|)
argument_list|)
expr_stmt|;
else|else
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"gni_test_callback context %p rescode %d gni_errno %d flags 0x%x addr %s\n"
operator|,
name|context
operator|,
name|rescode
operator|,
name|gni_errno
operator|,
name|flags
operator|,
name|stoa
argument_list|(
name|psau
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_BLOCKING_WORKER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_RES_INIT
end_ifdef

begin_function
specifier|static
name|void
name|reload_resolv_conf
parameter_list|(
name|dnsworker_ctx
modifier|*
name|worker_ctx
parameter_list|)
block|{
name|time_t
name|time_now
decl_stmt|;
comment|/* 	 * This is ad-hoc.  Reload /etc/resolv.conf once per minute 	 * to pick up on changes from the DHCP client.  [Bug 1226] 	 * When using threads for the workers, this needs to happen 	 * only once per minute process-wide. 	 */
name|time_now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WORK_THREAD
name|worker_ctx
operator|->
name|next_res_init
operator|=
name|next_res_init
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|worker_ctx
operator|->
name|next_res_init
operator|<=
name|time_now
condition|)
block|{
if|if
condition|(
name|worker_ctx
operator|->
name|next_res_init
operator|!=
literal|0
condition|)
name|res_init
argument_list|()
expr_stmt|;
name|worker_ctx
operator|->
name|next_res_init
operator|=
name|time_now
operator|+
literal|60
expr_stmt|;
ifdef|#
directive|ifdef
name|WORK_THREAD
name|next_res_init
operator|=
name|worker_ctx
operator|->
name|next_res_init
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_RES_INIT */
end_comment

begin_function
specifier|static
name|u_int
name|reserve_dnschild_ctx
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|size_t
name|ps
init|=
sizeof|sizeof
argument_list|(
name|dnschild_contexts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|cs
init|=
sizeof|sizeof
argument_list|(
operator|*
name|dnschild_contexts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|u_int
name|c
decl_stmt|;
name|u_int
name|new_alloc
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|size_t
name|new_octets
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
for|for
control|(
init|;
name|c
operator|<
name|dnschild_contexts_alloc
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|==
name|dnschild_contexts
index|[
name|c
index|]
condition|)
block|{
name|dnschild_contexts
index|[
name|c
index|]
operator|=
name|emalloc_zero
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
block|}
name|new_alloc
operator|=
name|dnschild_contexts_alloc
operator|+
literal|20
expr_stmt|;
name|new_octets
operator|=
name|new_alloc
operator|*
name|ps
expr_stmt|;
name|octets
operator|=
name|dnschild_contexts_alloc
operator|*
name|ps
expr_stmt|;
name|dnschild_contexts
operator|=
name|erealloc_zero
argument_list|(
name|dnschild_contexts
argument_list|,
name|new_octets
argument_list|,
name|octets
argument_list|)
expr_stmt|;
name|dnschild_contexts_alloc
operator|=
name|new_alloc
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|get_dnschild_ctx
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|u_int
name|shared_ctx
init|=
name|UINT_MAX
decl_stmt|;
if|if
condition|(
name|worker_per_query
condition|)
return|return
name|reserve_dnschild_ctx
argument_list|()
return|;
if|if
condition|(
name|UINT_MAX
operator|==
name|shared_ctx
condition|)
name|shared_ctx
operator|=
name|reserve_dnschild_ctx
argument_list|()
expr_stmt|;
return|return
name|shared_ctx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_dnsworker_context
parameter_list|(
name|u_int
name|idx
parameter_list|)
block|{
specifier|const
name|size_t
name|worker_context_sz
init|=
sizeof|sizeof
argument_list|(
operator|*
name|dnsworker_contexts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|REQUIRE
argument_list|(
name|NULL
operator|==
name|dnsworker_contexts
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|dnsworker_contexts
index|[
name|idx
index|]
operator|=
name|emalloc_zero
argument_list|(
name|worker_context_sz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dnsworker_ctx
modifier|*
name|get_worker_context
parameter_list|(
name|blocking_child
modifier|*
name|c
parameter_list|,
name|u_int
name|idx
parameter_list|)
block|{
specifier|static
name|size_t
name|ps
init|=
sizeof|sizeof
argument_list|(
name|dnsworker_contexts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|u_int
name|min_new_alloc
decl_stmt|;
name|u_int
name|new_alloc
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|size_t
name|new_octets
decl_stmt|;
if|if
condition|(
name|dnsworker_contexts_alloc
operator|<=
name|idx
condition|)
block|{
name|min_new_alloc
operator|=
literal|1
operator|+
name|idx
expr_stmt|;
comment|/* round new_alloc up to nearest multiple of 4 */
name|new_alloc
operator|=
operator|(
name|min_new_alloc
operator|+
literal|4
operator|)
operator|&
operator|~
operator|(
literal|4
operator|-
literal|1
operator|)
expr_stmt|;
name|new_octets
operator|=
name|new_alloc
operator|*
name|ps
expr_stmt|;
name|octets
operator|=
name|dnsworker_contexts_alloc
operator|*
name|ps
expr_stmt|;
name|dnsworker_contexts
operator|=
name|erealloc_zero
argument_list|(
name|dnsworker_contexts
argument_list|,
name|new_octets
argument_list|,
name|octets
argument_list|)
expr_stmt|;
name|dnsworker_contexts_alloc
operator|=
name|new_alloc
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|dnsworker_contexts
index|[
name|idx
index|]
condition|)
name|alloc_dnsworker_context
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
operator|*
name|dnsworker_contexts
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|dnsworker_contexts
index|[
name|idx
index|]
operator|->
name|c
operator|=
name|c
expr_stmt|;
return|return
name|dnsworker_contexts
index|[
name|idx
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scheduled_sleep
parameter_list|(
name|time_t
name|scheduled
parameter_list|,
name|time_t
name|earliest
parameter_list|,
name|dnsworker_ctx
modifier|*
name|worker_ctx
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
if|if
condition|(
name|scheduled
operator|<
name|worker_ctx
operator|->
name|ignore_scheduled_before
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ignoring sleep until %s scheduled at %s (before %s)\n"
operator|,
name|humantime
argument_list|(
name|earliest
argument_list|)
operator|,
name|humantime
argument_list|(
name|scheduled
argument_list|)
operator|,
name|humantime
argument_list|(
name|worker_ctx
operator|->
name|ignore_scheduled_before
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|<
name|earliest
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"sleep until %s scheduled at %s (>= %s)\n"
operator|,
name|humantime
argument_list|(
name|earliest
argument_list|)
operator|,
name|humantime
argument_list|(
name|scheduled
argument_list|)
operator|,
name|humantime
argument_list|(
name|worker_ctx
operator|->
name|ignore_scheduled_before
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|worker_sleep
argument_list|(
name|worker_ctx
operator|->
name|c
argument_list|,
name|earliest
operator|-
name|now
argument_list|)
condition|)
block|{
comment|/* our sleep was interrupted */
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|worker_ctx
operator|->
name|ignore_scheduled_before
operator|=
name|now
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RES_INIT
name|worker_ctx
operator|->
name|next_res_init
operator|=
name|now
operator|+
literal|60
expr_stmt|;
name|next_res_init
operator|=
name|worker_ctx
operator|->
name|next_res_init
expr_stmt|;
name|res_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"sleep interrupted by daemon, ignoring sleeps scheduled before now (%s)\n"
operator|,
name|humantime
argument_list|(
name|worker_ctx
operator|->
name|ignore_scheduled_before
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * manage_dns_retry_interval is a helper used by  * getaddrinfo_sometime_complete and getnameinfo_sometime_complete  * to calculate the new retry interval and schedule the next query.  */
end_comment

begin_function
specifier|static
name|void
name|manage_dns_retry_interval
parameter_list|(
name|time_t
modifier|*
name|pscheduled
parameter_list|,
name|time_t
modifier|*
name|pwhen
parameter_list|,
name|int
modifier|*
name|pretry
parameter_list|,
name|time_t
modifier|*
name|pnext_timeslot
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
name|time_t
name|when
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|retry
operator|=
operator|*
name|pretry
expr_stmt|;
name|when
operator|=
name|max
argument_list|(
name|now
operator|+
name|retry
argument_list|,
operator|*
name|pnext_timeslot
argument_list|)
expr_stmt|;
operator|*
name|pnext_timeslot
operator|=
name|when
expr_stmt|;
name|retry
operator|=
name|min
argument_list|(
literal|64
argument_list|,
name|retry
operator|<<
literal|1
argument_list|)
expr_stmt|;
operator|*
name|pscheduled
operator|=
name|now
expr_stmt|;
operator|*
name|pwhen
operator|=
name|when
expr_stmt|;
operator|*
name|pretry
operator|=
name|retry
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * should_retry_dns is a helper used by getaddrinfo_sometime_complete  * and getnameinfo_sometime_complete which implements ntpd's DNS retry  * policy.  */
end_comment

begin_function
specifier|static
name|int
name|should_retry_dns
parameter_list|(
name|int
name|rescode
parameter_list|,
name|int
name|res_errno
parameter_list|)
block|{
specifier|static
name|int
name|eai_again_seen
decl_stmt|;
name|int
name|again
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EAI_SYSTEM
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|char
name|msg
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * If the resolver failed, see if the failure is 	 * temporary. If so, return success. 	 */
name|again
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|rescode
condition|)
block|{
case|case
name|EAI_FAIL
case|:
name|again
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EAI_AGAIN
case|:
name|again
operator|=
literal|1
expr_stmt|;
name|eai_again_seen
operator|=
literal|1
expr_stmt|;
comment|/* [Bug 1178] */
break|break;
case|case
name|EAI_NONAME
case|:
if|#
directive|if
name|defined
argument_list|(
name|EAI_NODATA
argument_list|)
operator|&&
operator|(
name|EAI_NODATA
operator|!=
name|EAI_NONAME
operator|)
case|case
name|EAI_NODATA
case|:
endif|#
directive|endif
name|again
operator|=
operator|!
name|eai_again_seen
expr_stmt|;
comment|/* [Bug 1178] */
break|break;
ifdef|#
directive|ifdef
name|EAI_SYSTEM
case|case
name|EAI_SYSTEM
case|:
comment|/*  		 * EAI_SYSTEM means the real error is in errno.  We should be more 		 * discriminating about which errno values require retrying, but 		 * this matches existing behavior. 		 */
name|again
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|errno_to_str
argument_list|(
name|res_errno
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"intres: EAI_SYSTEM errno %d (%s) means try again, right?\n"
operator|,
name|res_errno
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
block|}
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"intres: resolver returned: %s (%d), %sretrying\n"
operator|,
name|gai_strerror
argument_list|(
name|rescode
argument_list|)
operator|,
name|rescode
operator|,
name|again
condition|?
literal|""
else|:
literal|"not "
operator|)
argument_list|)
expr_stmt|;
return|return
name|again
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !WORKER follows */
end_comment

begin_decl_stmt
name|int
name|ntp_intres_nonempty_compilation_unit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

