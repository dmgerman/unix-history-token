begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * authkeys.c - routines to manage the storage of authentication keys  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_malloc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Structure to store keys in in the hash table.  */
end_comment

begin_struct
struct|struct
name|savekey
block|{
name|struct
name|savekey
modifier|*
name|next
decl_stmt|;
union|union
block|{
name|u_char
name|MD5_key
index|[
literal|64
index|]
decl_stmt|;
comment|/* for keys up to to 512 bits */
block|}
name|k
union|;
name|keyid_t
name|keyid
decl_stmt|;
comment|/* key identifier */
name|int
name|type
decl_stmt|;
comment|/* key type */
name|u_short
name|flags
decl_stmt|;
comment|/* flags that wave */
name|u_long
name|lifetime
decl_stmt|;
comment|/* remaining lifetime */
name|int
name|keylen
decl_stmt|;
comment|/* key length */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KEY_TRUSTED
value|0x001
end_define

begin_comment
comment|/* this key is trusted */
end_comment

begin_comment
comment|/*  * The hash table. This is indexed by the low order bits of the  * keyid. We make this fairly big for potentially busy servers.  */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|64
end_define

begin_define
define|#
directive|define
name|HASHMASK
value|((HASHSIZE)-1)
end_define

begin_define
define|#
directive|define
name|KEYHASH
parameter_list|(
name|keyid
parameter_list|)
value|((keyid)& HASHMASK)
end_define

begin_decl_stmt
name|struct
name|savekey
modifier|*
name|key_hash
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|authkeynotfound
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys not found */
end_comment

begin_decl_stmt
name|u_long
name|authkeylookups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to lookup keys */
end_comment

begin_decl_stmt
name|u_long
name|authnumkeys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of active keys */
end_comment

begin_decl_stmt
name|u_long
name|authkeyexpired
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key lifetime expirations */
end_comment

begin_decl_stmt
name|u_long
name|authkeyuncached
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache misses */
end_comment

begin_decl_stmt
name|u_long
name|authnokey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to encrypt with no key */
end_comment

begin_decl_stmt
name|u_long
name|authencryptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to encrypt */
end_comment

begin_decl_stmt
name|u_long
name|authdecryptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to decrypt */
end_comment

begin_comment
comment|/*  * Storage for free key structures.  We malloc() such things but  * never free them.  */
end_comment

begin_decl_stmt
name|struct
name|savekey
modifier|*
name|authfreekeys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|authnumfreekeys
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MEMINC
value|12
end_define

begin_comment
comment|/* number of new free ones to get */
end_comment

begin_comment
comment|/*  * The key cache. We cache the last key we looked at here.  */
end_comment

begin_decl_stmt
name|keyid_t
name|cache_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key identifier */
end_comment

begin_decl_stmt
name|u_char
modifier|*
name|cache_key
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key pointer */
end_comment

begin_decl_stmt
name|u_int
name|cache_keylen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key length */
end_comment

begin_decl_stmt
name|int
name|cache_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key type */
end_comment

begin_decl_stmt
name|u_short
name|cache_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags that wave */
end_comment

begin_comment
comment|/*  * init_auth - initialize internal data  */
end_comment

begin_function
name|void
name|init_auth
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize hash table and free list 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key_hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|key_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * auth_findkey - find a key in the hash table  */
end_comment

begin_function
name|struct
name|savekey
modifier|*
name|auth_findkey
parameter_list|(
name|keyid_t
name|keyno
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
return|return
operator|(
name|sk
operator|)
return|;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * auth_havekey - return one if the key is known  */
end_comment

begin_function
name|int
name|auth_havekey
parameter_list|(
name|keyid_t
name|keyno
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
operator|||
operator|(
name|keyno
operator|==
name|cache_keyid
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * authhavekey - return one and cache the key, if known and trusted.  */
end_comment

begin_function
name|int
name|authhavekey
parameter_list|(
name|keyid_t
name|keyno
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|authkeylookups
operator|++
expr_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
operator|||
name|keyno
operator|==
name|cache_keyid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Seach the bin for the key. If found and the key type 	 * is zero, somebody marked it trusted without specifying 	 * a key or key type. In this case consider the key missing. 	 */
name|authkeyuncached
operator|++
expr_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
if|if
condition|(
name|sk
operator|->
name|type
operator|==
literal|0
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
block|}
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * If the key is not found, or if it is found but not trusted, 	 * the key is not considered found. 	 */
if|if
condition|(
name|sk
operator|==
name|NULL
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|sk
operator|->
name|flags
operator|&
name|KEY_TRUSTED
operator|)
condition|)
block|{
name|authnokey
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * The key is found and trusted. Initialize the key cache. 	 */
name|cache_keyid
operator|=
name|sk
operator|->
name|keyid
expr_stmt|;
name|cache_type
operator|=
name|sk
operator|->
name|type
expr_stmt|;
name|cache_flags
operator|=
name|sk
operator|->
name|flags
expr_stmt|;
name|cache_key
operator|=
name|sk
operator|->
name|k
operator|.
name|MD5_key
expr_stmt|;
name|cache_keylen
operator|=
name|sk
operator|->
name|keylen
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * auth_moremem - get some more free key structures  */
end_comment

begin_function
name|int
name|auth_moremem
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sk
operator|=
operator|(
expr|struct
name|savekey
operator|*
operator|)
name|calloc
argument_list|(
name|MEMINC
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|savekey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
name|MEMINC
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sk
operator|->
name|next
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|++
expr_stmt|;
block|}
name|authnumfreekeys
operator|+=
name|MEMINC
expr_stmt|;
return|return
operator|(
name|authnumfreekeys
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * authtrust - declare a key to be trusted/untrusted  */
end_comment

begin_function
name|void
name|authtrust
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|u_long
name|trust
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
comment|/* 	 * Search bin for key; if it does not exist and is untrusted, 	 * forget it. 	 */
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sk
operator|==
literal|0
operator|&&
operator|!
name|trust
condition|)
return|return;
comment|/* 	 * There are two conditions remaining. Either it does not 	 * exist and is to be trusted or it does exist and is or is 	 * not to be trusted. 	 */
if|if
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cache_keyid
operator|==
name|keyno
condition|)
block|{
name|cache_flags
operator|=
literal|0
expr_stmt|;
name|cache_keyid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Key exists. If it is to be trusted, say so and 		 * update its lifetime. If not, return it to the 		 * free list. 		 */
if|if
condition|(
name|trust
operator|>
literal|0
condition|)
block|{
name|sk
operator|->
name|flags
operator||=
name|KEY_TRUSTED
expr_stmt|;
if|if
condition|(
name|trust
operator|>
literal|1
condition|)
name|sk
operator|->
name|lifetime
operator|=
name|current_time
operator|+
name|trust
expr_stmt|;
else|else
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sk
operator|->
name|flags
operator|&=
operator|~
name|KEY_TRUSTED
expr_stmt|;
block|{
name|struct
name|savekey
modifier|*
name|skp
decl_stmt|;
name|skp
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|skp
operator|==
name|sk
condition|)
block|{
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|skp
operator|->
name|next
operator|!=
name|sk
condition|)
name|skp
operator|=
name|skp
operator|->
name|next
expr_stmt|;
name|skp
operator|->
name|next
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
name|authnumkeys
operator|--
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
expr_stmt|;
name|authnumfreekeys
operator|++
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Here there is not key, but the key is to be trusted. There 	 * seems to be a disconnect here. Here we allocate a new key, 	 * but do not specify a key type, key or key length. 	 */
if|if
condition|(
name|authnumfreekeys
operator|==
literal|0
condition|)
if|if
condition|(
name|auth_moremem
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|sk
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|keyno
expr_stmt|;
name|sk
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|keylen
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
name|KEY_TRUSTED
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
expr_stmt|;
name|authnumkeys
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * authistrusted - determine whether a key is trusted  */
end_comment

begin_function
name|int
name|authistrusted
parameter_list|(
name|keyid_t
name|keyno
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
name|keyno
operator|==
name|cache_keyid
condition|)
return|return
operator|(
operator|(
name|cache_flags
operator|&
name|KEY_TRUSTED
operator|)
operator|!=
literal|0
operator|)
return|;
name|authkeyuncached
operator|++
expr_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sk
operator|==
literal|0
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|sk
operator|->
name|flags
operator|&
name|KEY_TRUSTED
operator|)
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|MD5auth_setkey
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|int
name|keytype
parameter_list|,
specifier|const
name|u_char
modifier|*
name|key
parameter_list|,
specifier|const
name|int
name|len
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
comment|/* 	 * See if we already have the key.  If so just stick in the 	 * new value. 	 */
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
name|sk
operator|->
name|type
operator|=
name|keytype
expr_stmt|;
name|sk
operator|->
name|keylen
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DISABLE_BUG1243_FIX
name|memcpy
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|,
name|key
argument_list|,
name|sk
operator|->
name|keylen
argument_list|)
expr_stmt|;
else|#
directive|else
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cache_keyid
operator|==
name|keyno
condition|)
block|{
name|cache_flags
operator|=
literal|0
expr_stmt|;
name|cache_keyid
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Need to allocate new structure.  Do it. 	 */
if|if
condition|(
literal|0
operator|==
name|authnumfreekeys
operator|&&
operator|!
name|auth_moremem
argument_list|()
condition|)
return|return;
name|sk
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|keyno
expr_stmt|;
name|sk
operator|->
name|type
operator|=
name|keytype
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|keylen
operator|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DISABLE_BUG1243_FIX
name|memcpy
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|,
name|key
argument_list|,
name|sk
operator|->
name|keylen
argument_list|)
expr_stmt|;
else|#
directive|else
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sk
operator|->
name|next
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|int
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"auth_setkey: key %d type %d len %d "
argument_list|,
name|sk
operator|->
name|keyid
argument_list|,
name|sk
operator|->
name|type
argument_list|,
name|sk
operator|->
name|keylen
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sk
operator|->
name|keylen
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|"%c%c"
argument_list|,
name|hex
index|[
name|key
index|[
name|j
index|]
operator|>>
literal|4
index|]
argument_list|,
name|hex
index|[
name|key
index|[
name|j
index|]
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|authnumkeys
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * auth_delkeys - delete all known keys, in preparation for rereading  *		  the keys file (presumably)  */
end_comment

begin_function
name|void
name|auth_delkeys
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|struct
name|savekey
modifier|*
modifier|*
name|skp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|skp
operator|=
operator|&
operator|(
name|key_hash
index|[
name|i
index|]
operator|)
expr_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Leave autokey keys alone. 		 */
while|while
condition|(
name|sk
operator|!=
literal|0
operator|&&
name|sk
operator|->
name|keyid
operator|<=
name|NTP_MAXKEY
condition|)
block|{
comment|/* 			 * Don't lose info as to which keys are trusted. 			 */
if|if
condition|(
name|sk
operator|->
name|flags
operator|&
name|KEY_TRUSTED
condition|)
block|{
name|skp
operator|=
operator|&
operator|(
name|sk
operator|->
name|next
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sk
operator|->
name|k
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|keylen
operator|=
literal|0
expr_stmt|;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|skp
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumkeys
operator|--
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
expr_stmt|;
name|authnumfreekeys
operator|++
expr_stmt|;
name|sk
operator|=
operator|*
name|skp
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * auth_agekeys - delete keys whose lifetimes have expired  */
end_comment

begin_function
name|void
name|auth_agekeys
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|struct
name|savekey
modifier|*
name|skp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|sk
operator|=
name|skp
operator|=
name|key_hash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
name|skp
operator|=
name|sk
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sk
operator|->
name|lifetime
operator|>
literal|0
operator|&&
name|current_time
operator|>
name|sk
operator|->
name|lifetime
condition|)
block|{
name|authtrust
argument_list|(
name|sk
operator|->
name|keyid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|authkeyexpired
operator|++
expr_stmt|;
block|}
name|sk
operator|=
name|skp
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"auth_agekeys: at %lu keys %lu expired %lu\n"
argument_list|,
name|current_time
argument_list|,
name|authnumkeys
argument_list|,
name|authkeyexpired
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * authencrypt - generate message authenticator  *  * Returns length of authenticator field, zero if key not found.  */
end_comment

begin_function
name|int
name|authencrypt
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|u_int32
modifier|*
name|pkt
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|/* 	 * A zero key identifier means the sender has not verified 	 * the last message was correctly authenticated. The MAC 	 * consists of a single word with value zero. 	 */
name|authencryptions
operator|++
expr_stmt|;
name|pkt
index|[
name|length
operator|/
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|4
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|MD5authencrypt
argument_list|(
name|cache_type
argument_list|,
name|cache_key
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * authdecrypt - verify message authenticator  *  * Returns one if authenticator valid, zero if invalid or key not found.  */
end_comment

begin_function
name|int
name|authdecrypt
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|u_int32
modifier|*
name|pkt
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* 	 * A zero key identifier means the sender has not verified 	 * the last message was correctly authenticated. Nevertheless, 	 * the authenticator itself is considered valid. 	 */
name|authdecryptions
operator|++
expr_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
operator|||
name|size
operator|<
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|MD5authdecrypt
argument_list|(
name|cache_type
argument_list|,
name|cache_key
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

