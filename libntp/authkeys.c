begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * authkeys.c - routines to manage the storage of authentication keys  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lists.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_malloc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Structure to store keys in in the hash table.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|savekey
name|symkey
typedef|;
end_typedef

begin_struct
struct|struct
name|savekey
block|{
name|symkey
modifier|*
name|hlink
decl_stmt|;
comment|/* next in hash bucket */
name|DECL_DLIST_LINK
argument_list|(
name|symkey
argument_list|,
name|llink
argument_list|)
expr_stmt|;
comment|/* for overall& free lists */
name|u_char
modifier|*
name|secret
decl_stmt|;
comment|/* shared secret */
name|u_long
name|lifetime
decl_stmt|;
comment|/* remaining lifetime */
name|keyid_t
name|keyid
decl_stmt|;
comment|/* key identifier */
name|u_short
name|type
decl_stmt|;
comment|/* OpenSSL digest NID */
name|u_short
name|secretsize
decl_stmt|;
comment|/* secret octets */
name|u_short
name|flags
decl_stmt|;
comment|/* KEY_ flags that wave */
block|}
struct|;
end_struct

begin_comment
comment|/* define the payload region of symkey beyond the list pointers */
end_comment

begin_define
define|#
directive|define
name|symkey_payload
value|secret
end_define

begin_define
define|#
directive|define
name|KEY_TRUSTED
value|0x001
end_define

begin_comment
comment|/* this key is trusted */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|symkey_alloc_tag
name|symkey_alloc
typedef|;
end_typedef

begin_struct
struct|struct
name|symkey_alloc_tag
block|{
name|symkey_alloc
modifier|*
name|link
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
comment|/* enable free() atexit */
block|}
struct|;
end_struct

begin_decl_stmt
name|symkey_alloc
modifier|*
name|authallocs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function_decl
specifier|static
specifier|inline
name|u_short
name|auth_log2
parameter_list|(
name|double
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|auth_resize_hashtable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocsymkey
parameter_list|(
name|symkey
modifier|*
modifier|*
parameter_list|,
name|keyid_t
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|u_long
parameter_list|,
name|u_short
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freesymkey
parameter_list|(
name|symkey
modifier|*
parameter_list|,
name|symkey
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_auth_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|symkey
name|key_listhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all in-use keys */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * The hash table. This is indexed by the low order bits of the  * keyid. We make this fairly big for potentially busy servers.  */
end_comment

begin_define
define|#
directive|define
name|DEF_AUTHHASHSIZE
value|64
end_define

begin_comment
comment|//#define	HASHMASK	((HASHSIZE)-1)
end_comment

begin_define
define|#
directive|define
name|KEYHASH
parameter_list|(
name|keyid
parameter_list|)
value|((keyid)& authhashmask)
end_define

begin_decl_stmt
name|int
name|authhashdisabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|authhashbuckets
init|=
name|DEF_AUTHHASHSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|authhashmask
init|=
name|DEF_AUTHHASHSIZE
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symkey
modifier|*
modifier|*
name|key_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|authkeynotfound
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys not found */
end_comment

begin_decl_stmt
name|u_long
name|authkeylookups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to lookup keys */
end_comment

begin_decl_stmt
name|u_long
name|authnumkeys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of active keys */
end_comment

begin_decl_stmt
name|u_long
name|authkeyexpired
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key lifetime expirations */
end_comment

begin_decl_stmt
name|u_long
name|authkeyuncached
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache misses */
end_comment

begin_decl_stmt
name|u_long
name|authnokey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to encrypt with no key */
end_comment

begin_decl_stmt
name|u_long
name|authencryptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to encrypt */
end_comment

begin_decl_stmt
name|u_long
name|authdecryptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to decrypt */
end_comment

begin_comment
comment|/*  * Storage for free symkey structures.  We malloc() such things but  * never free them.  */
end_comment

begin_decl_stmt
name|symkey
modifier|*
name|authfreekeys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|authnumfreekeys
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MEMINC
value|16
end_define

begin_comment
comment|/* number of new free ones to get */
end_comment

begin_comment
comment|/*  * The key cache. We cache the last key we looked at here.  */
end_comment

begin_decl_stmt
name|keyid_t
name|cache_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key identifier */
end_comment

begin_decl_stmt
name|u_char
modifier|*
name|cache_secret
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secret */
end_comment

begin_decl_stmt
name|u_short
name|cache_secretsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secret length */
end_comment

begin_decl_stmt
name|int
name|cache_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OpenSSL digest NID */
end_comment

begin_decl_stmt
name|u_short
name|cache_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags that wave */
end_comment

begin_comment
comment|/*  * init_auth - initialize internal data  */
end_comment

begin_function
name|void
name|init_auth
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|newalloc
decl_stmt|;
comment|/* 	 * Initialize hash table and free list 	 */
name|newalloc
operator|=
name|authhashbuckets
operator|*
sizeof|sizeof
argument_list|(
name|key_hash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|key_hash
operator|=
name|erealloc
argument_list|(
name|key_hash
argument_list|,
name|newalloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key_hash
argument_list|,
literal|'\0'
argument_list|,
name|newalloc
argument_list|)
expr_stmt|;
name|INIT_DLIST
argument_list|(
name|key_listhead
argument_list|,
name|llink
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
operator|&
name|free_auth_mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * free_auth_mem - assist in leak detection by freeing all dynamic  *		   allocations from this module.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|free_auth_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|symkey_alloc
modifier|*
name|alloc
decl_stmt|;
name|symkey_alloc
modifier|*
name|next_alloc
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|sk
operator|=
name|HEAD_DLIST
argument_list|(
name|key_listhead
argument_list|,
name|llink
argument_list|)
operator|)
condition|)
block|{
name|freesymkey
argument_list|(
name|sk
argument_list|,
operator|&
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|sk
operator|->
name|keyid
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|key_hash
argument_list|)
expr_stmt|;
name|key_hash
operator|=
name|NULL
expr_stmt|;
name|cache_keyid
operator|=
literal|0
expr_stmt|;
name|cache_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|alloc
operator|=
name|authallocs
init|;
name|alloc
operator|!=
name|NULL
condition|;
name|alloc
operator|=
name|next_alloc
control|)
block|{
name|next_alloc
operator|=
name|alloc
operator|->
name|link
expr_stmt|;
name|free
argument_list|(
name|alloc
operator|->
name|mem
argument_list|)
expr_stmt|;
block|}
name|authfreekeys
operator|=
name|NULL
expr_stmt|;
name|authnumfreekeys
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * auth_moremem - get some more free key structures  */
end_comment

begin_function
name|void
name|auth_moremem
parameter_list|(
name|int
name|keycount
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|void
modifier|*
name|base
decl_stmt|;
name|symkey_alloc
modifier|*
name|allocrec
decl_stmt|;
define|#
directive|define
name|MOREMEM_EXTRA_ALLOC
value|(sizeof(*allocrec))
else|#
directive|else
define|#
directive|define
name|MOREMEM_EXTRA_ALLOC
value|(0)
endif|#
directive|endif
name|i
operator|=
operator|(
name|keycount
operator|>
literal|0
operator|)
condition|?
name|keycount
else|:
name|MEMINC
expr_stmt|;
name|sk
operator|=
name|emalloc_zero
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sk
argument_list|)
operator|+
name|MOREMEM_EXTRA_ALLOC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|base
operator|=
name|sk
expr_stmt|;
endif|#
directive|endif
name|authnumfreekeys
operator|+=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|sk
operator|++
control|)
block|{
name|LINK_SLIST
argument_list|(
name|authfreekeys
argument_list|,
name|sk
argument_list|,
name|llink
operator|.
name|f
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|allocrec
operator|=
operator|(
name|void
operator|*
operator|)
name|sk
expr_stmt|;
name|allocrec
operator|->
name|mem
operator|=
name|base
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|authallocs
argument_list|,
name|allocrec
argument_list|,
name|link
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * auth_prealloc_symkeys  */
end_comment

begin_function
name|void
name|auth_prealloc_symkeys
parameter_list|(
name|int
name|keycount
parameter_list|)
block|{
name|int
name|allocated
decl_stmt|;
name|int
name|additional
decl_stmt|;
name|allocated
operator|=
name|authnumkeys
operator|+
name|authnumfreekeys
expr_stmt|;
name|additional
operator|=
name|keycount
operator|-
name|allocated
expr_stmt|;
if|if
condition|(
name|additional
operator|>
literal|0
condition|)
name|auth_moremem
argument_list|(
name|additional
argument_list|)
expr_stmt|;
name|auth_resize_hashtable
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_short
name|auth_log2
parameter_list|(
name|double
name|x
parameter_list|)
block|{
return|return
call|(
name|u_short
call|)
argument_list|(
name|log10
argument_list|(
name|x
argument_list|)
operator|/
name|log10
argument_list|(
literal|2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * auth_resize_hashtable  *  * Size hash table to average 4 or fewer entries per bucket initially,  * within the bounds of at least 4 and no more than 15 bits for the hash  * table index.  Populate the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|auth_resize_hashtable
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|totalkeys
decl_stmt|;
name|u_short
name|hashbits
decl_stmt|;
name|u_short
name|hash
decl_stmt|;
name|size_t
name|newalloc
decl_stmt|;
name|symkey
modifier|*
name|sk
decl_stmt|;
name|totalkeys
operator|=
name|authnumkeys
operator|+
name|authnumfreekeys
expr_stmt|;
name|hashbits
operator|=
name|auth_log2
argument_list|(
name|totalkeys
operator|/
literal|4.0
argument_list|)
operator|+
literal|1
expr_stmt|;
name|hashbits
operator|=
name|max
argument_list|(
literal|4
argument_list|,
name|hashbits
argument_list|)
expr_stmt|;
name|hashbits
operator|=
name|min
argument_list|(
literal|15
argument_list|,
name|hashbits
argument_list|)
expr_stmt|;
name|authhashbuckets
operator|=
literal|1
operator|<<
name|hashbits
expr_stmt|;
name|authhashmask
operator|=
name|authhashbuckets
operator|-
literal|1
expr_stmt|;
name|newalloc
operator|=
name|authhashbuckets
operator|*
sizeof|sizeof
argument_list|(
name|key_hash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|key_hash
operator|=
name|erealloc
argument_list|(
name|key_hash
argument_list|,
name|newalloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key_hash
argument_list|,
literal|'\0'
argument_list|,
name|newalloc
argument_list|)
expr_stmt|;
name|ITER_DLIST_BEGIN
argument_list|(
argument|key_listhead
argument_list|,
argument|sk
argument_list|,
argument|llink
argument_list|,
argument|symkey
argument_list|)
name|hash
operator|=
name|KEYHASH
argument_list|(
name|sk
operator|->
name|keyid
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|key_hash
index|[
name|hash
index|]
argument_list|,
name|sk
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|ITER_DLIST_END
argument_list|()
block|}
end_function

begin_comment
comment|/*  * allocsymkey - common code to allocate and link in symkey  *  * secret must be allocated with a free-compatible allocator.  It is  * owned by the referring symkey structure, and will be free()d by  * freesymkey().  */
end_comment

begin_function
specifier|static
name|void
name|allocsymkey
parameter_list|(
name|symkey
modifier|*
modifier|*
name|bucket
parameter_list|,
name|keyid_t
name|id
parameter_list|,
name|u_short
name|flags
parameter_list|,
name|u_short
name|type
parameter_list|,
name|u_long
name|lifetime
parameter_list|,
name|u_short
name|secretsize
parameter_list|,
name|u_char
modifier|*
name|secret
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
name|authnumfreekeys
operator|<
literal|1
condition|)
name|auth_moremem
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|UNLINK_HEAD_SLIST
argument_list|(
name|sk
argument_list|,
name|authfreekeys
argument_list|,
name|llink
operator|.
name|f
argument_list|)
expr_stmt|;
name|DEBUG_ENSURE
argument_list|(
name|sk
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|id
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|sk
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|sk
operator|->
name|secretsize
operator|=
name|secretsize
expr_stmt|;
name|sk
operator|->
name|secret
operator|=
name|secret
expr_stmt|;
name|sk
operator|->
name|lifetime
operator|=
name|lifetime
expr_stmt|;
name|LINK_SLIST
argument_list|(
operator|*
name|bucket
argument_list|,
name|sk
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|LINK_TAIL_DLIST
argument_list|(
name|key_listhead
argument_list|,
name|sk
argument_list|,
name|llink
argument_list|)
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|authnumkeys
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * freesymkey - common code to remove a symkey and recycle its entry.  */
end_comment

begin_function
specifier|static
name|void
name|freesymkey
parameter_list|(
name|symkey
modifier|*
name|sk
parameter_list|,
name|symkey
modifier|*
modifier|*
name|bucket
parameter_list|)
block|{
name|symkey
modifier|*
name|unlinked
decl_stmt|;
if|if
condition|(
name|sk
operator|->
name|secret
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|sk
operator|->
name|secret
argument_list|,
literal|'\0'
argument_list|,
name|sk
operator|->
name|secretsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sk
operator|->
name|secret
argument_list|)
expr_stmt|;
block|}
name|UNLINK_SLIST
argument_list|(
name|unlinked
argument_list|,
operator|*
name|bucket
argument_list|,
name|sk
argument_list|,
name|hlink
argument_list|,
name|symkey
argument_list|)
expr_stmt|;
name|DEBUG_ENSURE
argument_list|(
name|sk
operator|==
name|unlinked
argument_list|)
expr_stmt|;
name|UNLINK_DLIST
argument_list|(
name|sk
argument_list|,
name|llink
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sk
operator|+
name|offsetof
argument_list|(
name|symkey
argument_list|,
name|symkey_payload
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sk
argument_list|)
operator|-
name|offsetof
argument_list|(
name|symkey
argument_list|,
name|symkey_payload
argument_list|)
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|authfreekeys
argument_list|,
name|sk
argument_list|,
name|llink
operator|.
name|f
argument_list|)
expr_stmt|;
name|authnumkeys
operator|--
expr_stmt|;
name|authnumfreekeys
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * auth_findkey - find a key in the hash table  */
end_comment

begin_function
name|struct
name|savekey
modifier|*
name|auth_findkey
parameter_list|(
name|keyid_t
name|id
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
for|for
control|(
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|id
argument_list|)
index|]
init|;
name|sk
operator|!=
name|NULL
condition|;
name|sk
operator|=
name|sk
operator|->
name|hlink
control|)
block|{
if|if
condition|(
name|id
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
return|return
name|sk
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * auth_havekey - return TRUE if the key id is zero or known  */
end_comment

begin_function
name|int
name|auth_havekey
parameter_list|(
name|keyid_t
name|id
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|id
operator|||
name|cache_keyid
operator|==
name|id
condition|)
block|{
return|return
name|TRUE
return|;
block|}
for|for
control|(
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|id
argument_list|)
index|]
init|;
name|sk
operator|!=
name|NULL
condition|;
name|sk
operator|=
name|sk
operator|->
name|hlink
control|)
block|{
if|if
condition|(
name|id
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * authhavekey - return TRUE and cache the key, if zero or both known  *		 and trusted.  */
end_comment

begin_function
name|int
name|authhavekey
parameter_list|(
name|keyid_t
name|id
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|authkeylookups
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|id
operator|||
name|cache_keyid
operator|==
name|id
condition|)
block|{
return|return
name|TRUE
return|;
block|}
comment|/* 	 * Seach the bin for the key. If found and the key type 	 * is zero, somebody marked it trusted without specifying 	 * a key or key type. In this case consider the key missing. 	 */
name|authkeyuncached
operator|++
expr_stmt|;
for|for
control|(
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|id
argument_list|)
index|]
init|;
name|sk
operator|!=
name|NULL
condition|;
name|sk
operator|=
name|sk
operator|->
name|hlink
control|)
block|{
if|if
condition|(
name|id
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|sk
operator|->
name|type
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
block|}
block|}
comment|/* 	 * If the key is not found, or if it is found but not trusted, 	 * the key is not considered found. 	 */
if|if
condition|(
name|NULL
operator|==
name|sk
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|KEY_TRUSTED
operator|&
name|sk
operator|->
name|flags
operator|)
condition|)
block|{
name|authnokey
operator|++
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	 * The key is found and trusted. Initialize the key cache. 	 */
name|cache_keyid
operator|=
name|sk
operator|->
name|keyid
expr_stmt|;
name|cache_type
operator|=
name|sk
operator|->
name|type
expr_stmt|;
name|cache_flags
operator|=
name|sk
operator|->
name|flags
expr_stmt|;
name|cache_secret
operator|=
name|sk
operator|->
name|secret
expr_stmt|;
name|cache_secretsize
operator|=
name|sk
operator|->
name|secretsize
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * authtrust - declare a key to be trusted/untrusted  */
end_comment

begin_function
name|void
name|authtrust
parameter_list|(
name|keyid_t
name|id
parameter_list|,
name|u_long
name|trust
parameter_list|)
block|{
name|symkey
modifier|*
modifier|*
name|bucket
decl_stmt|;
name|symkey
modifier|*
name|sk
decl_stmt|;
name|u_long
name|lifetime
decl_stmt|;
comment|/* 	 * Search bin for key; if it does not exist and is untrusted, 	 * forget it. 	 */
name|bucket
operator|=
operator|&
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|sk
operator|=
operator|*
name|bucket
init|;
name|sk
operator|!=
name|NULL
condition|;
name|sk
operator|=
name|sk
operator|->
name|hlink
control|)
block|{
if|if
condition|(
name|id
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|trust
operator|&&
name|NULL
operator|==
name|sk
condition|)
return|return;
comment|/* 	 * There are two conditions remaining. Either it does not 	 * exist and is to be trusted or it does exist and is or is 	 * not to be trusted. 	 */
if|if
condition|(
name|sk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cache_keyid
operator|==
name|id
condition|)
block|{
name|cache_flags
operator|=
literal|0
expr_stmt|;
name|cache_keyid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Key exists. If it is to be trusted, say so and 		 * update its lifetime.  		 */
if|if
condition|(
name|trust
operator|>
literal|0
condition|)
block|{
name|sk
operator|->
name|flags
operator||=
name|KEY_TRUSTED
expr_stmt|;
if|if
condition|(
name|trust
operator|>
literal|1
condition|)
name|sk
operator|->
name|lifetime
operator|=
name|current_time
operator|+
name|trust
expr_stmt|;
else|else
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* No longer trusted, return it to the free list. */
name|freesymkey
argument_list|(
name|sk
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * keyid is not present, but the is to be trusted.  We allocate 	 * a new key, but do not specify a key type or secret. 	 */
if|if
condition|(
name|trust
operator|>
literal|1
condition|)
block|{
name|lifetime
operator|=
name|current_time
operator|+
name|trust
expr_stmt|;
block|}
else|else
block|{
name|lifetime
operator|=
literal|0
expr_stmt|;
block|}
name|allocsymkey
argument_list|(
name|bucket
argument_list|,
name|id
argument_list|,
name|KEY_TRUSTED
argument_list|,
literal|0
argument_list|,
name|lifetime
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * authistrusted - determine whether a key is trusted  */
end_comment

begin_function
name|int
name|authistrusted
parameter_list|(
name|keyid_t
name|keyno
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|symkey
modifier|*
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
name|keyno
operator|==
name|cache_keyid
condition|)
return|return
operator|!
operator|!
operator|(
name|KEY_TRUSTED
operator|&
name|cache_flags
operator|)
return|;
name|authkeyuncached
operator|++
expr_stmt|;
name|bucket
operator|=
operator|&
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|sk
operator|=
operator|*
name|bucket
init|;
name|sk
operator|!=
name|NULL
condition|;
name|sk
operator|=
name|sk
operator|->
name|hlink
control|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
block|}
if|if
condition|(
name|NULL
operator|==
name|sk
operator|||
operator|!
operator|(
name|KEY_TRUSTED
operator|&
name|sk
operator|->
name|flags
operator|)
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|MD5auth_setkey
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|int
name|keytype
parameter_list|,
specifier|const
name|u_char
modifier|*
name|key
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|symkey
modifier|*
modifier|*
name|bucket
decl_stmt|;
name|u_char
modifier|*
name|secret
decl_stmt|;
name|size_t
name|secretsize
decl_stmt|;
name|DEBUG_ENSURE
argument_list|(
name|keytype
operator|<=
name|USHRT_MAX
argument_list|)
expr_stmt|;
name|DEBUG_ENSURE
argument_list|(
name|len
operator|<
literal|4
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|len
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * See if we already have the key.  If so just stick in the 	 * new value. 	 */
name|bucket
operator|=
operator|&
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|sk
operator|=
operator|*
name|bucket
init|;
name|sk
operator|!=
name|NULL
condition|;
name|sk
operator|=
name|sk
operator|->
name|hlink
control|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
name|sk
operator|->
name|type
operator|=
operator|(
name|u_short
operator|)
name|keytype
expr_stmt|;
name|secretsize
operator|=
name|len
expr_stmt|;
name|sk
operator|->
name|secretsize
operator|=
operator|(
name|u_short
operator|)
name|secretsize
expr_stmt|;
ifndef|#
directive|ifndef
name|DISABLE_BUG1243_FIX
name|memcpy
argument_list|(
name|sk
operator|->
name|secret
argument_list|,
name|key
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sk
operator|->
name|secret
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cache_keyid
operator|==
name|keyno
condition|)
block|{
name|cache_flags
operator|=
literal|0
expr_stmt|;
name|cache_keyid
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* 	 * Need to allocate new structure.  Do it. 	 */
name|secretsize
operator|=
name|len
expr_stmt|;
name|secret
operator|=
name|emalloc
argument_list|(
name|secretsize
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DISABLE_BUG1243_FIX
name|memcpy
argument_list|(
name|secret
argument_list|,
name|key
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|secret
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|allocsymkey
argument_list|(
name|bucket
argument_list|,
name|keyno
argument_list|,
literal|0
argument_list|,
operator|(
name|u_short
operator|)
name|keytype
argument_list|,
literal|0
argument_list|,
operator|(
name|u_short
operator|)
name|secretsize
argument_list|,
name|secret
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
block|{
name|size_t
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"auth_setkey: key %d type %d len %d "
argument_list|,
operator|(
name|int
operator|)
name|keyno
argument_list|,
name|keytype
argument_list|,
operator|(
name|int
operator|)
name|secretsize
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|secretsize
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|secret
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * auth_delkeys - delete non-autokey untrusted keys, and clear all info  *                except the trusted bit of non-autokey trusted keys, in  *		  preparation for rereading the keys file.  */
end_comment

begin_function
name|void
name|auth_delkeys
parameter_list|(
name|void
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|ITER_DLIST_BEGIN
argument_list|(
argument|key_listhead
argument_list|,
argument|sk
argument_list|,
argument|llink
argument_list|,
argument|symkey
argument_list|)
if|if
condition|(
name|sk
operator|->
name|keyid
operator|>
name|NTP_MAXKEY
condition|)
block|{
comment|/* autokey */
continue|continue;
block|}
comment|/* 		 * Don't lose info as to which keys are trusted. 		 */
if|if
condition|(
name|KEY_TRUSTED
operator|&
name|sk
operator|->
name|flags
condition|)
block|{
if|if
condition|(
name|sk
operator|->
name|secret
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|sk
operator|->
name|secret
argument_list|,
literal|'\0'
argument_list|,
name|sk
operator|->
name|secretsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sk
operator|->
name|secret
argument_list|)
expr_stmt|;
block|}
name|sk
operator|->
name|secretsize
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|lifetime
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|freesymkey
argument_list|(
name|sk
argument_list|,
operator|&
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|sk
operator|->
name|keyid
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
name|ITER_DLIST_END
argument_list|()
block|}
end_function

begin_comment
comment|/*  * auth_agekeys - delete keys whose lifetimes have expired  */
end_comment

begin_function
name|void
name|auth_agekeys
parameter_list|(
name|void
parameter_list|)
block|{
name|symkey
modifier|*
name|sk
decl_stmt|;
name|ITER_DLIST_BEGIN
argument_list|(
argument|key_listhead
argument_list|,
argument|sk
argument_list|,
argument|llink
argument_list|,
argument|symkey
argument_list|)
if|if
condition|(
name|sk
operator|->
name|lifetime
operator|>
literal|0
operator|&&
name|current_time
operator|>
name|sk
operator|->
name|lifetime
condition|)
block|{
name|freesymkey
argument_list|(
name|sk
argument_list|,
operator|&
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|sk
operator|->
name|keyid
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|authkeyexpired
operator|++
expr_stmt|;
block|}
name|ITER_DLIST_END
argument_list|()
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"auth_agekeys: at %lu keys %lu expired %lu\n"
operator|,
name|current_time
operator|,
name|authnumkeys
operator|,
name|authkeyexpired
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * authencrypt - generate message authenticator  *  * Returns length of authenticator field, zero if key not found.  */
end_comment

begin_function
name|int
name|authencrypt
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|u_int32
modifier|*
name|pkt
parameter_list|,
name|int
name|length
parameter_list|)
block|{\
comment|/* 	 * A zero key identifier means the sender has not verified 	 * the last message was correctly authenticated. The MAC 	 * consists of a single word with value zero. 	 */
name|authencryptions
operator|++
expr_stmt|;
name|pkt
index|[
name|length
operator|/
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|keyno
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|keyno
condition|)
block|{
return|return
literal|4
return|;
block|}
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|MD5authencrypt
argument_list|(
name|cache_type
argument_list|,
name|cache_secret
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * authdecrypt - verify message authenticator  *  * Returns TRUE if authenticator valid, FALSE if invalid or not found.  */
end_comment

begin_function
name|int
name|authdecrypt
parameter_list|(
name|keyid_t
name|keyno
parameter_list|,
name|u_int32
modifier|*
name|pkt
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* 	 * A zero key identifier means the sender has not verified 	 * the last message was correctly authenticated.  For our 	 * purpose this is an invalid authenticator. 	 */
name|authdecryptions
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|keyno
operator|||
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
operator|||
name|size
operator|<
literal|4
condition|)
block|{
return|return
name|FALSE
return|;
block|}
return|return
name|MD5authdecrypt
argument_list|(
name|cache_type
argument_list|,
name|cache_secret
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

end_unit

