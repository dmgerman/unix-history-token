begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_calendar.c - calendar and helper functions  *  * Written by Juergen Perlinger (perlinger@ntp.org) for the NTP project.  * The contents of 'html/copyright.html' apply.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_comment
comment|/*  *---------------------------------------------------------------------  * replacing the 'time()' function  * --------------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|static
name|systime_func_ptr
name|systime_func
init|=
operator|&
name|time
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|inline
name|time_t
name|now
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|systime_func_ptr
name|ntpcal_set_timefunc
parameter_list|(
name|systime_func_ptr
name|nfunc
parameter_list|)
block|{
name|systime_func_ptr
name|res
decl_stmt|;
name|res
operator|=
name|systime_func
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|nfunc
condition|)
name|nfunc
operator|=
operator|&
name|time
expr_stmt|;
name|systime_func
operator|=
name|nfunc
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|time_t
name|now
parameter_list|(
name|void
parameter_list|)
block|{
return|return
call|(
modifier|*
name|systime_func
call|)
argument_list|(
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert between 'time_t' and 'vint64'  *---------------------------------------------------------------------  */
end_comment

begin_function
name|vint64
name|time_to_vint64
parameter_list|(
specifier|const
name|time_t
modifier|*
name|ptt
parameter_list|)
block|{
name|vint64
name|res
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
name|tt
operator|=
operator|*
name|ptt
expr_stmt|;
if|#
directive|if
name|SIZEOF_TIME_T
operator|<=
literal|4
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tt
operator|<
literal|0
condition|)
block|{
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|uint32_t
operator|)
operator|-
name|tt
expr_stmt|;
name|M_NEG
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|uint32_t
operator|)
name|tt
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
name|res
operator|.
name|q_s
operator|=
name|tt
expr_stmt|;
else|#
directive|else
comment|/* 	 * shifting negative signed quantities is compiler-dependent, so 	 * we better avoid it and do it all manually. And shifting more 	 * than the width of a quantity is undefined. Also a don't do! 	 */
if|if
condition|(
name|tt
operator|<
literal|0
condition|)
block|{
name|tt
operator|=
operator|-
name|tt
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|uint32_t
operator|)
name|tt
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|tt
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|M_NEG
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|uint32_t
operator|)
name|tt
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|tt
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|res
return|;
block|}
end_function

begin_function
name|time_t
name|vint64_to_time
parameter_list|(
specifier|const
name|vint64
modifier|*
name|tv
parameter_list|)
block|{
name|time_t
name|res
decl_stmt|;
if|#
directive|if
name|SIZEOF_TIME_T
operator|<=
literal|4
name|res
operator|=
operator|(
name|time_t
operator|)
name|tv
operator|->
name|D_s
operator|.
name|lo
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INT64
argument_list|)
name|res
operator|=
operator|(
name|time_t
operator|)
name|tv
operator|->
name|q_s
expr_stmt|;
else|#
directive|else
name|res
operator|=
operator|(
operator|(
name|time_t
operator|)
name|tv
operator|->
name|d_s
operator|.
name|hi
operator|<<
literal|32
operator|)
operator||
name|tv
operator|->
name|D_s
operator|.
name|lo
expr_stmt|;
endif|#
directive|endif
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Get the build date& time  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_get_build_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
comment|/* The C standard tells us the format of '__DATE__': 	 * 	 * __DATE__ The date of translation of the preprocessing 	 * translation unit: a character string literal of the form "Mmm 	 * dd yyyy", where the names of the months are the same as those 	 * generated by the asctime function, and the first character of 	 * dd is a space character if the value is less than 10. If the 	 * date of translation is not available, an 	 * implementation-defined valid date shall be supplied. 	 * 	 * __TIME__ The time of translation of the preprocessing 	 * translation unit: a character string literal of the form 	 * "hh:mm:ss" as in the time generated by the asctime 	 * function. If the time of translation is not available, an 	 * implementation-defined valid time shall be supplied. 	 * 	 * Note that MSVC declares DATE and TIME to be in the local time 	 * zone, while neither the C standard nor the GCC docs make any 	 * statement about this. As a result, we may be +/-12hrs off 	 * UTC.  But for practical purposes, this should not be a 	 * problem. 	 * 	 */
ifdef|#
directive|ifdef
name|MKREPRO_DATE
specifier|static
specifier|const
name|char
name|build
index|[]
init|=
name|MKREPRO_TIME
literal|"/"
name|MKREPRO_DATE
decl_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|char
name|build
index|[]
init|=
name|__TIME__
literal|"/"
name|__DATE__
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|char
name|mlist
index|[]
init|=
literal|"JanFebMarAprMayJunJulAugSepOctNovDec"
decl_stmt|;
name|char
name|monstr
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|short
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|day
decl_stmt|,
name|year
decl_stmt|;
comment|/* Note: The above quantities are used for sscanf 'hu' format, 	 * so using 'uint16_t' is contra-indicated! 	 */
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|int
name|ignore
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|ZERO
argument_list|(
operator|*
name|jd
argument_list|)
expr_stmt|;
name|jd
operator|->
name|year
operator|=
literal|1970
expr_stmt|;
name|jd
operator|->
name|month
operator|=
literal|1
expr_stmt|;
name|jd
operator|->
name|monthday
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* check environment if build date should be ignored */
if|if
condition|(
literal|0
operator|==
name|ignore
condition|)
block|{
specifier|const
name|char
modifier|*
name|envstr
decl_stmt|;
name|envstr
operator|=
name|getenv
argument_list|(
literal|"NTPD_IGNORE_BUILD_DATE"
argument_list|)
expr_stmt|;
name|ignore
operator|=
literal|1
operator|+
operator|(
name|envstr
operator|&&
operator|(
operator|!
operator|*
name|envstr
operator|||
operator|!
name|strcasecmp
argument_list|(
name|envstr
argument_list|,
literal|"yes"
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ignore
operator|>
literal|1
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
if|if
condition|(
literal|6
operator|==
name|sscanf
argument_list|(
name|build
argument_list|,
literal|"%hu:%hu:%hu/%3s %hu %hu"
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|minute
argument_list|,
operator|&
name|second
argument_list|,
name|monstr
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|year
argument_list|)
condition|)
block|{
name|cp
operator|=
name|strstr
argument_list|(
name|mlist
argument_list|,
name|monstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|cp
condition|)
block|{
name|jd
operator|->
name|year
operator|=
name|year
expr_stmt|;
name|jd
operator|->
name|month
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|mlist
operator|)
operator|/
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|jd
operator|->
name|monthday
operator|=
operator|(
name|uint8_t
operator|)
name|day
expr_stmt|;
name|jd
operator|->
name|hour
operator|=
operator|(
name|uint8_t
operator|)
name|hour
expr_stmt|;
name|jd
operator|->
name|minute
operator|=
operator|(
name|uint8_t
operator|)
name|minute
expr_stmt|;
name|jd
operator|->
name|second
operator|=
operator|(
name|uint8_t
operator|)
name|second
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * basic calendar stuff  * --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* month table for a year starting with March,1st */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|shift_month_table
index|[
literal|13
index|]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|61
block|,
literal|92
block|,
literal|122
block|,
literal|153
block|,
literal|184
block|,
literal|214
block|,
literal|245
block|,
literal|275
block|,
literal|306
block|,
literal|337
block|,
literal|366
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* month tables for years starting with January,1st; regular& leap */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|real_month_table
index|[
literal|2
index|]
index|[
literal|13
index|]
init|=
block|{
comment|/* -*- table for regular years -*- */
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|,
literal|365
block|}
block|,
comment|/* -*- table for leap years -*- */
block|{
literal|0
block|,
literal|31
block|,
literal|60
block|,
literal|91
block|,
literal|121
block|,
literal|152
block|,
literal|182
block|,
literal|213
block|,
literal|244
block|,
literal|274
block|,
literal|305
block|,
literal|335
block|,
literal|366
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some notes on the terminology:  *  * We use the proleptic Gregorian calendar, which is the Gregorian  * calendar extended in both directions ad infinitum. This totally  * disregards the fact that this calendar was invented in 1582, and  * was adopted at various dates over the world; sometimes even after  * the start of the NTP epoch.  *  * Normally date parts are given as current cycles, while time parts  * are given as elapsed cycles:  *  * 1970-01-01/03:04:05 means 'IN the 1970st. year, IN the first month,  * ON the first day, with 3hrs, 4minutes and 5 seconds elapsed.  *  * The basic calculations for this calendar implementation deal with  * ELAPSED date units, which is the number of full years, full months  * and full days before a date: 1970-01-01 would be (1969, 0, 0) in  * that notation.  *  * To ease the numeric computations, month and day values outside the  * normal range are acceptable: 2001-03-00 will be treated as the day  * before 2001-03-01, 2000-13-32 will give the same result as  * 2001-02-01 and so on.  *  * 'rd' or 'RD' is used as an abbreviation for the latin 'rata die'  * (day number).  This is the number of days elapsed since 0000-12-31  * in the proleptic Gregorian calendar. The begin of the Christian Era  * (0001-01-01) is RD(1).  *  *   * Some notes on the implementation:  *  * Calendar algorithms thrive on the division operation, which is one of  * the slowest numerical operations in any CPU. What saves us here from  * abysmal performance is the fact that all divisions are divisions by  * constant numbers, and most compilers can do this by a multiplication  * operation.  But this might not work when using the div/ldiv/lldiv  * function family, because many compilers are not able to do inline  * expansion of the code with following optimisation for the  * constant-divider case.  *  * Also div/ldiv/lldiv are defined in terms of int/long/longlong, which  * are inherently target dependent. Nothing that could not be cured with  * autoconf, but still a mess...  *  * Furthermore, we need floor division while C demands truncation to  * zero, so additional steps are required to make sure the algorithms  * work.  *  * For all this, all divisions by constant are coded manually, even when  * there is a joined div/mod operation: The optimiser should sort that  * out, if possible.  *  * Finally, the functions do not check for overflow conditions. This  * is a sacrifice made for execution speed; since a 32-bit day counter  * covers +/- 5,879,610 years, this should not pose a problem here.  */
end_comment

begin_comment
comment|/*  * ==================================================================  *  * General algorithmic stuff  *  * ==================================================================  */
end_comment

begin_comment
comment|/*  *---------------------------------------------------------------------  * Do a periodic extension of 'value' around 'pivot' with a period of  * 'cycle'.  *  * The result 'res' is a number that holds to the following properties:  *  *   1)	 res MOD cycle == value MOD cycle  *   2)	 pivot<= res< pivot + cycle  *	 (replace</<= with>/>= for negative cycles)  *  * where 'MOD' denotes the modulo operator for FLOOR DIVISION, which  * is not the same as the '%' operator in C: C requires division to be  * a truncated division, where remainder and dividend have the same  * sign if the remainder is not zero, whereas floor division requires  * divider and modulus to have the same sign for a non-zero modulus.  *  * This function has some useful applications:  *  * + let Y be a calendar year and V a truncated 2-digit year: then  *	periodic_extend(Y-50, V, 100)  *   is the closest expansion of the truncated year with respect to  *   the full year, that is a 4-digit year with a difference of less  *   than 50 years to the year Y. ("century unfolding")  *  * + let T be a UN*X time stamp and V be seconds-of-day: then  *	perodic_extend(T-43200, V, 86400)  *   is a time stamp that has the same seconds-of-day as the input  *   value, with an absolute difference to T of<= 12hrs.  ("day  *   unfolding")  *  * + Wherever you have a truncated periodic value and a non-truncated  *   base value and you want to match them somehow...  *  * Basically, the function delivers 'pivot + (value - pivot) % cycle',  * but the implementation takes some pains to avoid internal signed  * integer overflows in the '(value - pivot) % cycle' part and adheres  * to the floor division convention.  *  * If 64bit scalars where available on all intended platforms, writing a  * version that uses 64 bit ops would be easy; writing a general  * division routine for 64bit ops on a platform that can only do  * 32/16bit divisions and is still performant is a bit more  * difficult. Since most usecases can be coded in a way that does only  * require the 32-bit version a 64bit version is NOT provided here.  * ---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_periodic_extend
parameter_list|(
name|int32_t
name|pivot
parameter_list|,
name|int32_t
name|value
parameter_list|,
name|int32_t
name|cycle
parameter_list|)
block|{
name|uint32_t
name|diff
decl_stmt|;
name|char
name|cpl
init|=
literal|0
decl_stmt|;
comment|/* modulo complement flag */
name|char
name|neg
init|=
literal|0
decl_stmt|;
comment|/* sign change flag	    */
comment|/* make the cycle positive and adjust the flags */
if|if
condition|(
name|cycle
operator|<
literal|0
condition|)
block|{
name|cycle
operator|=
operator|-
name|cycle
expr_stmt|;
name|neg
operator|^=
literal|1
expr_stmt|;
name|cpl
operator|^=
literal|1
expr_stmt|;
block|}
comment|/* guard against div by zero or one */
if|if
condition|(
name|cycle
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Get absolute difference as unsigned quantity and 		 * the complement flag. This is done by always 		 * subtracting the smaller value from the bigger 		 * one. This implementation works only on a two's 		 * complement machine! 		 */
if|if
condition|(
name|value
operator|>=
name|pivot
condition|)
block|{
name|diff
operator|=
operator|(
name|uint32_t
operator|)
name|value
operator|-
operator|(
name|uint32_t
operator|)
name|pivot
expr_stmt|;
block|}
else|else
block|{
name|diff
operator|=
operator|(
name|uint32_t
operator|)
name|pivot
operator|-
operator|(
name|uint32_t
operator|)
name|value
expr_stmt|;
name|cpl
operator|^=
literal|1
expr_stmt|;
block|}
name|diff
operator|%=
operator|(
name|uint32_t
operator|)
name|cycle
expr_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
if|if
condition|(
name|cpl
condition|)
name|diff
operator|=
name|cycle
operator|-
name|diff
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|diff
operator|=
operator|~
name|diff
operator|+
literal|1
expr_stmt|;
name|pivot
operator|+=
name|diff
expr_stmt|;
block|}
block|}
return|return
name|pivot
return|;
block|}
end_function

begin_comment
comment|/*  *-------------------------------------------------------------------  * Convert a timestamp in NTP scale to a 64bit seconds value in the UN*X  * scale with proper epoch unfolding around a given pivot or the current  * system time. This function happily accepts negative pivot values as  * timestamps befor 1970-01-01, so be aware of possible trouble on  * platforms with 32bit 'time_t'!  *  * This is also a periodic extension, but since the cycle is 2^32 and  * the shift is 2^31, we can do some *very* fast math without explicit  * divisions.  *-------------------------------------------------------------------  */
end_comment

begin_function
name|vint64
name|ntpcal_ntp_to_time
parameter_list|(
name|uint32_t
name|ntp
parameter_list|,
specifier|const
name|time_t
modifier|*
name|pivot
parameter_list|)
block|{
name|vint64
name|res
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_INT64
name|res
operator|.
name|q_s
operator|=
operator|(
name|pivot
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|pivot
else|:
name|now
argument_list|()
expr_stmt|;
name|res
operator|.
name|Q_s
operator|-=
literal|0x80000000
expr_stmt|;
comment|/* unshift of half range */
name|ntp
operator|-=
operator|(
name|uint32_t
operator|)
name|JAN_1970
expr_stmt|;
comment|/* warp into UN*X domain */
name|ntp
operator|-=
name|res
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
comment|/* cycle difference	 */
name|res
operator|.
name|Q_s
operator|+=
operator|(
name|uint64_t
operator|)
name|ntp
expr_stmt|;
comment|/* get expanded time	 */
else|#
directive|else
comment|/* no 64bit scalars */
name|time_t
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|pivot
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|pivot
else|:
name|now
argument_list|()
expr_stmt|;
name|res
operator|=
name|time_to_vint64
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|ntp
operator|-=
operator|(
name|uint32_t
operator|)
name|JAN_1970
expr_stmt|;
comment|/* warp into UN*X domain */
name|ntp
operator|-=
name|res
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
comment|/* cycle difference	 */
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no 64bit scalars */
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *-------------------------------------------------------------------  * Convert a timestamp in NTP scale to a 64bit seconds value in the NTP  * scale with proper epoch unfolding around a given pivot or the current  * system time.  *  * Note: The pivot must be given in the UN*X time domain!  *  * This is also a periodic extension, but since the cycle is 2^32 and  * the shift is 2^31, we can do some *very* fast math without explicit  * divisions.  *-------------------------------------------------------------------  */
end_comment

begin_function
name|vint64
name|ntpcal_ntp_to_ntp
parameter_list|(
name|uint32_t
name|ntp
parameter_list|,
specifier|const
name|time_t
modifier|*
name|pivot
parameter_list|)
block|{
name|vint64
name|res
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_INT64
name|res
operator|.
name|q_s
operator|=
operator|(
name|pivot
operator|)
condition|?
operator|*
name|pivot
else|:
name|now
argument_list|()
expr_stmt|;
name|res
operator|.
name|Q_s
operator|-=
literal|0x80000000
expr_stmt|;
comment|/* unshift of half range */
name|res
operator|.
name|Q_s
operator|+=
operator|(
name|uint32_t
operator|)
name|JAN_1970
expr_stmt|;
comment|/* warp into NTP domain	 */
name|ntp
operator|-=
name|res
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
comment|/* cycle difference	 */
name|res
operator|.
name|Q_s
operator|+=
operator|(
name|uint64_t
operator|)
name|ntp
expr_stmt|;
comment|/* get expanded time	 */
else|#
directive|else
comment|/* no 64bit scalars */
name|time_t
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|pivot
operator|)
condition|?
operator|*
name|pivot
else|:
name|now
argument_list|()
expr_stmt|;
name|res
operator|=
name|time_to_vint64
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
literal|0x80000000u
argument_list|)
expr_stmt|;
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
operator|(
name|uint32_t
operator|)
name|JAN_1970
argument_list|)
expr_stmt|;
comment|/*into NTP */
name|ntp
operator|-=
name|res
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
comment|/* cycle difference	 */
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
literal|0
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no 64bit scalars */
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * ==================================================================  *  * Splitting values to composite entities  *  * ==================================================================  */
end_comment

begin_comment
comment|/*  *-------------------------------------------------------------------   * Split a 64bit seconds value into elapsed days in 'res.hi' and  * elapsed seconds since midnight in 'res.lo' using explicit floor  * division. This function happily accepts negative time values as  * timestamps before the respective epoch start.  * -------------------------------------------------------------------  */
end_comment

begin_function
name|ntpcal_split
name|ntpcal_daysplit
parameter_list|(
specifier|const
name|vint64
modifier|*
name|ts
parameter_list|)
block|{
name|ntpcal_split
name|res
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_INT64
comment|/* manual floor division by SECSPERDAY */
name|res
operator|.
name|hi
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|ts
operator|->
name|q_s
operator|/
name|SECSPERDAY
argument_list|)
expr_stmt|;
name|res
operator|.
name|lo
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|ts
operator|->
name|q_s
operator|%
name|SECSPERDAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|lo
operator|<
literal|0
condition|)
block|{
name|res
operator|.
name|hi
operator|-=
literal|1
expr_stmt|;
name|res
operator|.
name|lo
operator|+=
name|SECSPERDAY
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	 * since we do not have 64bit ops, we have to this by hand. 	 * Luckily SECSPERDAY is 86400 is 675*128, so we do the division 	 * using chained 32/16 bit divisions and shifts. 	 */
name|vint64
name|op
decl_stmt|;
name|uint32_t
name|q
decl_stmt|,
name|r
decl_stmt|,
name|a
decl_stmt|;
name|int
name|isneg
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|op
argument_list|,
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fix sign */
name|isneg
operator|=
name|M_ISNEG
argument_list|(
name|op
operator|.
name|D_s
operator|.
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
name|M_NEG
argument_list|(
name|op
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|op
operator|.
name|D_s
operator|.
name|lo
argument_list|)
expr_stmt|;
comment|/* save remainder of DIV 128, shift for divide */
name|r
operator|=
name|op
operator|.
name|D_s
operator|.
name|lo
operator|&
literal|127
expr_stmt|;
comment|/* save remainder bits */
name|op
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|op
operator|.
name|D_s
operator|.
name|lo
operator|>>
literal|7
operator|)
operator||
operator|(
name|op
operator|.
name|D_s
operator|.
name|hi
operator|<<
literal|25
operator|)
expr_stmt|;
name|op
operator|.
name|D_s
operator|.
name|hi
operator|=
operator|(
name|op
operator|.
name|D_s
operator|.
name|hi
operator|>>
literal|7
operator|)
expr_stmt|;
comment|/* now do a mnual division, trying to remove as many ops as 	 * possible -- division is always slow! An since we do not have 	 * the advantage of a specific 64/32 bit or even a specific 32/16 	 * bit division op, but must use the general 32/32bit division 	 * even if we *know* the divider fits into unsigned 16 bits, the 	 * exra code pathes should pay off. 	 */
name|a
operator|=
name|op
operator|.
name|D_s
operator|.
name|hi
expr_stmt|;
if|if
condition|(
name|a
operator|>
literal|675u
condition|)
name|a
operator|=
name|a
operator|%
literal|675u
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
name|a
operator|=
operator|(
name|a
operator|<<
literal|16
operator|)
operator||
name|op
operator|.
name|W_s
operator|.
name|lh
expr_stmt|;
name|q
operator|=
name|a
operator|/
literal|675u
expr_stmt|;
name|a
operator|=
name|a
operator|%
literal|675u
expr_stmt|;
name|a
operator|=
operator|(
name|a
operator|<<
literal|16
operator|)
operator||
name|op
operator|.
name|W_s
operator|.
name|ll
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|<<
literal|16
operator|)
operator||
operator|(
name|a
operator|/
literal|675u
operator|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|op
operator|.
name|D_s
operator|.
name|lo
expr_stmt|;
name|q
operator|=
name|a
operator|/
literal|675u
expr_stmt|;
block|}
name|a
operator|=
name|a
operator|%
literal|675u
expr_stmt|;
comment|/* assemble remainder */
name|r
operator||=
name|a
operator|<<
literal|7
expr_stmt|;
comment|/* fix sign of result */
if|if
condition|(
name|isneg
condition|)
block|{
if|if
condition|(
name|r
condition|)
block|{
name|r
operator|=
name|SECSPERDAY
operator|-
name|r
expr_stmt|;
name|q
operator|=
operator|~
name|q
expr_stmt|;
block|}
else|else
name|q
operator|=
operator|~
name|q
operator|+
literal|1
expr_stmt|;
block|}
name|res
operator|.
name|hi
operator|=
name|q
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|r
expr_stmt|;
endif|#
directive|endif
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *-------------------------------------------------------------------   * Split a 32bit seconds value into h/m/s and excessive days.  This  * function happily accepts negative time values as timestamps before  * midnight.  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int32_t
name|priv_timesplit
parameter_list|(
name|int32_t
name|split
index|[
literal|3
index|]
parameter_list|,
name|int32_t
name|ts
parameter_list|)
block|{
name|int32_t
name|days
init|=
literal|0
decl_stmt|;
comment|/* make sure we have a positive offset into a day */
if|if
condition|(
name|ts
operator|<
literal|0
operator|||
name|ts
operator|>=
name|SECSPERDAY
condition|)
block|{
name|days
operator|=
name|ts
operator|/
name|SECSPERDAY
expr_stmt|;
name|ts
operator|=
name|ts
operator|%
name|SECSPERDAY
expr_stmt|;
if|if
condition|(
name|ts
operator|<
literal|0
condition|)
block|{
name|days
operator|-=
literal|1
expr_stmt|;
name|ts
operator|+=
name|SECSPERDAY
expr_stmt|;
block|}
block|}
comment|/* get secs, mins, hours */
name|split
index|[
literal|2
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|ts
operator|%
name|SECSPERMIN
argument_list|)
expr_stmt|;
name|ts
operator|/=
name|SECSPERMIN
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|ts
operator|%
name|MINSPERHR
argument_list|)
expr_stmt|;
name|split
index|[
literal|0
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|ts
operator|/
name|MINSPERHR
argument_list|)
expr_stmt|;
return|return
name|days
return|;
block|}
end_function

begin_comment
comment|/*  * ---------------------------------------------------------------------  * Given the number of elapsed days in the calendar era, split this  * number into the number of elapsed years in 'res.hi' and the number  * of elapsed days of that year in 'res.lo'.  *  * if 'isleapyear' is not NULL, it will receive an integer that is 0 for  * regular years and a non-zero value for leap years.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|ntpcal_split
name|ntpcal_split_eradays
parameter_list|(
name|int32_t
name|days
parameter_list|,
name|int
modifier|*
name|isleapyear
parameter_list|)
block|{
name|ntpcal_split
name|res
decl_stmt|;
name|int32_t
name|n400
decl_stmt|,
name|n100
decl_stmt|,
name|n004
decl_stmt|,
name|n001
decl_stmt|,
name|yday
decl_stmt|;
comment|/* calendar year cycles */
comment|/* 	 * Split off calendar cycles, using floor division in the first 	 * step. After that first step, simple division does it because 	 * all operands are positive; alas, we have to be aware of the 	 * possibe cycle overflows for 100 years and 1 year, caused by 	 * the additional leap day. 	 */
name|n400
operator|=
name|days
operator|/
name|GREGORIAN_CYCLE_DAYS
expr_stmt|;
name|yday
operator|=
name|days
operator|%
name|GREGORIAN_CYCLE_DAYS
expr_stmt|;
if|if
condition|(
name|yday
operator|<
literal|0
condition|)
block|{
name|n400
operator|-=
literal|1
expr_stmt|;
name|yday
operator|+=
name|GREGORIAN_CYCLE_DAYS
expr_stmt|;
block|}
name|n100
operator|=
name|yday
operator|/
name|GREGORIAN_NORMAL_CENTURY_DAYS
expr_stmt|;
name|yday
operator|=
name|yday
operator|%
name|GREGORIAN_NORMAL_CENTURY_DAYS
expr_stmt|;
name|n004
operator|=
name|yday
operator|/
name|GREGORIAN_NORMAL_LEAP_CYCLE_DAYS
expr_stmt|;
name|yday
operator|=
name|yday
operator|%
name|GREGORIAN_NORMAL_LEAP_CYCLE_DAYS
expr_stmt|;
name|n001
operator|=
name|yday
operator|/
name|DAYSPERYEAR
expr_stmt|;
name|yday
operator|=
name|yday
operator|%
name|DAYSPERYEAR
expr_stmt|;
comment|/* 	 * check for leap cycle overflows and calculate the leap flag 	 * if needed 	 */
if|if
condition|(
operator|(
name|n001
operator||
name|n100
operator|)
operator|>
literal|3
condition|)
block|{
comment|/* hit last day of leap year */
name|n001
operator|-=
literal|1
expr_stmt|;
name|yday
operator|+=
name|DAYSPERYEAR
expr_stmt|;
if|if
condition|(
name|isleapyear
condition|)
operator|*
name|isleapyear
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isleapyear
condition|)
operator|*
name|isleapyear
operator|=
operator|(
name|n001
operator|==
literal|3
operator|)
operator|&&
operator|(
operator|(
name|n004
operator|!=
literal|24
operator|)
operator|||
operator|(
name|n100
operator|==
literal|3
operator|)
operator|)
expr_stmt|;
comment|/* now merge the cycles to elapsed years, using horner scheme */
name|res
operator|.
name|hi
operator|=
operator|(
operator|(
literal|4
operator|*
name|n400
operator|+
name|n100
operator|)
operator|*
literal|25
operator|+
name|n004
operator|)
operator|*
literal|4
operator|+
name|n001
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|yday
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Given a number of elapsed days in a year and a leap year indicator,  * split the number of elapsed days into the number of elapsed months in  * 'res.hi' and the number of elapsed days of that month in 'res.lo'.  *  * This function will fail and return {-1,-1} if the number of elapsed  * days is not in the valid range!  *---------------------------------------------------------------------  */
end_comment

begin_function
name|ntpcal_split
name|ntpcal_split_yeardays
parameter_list|(
name|int32_t
name|eyd
parameter_list|,
name|int
name|isleapyear
parameter_list|)
block|{
name|ntpcal_split
name|res
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|lt
decl_stmt|;
comment|/* month length table	*/
comment|/* check leap year flag and select proper table */
name|lt
operator|=
name|real_month_table
index|[
operator|(
name|isleapyear
operator|!=
literal|0
operator|)
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|eyd
operator|&&
name|eyd
operator|<
name|lt
index|[
literal|12
index|]
condition|)
block|{
comment|/* get zero-based month by approximation& correction step */
name|res
operator|.
name|hi
operator|=
name|eyd
operator|>>
literal|5
expr_stmt|;
comment|/* approx month; might be 1 too low */
if|if
condition|(
name|lt
index|[
name|res
operator|.
name|hi
operator|+
literal|1
index|]
operator|<=
name|eyd
condition|)
comment|/* fixup approximative month value  */
name|res
operator|.
name|hi
operator|+=
literal|1
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|eyd
operator|-
name|lt
index|[
name|res
operator|.
name|hi
index|]
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|lo
operator|=
name|res
operator|.
name|hi
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert a RD into the date part of a 'struct calendar'.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_rd_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|int32_t
name|rd
parameter_list|)
block|{
name|ntpcal_split
name|split
decl_stmt|;
name|int
name|leaps
decl_stmt|;
name|int
name|retv
decl_stmt|;
name|leaps
operator|=
literal|0
expr_stmt|;
name|retv
operator|=
literal|0
expr_stmt|;
comment|/* get day-of-week first */
name|jd
operator|->
name|weekday
operator|=
name|rd
operator|%
literal|7
expr_stmt|;
if|if
condition|(
name|jd
operator|->
name|weekday
operator|>=
literal|7
condition|)
comment|/* unsigned! */
name|jd
operator|->
name|weekday
operator|+=
literal|7
expr_stmt|;
name|split
operator|=
name|ntpcal_split_eradays
argument_list|(
name|rd
operator|-
literal|1
argument_list|,
operator|&
name|leaps
argument_list|)
expr_stmt|;
name|retv
operator|=
name|leaps
expr_stmt|;
comment|/* get year and day-of-year */
name|jd
operator|->
name|year
operator|=
operator|(
name|uint16_t
operator|)
name|split
operator|.
name|hi
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|jd
operator|->
name|year
operator|!=
name|split
operator|.
name|hi
operator|+
literal|1
condition|)
block|{
name|jd
operator|->
name|year
operator|=
literal|0
expr_stmt|;
name|retv
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* bletch. overflow trouble. */
block|}
name|jd
operator|->
name|yearday
operator|=
operator|(
name|uint16_t
operator|)
name|split
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
comment|/* convert to month and mday */
name|split
operator|=
name|ntpcal_split_yeardays
argument_list|(
name|split
operator|.
name|lo
argument_list|,
name|leaps
argument_list|)
expr_stmt|;
name|jd
operator|->
name|month
operator|=
operator|(
name|uint8_t
operator|)
name|split
operator|.
name|hi
operator|+
literal|1
expr_stmt|;
name|jd
operator|->
name|monthday
operator|=
operator|(
name|uint8_t
operator|)
name|split
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
return|return
name|retv
condition|?
name|retv
else|:
name|leaps
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert a RD into the date part of a 'struct tm'.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_rd_to_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|utm
parameter_list|,
name|int32_t
name|rd
parameter_list|)
block|{
name|ntpcal_split
name|split
decl_stmt|;
name|int
name|leaps
decl_stmt|;
name|leaps
operator|=
literal|0
expr_stmt|;
comment|/* get day-of-week first */
name|utm
operator|->
name|tm_wday
operator|=
name|rd
operator|%
literal|7
expr_stmt|;
if|if
condition|(
name|utm
operator|->
name|tm_wday
operator|<
literal|0
condition|)
name|utm
operator|->
name|tm_wday
operator|+=
literal|7
expr_stmt|;
comment|/* get year and day-of-year */
name|split
operator|=
name|ntpcal_split_eradays
argument_list|(
name|rd
operator|-
literal|1
argument_list|,
operator|&
name|leaps
argument_list|)
expr_stmt|;
name|utm
operator|->
name|tm_year
operator|=
name|split
operator|.
name|hi
operator|-
literal|1899
expr_stmt|;
name|utm
operator|->
name|tm_yday
operator|=
name|split
operator|.
name|lo
expr_stmt|;
comment|/* 0-based */
comment|/* convert to month and mday */
name|split
operator|=
name|ntpcal_split_yeardays
argument_list|(
name|split
operator|.
name|lo
argument_list|,
name|leaps
argument_list|)
expr_stmt|;
name|utm
operator|->
name|tm_mon
operator|=
name|split
operator|.
name|hi
expr_stmt|;
comment|/* 0-based */
name|utm
operator|->
name|tm_mday
operator|=
name|split
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
comment|/* 1-based */
return|return
name|leaps
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Take a value of seconds since midnight and split it into hhmmss in a  * 'struct calendar'.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_daysec_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|int32_t
name|sec
parameter_list|)
block|{
name|int32_t
name|days
decl_stmt|;
name|int
name|ts
index|[
literal|3
index|]
decl_stmt|;
name|days
operator|=
name|priv_timesplit
argument_list|(
name|ts
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|jd
operator|->
name|hour
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|jd
operator|->
name|minute
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|jd
operator|->
name|second
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|2
index|]
expr_stmt|;
return|return
name|days
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Take a value of seconds since midnight and split it into hhmmss in a  * 'struct tm'.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_daysec_to_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|utm
parameter_list|,
name|int32_t
name|sec
parameter_list|)
block|{
name|int32_t
name|days
decl_stmt|;
name|int32_t
name|ts
index|[
literal|3
index|]
decl_stmt|;
name|days
operator|=
name|priv_timesplit
argument_list|(
name|ts
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|utm
operator|->
name|tm_hour
operator|=
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|utm
operator|->
name|tm_min
operator|=
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|utm
operator|->
name|tm_sec
operator|=
name|ts
index|[
literal|2
index|]
expr_stmt|;
return|return
name|days
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a split representation for day/second-of-day and day offset  * and convert it to a 'struct calendar'. The seconds will be normalised  * into the range of a day, and the day will be adjusted accordingly.  *  * returns>0 if the result is in a leap year, 0 if in a regular  * year and<0 if the result did not fit into the calendar struct.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_daysplit_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
specifier|const
name|ntpcal_split
modifier|*
name|ds
parameter_list|,
name|int32_t
name|dof
parameter_list|)
block|{
name|dof
operator|+=
name|ntpcal_daysec_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|->
name|lo
argument_list|)
expr_stmt|;
return|return
name|ntpcal_rd_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|->
name|hi
operator|+
name|dof
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a split representation for day/second-of-day and day offset  * and convert it to a 'struct tm'. The seconds will be normalised  * into the range of a day, and the day will be adjusted accordingly.  *  * returns 1 if the result is in a leap year and zero if in a regular  * year.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_daysplit_to_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|utm
parameter_list|,
specifier|const
name|ntpcal_split
modifier|*
name|ds
parameter_list|,
name|int32_t
name|dof
parameter_list|)
block|{
name|dof
operator|+=
name|ntpcal_daysec_to_tm
argument_list|(
name|utm
argument_list|,
name|ds
operator|->
name|lo
argument_list|)
expr_stmt|;
return|return
name|ntpcal_rd_to_tm
argument_list|(
name|utm
argument_list|,
name|ds
operator|->
name|hi
operator|+
name|dof
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Take a UN*X time and convert to a calendar structure.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ntpcal_time_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
specifier|const
name|vint64
modifier|*
name|ts
parameter_list|)
block|{
name|ntpcal_split
name|ds
decl_stmt|;
name|ds
operator|=
name|ntpcal_daysplit
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|ds
operator|.
name|hi
operator|+=
name|ntpcal_daysec_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|.
name|lo
argument_list|)
expr_stmt|;
name|ds
operator|.
name|hi
operator|+=
name|DAY_UNIX_STARTS
expr_stmt|;
return|return
name|ntpcal_rd_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|.
name|hi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==================================================================  *  * merging composite entities  *  * ==================================================================  */
end_comment

begin_comment
comment|/*  *---------------------------------------------------------------------  * Merge a number of days and a number of seconds into seconds,  * expressed in 64 bits to avoid overflow.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|vint64
name|ntpcal_dayjoin
parameter_list|(
name|int32_t
name|days
parameter_list|,
name|int32_t
name|secs
parameter_list|)
block|{
name|vint64
name|res
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_INT64
name|res
operator|.
name|q_s
operator|=
name|days
expr_stmt|;
name|res
operator|.
name|q_s
operator|*=
name|SECSPERDAY
expr_stmt|;
name|res
operator|.
name|q_s
operator|+=
name|secs
expr_stmt|;
else|#
directive|else
name|uint32_t
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|int
name|isneg
decl_stmt|;
comment|/* 	 * res = days *86400 + secs, using manual 16/32 bit 	 * multiplications and shifts. 	 */
name|isneg
operator|=
operator|(
name|days
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
name|days
operator|=
operator|-
name|days
expr_stmt|;
comment|/* assemble days * 675 */
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|days
operator|&
literal|0xFFFF
operator|)
operator|*
literal|675u
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|p1
operator|=
operator|(
name|days
operator|>>
literal|16
operator|)
operator|*
literal|675u
expr_stmt|;
name|p2
operator|=
name|p1
operator|>>
literal|16
expr_stmt|;
name|p1
operator|=
name|p1
operator|<<
literal|16
expr_stmt|;
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
name|p2
argument_list|,
name|p1
argument_list|)
expr_stmt|;
comment|/* mul by 128, using shift */
name|res
operator|.
name|D_s
operator|.
name|hi
operator|=
operator|(
name|res
operator|.
name|D_s
operator|.
name|hi
operator|<<
literal|7
operator|)
operator||
operator|(
name|res
operator|.
name|D_s
operator|.
name|lo
operator|>>
literal|25
operator|)
expr_stmt|;
name|res
operator|.
name|D_s
operator|.
name|lo
operator|=
operator|(
name|res
operator|.
name|D_s
operator|.
name|lo
operator|<<
literal|7
operator|)
expr_stmt|;
comment|/* fix sign */
if|if
condition|(
name|isneg
condition|)
name|M_NEG
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|)
expr_stmt|;
comment|/* properly add seconds */
name|p2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|secs
operator|<
literal|0
condition|)
block|{
name|p1
operator|=
operator|(
name|uint32_t
operator|)
operator|-
name|secs
expr_stmt|;
name|M_NEG
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p1
operator|=
operator|(
name|uint32_t
operator|)
name|secs
expr_stmt|;
block|}
name|M_ADD
argument_list|(
name|res
operator|.
name|D_s
operator|.
name|hi
argument_list|,
name|res
operator|.
name|D_s
operator|.
name|lo
argument_list|,
name|p2
argument_list|,
name|p1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert elapsed years in Era into elapsed days in Era.  *  * To accomodate for negative values of years, floor division would be  * required for all division operations. This can be eased by first  * splitting the years into full 400-year cycles and years in the  * cycle. Only this operation must be coded as a full floor division; as  * the years in the cycle is a non-negative number, all other divisions  * can be regular truncated divisions.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_days_in_years
parameter_list|(
name|int32_t
name|years
parameter_list|)
block|{
name|int32_t
name|cycle
decl_stmt|;
comment|/* full gregorian cycle */
comment|/* split off full calendar cycles, using floor division */
name|cycle
operator|=
name|years
operator|/
literal|400
expr_stmt|;
name|years
operator|=
name|years
operator|%
literal|400
expr_stmt|;
if|if
condition|(
name|years
operator|<
literal|0
condition|)
block|{
name|cycle
operator|-=
literal|1
expr_stmt|;
name|years
operator|+=
literal|400
expr_stmt|;
block|}
comment|/* 	 * Calculate days in cycle. years now is a non-negative number, 	 * holding the number of years in the 400-year cycle. 	 */
return|return
name|cycle
operator|*
name|GREGORIAN_CYCLE_DAYS
operator|+
name|years
operator|*
name|DAYSPERYEAR
comment|/* days inregular years	*/
operator|+
name|years
operator|/
literal|4
comment|/* 4 year leap rule	*/
operator|-
name|years
operator|/
literal|100
return|;
comment|/* 100 year leap rule	*/
comment|/* the 400-year rule does not apply due to full-cycle split-off */
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert a number of elapsed month in a year into elapsed days in year.  *  * The month will be normalized, and 'res.hi' will contain the  * excessive years that must be considered when converting the years,  * while 'res.lo' will contain the number of elapsed days since start  * of the year.  *  * This code uses the shifted-month-approach to convert month to days,  * because then there is no need to have explicit leap year  * information.	 The slight disadvantage is that for most month values  * the result is a negative value, and the year excess is one; the  * conversion is then simply based on the start of the following year.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|ntpcal_split
name|ntpcal_days_in_months
parameter_list|(
name|int32_t
name|m
parameter_list|)
block|{
name|ntpcal_split
name|res
decl_stmt|;
comment|/* normalize month into range */
name|res
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|lo
operator|<
literal|0
operator|||
name|res
operator|.
name|lo
operator|>=
literal|12
condition|)
block|{
name|res
operator|.
name|hi
operator|=
name|res
operator|.
name|lo
operator|/
literal|12
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|res
operator|.
name|lo
operator|%
literal|12
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|lo
operator|<
literal|0
condition|)
block|{
name|res
operator|.
name|hi
operator|-=
literal|1
expr_stmt|;
name|res
operator|.
name|lo
operator|+=
literal|12
expr_stmt|;
block|}
block|}
comment|/* add 10 month for year starting with march */
if|if
condition|(
name|res
operator|.
name|lo
operator|<
literal|2
condition|)
name|res
operator|.
name|lo
operator|+=
literal|10
expr_stmt|;
else|else
block|{
name|res
operator|.
name|hi
operator|+=
literal|1
expr_stmt|;
name|res
operator|.
name|lo
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* get cummulated days in year with unshift */
name|res
operator|.
name|lo
operator|=
name|shift_month_table
index|[
name|res
operator|.
name|lo
index|]
operator|-
literal|306
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert ELAPSED years/months/days of gregorian calendar to elapsed  * days in Gregorian epoch.  *  * If you want to convert years and days-of-year, just give a month of  * zero.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_edate_to_eradays
parameter_list|(
name|int32_t
name|years
parameter_list|,
name|int32_t
name|mons
parameter_list|,
name|int32_t
name|mdays
parameter_list|)
block|{
name|ntpcal_split
name|tmp
decl_stmt|;
name|int32_t
name|res
decl_stmt|;
if|if
condition|(
name|mons
condition|)
block|{
name|tmp
operator|=
name|ntpcal_days_in_months
argument_list|(
name|mons
argument_list|)
expr_stmt|;
name|res
operator|=
name|ntpcal_days_in_years
argument_list|(
name|years
operator|+
name|tmp
operator|.
name|hi
argument_list|)
operator|+
name|tmp
operator|.
name|lo
expr_stmt|;
block|}
else|else
name|res
operator|=
name|ntpcal_days_in_years
argument_list|(
name|years
argument_list|)
expr_stmt|;
name|res
operator|+=
name|mdays
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert ELAPSED years/months/days of gregorian calendar to elapsed  * days in year.  *  * Note: This will give the true difference to the start of the given year,  * even if months& days are off-scale.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_edate_to_yeardays
parameter_list|(
name|int32_t
name|years
parameter_list|,
name|int32_t
name|mons
parameter_list|,
name|int32_t
name|mdays
parameter_list|)
block|{
name|ntpcal_split
name|tmp
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|mons
operator|&&
name|mons
operator|<
literal|12
condition|)
block|{
name|years
operator|+=
literal|1
expr_stmt|;
name|mdays
operator|+=
name|real_month_table
index|[
name|is_leapyear
argument_list|(
name|years
argument_list|)
index|]
index|[
name|mons
index|]
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|ntpcal_days_in_months
argument_list|(
name|mons
argument_list|)
expr_stmt|;
name|mdays
operator|+=
name|tmp
operator|.
name|lo
operator|+
name|ntpcal_days_in_years
argument_list|(
name|years
operator|+
name|tmp
operator|.
name|hi
argument_list|)
operator|-
name|ntpcal_days_in_years
argument_list|(
name|years
argument_list|)
expr_stmt|;
block|}
return|return
name|mdays
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert elapsed days and the hour/minute/second information into  * total seconds.  *  * If 'isvalid' is not NULL, do a range check on the time specification  * and tell if the time input is in the normal range, permitting for a  * single leapsecond.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_etime_to_seconds
parameter_list|(
name|int32_t
name|hours
parameter_list|,
name|int32_t
name|minutes
parameter_list|,
name|int32_t
name|seconds
parameter_list|)
block|{
name|int32_t
name|res
decl_stmt|;
name|res
operator|=
operator|(
name|hours
operator|*
name|MINSPERHR
operator|+
name|minutes
operator|)
operator|*
name|SECSPERMIN
operator|+
name|seconds
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert the date part of a 'struct tm' (that is, year, month,  * day-of-month) into the RD of that day.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_tm_to_rd
parameter_list|(
specifier|const
name|struct
name|tm
modifier|*
name|utm
parameter_list|)
block|{
return|return
name|ntpcal_edate_to_eradays
argument_list|(
name|utm
operator|->
name|tm_year
operator|+
literal|1899
argument_list|,
name|utm
operator|->
name|tm_mon
argument_list|,
name|utm
operator|->
name|tm_mday
operator|-
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * Convert the date part of a 'struct calendar' (that is, year, month,  * day-of-month) into the RD of that day.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_date_to_rd
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
return|return
name|ntpcal_edate_to_eradays
argument_list|(
operator|(
name|int32_t
operator|)
name|jd
operator|->
name|year
operator|-
literal|1
argument_list|,
operator|(
name|int32_t
operator|)
name|jd
operator|->
name|month
operator|-
literal|1
argument_list|,
operator|(
name|int32_t
operator|)
name|jd
operator|->
name|monthday
operator|-
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * convert a year number to rata die of year start  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_year_to_ystart
parameter_list|(
name|int32_t
name|year
parameter_list|)
block|{
return|return
name|ntpcal_days_in_years
argument_list|(
name|year
operator|-
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * For a given RD, get the RD of the associated year start,  * that is, the RD of the last January,1st on or before that day.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_rd_to_ystart
parameter_list|(
name|int32_t
name|rd
parameter_list|)
block|{
comment|/* 	 * Rather simple exercise: split the day number into elapsed 	 * years and elapsed days, then remove the elapsed days from the 	 * input value. Nice'n sweet... 	 */
return|return
name|rd
operator|-
name|ntpcal_split_eradays
argument_list|(
name|rd
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
operator|.
name|lo
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * For a given RD, get the RD of the associated month start.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_rd_to_mstart
parameter_list|(
name|int32_t
name|rd
parameter_list|)
block|{
name|ntpcal_split
name|split
decl_stmt|;
name|int
name|leaps
decl_stmt|;
name|split
operator|=
name|ntpcal_split_eradays
argument_list|(
name|rd
operator|-
literal|1
argument_list|,
operator|&
name|leaps
argument_list|)
expr_stmt|;
name|split
operator|=
name|ntpcal_split_yeardays
argument_list|(
name|split
operator|.
name|lo
argument_list|,
name|leaps
argument_list|)
expr_stmt|;
return|return
name|rd
operator|-
name|split
operator|.
name|lo
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a 'struct calendar' and get the seconds-of-day from it.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_date_to_daysec
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
return|return
name|ntpcal_etime_to_seconds
argument_list|(
name|jd
operator|->
name|hour
argument_list|,
name|jd
operator|->
name|minute
argument_list|,
name|jd
operator|->
name|second
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a 'struct tm' and get the seconds-of-day from it.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int32_t
name|ntpcal_tm_to_daysec
parameter_list|(
specifier|const
name|struct
name|tm
modifier|*
name|utm
parameter_list|)
block|{
return|return
name|ntpcal_etime_to_seconds
argument_list|(
name|utm
operator|->
name|tm_hour
argument_list|,
name|utm
operator|->
name|tm_min
argument_list|,
name|utm
operator|->
name|tm_sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------------------  * take a 'struct calendar' and convert it to a 'time_t'  *---------------------------------------------------------------------  */
end_comment

begin_function
name|time_t
name|ntpcal_date_to_time
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
name|vint64
name|join
decl_stmt|;
name|int32_t
name|days
decl_stmt|,
name|secs
decl_stmt|;
name|days
operator|=
name|ntpcal_date_to_rd
argument_list|(
name|jd
argument_list|)
operator|-
name|DAY_UNIX_STARTS
expr_stmt|;
name|secs
operator|=
name|ntpcal_date_to_daysec
argument_list|(
name|jd
argument_list|)
expr_stmt|;
name|join
operator|=
name|ntpcal_dayjoin
argument_list|(
name|days
argument_list|,
name|secs
argument_list|)
expr_stmt|;
return|return
name|vint64_to_time
argument_list|(
operator|&
name|join
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==================================================================  *  * extended and unchecked variants of caljulian/caltontp  *  * ==================================================================  */
end_comment

begin_function
name|int
name|ntpcal_ntp64_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
specifier|const
name|vint64
modifier|*
name|ntp
parameter_list|)
block|{
name|ntpcal_split
name|ds
decl_stmt|;
name|ds
operator|=
name|ntpcal_daysplit
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
name|ds
operator|.
name|hi
operator|+=
name|ntpcal_daysec_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|.
name|lo
argument_list|)
expr_stmt|;
return|return
name|ntpcal_rd_to_date
argument_list|(
name|jd
argument_list|,
name|ds
operator|.
name|hi
operator|+
name|DAY_NTP_STARTS
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ntpcal_ntp_to_date
parameter_list|(
name|struct
name|calendar
modifier|*
name|jd
parameter_list|,
name|uint32_t
name|ntp
parameter_list|,
specifier|const
name|time_t
modifier|*
name|piv
parameter_list|)
block|{
name|vint64
name|ntp64
decl_stmt|;
comment|/* 	 * Unfold ntp time around current time into NTP domain. Split 	 * into days and seconds, shift days into CE domain and 	 * process the parts. 	 */
name|ntp64
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|ntp
argument_list|,
name|piv
argument_list|)
expr_stmt|;
return|return
name|ntpcal_ntp64_to_date
argument_list|(
name|jd
argument_list|,
operator|&
name|ntp64
argument_list|)
return|;
block|}
end_function

begin_function
name|vint64
name|ntpcal_date_to_ntp64
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
comment|/* 	 * Convert date to NTP. Ignore yearday, use d/m/y only. 	 */
return|return
name|ntpcal_dayjoin
argument_list|(
name|ntpcal_date_to_rd
argument_list|(
name|jd
argument_list|)
operator|-
name|DAY_NTP_STARTS
argument_list|,
name|ntpcal_date_to_daysec
argument_list|(
name|jd
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|ntpcal_date_to_ntp
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|jd
parameter_list|)
block|{
comment|/* 	 * Get lower half of 64-bit NTP timestamp from date/time. 	 */
return|return
name|ntpcal_date_to_ntp64
argument_list|(
name|jd
argument_list|)
operator|.
name|d_s
operator|.
name|lo
return|;
block|}
end_function

begin_comment
comment|/*  * ==================================================================  *  * day-of-week calculations  *  * ==================================================================  */
end_comment

begin_comment
comment|/*  * Given a RataDie and a day-of-week, calculate a RDN that is reater-than,  * greater-or equal, closest, less-or-equal or less-than the given RDN  * and denotes the given day-of-week  */
end_comment

begin_function
name|int32_t
name|ntpcal_weekday_gt
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
operator|+
literal|1
argument_list|,
name|dow
argument_list|,
literal|7
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|ntpcal_weekday_ge
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
argument_list|,
name|dow
argument_list|,
literal|7
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|ntpcal_weekday_close
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
operator|-
literal|3
argument_list|,
name|dow
argument_list|,
literal|7
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|ntpcal_weekday_le
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
argument_list|,
name|dow
argument_list|,
operator|-
literal|7
argument_list|)
return|;
block|}
end_function

begin_function
name|int32_t
name|ntpcal_weekday_lt
parameter_list|(
name|int32_t
name|rdn
parameter_list|,
name|int32_t
name|dow
parameter_list|)
block|{
return|return
name|ntpcal_periodic_extend
argument_list|(
name|rdn
operator|-
literal|1
argument_list|,
name|dow
argument_list|,
operator|-
literal|7
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==================================================================  *  * ISO week-calendar conversions  *  * The ISO8601 calendar defines a calendar of years, weeks and weekdays.  * It is related to the Gregorian calendar, and a ISO year starts at the  * Monday closest to Jan,1st of the corresponding Gregorian year.  A ISO  * calendar year has always 52 or 53 weeks, and like the Grogrian  * calendar the ISO8601 calendar repeats itself every 400 years, or  * 146097 days, or 20871 weeks.  *  * While it is possible to write ISO calendar functions based on the  * Gregorian calendar functions, the following implementation takes a  * different approach, based directly on years and weeks.  *  * Analysis of the tabulated data shows that it is not possible to  * interpolate from years to weeks over a full 400 year range; cyclic  * shifts over 400 years do not provide a solution here. But it *is*  * possible to interpolate over every single century of the 400-year  * cycle. (The centennial leap year rule seems to be the culprit here.)  *  * It can be shown that a conversion from years to weeks can be done  * using a linear transformation of the form  *  *   w = floor( y * a + b )  *  * where the slope a must hold to  *  *  52.1780821918<= a< 52.1791044776  *  * and b must be chosen according to the selected slope and the number  * of the century in a 400-year period.  *  * The inverse calculation can also be done in this way. Careful scaling  * provides an unlimited set of integer coefficients a,k,b that enable  * us to write the calulation in the form  *  *   w = (y * a	 + b ) / k  *   y = (w * a' + b') / k'  *  * In this implementation the values of k and k' are chosen to be  * smallest possible powers of two, so the division can be implemented  * as shifts if the optimiser chooses to do so.  *  * ==================================================================  */
end_comment

begin_comment
comment|/*  * Given a number of elapsed (ISO-)years since the begin of the  * christian era, return the number of elapsed weeks corresponding to  * the number of years.  */
end_comment

begin_function
name|int32_t
name|isocal_weeks_in_years
parameter_list|(
name|int32_t
name|years
parameter_list|)
block|{
comment|/* 	 * use: w = (y * 53431 + b[c]) / 1024 as interpolation 	 */
specifier|static
specifier|const
name|int32_t
name|bctab
index|[
literal|4
index|]
init|=
block|{
literal|449
block|,
literal|157
block|,
literal|889
block|,
literal|597
block|}
decl_stmt|;
name|int32_t
name|cycle
decl_stmt|;
comment|/* full gregorian cycle */
name|int32_t
name|cents
decl_stmt|;
comment|/* full centuries	   */
name|int32_t
name|weeks
decl_stmt|;
comment|/* accumulated weeks	   */
comment|/* split off full calendar cycles, using floor division */
name|cycle
operator|=
name|years
operator|/
literal|400
expr_stmt|;
name|years
operator|=
name|years
operator|%
literal|400
expr_stmt|;
if|if
condition|(
name|years
operator|<
literal|0
condition|)
block|{
name|cycle
operator|-=
literal|1
expr_stmt|;
name|years
operator|+=
literal|400
expr_stmt|;
block|}
comment|/* split off full centuries */
name|cents
operator|=
name|years
operator|/
literal|100
expr_stmt|;
name|years
operator|=
name|years
operator|%
literal|100
expr_stmt|;
comment|/* 	 * calculate elapsed weeks, taking into account that the 	 * first, third and fourth century have 5218 weeks but the 	 * second century falls short by one week. 	 */
name|weeks
operator|=
operator|(
name|years
operator|*
literal|53431
operator|+
name|bctab
index|[
name|cents
index|]
operator|)
operator|/
literal|1024
expr_stmt|;
return|return
name|cycle
operator|*
name|GREGORIAN_CYCLE_WEEKS
operator|+
name|cents
operator|*
literal|5218
operator|-
operator|(
name|cents
operator|>
literal|1
operator|)
operator|+
name|weeks
return|;
block|}
end_function

begin_comment
comment|/*  * Given a number of elapsed weeks since the begin of the christian  * era, split this number into the number of elapsed years in res.hi  * and the excessive number of weeks in res.lo. (That is, res.lo is  * the number of elapsed weeks in the remaining partial year.)  */
end_comment

begin_function
name|ntpcal_split
name|isocal_split_eraweeks
parameter_list|(
name|int32_t
name|weeks
parameter_list|)
block|{
comment|/* 	 * use: y = (w * 157 + b[c]) / 8192 as interpolation 	 */
specifier|static
specifier|const
name|int32_t
name|bctab
index|[
literal|4
index|]
init|=
block|{
literal|85
block|,
literal|131
block|,
literal|17
block|,
literal|62
block|}
decl_stmt|;
name|ntpcal_split
name|res
decl_stmt|;
name|int32_t
name|cents
decl_stmt|;
comment|/* 	 * split off 400-year cycles, using the fact that a 400-year 	 * cycle has 146097 days, which is exactly 20871 weeks. 	 */
name|res
operator|.
name|hi
operator|=
name|weeks
operator|/
name|GREGORIAN_CYCLE_WEEKS
expr_stmt|;
name|res
operator|.
name|lo
operator|=
name|weeks
operator|%
name|GREGORIAN_CYCLE_WEEKS
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|lo
operator|<
literal|0
condition|)
block|{
name|res
operator|.
name|hi
operator|-=
literal|1
expr_stmt|;
name|res
operator|.
name|lo
operator|+=
name|GREGORIAN_CYCLE_WEEKS
expr_stmt|;
block|}
name|res
operator|.
name|hi
operator|*=
literal|400
expr_stmt|;
comment|/* 	 * split off centuries, taking into account that the first, 	 * third and fourth century have 5218 weeks but that the 	 * second century falls short by one week. 	 */
name|res
operator|.
name|lo
operator|+=
operator|(
name|res
operator|.
name|lo
operator|>=
literal|10435
operator|)
expr_stmt|;
name|cents
operator|=
name|res
operator|.
name|lo
operator|/
literal|5218
expr_stmt|;
name|res
operator|.
name|lo
operator|%=
literal|5218
expr_stmt|;
comment|/* res.lo is weeks in century now */
comment|/* convert elapsed weeks in century to elapsed years and weeks */
name|res
operator|.
name|lo
operator|=
name|res
operator|.
name|lo
operator|*
literal|157
operator|+
name|bctab
index|[
name|cents
index|]
expr_stmt|;
name|res
operator|.
name|hi
operator|+=
name|cents
operator|*
literal|100
operator|+
name|res
operator|.
name|lo
operator|/
literal|8192
expr_stmt|;
name|res
operator|.
name|lo
operator|=
operator|(
name|res
operator|.
name|lo
operator|%
literal|8192
operator|)
operator|/
literal|157
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Given a second in the NTP time scale and a pivot, expand the NTP  * time stamp around the pivot and convert into an ISO calendar time  * stamp.  */
end_comment

begin_function
name|int
name|isocal_ntp64_to_date
parameter_list|(
name|struct
name|isodate
modifier|*
name|id
parameter_list|,
specifier|const
name|vint64
modifier|*
name|ntp
parameter_list|)
block|{
name|ntpcal_split
name|ds
decl_stmt|;
name|int32_t
name|ts
index|[
literal|3
index|]
decl_stmt|;
comment|/* 	 * Split NTP time into days and seconds, shift days into CE 	 * domain and process the parts. 	 */
name|ds
operator|=
name|ntpcal_daysplit
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
comment|/* split time part */
name|ds
operator|.
name|hi
operator|+=
name|priv_timesplit
argument_list|(
name|ts
argument_list|,
name|ds
operator|.
name|lo
argument_list|)
expr_stmt|;
name|id
operator|->
name|hour
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|0
index|]
expr_stmt|;
name|id
operator|->
name|minute
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|1
index|]
expr_stmt|;
name|id
operator|->
name|second
operator|=
operator|(
name|uint8_t
operator|)
name|ts
index|[
literal|2
index|]
expr_stmt|;
comment|/* split date part */
name|ds
operator|.
name|lo
operator|=
name|ds
operator|.
name|hi
operator|+
name|DAY_NTP_STARTS
operator|-
literal|1
expr_stmt|;
comment|/* elapsed era days  */
name|ds
operator|.
name|hi
operator|=
name|ds
operator|.
name|lo
operator|/
literal|7
expr_stmt|;
comment|/* elapsed era weeks */
name|ds
operator|.
name|lo
operator|=
name|ds
operator|.
name|lo
operator|%
literal|7
expr_stmt|;
comment|/* elapsed week days */
if|if
condition|(
name|ds
operator|.
name|lo
operator|<
literal|0
condition|)
block|{
comment|/* floor division!   */
name|ds
operator|.
name|hi
operator|-=
literal|1
expr_stmt|;
name|ds
operator|.
name|lo
operator|+=
literal|7
expr_stmt|;
block|}
name|id
operator|->
name|weekday
operator|=
operator|(
name|uint8_t
operator|)
name|ds
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
comment|/* weekday result    */
name|ds
operator|=
name|isocal_split_eraweeks
argument_list|(
name|ds
operator|.
name|hi
argument_list|)
expr_stmt|;
comment|/* elapsed years&week*/
name|id
operator|->
name|year
operator|=
operator|(
name|uint16_t
operator|)
name|ds
operator|.
name|hi
operator|+
literal|1
expr_stmt|;
comment|/* shift to current  */
name|id
operator|->
name|week
operator|=
operator|(
name|uint8_t
operator|)
name|ds
operator|.
name|lo
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|ds
operator|.
name|hi
operator|>=
literal|0
operator|&&
name|ds
operator|.
name|hi
operator|<
literal|0x0000FFFF
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isocal_ntp_to_date
parameter_list|(
name|struct
name|isodate
modifier|*
name|id
parameter_list|,
name|uint32_t
name|ntp
parameter_list|,
specifier|const
name|time_t
modifier|*
name|piv
parameter_list|)
block|{
name|vint64
name|ntp64
decl_stmt|;
comment|/* 	 * Unfold ntp time around current time into NTP domain, then 	 * convert the full time stamp. 	 */
name|ntp64
operator|=
name|ntpcal_ntp_to_ntp
argument_list|(
name|ntp
argument_list|,
name|piv
argument_list|)
expr_stmt|;
return|return
name|isocal_ntp64_to_date
argument_list|(
name|id
argument_list|,
operator|&
name|ntp64
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a ISO date spec into a second in the NTP time scale,  * properly truncated to 32 bit.  */
end_comment

begin_function
name|vint64
name|isocal_date_to_ntp64
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|id
parameter_list|)
block|{
name|int32_t
name|weeks
decl_stmt|,
name|days
decl_stmt|,
name|secs
decl_stmt|;
name|weeks
operator|=
name|isocal_weeks_in_years
argument_list|(
operator|(
name|int32_t
operator|)
name|id
operator|->
name|year
operator|-
literal|1
argument_list|)
operator|+
operator|(
name|int32_t
operator|)
name|id
operator|->
name|week
operator|-
literal|1
expr_stmt|;
name|days
operator|=
name|weeks
operator|*
literal|7
operator|+
operator|(
name|int32_t
operator|)
name|id
operator|->
name|weekday
expr_stmt|;
comment|/* days is RDN of ISO date now */
name|secs
operator|=
name|ntpcal_etime_to_seconds
argument_list|(
name|id
operator|->
name|hour
argument_list|,
name|id
operator|->
name|minute
argument_list|,
name|id
operator|->
name|second
argument_list|)
expr_stmt|;
return|return
name|ntpcal_dayjoin
argument_list|(
name|days
operator|-
name|DAY_NTP_STARTS
argument_list|,
name|secs
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|isocal_date_to_ntp
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|id
parameter_list|)
block|{
comment|/* 	 * Get lower half of 64-bit NTP timestamp from date/time. 	 */
return|return
name|isocal_date_to_ntp64
argument_list|(
name|id
argument_list|)
operator|.
name|d_s
operator|.
name|lo
return|;
block|}
end_function

begin_comment
comment|/* -*-EOF-*- */
end_comment

end_unit

