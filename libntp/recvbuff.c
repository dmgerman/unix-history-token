begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lists.h"
end_include

begin_include
include|#
directive|include
file|"recvbuff.h"
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|uninit_recvbuff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Memory allocation  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|full_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of recvbufs on fulllist */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|free_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of recvbufs on freelist */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|total_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total recvbufs currently in use */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|lowater_adds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times we have added memory */
end_comment

begin_decl_stmt
specifier|static
name|u_long
specifier|volatile
name|buffer_shortfall
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of missed free receive buffers 					   between replenishments */
end_comment

begin_expr_stmt
specifier|static
name|ISC_LIST
argument_list|(
argument|recvbuf_t
argument_list|)
name|full_recv_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Currently used recv buffers */
end_comment

begin_decl_stmt
specifier|static
name|recvbuf_t
modifier|*
name|free_recv_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently unused buffers */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_if

begin_comment
comment|/*  * For Windows we need to set up a lock to manipulate the  * recv buffers to prevent corruption. We keep it lock for as  * short a time as possible  */
end_comment

begin_decl_stmt
specifier|static
name|CRITICAL_SECTION
name|RecvLock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOCK
parameter_list|()
value|EnterCriticalSection(&RecvLock)
end_define

begin_define
define|#
directive|define
name|UNLOCK
parameter_list|()
value|LeaveCriticalSection(&RecvLock)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOCK
parameter_list|()
end_define

begin_define
define|#
directive|define
name|UNLOCK
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|u_long
name|free_recvbuffs
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|free_recvbufs
return|;
block|}
end_function

begin_function
name|u_long
name|full_recvbuffs
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|full_recvbufs
return|;
block|}
end_function

begin_function
name|u_long
name|total_recvbuffs
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|total_recvbufs
return|;
block|}
end_function

begin_function
name|u_long
name|lowater_additions
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|lowater_adds
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|initialise_buffer
parameter_list|(
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
name|memset
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_buffers
parameter_list|(
name|int
name|nbufs
parameter_list|)
block|{
specifier|register
name|recvbuf_t
modifier|*
name|bufp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|abuf
decl_stmt|;
name|abuf
operator|=
name|nbufs
operator|+
name|buffer_shortfall
expr_stmt|;
name|buffer_shortfall
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|bufp
operator|=
name|emalloc
argument_list|(
name|abuf
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bufp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abuf
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 		 * Allocate each buffer individually so they can be 		 * free()d during ntpd shutdown on DEBUG builds to 		 * keep them out of heap leak reports. 		 */
name|bufp
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bufp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|bufp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bufp
argument_list|)
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|free_recv_list
argument_list|,
name|bufp
argument_list|,
name|link
operator|.
name|next
argument_list|)
expr_stmt|;
name|bufp
operator|++
expr_stmt|;
name|free_recvbufs
operator|++
expr_stmt|;
name|total_recvbufs
operator|++
expr_stmt|;
block|}
name|lowater_adds
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_recvbuff
parameter_list|(
name|int
name|nbufs
parameter_list|)
block|{
comment|/* 	 * Init buffer free list and stat counters 	 */
name|ISC_LIST_INIT
argument_list|(
name|full_recv_list
argument_list|)
expr_stmt|;
name|free_recvbufs
operator|=
name|total_recvbufs
operator|=
literal|0
expr_stmt|;
name|full_recvbufs
operator|=
name|lowater_adds
operator|=
literal|0
expr_stmt|;
name|create_buffers
argument_list|(
name|nbufs
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
name|InitializeCriticalSection
argument_list|(
operator|&
name|RecvLock
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
operator|&
name|uninit_recvbuff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|uninit_recvbuff
parameter_list|(
name|void
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|rbunlinked
decl_stmt|;
while|while
condition|(
operator|(
name|rbunlinked
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|full_recv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE_TYPE
argument_list|(
name|full_recv_list
argument_list|,
name|rbunlinked
argument_list|,
name|link
argument_list|,
name|recvbuf_t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rbunlinked
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|UNLINK_HEAD_SLIST
argument_list|(
name|rbunlinked
argument_list|,
name|free_recv_list
argument_list|,
name|link
operator|.
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbunlinked
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rbunlinked
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rbunlinked
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * freerecvbuf - make a single recvbuf available for reuse  */
end_comment

begin_function
name|void
name|freerecvbuf
parameter_list|(
name|recvbuf_t
modifier|*
name|rb
parameter_list|)
block|{
if|if
condition|(
name|rb
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"freerecvbuff received NULL buffer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOCK
argument_list|()
expr_stmt|;
operator|(
name|rb
operator|->
name|used
operator|)
operator|--
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|used
operator|!=
literal|0
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"******** freerecvbuff non-zero usage: %d *******"
argument_list|,
name|rb
operator|->
name|used
argument_list|)
expr_stmt|;
name|LINK_SLIST
argument_list|(
name|free_recv_list
argument_list|,
name|rb
argument_list|,
name|link
operator|.
name|next
argument_list|)
expr_stmt|;
name|free_recvbufs
operator|++
expr_stmt|;
name|UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_full_recv_buffer
parameter_list|(
name|recvbuf_t
modifier|*
name|rb
parameter_list|)
block|{
if|if
condition|(
name|rb
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"add_full_recv_buffer received NULL buffer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOCK
argument_list|()
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|full_recv_list
argument_list|,
name|rb
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|full_recvbufs
operator|++
expr_stmt|;
name|UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|recvbuf_t
modifier|*
name|get_free_recv_buffer
parameter_list|(
name|void
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|buffer
decl_stmt|;
name|LOCK
argument_list|()
expr_stmt|;
name|UNLINK_HEAD_SLIST
argument_list|(
name|buffer
argument_list|,
name|free_recv_list
argument_list|,
name|link
operator|.
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|free_recvbufs
operator|--
expr_stmt|;
name|initialise_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|(
name|buffer
operator|->
name|used
operator|)
operator|++
expr_stmt|;
block|}
else|else
name|buffer_shortfall
operator|++
expr_stmt|;
name|UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IO_COMPLETION_PORT
end_ifdef

begin_function
name|recvbuf_t
modifier|*
name|get_free_recv_buffer_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buffer
condition|)
block|{
name|create_buffers
argument_list|(
name|RECV_INC
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
block|}
name|NTP_ENSURE
argument_list|(
name|buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|recvbuf_t
modifier|*
name|get_full_recv_buffer
parameter_list|(
name|void
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|rbuf
decl_stmt|;
name|LOCK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
comment|/* 	 * make sure there are free buffers when we 	 * wander off to do lengthy packet processing with 	 * any buffer we grab from the full list. 	 *  	 * fixes malloc() interrupted by SIGIO risk 	 * (Bug 889) 	 */
if|if
condition|(
name|NULL
operator|==
name|free_recv_list
operator|||
name|buffer_shortfall
operator|>
literal|0
condition|)
block|{
comment|/* 		 * try to get us some more buffers 		 */
name|create_buffers
argument_list|(
name|RECV_INC
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * try to grab a full buffer 	 */
name|rbuf
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|full_recv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbuf
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE_TYPE
argument_list|(
name|full_recv_list
argument_list|,
name|rbuf
argument_list|,
name|link
argument_list|,
name|recvbuf_t
argument_list|)
expr_stmt|;
operator|--
name|full_recvbufs
expr_stmt|;
block|}
else|else
comment|/* 		 * Make sure we reset the full count to 0 		 */
name|full_recvbufs
operator|=
literal|0
expr_stmt|;
name|UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|rbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks to see if there are buffers to process  */
end_comment

begin_function
name|isc_boolean_t
name|has_full_recv_buffer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ISC_LIST_HEAD
argument_list|(
name|full_recv_list
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
else|else
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

end_unit

