begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * pcap-dag.c: Packet capture interface for Emulex EndaceDAG cards.  *  * The functionality of this code attempts to mimic that of pcap-linux as much  * as possible.  This code is compiled in several different ways depending on  * whether DAG_ONLY and HAVE_DAG_API are defined.  If HAVE_DAG_API is not  * defined it should not get compiled in, otherwise if DAG_ONLY is defined then  * the 'dag_' function calls are renamed to 'pcap_' equivalents.  If DAG_ONLY  * is not defined then nothing is altered - the dag_ functions will be  * called as required from their pcap-linux/bpf equivalents.  *  * Authors: Richard Littin, Sean Irvine ({richard,sean}@reeltwo.com)  * Modifications: Jesper Peterson  *                Koryn Grant  *                Stephen Donnelly<stephen.donnelly@emulex.com>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* optionally get BSD define */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_struct_decl
struct_decl|struct
name|mbuf
struct_decl|;
end_struct_decl

begin_comment
comment|/* Squelch compiler warnings on some platforms for */
end_comment

begin_struct_decl
struct_decl|struct
name|rtentry
struct_decl|;
end_struct_decl

begin_comment
comment|/* declarations in<net/if.h> */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|"dagnew.h"
end_include

begin_include
include|#
directive|include
file|"dagapi.h"
end_include

begin_include
include|#
directive|include
file|"dagpci.h"
end_include

begin_include
include|#
directive|include
file|"pcap-dag.h"
end_include

begin_comment
comment|/*  * DAG devices have names beginning with "dag", followed by a number  * from 0 to DAG_MAX_BOARDS, then optionally a colon and a stream number  * from 0 to DAG_STREAM_MAX.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DAG_MAX_BOARDS
end_ifndef

begin_define
define|#
directive|define
name|DAG_MAX_BOARDS
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_AAL5
end_ifndef

begin_define
define|#
directive|define
name|TYPE_AAL5
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_MC_HDLC
end_ifndef

begin_define
define|#
directive|define
name|TYPE_MC_HDLC
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_MC_RAW
end_ifndef

begin_define
define|#
directive|define
name|TYPE_MC_RAW
value|6
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_MC_ATM
end_ifndef

begin_define
define|#
directive|define
name|TYPE_MC_ATM
value|7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_MC_RAW_CHANNEL
end_ifndef

begin_define
define|#
directive|define
name|TYPE_MC_RAW_CHANNEL
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_MC_AAL5
end_ifndef

begin_define
define|#
directive|define
name|TYPE_MC_AAL5
value|9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_COLOR_HDLC_POS
end_ifndef

begin_define
define|#
directive|define
name|TYPE_COLOR_HDLC_POS
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_COLOR_ETH
end_ifndef

begin_define
define|#
directive|define
name|TYPE_COLOR_ETH
value|11
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_MC_AAL2
end_ifndef

begin_define
define|#
directive|define
name|TYPE_MC_AAL2
value|12
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_IP_COUNTER
end_ifndef

begin_define
define|#
directive|define
name|TYPE_IP_COUNTER
value|13
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_TCP_FLOW_COUNTER
end_ifndef

begin_define
define|#
directive|define
name|TYPE_TCP_FLOW_COUNTER
value|14
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_DSM_COLOR_HDLC_POS
end_ifndef

begin_define
define|#
directive|define
name|TYPE_DSM_COLOR_HDLC_POS
value|15
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_DSM_COLOR_ETH
end_ifndef

begin_define
define|#
directive|define
name|TYPE_DSM_COLOR_ETH
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_COLOR_MC_HDLC_POS
end_ifndef

begin_define
define|#
directive|define
name|TYPE_COLOR_MC_HDLC_POS
value|17
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_AAL2
end_ifndef

begin_define
define|#
directive|define
name|TYPE_AAL2
value|18
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_COLOR_HASH_POS
end_ifndef

begin_define
define|#
directive|define
name|TYPE_COLOR_HASH_POS
value|19
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_COLOR_HASH_ETH
end_ifndef

begin_define
define|#
directive|define
name|TYPE_COLOR_HASH_ETH
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_INFINIBAND
end_ifndef

begin_define
define|#
directive|define
name|TYPE_INFINIBAND
value|21
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_IPV4
end_ifndef

begin_define
define|#
directive|define
name|TYPE_IPV4
value|22
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_IPV6
end_ifndef

begin_define
define|#
directive|define
name|TYPE_IPV6
value|23
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_RAW_LINK
end_ifndef

begin_define
define|#
directive|define
name|TYPE_RAW_LINK
value|24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_INFINIBAND_LINK
end_ifndef

begin_define
define|#
directive|define
name|TYPE_INFINIBAND_LINK
value|25
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TYPE_PAD
end_ifndef

begin_define
define|#
directive|define
name|TYPE_PAD
value|48
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ATM_CELL_SIZE
value|52
end_define

begin_define
define|#
directive|define
name|ATM_HDR_SIZE
value|4
end_define

begin_comment
comment|/*  * A header containing additional MTP information.  */
end_comment

begin_define
define|#
directive|define
name|MTP2_SENT_OFFSET
value|0
end_define

begin_comment
comment|/* 1 byte */
end_comment

begin_define
define|#
directive|define
name|MTP2_ANNEX_A_USED_OFFSET
value|1
end_define

begin_comment
comment|/* 1 byte */
end_comment

begin_define
define|#
directive|define
name|MTP2_LINK_NUMBER_OFFSET
value|2
end_define

begin_comment
comment|/* 2 bytes */
end_comment

begin_define
define|#
directive|define
name|MTP2_HDR_LEN
value|4
end_define

begin_comment
comment|/* length of the header */
end_comment

begin_define
define|#
directive|define
name|MTP2_ANNEX_A_NOT_USED
value|0
end_define

begin_define
define|#
directive|define
name|MTP2_ANNEX_A_USED
value|1
end_define

begin_define
define|#
directive|define
name|MTP2_ANNEX_A_USED_UNKNOWN
value|2
end_define

begin_comment
comment|/* SunATM pseudo header */
end_comment

begin_struct
struct|struct
name|sunatm_hdr
block|{
name|unsigned
name|char
name|flags
decl_stmt|;
comment|/* destination and traffic type */
name|unsigned
name|char
name|vpi
decl_stmt|;
comment|/* VPI */
name|unsigned
name|short
name|vci
decl_stmt|;
comment|/* VCI */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Private data for capturing on DAG devices.  */
end_comment

begin_struct
struct|struct
name|pcap_dag
block|{
name|struct
name|pcap_stat
name|stat
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
name|u_char
modifier|*
name|dag_mem_bottom
decl_stmt|;
comment|/* DAG card current memory bottom pointer */
name|u_char
modifier|*
name|dag_mem_top
decl_stmt|;
comment|/* DAG card current memory top pointer */
else|#
directive|else
comment|/* HAVE_DAG_STREAMS_API */
name|void
modifier|*
name|dag_mem_base
decl_stmt|;
comment|/* DAG card memory base address */
name|u_int
name|dag_mem_bottom
decl_stmt|;
comment|/* DAG card current memory bottom offset */
name|u_int
name|dag_mem_top
decl_stmt|;
comment|/* DAG card current memory top offset */
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
name|int
name|dag_fcs_bits
decl_stmt|;
comment|/* Number of checksum bits from link layer */
name|int
name|dag_offset_flags
decl_stmt|;
comment|/* Flags to pass to dag_offset(). */
name|int
name|dag_stream
decl_stmt|;
comment|/* DAG stream number */
name|int
name|dag_timeout
decl_stmt|;
comment|/* timeout specified to pcap_open_live. 				 * Same as in linux above, introduce 				 * generally? */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|pcap_dag_node
block|{
name|struct
name|pcap_dag_node
modifier|*
name|next
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
block|}
name|pcap_dag_node_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|pcap_dag_node_t
modifier|*
name|pcap_dags
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atexit_handler_installed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|short
name|endian_test_word
init|=
literal|0x0100
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_BIGENDIAN
parameter_list|()
value|(*((unsigned char *)&endian_test_word))
end_define

begin_define
define|#
directive|define
name|MAX_DAG_PACKET
value|65536
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TempPkt
index|[
name|MAX_DAG_PACKET
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|dag_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_set_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_get_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dag_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|delete_pcap_dag
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|pcap_dag_node_t
modifier|*
name|curr
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|curr
operator|=
name|pcap_dags
init|;
name|curr
operator|!=
name|NULL
operator|&&
name|curr
operator|->
name|p
operator|!=
name|p
condition|;
name|prev
operator|=
name|curr
operator|,
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
comment|/* empty */
block|}
if|if
condition|(
name|curr
operator|!=
name|NULL
operator|&&
name|curr
operator|->
name|p
operator|==
name|p
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|pcap_dags
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Performs a graceful shutdown of the DAG card, frees dynamic memory held  * in the pcap_t structure, and closes the file descriptor for the DAG card.  */
end_comment

begin_function
specifier|static
name|void
name|dag_platform_cleanup
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_dag
modifier|*
name|pd
init|=
name|p
operator|->
name|pr
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
if|if
condition|(
name|dag_stop_stream
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|pd
operator|->
name|dag_stream
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_stop_stream: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dag_detach_stream
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|pd
operator|->
name|dag_stream
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_detach_stream: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|dag_stop
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_stop: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
if|if
condition|(
name|p
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|dag_close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_close: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|delete_pcap_dag
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pcap_cleanup_live_common
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Note: don't need to call close(p->fd) here as dag_close(p->fd) does this. */
block|}
end_function

begin_function
specifier|static
name|void
name|atexit_handler
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|pcap_dags
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pcap_dags
operator|->
name|pid
operator|==
name|getpid
argument_list|()
condition|)
block|{
if|if
condition|(
name|pcap_dags
operator|->
name|p
operator|!=
name|NULL
condition|)
name|dag_platform_cleanup
argument_list|(
name|pcap_dags
operator|->
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delete_pcap_dag
argument_list|(
name|pcap_dags
operator|->
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|new_pcap_dag
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|pcap_dag_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pcap_dag_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|atexit_handler_installed
condition|)
block|{
name|atexit
argument_list|(
name|atexit_handler
argument_list|)
expr_stmt|;
name|atexit_handler_installed
operator|=
literal|1
expr_stmt|;
block|}
name|node
operator|->
name|next
operator|=
name|pcap_dags
expr_stmt|;
name|node
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|node
operator|->
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|pcap_dags
operator|=
name|node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|dag_erf_ext_header_count
parameter_list|(
name|uint8_t
modifier|*
name|erf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint32_t
name|hdr_num
init|=
literal|0
decl_stmt|;
name|uint8_t
name|hdr_type
decl_stmt|;
comment|/* basic sanity checks */
if|if
condition|(
name|erf
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|<
literal|16
condition|)
return|return
literal|0
return|;
comment|/* check if we have any extension headers */
if|if
condition|(
operator|(
name|erf
index|[
literal|8
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
condition|)
return|return
literal|0
return|;
comment|/* loop over the extension headers */
do|do
block|{
comment|/* sanity check we have enough bytes */
if|if
condition|(
name|len
operator|<
operator|(
literal|24
operator|+
operator|(
name|hdr_num
operator|*
literal|8
operator|)
operator|)
condition|)
return|return
name|hdr_num
return|;
comment|/* get the header type */
name|hdr_type
operator|=
name|erf
index|[
operator|(
literal|16
operator|+
operator|(
name|hdr_num
operator|*
literal|8
operator|)
operator|)
index|]
expr_stmt|;
name|hdr_num
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|hdr_type
operator|&
literal|0x80
condition|)
do|;
return|return
name|hdr_num
return|;
block|}
end_function

begin_comment
comment|/*  *  Read at most max_packets from the capture stream and call the callback  *  for each of them. Returns the number of packets handled, -1 if an  *  error occured, or -2 if we were told to break out of the loop.  */
end_comment

begin_function
specifier|static
name|int
name|dag_read
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|pcap_dag
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|unsigned
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
name|pd
operator|->
name|dag_offset_flags
decl_stmt|;
name|unsigned
name|int
name|nonblocking
init|=
name|flags
operator|&
name|DAGF_NONBLOCK
decl_stmt|;
name|unsigned
name|int
name|num_ext_hdr
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ticks_per_second
decl_stmt|;
comment|/* Get the next bufferful of packets (if necessary). */
while|while
condition|(
name|pd
operator|->
name|dag_mem_top
operator|-
name|pd
operator|->
name|dag_mem_bottom
operator|<
name|dag_record_size
condition|)
block|{
comment|/* 		 * Has "pcap_breakloop()" been called? 		 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 			 * Yes - clear the flag that indicates that 			 * it has, and return -2 to indicate that 			 * we were told to break out of the loop. 			 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
comment|/* dag_advance_stream() will block (unless nonblock is called) 		 * until 64kB of data has accumulated. 		 * If to_ms is set, it will timeout before 64kB has accumulated. 		 * We wait for 64kB because processing a few packets at a time 		 * can cause problems at high packet rates (>200kpps) due 		 * to inefficiencies. 		 * This does mean if to_ms is not specified the capture may 'hang' 		 * for long periods if the data rate is extremely slow (<64kB/sec) 		 * If non-block is specified it will return immediately. The user 		 * is then responsible for efficiency. 		 */
if|if
condition|(
name|NULL
operator|==
operator|(
name|pd
operator|->
name|dag_mem_top
operator|=
name|dag_advance_stream
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|pd
operator|->
name|dag_stream
argument_list|,
operator|&
operator|(
name|pd
operator|->
name|dag_mem_bottom
operator|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
comment|/* dag_offset does not support timeouts */
name|pd
operator|->
name|dag_mem_top
operator|=
name|dag_offset
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|&
operator|(
name|pd
operator|->
name|dag_mem_bottom
operator|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
if|if
condition|(
name|nonblocking
operator|&&
operator|(
name|pd
operator|->
name|dag_mem_top
operator|-
name|pd
operator|->
name|dag_mem_bottom
operator|<
name|dag_record_size
operator|)
condition|)
block|{
comment|/* Pcap is configured to process only available packets, and there aren't any, return immediately. */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|nonblocking
operator|&&
name|pd
operator|->
name|dag_timeout
operator|&&
operator|(
name|pd
operator|->
name|dag_mem_top
operator|-
name|pd
operator|->
name|dag_mem_bottom
operator|<
name|dag_record_size
operator|)
condition|)
block|{
comment|/* Blocking mode, but timeout set and no data has arrived, return anyway.*/
return|return
literal|0
return|;
block|}
block|}
comment|/* Process the packets. */
while|while
condition|(
name|pd
operator|->
name|dag_mem_top
operator|-
name|pd
operator|->
name|dag_mem_bottom
operator|>=
name|dag_record_size
condition|)
block|{
name|unsigned
name|short
name|packet_len
init|=
literal|0
decl_stmt|;
name|int
name|caplen
init|=
literal|0
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pcap_header
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
name|dag_record_t
modifier|*
name|header
init|=
operator|(
name|dag_record_t
operator|*
operator|)
operator|(
name|pd
operator|->
name|dag_mem_bottom
operator|)
decl_stmt|;
else|#
directive|else
name|dag_record_t
modifier|*
name|header
init|=
operator|(
name|dag_record_t
operator|*
operator|)
operator|(
name|pd
operator|->
name|dag_mem_base
operator|+
name|pd
operator|->
name|dag_mem_bottom
operator|)
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
name|u_char
modifier|*
name|dp
init|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|header
operator|)
decl_stmt|;
comment|/* + dag_record_size; */
name|unsigned
name|short
name|rlen
decl_stmt|;
comment|/* 		 * Has "pcap_breakloop()" been called? 		 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 			 * Yes - clear the flag that indicates that 			 * it has, and return -2 to indicate that 			 * we were told to break out of the loop. 			 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|rlen
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|<
name|dag_record_size
condition|)
block|{
name|strncpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"dag_read: record too small"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pd
operator|->
name|dag_mem_bottom
operator|+=
name|rlen
expr_stmt|;
comment|/* Count lost packets. */
switch|switch
condition|(
operator|(
name|header
operator|->
name|type
operator|&
literal|0x7f
operator|)
condition|)
block|{
comment|/* in these types the color value overwrites the lctr */
case|case
name|TYPE_COLOR_HDLC_POS
case|:
case|case
name|TYPE_COLOR_ETH
case|:
case|case
name|TYPE_DSM_COLOR_HDLC_POS
case|:
case|case
name|TYPE_DSM_COLOR_ETH
case|:
case|case
name|TYPE_COLOR_MC_HDLC_POS
case|:
case|case
name|TYPE_COLOR_HASH_ETH
case|:
case|case
name|TYPE_COLOR_HASH_POS
case|:
break|break;
default|default:
if|if
condition|(
name|header
operator|->
name|lctr
condition|)
block|{
if|if
condition|(
name|pd
operator|->
name|stat
operator|.
name|ps_drop
operator|>
operator|(
name|UINT_MAX
operator|-
name|ntohs
argument_list|(
name|header
operator|->
name|lctr
argument_list|)
operator|)
condition|)
block|{
name|pd
operator|->
name|stat
operator|.
name|ps_drop
operator|=
name|UINT_MAX
expr_stmt|;
block|}
else|else
block|{
name|pd
operator|->
name|stat
operator|.
name|ps_drop
operator|+=
name|ntohs
argument_list|(
name|header
operator|->
name|lctr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|header
operator|->
name|type
operator|&
literal|0x7f
operator|)
operator|==
name|TYPE_PAD
condition|)
block|{
continue|continue;
block|}
name|num_ext_hdr
operator|=
name|dag_erf_ext_header_count
argument_list|(
name|dp
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
comment|/* ERF encapsulation */
comment|/* The Extensible Record Format is not dropped for this kind of encapsulation, 		 * and will be handled as a pseudo header by the decoding application. 		 * The information carried in the ERF header and in the optional subheader (if present) 		 * could be merged with the libpcap information, to offer a better decoding. 		 * The packet length is 		 * o the length of the packet on the link (header->wlen), 		 * o plus the length of the ERF header (dag_record_size), as the length of the 		 *   pseudo header will be adjusted during the decoding, 		 * o plus the length of the optional subheader (if present). 		 * 		 * The capture length is header.rlen and the byte stuffing for alignment will be dropped 		 * if the capture length is greater than the packet length. 		 */
if|if
condition|(
name|p
operator|->
name|linktype
operator|==
name|DLT_ERF
condition|)
block|{
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
operator|+
name|dag_record_size
expr_stmt|;
name|caplen
operator|=
name|rlen
expr_stmt|;
switch|switch
condition|(
operator|(
name|header
operator|->
name|type
operator|&
literal|0x7f
operator|)
condition|)
block|{
case|case
name|TYPE_MC_AAL5
case|:
case|case
name|TYPE_MC_ATM
case|:
case|case
name|TYPE_MC_HDLC
case|:
case|case
name|TYPE_MC_RAW_CHANNEL
case|:
case|case
name|TYPE_MC_RAW
case|:
case|case
name|TYPE_MC_AAL2
case|:
case|case
name|TYPE_COLOR_MC_HDLC_POS
case|:
name|packet_len
operator|+=
literal|4
expr_stmt|;
comment|/* MC header */
break|break;
case|case
name|TYPE_COLOR_HASH_ETH
case|:
case|case
name|TYPE_DSM_COLOR_ETH
case|:
case|case
name|TYPE_COLOR_ETH
case|:
case|case
name|TYPE_ETH
case|:
name|packet_len
operator|+=
literal|2
expr_stmt|;
comment|/* ETH header */
break|break;
block|}
comment|/* switch type */
comment|/* Include ERF extension headers */
name|packet_len
operator|+=
operator|(
literal|8
operator|*
name|num_ext_hdr
operator|)
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Other kind of encapsulation according to the header Type */
comment|/* Skip over generic ERF header */
name|dp
operator|+=
name|dag_record_size
expr_stmt|;
comment|/* Skip over extension headers */
name|dp
operator|+=
literal|8
operator|*
name|num_ext_hdr
expr_stmt|;
switch|switch
condition|(
operator|(
name|header
operator|->
name|type
operator|&
literal|0x7f
operator|)
condition|)
block|{
case|case
name|TYPE_ATM
case|:
case|case
name|TYPE_AAL5
case|:
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|TYPE_AAL5
condition|)
block|{
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
expr_stmt|;
block|}
case|case
name|TYPE_MC_ATM
case|:
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|TYPE_MC_ATM
condition|)
block|{
name|caplen
operator|=
name|packet_len
operator|=
name|ATM_CELL_SIZE
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
block|}
case|case
name|TYPE_MC_AAL5
case|:
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|TYPE_MC_AAL5
condition|)
block|{
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
operator|-
literal|4
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Skip over extension headers */
name|caplen
operator|-=
operator|(
literal|8
operator|*
name|num_ext_hdr
operator|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|TYPE_ATM
condition|)
block|{
name|caplen
operator|=
name|packet_len
operator|=
name|ATM_CELL_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|linktype
operator|==
name|DLT_SUNATM
condition|)
block|{
name|struct
name|sunatm_hdr
modifier|*
name|sunatm
init|=
operator|(
expr|struct
name|sunatm_hdr
operator|*
operator|)
name|dp
decl_stmt|;
name|unsigned
name|long
name|rawatm
decl_stmt|;
name|rawatm
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dp
operator|)
argument_list|)
expr_stmt|;
name|sunatm
operator|->
name|vci
operator|=
name|htons
argument_list|(
operator|(
name|rawatm
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|sunatm
operator|->
name|vpi
operator|=
operator|(
name|rawatm
operator|>>
literal|20
operator|)
operator|&
literal|0x00ff
expr_stmt|;
name|sunatm
operator|->
name|flags
operator|=
operator|(
operator|(
name|header
operator|->
name|flags
operator|.
name|iface
operator|&
literal|1
operator|)
condition|?
literal|0x80
else|:
literal|0x00
operator|)
operator||
operator|(
operator|(
name|sunatm
operator|->
name|vpi
operator|==
literal|0
operator|&&
name|sunatm
operator|->
name|vci
operator|==
name|htons
argument_list|(
literal|5
argument_list|)
operator|)
condition|?
literal|6
else|:
operator|(
operator|(
name|sunatm
operator|->
name|vpi
operator|==
literal|0
operator|&&
name|sunatm
operator|->
name|vci
operator|==
name|htons
argument_list|(
literal|16
argument_list|)
operator|)
condition|?
literal|5
else|:
operator|(
operator|(
name|dp
index|[
name|ATM_HDR_SIZE
index|]
operator|==
literal|0xaa
operator|&&
name|dp
index|[
name|ATM_HDR_SIZE
operator|+
literal|1
index|]
operator|==
literal|0xaa
operator|&&
name|dp
index|[
name|ATM_HDR_SIZE
operator|+
literal|2
index|]
operator|==
literal|0x03
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|packet_len
operator|-=
name|ATM_HDR_SIZE
expr_stmt|;
name|caplen
operator|-=
name|ATM_HDR_SIZE
expr_stmt|;
name|dp
operator|+=
name|ATM_HDR_SIZE
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_COLOR_HASH_ETH
case|:
case|case
name|TYPE_DSM_COLOR_ETH
case|:
case|case
name|TYPE_COLOR_ETH
case|:
case|case
name|TYPE_ETH
case|:
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|packet_len
operator|-=
operator|(
name|pd
operator|->
name|dag_fcs_bits
operator|>>
literal|3
operator|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
operator|-
literal|2
expr_stmt|;
comment|/* Skip over extension headers */
name|caplen
operator|-=
operator|(
literal|8
operator|*
name|num_ext_hdr
operator|)
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
name|dp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TYPE_COLOR_HASH_POS
case|:
case|case
name|TYPE_DSM_COLOR_HDLC_POS
case|:
case|case
name|TYPE_COLOR_HDLC_POS
case|:
case|case
name|TYPE_HDLC_POS
case|:
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|packet_len
operator|-=
operator|(
name|pd
operator|->
name|dag_fcs_bits
operator|>>
literal|3
operator|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
expr_stmt|;
comment|/* Skip over extension headers */
name|caplen
operator|-=
operator|(
literal|8
operator|*
name|num_ext_hdr
operator|)
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_COLOR_MC_HDLC_POS
case|:
case|case
name|TYPE_MC_HDLC
case|:
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|packet_len
operator|-=
operator|(
name|pd
operator|->
name|dag_fcs_bits
operator|>>
literal|3
operator|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
operator|-
literal|4
expr_stmt|;
comment|/* Skip over extension headers */
name|caplen
operator|-=
operator|(
literal|8
operator|*
name|num_ext_hdr
operator|)
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
comment|/* jump the MC_HDLC_HEADER */
name|dp
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|DLT_MTP2_WITH_PHDR
if|if
condition|(
name|p
operator|->
name|linktype
operator|==
name|DLT_MTP2_WITH_PHDR
condition|)
block|{
comment|/* Add the MTP2 Pseudo Header */
name|caplen
operator|+=
name|MTP2_HDR_LEN
expr_stmt|;
name|packet_len
operator|+=
name|MTP2_HDR_LEN
expr_stmt|;
name|TempPkt
index|[
name|MTP2_SENT_OFFSET
index|]
operator|=
literal|0
expr_stmt|;
name|TempPkt
index|[
name|MTP2_ANNEX_A_USED_OFFSET
index|]
operator|=
name|MTP2_ANNEX_A_USED_UNKNOWN
expr_stmt|;
operator|*
operator|(
name|TempPkt
operator|+
name|MTP2_LINK_NUMBER_OFFSET
operator|)
operator|=
operator|(
operator|(
name|header
operator|->
name|rec
operator|.
name|mc_hdlc
operator|.
name|mc_header
operator|>>
literal|16
operator|)
operator|&
literal|0x01
operator|)
expr_stmt|;
operator|*
operator|(
name|TempPkt
operator|+
name|MTP2_LINK_NUMBER_OFFSET
operator|+
literal|1
operator|)
operator|=
operator|(
operator|(
name|header
operator|->
name|rec
operator|.
name|mc_hdlc
operator|.
name|mc_header
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|TempPkt
operator|+
name|MTP2_HDR_LEN
argument_list|,
name|dp
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
name|dp
operator|=
name|TempPkt
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|TYPE_IPV4
case|:
case|case
name|TYPE_IPV6
case|:
name|packet_len
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|caplen
operator|=
name|rlen
operator|-
name|dag_record_size
expr_stmt|;
comment|/* Skip over extension headers */
name|caplen
operator|-=
operator|(
literal|8
operator|*
name|num_ext_hdr
operator|)
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
name|packet_len
condition|)
block|{
name|caplen
operator|=
name|packet_len
expr_stmt|;
block|}
break|break;
comment|/* These types have no matching 'native' DLT, but can be used with DLT_ERF above */
case|case
name|TYPE_MC_RAW
case|:
case|case
name|TYPE_MC_RAW_CHANNEL
case|:
case|case
name|TYPE_IP_COUNTER
case|:
case|case
name|TYPE_TCP_FLOW_COUNTER
case|:
case|case
name|TYPE_INFINIBAND
case|:
case|case
name|TYPE_RAW_LINK
case|:
case|case
name|TYPE_INFINIBAND_LINK
case|:
default|default:
comment|/* Unhandled ERF type. 				 * Ignore rather than generating error 				 */
continue|continue;
block|}
comment|/* switch type */
block|}
comment|/* ERF encapsulation */
if|if
condition|(
name|caplen
operator|>
name|p
operator|->
name|snapshot
condition|)
name|caplen
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
comment|/* Run the packet filter if there is one. */
if|if
condition|(
operator|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
operator|==
name|NULL
operator|)
operator|||
name|bpf_filter
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|dp
argument_list|,
name|packet_len
argument_list|,
name|caplen
argument_list|)
condition|)
block|{
comment|/* convert between timestamp formats */
specifier|register
name|unsigned
name|long
name|long
name|ts
decl_stmt|;
if|if
condition|(
name|IS_BIGENDIAN
argument_list|()
condition|)
block|{
name|ts
operator|=
name|SWAPLL
argument_list|(
name|header
operator|->
name|ts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ts
operator|=
name|header
operator|->
name|ts
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
condition|)
block|{
case|case
name|PCAP_TSTAMP_PRECISION_NANO
case|:
name|ticks_per_second
operator|=
literal|1000000000
expr_stmt|;
break|break;
case|case
name|PCAP_TSTAMP_PRECISION_MICRO
case|:
default|default:
name|ticks_per_second
operator|=
literal|1000000
expr_stmt|;
break|break;
block|}
name|pcap_header
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|ts
operator|>>
literal|32
expr_stmt|;
name|ts
operator|=
operator|(
name|ts
operator|&
literal|0xffffffffULL
operator|)
operator|*
name|ticks_per_second
expr_stmt|;
name|ts
operator|+=
literal|0x80000000
expr_stmt|;
comment|/* rounding */
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|ts
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|>=
name|ticks_per_second
condition|)
block|{
name|pcap_header
operator|.
name|ts
operator|.
name|tv_usec
operator|-=
name|ticks_per_second
expr_stmt|;
name|pcap_header
operator|.
name|ts
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
comment|/* Fill in our own header data */
name|pcap_header
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pcap_header
operator|.
name|len
operator|=
name|packet_len
expr_stmt|;
comment|/* Count the packet. */
name|pd
operator|->
name|stat
operator|.
name|ps_recv
operator|++
expr_stmt|;
comment|/* Call the user supplied callback function */
name|callback
argument_list|(
name|user
argument_list|,
operator|&
name|pcap_header
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* Only count packets that pass the filter, for consistency with standard Linux behaviour. */
name|processed
operator|++
expr_stmt|;
if|if
condition|(
name|processed
operator|==
name|cnt
operator|&&
operator|!
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|cnt
argument_list|)
condition|)
block|{
comment|/* Reached the user-specified limit. */
return|return
name|cnt
return|;
block|}
block|}
block|}
return|return
name|processed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_inject
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
name|_U_
parameter_list|,
name|size_t
name|size
name|_U_
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"Sending packets isn't supported on DAG cards"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Get a handle for a live capture from the given DAG device.  Passing a NULL  *  device will result in a failure.  The promisc flag is ignored because DAG  *  cards are always promiscuous.  The to_ms parameter is used in setting the  *  API polling parameters.  *  *  snaplen is now also ignored, until we get per-stream slen support. Set  *  slen with approprite DAG tool BEFORE pcap_activate().  *  *  See also pcap(3).  */
end_comment

begin_function
specifier|static
name|int
name|dag_activate
parameter_list|(
name|pcap_t
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|pcap_dag
modifier|*
name|handlep
init|=
name|handle
operator|->
name|priv
decl_stmt|;
if|#
directive|if
literal|0
block|char conf[30];
comment|/* dag configure string */
endif|#
directive|endif
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
name|daginf_t
modifier|*
name|daginf
decl_stmt|;
name|char
modifier|*
name|newDev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|device
init|=
name|handle
operator|->
name|opt
operator|.
name|device
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
name|uint32_t
name|mindata
decl_stmt|;
name|struct
name|timeval
name|maxwait
decl_stmt|;
name|struct
name|timeval
name|poll
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"device is NULL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Initialize some components of the pcap structure. */
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
name|newDev
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|device
argument_list|)
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|newDev
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't allocate string for device name: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Parse input name to get dag device and stream number if provided */
if|if
condition|(
name|dag_parse_name
argument_list|(
name|device
argument_list|,
name|newDev
argument_list|,
name|strlen
argument_list|(
name|device
argument_list|)
operator|+
literal|16
argument_list|,
operator|&
name|handlep
operator|->
name|dag_stream
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_parse_name: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|device
operator|=
name|newDev
expr_stmt|;
if|if
condition|(
name|handlep
operator|->
name|dag_stream
operator|%
literal|2
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_parse_name: tx (even numbered) streams not supported for capture"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
else|#
directive|else
if|if
condition|(
name|strncmp
argument_list|(
name|device
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|newDev
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|device
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|newDev
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't allocate string for device name: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|strcpy
argument_list|(
name|newDev
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newDev
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|device
operator|=
name|newDev
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
comment|/* setup device parameters */
if|if
condition|(
operator|(
name|handle
operator|->
name|fd
operator|=
name|dag_open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|device
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_open %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
comment|/* Open requested stream. Can fail if already locked or on error */
if|if
condition|(
name|dag_attach_stream
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|handlep
operator|->
name|dag_stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_attach_stream: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failclose
goto|;
block|}
comment|/* Set up default poll parameters for stream 	 * Can be overridden by pcap_set_nonblock() 	 */
if|if
condition|(
name|dag_get_stream_poll
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|handlep
operator|->
name|dag_stream
argument_list|,
operator|&
name|mindata
argument_list|,
operator|&
name|maxwait
argument_list|,
operator|&
name|poll
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_get_stream_poll: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|faildetach
goto|;
block|}
if|if
condition|(
name|handle
operator|->
name|opt
operator|.
name|immediate
condition|)
block|{
comment|/* Call callback immediately. 		 * XXX - is this the right way to handle this? 		 */
name|mindata
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Amount of data to collect in Bytes before calling callbacks. 		 * Important for efficiency, but can introduce latency 		 * at low packet rates if to_ms not set! 		 */
name|mindata
operator|=
literal|65536
expr_stmt|;
block|}
comment|/* Obey opt.timeout (was to_ms) if supplied. This is a good idea! 	 * Recommend 10-100ms. Calls will time out even if no data arrived. 	 */
name|maxwait
operator|.
name|tv_sec
operator|=
name|handle
operator|->
name|opt
operator|.
name|timeout
operator|/
literal|1000
expr_stmt|;
name|maxwait
operator|.
name|tv_usec
operator|=
operator|(
name|handle
operator|->
name|opt
operator|.
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|dag_set_stream_poll
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|handlep
operator|->
name|dag_stream
argument_list|,
name|mindata
argument_list|,
operator|&
name|maxwait
argument_list|,
operator|&
name|poll
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_set_stream_poll: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|faildetach
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|handlep
operator|->
name|dag_mem_base
operator|=
name|dag_mmap
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_mmap %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failclose
goto|;
block|}
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
comment|/* XXX Not calling dag_configure() to set slen; this is unsafe in 	 * multi-stream environments as the gpp config is global.          * Once the firmware provides 'per-stream slen' this can be supported 	 * again via the Config API without side-effects */
if|#
directive|if
literal|0
comment|/* set the card snap length to the specified snaplen parameter */
comment|/* This is a really bad idea, as different cards have different 	 * valid slen ranges. Should fix in Config API. */
block|if (handle->snapshot == 0 || handle->snapshot> MAX_DAG_SNAPLEN) { 		handle->snapshot = MAX_DAG_SNAPLEN; 	} else if (snaplen< MIN_DAG_SNAPLEN) { 		handle->snapshot = MIN_DAG_SNAPLEN; 	}
comment|/* snap len has to be a multiple of 4 */
block|pcap_snprintf(conf, 30, "varlen slen=%d", (snaplen + 3)& ~3);  	if(dag_configure(handle->fd, conf)< 0) { 		pcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,"dag_configure %s: %s", device, pcap_strerror(errno)); 		goto faildetach; 	}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
if|if
condition|(
name|dag_start_stream
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|handlep
operator|->
name|dag_stream
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_start_stream %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|faildetach
goto|;
block|}
else|#
directive|else
if|if
condition|(
name|dag_start
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_start %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failclose
goto|;
block|}
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
comment|/* 	 * Important! You have to ensure bottom is properly 	 * initialized to zero on startup, it won't give you 	 * a compiler warning if you make this mistake! 	 */
name|handlep
operator|->
name|dag_mem_bottom
operator|=
literal|0
expr_stmt|;
name|handlep
operator|->
name|dag_mem_top
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Find out how many FCS bits we should strip. 	 * First, query the card to see if it strips the FCS. 	 */
name|daginf
operator|=
name|dag_info
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0x4200
operator|==
name|daginf
operator|->
name|device_code
operator|)
operator|||
operator|(
literal|0x4230
operator|==
name|daginf
operator|->
name|device_code
operator|)
condition|)
block|{
comment|/* DAG 4.2S and 4.23S already strip the FCS.  Stripping the final word again truncates the packet. */
name|handlep
operator|->
name|dag_fcs_bits
operator|=
literal|0
expr_stmt|;
comment|/* Note that no FCS will be supplied. */
name|handle
operator|->
name|linktype_ext
operator|=
name|LT_FCS_DATALINK_EXT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Start out assuming it's 32 bits. 		 */
name|handlep
operator|->
name|dag_fcs_bits
operator|=
literal|32
expr_stmt|;
comment|/* Allow an environment variable to override. */
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"ERF_FCS_BITS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|n
operator|==
literal|16
operator|||
name|n
operator|==
literal|32
condition|)
block|{
name|handlep
operator|->
name|dag_fcs_bits
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"pcap_activate %s: bad ERF_FCS_BITS value (%d) in environment"
argument_list|,
name|device
argument_list|,
name|n
argument_list|)
expr_stmt|;
goto|goto
name|failstop
goto|;
block|}
block|}
comment|/* 		 * Did the user request that they not be stripped? 		 */
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"ERF_DONT_STRIP_FCS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Yes.  Note the number of bytes that will be 			   supplied. */
name|handle
operator|->
name|linktype_ext
operator|=
name|LT_FCS_DATALINK_EXT
argument_list|(
name|handlep
operator|->
name|dag_fcs_bits
operator|/
literal|16
argument_list|)
expr_stmt|;
comment|/* And don't strip them. */
name|handlep
operator|->
name|dag_fcs_bits
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|handlep
operator|->
name|dag_timeout
operator|=
name|handle
operator|->
name|opt
operator|.
name|timeout
expr_stmt|;
name|handle
operator|->
name|linktype
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dag_get_datalink
argument_list|(
name|handle
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|failstop
goto|;
name|handle
operator|->
name|bufsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_pcap_dag
argument_list|(
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|handle
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"new_pcap_dag %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failstop
goto|;
block|}
comment|/* 	 * "select()" and "poll()" don't work on DAG device descriptors. 	 */
name|handle
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|newDev
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newDev
argument_list|)
expr_stmt|;
block|}
name|handle
operator|->
name|read_op
operator|=
name|dag_read
expr_stmt|;
name|handle
operator|->
name|inject_op
operator|=
name|dag_inject
expr_stmt|;
name|handle
operator|->
name|setfilter_op
operator|=
name|dag_setfilter
expr_stmt|;
name|handle
operator|->
name|setdirection_op
operator|=
name|NULL
expr_stmt|;
comment|/* Not implemented.*/
name|handle
operator|->
name|set_datalink_op
operator|=
name|dag_set_datalink
expr_stmt|;
name|handle
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_fd
expr_stmt|;
name|handle
operator|->
name|setnonblock_op
operator|=
name|dag_setnonblock
expr_stmt|;
name|handle
operator|->
name|stats_op
operator|=
name|dag_stats
expr_stmt|;
name|handle
operator|->
name|cleanup_op
operator|=
name|dag_platform_cleanup
expr_stmt|;
name|handlep
operator|->
name|stat
operator|.
name|ps_drop
operator|=
literal|0
expr_stmt|;
name|handlep
operator|->
name|stat
operator|.
name|ps_recv
operator|=
literal|0
expr_stmt|;
name|handlep
operator|->
name|stat
operator|.
name|ps_ifdrop
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
name|failstop
label|:
if|if
condition|(
name|dag_stop_stream
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|handlep
operator|->
name|dag_stream
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_stop_stream: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|faildetach
label|:
if|if
condition|(
name|dag_detach_stream
argument_list|(
name|handle
operator|->
name|fd
argument_list|,
name|handlep
operator|->
name|dag_stream
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_detach_stream: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|failstop
label|:
if|if
condition|(
name|dag_stop
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_stop: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
name|failclose
label|:
if|if
condition|(
name|dag_close
argument_list|(
name|handle
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dag_close: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|delete_pcap_dag
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|fail
label|:
name|pcap_cleanup_live_common
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|newDev
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newDev
argument_list|)
expr_stmt|;
block|}
return|return
name|PCAP_ERROR
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|dag_create
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|,
name|int
modifier|*
name|is_ours
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cpend
decl_stmt|;
name|long
name|devnum
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
name|long
name|stream
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* Does this look like a DAG device? */
name|cp
operator|=
name|strrchr
argument_list|(
name|device
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|device
expr_stmt|;
comment|/* Does it begin with "dag"? */
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"dag"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Nope, doesn't begin with "dag" */
operator|*
name|is_ours
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Yes - is "dag" followed by a number from 0 to DAG_MAX_BOARDS-1 */
name|cp
operator|+=
literal|3
expr_stmt|;
name|devnum
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cpend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
if|if
condition|(
operator|*
name|cpend
operator|==
literal|':'
condition|)
block|{
comment|/* Followed by a stream number. */
name|stream
operator|=
name|strtol
argument_list|(
operator|++
name|cpend
argument_list|,
operator|&
name|cpend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|cpend
operator|==
name|cp
operator|||
operator|*
name|cpend
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Not followed by a number. */
operator|*
name|is_ours
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|devnum
operator|<
literal|0
operator|||
name|devnum
operator|>=
name|DAG_MAX_BOARDS
condition|)
block|{
comment|/* Followed by a non-valid number. */
operator|*
name|is_ours
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
if|if
condition|(
name|stream
operator|<
literal|0
operator|||
name|stream
operator|>=
name|DAG_STREAM_MAX
condition|)
block|{
comment|/* Followed by a non-valid stream number. */
operator|*
name|is_ours
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* OK, it's probably ours. */
operator|*
name|is_ours
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_dag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|->
name|activate_op
operator|=
name|dag_activate
expr_stmt|;
comment|/* 	 * We claim that we support microsecond and nanosecond time 	 * stamps. 	 * 	 * XXX Our native precision is 2^-32s, but libpcap doesn't support 	 * power of two precisions yet. We can convert to either MICRO or NANO. 	 */
name|p
operator|->
name|tstamp_precision_count
operator|=
literal|2
expr_stmt|;
name|p
operator|->
name|tstamp_precision_list
operator|=
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tstamp_precision_list
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|pcap_close
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|->
name|tstamp_precision_list
index|[
literal|0
index|]
operator|=
name|PCAP_TSTAMP_PRECISION_MICRO
expr_stmt|;
name|p
operator|->
name|tstamp_precision_list
index|[
literal|1
index|]
operator|=
name|PCAP_TSTAMP_PRECISION_NANO
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|pcap_dag
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
comment|/* This needs to be filled out correctly.  Hopefully a dagapi call will 		 provide all necessary information. 	*/
comment|/*pd->stat.ps_recv = 0;*/
comment|/*pd->stat.ps_drop = 0;*/
operator|*
name|ps
operator|=
name|pd
operator|->
name|stat
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Previously we just generated a list of all possible names and let  * pcap_add_if() attempt to open each one, but with streams this adds up  * to 81 possibilities which is inefficient.  *  * Since we know more about the devices we can prune the tree here.  * pcap_add_if() will still retest each device but the total number of  * open attempts will still be much less than the naive approach.  */
end_comment

begin_function
name|int
name|dag_findalldevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|devlistp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
comment|/* XXX - pick a size */
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
name|dagname
index|[
name|DAGNAME_BUFSIZE
index|]
decl_stmt|;
name|int
name|dagstream
decl_stmt|;
name|int
name|dagfd
decl_stmt|;
name|dag_card_inf_t
modifier|*
name|inf
decl_stmt|;
name|char
modifier|*
name|description
decl_stmt|;
comment|/* Try all the DAGs 0-DAG_MAX_BOARDS */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|DAG_MAX_BOARDS
condition|;
name|c
operator|++
control|)
block|{
name|pcap_snprintf
argument_list|(
name|name
argument_list|,
literal|12
argument_list|,
literal|"dag%d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|dag_parse_name
argument_list|(
name|name
argument_list|,
name|dagname
argument_list|,
name|DAGNAME_BUFSIZE
argument_list|,
operator|&
name|dagstream
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|description
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|dagfd
operator|=
name|dag_open
argument_list|(
name|dagname
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|inf
operator|=
name|dag_pciinfo
argument_list|(
name|dagfd
argument_list|)
operator|)
condition|)
name|description
operator|=
name|dag_device_name
argument_list|(
name|inf
operator|->
name|device_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_add_if
argument_list|(
name|devlistp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|description
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Failure. 				 */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
block|{
name|int
name|stream
decl_stmt|,
name|rxstreams
decl_stmt|;
name|rxstreams
operator|=
name|dag_rx_get_stream_count
argument_list|(
name|dagfd
argument_list|)
expr_stmt|;
for|for
control|(
name|stream
operator|=
literal|0
init|;
name|stream
operator|<
name|DAG_STREAM_MAX
condition|;
name|stream
operator|+=
literal|2
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|dag_attach_stream
argument_list|(
name|dagfd
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|dag_detach_stream
argument_list|(
name|dagfd
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|name
argument_list|,
literal|10
argument_list|,
literal|"dag%d:%d"
argument_list|,
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_add_if
argument_list|(
name|devlistp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|description
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 							 * Failure. 							 */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|rxstreams
operator|--
expr_stmt|;
if|if
condition|(
name|rxstreams
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
name|dag_close
argument_list|(
name|dagfd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Installs the given bpf filter program in the given pcap structure.  There is  * no attempt to store the filter in kernel memory as that is not supported  * with DAG cards.  */
end_comment

begin_function
specifier|static
name|int
name|dag_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|strncpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"setfilter: No filter specified"
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make our private copy of the filter */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_set_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
block|{
name|p
operator|->
name|linktype
operator|=
name|dlt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|struct
name|pcap_dag
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
comment|/* 	 * Set non-blocking mode on the FD. 	 * XXX - is that necessary?  If not, don't bother calling it, 	 * and have a "dag_getnonblock()" function that looks at 	 * "pd->dag_offset_flags". 	 */
if|if
condition|(
name|pcap_setnonblock_fd
argument_list|(
name|p
argument_list|,
name|nonblock
argument_list|,
name|errbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_DAG_STREAMS_API
block|{
name|uint32_t
name|mindata
decl_stmt|;
name|struct
name|timeval
name|maxwait
decl_stmt|;
name|struct
name|timeval
name|poll
decl_stmt|;
if|if
condition|(
name|dag_get_stream_poll
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|pd
operator|->
name|dag_stream
argument_list|,
operator|&
name|mindata
argument_list|,
operator|&
name|maxwait
argument_list|,
operator|&
name|poll
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_get_stream_poll: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Amount of data to collect in Bytes before calling callbacks. 		 * Important for efficiency, but can introduce latency 		 * at low packet rates if to_ms not set! 		 */
if|if
condition|(
name|nonblock
condition|)
name|mindata
operator|=
literal|0
expr_stmt|;
else|else
name|mindata
operator|=
literal|65536
expr_stmt|;
if|if
condition|(
name|dag_set_stream_poll
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|pd
operator|->
name|dag_stream
argument_list|,
name|mindata
argument_list|,
operator|&
name|maxwait
argument_list|,
operator|&
name|poll
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"dag_set_stream_poll: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_DAG_STREAMS_API */
if|if
condition|(
name|nonblock
condition|)
block|{
name|pd
operator|->
name|dag_offset_flags
operator||=
name|DAGF_NONBLOCK
expr_stmt|;
block|}
else|else
block|{
name|pd
operator|->
name|dag_offset_flags
operator|&=
operator|~
name|DAGF_NONBLOCK
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dag_get_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_dag
modifier|*
name|pd
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|,
name|dlt_index
init|=
literal|0
decl_stmt|;
name|uint8_t
name|types
index|[
literal|255
index|]
decl_stmt|;
name|memset
argument_list|(
name|types
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|==
name|NULL
operator|&&
operator|(
name|p
operator|->
name|dlt_list
operator|=
name|malloc
argument_list|(
literal|255
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|p
operator|->
name|dlt_list
operator|)
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|->
name|linktype
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DAG_GET_STREAM_ERF_TYPES
comment|/* Get list of possible ERF types for this card */
if|if
condition|(
name|dag_get_stream_erf_types
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|pd
operator|->
name|dag_stream
argument_list|,
name|types
argument_list|,
literal|255
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"dag_get_stream_erf_types: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|types
index|[
name|index
index|]
condition|)
block|{
elif|#
directive|elif
name|defined
name|HAVE_DAG_GET_ERF_TYPES
comment|/* Get list of possible ERF types for this card */
if|if
condition|(
name|dag_get_erf_types
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|types
argument_list|,
literal|255
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"dag_get_erf_types: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|types
index|[
name|index
index|]
condition|)
block|{
else|#
directive|else
comment|/* Check the type through a dagapi call. */
name|types
index|[
name|index
index|]
operator|=
name|dag_linktype
argument_list|(
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
block|{
endif|#
directive|endif
switch|switch
condition|(
operator|(
name|types
index|[
name|index
index|]
operator|&
literal|0x7f
operator|)
condition|)
block|{
case|case
name|TYPE_HDLC_POS
case|:
case|case
name|TYPE_COLOR_HDLC_POS
case|:
case|case
name|TYPE_DSM_COLOR_HDLC_POS
case|:
case|case
name|TYPE_COLOR_HASH_POS
case|:
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_CHDLC
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_PPP_SERIAL
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_FRELAY
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|linktype
condition|)
name|p
operator|->
name|linktype
operator|=
name|DLT_CHDLC
expr_stmt|;
break|break;
case|case
name|TYPE_ETH
case|:
case|case
name|TYPE_COLOR_ETH
case|:
case|case
name|TYPE_DSM_COLOR_ETH
case|:
case|case
name|TYPE_COLOR_HASH_ETH
case|:
comment|/* 			 * This is (presumably) a real Ethernet capture; give it a 			 * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so 			 * that an application can let you choose it, in case you're 			 * capturing DOCSIS traffic that a Cisco Cable Modem 			 * Termination System is putting out onto an Ethernet (it 			 * doesn't put an Ethernet header onto the wire, it puts raw 			 * DOCSIS frames out on the wire inside the low-level 			 * Ethernet framing). 			 */
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_EN10MB
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_DOCSIS
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|linktype
condition|)
name|p
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
break|break;
case|case
name|TYPE_ATM
case|:
case|case
name|TYPE_AAL5
case|:
case|case
name|TYPE_MC_ATM
case|:
case|case
name|TYPE_MC_AAL5
case|:
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_ATM_RFC1483
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_SUNATM
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|linktype
condition|)
name|p
operator|->
name|linktype
operator|=
name|DLT_ATM_RFC1483
expr_stmt|;
break|break;
case|case
name|TYPE_COLOR_MC_HDLC_POS
case|:
case|case
name|TYPE_MC_HDLC
case|:
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_CHDLC
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_PPP_SERIAL
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_FRELAY
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_MTP2
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_MTP2_WITH_PHDR
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_LAPD
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|linktype
condition|)
name|p
operator|->
name|linktype
operator|=
name|DLT_CHDLC
expr_stmt|;
break|break;
case|case
name|TYPE_IPV4
case|:
case|case
name|TYPE_IPV6
case|:
if|if
condition|(
operator|!
name|p
operator|->
name|linktype
condition|)
name|p
operator|->
name|linktype
operator|=
name|DLT_RAW
expr_stmt|;
break|break;
case|case
name|TYPE_LEGACY
case|:
case|case
name|TYPE_MC_RAW
case|:
case|case
name|TYPE_MC_RAW_CHANNEL
case|:
case|case
name|TYPE_IP_COUNTER
case|:
case|case
name|TYPE_TCP_FLOW_COUNTER
case|:
case|case
name|TYPE_INFINIBAND
case|:
case|case
name|TYPE_RAW_LINK
case|:
case|case
name|TYPE_INFINIBAND_LINK
case|:
default|default:
comment|/* Libpcap cannot deal with these types yet */
comment|/* Add no 'native' DLTs, but still covered by DLT_ERF */
break|break;
block|}
comment|/* switch */
name|index
operator|++
expr_stmt|;
block|}
name|p
operator|->
name|dlt_list
index|[
name|dlt_index
operator|++
index|]
operator|=
name|DLT_ERF
expr_stmt|;
name|p
operator|->
name|dlt_count
operator|=
name|dlt_index
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|linktype
condition|)
name|p
operator|->
name|linktype
operator|=
name|DLT_ERF
expr_stmt|;
return|return
name|p
operator|->
name|linktype
return|;
block|}
ifdef|#
directive|ifdef
name|DAG_ONLY
comment|/*  * This libpcap build supports only DAG cards, not regular network  * interfaces.  */
comment|/*  * There are no regular interfaces, just DAG interfaces.  */
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
operator|*
name|alldevsp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Attempts to open a regular interface fail.  */
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"This version of libpcap only supports DAG cards"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

