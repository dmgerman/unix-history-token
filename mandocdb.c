begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mandocdb.c,v 1.49.2.10 2013/11/21 01:53:48 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011, 2012 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2011, 2012 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<libkern/OSByteOrder.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__linux__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<endian.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sun
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
name|defined
argument_list|(
name|__sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<db_185.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandocdb.h"
end_include

begin_include
include|#
directive|include
file|"manpath.h"
end_include

begin_define
define|#
directive|define
name|MANDOC_BUFSZ
value|BUFSIZ
end_define

begin_define
define|#
directive|define
name|MANDOC_SLOP
value|1024
end_define

begin_define
define|#
directive|define
name|MANDOC_SRC
value|0x1
end_define

begin_define
define|#
directive|define
name|MANDOC_FORM
value|0x2
end_define

begin_comment
comment|/* Access to the mandoc database on disk. */
end_comment

begin_struct
struct|struct
name|mdb
block|{
name|char
name|idxn
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* index db filename */
name|char
name|dbn
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* keyword db filename */
name|DB
modifier|*
name|idx
decl_stmt|;
comment|/* index recno database */
name|DB
modifier|*
name|db
decl_stmt|;
comment|/* keyword btree database */
block|}
struct|;
end_struct

begin_comment
comment|/* Stack of temporarily unused index records. */
end_comment

begin_struct
struct|struct
name|recs
block|{
name|recno_t
modifier|*
name|stack
decl_stmt|;
comment|/* pointer to a malloc'ed array */
name|size_t
name|size
decl_stmt|;
comment|/* number of allocated slots */
name|size_t
name|cur
decl_stmt|;
comment|/* current number of empty records */
name|recno_t
name|last
decl_stmt|;
comment|/* last record number in the index */
block|}
struct|;
end_struct

begin_comment
comment|/* Tiny list for files.  No need to bring in QUEUE. */
end_comment

begin_struct
struct|struct
name|of
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* heap-allocated */
name|char
modifier|*
name|sec
decl_stmt|;
name|char
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
name|int
name|src_form
decl_stmt|;
name|struct
name|of
modifier|*
name|next
decl_stmt|;
comment|/* NULL for last one */
name|struct
name|of
modifier|*
name|first
decl_stmt|;
comment|/* first in list */
block|}
struct|;
end_struct

begin_comment
comment|/* Buffer for storing growable data. */
end_comment

begin_struct
struct|struct
name|buf
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* current length */
name|size_t
name|size
decl_stmt|;
comment|/* total buffer size */
block|}
struct|;
end_struct

begin_comment
comment|/* Operation we're going to perform. */
end_comment

begin_enum
enum|enum
name|op
block|{
name|OP_DEFAULT
init|=
literal|0
block|,
comment|/* new dbs from dir list or default config */
name|OP_CONFFILE
block|,
comment|/* new databases from custom config file */
name|OP_UPDATE
block|,
comment|/* delete/add entries in existing database */
name|OP_DELETE
block|,
comment|/* delete entries from existing database */
name|OP_TEST
comment|/* change no databases, report potential problems */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|MAN_ARGS
value|DB *hash, \ 			  struct buf *buf, \ 			  struct buf *dbuf, \ 			  const struct man_node *n
end_define

begin_define
define|#
directive|define
name|MDOC_ARGS
value|DB *hash, \ 			  struct buf *buf, \ 			  struct buf *dbuf, \ 			  const struct mdoc_node *n, \ 			  const struct mdoc_meta *m
end_define

begin_function_decl
specifier|static
name|void
name|buf_appendmdoc
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|buf_append
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|buf_appendb
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbt_put
parameter_list|(
name|DB
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|DBT
modifier|*
parameter_list|,
name|DBT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_put
parameter_list|(
name|DB
modifier|*
parameter_list|,
specifier|const
name|struct
name|buf
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_reset
parameter_list|(
name|DB
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|index_merge
parameter_list|(
specifier|const
name|struct
name|of
modifier|*
parameter_list|,
name|struct
name|mparse
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|DB
modifier|*
parameter_list|,
name|struct
name|mdb
modifier|*
parameter_list|,
name|struct
name|recs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|index_prune
parameter_list|(
specifier|const
name|struct
name|of
modifier|*
parameter_list|,
name|struct
name|mdb
modifier|*
parameter_list|,
name|struct
name|recs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ofile_argbuild
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
index|[]
parameter_list|,
name|struct
name|of
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ofile_dirbuild
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|of
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ofile_free
parameter_list|(
name|struct
name|of
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pformatted
parameter_list|(
name|DB
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
specifier|const
name|struct
name|of
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pman_node
parameter_list|(
name|MAN_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmdoc_node
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_head
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_body
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_Fd
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_In
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_Fn
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_Nd
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_Nm
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_Sh
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_St
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmdoc_Xr
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MDOCF_CHILD
value|0x01
end_define

begin_comment
comment|/* Automatically index child nodes. */
end_comment

begin_struct
struct|struct
name|mdoc_handler
block|{
name|int
function_decl|(
modifier|*
name|fp
function_decl|)
parameter_list|(
name|MDOC_ARGS
parameter_list|)
function_decl|;
comment|/* Optional handler. */
name|uint64_t
name|mask
decl_stmt|;
comment|/* Set unless handler returns 0. */
name|int
name|flags
decl_stmt|;
comment|/* For use by pmdoc_node. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mdoc_handler
name|mdocs
index|[
name|MDOC_MAX
index|]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ap */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Dd */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Dt */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Os */
block|{
name|pmdoc_Sh
block|,
name|TYPE_Sh
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Sh */
block|{
name|pmdoc_head
block|,
name|TYPE_Ss
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Ss */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Pp */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* D1 */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Dl */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bd */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ed */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bl */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* El */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* It */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ad */
block|{
name|NULL
block|,
name|TYPE_An
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* An */
block|{
name|NULL
block|,
name|TYPE_Ar
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Ar */
block|{
name|NULL
block|,
name|TYPE_Cd
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Cd */
block|{
name|NULL
block|,
name|TYPE_Cm
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Cm */
block|{
name|NULL
block|,
name|TYPE_Dv
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Dv */
block|{
name|NULL
block|,
name|TYPE_Er
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Er */
block|{
name|NULL
block|,
name|TYPE_Ev
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Ev */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ex */
block|{
name|NULL
block|,
name|TYPE_Fa
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Fa */
block|{
name|pmdoc_Fd
block|,
name|TYPE_In
block|,
literal|0
block|}
block|,
comment|/* Fd */
block|{
name|NULL
block|,
name|TYPE_Fl
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Fl */
block|{
name|pmdoc_Fn
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Fn */
block|{
name|NULL
block|,
name|TYPE_Ft
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Ft */
block|{
name|NULL
block|,
name|TYPE_Ic
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Ic */
block|{
name|pmdoc_In
block|,
name|TYPE_In
block|,
literal|0
block|}
block|,
comment|/* In */
block|{
name|NULL
block|,
name|TYPE_Li
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Li */
block|{
name|pmdoc_Nd
block|,
name|TYPE_Nd
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Nd */
block|{
name|pmdoc_Nm
block|,
name|TYPE_Nm
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Nm */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Op */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ot */
block|{
name|NULL
block|,
name|TYPE_Pa
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Pa */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Rv */
block|{
name|pmdoc_St
block|,
name|TYPE_St
block|,
literal|0
block|}
block|,
comment|/* St */
block|{
name|NULL
block|,
name|TYPE_Va
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Va */
block|{
name|pmdoc_body
block|,
name|TYPE_Va
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Vt */
block|{
name|pmdoc_Xr
block|,
name|TYPE_Xr
block|,
literal|0
block|}
block|,
comment|/* Xr */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %A */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %B */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %D */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %I */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %J */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %N */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %O */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %P */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %R */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %T */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %V */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ac */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ao */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Aq */
block|{
name|NULL
block|,
name|TYPE_At
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* At */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bc */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bf */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bo */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bq */
block|{
name|NULL
block|,
name|TYPE_Bsx
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Bsx */
block|{
name|NULL
block|,
name|TYPE_Bx
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Bx */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Db */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Dc */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Do */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Dq */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ec */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ef */
block|{
name|NULL
block|,
name|TYPE_Em
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Em */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Eo */
block|{
name|NULL
block|,
name|TYPE_Fx
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Fx */
block|{
name|NULL
block|,
name|TYPE_Ms
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Ms */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* No */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ns */
block|{
name|NULL
block|,
name|TYPE_Nx
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Nx */
block|{
name|NULL
block|,
name|TYPE_Ox
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Ox */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Pc */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Pf */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Po */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Pq */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Qc */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ql */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Qo */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Qq */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Re */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Rs */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Sc */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* So */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Sq */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Sm */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Sx */
block|{
name|NULL
block|,
name|TYPE_Sy
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Sy */
block|{
name|NULL
block|,
name|TYPE_Tn
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Tn */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ux */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Xc */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Xo */
block|{
name|pmdoc_head
block|,
name|TYPE_Fn
block|,
literal|0
block|}
block|,
comment|/* Fo */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Fc */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Oo */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Oc */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bk */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ek */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bt */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Hf */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Fr */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ud */
block|{
name|NULL
block|,
name|TYPE_Lb
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Lb */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Lp */
block|{
name|NULL
block|,
name|TYPE_Lk
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Lk */
block|{
name|NULL
block|,
name|TYPE_Mt
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Mt */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Brq */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Bro */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Brc */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %C */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Es */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* En */
block|{
name|NULL
block|,
name|TYPE_Dx
block|,
name|MDOCF_CHILD
block|}
block|,
comment|/* Dx */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %Q */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* br */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* sp */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %U */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Ta */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_all
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use all directories and files. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output verbosity level. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Potential problems in manuals. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|mparse
modifier|*
name|mp
decl_stmt|;
comment|/* parse sequence */
name|struct
name|manpaths
name|dirs
decl_stmt|;
name|struct
name|mdb
name|mdb
decl_stmt|;
name|struct
name|recs
name|recs
decl_stmt|;
name|enum
name|op
name|op
decl_stmt|;
comment|/* current operation */
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|pbuf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|flags
decl_stmt|;
name|DB
modifier|*
name|hash
decl_stmt|;
comment|/* temporary keyword hashtable */
name|BTREEINFO
name|info
decl_stmt|;
comment|/* btree configuration */
name|size_t
name|sz1
decl_stmt|,
name|sz2
decl_stmt|,
name|ipath
decl_stmt|;
name|struct
name|buf
name|buf
decl_stmt|,
comment|/* keyword buffer */
name|dbuf
decl_stmt|;
comment|/* description buffer */
name|struct
name|of
modifier|*
name|of
decl_stmt|;
comment|/* list of files for processing */
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
operator|==
name|NULL
condition|)
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|++
name|progname
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dirs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpaths
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mdb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mdb
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|recs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|recs
argument_list|)
argument_list|)
expr_stmt|;
name|of
operator|=
name|NULL
expr_stmt|;
name|mp
operator|=
name|NULL
expr_stmt|;
name|hash
operator|=
name|NULL
expr_stmt|;
name|op
operator|=
name|OP_DEFAULT
expr_stmt|;
name|dir
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aC:d:tu:vW"
argument_list|)
operator|)
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
operator|(
literal|'a'
operator|)
case|:
name|use_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
literal|'C'
operator|)
case|:
if|if
condition|(
name|op
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-C: conflicting options\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|dir
operator|=
name|optarg
expr_stmt|;
name|op
operator|=
name|OP_CONFFILE
expr_stmt|;
break|break;
case|case
operator|(
literal|'d'
operator|)
case|:
if|if
condition|(
name|op
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-d: conflicting options\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|dir
operator|=
name|optarg
expr_stmt|;
name|op
operator|=
name|OP_UPDATE
expr_stmt|;
break|break;
case|case
operator|(
literal|'t'
operator|)
case|:
name|dup2
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-t: conflicting options\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|op
operator|=
name|OP_TEST
expr_stmt|;
name|use_all
operator|=
literal|1
expr_stmt|;
name|warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
literal|'u'
operator|)
case|:
if|if
condition|(
name|op
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-u: conflicting options\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|dir
operator|=
name|optarg
expr_stmt|;
name|op
operator|=
name|OP_DELETE
expr_stmt|;
break|break;
case|case
operator|(
literal|'v'
operator|)
case|:
name|verb
operator|++
expr_stmt|;
break|break;
case|case
operator|(
literal|'W'
operator|)
case|:
name|warnings
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|OP_CONFFILE
operator|==
name|op
operator|&&
name|argc
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-C: too many arguments\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|BTREEINFO
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|lorder
operator|=
literal|4321
expr_stmt|;
name|info
operator|.
name|flags
operator|=
name|R_DUP
expr_stmt|;
name|mp
operator|=
name|mparse_alloc
argument_list|(
name|MPARSE_AUTO
argument_list|,
name|MANDOCLEVEL_FATAL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|size
operator|=
name|dbuf
operator|.
name|size
operator|=
name|MANDOC_BUFSZ
expr_stmt|;
name|buf
operator|.
name|cp
operator|=
name|mandoc_malloc
argument_list|(
name|buf
operator|.
name|size
argument_list|)
expr_stmt|;
name|dbuf
operator|.
name|cp
operator|=
name|mandoc_malloc
argument_list|(
name|dbuf
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP_TEST
operator|==
name|op
condition|)
block|{
name|ofile_argbuild
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|of
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|of
condition|)
goto|goto
name|out
goto|;
name|index_merge
argument_list|(
name|of
argument_list|,
name|mp
argument_list|,
operator|&
name|dbuf
argument_list|,
operator|&
name|buf
argument_list|,
name|hash
argument_list|,
operator|&
name|mdb
argument_list|,
operator|&
name|recs
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|OP_UPDATE
operator|==
name|op
operator|||
name|OP_DELETE
operator|==
name|op
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|realpath
argument_list|(
name|dir
argument_list|,
name|pbuf
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlcat
argument_list|(
name|pbuf
argument_list|,
literal|"/"
argument_list|,
name|PATH_MAX
argument_list|)
operator|>=
name|PATH_MAX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: path too long\n"
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|,
name|pbuf
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|sz1
operator|=
name|strlcat
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|,
name|MANDOC_DB
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|,
name|pbuf
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|sz2
operator|=
name|strlcat
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|,
name|MANDOC_IDX
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz1
operator|>=
name|PATH_MAX
operator|||
name|sz2
operator|>=
name|PATH_MAX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: path too long\n"
argument_list|,
name|mdb
operator|.
name|idxn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|O_CREAT
operator||
name|O_RDWR
expr_stmt|;
name|mdb
operator|.
name|db
operator|=
name|dbopen
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|,
name|flags
argument_list|,
literal|0644
argument_list|,
name|DB_BTREE
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|mdb
operator|.
name|idx
operator|=
name|dbopen
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|,
name|flags
argument_list|,
literal|0644
argument_list|,
name|DB_RECNO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|mdb
operator|.
name|db
condition|)
block|{
name|perror
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NULL
operator|==
name|mdb
operator|.
name|idx
condition|)
block|{
name|perror
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
name|ofile_argbuild
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|of
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|of
condition|)
goto|goto
name|out
goto|;
name|index_prune
argument_list|(
name|of
argument_list|,
operator|&
name|mdb
argument_list|,
operator|&
name|recs
argument_list|)
expr_stmt|;
comment|/* 		 * Go to the root of the respective manual tree. 		 * This must work or no manuals may be found (they're 		 * indexed relative to the root). 		 */
if|if
condition|(
name|OP_UPDATE
operator|==
name|op
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|chdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
name|index_merge
argument_list|(
name|of
argument_list|,
name|mp
argument_list|,
operator|&
name|dbuf
argument_list|,
operator|&
name|buf
argument_list|,
name|hash
argument_list|,
operator|&
name|mdb
argument_list|,
operator|&
name|recs
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Configure the directories we're going to scan. 	 * If we have command-line arguments, use them. 	 * If not, we use man(1)'s method (see mandocdb.8). 	 */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|dirs
operator|.
name|paths
operator|=
name|mandoc_calloc
argument_list|(
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dirs
operator|.
name|sz
operator|=
name|argc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|cp
operator|=
name|realpath
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|pbuf
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dirs
operator|.
name|paths
index|[
name|i
index|]
operator|=
name|mandoc_strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|manpath_parse
argument_list|(
operator|&
name|dirs
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ipath
operator|=
literal|0
init|;
name|ipath
operator|<
name|dirs
operator|.
name|sz
condition|;
name|ipath
operator|++
control|)
block|{
comment|/* 		 * Go to the root of the respective manual tree. 		 * This must work or no manuals may be found: 		 * They are indexed relative to the root. 		 */
if|if
condition|(
operator|-
literal|1
operator|==
name|chdir
argument_list|(
name|dirs
operator|.
name|paths
index|[
name|ipath
index|]
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|dirs
operator|.
name|paths
index|[
name|ipath
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
comment|/* Create a new database in two temporary files. */
name|flags
operator|=
name|O_CREAT
operator||
name|O_EXCL
operator||
name|O_RDWR
expr_stmt|;
while|while
condition|(
name|NULL
operator|==
name|mdb
operator|.
name|db
condition|)
block|{
name|strlcpy
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|,
name|MANDOC_DB
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|,
literal|".XXXXXXXXXX"
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|mktemp
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
name|mdb
operator|.
name|db
operator|=
name|dbopen
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|,
name|flags
argument_list|,
literal|0644
argument_list|,
name|DB_BTREE
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|mdb
operator|.
name|db
operator|&&
name|EEXIST
operator|!=
name|errno
condition|)
block|{
name|perror
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|NULL
operator|==
name|mdb
operator|.
name|idx
condition|)
block|{
name|strlcpy
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|,
name|MANDOC_IDX
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|,
literal|".XXXXXXXXXX"
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|mktemp
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
name|mdb
operator|.
name|idx
operator|=
name|dbopen
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|,
name|flags
argument_list|,
literal|0644
argument_list|,
name|DB_RECNO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|mdb
operator|.
name|idx
operator|&&
name|EEXIST
operator|!=
name|errno
condition|)
block|{
name|perror
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Search for manuals and fill the new database. 		 */
name|ofile_dirbuild
argument_list|(
literal|"."
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
operator|&
name|of
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|of
condition|)
block|{
name|index_merge
argument_list|(
name|of
argument_list|,
name|mp
argument_list|,
operator|&
name|dbuf
argument_list|,
operator|&
name|buf
argument_list|,
name|hash
argument_list|,
operator|&
name|mdb
argument_list|,
operator|&
name|recs
argument_list|)
expr_stmt|;
name|ofile_free
argument_list|(
name|of
argument_list|)
expr_stmt|;
name|of
operator|=
name|NULL
expr_stmt|;
block|}
call|(
modifier|*
name|mdb
operator|.
name|db
operator|->
name|close
call|)
argument_list|(
name|mdb
operator|.
name|db
argument_list|)
expr_stmt|;
call|(
modifier|*
name|mdb
operator|.
name|idx
operator|->
name|close
call|)
argument_list|(
name|mdb
operator|.
name|idx
argument_list|)
expr_stmt|;
name|mdb
operator|.
name|db
operator|=
name|NULL
expr_stmt|;
name|mdb
operator|.
name|idx
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Replace the old database with the new one. 		 * This is not perfectly atomic, 		 * but i cannot think of a better way. 		 */
if|if
condition|(
operator|-
literal|1
operator|==
name|rename
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|,
name|MANDOC_DB
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|MANDOC_DB
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mdb
operator|.
name|dbn
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|rename
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|,
name|MANDOC_IDX
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|MANDOC_IDX
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|MANDOC_DB
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|MANDOC_IDX
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mdb
operator|.
name|idxn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|mdb
operator|.
name|db
condition|)
call|(
modifier|*
name|mdb
operator|.
name|db
operator|->
name|close
call|)
argument_list|(
name|mdb
operator|.
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdb
operator|.
name|idx
condition|)
call|(
modifier|*
name|mdb
operator|.
name|idx
operator|->
name|close
call|)
argument_list|(
name|mdb
operator|.
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
condition|)
call|(
modifier|*
name|hash
operator|->
name|close
call|)
argument_list|(
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
name|mparse_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|manpath_free
argument_list|(
operator|&
name|dirs
argument_list|)
expr_stmt|;
name|ofile_free
argument_list|(
name|of
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|.
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dbuf
operator|.
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|recs
operator|.
name|stack
argument_list|)
expr_stmt|;
return|return
operator|(
name|MANDOCLEVEL_OK
operator|)
return|;
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-avvv] [-C file] | dir ... | -t file ...\n"
literal|"                        -d dir [file ...] | "
literal|"-u dir [file ...]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
block|}
end_function

begin_function
name|void
name|index_merge
parameter_list|(
specifier|const
name|struct
name|of
modifier|*
name|of
parameter_list|,
name|struct
name|mparse
modifier|*
name|mp
parameter_list|,
name|struct
name|buf
modifier|*
name|dbuf
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
name|DB
modifier|*
name|hash
parameter_list|,
name|struct
name|mdb
modifier|*
name|mdb
parameter_list|,
name|struct
name|recs
modifier|*
name|recs
parameter_list|)
block|{
name|recno_t
name|rec
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|skip
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|val
decl_stmt|;
name|DB
modifier|*
name|files
decl_stmt|;
comment|/* temporary file name table */
name|struct
name|mdoc
modifier|*
name|mdoc
decl_stmt|;
name|struct
name|man
modifier|*
name|man
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|msec
decl_stmt|,
modifier|*
name|march
decl_stmt|,
modifier|*
name|mtitle
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|;
name|size_t
name|sv
decl_stmt|;
name|unsigned
name|seq
decl_stmt|;
name|uint64_t
name|vbuf
index|[
literal|2
index|]
decl_stmt|;
name|char
name|type
decl_stmt|;
specifier|static
name|char
name|emptystring
index|[]
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|warnings
condition|)
block|{
name|files
operator|=
name|NULL
expr_stmt|;
name|hash_reset
argument_list|(
operator|&
name|files
argument_list|)
expr_stmt|;
block|}
name|rec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|of
operator|=
name|of
operator|->
name|first
init|;
name|of
condition|;
name|of
operator|=
name|of
operator|->
name|next
control|)
block|{
name|fn
operator|=
name|of
operator|->
name|fname
expr_stmt|;
comment|/* 		 * Try interpreting the file as mdoc(7) or man(7) 		 * source code, unless it is already known to be 		 * formatted.  Fall back to formatted mode. 		 */
name|mparse_reset
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mdoc
operator|=
name|NULL
expr_stmt|;
name|man
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|MANDOC_SRC
operator|&
name|of
operator|->
name|src_form
operator|||
operator|!
operator|(
name|MANDOC_FORM
operator|&
name|of
operator|->
name|src_form
operator|)
operator|)
operator|&&
name|MANDOCLEVEL_FATAL
operator|>
name|mparse_readfd
argument_list|(
name|mp
argument_list|,
operator|-
literal|1
argument_list|,
name|fn
argument_list|)
condition|)
name|mparse_result
argument_list|(
name|mp
argument_list|,
operator|&
name|mdoc
argument_list|,
operator|&
name|man
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|mdoc
condition|)
block|{
name|msec
operator|=
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
operator|->
name|msec
expr_stmt|;
name|march
operator|=
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
operator|->
name|arch
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|march
condition|)
name|march
operator|=
literal|""
expr_stmt|;
name|mtitle
operator|=
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
operator|->
name|title
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NULL
operator|!=
name|man
condition|)
block|{
name|msec
operator|=
name|man_meta
argument_list|(
name|man
argument_list|)
operator|->
name|msec
expr_stmt|;
name|march
operator|=
literal|""
expr_stmt|;
name|mtitle
operator|=
name|man_meta
argument_list|(
name|man
argument_list|)
operator|->
name|title
expr_stmt|;
block|}
else|else
block|{
name|msec
operator|=
name|of
operator|->
name|sec
expr_stmt|;
name|march
operator|=
name|of
operator|->
name|arch
expr_stmt|;
name|mtitle
operator|=
name|of
operator|->
name|title
expr_stmt|;
block|}
comment|/* 		 * Check whether the manual section given in a file 		 * agrees with the directory where the file is located. 		 * Some manuals have suffixes like (3p) on their 		 * section number either inside the file or in the 		 * directory name, some are linked into more than one 		 * section, like encrypt(1) = makekey(8).  Do not skip 		 * manuals for such reasons. 		 */
name|skip
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|of
operator|->
name|sec
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|msec
argument_list|)
expr_stmt|;
if|if
condition|(
name|warnings
condition|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|msec
argument_list|,
name|of
operator|->
name|sec
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
literal|"section \"%s\" manual "
literal|"in \"%s\" directory\n"
argument_list|,
name|fn
argument_list|,
name|msec
argument_list|,
name|of
operator|->
name|sec
argument_list|)
expr_stmt|;
comment|/* 		 * Manual page directories exist for each kernel 		 * architecture as returned by machine(1). 		 * However, many manuals only depend on the 		 * application architecture as returned by arch(1). 		 * For example, some (2/ARM) manuals are shared 		 * across the "armish" and "zaurus" kernel 		 * architectures. 		 * A few manuals are even shared across completely 		 * different architectures, for example fdformat(1) 		 * on amd64, i386, sparc, and sparc64. 		 * Thus, warn about architecture mismatches, 		 * but don't skip manuals for this reason. 		 */
name|assert
argument_list|(
name|of
operator|->
name|arch
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|march
argument_list|)
expr_stmt|;
if|if
condition|(
name|warnings
condition|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|march
argument_list|,
name|of
operator|->
name|arch
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
literal|"architecture \"%s\" manual "
literal|"in \"%s\" directory\n"
argument_list|,
name|fn
argument_list|,
name|march
argument_list|,
name|of
operator|->
name|arch
argument_list|)
expr_stmt|;
comment|/* 		 * By default, skip a file if the title given 		 * in the file disagrees with the file name. 		 * Do not warn, this happens for all MLINKs. 		 */
name|assert
argument_list|(
name|of
operator|->
name|title
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mtitle
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|mtitle
argument_list|,
name|of
operator|->
name|title
argument_list|)
condition|)
name|skip
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Build a title string for the file.  If it matches 		 * the location of the file, remember the title as 		 * found; else, remember it as missing. 		 */
if|if
condition|(
name|warnings
condition|)
block|{
name|buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|mtitle
argument_list|,
name|strlen
argument_list|(
name|mtitle
argument_list|)
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
literal|"("
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|msec
argument_list|,
name|strlen
argument_list|(
name|msec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|march
condition|)
block|{
name|buf_appendb
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|march
argument_list|,
name|strlen
argument_list|(
name|march
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf_appendb
argument_list|(
name|buf
argument_list|,
literal|")"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
operator|->
name|cp
init|;
literal|'\0'
operator|!=
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
name|key
operator|.
name|data
operator|=
name|buf
operator|->
name|cp
expr_stmt|;
name|key
operator|.
name|size
operator|=
name|buf
operator|->
name|len
expr_stmt|;
name|val
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|val
operator|.
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|skip
condition|)
name|val
operator|.
name|data
operator|=
name|emptystring
expr_stmt|;
else|else
block|{
name|ch
operator|=
call|(
modifier|*
name|files
operator|->
name|get
call|)
argument_list|(
name|files
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"hash"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>
literal|0
condition|)
block|{
name|val
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|fn
expr_stmt|;
name|val
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|val
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|!=
name|val
operator|.
name|data
operator|&&
call|(
modifier|*
name|files
operator|->
name|put
call|)
argument_list|(
name|files
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"hash"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skip
operator|&&
operator|!
name|use_all
condition|)
continue|continue;
comment|/* 		 * The index record value consists of a nil-terminated 		 * filename, a nil-terminated manual section, and a 		 * nil-terminated description.  Use the actual 		 * location of the file, such that the user can find 		 * it with man(1).  Since the description may not be 		 * set, we set a sentinel to see if we're going to 		 * write a nil byte in its place. 		 */
name|dbuf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|mdoc
condition|?
literal|'d'
else|:
operator|(
name|man
condition|?
literal|'a'
else|:
literal|'c'
operator|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|dbuf
argument_list|,
operator|&
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|dbuf
argument_list|,
name|fn
argument_list|,
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|dbuf
argument_list|,
name|of
operator|->
name|sec
argument_list|,
name|strlen
argument_list|(
name|of
operator|->
name|sec
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|dbuf
argument_list|,
name|of
operator|->
name|title
argument_list|,
name|strlen
argument_list|(
name|of
operator|->
name|title
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|dbuf
argument_list|,
name|of
operator|->
name|arch
argument_list|,
name|strlen
argument_list|(
name|of
operator|->
name|arch
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sv
operator|=
name|dbuf
operator|->
name|len
expr_stmt|;
comment|/* 		 * Collect keyword/mask pairs. 		 * Each pair will become a new btree node. 		 */
name|hash_reset
argument_list|(
operator|&
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdoc
condition|)
name|pmdoc_node
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|dbuf
argument_list|,
name|mdoc_node
argument_list|(
name|mdoc
argument_list|)
argument_list|,
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|man
condition|)
name|pman_node
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|dbuf
argument_list|,
name|man_node
argument_list|(
name|man
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pformatted
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|dbuf
argument_list|,
name|of
argument_list|)
expr_stmt|;
comment|/* Test mode, do not access any database. */
if|if
condition|(
name|NULL
operator|==
name|mdb
operator|->
name|db
operator|||
name|NULL
operator|==
name|mdb
operator|->
name|idx
condition|)
continue|continue;
comment|/* 		 * Make sure the file name is always registered 		 * as an .Nm search key. 		 */
name|buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|buf_append
argument_list|(
name|buf
argument_list|,
name|of
operator|->
name|title
argument_list|)
expr_stmt|;
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|TYPE_Nm
argument_list|)
expr_stmt|;
comment|/* 		 * Reclaim an empty index record, if available. 		 * Use its record number for all new btree nodes. 		 */
if|if
condition|(
name|recs
operator|->
name|cur
operator|>
literal|0
condition|)
block|{
name|recs
operator|->
name|cur
operator|--
expr_stmt|;
name|rec
operator|=
name|recs
operator|->
name|stack
index|[
operator|(
name|int
operator|)
name|recs
operator|->
name|cur
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|recs
operator|->
name|last
operator|>
literal|0
condition|)
block|{
name|rec
operator|=
name|recs
operator|->
name|last
expr_stmt|;
name|recs
operator|->
name|last
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|rec
operator|++
expr_stmt|;
name|vbuf
index|[
literal|1
index|]
operator|=
name|htobe64
argument_list|(
name|rec
argument_list|)
expr_stmt|;
comment|/* 		 * Copy from the in-memory hashtable of pending 		 * keyword/mask pairs into the database. 		 */
name|seq
operator|=
name|R_FIRST
expr_stmt|;
while|while
condition|(
literal|0
operator|==
operator|(
name|ch
operator|=
call|(
modifier|*
name|hash
operator|->
name|seq
call|)
argument_list|(
name|hash
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
name|seq
argument_list|)
operator|)
condition|)
block|{
name|seq
operator|=
name|R_NEXT
expr_stmt|;
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|==
name|val
operator|.
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mask
argument_list|,
name|val
operator|.
name|data
argument_list|,
name|val
operator|.
name|size
argument_list|)
expr_stmt|;
name|vbuf
index|[
literal|0
index|]
operator|=
name|htobe64
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|val
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|vbuf
argument_list|)
expr_stmt|;
name|val
operator|.
name|data
operator|=
operator|&
name|vbuf
expr_stmt|;
name|dbt_put
argument_list|(
name|mdb
operator|->
name|db
argument_list|,
name|mdb
operator|->
name|dbn
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"hash"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mdb
operator|->
name|dbn
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mdb
operator|->
name|idxn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Apply to the index.  If we haven't had a description 		 * set, put an empty one in now. 		 */
if|if
condition|(
name|dbuf
operator|->
name|len
operator|==
name|sv
condition|)
name|buf_appendb
argument_list|(
name|dbuf
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|key
operator|.
name|data
operator|=
operator|&
name|rec
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
expr_stmt|;
name|val
operator|.
name|data
operator|=
name|dbuf
operator|->
name|cp
expr_stmt|;
name|val
operator|.
name|size
operator|=
name|dbuf
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: adding to index\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|dbt_put
argument_list|(
name|mdb
operator|->
name|idx
argument_list|,
name|mdb
operator|->
name|idxn
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Iterate the remembered file titles and check that 	 * all files can be found by their main title. 	 */
if|if
condition|(
name|warnings
condition|)
block|{
name|seq
operator|=
name|R_FIRST
expr_stmt|;
while|while
condition|(
literal|0
operator|==
call|(
modifier|*
name|files
operator|->
name|seq
call|)
argument_list|(
name|files
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
name|seq
argument_list|)
condition|)
block|{
name|seq
operator|=
name|R_NEXT
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: probably "
literal|"unreachable, title is %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|val
operator|.
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|files
operator|->
name|close
call|)
argument_list|(
name|files
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Scan through all entries in the index file `idx' and prune those  * entries in `ofile'.  * Pruning consists of removing from `db', then invalidating the entry  * in `idx' (zeroing its value size).  */
end_comment

begin_function
specifier|static
name|void
name|index_prune
parameter_list|(
specifier|const
name|struct
name|of
modifier|*
name|ofile
parameter_list|,
name|struct
name|mdb
modifier|*
name|mdb
parameter_list|,
name|struct
name|recs
modifier|*
name|recs
parameter_list|)
block|{
specifier|const
name|struct
name|of
modifier|*
name|of
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
name|uint64_t
name|vbuf
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|seq
decl_stmt|,
name|sseq
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|val
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|recs
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|seq
operator|=
name|R_FIRST
expr_stmt|;
while|while
condition|(
literal|0
operator|==
operator|(
name|ch
operator|=
call|(
modifier|*
name|mdb
operator|->
name|idx
operator|->
name|seq
call|)
argument_list|(
name|mdb
operator|->
name|idx
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
name|seq
argument_list|)
operator|)
condition|)
block|{
name|seq
operator|=
name|R_NEXT
expr_stmt|;
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
operator|==
name|key
operator|.
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|recs
operator|->
name|last
argument_list|,
name|key
operator|.
name|data
argument_list|,
name|key
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* Deleted records are zero-sized.  Skip them. */
if|if
condition|(
literal|0
operator|==
name|val
operator|.
name|size
condition|)
goto|goto
name|cont
goto|;
comment|/* 		 * Make sure we're sane. 		 * Read past our mdoc/man/cat type to the next string, 		 * then make sure it's bounded by a NUL. 		 * Failing any of these, we go into our error handler. 		 */
name|fn
operator|=
operator|(
name|char
operator|*
operator|)
name|val
operator|.
name|data
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|memchr
argument_list|(
name|fn
argument_list|,
literal|'\0'
argument_list|,
name|val
operator|.
name|size
operator|-
literal|1
argument_list|)
condition|)
break|break;
comment|/* 		 * Search for the file in those we care about. 		 * XXX: build this into a tree.  Too slow. 		 */
for|for
control|(
name|of
operator|=
name|ofile
operator|->
name|first
init|;
name|of
condition|;
name|of
operator|=
name|of
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|fn
argument_list|,
name|of
operator|->
name|fname
argument_list|)
condition|)
break|break;
if|if
condition|(
name|NULL
operator|==
name|of
condition|)
continue|continue;
comment|/* 		 * Search through the keyword database, throwing out all 		 * references to our file. 		 */
name|sseq
operator|=
name|R_FIRST
expr_stmt|;
while|while
condition|(
literal|0
operator|==
operator|(
name|ch
operator|=
call|(
modifier|*
name|mdb
operator|->
name|db
operator|->
name|seq
call|)
argument_list|(
name|mdb
operator|->
name|db
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
name|sseq
argument_list|)
operator|)
condition|)
block|{
name|sseq
operator|=
name|R_NEXT
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|vbuf
argument_list|)
operator|!=
name|val
operator|.
name|size
condition|)
break|break;
name|memcpy
argument_list|(
name|vbuf
argument_list|,
name|val
operator|.
name|data
argument_list|,
name|val
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|recs
operator|->
name|last
operator|!=
name|betoh64
argument_list|(
name|vbuf
index|[
literal|1
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ch
operator|=
call|(
modifier|*
name|mdb
operator|->
name|db
operator|->
name|del
call|)
argument_list|(
name|mdb
operator|->
name|db
argument_list|,
operator|&
name|key
argument_list|,
name|R_CURSOR
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|mdb
operator|->
name|dbn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|!=
name|ch
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: corrupt database\n"
argument_list|,
name|mdb
operator|->
name|dbn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"%s: deleting from index\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|val
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
call|(
modifier|*
name|mdb
operator|->
name|idx
operator|->
name|put
call|)
argument_list|(
name|mdb
operator|->
name|idx
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
name|R_CURSOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
break|break;
name|cont
label|:
if|if
condition|(
name|recs
operator|->
name|cur
operator|>=
name|recs
operator|->
name|size
condition|)
block|{
name|recs
operator|->
name|size
operator|+=
name|MANDOC_SLOP
expr_stmt|;
name|recs
operator|->
name|stack
operator|=
name|mandoc_realloc
argument_list|(
name|recs
operator|->
name|stack
argument_list|,
name|recs
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|recno_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|recs
operator|->
name|stack
index|[
operator|(
name|int
operator|)
name|recs
operator|->
name|cur
index|]
operator|=
name|recs
operator|->
name|last
expr_stmt|;
name|recs
operator|->
name|cur
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|mdb
operator|->
name|idxn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|!=
name|ch
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: corrupt index\n"
argument_list|,
name|mdb
operator|->
name|idxn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
name|recs
operator|->
name|last
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grow the buffer (if necessary) and copy in a binary string.  */
end_comment

begin_function
specifier|static
name|void
name|buf_appendb
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|void
modifier|*
name|cp
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
comment|/* Overshoot by MANDOC_BUFSZ. */
while|while
condition|(
name|buf
operator|->
name|len
operator|+
name|sz
operator|>=
name|buf
operator|->
name|size
condition|)
block|{
name|buf
operator|->
name|size
operator|=
name|buf
operator|->
name|len
operator|+
name|sz
operator|+
name|MANDOC_BUFSZ
expr_stmt|;
name|buf
operator|->
name|cp
operator|=
name|mandoc_realloc
argument_list|(
name|buf
operator|->
name|cp
argument_list|,
name|buf
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf
operator|->
name|cp
operator|+
operator|(
name|int
operator|)
name|buf
operator|->
name|len
argument_list|,
name|cp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|buf
operator|->
name|len
operator|+=
name|sz
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a nil-terminated string to the buffer.    * This can be invoked multiple times.    * The buffer string will be nil-terminated.  * If invoked multiple times, a space is put between strings.  */
end_comment

begin_function
specifier|static
name|void
name|buf_append
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|sz
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|buf
operator|->
name|len
condition|)
name|buf
operator|->
name|cp
index|[
operator|(
name|int
operator|)
name|buf
operator|->
name|len
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recursively add all text from a given node.    * This is optimised for general mdoc nodes in this context, which do  * not consist of subexpressions and having a recursive call for n->next  * would be wasteful.  * The "f" variable should be 0 unless called from pmdoc_Nd for the  * description buffer, which does not start at the beginning of the  * buffer.  */
end_comment

begin_function
specifier|static
name|void
name|buf_appendmdoc
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|,
name|int
name|f
parameter_list|)
block|{
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|child
condition|)
name|buf_appendmdoc
argument_list|(
name|buf
argument_list|,
name|n
operator|->
name|child
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_TEXT
operator|==
name|n
operator|->
name|type
operator|&&
name|f
condition|)
block|{
name|f
operator|=
literal|0
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|n
operator|->
name|string
argument_list|,
name|strlen
argument_list|(
name|n
operator|->
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MDOC_TEXT
operator|==
name|n
operator|->
name|type
condition|)
name|buf_append
argument_list|(
name|buf
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hash_reset
parameter_list|(
name|DB
modifier|*
modifier|*
name|db
parameter_list|)
block|{
name|DB
modifier|*
name|hash
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|hash
operator|=
operator|*
name|db
operator|)
condition|)
call|(
modifier|*
name|hash
operator|->
name|close
call|)
argument_list|(
name|hash
argument_list|)
expr_stmt|;
operator|*
name|db
operator|=
name|dbopen
argument_list|(
name|NULL
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
argument_list|,
literal|0644
argument_list|,
name|DB_HASH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|*
name|db
condition|)
block|{
name|perror
argument_list|(
literal|"hash"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_head
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
return|return
operator|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_body
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
return|return
operator|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_Fd
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|SEC_SYNOPSIS
operator|!=
name|n
operator|->
name|sec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|child
operator|)
operator|||
name|MDOC_TEXT
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Only consider those `Fd' macro fields that begin with an 	 * "inclusion" token (versus, e.g., #define). 	 */
if|if
condition|(
name|strcmp
argument_list|(
literal|"#include"
argument_list|,
name|n
operator|->
name|string
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|next
operator|)
operator|||
name|MDOC_TEXT
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Strip away the enclosing angle brackets and make sure we're 	 * not zero-length. 	 */
name|start
operator|=
name|n
operator|->
name|string
expr_stmt|;
if|if
condition|(
literal|'<'
operator|==
operator|*
name|start
operator|||
literal|'"'
operator|==
operator|*
name|start
condition|)
name|start
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|sz
operator|=
name|strlen
argument_list|(
name|start
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|end
operator|=
operator|&
name|start
index|[
operator|(
name|int
operator|)
name|sz
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
literal|'>'
operator|==
operator|*
name|end
operator|||
literal|'"'
operator|==
operator|*
name|end
condition|)
name|end
operator|--
expr_stmt|;
name|assert
argument_list|(
name|end
operator|>=
name|start
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|start
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|end
operator|-
name|start
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_In
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
operator|||
name|MDOC_TEXT
operator|!=
name|n
operator|->
name|child
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|buf_append
argument_list|(
name|buf
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_Fn
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
name|struct
name|mdoc_node
modifier|*
name|nn
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|nn
operator|=
name|n
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|nn
operator|||
name|MDOC_TEXT
operator|!=
name|nn
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* .Fn "struct type *name" "char *arg" */
name|cp
operator|=
name|strrchr
argument_list|(
name|nn
operator|->
name|string
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|cp
condition|)
name|cp
operator|=
name|nn
operator|->
name|string
expr_stmt|;
comment|/* Strip away pointer symbol. */
while|while
condition|(
literal|'*'
operator|==
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* Store the function name. */
name|buf_append
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|TYPE_Fn
argument_list|)
expr_stmt|;
comment|/* Store the function type. */
if|if
condition|(
name|nn
operator|->
name|string
operator|<
name|cp
condition|)
block|{
name|buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|nn
operator|->
name|string
argument_list|,
name|cp
operator|-
name|nn
operator|->
name|string
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|TYPE_Ft
argument_list|)
expr_stmt|;
block|}
comment|/* Store the arguments. */
for|for
control|(
name|nn
operator|=
name|nn
operator|->
name|next
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|MDOC_TEXT
operator|!=
name|nn
operator|->
name|type
condition|)
continue|continue;
name|buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|buf_append
argument_list|(
name|buf
argument_list|,
name|nn
operator|->
name|string
argument_list|)
expr_stmt|;
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|TYPE_Fa
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_St
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
operator|||
name|MDOC_TEXT
operator|!=
name|n
operator|->
name|child
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|buf_append
argument_list|(
name|buf
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_Xr
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|child
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|n
operator|->
name|string
argument_list|,
name|strlen
argument_list|(
name|n
operator|->
name|string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|n
operator|=
name|n
operator|->
name|next
operator|)
condition|)
block|{
name|buf_appendb
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|n
operator|->
name|string
argument_list|,
name|strlen
argument_list|(
name|n
operator|->
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|buf_appendb
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_Nd
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BODY
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|buf_appendmdoc
argument_list|(
name|dbuf
argument_list|,
name|n
operator|->
name|child
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_Nm
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
if|if
condition|(
name|SEC_NAME
operator|==
name|n
operator|->
name|sec
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|SEC_SYNOPSIS
operator|!=
name|n
operator|->
name|sec
operator|||
name|MDOC_HEAD
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
name|buf_append
argument_list|(
name|buf
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pmdoc_Sh
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
return|return
operator|(
name|SEC_CUSTOM
operator|==
name|n
operator|->
name|sec
operator|&&
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_put
parameter_list|(
name|DB
modifier|*
name|db
parameter_list|,
specifier|const
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|mask
parameter_list|)
block|{
name|uint64_t
name|oldmask
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|val
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|<
literal|2
condition|)
return|return;
name|key
operator|.
name|data
operator|=
name|buf
operator|->
name|cp
expr_stmt|;
name|key
operator|.
name|size
operator|=
name|buf
operator|->
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
call|(
modifier|*
name|db
operator|->
name|get
call|)
argument_list|(
name|db
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"hash"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|rc
condition|)
block|{
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|==
name|val
operator|.
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|oldmask
argument_list|,
name|val
operator|.
name|data
argument_list|,
name|val
operator|.
name|size
argument_list|)
expr_stmt|;
name|mask
operator||=
name|oldmask
expr_stmt|;
block|}
name|val
operator|.
name|data
operator|=
operator|&
name|mask
expr_stmt|;
name|val
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
call|(
modifier|*
name|db
operator|->
name|put
call|)
argument_list|(
name|db
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"hash"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dbt_put
parameter_list|(
name|DB
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|dbn
parameter_list|,
name|DBT
modifier|*
name|key
parameter_list|,
name|DBT
modifier|*
name|val
parameter_list|)
block|{
name|assert
argument_list|(
name|key
operator|->
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|val
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
call|(
modifier|*
name|db
operator|->
name|put
call|)
argument_list|(
name|db
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|perror
argument_list|(
name|dbn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Call out to per-macro handlers after clearing the persistent database  * key.  If the macro sets the database key, flush it to the database.  */
end_comment

begin_function
specifier|static
name|void
name|pmdoc_node
parameter_list|(
name|MDOC_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|MDOC_HEAD
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|MDOC_BODY
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|MDOC_TAIL
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|MDOC_BLOCK
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|MDOC_ELEM
operator|)
case|:
name|buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Both NULL handlers and handlers returning true 		 * request using the data.  Only skip the element 		 * when the handler returns false. 		 */
if|if
condition|(
name|NULL
operator|!=
name|mdocs
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|fp
operator|&&
literal|0
operator|==
operator|(
operator|*
name|mdocs
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|fp
operator|)
operator|(
name|hash
operator|,
name|buf
operator|,
name|dbuf
operator|,
name|n
operator|,
name|m
operator|)
condition|)
break|break;
comment|/* 		 * For many macros, use the text from all children. 		 * Set zero flags for macros not needing this. 		 * In that case, the handler must fill the buffer. 		 */
if|if
condition|(
name|MDOCF_CHILD
operator|&
name|mdocs
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|flags
condition|)
name|buf_appendmdoc
argument_list|(
name|buf
argument_list|,
name|n
operator|->
name|child
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Cover the most common case: 		 * Automatically stage one string per element. 		 * Set a zero mask for macros not needing this. 		 * Additional staging can be done in the handler. 		 */
if|if
condition|(
name|mdocs
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|mask
condition|)
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|mdocs
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|pmdoc_node
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|dbuf
argument_list|,
name|n
operator|->
name|child
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|pmdoc_node
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|dbuf
argument_list|,
name|n
operator|->
name|next
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pman_node
parameter_list|(
name|MAN_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|man_node
modifier|*
name|head
decl_stmt|,
modifier|*
name|body
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|sv
decl_stmt|,
modifier|*
name|title
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|titlesz
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We're only searching for one thing: the first text child in 	 * the BODY of a NAME section.  Since we don't keep track of 	 * sections in -man, run some hoops to find out whether we're in 	 * the correct section or not. 	 */
if|if
condition|(
name|MAN_BODY
operator|==
name|n
operator|->
name|type
operator|&&
name|MAN_SH
operator|==
name|n
operator|->
name|tok
condition|)
block|{
name|body
operator|=
name|n
expr_stmt|;
name|assert
argument_list|(
name|body
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|head
operator|=
name|body
operator|->
name|parent
operator|->
name|head
operator|)
operator|&&
literal|1
operator|==
name|head
operator|->
name|nchild
operator|&&
name|NULL
operator|!=
operator|(
name|head
operator|=
operator|(
name|head
operator|->
name|child
operator|)
operator|)
operator|&&
name|MAN_TEXT
operator|==
name|head
operator|->
name|type
operator|&&
literal|0
operator|==
name|strcmp
argument_list|(
name|head
operator|->
name|string
argument_list|,
literal|"NAME"
argument_list|)
operator|&&
name|NULL
operator|!=
operator|(
name|body
operator|=
name|body
operator|->
name|child
operator|)
operator|&&
name|MAN_TEXT
operator|==
name|body
operator|->
name|type
condition|)
block|{
name|title
operator|=
name|NULL
expr_stmt|;
name|titlesz
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Suck the entire NAME section into memory. 			 * Yes, we might run away. 			 * But too many manuals have big, spread-out 			 * NAME sections over many lines. 			 */
for|for
control|(
init|;
name|NULL
operator|!=
name|body
condition|;
name|body
operator|=
name|body
operator|->
name|next
control|)
block|{
if|if
condition|(
name|MAN_TEXT
operator|!=
name|body
operator|->
name|type
condition|)
break|break;
if|if
condition|(
literal|0
operator|==
operator|(
name|sz
operator|=
name|strlen
argument_list|(
name|body
operator|->
name|string
argument_list|)
operator|)
condition|)
continue|continue;
name|title
operator|=
name|mandoc_realloc
argument_list|(
name|title
argument_list|,
name|titlesz
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|title
operator|+
name|titlesz
argument_list|,
name|body
operator|->
name|string
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|titlesz
operator|+=
name|sz
operator|+
literal|1
expr_stmt|;
name|title
index|[
operator|(
name|int
operator|)
name|titlesz
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|title
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|title
operator|=
name|mandoc_realloc
argument_list|(
name|title
argument_list|,
name|titlesz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|title
index|[
operator|(
name|int
operator|)
name|titlesz
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip leading space.  */
name|sv
operator|=
name|title
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|sv
argument_list|)
condition|)
name|sv
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|sz
operator|=
name|strlen
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Erase trailing space. */
name|start
operator|=
operator|&
name|sv
index|[
name|sz
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|start
operator|>
name|sv
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|start
argument_list|)
condition|)
operator|*
name|start
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|sv
condition|)
block|{
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|start
operator|=
name|sv
expr_stmt|;
comment|/*  			 * Go through a special heuristic dance here. 			 * This is why -man manuals are great! 			 * (I'm being sarcastic: my eyes are bleeding.) 			 * Conventionally, one or more manual names are 			 * comma-specified prior to a whitespace, then a 			 * dash, then a description.  Try to puzzle out 			 * the name parts here. 			 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|sz
operator|=
name|strcspn
argument_list|(
name|start
argument_list|,
literal|" ,"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|start
index|[
operator|(
name|int
operator|)
name|sz
index|]
condition|)
break|break;
name|buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|TYPE_Nm
argument_list|)
expr_stmt|;
if|if
condition|(
literal|' '
operator|==
name|start
index|[
operator|(
name|int
operator|)
name|sz
index|]
condition|)
block|{
name|start
operator|+=
operator|(
name|int
operator|)
name|sz
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
literal|','
operator|==
name|start
index|[
operator|(
name|int
operator|)
name|sz
index|]
argument_list|)
expr_stmt|;
name|start
operator|+=
operator|(
name|int
operator|)
name|sz
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
operator|*
name|start
condition|)
name|start
operator|++
expr_stmt|;
block|}
name|buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sv
operator|==
name|start
condition|)
block|{
name|buf_append
argument_list|(
name|buf
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|start
argument_list|)
condition|)
name|start
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
condition|)
name|start
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"\\-\\-"
argument_list|,
literal|4
argument_list|)
condition|)
name|start
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"\\-"
argument_list|,
literal|2
argument_list|)
condition|)
name|start
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"\\(en"
argument_list|,
literal|4
argument_list|)
condition|)
name|start
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"\\(em"
argument_list|,
literal|4
argument_list|)
condition|)
name|start
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
operator|*
name|start
condition|)
name|start
operator|++
expr_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|start
argument_list|)
operator|+
literal|1
expr_stmt|;
name|buf_appendb
argument_list|(
name|dbuf
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|TYPE_Nd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|n
operator|=
name|n
operator|->
name|child
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
name|pman_node
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|dbuf
argument_list|,
name|n
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a formatted manual page.  * By necessity, this involves rather crude guesswork.  */
end_comment

begin_function
specifier|static
name|void
name|pformatted
parameter_list|(
name|DB
modifier|*
name|hash
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
name|struct
name|buf
modifier|*
name|dbuf
parameter_list|,
specifier|const
name|struct
name|of
modifier|*
name|of
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|title
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|plen
decl_stmt|,
name|titlesz
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|stream
operator|=
name|fopen
argument_list|(
name|of
operator|->
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|perror
argument_list|(
name|of
operator|->
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Always use the title derived from the filename up front, 	 * do not even try to find it in the file.  This also makes 	 * sure we don't end up with an orphan index record, even if 	 * the file content turns out to be completely unintelligible. 	 */
name|buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|buf_append
argument_list|(
name|buf
argument_list|,
name|of
operator|->
name|title
argument_list|)
expr_stmt|;
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|TYPE_Nm
argument_list|)
expr_stmt|;
comment|/* Skip to first blank line. */
while|while
condition|(
name|NULL
operator|!=
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|stream
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
if|if
condition|(
literal|'\n'
operator|==
operator|*
name|line
condition|)
break|break;
comment|/* 	 * Assume the first line that is not indented 	 * is the first section header.  Skip to it. 	 */
while|while
condition|(
name|NULL
operator|!=
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|stream
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
if|if
condition|(
literal|'\n'
operator|!=
operator|*
name|line
operator|&&
literal|' '
operator|!=
operator|*
name|line
condition|)
break|break;
comment|/* 	 * Read up until the next section into a buffer. 	 * Strip the leading and trailing newline from each read line, 	 * appending a trailing space. 	 * Ignore empty (whitespace-only) lines. 	 */
name|titlesz
operator|=
literal|0
expr_stmt|;
name|title
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|stream
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
literal|' '
operator|!=
operator|*
name|line
operator|||
literal|'\n'
operator|!=
name|line
index|[
operator|(
name|int
operator|)
name|len
operator|-
literal|1
index|]
condition|)
break|break;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
literal|1
operator|==
name|len
condition|)
continue|continue;
name|title
operator|=
name|mandoc_realloc
argument_list|(
name|title
argument_list|,
name|titlesz
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|title
operator|+
name|titlesz
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|titlesz
operator|+=
name|len
expr_stmt|;
name|title
index|[
operator|(
name|int
operator|)
name|titlesz
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* 	 * If no page content can be found, or the input line 	 * is already the next section header, or there is no 	 * trailing newline, reuse the page title as the page 	 * description. 	 */
if|if
condition|(
name|NULL
operator|==
name|title
operator|||
literal|'\0'
operator|==
operator|*
name|title
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot find NAME section\n"
argument_list|,
name|of
operator|->
name|fname
argument_list|)
expr_stmt|;
name|buf_appendb
argument_list|(
name|dbuf
argument_list|,
name|buf
operator|->
name|cp
argument_list|,
name|buf
operator|->
name|size
argument_list|)
expr_stmt|;
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|TYPE_Nd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
return|return;
block|}
name|title
operator|=
name|mandoc_realloc
argument_list|(
name|title
argument_list|,
name|titlesz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|title
index|[
operator|(
name|int
operator|)
name|titlesz
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Skip to the first dash. 	 * Use the remaining line as the description (no more than 70 	 * bytes). 	 */
if|if
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|strstr
argument_list|(
name|title
argument_list|,
literal|"- "
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|p
operator|+=
literal|2
init|;
literal|' '
operator|==
operator|*
name|p
operator|||
literal|'\b'
operator|==
operator|*
name|p
condition|;
name|p
operator|++
control|)
comment|/* Skip to next word. */
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no dash in title line\n"
argument_list|,
name|of
operator|->
name|fname
argument_list|)
expr_stmt|;
name|p
operator|=
name|title
expr_stmt|;
block|}
name|plen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Strip backspace-encoding from line. */
while|while
condition|(
name|NULL
operator|!=
operator|(
name|line
operator|=
name|memchr
argument_list|(
name|p
argument_list|,
literal|'\b'
argument_list|,
name|plen
argument_list|)
operator|)
condition|)
block|{
name|len
operator|=
name|line
operator|-
name|p
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|len
condition|)
block|{
name|memmove
argument_list|(
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|plen
operator|--
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|memmove
argument_list|(
name|line
operator|-
literal|1
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|plen
operator|-
name|len
argument_list|)
expr_stmt|;
name|plen
operator|-=
literal|2
expr_stmt|;
block|}
name|buf_appendb
argument_list|(
name|dbuf
argument_list|,
name|p
argument_list|,
name|plen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|buf_appendb
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
name|plen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hash_put
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|TYPE_Nd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ofile_argbuild
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|struct
name|of
modifier|*
modifier|*
name|of
parameter_list|,
specifier|const
name|char
modifier|*
name|basedir
parameter_list|)
block|{
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|pbuf
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|sec
decl_stmt|,
modifier|*
name|arch
decl_stmt|,
modifier|*
name|title
decl_stmt|;
name|char
modifier|*
name|relpath
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|src_form
decl_stmt|;
name|struct
name|of
modifier|*
name|nof
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|relpath
operator|=
name|realpath
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|pbuf
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|NULL
operator|!=
name|basedir
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|pbuf
argument_list|,
name|basedir
argument_list|)
operator|!=
name|pbuf
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: file outside "
literal|"base directory %s\n"
argument_list|,
name|pbuf
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|relpath
operator|=
name|pbuf
operator|+
name|strlen
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Try to infer the manual section, architecture and 		 * page title from the path, assuming it looks like 		 *   man*[/<arch>]/<title>.<section>   or 		 *   cat<section>[/<arch>]/<title>.0 		 */
if|if
condition|(
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|relpath
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: path too long\n"
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sec
operator|=
name|arch
operator|=
name|title
operator|=
literal|""
expr_stmt|;
name|src_form
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|--
operator|>
name|buf
condition|)
block|{
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|sec
operator|&&
literal|'.'
operator|==
operator|*
name|p
condition|)
block|{
name|sec
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
literal|'0'
operator|==
operator|*
name|sec
condition|)
name|src_form
operator||=
name|MANDOC_FORM
expr_stmt|;
elseif|else
if|if
condition|(
literal|'1'
operator|<=
operator|*
name|sec
operator|&&
literal|'9'
operator|>=
operator|*
name|sec
condition|)
name|src_form
operator||=
name|MANDOC_SRC
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
literal|'/'
operator|!=
operator|*
name|p
condition|)
continue|continue;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|title
condition|)
block|{
name|title
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"man"
argument_list|,
name|p
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
condition|)
name|src_form
operator||=
name|MANDOC_SRC
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"cat"
argument_list|,
name|p
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
condition|)
name|src_form
operator||=
name|MANDOC_FORM
expr_stmt|;
else|else
name|arch
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|title
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot deduce title "
literal|"from filename\n"
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
name|title
operator|=
name|buf
expr_stmt|;
block|}
comment|/* 		 * Build the file structure. 		 */
name|nof
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|of
argument_list|)
argument_list|)
expr_stmt|;
name|nof
operator|->
name|fname
operator|=
name|mandoc_strdup
argument_list|(
name|relpath
argument_list|)
expr_stmt|;
name|nof
operator|->
name|sec
operator|=
name|mandoc_strdup
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|nof
operator|->
name|arch
operator|=
name|mandoc_strdup
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|nof
operator|->
name|title
operator|=
name|mandoc_strdup
argument_list|(
name|title
argument_list|)
expr_stmt|;
name|nof
operator|->
name|src_form
operator|=
name|src_form
expr_stmt|;
comment|/* 		 * Add the structure to the list. 		 */
if|if
condition|(
name|NULL
operator|==
operator|*
name|of
condition|)
block|{
operator|*
name|of
operator|=
name|nof
expr_stmt|;
operator|(
operator|*
name|of
operator|)
operator|->
name|first
operator|=
name|nof
expr_stmt|;
block|}
else|else
block|{
name|nof
operator|->
name|first
operator|=
operator|(
operator|*
name|of
operator|)
operator|->
name|first
expr_stmt|;
operator|(
operator|*
name|of
operator|)
operator|->
name|next
operator|=
name|nof
expr_stmt|;
operator|*
name|of
operator|=
name|nof
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Recursively build up a list of files to parse.  * We use this instead of ftw() and so on because I don't want global  * variables hanging around.  * This ignores the mandoc.db and mandoc.index files, but assumes that  * everything else is a manual.  * Pass in a pointer to a NULL structure for the first invocation.  */
end_comment

begin_function
specifier|static
name|void
name|ofile_dirbuild
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|psec
parameter_list|,
specifier|const
name|char
modifier|*
name|parch
parameter_list|,
name|int
name|p_src_form
parameter_list|,
name|struct
name|of
modifier|*
modifier|*
name|of
parameter_list|)
block|{
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
name|struct
name|stat
name|sb
decl_stmt|;
endif|#
directive|endif
name|size_t
name|sz
decl_stmt|;
name|DIR
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|sec
decl_stmt|,
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|struct
name|of
modifier|*
name|nof
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|int
name|src_form
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|d
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|perror
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|NULL
operator|!=
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
condition|)
block|{
name|fn
operator|=
name|dp
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
literal|'.'
operator|==
operator|*
name|fn
condition|)
continue|continue;
name|src_form
operator|=
name|p_src_form
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
name|stat
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IFDIR
operator|&
name|sb
operator|.
name|st_mode
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|DT_DIR
operator|==
name|dp
operator|->
name|d_type
condition|)
block|{
endif|#
directive|endif
name|sec
operator|=
name|psec
expr_stmt|;
name|arch
operator|=
name|parch
expr_stmt|;
comment|/* 			 * By default, only use directories called: 			 *   man<section>/[<arch>/]   or 			 *   cat<section>/[<arch>/] 			 */
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|sec
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"man"
argument_list|,
name|fn
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|src_form
operator||=
name|MANDOC_SRC
expr_stmt|;
name|sec
operator|=
name|fn
operator|+
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"cat"
argument_list|,
name|fn
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|src_form
operator||=
name|MANDOC_FORM
expr_stmt|;
name|sec
operator|=
name|fn
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: bad section\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_all
condition|)
name|sec
operator|=
name|fn
expr_stmt|;
else|else
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|arch
condition|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|strchr
argument_list|(
name|fn
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: bad architecture\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|use_all
condition|)
continue|continue;
block|}
name|arch
operator|=
name|fn
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: "
literal|"excessive subdirectory\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|use_all
condition|)
continue|continue;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|dir
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|sz
operator|=
name|strlcat
argument_list|(
name|buf
argument_list|,
name|fn
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|PATH_MAX
operator|<=
name|sz
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: "
literal|"path too long\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ofile_dirbuild
argument_list|(
name|buf
argument_list|,
name|sec
argument_list|,
name|arch
argument_list|,
name|src_form
argument_list|,
name|of
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
if|if
condition|(
literal|0
operator|==
name|S_IFREG
operator|&
name|sb
operator|.
name|st_mode
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|DT_REG
operator|!=
name|dp
operator|->
name|d_type
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: not a regular file\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|MANDOC_DB
argument_list|,
name|fn
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|MANDOC_IDX
argument_list|,
name|fn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|psec
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: file outside section\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|use_all
condition|)
continue|continue;
block|}
comment|/* 		 * By default, skip files where the file name suffix 		 * does not agree with the section directory 		 * they are located in. 		 */
name|suffix
operator|=
name|strrchr
argument_list|(
name|fn
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|suffix
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: no filename suffix\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|use_all
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|MANDOC_SRC
operator|&
name|src_form
operator|&&
name|strcmp
argument_list|(
name|suffix
operator|+
literal|1
argument_list|,
name|psec
argument_list|)
operator|)
operator|||
operator|(
name|MANDOC_FORM
operator|&
name|src_form
operator|&&
name|strcmp
argument_list|(
name|suffix
operator|+
literal|1
argument_list|,
literal|"0"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: wrong filename suffix\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|use_all
condition|)
continue|continue;
if|if
condition|(
literal|'0'
operator|==
name|suffix
index|[
literal|1
index|]
condition|)
name|src_form
operator||=
name|MANDOC_FORM
expr_stmt|;
elseif|else
if|if
condition|(
literal|'1'
operator|<=
name|suffix
index|[
literal|1
index|]
operator|&&
literal|'9'
operator|>=
name|suffix
index|[
literal|1
index|]
condition|)
name|src_form
operator||=
name|MANDOC_SRC
expr_stmt|;
block|}
comment|/* 		 * Skip formatted manuals if a source version is 		 * available.  Ignore the age: it is very unlikely 		 * that people install newer formatted base manuals 		 * when they used to have source manuals before, 		 * and in ports, old manuals get removed on update. 		 */
if|if
condition|(
literal|0
operator|==
name|use_all
operator|&&
name|MANDOC_FORM
operator|&
name|src_form
operator|&&
literal|'\0'
operator|!=
operator|*
name|psec
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|dir
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|parch
operator|&&
name|NULL
operator|!=
name|p
condition|)
for|for
control|(
name|p
operator|--
init|;
name|p
operator|>
name|buf
condition|;
name|p
operator|--
control|)
if|if
condition|(
literal|'/'
operator|==
operator|*
name|p
condition|)
break|break;
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
name|p
operator|=
name|buf
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
literal|"cat"
argument_list|,
name|p
argument_list|,
literal|3
argument_list|)
condition|)
name|memcpy
argument_list|(
name|p
argument_list|,
literal|"man"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|sz
operator|=
name|strlcat
argument_list|(
name|buf
argument_list|,
name|fn
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>=
name|PATH_MAX
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: path too long\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|q
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|q
operator|&&
name|p
operator|<
name|q
operator|++
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|sz
operator|=
name|strlcat
argument_list|(
name|buf
argument_list|,
name|psec
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>=
name|PATH_MAX
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: path too long\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
literal|0
operator|==
name|access
argument_list|(
name|buf
argument_list|,
name|R_OK
argument_list|)
condition|)
continue|continue;
block|}
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
literal|'.'
operator|==
name|dir
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'/'
operator|==
name|dir
index|[
literal|1
index|]
condition|)
block|{
name|strlcat
argument_list|(
name|buf
argument_list|,
name|dir
operator|+
literal|2
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
block|}
name|sz
operator|=
name|strlcat
argument_list|(
name|buf
argument_list|,
name|fn
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>=
name|PATH_MAX
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s/%s: path too long\n"
argument_list|,
name|dir
argument_list|,
name|fn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nof
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|of
argument_list|)
argument_list|)
expr_stmt|;
name|nof
operator|->
name|fname
operator|=
name|mandoc_strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|nof
operator|->
name|sec
operator|=
name|mandoc_strdup
argument_list|(
name|psec
argument_list|)
expr_stmt|;
name|nof
operator|->
name|arch
operator|=
name|mandoc_strdup
argument_list|(
name|parch
argument_list|)
expr_stmt|;
name|nof
operator|->
name|src_form
operator|=
name|src_form
expr_stmt|;
comment|/* 		 * Remember the file name without the extension, 		 * to be used as the page title in the database. 		 */
if|if
condition|(
name|NULL
operator|!=
name|suffix
condition|)
operator|*
name|suffix
operator|=
literal|'\0'
expr_stmt|;
name|nof
operator|->
name|title
operator|=
name|mandoc_strdup
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* 		 * Add the structure to the list. 		 */
if|if
condition|(
name|NULL
operator|==
operator|*
name|of
condition|)
block|{
operator|*
name|of
operator|=
name|nof
expr_stmt|;
operator|(
operator|*
name|of
operator|)
operator|->
name|first
operator|=
name|nof
expr_stmt|;
block|}
else|else
block|{
name|nof
operator|->
name|first
operator|=
operator|(
operator|*
name|of
operator|)
operator|->
name|first
expr_stmt|;
operator|(
operator|*
name|of
operator|)
operator|->
name|next
operator|=
name|nof
expr_stmt|;
operator|*
name|of
operator|=
name|nof
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|ofile_free
parameter_list|(
name|struct
name|of
modifier|*
name|of
parameter_list|)
block|{
name|struct
name|of
modifier|*
name|nof
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|of
condition|)
name|of
operator|=
name|of
operator|->
name|first
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|of
condition|)
block|{
name|nof
operator|=
name|of
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|of
operator|->
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|of
operator|->
name|sec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|of
operator|->
name|arch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|of
operator|->
name|title
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|of
argument_list|)
expr_stmt|;
name|of
operator|=
name|nof
expr_stmt|;
block|}
block|}
end_function

end_unit

