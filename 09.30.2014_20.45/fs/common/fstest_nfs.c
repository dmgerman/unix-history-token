begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: fstest_nfs.c,v 1.9 2011/02/28 21:08:46 pooka Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2010 The NetBSD Foundation, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/statvfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<puffs.h>
end_include

begin_include
include|#
directive|include
file|<puffsdump.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<rump/rump.h>
end_include

begin_include
include|#
directive|include
file|<rump/rump_syscalls.h>
end_include

begin_include
include|#
directive|include
file|"h_fsmacros.h"
end_include

begin_include
include|#
directive|include
file|"mount_nfs.h"
end_include

begin_include
include|#
directive|include
file|"../../net/config/netconfig.c"
end_include

begin_define
define|#
directive|define
name|SERVERADDR
value|"10.3.2.1"
end_define

begin_define
define|#
directive|define
name|SERVERROADDR
value|"10.4.2.1"
end_define

begin_define
define|#
directive|define
name|CLIENTADDR
value|"10.3.2.2"
end_define

begin_define
define|#
directive|define
name|CLIENTROADDR
value|"10.4.2.2"
end_define

begin_define
define|#
directive|define
name|NETNETMASK
value|"255.255.255.0"
end_define

begin_define
define|#
directive|define
name|EXPORTPATH
value|"/myexport"
end_define

begin_function
specifier|static
name|void
name|childfail
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|atf_tc_fail
argument_list|(
literal|"child died"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fork rump nfsd, configure interface */
end_comment

begin_function
specifier|static
name|int
name|donewfs
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
modifier|*
name|argp
parameter_list|,
specifier|const
name|char
modifier|*
name|image
parameter_list|,
name|off_t
name|size
parameter_list|,
name|void
modifier|*
name|fspriv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|srcdir
decl_stmt|;
name|char
modifier|*
name|nfsdargv
index|[
literal|16
index|]
decl_stmt|;
name|char
name|nfsdpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|imagepath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|ethername
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|ethername_ro
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|,
name|ifname_ro
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|char
name|cwd
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|nfstestargs
modifier|*
name|args
decl_stmt|;
name|pid_t
name|childpid
decl_stmt|;
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|devnull
decl_stmt|;
comment|/* 	 * First, we start the nfs service. 	 */
name|srcdir
operator|=
name|atf_tc_get_config_var
argument_list|(
name|tc
argument_list|,
literal|"srcdir"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|nfsdpath
argument_list|,
literal|"%s/../nfs/nfsservice/rumpnfsd"
argument_list|,
name|srcdir
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ethername
argument_list|,
literal|"/%s/%s.etherbus"
argument_list|,
name|getcwd
argument_list|(
name|cwd
argument_list|,
sizeof|sizeof
argument_list|(
name|cwd
argument_list|)
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ethername_ro
argument_list|,
literal|"%s_ro"
argument_list|,
name|ethername
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|imagepath
argument_list|,
literal|"/%s/%s"
argument_list|,
name|cwd
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|nfsdargv
index|[
literal|0
index|]
operator|=
name|nfsdpath
expr_stmt|;
name|nfsdargv
index|[
literal|1
index|]
operator|=
name|ethername
expr_stmt|;
name|nfsdargv
index|[
literal|2
index|]
operator|=
name|ethername_ro
expr_stmt|;
name|nfsdargv
index|[
literal|3
index|]
operator|=
name|__UNCONST
argument_list|(
name|SERVERADDR
argument_list|)
expr_stmt|;
name|nfsdargv
index|[
literal|4
index|]
operator|=
name|__UNCONST
argument_list|(
name|SERVERROADDR
argument_list|)
expr_stmt|;
name|nfsdargv
index|[
literal|5
index|]
operator|=
name|__UNCONST
argument_list|(
name|NETNETMASK
argument_list|)
expr_stmt|;
name|nfsdargv
index|[
literal|6
index|]
operator|=
name|__UNCONST
argument_list|(
name|EXPORTPATH
argument_list|)
expr_stmt|;
name|nfsdargv
index|[
literal|7
index|]
operator|=
name|imagepath
expr_stmt|;
name|nfsdargv
index|[
literal|8
index|]
operator|=
name|NULL
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|childfail
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipes
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|errno
return|;
switch|switch
condition|(
operator|(
name|childpid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|chdir
argument_list|(
name|dirname
argument_list|(
name|nfsdpath
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"chdir"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|,
literal|3
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"dup2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execvp
argument_list|(
name|nfsdargv
index|[
literal|0
index|]
argument_list|,
name|nfsdargv
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"execvp"
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
return|return
name|errno
return|;
default|default:
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Ok, nfsd has been run.  The following sleep helps with the 	 * theoretical problem that nfsd can't start fast enough to 	 * process our mount request and we end up doing a timeout 	 * before the mount.  This would take several seconds.  So 	 * try to make sure nfsd is up&running already at this stage. 	 */
if|if
condition|(
name|read
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|,
operator|&
name|devnull
argument_list|,
literal|4
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|errno
return|;
comment|/* 	 * Configure our networking interface. 	 */
name|rump_init
argument_list|()
expr_stmt|;
name|netcfg_rump_makeshmif
argument_list|(
name|ethername
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|netcfg_rump_if
argument_list|(
name|ifname
argument_list|,
name|CLIENTADDR
argument_list|,
name|NETNETMASK
argument_list|)
expr_stmt|;
name|netcfg_rump_makeshmif
argument_list|(
name|ethername_ro
argument_list|,
name|ifname_ro
argument_list|)
expr_stmt|;
name|netcfg_rump_if
argument_list|(
name|ifname_ro
argument_list|,
name|CLIENTROADDR
argument_list|,
name|NETNETMASK
argument_list|)
expr_stmt|;
comment|/* 	 * That's it.  The rest is done in mount, since we don't have 	 * the mountpath available here. 	 */
name|args
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
return|return
name|errno
return|;
name|memset
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|ta_childpid
operator|=
name|childpid
expr_stmt|;
name|strcpy
argument_list|(
name|args
operator|->
name|ta_ethername
argument_list|,
name|ethername
argument_list|)
expr_stmt|;
operator|*
name|argp
operator|=
name|args
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nfs_fstest_newfs
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
modifier|*
name|argp
parameter_list|,
specifier|const
name|char
modifier|*
name|image
parameter_list|,
name|off_t
name|size
parameter_list|,
name|void
modifier|*
name|fspriv
parameter_list|)
block|{
return|return
name|donewfs
argument_list|(
name|tc
argument_list|,
name|argp
argument_list|,
name|image
argument_list|,
name|size
argument_list|,
name|fspriv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|nfsro_fstest_newfs
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
modifier|*
name|argp
parameter_list|,
specifier|const
name|char
modifier|*
name|image
parameter_list|,
name|off_t
name|size
parameter_list|,
name|void
modifier|*
name|fspriv
parameter_list|)
block|{
return|return
name|donewfs
argument_list|(
name|tc
argument_list|,
name|argp
argument_list|,
name|image
argument_list|,
name|size
argument_list|,
name|fspriv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* mount the file system */
end_comment

begin_function
specifier|static
name|int
name|domount
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|serverpath
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
name|canon_dev
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|canon_dir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|nfscliargs
index|[]
init|=
block|{
literal|"nfsclient"
block|,
name|serverpath
block|,
name|path
block|,
name|NULL
block|, 	}
decl_stmt|;
name|struct
name|nfs_args
name|args
decl_stmt|;
name|int
name|mntflags
decl_stmt|;
if|if
condition|(
name|rump_sys_mkdir
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|errno
return|;
comment|/* XXX: atf does not reset values */
name|optind
operator|=
literal|1
expr_stmt|;
name|opterr
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We use nfs parseargs here, since as a side effect it 	 * takes care of the RPC hulabaloo. 	 */
name|mount_nfs_parseargs
argument_list|(
name|__arraycount
argument_list|(
name|nfscliargs
argument_list|)
operator|-
literal|1
argument_list|,
name|__UNCONST
argument_list|(
name|nfscliargs
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|mntflags
argument_list|,
name|canon_dev
argument_list|,
name|canon_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|rump_sys_mount
argument_list|(
name|MOUNT_NFS
argument_list|,
name|path
argument_list|,
name|flags
argument_list|,
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nfs_fstest_mount
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|domount
argument_list|(
name|tc
argument_list|,
name|arg
argument_list|,
name|SERVERADDR
literal|":"
name|EXPORTPATH
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is where the magic happens!  *  * If we are mounting r/w, do the normal thing.  However, if we are  * doing a r/o mount, switch use the r/o server export address  * and do a r/w mount.  This way we end up testing the r/o export policy  * of the server! (yes, slightly questionable semantics, but at least  * we notice very quickly if our assumption is broken in the future ;)  */
end_comment

begin_function
name|int
name|nfsro_fstest_mount
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|MNT_RDONLY
condition|)
block|{
name|flags
operator|&=
operator|~
name|MNT_RDONLY
expr_stmt|;
return|return
name|domount
argument_list|(
name|tc
argument_list|,
name|arg
argument_list|,
name|SERVERROADDR
literal|":"
name|EXPORTPATH
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|domount
argument_list|(
name|tc
argument_list|,
name|arg
argument_list|,
name|SERVERADDR
literal|":"
name|EXPORTPATH
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dodelfs
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * XXX: no access to "args" since we're called from "cleanup". 	 * Trust atf to kill nfsd process and remove etherfile. 	 */
if|#
directive|if
literal|0
comment|/* 	 * It's highly expected that the child will die next, so we 	 * don't need that information anymore thank you very many. 	 */
block|signal(SIGCHLD, SIG_IGN);
comment|/* 	 * Just KILL it.  Sending it SIGTERM first causes it to try 	 * to send some unmount RPCs, leading to sticky situations. 	 */
block|kill(args->ta_childpid, SIGKILL); 	wait(&status);
comment|/* remove ethernet bus */
block|if (unlink(args->ta_ethername) == -1) 		atf_tc_fail_errno("unlink ethername");
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nfs_fstest_delfs
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|dodelfs
argument_list|(
name|tc
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|nfsro_fstest_delfs
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|dodelfs
argument_list|(
name|tc
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dounmount
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|i
decl_stmt|,
name|sverrno
decl_stmt|;
comment|/* 	 * NFS handles sillyrenames in an workqueue.  Some of them might 	 * be still in the queue even if all user activity has ceased. 	 * We try to unmount for 2 seconds to give them a chance 	 * to flush out. 	 * 	 * PR kern/43799 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|rump_sys_unmount
argument_list|(
name|path
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|sverrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|sverrno
operator|!=
name|EBUSY
condition|)
break|break;
name|usleep
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
return|return
name|sverrno
return|;
if|if
condition|(
name|rump_sys_rmdir
argument_list|(
name|path
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|errno
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nfs_fstest_unmount
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|dounmount
argument_list|(
name|tc
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|nfsro_fstest_unmount
parameter_list|(
specifier|const
name|atf_tc_t
modifier|*
name|tc
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|dounmount
argument_list|(
name|tc
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

end_unit

