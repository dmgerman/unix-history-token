begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * ls - list file or directory  *  * Modified by Bill Joy UCB May/August 1977  *  * This version of ls is designed for graphic terminals and to  * list directories with lots of files in them compactly.  * It supports three variants for listings:  *  *	1) Columnar output.  *	2) Stream output.  *	3) Old one per line format.  *  * Columnar output is the default.  * If, however, the standard output is not a teletype, the default  * is one-per-line.  *  * With columnar output, the items are sorted down the columns.  * We use columns only for a directory we are interpreting.  * Thus, in particular, we do not use columns for  *  *	ls /usr/bin/p*  *  * This version of ls also prints non-printing characters as '?' if  * the standard output is a teletype.  *  * Flags relating to these and other new features are:  *  *	-m	force stream output.  *  *	-1	force one entry per line, e.g. to a teletype  *  *	-q	force non-printings to be '?'s, e.g. to a file  *  *	-c	force columnar output, e.g. into a file  *  *	-n	like -l, but user/group id's in decimal rather than  *		looking in /etc/passwd to save time  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|NFILES
value|1024
end_define

begin_decl_stmt
name|FILE
modifier|*
name|pwdf
decl_stmt|,
modifier|*
name|dirf
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|lbuf
block|{
union|union
block|{
name|char
name|lname
index|[
literal|15
index|]
decl_stmt|;
name|char
modifier|*
name|namep
decl_stmt|;
block|}
name|ln
union|;
name|char
name|ltype
decl_stmt|;
name|short
name|lnum
decl_stmt|;
name|short
name|lflags
decl_stmt|;
name|short
name|lnl
decl_stmt|;
name|short
name|luid
decl_stmt|;
name|short
name|lgid
decl_stmt|;
name|long
name|lsize
decl_stmt|;
name|long
name|lmtime
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|aflg
decl_stmt|,
name|dflg
decl_stmt|,
name|lflg
decl_stmt|,
name|sflg
decl_stmt|,
name|tflg
decl_stmt|,
name|uflg
decl_stmt|,
name|iflg
decl_stmt|,
name|fflg
decl_stmt|,
name|gflg
decl_stmt|,
name|cflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Aflg
decl_stmt|,
name|nflg
decl_stmt|,
name|qflg
decl_stmt|,
name|across
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nopad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|rflg
literal|1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|year
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|lastuid
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|tbuf
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|tblocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|statreq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lbuf
modifier|*
name|flist
index|[
name|NFILES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lbuf
modifier|*
modifier|*
name|lastp
init|=
name|flist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lbuf
modifier|*
modifier|*
name|firstp
init|=
name|flist
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|char
operator|*
name|dotp
literal|"."
expr_stmt|;
end_expr_stmt

begin_function_decl
name|char
modifier|*
name|makename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|lbuf
modifier|*
name|gstat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|nblock
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ISARG
value|0100000
end_define

begin_expr_stmt
name|int
name|colwidth
literal|15
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|outcol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|obuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|ep
decl_stmt|,
modifier|*
modifier|*
name|ep1
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
modifier|*
name|slastp
decl_stmt|;
name|struct
name|lbuf
modifier|*
modifier|*
name|epp
decl_stmt|;
name|struct
name|lbuf
name|lb
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|compar
parameter_list|()
function_decl|;
name|Aflg
operator|=
name|getuid
argument_list|()
operator|==
literal|0
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|lb
operator|.
name|lmtime
argument_list|)
expr_stmt|;
name|year
operator|=
name|lb
operator|.
name|lmtime
operator|-
literal|6L
operator|*
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
expr_stmt|;
comment|/* 6 months ago */
name|qflg
operator|=
name|gtty
argument_list|(
literal|1
argument_list|,
name|buff
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* 	 * If the standard output is not a teletype, 	 * then we default to one-per-line format 	 * otherwise decide between stream and 	 * columnar based on our name. 	 */
if|if
condition|(
name|qflg
condition|)
block|{
name|cflg
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
literal|0
index|]
init|;
name|cp
index|[
literal|0
index|]
operator|&&
name|cp
index|[
literal|1
index|]
condition|;
name|cp
operator|++
control|)
continue|continue;
comment|/* 		 * Name ends in l => stream 		 */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'l'
condition|)
name|nopad
operator|=
literal|1
operator|,
name|cflg
operator|=
literal|0
expr_stmt|;
comment|/* 		 * ... if doesn't end in l or s ==> columns sorted across 		 * 		else if (cp[0] == 's') 			across = 1; 		 */
block|}
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
comment|/* 		 * c - force columnar output 		 */
case|case
literal|'c'
case|:
name|cflg
operator|=
literal|1
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* 		 * m - force stream output 		 */
case|case
literal|'m'
case|:
name|cflg
operator|=
literal|0
expr_stmt|;
name|nopad
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* 		 * x - force sort across 		 */
case|case
literal|'x'
case|:
name|across
operator|=
literal|1
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
name|cflg
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* 		 * q - force ?'s in output 		 */
case|case
literal|'q'
case|:
name|qflg
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* 		 * 1 - force 1/line in output 		 */
case|case
literal|'1'
case|:
name|cflg
operator|=
literal|0
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* STANDARD FLAGS */
case|case
literal|'a'
case|:
name|aflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
name|Aflg
operator|=
operator|!
name|Aflg
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|colwidth
operator|=
operator|+
literal|5
expr_stmt|;
name|sflg
operator|++
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|dflg
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * n - don't look in password file 		 */
case|case
literal|'n'
case|:
name|nflg
operator|++
expr_stmt|;
case|case
literal|'l'
case|:
name|lflg
operator|++
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflg
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|tflg
operator|++
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
name|uflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|colwidth
operator|=
operator|+
literal|5
expr_stmt|;
name|iflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|fflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
name|gflg
operator|++
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|fflg
condition|)
block|{
name|aflg
operator|++
expr_stmt|;
name|lflg
operator|=
literal|0
expr_stmt|;
name|sflg
operator|=
literal|0
expr_stmt|;
name|tflg
operator|=
literal|0
expr_stmt|;
name|statreq
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lflg
condition|)
block|{
name|cflg
operator|=
literal|0
expr_stmt|;
name|t
operator|=
literal|"/etc/passwd"
expr_stmt|;
if|if
condition|(
name|gflg
condition|)
name|t
operator|=
literal|"/etc/group"
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
name|colwidth
operator|=
literal|70
expr_stmt|;
name|pwdf
operator|=
name|fopen
argument_list|(
name|t
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|argc
operator|++
expr_stmt|;
name|argv
operator|=
operator|&
name|dotp
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ep
operator|=
name|gstat
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|ep
operator|->
name|ln
operator|.
name|namep
operator|=
operator|*
name|argv
expr_stmt|;
name|ep
operator|->
name|lflags
operator|=
operator||
name|ISARG
expr_stmt|;
block|}
name|qsort
argument_list|(
name|firstp
argument_list|,
name|lastp
operator|-
name|firstp
argument_list|,
sizeof|sizeof
expr|*
name|lastp
argument_list|,
name|compar
argument_list|)
expr_stmt|;
name|slastp
operator|=
name|lastp
expr_stmt|;
for|for
control|(
name|epp
operator|=
name|firstp
init|;
name|epp
operator|<
name|slastp
condition|;
name|epp
operator|++
control|)
block|{
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|ltype
operator|==
literal|'d'
operator|&&
name|dflg
operator|==
literal|0
operator|||
name|fflg
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|ep
operator|->
name|ln
operator|.
name|namep
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|slastp
expr_stmt|;
name|readdir
argument_list|(
name|ep
operator|->
name|ln
operator|.
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflg
operator|==
literal|0
condition|)
name|qsort
argument_list|(
name|slastp
argument_list|,
name|lastp
operator|-
name|slastp
argument_list|,
sizeof|sizeof
expr|*
name|lastp
argument_list|,
name|compar
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflg
operator|||
name|sflg
condition|)
name|printf
argument_list|(
literal|"total %D"
argument_list|,
name|tblocks
argument_list|)
expr_stmt|;
name|pem
argument_list|(
name|slastp
argument_list|,
name|lastp
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
else|else
name|pentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outcol
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|pem
argument_list|(
name|slp
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|lbuf
operator|*
operator|*
name|slp
operator|,
operator|*
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|ncols
decl_stmt|,
name|nrows
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
modifier|*
name|ep
decl_stmt|;
name|ncols
operator|=
literal|80
operator|/
name|colwidth
expr_stmt|;
if|if
condition|(
name|ncols
operator|==
literal|1
operator|||
name|cflg
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|slp
init|;
name|ep
operator|<
name|lp
condition|;
name|ep
operator|++
control|)
name|pentry
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	if (across) { 		for (ep = slp; ep< lp; ep++) 			pentry(*ep); 		return; 	} */
if|if
condition|(
name|statreq
condition|)
name|slp
operator|--
expr_stmt|;
name|nrows
operator|=
operator|(
name|lp
operator|-
name|slp
operator|-
literal|1
operator|)
operator|/
name|ncols
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|nrows
condition|;
name|row
operator|++
control|)
block|{
name|col
operator|=
name|row
operator|==
literal|0
operator|&&
name|statreq
expr_stmt|;
for|for
control|(
init|;
name|col
operator|<
name|ncols
condition|;
name|col
operator|++
control|)
block|{
name|ep
operator|=
name|slp
operator|+
operator|(
name|nrows
operator|*
name|col
operator|)
operator|+
name|row
expr_stmt|;
if|if
condition|(
name|ep
operator|<
name|lp
condition|)
name|pentry
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outcol
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pputchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
name|outcol
operator|=
operator|(
name|outcol
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|outcol
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|qflg
operator|&&
operator|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>=
literal|0177
operator|)
condition|)
name|c
operator|=
literal|'?'
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|newline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|outcol
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|column
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|outcol
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|nopad
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
if|if
condition|(
name|outcol
operator|+
name|colwidth
operator|+
literal|2
operator|>
literal|80
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|putc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cflg
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|outcol
operator|/
name|colwidth
operator|+
literal|2
operator|)
operator|*
name|colwidth
operator|>
literal|80
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
return|return;
block|}
do|do
block|{
name|outcol
operator|++
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|outcol
operator|%
name|colwidth
condition|)
do|;
block|}
end_block

begin_macro
name|getname
argument_list|(
argument|uid
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|uid
operator|==
name|lastuid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pwdf
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|rewind
argument_list|(
name|pwdf
argument_list|)
expr_stmt|;
name|lastuid
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|pwdf
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|c
operator|=
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|2
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|n
operator|!=
name|uid
condition|)
do|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lastuid
operator|=
name|uid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|long
name|nblock
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|size
operator|+
literal|511
operator|)
operator|>>
literal|9
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|m1
index|[]
block|{
literal|1
operator|,
name|S_IREAD
operator|>>
literal|0
operator|,
literal|'r'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m2
index|[]
block|{
literal|1
operator|,
name|S_IWRITE
operator|>>
literal|0
operator|,
literal|'w'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m3
index|[]
block|{
literal|2
operator|,
name|S_ISUID
operator|,
literal|'s'
operator|,
name|S_IEXEC
operator|>>
literal|0
operator|,
literal|'x'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m4
index|[]
block|{
literal|1
operator|,
name|S_IREAD
operator|>>
literal|3
operator|,
literal|'r'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m5
index|[]
block|{
literal|1
operator|,
name|S_IWRITE
operator|>>
literal|3
operator|,
literal|'w'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m6
index|[]
block|{
literal|2
operator|,
name|S_ISGID
operator|,
literal|'s'
operator|,
name|S_IEXEC
operator|>>
literal|3
operator|,
literal|'x'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m7
index|[]
block|{
literal|1
operator|,
name|S_IREAD
operator|>>
literal|6
operator|,
literal|'r'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m8
index|[]
block|{
literal|1
operator|,
name|S_IWRITE
operator|>>
literal|6
operator|,
literal|'w'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m9
index|[]
block|{
literal|2
operator|,
name|S_ISVTX
operator|,
literal|'t'
operator|,
name|S_IEXEC
operator|>>
literal|6
operator|,
literal|'x'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
modifier|*
name|m
index|[]
block|{
name|m1
operator|,
name|m2
operator|,
name|m3
operator|,
name|m4
operator|,
name|m5
operator|,
name|m6
operator|,
name|m7
operator|,
name|m8
operator|,
name|m9
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|pmode
argument_list|(
argument|aflag
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
modifier|*
name|mp
decl_stmt|;
name|flags
operator|=
name|aflag
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|m
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|m
index|[
sizeof|sizeof
argument_list|(
name|m
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
index|]
condition|;
control|)
name|select
argument_list|(
operator|*
name|mp
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|select
argument_list|(
name|pairp
argument_list|)
specifier|register
name|int
operator|*
name|pairp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
operator|*
name|pairp
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
operator|(
name|flags
operator|&
operator|*
name|pairp
operator|++
operator|)
operator|==
literal|0
condition|)
name|pairp
operator|++
expr_stmt|;
name|pputchar
argument_list|(
operator|*
name|pairp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|makename
parameter_list|(
name|dir
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|dfile
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|dp
operator|=
name|dfile
expr_stmt|;
name|fp
operator|=
name|dir
expr_stmt|;
while|while
condition|(
operator|*
name|fp
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|fp
operator|=
name|file
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRSIZ
condition|;
name|i
operator|++
control|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dfile
operator|)
return|;
block|}
end_block

begin_macro
name|readdir
argument_list|(
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|struct
name|direct
name|dentry
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|(
name|dirf
operator|=
name|fopen
argument_list|(
name|dir
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s unreadable\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
name|tblocks
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|dentry
argument_list|,
sizeof|sizeof
argument_list|(
name|dentry
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dirf
argument_list|)
operator|!=
literal|1
condition|)
break|break;
if|if
condition|(
name|dentry
operator|.
name|d_ino
operator|==
literal|0
operator|||
name|aflg
operator|==
literal|0
operator|&&
name|dentry
operator|.
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
operator|!
name|Aflg
operator|||
name|dentry
operator|.
name|d_name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|dentry
operator|.
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dentry
operator|.
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
continue|continue;
name|ep
operator|=
name|gstat
argument_list|(
name|makename
argument_list|(
name|dir
argument_list|,
name|dentry
operator|.
name|d_name
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ep
operator|->
name|lnum
operator|!=
operator|-
literal|1
condition|)
name|ep
operator|->
name|lnum
operator|=
name|dentry
operator|.
name|d_ino
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DIRSIZ
condition|;
name|j
operator|++
control|)
name|ep
operator|->
name|ln
operator|.
name|lname
index|[
name|j
index|]
operator|=
name|dentry
operator|.
name|d_name
index|[
name|j
index|]
expr_stmt|;
block|}
name|fclose
argument_list|(
name|dirf
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|lbuf
modifier|*
name|gstat
parameter_list|(
name|file
parameter_list|,
name|argfl
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|statb
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|rep
decl_stmt|;
specifier|static
name|int
name|nomocore
decl_stmt|;
if|if
condition|(
name|nomocore
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rep
operator|=
operator|(
expr|struct
name|lbuf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ls: out of memory\n"
argument_list|)
expr_stmt|;
name|nomocore
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|lastp
operator|>=
operator|&
name|flist
index|[
name|NFILES
index|]
condition|)
block|{
specifier|static
name|int
name|msg
decl_stmt|;
name|lastp
operator|--
expr_stmt|;
if|if
condition|(
name|msg
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ls: too many files\n"
argument_list|)
expr_stmt|;
name|msg
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|lastp
operator|++
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|lflags
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|lnum
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|ltype
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|argfl
operator|||
name|statreq
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s not found\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|statb
operator|.
name|st_ino
operator|=
operator|-
literal|1
expr_stmt|;
name|statb
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|statb
operator|.
name|st_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argfl
condition|)
block|{
name|lastp
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|rep
operator|->
name|lnum
operator|=
name|statb
operator|.
name|st_ino
expr_stmt|;
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|st_size
expr_stmt|;
switch|switch
condition|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFDIR
case|:
name|rep
operator|->
name|ltype
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|rep
operator|->
name|ltype
operator|=
literal|'b'
expr_stmt|;
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|st_rdev
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
name|rep
operator|->
name|ltype
operator|=
literal|'c'
expr_stmt|;
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|st_rdev
expr_stmt|;
break|break;
block|}
name|rep
operator|->
name|lflags
operator|=
name|statb
operator|.
name|st_mode
operator|&
operator|~
name|S_IFMT
expr_stmt|;
name|rep
operator|->
name|luid
operator|=
name|statb
operator|.
name|st_uid
expr_stmt|;
name|rep
operator|->
name|lgid
operator|=
name|statb
operator|.
name|st_gid
expr_stmt|;
name|rep
operator|->
name|lnl
operator|=
name|statb
operator|.
name|st_nlink
expr_stmt|;
if|if
condition|(
name|uflg
condition|)
name|rep
operator|->
name|lmtime
operator|=
name|statb
operator|.
name|st_atime
expr_stmt|;
elseif|else
if|if
condition|(
name|cflg
condition|)
name|rep
operator|->
name|lmtime
operator|=
name|statb
operator|.
name|st_ctime
expr_stmt|;
else|else
name|rep
operator|->
name|lmtime
operator|=
name|statb
operator|.
name|st_mtime
expr_stmt|;
name|tblocks
operator|=
operator|+
name|nblock
argument_list|(
name|statb
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rep
operator|)
return|;
block|}
end_function

begin_macro
name|compar
argument_list|(
argument|pp1
argument_list|,
argument|pp2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|lbuf
modifier|*
modifier|*
name|pp1
decl_stmt|,
modifier|*
modifier|*
name|pp2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|lbuf
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p1
operator|=
operator|*
name|pp1
expr_stmt|;
name|p2
operator|=
operator|*
name|pp2
expr_stmt|;
if|if
condition|(
name|dflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|lflags
operator|&
name|ISARG
operator|&&
name|p1
operator|->
name|ltype
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p2
operator|->
name|lflags
operator|&
name|ISARG
operator|&&
name|p2
operator|->
name|ltype
operator|==
literal|'d'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|p2
operator|->
name|lflags
operator|&
name|ISARG
operator|&&
name|p2
operator|->
name|ltype
operator|==
literal|'d'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tflg
condition|)
block|{
if|if
condition|(
name|p2
operator|->
name|lmtime
operator|==
name|p1
operator|->
name|lmtime
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p2
operator|->
name|lmtime
operator|>
name|p1
operator|->
name|lmtime
condition|)
return|return
operator|(
name|rflg
operator|)
return|;
return|return
operator|(
operator|-
name|rflg
operator|)
return|;
block|}
return|return
operator|(
name|rflg
operator|*
name|strcmp
argument_list|(
name|p1
operator|->
name|lflags
operator|&
name|ISARG
condition|?
name|p1
operator|->
name|ln
operator|.
name|namep
else|:
name|p1
operator|->
name|ln
operator|.
name|lname
argument_list|,
name|p2
operator|->
name|lflags
operator|&
name|ISARG
condition|?
name|p2
operator|->
name|ln
operator|.
name|namep
else|:
name|p2
operator|->
name|ln
operator|.
name|lname
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|pentry
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|lbuf
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
struct|struct
block|{
name|char
name|dminor
decl_stmt|,
name|dmajor
decl_stmt|;
block|}
struct|;
specifier|register
name|t
expr_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lnum
operator|==
operator|-
literal|1
condition|)
return|return;
name|column
argument_list|()
expr_stmt|;
if|if
condition|(
name|iflg
condition|)
if|if
condition|(
name|nopad
operator|&&
operator|!
name|lflg
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|p
operator|->
name|lnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%5d "
argument_list|,
name|p
operator|->
name|lnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflg
condition|)
if|if
condition|(
name|nopad
operator|&&
operator|!
name|lflg
condition|)
name|printf
argument_list|(
literal|"%D "
argument_list|,
name|nblock
argument_list|(
name|p
operator|->
name|lsize
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%4D "
argument_list|,
name|nblock
argument_list|(
name|p
operator|->
name|lsize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflg
condition|)
block|{
name|putchar
argument_list|(
name|p
operator|->
name|ltype
argument_list|)
expr_stmt|;
name|pmode
argument_list|(
name|p
operator|->
name|lflags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2d "
argument_list|,
name|p
operator|->
name|lnl
argument_list|)
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|luid
expr_stmt|;
if|if
condition|(
name|gflg
condition|)
name|t
operator|=
name|p
operator|->
name|lgid
expr_stmt|;
if|if
condition|(
name|nflg
operator|==
literal|0
operator|&&
name|getname
argument_list|(
name|t
argument_list|,
name|tbuf
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%-8.8s"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-8d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ltype
operator|==
literal|'b'
operator|||
name|p
operator|->
name|ltype
operator|==
literal|'c'
condition|)
name|printf
argument_list|(
literal|"%3d,%3d"
argument_list|,
name|major
argument_list|(
operator|(
name|int
operator|)
name|p
operator|->
name|lsize
argument_list|)
argument_list|,
name|minor
argument_list|(
operator|(
name|int
operator|)
name|p
operator|->
name|lsize
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%7ld"
argument_list|,
name|p
operator|->
name|lsize
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|p
operator|->
name|lmtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lmtime
operator|<
name|year
condition|)
name|printf
argument_list|(
literal|" %-7.7s %-4.4s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|,
name|cp
operator|+
literal|20
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %-12.12s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|lflags
operator|&
name|ISARG
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|p
operator|->
name|ln
operator|.
name|namep
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%.14s"
argument_list|,
name|p
operator|->
name|ln
operator|.
name|lname
argument_list|)
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_expr_stmt
name|_strout
argument_list|(
name|count
argument_list|,
name|string
argument_list|,
name|adjust
argument_list|,
name|file
argument_list|,
name|fillch
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|count
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|adjust
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|_iobuf
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|adjust
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
operator|&&
name|fillch
operator|==
literal|'0'
condition|)
block|{
name|pputchar
argument_list|(
operator|*
name|string
operator|++
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|adjust
operator|=
operator|-
name|adjust
expr_stmt|;
while|while
condition|(
operator|--
name|adjust
operator|>=
literal|0
condition|)
name|pputchar
argument_list|(
name|fillch
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
name|pputchar
argument_list|(
operator|*
name|string
operator|++
argument_list|,
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|adjust
operator|>=
literal|0
condition|)
name|pputchar
argument_list|(
name|fillch
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

