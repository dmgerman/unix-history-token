begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * pi - Pascal interpreter code translator  *  * Charles Haley, Bill Joy UCB  * Version 1.2 January 1979  */
end_comment

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_decl_stmt
name|int
modifier|*
name|obufp
block|{
name|obuf
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * If DEBUG is defined, include the table  * of the printing opcode names.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|otext
index|[]
block|{
include|#
directive|include
file|"OPnames.h"
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Put is responsible for the interpreter equivalent of code  * generation.  Since the interpreter is specifically designed  * for Pascal, little work is required here.  */
end_comment

begin_macro
name|put
argument_list|(
argument|a
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|subop
decl_stmt|,
name|suboppr
decl_stmt|,
name|op
decl_stmt|,
name|oldlc
decl_stmt|,
name|w
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
specifier|static
name|int
name|casewrd
decl_stmt|;
comment|/* 	 * It would be nice to do some more 	 * optimizations here.  The work 	 * done to collapse offsets in lval 	 * should be done here, the IFEQ etc 	 * relational operators could be used 	 * etc. 	 */
name|oldlc
operator|=
name|lc
expr_stmt|;
if|if
condition|(
name|cgenflg
condition|)
comment|/* 		 * code disabled - do nothing 		 */
return|return
operator|(
name|oldlc
operator|)
return|;
name|p
operator|=
operator|&
name|a
expr_stmt|;
name|n
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|suboppr
operator|=
name|subop
operator|=
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
name|op
operator|=
operator|*
name|p
operator|&
literal|0377
expr_stmt|;
name|string
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|cp
operator|=
name|otext
index|[
name|op
index|]
operator|)
operator|==
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|"op= %o\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"put"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|op
condition|)
block|{
comment|/***** 		case O_LINO: 			if (line == codeline) 				return (oldlc); 			codeline = line; *****/
case|case
name|O_PUSH
case|:
case|case
name|O_POP
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_NEW
case|:
case|case
name|O_DISPOSE
case|:
case|case
name|O_AS
case|:
case|case
name|O_IND
case|:
case|case
name|O_OFF
case|:
case|case
name|O_INX2
case|:
case|case
name|O_INX4
case|:
case|case
name|O_CARD
case|:
case|case
name|O_ADDT
case|:
case|case
name|O_SUBT
case|:
case|case
name|O_MULT
case|:
case|case
name|O_IN
case|:
case|case
name|O_CASE1OP
case|:
case|case
name|O_CASE2OP
case|:
case|case
name|O_CASE4OP
case|:
case|case
name|O_PACK
case|:
case|case
name|O_UNPACK
case|:
case|case
name|O_RANG2
case|:
case|case
name|O_RSNG2
case|:
case|case
name|O_RANG42
case|:
case|case
name|O_RSNG42
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
break|break;
case|case
name|O_CON2
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|<
literal|128
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
operator|-
literal|128
condition|)
block|{
name|suboppr
operator|=
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_CON2
condition|)
name|op
operator|=
name|O_CON1
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|op
operator|>=
name|O_REL2
operator|&&
name|op
operator|<=
name|O_REL84
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|subop
operator|>>
literal|1
operator|)
operator|*
literal|5
operator|)
operator|>=
literal|30
condition|)
name|i
operator|=
operator|-
literal|30
expr_stmt|;
else|else
name|i
operator|=
operator|+
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|string
operator|=
operator|&
literal|"IFEQ\0IFNE\0IFLT\0IFGT\0IFLE\0IFGE"
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
name|suboppr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_IF
case|:
case|case
name|O_TRA
case|:
comment|/***** 			codeline = 0; *****/
case|case
name|O_CALL
case|:
case|case
name|O_FOR1U
case|:
case|case
name|O_FOR2U
case|:
case|case
name|O_FOR4U
case|:
case|case
name|O_FOR1D
case|:
case|case
name|O_FOR2D
case|:
case|case
name|O_FOR4D
case|:
name|p
index|[
literal|1
index|]
operator|=
operator|-
name|lc
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|O_WRIT82
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|string
operator|=
operator|&
literal|"22\024\042\044"
index|[
name|subop
operator|*
literal|3
index|]
expr_stmt|;
endif|#
directive|endif
name|suboppr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|O_CONG
case|:
name|i
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'c'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\tCONG:%d\t%s\n"
argument_list|,
name|lc
argument_list|,
name|i
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|<=
literal|127
condition|)
name|word
argument_list|(
name|O_CON
operator||
name|i
operator|<<
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
name|word
argument_list|(
name|O_CON
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|w
operator|=
operator|*
name|cp
condition|?
operator|*
name|cp
operator|++
else|:
literal|' '
expr_stmt|;
name|w
operator|=
operator||
operator|(
operator|*
name|cp
condition|?
operator|*
name|cp
operator|++
else|:
literal|' '
operator|)
operator|<<
literal|8
expr_stmt|;
name|word
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CONC
case|:
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|string
operator|=
literal|"'x'"
operator|)
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|suboppr
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_CON1
expr_stmt|;
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|around
goto|;
case|case
name|O_CON1
case|:
name|suboppr
operator|=
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|around
label|:
name|n
operator|--
expr_stmt|;
break|break;
case|case
name|O_CASEBEG
case|:
name|casewrd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASEEND
case|:
if|if
condition|(
name|lc
operator|&
literal|1
condition|)
block|{
name|lc
operator|--
expr_stmt|;
name|word
argument_list|(
name|casewrd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASE1
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'c'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\tCASE1\t%d\n"
argument_list|,
name|lc
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lc
operator|++
expr_stmt|;
if|if
condition|(
name|lc
operator|&
literal|1
condition|)
name|casewrd
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|lc
operator|=
operator|-
literal|2
expr_stmt|;
name|word
argument_list|(
name|casewrd
operator||
name|p
index|[
literal|2
index|]
operator|<<
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASE2
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'c'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\tCASE2\t%d\n"
argument_list|,
name|lc
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|word
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASE4
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'c'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\tCASE4\t%d %d\n"
argument_list|,
name|lc
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|word
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'c'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%5d\t%s"
argument_list|,
name|lc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|suboppr
condition|)
name|printf
argument_list|(
literal|":%d"
argument_list|,
name|suboppr
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|op
operator|!=
name|NIL
condition|)
name|word
argument_list|(
name|op
operator||
name|subop
operator|<<
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|word
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Putspace puts out a table  * of nothing to leave space  * for the case branch table e.g.  */
end_comment

begin_macro
name|putspace
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'c'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\t.=.+%d\n"
argument_list|,
name|lc
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|even
argument_list|(
name|n
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|=
operator|-
literal|2
control|)
name|word
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Patch repairs the branch  * at location loc to come  * to the current location.  */
end_comment

begin_macro
name|patch
argument_list|(
argument|loc
argument_list|)
end_macro

begin_block
block|{
name|patchfil
argument_list|(
name|loc
argument_list|,
name|lc
operator|-
name|loc
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Patchfil makes loc+2 have value  * as its contents.  */
end_comment

begin_macro
name|patchfil
argument_list|(
argument|loc
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|cgenflg
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|loc
operator|>
name|lc
condition|)
name|panic
argument_list|(
literal|"patchfil"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'c'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\tpatch %u %d\n"
argument_list|,
name|loc
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
operator|(
name|loc
operator|+
literal|2
operator|-
operator|(
name|lc
operator|&
operator|~
literal|0777
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|512
condition|)
name|obuf
index|[
name|i
index|]
operator|=
name|value
expr_stmt|;
else|else
block|{
name|seek
argument_list|(
name|ofil
argument_list|,
name|loc
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|ofil
argument_list|,
operator|&
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|seek
argument_list|(
name|ofil
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Put the word o into the code  */
end_comment

begin_macro
name|word
argument_list|(
argument|o
argument_list|)
end_macro

begin_decl_stmt
name|int
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|obufp
operator|=
name|o
expr_stmt|;
name|obufp
operator|++
expr_stmt|;
name|lc
operator|=
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|obufp
operator|>=
name|obuf
operator|+
literal|256
condition|)
name|pflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flush the code buffer  */
end_comment

begin_macro
name|pflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|i
operator|=
operator|(
name|obufp
operator|-
name|obuf
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|write
argument_list|(
name|ofil
argument_list|,
name|obuf
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|perror
argument_list|(
name|obj
argument_list|)
operator|,
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
name|obufp
operator|=
name|obuf
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Getlab - returns the location counter.  * included here for the eventual code generator.  */
end_comment

begin_macro
name|getlab
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|lc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Putlab - lay down a label.  */
end_comment

begin_macro
name|putlab
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|l
operator|)
return|;
block|}
end_block

end_unit

