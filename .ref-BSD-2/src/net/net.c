begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* must be setuid root */
end_comment

begin_comment
comment|/* 	net - -c cmd -f -i file -l name -mmach -n -o file -p passwd 		-r file -s file -w -x -y -z command 		 	-	take from standard input 	-c cmd	think of this as a "cmd" * 	-f	force prompting of user name and password 	-i file	remote stdin * 	-l name remote login name 	-m Mach	remote machine 	-n	do not mail or write back anything, not even err msgs 	-o file	remote stdout& stderr * 	-p pass remote password 	-r file	local response file 	-s file	local stdin file * 	 	(super users only, always skip login/passwd check:) 	-w	this is a write/mail response cmd * 	-x	this is being forwarded through us to another machine * 	-y	skip login/password check * 	-z	this is a response file being returned *  	* = not documented in net(NEW) 	 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dfname
index|[]
init|=
name|DFNAME
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|out
parameter_list|()
function_decl|;
name|char
name|resp
index|[
name|FNS
index|]
decl_stmt|,
name|infile
index|[
name|FNS
index|]
decl_stmt|,
name|outfile
index|[
name|FNS
index|]
decl_stmt|,
name|localin
index|[
name|FNS
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BFS
operator|*
literal|2
index|]
decl_stmt|;
name|char
name|sin
decl_stmt|,
name|code
decl_stmt|,
name|zopt
decl_stmt|,
name|wopt
decl_stmt|,
name|yopt
decl_stmt|,
name|xopt
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|cnt
init|=
literal|0l
decl_stmt|;
name|char
name|cflag
init|=
literal|'a'
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|rfile
decl_stmt|;
name|struct
name|utmp
name|utmpstr
decl_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|debugflg
operator|=
name|DBV
expr_stmt|;
name|sin
operator|=
literal|0
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|resp
index|[
literal|0
index|]
operator|=
name|outfile
index|[
literal|0
index|]
operator|=
name|infile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|realcmd
index|[
literal|0
index|]
operator|=
name|localin
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|wopt
operator|=
name|xopt
operator|=
name|yopt
operator|=
name|zopt
operator|=
literal|0
expr_stmt|;
name|ttystr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|strcat
argument_list|(
name|ttystr
argument_list|,
name|ttyname
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
literal|2
argument_list|)
condition|)
name|strcat
argument_list|(
name|ttystr
argument_list|,
name|ttyname
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|remote
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0
case|:
name|sin
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|harg
argument_list|(
name|realcmd
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|status
operator|.
name|force
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|harg
argument_list|(
name|infile
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|harg
argument_list|(
name|status
operator|.
name|login
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|harg
argument_list|(
name|buf
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|remote
operator|=
name|lookup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|status
operator|.
name|nowrite
operator|++
expr_stmt|;
name|status
operator|.
name|nonotify
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|harg
argument_list|(
name|outfile
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|harg
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|harg
argument_list|(
name|buf
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|addir
argument_list|(
name|resp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|harg
argument_list|(
name|localin
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wopt
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xopt
operator|++
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|yopt
operator|++
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|zopt
operator|++
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown option %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
literal|'q'
expr_stmt|;
if|if
condition|(
name|zopt
operator|||
name|wopt
operator|||
name|yopt
operator|||
name|xopt
condition|)
block|{
comment|/* check z or w or y or x option permission */
ifndef|#
directive|ifndef
name|TESTING
if|if
condition|(
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Not super-user"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
name|zopt
condition|?
literal|'s'
else|:
literal|'w'
expr_stmt|;
name|code
operator|=
name|yopt
condition|?
literal|'y'
else|:
name|code
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* no passwd required */
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	code	option	reason 	q		normal request 	w	-w	message to be written back 	 	-x	being forwarded through us 	y	-y	simply skips login check (used by netlpr) 	s	-z	normal response */
comment|/* 	debug("d:%s:%s:",status.defcmd,cmd); */
name|commandfile
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"d:%s:"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote
operator|==
literal|0
condition|)
name|remote
operator|=
name|getremote
argument_list|(
name|local
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TESTING
if|if
condition|(
name|remote
operator|==
name|local
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Request sent to local machine - doesn't make sense\n"
argument_list|)
expr_stmt|;
comment|/* exit(1); */
block|}
endif|#
directive|endif
name|strcat
argument_list|(
name|status
operator|.
name|defcmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|cmd
argument_list|,
name|status
operator|.
name|defcmd
argument_list|)
expr_stmt|;
name|cmd
index|[
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mktemp
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
comment|/* determine through machine */
name|i
operator|=
name|gothru
argument_list|(
name|local
argument_list|,
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|longname
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No path to %s machine.\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown machine\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dfname
index|[
name|strlen
argument_list|(
name|dfname
argument_list|)
operator|-
literal|11
index|]
operator|=
name|i
expr_stmt|;
comment|/* set directory */
name|dfname
index|[
name|strlen
argument_list|(
name|dfname
argument_list|)
operator|-
literal|7
index|]
operator|=
name|i
expr_stmt|;
comment|/* set file (unused) */
if|if
condition|(
name|resp
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|resp
argument_list|,
literal|"/dev/tty"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't have /dev/tty as response file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|resp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|s
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'/'
operator|&&
name|s
operator|>
operator|&
operator|(
name|buf
index|[
literal|0
index|]
operator|)
condition|)
name|s
operator|--
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
literal|"chkdir %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rfile
operator|=
name|fopen
argument_list|(
name|resp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|chmod
argument_list|(
name|resp
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rfile
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|resp
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|access
argument_list|(
name|resp
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|file
operator|=
name|fopen
argument_list|(
name|dfname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|chmod
argument_list|(
name|dfname
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|dfname
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|xopt
condition|)
goto|goto
name|stickit
goto|;
if|if
condition|(
name|code
operator|==
literal|'q'
condition|)
block|{
name|passwdent
argument_list|()
expr_stmt|;
name|promptlogin
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|OLDPROT
if|if
condition|(
name|machtype
index|[
name|local
operator|-
literal|'a'
index|]
operator|==
name|M_CC
operator|&&
name|machtype
index|[
name|remote
operator|-
literal|'a'
index|]
operator|==
name|M_CC
operator|&&
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|s
operator|=
name|crypt
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|code
operator|==
literal|'q'
operator|&&
name|strcmp
argument_list|(
name|status
operator|.
name|login
argument_list|,
literal|"network"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Zero-length password not allowed\n"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
literal|'q'
operator|&&
operator|(
name|streql
argument_list|(
name|status
operator|.
name|login
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
operator|||
name|streql
argument_list|(
name|status
operator|.
name|login
argument_list|,
literal|"ruut"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't login as root through the network\n"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SPACCT
comment|/* handle special accounts */
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
name|handlesp
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|status
operator|.
name|mpasswd
argument_list|,
name|status
operator|.
name|localname
argument_list|,
name|status
operator|.
name|muid
argument_list|,
name|status
operator|.
name|mgid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|enmask
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|)
expr_stmt|;
name|ltime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ttystr
index|[
literal|0
index|]
operator|&&
name|status
operator|.
name|nowrite
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|fopen
argument_list|(
literal|"/etc/utmp"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"/etc/utmp"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fread
argument_list|(
operator|&
name|utmpstr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|utmpstr
argument_list|,
name|temp
argument_list|)
operator|==
sizeof|sizeof
name|utmpstr
condition|)
ifdef|#
directive|ifdef
name|OLDTTY
if|if
condition|(
name|utmpstr
operator|.
name|ut_tty
operator|==
name|ttystr
index|[
literal|8
index|]
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|strcmp
argument_list|(
name|utmpstr
operator|.
name|ut_line
argument_list|,
name|ttystr
operator|+
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|ltime
operator|=
name|utmpstr
operator|.
name|ut_time
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	debug("p:%s:\n",status.mpasswd); */
if|if
condition|(
name|status
operator|.
name|nonotify
condition|)
name|cflag
operator|+=
name|F_NONOTIFY
expr_stmt|;
comment|/* 	protocol: 	code, remote mach, local mach, version stamp (2), remote login name, 	password, -i, -o, -r files, local login name, terminal, flag, 	utmp tty time, cc jobno, unused string, 	command '\n' real command '\n' 	any data 	 	changes: 	1) remove header 	2) remove unused string 	3) use ascii length instead of 4 bytes 	4) encrypt the login name, command, and part of data as well */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c :%c :%c :%c :%c :%s :%s :%s :%s :%s :%s :%s :%c :%lo :%d :%ld :"
argument_list|,
name|code
argument_list|,
name|remote
argument_list|,
name|local
argument_list|,
name|VMAJOR
operator|+
literal|'a'
argument_list|,
name|VMINOR
operator|+
literal|'a'
argument_list|,
name|status
operator|.
name|login
argument_list|,
name|status
operator|.
name|mpasswd
argument_list|,
name|infile
argument_list|,
name|outfile
argument_list|,
name|resp
argument_list|,
name|status
operator|.
name|localname
argument_list|,
name|ttystr
argument_list|,
name|cflag
argument_list|,
name|ltime
argument_list|,
name|status
operator|.
name|jobno
argument_list|,
name|gettime
argument_list|()
operator|-
name|TIMEBASE
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|cmd
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|realcmd
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|stickit
label|:
if|if
condition|(
name|sin
condition|)
while|while
condition|(
operator|(
name|i
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|file
argument_list|)
operator|!=
name|i
condition|)
block|{
name|perror
argument_list|(
literal|"net queue file"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cnt
operator|+=
name|i
operator|)
operator|>
name|MAXFILE
condition|)
goto|goto
name|toobig
goto|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|localin
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|localin
argument_list|,
literal|4
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|localin
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|fopen
argument_list|(
name|localin
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|localin
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|temp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cnt
operator|+=
name|i
operator|)
operator|>
name|MAXFILE
condition|)
goto|goto
name|toobig
goto|;
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|file
argument_list|)
operator|!=
name|i
condition|)
block|{
name|perror
argument_list|(
literal|"net queue file"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|dfname
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
name|dfname
index|[
name|strlen
argument_list|(
name|dfname
argument_list|)
operator|-
literal|9
index|]
operator|=
literal|'c'
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|dfname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|dfname
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|dfname
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|toobig
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No more than %ld bytes can be sent\n"
argument_list|,
name|MAXFILE
argument_list|)
expr_stmt|;
name|out
argument_list|()
expr_stmt|;
comment|/* no return */
block|}
name|out
argument_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|sgttyb
name|stt
decl_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|dfname
argument_list|)
operator|-
literal|9
expr_stmt|;
name|dfname
index|[
name|i
index|]
operator|=
operator|(
name|dfname
index|[
name|i
index|]
operator|==
literal|'c'
condition|?
literal|'d'
else|:
literal|'c'
operator|)
expr_stmt|;
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|stt
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|stt
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
name|stty
argument_list|(
literal|0
argument_list|,
operator|&
name|stt
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|enmask
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|OLDPROT
while|while
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|s
operator|&=
literal|0177
expr_stmt|;
comment|/* strip quote bites */
operator|*
name|s
operator|++
operator|^=
literal|040
expr_stmt|;
comment|/* invert upper-lower */
block|}
else|#
directive|else
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|nbsencrypt
argument_list|(
name|s
argument_list|,
name|THEKEY
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|addir
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|t
expr_stmt|;
block|{
if|if
condition|(
name|t
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|gwd
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* returns pass if not special, otherwise returns funny passwd */
comment|/* list of special accounts must be consistent - with netdaemon.c */
name|char
modifier|*
name|handlesp
parameter_list|(
name|log
parameter_list|,
name|pass
parameter_list|,
name|localname
parameter_list|,
name|luid
parameter_list|,
name|lgid
parameter_list|)
name|char
modifier|*
name|log
decl_stmt|,
decl|*
name|pass
decl_stmt|,
modifier|*
name|localname
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SPACCT
name|long
name|lt
decl_stmt|;
name|char
name|str
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|log
argument_list|,
name|localname
argument_list|)
operator|==
literal|0
operator|&&
name|luid
operator|!=
literal|0
operator|&&
name|lgid
operator|==
literal|0
operator|&&
operator|(
name|strcmp
argument_list|(
name|log
argument_list|,
literal|"source"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|log
argument_list|,
literal|"daemon"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|lt
operator|=
name|lgid
expr_stmt|;
name|lt
operator|=
operator|(
name|lt
operator|<<
literal|16
operator|)
operator||
name|luid
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%ld"
argument_list|,
name|lt
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|pass
operator|)
return|;
block|}
end_function

end_unit

