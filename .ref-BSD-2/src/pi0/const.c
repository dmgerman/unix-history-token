begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * pi - Pascal interpreter code translator  *  * Charles Haley, Bill Joy UCB  * Version 1.2 January 1979  */
end_comment

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/*  * Const enters the definitions  * of the constant declaration  * part into the namelist.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PI1
end_ifndef

begin_macro
name|constbeg
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|parts
operator|&
operator|(
name|TPRT
operator||
name|VPRT
operator|)
condition|)
name|error
argument_list|(
literal|"Constant declarations must precede type and variable declarations"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|&
name|CPRT
condition|)
name|error
argument_list|(
literal|"All constants must be declared in one const part"
argument_list|)
expr_stmt|;
name|parts
operator|=
operator||
name|CPRT
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|const
operator|(
name|cline
operator|,
name|cid
operator|,
name|cdecl
operator|)
name|int
name|cline
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|cid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
modifier|*
name|cdecl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
ifdef|#
directive|ifdef
name|PI0
name|send
argument_list|(
name|REVCNST
argument_list|,
name|cline
argument_list|,
name|cid
argument_list|,
name|cdecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|line
operator|=
name|cline
expr_stmt|;
name|gconst
argument_list|(
name|cdecl
argument_list|)
expr_stmt|;
name|np
operator|=
name|enter
argument_list|(
name|defnl
argument_list|(
name|cid
argument_list|,
name|CONST
argument_list|,
name|con
operator|.
name|ctype
argument_list|,
name|con
operator|.
name|cival
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
name|np
operator|->
name|nl_flags
operator|=
operator||
name|NMOD
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|con
operator|.
name|ctype
operator|==
name|NIL
condition|)
return|return;
if|if
condition|(
name|isa
argument_list|(
name|con
operator|.
name|ctype
argument_list|,
literal|"i"
argument_list|)
condition|)
name|np
operator|->
name|range
index|[
literal|0
index|]
operator|=
name|con
operator|.
name|crval
expr_stmt|;
elseif|else
if|if
condition|(
name|isa
argument_list|(
name|con
operator|.
name|ctype
argument_list|,
literal|"d"
argument_list|)
condition|)
name|np
operator|->
name|real
operator|=
name|con
operator|.
name|crval
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|PI1
end_ifndef

begin_macro
name|constend
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Gconst extracts  * a constant declaration  * from the tree for it.  * only types of constants  * are integer, reals, strings  * and scalars, the first two  * being possibly signed.  */
end_comment

begin_macro
name|gconst
argument_list|(
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
specifier|register
operator|*
name|cn
expr_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|negd
decl_stmt|,
name|sgnd
decl_stmt|;
name|long
name|ci
decl_stmt|;
name|con
operator|.
name|ctype
operator|=
name|NIL
expr_stmt|;
name|cn
operator|=
name|r
expr_stmt|;
name|negd
operator|=
name|sgnd
operator|=
literal|0
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|cn
operator|==
name|NIL
operator|||
name|cn
index|[
literal|1
index|]
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
switch|switch
condition|(
name|cn
index|[
literal|0
index|]
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"gconst"
argument_list|)
expr_stmt|;
case|case
name|T_MINUSC
case|:
name|negd
operator|=
literal|1
operator|-
name|negd
expr_stmt|;
case|case
name|T_PLUSC
case|:
name|sgnd
operator|++
expr_stmt|;
name|cn
operator|=
name|cn
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|T_ID
case|:
name|np
operator|=
name|lookup
argument_list|(
name|cn
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NIL
condition|)
return|return;
if|if
condition|(
name|np
operator|->
name|class
operator|!=
name|CONST
condition|)
block|{
name|derror
argument_list|(
literal|"%s is a %s, not a constant as required"
argument_list|,
name|cn
index|[
literal|1
index|]
argument_list|,
name|classes
index|[
name|np
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|con
operator|.
name|ctype
operator|=
name|np
operator|->
name|type
expr_stmt|;
switch|switch
condition|(
name|classify
argument_list|(
name|np
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|TINT
case|:
name|con
operator|.
name|crval
operator|=
name|np
operator|->
name|range
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|TDOUBLE
case|:
name|con
operator|.
name|crval
operator|=
name|np
operator|->
name|real
expr_stmt|;
break|break;
case|case
name|TBOOL
case|:
case|case
name|TCHAR
case|:
case|case
name|TSTR
case|:
case|case
name|TSCAL
case|:
name|con
operator|.
name|cival
operator|=
name|np
operator|->
name|value
index|[
literal|0
index|]
expr_stmt|;
name|con
operator|.
name|crval
operator|=
name|con
operator|.
name|cival
expr_stmt|;
break|break;
case|case
name|NIL
case|:
name|con
operator|.
name|ctype
operator|=
name|NIL
expr_stmt|;
return|return;
default|default:
name|panic
argument_list|(
literal|"gconst2"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_CBINT
case|:
name|con
operator|.
name|crval
operator|=
name|a8tol
argument_list|(
name|cn
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|restcon
goto|;
case|case
name|T_CINT
case|:
name|con
operator|.
name|crval
operator|=
name|atof
argument_list|(
name|cn
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|con
operator|.
name|crval
operator|>
name|MAXINT
operator|||
name|con
operator|.
name|crval
operator|<
name|MININT
condition|)
block|{
name|derror
argument_list|(
literal|"Constant too large for this implementation"
argument_list|)
expr_stmt|;
name|con
operator|.
name|crval
operator|=
literal|0
expr_stmt|;
block|}
name|restcon
label|:
name|ci
operator|=
name|con
operator|.
name|crval
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
if|if
condition|(
name|bytes
argument_list|(
name|ci
argument_list|,
name|ci
argument_list|)
operator|<=
literal|2
condition|)
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|T2INT
expr_stmt|;
else|else
endif|#
directive|endif
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|T4INT
expr_stmt|;
break|break;
case|case
name|T_CFINT
case|:
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|TDOUBLE
expr_stmt|;
name|con
operator|.
name|crval
operator|=
name|atof
argument_list|(
name|cn
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CSTRNG
case|:
name|cp
operator|=
name|cn
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|T1CHAR
expr_stmt|;
name|con
operator|.
name|cival
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|con
operator|.
name|crval
operator|=
name|con
operator|.
name|cival
expr_stmt|;
break|break;
block|}
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|TSTR
expr_stmt|;
name|con
operator|.
name|cival
operator|=
name|savestr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|con
operator|.
name|crval
operator|=
name|con
operator|.
name|cival
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sgnd
condition|)
block|{
if|if
condition|(
name|isnta
argument_list|(
name|con
operator|.
name|ctype
argument_list|,
literal|"id"
argument_list|)
condition|)
name|derror
argument_list|(
literal|"%s constants cannot be signed"
argument_list|,
name|nameof
argument_list|(
name|con
operator|.
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|negd
condition|)
name|con
operator|.
name|crval
operator|=
operator|-
name|con
operator|.
name|crval
expr_stmt|;
name|ci
operator|=
name|con
operator|.
name|crval
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
if|if
condition|(
name|bytes
argument_list|(
name|ci
argument_list|,
name|ci
argument_list|)
operator|<=
literal|2
condition|)
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|T2INT
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_expr_stmt
name|isconst
argument_list|(
name|r
argument_list|)
specifier|register
name|int
operator|*
name|r
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|r
operator|==
name|NIL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|r
index|[
literal|0
index|]
condition|)
block|{
case|case
name|T_MINUS
case|:
name|r
index|[
literal|0
index|]
operator|=
name|T_MINUSC
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|r
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
name|isconst
argument_list|(
name|r
index|[
literal|1
index|]
argument_list|)
operator|)
return|;
case|case
name|T_PLUS
case|:
name|r
index|[
literal|0
index|]
operator|=
name|T_PLUSC
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|r
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
name|isconst
argument_list|(
name|r
index|[
literal|1
index|]
argument_list|)
operator|)
return|;
case|case
name|T_VAR
case|:
if|if
condition|(
name|r
index|[
literal|3
index|]
operator|!=
name|NIL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
index|[
literal|0
index|]
operator|=
name|T_ID
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|r
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_BINT
case|:
name|r
index|[
literal|0
index|]
operator|=
name|T_CBINT
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|r
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_INT
case|:
name|r
index|[
literal|0
index|]
operator|=
name|T_CINT
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|r
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_FINT
case|:
name|r
index|[
literal|0
index|]
operator|=
name|T_CFINT
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|r
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_STRNG
case|:
name|r
index|[
literal|0
index|]
operator|=
name|T_CSTRNG
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|r
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

