begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_comment
comment|/*  * Expreserve - preserve a file in /usr/preserve  * Bill Joy UCB November 13, 1977  *  * This routine is very naive - it doesn't remove anything from  * /usr/preserve... this may mean that we will be unable to preserve  * stuff there... the danger in doing anything with /usr/preserve  * is that the clock may be screwed up and we may get confused.  *  * We are called in two ways - first from the editor with no argumentss  * and the standard input open on the temp file. Second with an argument  * to preserve the entire contents of /tmp (root only).  *  * BUG: should do something about preserving Rx... (register contents)  *      temporaries.  */
end_comment

begin_define
define|#
directive|define
name|LBLKS
value|125
end_define

begin_define
define|#
directive|define
name|FNSIZE
value|128
end_define

begin_struct
struct|struct
name|header
block|{
name|time_t
name|Time
decl_stmt|;
comment|/* Time temp file last updated */
name|short
name|Uid
decl_stmt|;
comment|/* This users identity */
name|short
name|Flines
decl_stmt|;
comment|/* Number of lines in file */
name|char
name|Savedfile
index|[
name|FNSIZE
index|]
decl_stmt|;
comment|/* The current file name */
name|short
name|Blocks
index|[
name|LBLKS
index|]
decl_stmt|;
comment|/* Blocks where line pointers stashed */
block|}
name|H
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_define
define|#
directive|define
name|ignore
parameter_list|(
name|a
parameter_list|)
value|Ignore(a)
end_define

begin_define
define|#
directive|define
name|ignorl
parameter_list|(
name|a
parameter_list|)
value|Ignorl(a)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ignore
parameter_list|(
name|a
parameter_list|)
value|a
end_define

begin_define
define|#
directive|define
name|ignorl
parameter_list|(
name|a
parameter_list|)
value|a
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|eq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strcmp(a, b) == 0
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|)
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|tf
decl_stmt|;
name|struct
name|direct
name|dirent
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
comment|/* 	 * If only one argument, then preserve the standard input. 	 */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If not super user, then can only preserve standard input. 	 */
if|if
condition|(
name|getuid
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NOT super user\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * ... else preserve all the stuff in /tmp, removing 	 * it as we go. 	 */
if|if
condition|(
name|chdir
argument_list|(
literal|"/tmp"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tf
operator|=
name|fopen
argument_list|(
literal|"."
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dirent
argument_list|,
sizeof|sizeof
name|dirent
argument_list|,
literal|1
argument_list|,
name|tf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dirent
operator|.
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Ex temporaries must begin with Ex; 		 * we check that the 10th character of the name is null 		 * so we won't have to worry about non-null terminated names 		 * later on. 		 */
if|if
condition|(
name|dirent
operator|.
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'E'
operator|||
name|dirent
operator|.
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'x'
operator|||
name|dirent
operator|.
name|d_name
index|[
literal|10
index|]
condition|)
continue|continue;
if|if
condition|(
name|stat
argument_list|(
name|dirent
operator|.
name|d_name
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
continue|continue;
comment|/* 		 * Save the bastard. 		 */
name|ignore
argument_list|(
name|copyout
argument_list|(
name|dirent
operator|.
name|d_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
name|pattern
index|[]
init|=
literal|"/usr/preserve/Exaa`XXXXX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Copy file name into /usr/preserve/...  * If name is (char *) 0, then do the standard input.  * We make some checks on the input to make sure it is  * really an editor temporary, generate a name for the  * file (this is the slowest thing since we must stat  * to find a unique name), and finally copy the file.  */
end_comment

begin_macro
name|copyout
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|reenter
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* 	 * The first time we put in the digits of our 	 * process number at the end of the pattern. 	 */
if|if
condition|(
name|reenter
operator|==
literal|0
condition|)
block|{
name|mkdigits
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|reenter
operator|++
expr_stmt|;
block|}
comment|/* 	 * If a file name was given, make it the standard 	 * input if possible. 	 */
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
block|{
name|ignore
argument_list|(
name|close
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Need read/write access for arcane reasons 		 * (see below). 		 */
if|if
condition|(
name|open
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get the header block. 	 */
name|ignorl
argument_list|(
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|H
argument_list|,
sizeof|sizeof
name|H
argument_list|)
operator|!=
sizeof|sizeof
name|H
condition|)
block|{
name|format
label|:
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Buffer format error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Consistency checsks so we don't copy out garbage. 	 */
if|if
condition|(
name|H
operator|.
name|Flines
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Negative number of lines\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|format
goto|;
block|}
if|if
condition|(
name|H
operator|.
name|Blocks
index|[
literal|0
index|]
operator|!=
literal|1
operator|||
name|H
operator|.
name|Blocks
index|[
literal|1
index|]
operator|!=
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Blocks %d %d\n"
argument_list|,
name|H
operator|.
name|Blocks
index|[
literal|0
index|]
argument_list|,
name|H
operator|.
name|Blocks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|format
goto|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
operator|&&
name|H
operator|.
name|Uid
operator|!=
name|getuid
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrong user-id\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|format
goto|;
block|}
if|if
condition|(
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Negative number of lines\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|format
goto|;
block|}
comment|/* 	 * If no name was assigned to the file, then give it the name 	 * LOST, by putting this in the header. 	 */
if|if
condition|(
name|H
operator|.
name|Savedfile
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|H
operator|.
name|Savedfile
argument_list|,
literal|"LOST"
argument_list|)
expr_stmt|;
name|ignore
argument_list|(
name|write
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|H
argument_list|,
sizeof|sizeof
name|H
argument_list|)
argument_list|)
expr_stmt|;
name|H
operator|.
name|Savedfile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * File is good.  Get a name and create a file for the copy. 	 */
name|mknext
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|ignore
argument_list|(
name|close
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|creat
argument_list|(
name|pattern
argument_list|,
literal|0600
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|perror
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Make the target be owned by the owner of the file. 	 */
name|ignore
argument_list|(
name|chown
argument_list|(
name|pattern
argument_list|,
name|H
operator|.
name|Uid
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the file. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|perror
argument_list|(
literal|"Buffer read error"
argument_list|)
expr_stmt|;
name|ignore
argument_list|(
name|unlink
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|name
condition|)
block|{
name|ignore
argument_list|(
name|unlink
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|notify
argument_list|(
name|H
operator|.
name|Uid
argument_list|,
name|H
operator|.
name|Savedfile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|perror
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Blast the last 5 characters of cp to be the process number.  */
end_comment

begin_macro
name|mkdigits
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|getpid
argument_list|()
operator|,
name|j
operator|=
literal|5
operator|,
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
init|;
name|j
operator|>
literal|0
condition|;
name|i
operator|/=
literal|10
operator|,
name|j
operator|--
control|)
operator|*
operator|--
name|cp
operator|=
name|i
operator|%
literal|10
operator||
literal|'0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Make the name in cp be unique by clobbering up to  * three alphabetic characters into a sequence of the form 'aab', 'aac', etc.  * Mktemp gets weird names too quickly to be useful here.  */
end_comment

begin_macro
name|mknext
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|dcp
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|dcp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|dcp
argument_list|)
condition|)
name|dcp
operator|--
expr_stmt|;
name|whoops
label|:
if|if
condition|(
name|dcp
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|dcp
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|dcp
index|[
operator|-
literal|1
index|]
operator|==
literal|'z'
condition|)
block|{
name|dcp
index|[
operator|-
literal|1
index|]
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|dcp
index|[
operator|-
literal|2
index|]
operator|==
literal|'z'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find a name\n"
argument_list|)
expr_stmt|;
name|dcp
index|[
operator|-
literal|2
index|]
operator|++
expr_stmt|;
block|}
else|else
name|dcp
index|[
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
else|else
name|dcp
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|whoops
goto|;
block|}
end_block

begin_comment
comment|/*  * Notify user uid that his file fname has been saved.  */
end_comment

begin_macro
name|notify
argument_list|(
argument|uid
argument_list|,
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|passwd
modifier|*
name|pp
init|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|mf
decl_stmt|;
name|char
name|cmd
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"mail %s"
argument_list|,
name|pp
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|mf
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
operator|==
name|NULL
condition|)
return|return;
name|setbuf
argument_list|(
name|mf
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"A copy of an editor buffer of yours was saved when the system went down.\n\ No name was associated with this buffer so it has been named \"LOST\".\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"A copy of an editor buffer of your file \"%s\"\n\ was saved when the system went down.\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"This buffer can be retrieved using the \"recover\" command of the editor.\n\ An easy way to do this is to give the command ``ex -r'' followed by the\n\ name of file you were editing.  This works for ``edit'' and ``vi'' also.\n"
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	people making love  *	never exactly the same  *	just like a snowflake   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_macro
name|Ignore
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_macro
name|Ignorl
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|long
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

