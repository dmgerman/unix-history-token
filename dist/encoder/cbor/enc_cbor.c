begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2015, Juniper Networks, Inc.  * All rights reserved.  * This SOFTWARE is licensed under the LICENSE provided in the  * ../Copyright file. By downloading, installing, copying, or otherwise  * using the SOFTWARE, you agree to be bound by the terms of that  * LICENSE.  * Phil Shafer, August 2015  */
end_comment

begin_comment
comment|/*  * CBOR (RFC 7049) mades a suitable test case for libxo's external  * encoder API.  It's simple, streaming, well documented, and an  * IETF standard.  *  * This encoder uses the "pretty" flag for diagnostics, which isn't  * really kosher, but it's example code.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"xo.h"
end_include

begin_include
include|#
directive|include
file|"xo_encoder.h"
end_include

begin_include
include|#
directive|include
file|"xo_buf.h"
end_include

begin_comment
comment|/*  * memdump(): dump memory contents in hex/ascii 0         1         2         3         4         5         6         7 0123456789012345678901234567890123456789012345678901234567890123456789012345 XX XX XX XX  XX XX XX XX - XX XX XX XX  XX XX XX XX abcdefghijklmnop  */
end_comment

begin_function
specifier|static
name|void
name|cbor_memdump
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
enum|enum
block|{
name|MAX_PER_LINE
init|=
literal|16
block|}
enum|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|char
name|text
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|static const int ends[ MAX_PER_LINE ] = { 2, 5, 8, 11, 15, 18, 21, 24,                                               29, 32, 35, 38, 42, 45, 48, 51 };
endif|#
directive|endif
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|fp
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
name|tag
operator|=
literal|""
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s[%s] @ %p (%lx/%lu)\n"
argument_list|,
name|indent
operator|+
literal|1
argument_list|,
name|tag
argument_list|,
name|title
argument_list|,
name|data
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
name|tp
operator|=
name|text
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PER_LINE
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|&&
operator|(
name|i
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|8
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%02x "
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|data
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
operator|(
name|isprint
argument_list|(
operator|(
name|int
operator|)
operator|*
name|data
argument_list|)
operator|&&
operator|*
name|data
operator|>=
literal|' '
operator|)
condition|?
operator|*
name|data
else|:
literal|'.'
expr_stmt|;
name|data
operator|+=
literal|1
expr_stmt|;
block|}
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s%-54s%s\n"
argument_list|,
name|indent
operator|+
literal|1
argument_list|,
name|tag
argument_list|,
name|buf
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * CBOR breaks the first byte into two pieces, the major type in the  * top 3 bits and the minor value in the low 5 bits.  The value can be  * a small value (0 .. 23), an 8-bit value (24), a 16-bit value (25),  * a 32-bit value (26), or a 64-bit value (27).  A value of 31  * represents an unknown length, which we'll use extensively for  * streaming our content.  */
end_comment

begin_define
define|#
directive|define
name|CBOR_MAJOR_MASK
value|0xE0
end_define

begin_define
define|#
directive|define
name|CBOR_MINOR_MASK
value|0x1F
end_define

begin_define
define|#
directive|define
name|CBOR_MAJOR_SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|CBOR_MAJOR
parameter_list|(
name|_x
parameter_list|)
value|((_x)& CBOR_MAJOR_MASK)
end_define

begin_define
define|#
directive|define
name|CBOR_MAJOR_VAL
parameter_list|(
name|_x
parameter_list|)
value|((_x)<< CBOR_MAJOR_SHIFT)
end_define

begin_define
define|#
directive|define
name|CBOR_MINOR_VAL
parameter_list|(
name|_x
parameter_list|)
value|((_x)& CBOR_MINOR_MASK)
end_define

begin_comment
comment|/* Major type codes */
end_comment

begin_define
define|#
directive|define
name|CBOR_UNSIGNED
value|CBOR_MAJOR_VAL(0)
end_define

begin_comment
comment|/* 0x00 */
end_comment

begin_define
define|#
directive|define
name|CBOR_NEGATIVE
value|CBOR_MAJOR_VAL(1)
end_define

begin_comment
comment|/* 0x20 */
end_comment

begin_define
define|#
directive|define
name|CBOR_BYTES
value|CBOR_MAJOR_VAL(2)
end_define

begin_comment
comment|/* 0x40 */
end_comment

begin_define
define|#
directive|define
name|CBOR_STRING
value|CBOR_MAJOR_VAL(3)
end_define

begin_comment
comment|/* 0x60 */
end_comment

begin_define
define|#
directive|define
name|CBOR_ARRAY
value|CBOR_MAJOR_VAL(4)
end_define

begin_comment
comment|/* 0x80 */
end_comment

begin_define
define|#
directive|define
name|CBOR_MAP
value|CBOR_MAJOR_VAL(5)
end_define

begin_comment
comment|/* 0xa0 */
end_comment

begin_define
define|#
directive|define
name|CBOR_SEMANTIC
value|CBOR_MAJOR_VAL(6)
end_define

begin_comment
comment|/* 0xc0 */
end_comment

begin_define
define|#
directive|define
name|CBOR_SPECIAL
value|CBOR_MAJOR_VAL(7)
end_define

begin_comment
comment|/* 0xe0 */
end_comment

begin_define
define|#
directive|define
name|CBOR_ULIMIT
value|24
end_define

begin_comment
comment|/* Largest unsigned value */
end_comment

begin_define
define|#
directive|define
name|CBOR_NLIMIT
value|23
end_define

begin_comment
comment|/* Largest negative value */
end_comment

begin_define
define|#
directive|define
name|CBOR_BREAK
value|0xFF
end_define

begin_define
define|#
directive|define
name|CBOR_INDEF
value|0x1F
end_define

begin_define
define|#
directive|define
name|CBOR_FALSE
value|0xF4
end_define

begin_define
define|#
directive|define
name|CBOR_TRUE
value|0xF5
end_define

begin_define
define|#
directive|define
name|CBOR_NULL
value|0xF6
end_define

begin_define
define|#
directive|define
name|CBOR_UNDEF
value|0xF7
end_define

begin_define
define|#
directive|define
name|CBOR_LEN8
value|0x18
end_define

begin_comment
comment|/* 24 - 8-bit value */
end_comment

begin_define
define|#
directive|define
name|CBOR_LEN16
value|0x19
end_define

begin_comment
comment|/* 25 - 16-bit value */
end_comment

begin_define
define|#
directive|define
name|CBOR_LEN32
value|0x1a
end_define

begin_comment
comment|/* 26 - 32-bit value */
end_comment

begin_define
define|#
directive|define
name|CBOR_LEN64
value|0x1b
end_define

begin_comment
comment|/* 27 - 64-bit value */
end_comment

begin_define
define|#
directive|define
name|CBOR_LEN128
value|0x1c
end_define

begin_comment
comment|/* 28 - 128-bit value */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cbor_private_s
block|{
name|xo_buffer_t
name|c_data
decl_stmt|;
comment|/* Our data buffer */
name|unsigned
name|c_indent
decl_stmt|;
comment|/* Indent level */
name|unsigned
name|c_open_leaf_list
decl_stmt|;
comment|/* Open leaf list construct? */
block|}
name|cbor_private_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|cbor_encode_uint
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|uint64_t
name|minor
parameter_list|,
name|unsigned
name|limit
parameter_list|)
block|{
name|char
modifier|*
name|bp
init|=
name|xbp
operator|->
name|xb_curp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|minor
operator|>
operator|(
literal|1ULL
operator|<<
literal|32
operator|)
condition|)
block|{
operator|*
name|bp
operator|++
operator||=
name|CBOR_LEN64
expr_stmt|;
name|m
operator|=
literal|64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minor
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
operator|*
name|bp
operator|++
operator||=
name|CBOR_LEN32
expr_stmt|;
name|m
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minor
operator|>
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
block|{
operator|*
name|bp
operator|++
operator||=
name|CBOR_LEN16
expr_stmt|;
name|m
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minor
operator|>
name|limit
condition|)
block|{
operator|*
name|bp
operator|++
operator||=
name|CBOR_LEN8
expr_stmt|;
name|m
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bp
operator|++
operator||=
name|minor
operator|&
name|CBOR_MINOR_MASK
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
for|for
control|(
name|i
operator|=
name|m
operator|-
literal|8
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|-=
literal|8
control|)
operator|*
name|bp
operator|++
operator|=
name|minor
operator|>>
name|i
expr_stmt|;
block|}
name|xbp
operator|->
name|xb_curp
operator|=
name|bp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cbor_append
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|cbor_private_t
modifier|*
name|cbor
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|unsigned
name|major
parameter_list|,
name|unsigned
name|minor
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|minor
operator|+
literal|2
argument_list|)
condition|)
return|return;
name|unsigned
name|offset
init|=
name|xo_buf_offset
argument_list|(
name|xbp
argument_list|)
decl_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|=
name|major
expr_stmt|;
name|cbor_encode_uint
argument_list|(
name|xbp
argument_list|,
name|minor
argument_list|,
name|CBOR_ULIMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|data
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_get_flags
argument_list|(
name|xop
argument_list|)
operator|&
name|XOF_PRETTY
condition|)
name|cbor_memdump
argument_list|(
name|stdout
argument_list|,
literal|"append"
argument_list|,
name|xo_buf_data
argument_list|(
name|xbp
argument_list|,
name|offset
argument_list|)
argument_list|,
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|-
name|offset
argument_list|,
literal|""
argument_list|,
name|cbor
operator|->
name|c_indent
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbor_create
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|cbor_private_t
modifier|*
name|cbor
init|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cbor
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cbor
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|bzero
argument_list|(
name|cbor
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cbor
argument_list|)
argument_list|)
expr_stmt|;
name|xo_buf_init
argument_list|(
operator|&
name|cbor
operator|->
name|c_data
argument_list|)
expr_stmt|;
name|xo_set_private
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|)
expr_stmt|;
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
operator|&
name|cbor
operator|->
name|c_data
argument_list|,
name|CBOR_MAP
operator||
name|CBOR_INDEF
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbor_content
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|cbor_private_t
modifier|*
name|cbor
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|unsigned
name|offset
init|=
name|xo_buf_offset
argument_list|(
name|xbp
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
operator|||
operator|*
name|value
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
condition|)
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
operator|&
name|cbor
operator|->
name|c_data
argument_list|,
name|CBOR_TRUE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"false"
argument_list|)
operator|==
literal|0
condition|)
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
operator|&
name|cbor
operator|->
name|c_data
argument_list|,
name|CBOR_FALSE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|negative
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'-'
condition|)
block|{
name|value
operator|+=
literal|1
expr_stmt|;
name|negative
operator|=
literal|1
expr_stmt|;
block|}
name|char
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|long
name|long
name|ival
decl_stmt|;
name|ival
operator|=
name|strtoull
argument_list|(
name|value
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ival
operator|==
name|ULLONG_MAX
condition|)
comment|/* Sometimes a string is just a string */
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_STRING
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|xbp
operator|->
name|xb_curp
operator|=
name|negative
condition|?
name|CBOR_NEGATIVE
else|:
name|CBOR_UNSIGNED
expr_stmt|;
if|if
condition|(
name|negative
condition|)
name|ival
operator|-=
literal|1
expr_stmt|;
comment|/* Don't waste a negative zero */
name|cbor_encode_uint
argument_list|(
name|xbp
argument_list|,
name|ival
argument_list|,
name|negative
condition|?
name|CBOR_NLIMIT
else|:
name|CBOR_ULIMIT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xo_get_flags
argument_list|(
name|xop
argument_list|)
operator|&
name|XOF_PRETTY
condition|)
name|cbor_memdump
argument_list|(
name|stdout
argument_list|,
literal|"content"
argument_list|,
name|xo_buf_data
argument_list|(
name|xbp
argument_list|,
name|offset
argument_list|)
argument_list|,
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|-
name|offset
argument_list|,
literal|""
argument_list|,
name|cbor
operator|->
name|c_indent
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbor_handler
parameter_list|(
name|XO_ENCODER_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|cbor_private_t
modifier|*
name|cbor
init|=
name|private
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
name|cbor
condition|?
operator|&
name|cbor
operator|->
name|c_data
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|xo_get_flags
argument_list|(
name|xop
argument_list|)
operator|&
name|XOF_PRETTY
condition|)
block|{
name|printf
argument_list|(
literal|"%*sop %s: [%s] [%s]\n"
argument_list|,
name|cbor
condition|?
name|cbor
operator|->
name|c_indent
operator|*
literal|2
operator|+
literal|4
else|:
literal|0
argument_list|,
literal|""
argument_list|,
name|xo_encoder_op_name
argument_list|(
name|op
argument_list|)
argument_list|,
name|name
condition|?
else|:
literal|""
argument_list|,
name|value
condition|?
else|:
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't have private data, we're sunk */
if|if
condition|(
name|cbor
operator|==
name|NULL
operator|&&
name|op
operator|!=
name|XO_OP_CREATE
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|XO_OP_CREATE
case|:
comment|/* Called when the handle is init'd */
name|rc
operator|=
name|cbor_create
argument_list|(
name|xop
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_OP_OPEN_CONTAINER
case|:
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_STRING
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_MAP
operator||
name|CBOR_INDEF
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cbor
operator|->
name|c_indent
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|XO_OP_CLOSE_CONTAINER
case|:
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_BREAK
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cbor
operator|->
name|c_indent
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|XO_OP_OPEN_LIST
case|:
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_STRING
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_ARRAY
operator||
name|CBOR_INDEF
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cbor
operator|->
name|c_indent
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|XO_OP_CLOSE_LIST
case|:
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_BREAK
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cbor
operator|->
name|c_indent
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|XO_OP_OPEN_LEAF_LIST
case|:
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_STRING
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_ARRAY
operator||
name|CBOR_INDEF
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cbor
operator|->
name|c_indent
operator|+=
literal|1
expr_stmt|;
name|cbor
operator|->
name|c_open_leaf_list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XO_OP_CLOSE_LEAF_LIST
case|:
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_BREAK
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cbor
operator|->
name|c_indent
operator|-=
literal|1
expr_stmt|;
name|cbor
operator|->
name|c_open_leaf_list
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XO_OP_OPEN_INSTANCE
case|:
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_MAP
operator||
name|CBOR_INDEF
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cbor
operator|->
name|c_indent
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|XO_OP_CLOSE_INSTANCE
case|:
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_BREAK
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cbor
operator|->
name|c_indent
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|XO_OP_STRING
case|:
comment|/* Quoted UTF-8 string */
if|if
condition|(
operator|!
name|cbor
operator|->
name|c_open_leaf_list
condition|)
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_STRING
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_STRING
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_OP_CONTENT
case|:
comment|/* Other content */
if|if
condition|(
operator|!
name|cbor
operator|->
name|c_open_leaf_list
condition|)
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_STRING
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * It's content, not string, so we need to look at the 	 * string and build some content.  Turns out we only 	 * care about true, false, null, and numbers. 	 */
name|cbor_content
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_OP_FINISH
case|:
comment|/* Clean up function */
name|cbor_append
argument_list|(
name|xop
argument_list|,
name|cbor
argument_list|,
name|xbp
argument_list|,
name|CBOR_BREAK
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cbor
operator|->
name|c_indent
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|XO_OP_FLUSH
case|:
comment|/* Clean up function */
if|if
condition|(
name|xo_get_flags
argument_list|(
name|xop
argument_list|)
operator|&
name|XOF_PRETTY
condition|)
name|cbor_memdump
argument_list|(
name|stdout
argument_list|,
literal|"cbor"
argument_list|,
name|xbp
operator|->
name|xb_bufp
argument_list|,
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
argument_list|,
literal|">"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|write
argument_list|(
literal|1
argument_list|,
name|xbp
operator|->
name|xb_bufp
argument_list|,
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|rc
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|XO_OP_DESTROY
case|:
comment|/* Clean up function */
break|break;
case|case
name|XO_OP_ATTRIBUTE
case|:
comment|/* Attribute name/value */
break|break;
case|case
name|XO_OP_VERSION
case|:
comment|/* Version string */
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_encoder_library_init
parameter_list|(
name|XO_ENCODER_INIT_ARGS
parameter_list|)
block|{
name|arg
operator|->
name|xei_handler
operator|=
name|cbor_handler
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

