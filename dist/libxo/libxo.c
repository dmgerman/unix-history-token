begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014-2015, Juniper Networks, Inc.  * All rights reserved.  * This SOFTWARE is licensed under the LICENSE provided in the  * ../Copyright file. By downloading, installing, copying, or otherwise  * using the SOFTWARE, you agree to be bound by the terms of that  * LICENSE.  * Phil Shafer, July 2014  *  * This is the implementation of libxo, the formatting library that  * generates multiple styles of output from a single code path.  * Command line utilities can have their normal text output while  * automation tools can see XML or JSON output, and web tools can use  * HTML output that encodes the text output annotated with additional  * information.  Specialized encoders can be built that allow custom  * encoding including binary ones like CBOR, thrift, protobufs, etc.  *  * Full documentation is available in ./doc/libxo.txt or online at:  *   http://juniper.github.io/libxo/libxo-manual.html  *  * For first time readers, the core bits of code to start looking at are:  * - xo_do_emit() -- parse and emit a set of fields  * - xo_do_emit_fields -- the central function of the library  * - xo_do_format_field() -- handles formatting a single field  * - xo_transiton() -- the state machine that keeps things sane  * and of course the "xo_handle_t" data structure, which carries all  * configuration and state.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|"xo_config.h"
end_include

begin_include
include|#
directive|include
file|"xo.h"
end_include

begin_include
include|#
directive|include
file|"xo_encoder.h"
end_include

begin_include
include|#
directive|include
file|"xo_buf.h"
end_include

begin_comment
comment|/*  * We ask wcwidth() to do an impossible job, really.  It's supposed to  * need to tell us the number of columns consumed to display a unicode  * character.  It returns that number without any sort of context, but  * we know they are characters whose glyph differs based on placement  * (end of word, middle of word, etc) and many that affect characters  * previously emitted.  Without content, it can't hope to tell us.  * But it's the only standard tool we've got, so we use it.  We would  * use wcswidth() but it typically just loops through adding the results  * of wcwidth() calls in an entirely unhelpful way.  *  * Even then, there are many poor implementations (macosx), so we have  * to carry our own.  We could have configure.ac test this (with  * something like 'assert(wcwidth(0x200d) == 0)'), but it would have  * to run a binary, which breaks cross-compilation.  Hmm... I could  * run this test at init time and make a warning for our dear user.  *  * Anyhow, it remains a best-effort sort of thing.  And it's all made  * more hopeless because we assume the display code doing the rendering is  * playing by the same rules we are.  If it display 0x200d as a square  * box or a funky question mark, the output will be hosed.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LIBXO_WCWIDTH
end_ifdef

begin_include
include|#
directive|include
file|"xo_wcwidth.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LIBXO_WCWIDTH */
end_comment

begin_define
define|#
directive|define
name|xo_wcwidth
parameter_list|(
name|_x
parameter_list|)
value|wcwidth(_x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBXO_WCWIDTH */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDIO_EXT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdio_ext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDIO_EXT_H */
end_comment

begin_comment
comment|/*  * humanize_number is a great function, unless you don't have it.  So  * we carry one in our pocket.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_HUMANIZE_NUMBER
end_ifdef

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_define
define|#
directive|define
name|xo_humanize_number
value|humanize_number
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_HUMANIZE_NUMBER */
end_comment

begin_include
include|#
directive|include
file|"xo_humanize.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_HUMANIZE_NUMBER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETTEXT
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GETTEXT */
end_comment

begin_comment
comment|/*  * Three styles of specifying thread-local variables are supported.  * configure.ac has the brains to run each possibility through the  * compiler and see what works; we are left to define the THREAD_LOCAL  * macro to the right value.  Most toolchains (clang, gcc) use  * "before", but some (borland) use "after" and I've heard of some  * (ms) that use __declspec.  Any others out there?  */
end_comment

begin_define
define|#
directive|define
name|THREAD_LOCAL_before
value|1
end_define

begin_define
define|#
directive|define
name|THREAD_LOCAL_after
value|2
end_define

begin_define
define|#
directive|define
name|THREAD_LOCAL_declspec
value|3
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_THREAD_LOCAL
end_ifndef

begin_define
define|#
directive|define
name|THREAD_LOCAL
parameter_list|(
name|_x
parameter_list|)
value|_x
end_define

begin_elif
elif|#
directive|elif
name|HAVE_THREAD_LOCAL
operator|==
name|THREAD_LOCAL_before
end_elif

begin_define
define|#
directive|define
name|THREAD_LOCAL
parameter_list|(
name|_x
parameter_list|)
value|__thread _x
end_define

begin_elif
elif|#
directive|elif
name|HAVE_THREAD_LOCAL
operator|==
name|THREAD_LOCAL_after
end_elif

begin_define
define|#
directive|define
name|THREAD_LOCAL
parameter_list|(
name|_x
parameter_list|)
value|_x __thread
end_define

begin_elif
elif|#
directive|elif
name|HAVE_THREAD_LOCAL
operator|==
name|THREAD_LOCAL_declspec
end_elif

begin_define
define|#
directive|define
name|THREAD_LOCAL
parameter_list|(
name|_x
parameter_list|)
value|__declspec(_x)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|unknown thread-local setting
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_THREADS_H */
end_comment

begin_decl_stmt
specifier|const
name|char
name|xo_version
index|[]
init|=
name|LIBXO_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|xo_version_extra
index|[]
init|=
name|LIBXO_VERSION_EXTRA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|xo_default_format
index|[]
init|=
literal|"%s"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED
end_ifndef

begin_define
define|#
directive|define
name|UNUSED
value|__attribute__ ((__unused__))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_define
define|#
directive|define
name|XO_INDENT_BY
value|2
end_define

begin_comment
comment|/* Amount to indent when pretty printing */
end_comment

begin_define
define|#
directive|define
name|XO_DEPTH
value|128
end_define

begin_comment
comment|/* Default stack depth */
end_comment

begin_define
define|#
directive|define
name|XO_MAX_ANCHOR_WIDTH
value|(8*1024)
end_define

begin_comment
comment|/* Anything wider is just sillyb */
end_comment

begin_define
define|#
directive|define
name|XO_FAILURE_NAME
value|"failure"
end_define

begin_comment
comment|/* Flags for the stack frame */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|xo_xsf_flags_t
typedef|;
end_typedef

begin_comment
comment|/* XSF_* flags */
end_comment

begin_define
define|#
directive|define
name|XSF_NOT_FIRST
value|(1<<0)
end_define

begin_comment
comment|/* Not the first element */
end_comment

begin_define
define|#
directive|define
name|XSF_LIST
value|(1<<1)
end_define

begin_comment
comment|/* Frame is a list */
end_comment

begin_define
define|#
directive|define
name|XSF_INSTANCE
value|(1<<2)
end_define

begin_comment
comment|/* Frame is an instance */
end_comment

begin_define
define|#
directive|define
name|XSF_DTRT
value|(1<<3)
end_define

begin_comment
comment|/* Save the name for DTRT mode */
end_comment

begin_define
define|#
directive|define
name|XSF_CONTENT
value|(1<<4)
end_define

begin_comment
comment|/* Some content has been emitted */
end_comment

begin_define
define|#
directive|define
name|XSF_EMIT
value|(1<<5)
end_define

begin_comment
comment|/* Some field has been emitted */
end_comment

begin_define
define|#
directive|define
name|XSF_EMIT_KEY
value|(1<<6)
end_define

begin_comment
comment|/* A key has been emitted */
end_comment

begin_define
define|#
directive|define
name|XSF_EMIT_LEAF_LIST
value|(1<<7)
end_define

begin_comment
comment|/* A leaf-list field has been emitted */
end_comment

begin_comment
comment|/* These are the flags we propagate between markers and their parents */
end_comment

begin_define
define|#
directive|define
name|XSF_MARKER_FLAGS
define|\
value|(XSF_NOT_FIRST | XSF_CONTENT | XSF_EMIT | XSF_EMIT_KEY | XSF_EMIT_LEAF_LIST )
end_define

begin_comment
comment|/*  * A word about states: We use a finite state machine (FMS) approach  * to help remove fragility from the caller's code.  Instead of  * requiring a specific order of calls, we'll allow the caller more  * flexibility and make the library responsible for recovering from  * missed steps.  The goal is that the library should not be capable  * of emitting invalid xml or json, but the developer shouldn't need  * to know or understand all the details about these encodings.  *  * You can think of states as either states or events, since they  * function rather like both.  None of the XO_CLOSE_* events will  * persist as states, since the matching stack frame will be popped.  * Same is true of XSS_EMIT, which is an event that asks us to  * prep for emitting output fields.  */
end_comment

begin_comment
comment|/* Stack frame states */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|xo_state_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|XSS_INIT
value|0
end_define

begin_comment
comment|/* Initial stack state */
end_comment

begin_define
define|#
directive|define
name|XSS_OPEN_CONTAINER
value|1
end_define

begin_define
define|#
directive|define
name|XSS_CLOSE_CONTAINER
value|2
end_define

begin_define
define|#
directive|define
name|XSS_OPEN_LIST
value|3
end_define

begin_define
define|#
directive|define
name|XSS_CLOSE_LIST
value|4
end_define

begin_define
define|#
directive|define
name|XSS_OPEN_INSTANCE
value|5
end_define

begin_define
define|#
directive|define
name|XSS_CLOSE_INSTANCE
value|6
end_define

begin_define
define|#
directive|define
name|XSS_OPEN_LEAF_LIST
value|7
end_define

begin_define
define|#
directive|define
name|XSS_CLOSE_LEAF_LIST
value|8
end_define

begin_define
define|#
directive|define
name|XSS_DISCARDING
value|9
end_define

begin_comment
comment|/* Discarding data until recovered */
end_comment

begin_define
define|#
directive|define
name|XSS_MARKER
value|10
end_define

begin_comment
comment|/* xo_open_marker's marker */
end_comment

begin_define
define|#
directive|define
name|XSS_EMIT
value|11
end_define

begin_comment
comment|/* xo_emit has a leaf field */
end_comment

begin_define
define|#
directive|define
name|XSS_EMIT_LEAF_LIST
value|12
end_define

begin_comment
comment|/* xo_emit has a leaf-list ({l:}) */
end_comment

begin_define
define|#
directive|define
name|XSS_FINISH
value|13
end_define

begin_comment
comment|/* xo_finish was called */
end_comment

begin_define
define|#
directive|define
name|XSS_MAX
value|13
end_define

begin_define
define|#
directive|define
name|XSS_TRANSITION
parameter_list|(
name|_old
parameter_list|,
name|_new
parameter_list|)
value|((_old)<< 8 | (_new))
end_define

begin_comment
comment|/*  * xo_stack_t: As we open and close containers and levels, we  * create a stack of frames to track them.  This is needed for  * XOF_WARN and XOF_XPATH.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_stack_s
block|{
name|xo_xsf_flags_t
name|xs_flags
decl_stmt|;
comment|/* Flags for this frame */
name|xo_state_t
name|xs_state
decl_stmt|;
comment|/* State for this stack frame */
name|char
modifier|*
name|xs_name
decl_stmt|;
comment|/* Name (for XPath value) */
name|char
modifier|*
name|xs_keys
decl_stmt|;
comment|/* XPath predicate for any key fields */
block|}
name|xo_stack_t
typedef|;
end_typedef

begin_comment
comment|/*  * libxo supports colors and effects, for those who like them.  * XO_COL_* ("colors") refers to fancy ansi codes, while X__EFF_*  * ("effects") are bits since we need to maintain state.  */
end_comment

begin_define
define|#
directive|define
name|XO_COL_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|XO_COL_BLACK
value|1
end_define

begin_define
define|#
directive|define
name|XO_COL_RED
value|2
end_define

begin_define
define|#
directive|define
name|XO_COL_GREEN
value|3
end_define

begin_define
define|#
directive|define
name|XO_COL_YELLOW
value|4
end_define

begin_define
define|#
directive|define
name|XO_COL_BLUE
value|5
end_define

begin_define
define|#
directive|define
name|XO_COL_MAGENTA
value|6
end_define

begin_define
define|#
directive|define
name|XO_COL_CYAN
value|7
end_define

begin_define
define|#
directive|define
name|XO_COL_WHITE
value|8
end_define

begin_define
define|#
directive|define
name|XO_NUM_COLORS
value|9
end_define

begin_comment
comment|/*  * Yes, there's no blink.  We're civilized.  We like users.  Blink  * isn't something one does to someone you like.  Friends don't let  * friends use blink.  On friends.  You know what I mean.  Blink is  * like, well, it's like bursting into show tunes at a funeral.  It's  * just not done.  Not something anyone wants.  And on those rare  * instances where it might actually be appropriate, it's still wrong,  * since it's likely done by the wrong person for the wrong reason.  * Just like blink.  And if I implemented blink, I'd be like a funeral  * director who adds "Would you like us to burst into show tunes?" on  * the list of questions asked while making funeral arrangements.  * It's formalizing wrongness in the wrong way.  And we're just too  * civilized to do that.  Hhhmph!  */
end_comment

begin_define
define|#
directive|define
name|XO_EFF_RESET
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|XO_EFF_NORMAL
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|XO_EFF_BOLD
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|XO_EFF_UNDERLINE
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|XO_EFF_INVERSE
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|XO_EFF_CLEAR_BITS
value|XO_EFF_RESET
end_define

begin_comment
comment|/* Reset gets reset, surprisingly */
end_comment

begin_typedef
typedef|typedef
name|uint8_t
name|xo_effect_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint8_t
name|xo_color_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|xo_colors_s
block|{
name|xo_effect_t
name|xoc_effects
decl_stmt|;
comment|/* Current effect set */
name|xo_color_t
name|xoc_col_fg
decl_stmt|;
comment|/* Foreground color */
name|xo_color_t
name|xoc_col_bg
decl_stmt|;
comment|/* Background color */
block|}
name|xo_colors_t
typedef|;
end_typedef

begin_comment
comment|/*  * xo_handle_t: this is the principle data structure for libxo.  * It's used as a store for state, options, content, and all manor  * of other information.  */
end_comment

begin_struct
struct|struct
name|xo_handle_s
block|{
name|xo_xof_flags_t
name|xo_flags
decl_stmt|;
comment|/* Flags (XOF_*) from the user*/
name|xo_xof_flags_t
name|xo_iflags
decl_stmt|;
comment|/* Internal flags (XOIF_*) */
name|xo_style_t
name|xo_style
decl_stmt|;
comment|/* XO_STYLE_* value */
name|unsigned
name|short
name|xo_indent
decl_stmt|;
comment|/* Indent level (if pretty) */
name|unsigned
name|short
name|xo_indent_by
decl_stmt|;
comment|/* Indent amount (tab stop) */
name|xo_write_func_t
name|xo_write
decl_stmt|;
comment|/* Write callback */
name|xo_close_func_t
name|xo_close
decl_stmt|;
comment|/* Close callback */
name|xo_flush_func_t
name|xo_flush
decl_stmt|;
comment|/* Flush callback */
name|xo_formatter_t
name|xo_formatter
decl_stmt|;
comment|/* Custom formating function */
name|xo_checkpointer_t
name|xo_checkpointer
decl_stmt|;
comment|/* Custom formating support function */
name|void
modifier|*
name|xo_opaque
decl_stmt|;
comment|/* Opaque data for write function */
name|xo_buffer_t
name|xo_data
decl_stmt|;
comment|/* Output data */
name|xo_buffer_t
name|xo_fmt
decl_stmt|;
comment|/* Work area for building format strings */
name|xo_buffer_t
name|xo_attrs
decl_stmt|;
comment|/* Work area for building XML attributes */
name|xo_buffer_t
name|xo_predicate
decl_stmt|;
comment|/* Work area for building XPath predicates */
name|xo_stack_t
modifier|*
name|xo_stack
decl_stmt|;
comment|/* Stack pointer */
name|int
name|xo_depth
decl_stmt|;
comment|/* Depth of stack */
name|int
name|xo_stack_size
decl_stmt|;
comment|/* Size of the stack */
name|xo_info_t
modifier|*
name|xo_info
decl_stmt|;
comment|/* Info fields for all elements */
name|int
name|xo_info_count
decl_stmt|;
comment|/* Number of info entries */
name|va_list
name|xo_vap
decl_stmt|;
comment|/* Variable arguments (stdargs) */
name|char
modifier|*
name|xo_leading_xpath
decl_stmt|;
comment|/* A leading XPath expression */
name|mbstate_t
name|xo_mbstate
decl_stmt|;
comment|/* Multi-byte character conversion state */
name|ssize_t
name|xo_anchor_offset
decl_stmt|;
comment|/* Start of anchored text */
name|ssize_t
name|xo_anchor_columns
decl_stmt|;
comment|/* Number of columns since the start anchor */
name|ssize_t
name|xo_anchor_min_width
decl_stmt|;
comment|/* Desired width of anchored text */
name|ssize_t
name|xo_units_offset
decl_stmt|;
comment|/* Start of units insertion point */
name|ssize_t
name|xo_columns
decl_stmt|;
comment|/* Columns emitted during this xo_emit call */
name|uint8_t
name|xo_color_map_fg
index|[
name|XO_NUM_COLORS
index|]
decl_stmt|;
comment|/* Foreground color mappings */
name|uint8_t
name|xo_color_map_bg
index|[
name|XO_NUM_COLORS
index|]
decl_stmt|;
comment|/* Background color mappings */
name|xo_colors_t
name|xo_colors
decl_stmt|;
comment|/* Current color and effect values */
name|xo_buffer_t
name|xo_color_buf
decl_stmt|;
comment|/* HTML: buffer of colors and effects */
name|char
modifier|*
name|xo_version
decl_stmt|;
comment|/* Version string */
name|int
name|xo_errno
decl_stmt|;
comment|/* Saved errno for "%m" */
name|char
modifier|*
name|xo_gt_domain
decl_stmt|;
comment|/* Gettext domain, suitable for dgettext(3) */
name|xo_encoder_func_t
name|xo_encoder
decl_stmt|;
comment|/* Encoding function */
name|void
modifier|*
name|xo_private
decl_stmt|;
comment|/* Private data for external encoders */
block|}
struct|;
end_struct

begin_comment
comment|/* Flag operations */
end_comment

begin_define
define|#
directive|define
name|XOF_BIT_ISSET
parameter_list|(
name|_flag
parameter_list|,
name|_bit
parameter_list|)
value|(((_flag)& (_bit)) ? 1 : 0)
end_define

begin_define
define|#
directive|define
name|XOF_BIT_SET
parameter_list|(
name|_flag
parameter_list|,
name|_bit
parameter_list|)
value|do { (_flag) |= (_bit); } while (0)
end_define

begin_define
define|#
directive|define
name|XOF_BIT_CLEAR
parameter_list|(
name|_flag
parameter_list|,
name|_bit
parameter_list|)
value|do { (_flag)&= ~(_bit); } while (0)
end_define

begin_define
define|#
directive|define
name|XOF_ISSET
parameter_list|(
name|_xop
parameter_list|,
name|_bit
parameter_list|)
value|XOF_BIT_ISSET(_xop->xo_flags, _bit)
end_define

begin_define
define|#
directive|define
name|XOF_SET
parameter_list|(
name|_xop
parameter_list|,
name|_bit
parameter_list|)
value|XOF_BIT_SET(_xop->xo_flags, _bit)
end_define

begin_define
define|#
directive|define
name|XOF_CLEAR
parameter_list|(
name|_xop
parameter_list|,
name|_bit
parameter_list|)
value|XOF_BIT_CLEAR(_xop->xo_flags, _bit)
end_define

begin_define
define|#
directive|define
name|XOIF_ISSET
parameter_list|(
name|_xop
parameter_list|,
name|_bit
parameter_list|)
value|XOF_BIT_ISSET(_xop->xo_iflags, _bit)
end_define

begin_define
define|#
directive|define
name|XOIF_SET
parameter_list|(
name|_xop
parameter_list|,
name|_bit
parameter_list|)
value|XOF_BIT_SET(_xop->xo_iflags, _bit)
end_define

begin_define
define|#
directive|define
name|XOIF_CLEAR
parameter_list|(
name|_xop
parameter_list|,
name|_bit
parameter_list|)
value|XOF_BIT_CLEAR(_xop->xo_iflags, _bit)
end_define

begin_comment
comment|/* Internal flags */
end_comment

begin_define
define|#
directive|define
name|XOIF_REORDER
value|XOF_BIT(0)
end_define

begin_comment
comment|/* Reordering fields; record field info */
end_comment

begin_define
define|#
directive|define
name|XOIF_DIV_OPEN
value|XOF_BIT(1)
end_define

begin_comment
comment|/* A<div> is open */
end_comment

begin_define
define|#
directive|define
name|XOIF_TOP_EMITTED
value|XOF_BIT(2)
end_define

begin_comment
comment|/* The top JSON braces have been emitted */
end_comment

begin_define
define|#
directive|define
name|XOIF_ANCHOR
value|XOF_BIT(3)
end_define

begin_comment
comment|/* An anchor is in place  */
end_comment

begin_define
define|#
directive|define
name|XOIF_UNITS_PENDING
value|XOF_BIT(4)
end_define

begin_comment
comment|/* We have a units-insertion pending */
end_comment

begin_define
define|#
directive|define
name|XOIF_INIT_IN_PROGRESS
value|XOF_BIT(5)
end_define

begin_comment
comment|/* Init of handle is in progress */
end_comment

begin_comment
comment|/* Flags for formatting functions */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|xo_xff_flags_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|XFF_COLON
value|(1<<0)
end_define

begin_comment
comment|/* Append a ":" */
end_comment

begin_define
define|#
directive|define
name|XFF_COMMA
value|(1<<1)
end_define

begin_comment
comment|/* Append a "," iff there's more output */
end_comment

begin_define
define|#
directive|define
name|XFF_WS
value|(1<<2)
end_define

begin_comment
comment|/* Append a blank */
end_comment

begin_define
define|#
directive|define
name|XFF_ENCODE_ONLY
value|(1<<3)
end_define

begin_comment
comment|/* Only emit for encoding styles (XML, JSON) */
end_comment

begin_define
define|#
directive|define
name|XFF_QUOTE
value|(1<<4)
end_define

begin_comment
comment|/* Force quotes */
end_comment

begin_define
define|#
directive|define
name|XFF_NOQUOTE
value|(1<<5)
end_define

begin_comment
comment|/* Force no quotes */
end_comment

begin_define
define|#
directive|define
name|XFF_DISPLAY_ONLY
value|(1<<6)
end_define

begin_comment
comment|/* Only emit for display styles (text, html) */
end_comment

begin_define
define|#
directive|define
name|XFF_KEY
value|(1<<7)
end_define

begin_comment
comment|/* Field is a key (for XPath) */
end_comment

begin_define
define|#
directive|define
name|XFF_XML
value|(1<<8)
end_define

begin_comment
comment|/* Force XML encoding style (for XPath) */
end_comment

begin_define
define|#
directive|define
name|XFF_ATTR
value|(1<<9)
end_define

begin_comment
comment|/* Escape value using attribute rules (XML) */
end_comment

begin_define
define|#
directive|define
name|XFF_BLANK_LINE
value|(1<<10)
end_define

begin_comment
comment|/* Emit a blank line */
end_comment

begin_define
define|#
directive|define
name|XFF_NO_OUTPUT
value|(1<<11)
end_define

begin_comment
comment|/* Do not make any output */
end_comment

begin_define
define|#
directive|define
name|XFF_TRIM_WS
value|(1<<12)
end_define

begin_comment
comment|/* Trim whitespace off encoded values */
end_comment

begin_define
define|#
directive|define
name|XFF_LEAF_LIST
value|(1<<13)
end_define

begin_comment
comment|/* A leaf-list (list of values) */
end_comment

begin_define
define|#
directive|define
name|XFF_UNESCAPE
value|(1<<14)
end_define

begin_comment
comment|/* Need to printf-style unescape the value */
end_comment

begin_define
define|#
directive|define
name|XFF_HUMANIZE
value|(1<<15)
end_define

begin_comment
comment|/* Humanize the value (for display styles) */
end_comment

begin_define
define|#
directive|define
name|XFF_HN_SPACE
value|(1<<16)
end_define

begin_comment
comment|/* Humanize: put space before suffix */
end_comment

begin_define
define|#
directive|define
name|XFF_HN_DECIMAL
value|(1<<17)
end_define

begin_comment
comment|/* Humanize: add one decimal place if<10 */
end_comment

begin_define
define|#
directive|define
name|XFF_HN_1000
value|(1<<18)
end_define

begin_comment
comment|/* Humanize: use 1000, not 1024 */
end_comment

begin_define
define|#
directive|define
name|XFF_GT_FIELD
value|(1<<19)
end_define

begin_comment
comment|/* Call gettext() on a field */
end_comment

begin_define
define|#
directive|define
name|XFF_GT_PLURAL
value|(1<<20)
end_define

begin_comment
comment|/* Call dngettext to find plural form */
end_comment

begin_define
define|#
directive|define
name|XFF_ARGUMENT
value|(1<<21)
end_define

begin_comment
comment|/* Content provided via argument */
end_comment

begin_comment
comment|/* Flags to turn off when we don't want i18n processing */
end_comment

begin_define
define|#
directive|define
name|XFF_GT_FLAGS
value|(XFF_GT_FIELD | XFF_GT_PLURAL)
end_define

begin_comment
comment|/*  * Normal printf has width and precision, which for strings operate as  * min and max number of columns.  But this depends on the idea that  * one byte means one column, which UTF-8 and multi-byte characters  * pitches on its ear.  It may take 40 bytes of data to populate 14  * columns, but we can't go off looking at 40 bytes of data without the  * caller's permission for fear/knowledge that we'll generate core files.  *   * So we make three values, distinguishing between "max column" and  * "number of bytes that we will inspect inspect safely" We call the  * later "size", and make the format "%[[<min>].[[<size>].<max>]]s".  *  * Under the "first do no harm" theory, we default "max" to "size".  * This is a reasonable assumption for folks that don't grok the  * MBS/WCS/UTF-8 world, and while it will be annoying, it will never  * be evil.  *  * For example, xo_emit("{:tag/%-14.14s}", buf) will make 14  * columns of output, but will never look at more than 14 bytes of the  * input buffer.  This is mostly compatible with printf and caller's  * expectations.  *  * In contrast xo_emit("{:tag/%-14..14s}", buf) will look at however  * many bytes (or until a NUL is seen) are needed to fill 14 columns  * of output.  xo_emit("{:tag/%-14.*.14s}", xx, buf) will look at up  * to xx bytes (or until a NUL is seen) in order to fill 14 columns  * of output.  *  * It's fairly amazing how a good idea (handle all languages of the  * world) blows such a big hole in the bottom of the fairly weak boat  * that is C string handling.  The simplicity and completenesss are  * sunk in ways we haven't even begun to understand.  */
end_comment

begin_define
define|#
directive|define
name|XF_WIDTH_MIN
value|0
end_define

begin_comment
comment|/* Minimal width */
end_comment

begin_define
define|#
directive|define
name|XF_WIDTH_SIZE
value|1
end_define

begin_comment
comment|/* Maximum number of bytes to examine */
end_comment

begin_define
define|#
directive|define
name|XF_WIDTH_MAX
value|2
end_define

begin_comment
comment|/* Maximum width */
end_comment

begin_define
define|#
directive|define
name|XF_WIDTH_NUM
value|3
end_define

begin_comment
comment|/* Numeric fields in printf (min.size.max) */
end_comment

begin_comment
comment|/* Input and output string encodings */
end_comment

begin_define
define|#
directive|define
name|XF_ENC_WIDE
value|1
end_define

begin_comment
comment|/* Wide characters (wchar_t) */
end_comment

begin_define
define|#
directive|define
name|XF_ENC_UTF8
value|2
end_define

begin_comment
comment|/* UTF-8 */
end_comment

begin_define
define|#
directive|define
name|XF_ENC_LOCALE
value|3
end_define

begin_comment
comment|/* Current locale */
end_comment

begin_comment
comment|/*  * A place to parse printf-style format flags for each field  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_format_s
block|{
name|unsigned
name|char
name|xf_fc
decl_stmt|;
comment|/* Format character */
name|unsigned
name|char
name|xf_enc
decl_stmt|;
comment|/* Encoding of the string (XF_ENC_*) */
name|unsigned
name|char
name|xf_skip
decl_stmt|;
comment|/* Skip this field */
name|unsigned
name|char
name|xf_lflag
decl_stmt|;
comment|/* 'l' (long) */
name|unsigned
name|char
name|xf_hflag
decl_stmt|;
empty_stmt|;
comment|/* 'h' (half) */
name|unsigned
name|char
name|xf_jflag
decl_stmt|;
comment|/* 'j' (intmax_t) */
name|unsigned
name|char
name|xf_tflag
decl_stmt|;
comment|/* 't' (ptrdiff_t) */
name|unsigned
name|char
name|xf_zflag
decl_stmt|;
comment|/* 'z' (size_t) */
name|unsigned
name|char
name|xf_qflag
decl_stmt|;
comment|/* 'q' (quad_t) */
name|unsigned
name|char
name|xf_seen_minus
decl_stmt|;
comment|/* Seen a minus */
name|int
name|xf_leading_zero
decl_stmt|;
comment|/* Seen a leading zero (zero fill)  */
name|unsigned
name|xf_dots
decl_stmt|;
comment|/* Seen one or more '.'s */
name|int
name|xf_width
index|[
name|XF_WIDTH_NUM
index|]
decl_stmt|;
comment|/* Width/precision/size numeric fields */
name|unsigned
name|xf_stars
decl_stmt|;
comment|/* Seen one or more '*'s */
name|unsigned
name|char
name|xf_star
index|[
name|XF_WIDTH_NUM
index|]
decl_stmt|;
comment|/* Seen one or more '*'s */
block|}
name|xo_format_t
typedef|;
end_typedef

begin_comment
comment|/*  * This structure represents the parsed field information, suitable for  * processing by xo_do_emit and anything else that needs to parse fields.  * Note that all pointers point to the main format string.  *  * XXX This is a first step toward compilable or cachable format  * strings.  We can also cache the results of dgettext when no format  * is used, assuming the 'p' modifier has _not_ been set.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_field_info_s
block|{
name|xo_xff_flags_t
name|xfi_flags
decl_stmt|;
comment|/* Flags for this field */
name|unsigned
name|xfi_ftype
decl_stmt|;
comment|/* Field type, as character (e.g. 'V') */
specifier|const
name|char
modifier|*
name|xfi_start
decl_stmt|;
comment|/* Start of field in the format string */
specifier|const
name|char
modifier|*
name|xfi_content
decl_stmt|;
comment|/* Field's content */
specifier|const
name|char
modifier|*
name|xfi_format
decl_stmt|;
comment|/* Field's Format */
specifier|const
name|char
modifier|*
name|xfi_encoding
decl_stmt|;
comment|/* Field's encoding format */
specifier|const
name|char
modifier|*
name|xfi_next
decl_stmt|;
comment|/* Next character in format string */
name|ssize_t
name|xfi_len
decl_stmt|;
comment|/* Length of field */
name|ssize_t
name|xfi_clen
decl_stmt|;
comment|/* Content length */
name|ssize_t
name|xfi_flen
decl_stmt|;
comment|/* Format length */
name|ssize_t
name|xfi_elen
decl_stmt|;
comment|/* Encoding length */
name|unsigned
name|xfi_fnum
decl_stmt|;
comment|/* Field number (if used; 0 otherwise) */
name|unsigned
name|xfi_renum
decl_stmt|;
comment|/* Reordered number (0 == no renumbering) */
block|}
name|xo_field_info_t
typedef|;
end_typedef

begin_comment
comment|/*  * We keep a 'default' handle to allow callers to avoid having to  * allocate one.  Passing NULL to any of our functions will use  * this default handle.  Most functions have a variant that doesn't  * require a handle at all, since most output is to stdout, which  * the default handle handles handily.  */
end_comment

begin_expr_stmt
specifier|static
name|THREAD_LOCAL
argument_list|(
argument|xo_handle_t
argument_list|)
name|xo_default_handle
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|THREAD_LOCAL
argument_list|(
argument|int
argument_list|)
name|xo_default_inited
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|xo_locale_inited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|xo_program
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To allow libxo to be used in diverse environment, we allow the  * caller to give callbacks for memory allocation.  */
end_comment

begin_decl_stmt
name|xo_realloc_func_t
name|xo_realloc
init|=
name|realloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xo_free_func_t
name|xo_free
init|=
name|free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|xo_failure
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|xo_transition
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|xo_state_t
name|new_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xo_buf_append_div
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|class
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ssize_t
name|nlen
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|ssize_t
name|vlen
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|ssize_t
name|elen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xo_anchor_clear
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * xo_style is used to retrieve the current style.  When we're built  * for "text only" mode, we use this function to drive the removal  * of most of the code in libxo.  We return a constant and the compiler  * happily removes the non-text code that is not longer executed.  This  * trims our code nicely without needing to trampel perfectly readable  * code with ifdefs.  */
end_comment

begin_function
specifier|static
specifier|inline
name|xo_style_t
name|xo_style
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|LIBXO_TEXT_ONLY
return|return
name|XO_STYLE_TEXT
return|;
else|#
directive|else
comment|/* LIBXO_TEXT_ONLY */
return|return
name|xop
operator|->
name|xo_style
return|;
endif|#
directive|endif
comment|/* LIBXO_TEXT_ONLY */
block|}
end_function

begin_comment
comment|/*  * Callback to write data to a FILE pointer  */
end_comment

begin_function
specifier|static
name|xo_ssize_t
name|xo_write_to_file
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|opaque
decl_stmt|;
return|return
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback to close a file  */
end_comment

begin_function
specifier|static
name|void
name|xo_close_file
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|opaque
decl_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback to flush a FILE pointer  */
end_comment

begin_function
specifier|static
name|int
name|xo_flush_file
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|opaque
decl_stmt|;
return|return
name|fflush
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use a rotating stock of buffers to make a printable string  */
end_comment

begin_define
define|#
directive|define
name|XO_NUMBUFS
value|8
end_define

begin_define
define|#
directive|define
name|XO_SMBUFSZ
value|128
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xo_printable
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
name|THREAD_LOCAL
argument_list|(
argument|char
argument_list|)
name|bufset
index|[
name|XO_NUMBUFS
index|]
index|[
name|XO_SMBUFSZ
index|]
expr_stmt|;
specifier|static
name|THREAD_LOCAL
argument_list|(
argument|int
argument_list|)
name|bufnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
literal|""
return|;
if|if
condition|(
operator|++
name|bufnum
operator|==
name|XO_NUMBUFS
condition|)
name|bufnum
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
name|res
init|=
name|bufset
index|[
name|bufnum
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|res
operator|,
name|ep
operator|=
name|res
operator|+
name|XO_SMBUFSZ
operator|-
literal|1
init|;
operator|*
name|str
operator|&&
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
operator|,
name|str
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'\"'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'"'
expr_stmt|;
block|}
else|else
operator|*
name|cp
operator|=
operator|*
name|str
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_depth_check
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|xo_stack_t
modifier|*
name|xsp
decl_stmt|;
if|if
condition|(
name|depth
operator|>=
name|xop
operator|->
name|xo_stack_size
condition|)
block|{
name|depth
operator|+=
name|XO_DEPTH
expr_stmt|;
comment|/* Extra room */
name|xsp
operator|=
name|xo_realloc
argument_list|(
name|xop
operator|->
name|xo_stack
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_stack
index|[
literal|0
index|]
argument_list|)
operator|*
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsp
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"xo_depth_check: out of memory (%d)"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|int
name|count
init|=
name|depth
operator|-
name|xop
operator|->
name|xo_stack_size
decl_stmt|;
name|bzero
argument_list|(
name|xsp
operator|+
name|xop
operator|->
name|xo_stack_size
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|xsp
argument_list|)
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack_size
operator|=
name|depth
expr_stmt|;
name|xop
operator|->
name|xo_stack
operator|=
name|xsp
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|xo_no_setlocale
parameter_list|(
name|void
parameter_list|)
block|{
name|xo_locale_inited
operator|=
literal|1
expr_stmt|;
comment|/* Skip initialization */
block|}
end_function

begin_comment
comment|/*  * We need to decide if stdout is line buffered (_IOLBF).  Lacking a  * standard way to decide this (e.g. getlinebuf()), we have configure  * look to find __flbf, which glibc supported.  If not, we'll rely on  * isatty, with the assumption that terminals are the only thing  * that's line buffered.  We _could_ test for "steam._flags& _IOLBF",  * which is all __flbf does, but that's even tackier.  Like a  * bedazzled Elvis outfit on an ugly lap dog sort of tacky.  Not  * something we're willing to do.  */
end_comment

begin_function
specifier|static
name|int
name|xo_is_line_buffered
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
if|#
directive|if
name|HAVE___FLBF
if|if
condition|(
name|__flbf
argument_list|(
name|stream
argument_list|)
condition|)
return|return
literal|1
return|;
else|#
directive|else
comment|/* HAVE___FLBF */
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* HAVE___FLBF */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize an xo_handle_t, using both static defaults and  * the global settings from the LIBXO_OPTIONS environment  * variable.  */
end_comment

begin_function
specifier|static
name|void
name|xo_init_handle
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|->
name|xo_opaque
operator|=
name|stdout
expr_stmt|;
name|xop
operator|->
name|xo_write
operator|=
name|xo_write_to_file
expr_stmt|;
name|xop
operator|->
name|xo_flush
operator|=
name|xo_flush_file
expr_stmt|;
if|if
condition|(
name|xo_is_line_buffered
argument_list|(
name|stdout
argument_list|)
condition|)
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_FLUSH_LINE
argument_list|)
expr_stmt|;
comment|/*      * We only want to do color output on terminals, but we only want      * to do this if the user has asked for color.      */
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLOR_ALLOWED
argument_list|)
operator|&&
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_COLOR
argument_list|)
expr_stmt|;
comment|/*      * We need to initialize the locale, which isn't really pretty.      * Libraries should depend on their caller to set up the      * environment.  But we really can't count on the caller to do      * this, because well, they won't.  Trust me.      */
if|if
condition|(
operator|!
name|xo_locale_inited
condition|)
block|{
name|xo_locale_inited
operator|=
literal|1
expr_stmt|;
comment|/* Only do this once */
specifier|const
name|char
modifier|*
name|cp
init|=
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
literal|"C"
expr_stmt|;
comment|/* Default for C programs */
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/*      * Initialize only the xo_buffers we know we'll need; the others      * can be allocated as needed.      */
name|xo_buf_init
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
expr_stmt|;
name|xo_buf_init
argument_list|(
operator|&
name|xop
operator|->
name|xo_fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_INIT_IN_PROGRESS
argument_list|)
condition|)
return|return;
name|XOIF_SET
argument_list|(
name|xop
argument_list|,
name|XOIF_INIT_IN_PROGRESS
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_indent_by
operator|=
name|XO_INDENT_BY
expr_stmt|;
name|xo_depth_check
argument_list|(
name|xop
argument_list|,
name|XO_DEPTH
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_LIBXO_OPTIONS
argument_list|)
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_ENV
argument_list|)
condition|)
block|{
name|char
modifier|*
name|env
init|=
name|getenv
argument_list|(
literal|"LIBXO_OPTIONS"
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
condition|)
name|xo_set_options
argument_list|(
name|xop
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NO_GETENV */
name|XOIF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOIF_INIT_IN_PROGRESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the default handle.  */
end_comment

begin_function
specifier|static
name|void
name|xo_default_init
parameter_list|(
name|void
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
operator|&
name|xo_default_handle
decl_stmt|;
name|xo_init_handle
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xo_default_inited
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cheap convenience function to return either the argument, or  * the internal handle, after it has been initialized.  The usage  * is:  *    xop = xo_default(xop);  */
end_comment

begin_function
specifier|static
name|xo_handle_t
modifier|*
name|xo_default
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
if|if
condition|(
name|xop
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|xo_default_inited
operator|==
literal|0
condition|)
name|xo_default_init
argument_list|()
expr_stmt|;
name|xop
operator|=
operator|&
name|xo_default_handle
expr_stmt|;
block|}
return|return
name|xop
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of spaces we should be indenting.  If  * we are pretty-printing, this is indent * indent_by.  */
end_comment

begin_function
specifier|static
name|int
name|xo_indent
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
block|{
name|rc
operator|=
name|xop
operator|->
name|xo_indent
operator|*
name|xop
operator|->
name|xo_indent_by
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_TOP_EMITTED
argument_list|)
condition|)
name|rc
operator|+=
name|xop
operator|->
name|xo_indent_by
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|>
literal|0
operator|)
condition|?
name|rc
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_buf_indent
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
if|if
condition|(
name|indent
operator|<=
literal|0
condition|)
name|indent
operator|=
name|xo_indent
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|indent
argument_list|)
condition|)
return|return;
name|memset
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
literal|' '
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|indent
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|xo_xml_amp
index|[]
init|=
literal|"&amp;"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|xo_xml_lt
index|[]
init|=
literal|"&lt;"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|xo_xml_gt
index|[]
init|=
literal|"&gt;"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|xo_xml_quot
index|[]
init|=
literal|"&quot;"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|ssize_t
name|xo_escape_xml
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
name|ssize_t
name|slen
decl_stmt|;
name|ssize_t
name|delta
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|attr
init|=
name|XOF_BIT_ISSET
argument_list|(
name|flags
argument_list|,
name|XFF_ATTR
argument_list|)
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
comment|/* We're subtracting 2: 1 for the NUL, 1 for the char we replace */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'<'
condition|)
name|delta
operator|+=
sizeof|sizeof
argument_list|(
name|xo_xml_lt
argument_list|)
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'>'
condition|)
name|delta
operator|+=
sizeof|sizeof
argument_list|(
name|xo_xml_gt
argument_list|)
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'&'
condition|)
name|delta
operator|+=
sizeof|sizeof
argument_list|(
name|xo_xml_amp
argument_list|)
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&&
operator|*
name|cp
operator|==
literal|'"'
condition|)
name|delta
operator|+=
sizeof|sizeof
argument_list|(
name|xo_xml_quot
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
comment|/* Nothing to escape; bail */
return|return
name|len
return|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|delta
argument_list|)
condition|)
comment|/* No room; bail, but don't append */
return|return
literal|0
return|;
name|ep
operator|=
name|xbp
operator|->
name|xb_curp
expr_stmt|;
name|cp
operator|=
name|ep
operator|+
name|len
expr_stmt|;
name|ip
operator|=
name|cp
operator|+
name|delta
expr_stmt|;
do|do
block|{
name|cp
operator|-=
literal|1
expr_stmt|;
name|ip
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'<'
condition|)
name|sp
operator|=
name|xo_xml_lt
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'>'
condition|)
name|sp
operator|=
name|xo_xml_gt
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'&'
condition|)
name|sp
operator|=
name|xo_xml_amp
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&&
operator|*
name|cp
operator|==
literal|'"'
condition|)
name|sp
operator|=
name|xo_xml_quot
expr_stmt|;
else|else
block|{
operator|*
name|ip
operator|=
operator|*
name|cp
expr_stmt|;
continue|continue;
block|}
name|slen
operator|=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ip
operator|-=
name|slen
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|ip
argument_list|,
name|sp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cp
operator|>
name|ep
operator|&&
name|cp
operator|!=
name|ip
condition|)
do|;
return|return
name|len
operator|+
name|delta
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_escape_json
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|xo_xff_flags_t
name|flags
name|UNUSED
parameter_list|)
block|{
name|ssize_t
name|delta
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|||
operator|*
name|cp
operator|==
literal|'"'
condition|)
name|delta
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|'\r'
condition|)
name|delta
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
comment|/* Nothing to escape; bail */
return|return
name|len
return|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|delta
argument_list|)
condition|)
comment|/* No room; bail, but don't append */
return|return
literal|0
return|;
name|ep
operator|=
name|xbp
operator|->
name|xb_curp
expr_stmt|;
name|cp
operator|=
name|ep
operator|+
name|len
expr_stmt|;
name|ip
operator|=
name|cp
operator|+
name|delta
expr_stmt|;
do|do
block|{
name|cp
operator|-=
literal|1
expr_stmt|;
name|ip
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|||
operator|*
name|cp
operator|==
literal|'"'
condition|)
block|{
operator|*
name|ip
operator|--
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|ip
operator|=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|ip
operator|--
operator|=
literal|'n'
expr_stmt|;
operator|*
name|ip
operator|=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|ip
operator|--
operator|=
literal|'r'
expr_stmt|;
operator|*
name|ip
operator|=
literal|'\\'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ip
operator|=
operator|*
name|cp
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cp
operator|>
name|ep
operator|&&
name|cp
operator|!=
name|ip
condition|)
do|;
return|return
name|len
operator|+
name|delta
return|;
block|}
end_function

begin_comment
comment|/*  * PARAM-VALUE     = UTF-8-STRING ; characters '"', '\' and  *                                ; ']' MUST be escaped.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_escape_sdparams
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|xo_xff_flags_t
name|flags
name|UNUSED
parameter_list|)
block|{
name|ssize_t
name|delta
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|||
operator|*
name|cp
operator|==
literal|'"'
operator|||
operator|*
name|cp
operator|==
literal|']'
condition|)
name|delta
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
comment|/* Nothing to escape; bail */
return|return
name|len
return|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|delta
argument_list|)
condition|)
comment|/* No room; bail, but don't append */
return|return
literal|0
return|;
name|ep
operator|=
name|xbp
operator|->
name|xb_curp
expr_stmt|;
name|cp
operator|=
name|ep
operator|+
name|len
expr_stmt|;
name|ip
operator|=
name|cp
operator|+
name|delta
expr_stmt|;
do|do
block|{
name|cp
operator|-=
literal|1
expr_stmt|;
name|ip
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|||
operator|*
name|cp
operator|==
literal|'"'
operator|||
operator|*
name|cp
operator|==
literal|']'
condition|)
block|{
operator|*
name|ip
operator|--
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|ip
operator|=
literal|'\\'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ip
operator|=
operator|*
name|cp
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cp
operator|>
name|ep
operator|&&
name|cp
operator|!=
name|ip
condition|)
do|;
return|return
name|len
operator|+
name|delta
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_buf_escape
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|)
condition|)
return|return;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
case|case
name|XO_STYLE_HTML
case|:
name|len
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|len
operator|=
name|xo_escape_json
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_SDPARAMS
case|:
name|len
operator|=
name|xo_escape_sdparams
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|xbp
operator|->
name|xb_curp
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the current contents of the data buffer using the handle's  * xo_write function.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_write
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
if|if
condition|(
name|xbp
operator|->
name|xb_curp
operator|!=
name|xbp
operator|->
name|xb_bufp
condition|)
block|{
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Append ending NUL */
name|xo_anchor_clear
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_write
condition|)
name|rc
operator|=
name|xop
operator|->
name|xo_write
argument_list|(
name|xop
operator|->
name|xo_opaque
argument_list|,
name|xbp
operator|->
name|xb_bufp
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
block|}
comment|/* Turn off the flags that don't survive across writes */
name|XOIF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOIF_UNITS_PENDING
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * Format arguments into our buffer.  If a custom formatter has been set,  * we use that to do the work; otherwise we vsnprintf().  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_vsnprintf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|va_list
name|va_local
decl_stmt|;
name|ssize_t
name|rc
decl_stmt|;
name|ssize_t
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_formatter
condition|)
name|rc
operator|=
name|xop
operator|->
name|xo_formatter
argument_list|(
name|xop
argument_list|,
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
name|left
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
block|{
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * After we call vsnprintf(), the stage of vap is not defined. 	 * We need to copy it before we pass.  Then we have to do our 	 * own logic below to move it along.  This is because the 	 * implementation can have va_list be a pointer (bsd) or a 	 * structure (macosx) or anything in between. 	 */
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
comment|/* Reset vap to the start */
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_formatter
condition|)
name|rc
operator|=
name|xop
operator|->
name|xo_formatter
argument_list|(
name|xop
argument_list|,
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * Print some data through the handle.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_printf_v
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|ssize_t
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
decl_stmt|;
name|ssize_t
name|rc
decl_stmt|;
name|va_list
name|va_local
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
name|left
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
block|{
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
comment|/* Reset vap to the start */
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_printf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf_v
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * These next few function are make The Essential UTF-8 Ginsu Knife.  * Identify an input and output character, and convert it.  */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|xo_utf8_bits
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0x7f
block|,
literal|0x1f
block|,
literal|0x0f
block|,
literal|0x07
block|,
literal|0x03
block|,
literal|0x01
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|xo_is_utf8
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|&
literal|0x80
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ssize_t
name|xo_utf8_to_wc_len
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|b
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|buf
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0x0
condition|)
name|len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
name|len
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
name|len
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xfc
operator|)
operator|==
literal|0xf8
condition|)
name|len
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xfe
operator|)
operator|==
literal|0xfc
condition|)
name|len
operator|=
literal|6
expr_stmt|;
else|else
name|len
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_buf_utf8_len
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|ssize_t
name|bufsiz
parameter_list|)
block|{
name|unsigned
name|b
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|buf
decl_stmt|;
name|ssize_t
name|len
decl_stmt|,
name|i
decl_stmt|;
name|len
operator|=
name|xo_utf8_to_wc_len
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 data: %02hhx"
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|len
operator|>
name|bufsiz
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 data (short): %02hhx (%d/%d)"
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 data (byte %d): %x"
argument_list|,
name|i
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Build a wide character from the input buffer; the number of  * bits we pull off the first character is dependent on the length,  * but we put 6 bits off all other bytes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|wchar_t
name|xo_utf8_char
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
comment|/* Most common case: singleton byte */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|0
index|]
return|;
name|ssize_t
name|i
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cp
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buf
decl_stmt|;
name|wc
operator|=
operator|*
name|cp
operator|&
name|xo_utf8_bits
index|[
name|len
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|wc
operator|<<=
literal|6
expr_stmt|;
name|wc
operator||=
name|cp
index|[
name|i
index|]
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
operator|(
name|cp
index|[
name|i
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
name|wchar_t
operator|)
operator|-
literal|1
return|;
block|}
return|return
name|wc
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the number of bytes needed to encode a wide character.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_utf8_emit_len
parameter_list|(
name|wchar_t
name|wc
parameter_list|)
block|{
name|ssize_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
comment|/* Simple case */
name|len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
name|len
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|21
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
name|len
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
name|len
operator|=
literal|5
expr_stmt|;
else|else
name|len
operator|=
literal|6
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_utf8_emit_char
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|wchar_t
name|wc
parameter_list|)
block|{
name|ssize_t
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
comment|/* Simple case */
name|buf
index|[
literal|0
index|]
operator|=
name|wc
operator|&
literal|0x7f
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|wc
operator|>>=
literal|6
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|&=
name|xo_utf8_bits
index|[
name|len
index|]
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|~
name|xo_utf8_bits
index|[
name|len
index|]
operator|<<
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_buf_append_locale_from_utf8
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|ibuf
parameter_list|,
name|ssize_t
name|ilen
parameter_list|)
block|{
name|wchar_t
name|wc
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
comment|/*      * Build our wide character from the input buffer; the number of      * bits we pull off the first character is dependent on the length,      * but we put 6 bits off all other bytes.      */
name|wc
operator|=
name|xo_utf8_char
argument_list|(
name|ibuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
operator|(
name|wchar_t
operator|)
operator|-
literal|1
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid utf-8 byte sequence"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_LOCALE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|ilen
argument_list|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|ibuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|ilen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|MB_LEN_MAX
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_mbstate
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_mbstate
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|wcrtomb
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|wc
argument_list|,
operator|&
name|xop
operator|->
name|xo_mbstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"could not convert wide char: %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|xbp
operator|->
name|xb_curp
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|xo_wcwidth
argument_list|(
name|wc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_buf_append_locale
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sp
init|=
name|cp
decl_stmt|,
modifier|*
name|ep
init|=
name|cp
operator|+
name|len
decl_stmt|;
name|ssize_t
name|save_off
init|=
name|xbp
operator|->
name|xb_bufp
operator|-
name|xbp
operator|->
name|xb_curp
decl_stmt|;
name|ssize_t
name|slen
decl_stmt|;
name|int
name|cols
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|xo_is_utf8
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cols
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * We're looking at a non-ascii UTF-8 character. 	 * First we copy the previous data. 	 * Then we need find the length and validate it. 	 * Then we turn it into a wide string. 	 * Then we turn it into a localized string. 	 * Then we repeat.  Isn't i18n fun? 	 */
if|if
condition|(
name|sp
operator|!=
name|cp
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|sp
argument_list|,
name|cp
operator|-
name|sp
argument_list|)
expr_stmt|;
comment|/* Append previous data */
name|slen
operator|=
name|xo_buf_utf8_len
argument_list|(
name|xop
argument_list|,
name|cp
argument_list|,
name|ep
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|<=
literal|0
condition|)
block|{
comment|/* Bad data; back it all out */
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|save_off
expr_stmt|;
return|return;
block|}
name|cols
operator|+=
name|xo_buf_append_locale_from_utf8
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|cp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
comment|/* Next time through, we'll start at the next character */
name|cp
operator|+=
name|slen
operator|-
literal|1
expr_stmt|;
name|sp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Update column values */
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
comment|/* Before we fall into the basic logic below, we need reset len */
name|len
operator|=
name|ep
operator|-
name|sp
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
comment|/* Append trailing data */
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append the given string to the given buffer, without escaping or  * character set conversion.  This is the straight copy to the data  * buffer with no fanciness.  */
end_comment

begin_function
specifier|static
name|void
name|xo_data_append
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
name|xo_buf_append
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append the given string to the given buffer  */
end_comment

begin_function
specifier|static
name|void
name|xo_data_escape
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
name|xo_buf_escape
argument_list|(
name|xop
argument_list|,
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LIBXO_NO_RETAIN
end_ifdef

begin_comment
comment|/*  * Empty implementations of the retain logic  */
end_comment

begin_function
name|void
name|xo_retain_clear_all
parameter_list|(
name|void
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|void
name|xo_retain_clear
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
name|UNUSED
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_retain_add
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
name|UNUSED
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
name|UNUSED
parameter_list|,
name|unsigned
name|num_fields
name|UNUSED
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_retain_find
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
name|UNUSED
parameter_list|,
name|xo_field_info_t
modifier|*
modifier|*
name|valp
name|UNUSED
parameter_list|,
name|unsigned
modifier|*
name|nump
name|UNUSED
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !LIBXO_NO_RETAIN */
end_comment

begin_comment
comment|/*  * Retain: We retain parsed field definitions to enhance performance,  * especially inside loops.  We depend on the caller treating the format  * strings as immutable, so that we can retain pointers into them.  We  * hold the pointers in a hash table, so allow quick access.  Retained  * information is retained until xo_retain_clear is called.  */
end_comment

begin_comment
comment|/*  * xo_retain_entry_t holds information about one retained set of  * parsed fields.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_retain_entry_s
block|{
name|struct
name|xo_retain_entry_s
modifier|*
name|xre_next
decl_stmt|;
comment|/* Pointer to next (older) entry */
name|unsigned
name|long
name|xre_hits
decl_stmt|;
comment|/* Number of times we've hit */
specifier|const
name|char
modifier|*
name|xre_format
decl_stmt|;
comment|/* Pointer to format string */
name|unsigned
name|xre_num_fields
decl_stmt|;
comment|/* Number of fields saved */
name|xo_field_info_t
modifier|*
name|xre_fields
decl_stmt|;
comment|/* Pointer to fields */
block|}
name|xo_retain_entry_t
typedef|;
end_typedef

begin_comment
comment|/*  * xo_retain_t holds a complete set of parsed fields as a hash table.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XO_RETAIN_SIZE
end_ifndef

begin_define
define|#
directive|define
name|XO_RETAIN_SIZE
value|6
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XO_RETAIN_SIZE */
end_comment

begin_define
define|#
directive|define
name|RETAIN_HASH_SIZE
value|(1<<XO_RETAIN_SIZE)
end_define

begin_typedef
typedef|typedef
struct|struct
name|xo_retain_s
block|{
name|xo_retain_entry_t
modifier|*
name|xr_bucket
index|[
name|RETAIN_HASH_SIZE
index|]
decl_stmt|;
block|}
name|xo_retain_t
typedef|;
end_typedef

begin_expr_stmt
specifier|static
name|THREAD_LOCAL
argument_list|(
argument|xo_retain_t
argument_list|)
name|xo_retain
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|THREAD_LOCAL
argument_list|(
argument|unsigned
argument_list|)
name|xo_retain_count
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Simple hash function based on Thomas Wang's paper.  The original is  * gone, but an archive is available on the Way Back Machine:  *  * http://web.archive.org/web/20071223173210/\  *     http://www.concentric.net/~Ttwang/tech/inthash.htm  *  * For our purposes, we can assume the low four bits are uninteresting  * since any string less that 16 bytes wouldn't be worthy of  * retaining.  We toss the high bits also, since these bits are likely  * to be common among constant format strings.  We then run Wang's  * algorithm, and cap the result at RETAIN_HASH_SIZE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|xo_retain_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
specifier|volatile
name|uintptr_t
name|iptr
init|=
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|fmt
decl_stmt|;
comment|/* Discard low four bits and high bits; they aren't interesting */
name|uint32_t
name|val
init|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|iptr
operator|>>
literal|4
operator|)
operator|&
operator|(
operator|(
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|)
decl_stmt|;
name|val
operator|=
operator|(
name|val
operator|^
literal|61
operator|)
operator|^
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|val
operator|=
name|val
operator|+
operator|(
name|val
operator|<<
literal|3
operator|)
expr_stmt|;
name|val
operator|=
name|val
operator|^
operator|(
name|val
operator|>>
literal|4
operator|)
expr_stmt|;
name|val
operator|=
name|val
operator|*
literal|0x3a8f05c5
expr_stmt|;
comment|/* My large prime number */
name|val
operator|=
name|val
operator|^
operator|(
name|val
operator|>>
literal|15
operator|)
expr_stmt|;
name|val
operator|&=
name|RETAIN_HASH_SIZE
operator|-
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * Walk all buckets, clearing all retained entries  */
end_comment

begin_function
name|void
name|xo_retain_clear_all
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xo_retain_entry_t
modifier|*
name|xrep
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RETAIN_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|xrep
operator|=
name|xo_retain
operator|.
name|xr_bucket
index|[
name|i
index|]
init|;
name|xrep
condition|;
name|xrep
operator|=
name|next
control|)
block|{
name|next
operator|=
name|xrep
operator|->
name|xre_next
expr_stmt|;
name|xo_free
argument_list|(
name|xrep
argument_list|)
expr_stmt|;
block|}
name|xo_retain
operator|.
name|xr_bucket
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|xo_retain_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk all buckets, clearing all retained entries  */
end_comment

begin_function
name|void
name|xo_retain_clear
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
name|xo_retain_entry_t
modifier|*
modifier|*
name|xrepp
decl_stmt|;
name|unsigned
name|hash
init|=
name|xo_retain_hash
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
for|for
control|(
name|xrepp
operator|=
operator|&
name|xo_retain
operator|.
name|xr_bucket
index|[
name|hash
index|]
init|;
operator|*
name|xrepp
condition|;
name|xrepp
operator|=
operator|&
operator|(
operator|*
name|xrepp
operator|)
operator|->
name|xre_next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|xrepp
operator|)
operator|->
name|xre_format
operator|==
name|fmt
condition|)
block|{
operator|*
name|xrepp
operator|=
operator|(
operator|*
name|xrepp
operator|)
operator|->
name|xre_next
expr_stmt|;
name|xo_retain_count
operator|-=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Search the hash for an entry matching 'fmt'; return it's fields.  */
end_comment

begin_function
specifier|static
name|int
name|xo_retain_find
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|xo_field_info_t
modifier|*
modifier|*
name|valp
parameter_list|,
name|unsigned
modifier|*
name|nump
parameter_list|)
block|{
if|if
condition|(
name|xo_retain_count
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|unsigned
name|hash
init|=
name|xo_retain_hash
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
name|xo_retain_entry_t
modifier|*
name|xrep
decl_stmt|;
for|for
control|(
name|xrep
operator|=
name|xo_retain
operator|.
name|xr_bucket
index|[
name|hash
index|]
init|;
name|xrep
operator|!=
name|NULL
condition|;
name|xrep
operator|=
name|xrep
operator|->
name|xre_next
control|)
block|{
if|if
condition|(
name|xrep
operator|->
name|xre_format
operator|==
name|fmt
condition|)
block|{
operator|*
name|valp
operator|=
name|xrep
operator|->
name|xre_fields
expr_stmt|;
operator|*
name|nump
operator|=
name|xrep
operator|->
name|xre_num_fields
expr_stmt|;
name|xrep
operator|->
name|xre_hits
operator|+=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_retain_add
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
parameter_list|,
name|unsigned
name|num_fields
parameter_list|)
block|{
name|unsigned
name|hash
init|=
name|xo_retain_hash
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
name|xo_retain_entry_t
modifier|*
name|xrep
decl_stmt|;
name|ssize_t
name|sz
init|=
sizeof|sizeof
argument_list|(
operator|*
name|xrep
argument_list|)
operator|+
operator|(
name|num_fields
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fields
argument_list|)
decl_stmt|;
name|xo_field_info_t
modifier|*
name|xfip
decl_stmt|;
name|xrep
operator|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|xrep
operator|==
name|NULL
condition|)
return|return;
name|xfip
operator|=
operator|(
name|xo_field_info_t
operator|*
operator|)
operator|&
name|xrep
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|xfip
argument_list|,
name|fields
argument_list|,
name|num_fields
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fields
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|xrep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xrep
argument_list|)
argument_list|)
expr_stmt|;
name|xrep
operator|->
name|xre_format
operator|=
name|fmt
expr_stmt|;
name|xrep
operator|->
name|xre_fields
operator|=
name|xfip
expr_stmt|;
name|xrep
operator|->
name|xre_num_fields
operator|=
name|num_fields
expr_stmt|;
comment|/* Record the field info in the retain bucket */
name|xrep
operator|->
name|xre_next
operator|=
name|xo_retain
operator|.
name|xr_bucket
index|[
name|hash
index|]
expr_stmt|;
name|xo_retain
operator|.
name|xr_bucket
index|[
name|hash
index|]
operator|=
name|xrep
expr_stmt|;
name|xo_retain_count
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !LIBXO_NO_RETAIN */
end_comment

begin_comment
comment|/*  * Generate a warning.  Normally, this is a text message written to  * standard error.  If the XOF_WARN_XML flag is set, then we generate  * XMLified content on standard output.  */
end_comment

begin_function
specifier|static
name|void
name|xo_warn_hcv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|check_warn
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_warn
operator|&&
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_WARN
argument_list|)
condition|)
return|return;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
return|return;
name|ssize_t
name|len
init|=
name|strlen
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
name|ssize_t
name|plen
init|=
name|xo_program
condition|?
name|strlen
argument_list|(
name|xo_program
argument_list|)
else|:
literal|0
decl_stmt|;
name|char
modifier|*
name|newfmt
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
operator|+
name|plen
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|/* NUL, and ": " */
if|if
condition|(
name|plen
condition|)
block|{
name|memcpy
argument_list|(
name|newfmt
argument_list|,
name|xo_program
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|newfmt
index|[
name|plen
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|newfmt
index|[
name|plen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|newfmt
operator|+
name|plen
argument_list|,
name|fmt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newfmt
index|[
name|len
operator|+
name|plen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_WARN_XML
argument_list|)
condition|)
block|{
specifier|static
name|char
name|err_open
index|[]
init|=
literal|"<error>"
decl_stmt|;
specifier|static
name|char
name|err_close
index|[]
init|=
literal|"</error>"
decl_stmt|;
specifier|static
name|char
name|msg_open
index|[]
init|=
literal|"<message>"
decl_stmt|;
specifier|static
name|char
name|msg_close
index|[]
init|=
literal|"</message>"
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|err_open
argument_list|,
sizeof|sizeof
argument_list|(
name|err_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg_open
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|va_list
name|va_local
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|ssize_t
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
decl_stmt|;
name|ssize_t
name|rc
init|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|newfmt
argument_list|,
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|>=
name|left
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
block|{
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
return|return;
block|}
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Reset vap to the start */
name|va_copy
argument_list|(
name|vap
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg_close
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|err_close
argument_list|,
sizeof|sizeof
argument_list|(
name|err_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Append newline and NUL to string */
operator|(
name|void
operator|)
name|xo_write
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|newfmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xo_warn_hc
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|xop
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_warn_c
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|code
init|=
name|errno
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_warnx
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_err
parameter_list|(
name|int
name|eval
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|code
init|=
name|errno
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_errx
parameter_list|(
name|int
name|eval
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_errc
parameter_list|(
name|int
name|eval
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a warning.  Normally, this is a text message written to  * standard error.  If the XOF_WARN_XML flag is set, then we generate  * XMLified content on standard output.  */
end_comment

begin_function
name|void
name|xo_message_hcv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
specifier|static
name|char
name|msg_open
index|[]
init|=
literal|"<message>"
decl_stmt|;
specifier|static
name|char
name|msg_close
index|[]
init|=
literal|"</message>"
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
decl_stmt|;
name|ssize_t
name|rc
decl_stmt|;
name|va_list
name|va_local
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
operator|||
operator|*
name|fmt
operator|==
literal|'\0'
condition|)
return|return;
name|int
name|need_nl
init|=
operator|(
name|fmt
index|[
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
decl_stmt|;
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|xbp
operator|=
operator|&
name|xop
operator|->
name|xo_data
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_indent_by
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg_open
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|ssize_t
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
decl_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
name|left
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
block|{
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
return|return;
block|}
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Reset vap to the start */
name|va_copy
argument_list|(
name|vap
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
if|if
condition|(
name|need_nl
operator|&&
name|code
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_nl
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Append newline and NUL to string */
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg_close
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Append newline and NUL to string */
operator|(
name|void
operator|)
name|xo_write
argument_list|(
name|xop
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|bp
init|=
name|buf
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|ssize_t
name|bufsiz
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|ssize_t
name|rc2
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|bp
argument_list|,
name|bufsiz
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
name|bufsiz
condition|)
block|{
name|bufsiz
operator|=
name|rc
operator|+
name|BUFSIZ
expr_stmt|;
name|bp
operator|=
name|alloca
argument_list|(
name|bufsiz
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|bp
argument_list|,
name|bufsiz
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
name|cp
operator|=
name|bp
operator|+
name|rc
expr_stmt|;
if|if
condition|(
name|need_nl
condition|)
block|{
name|rc2
operator|=
name|snprintf
argument_list|(
name|cp
argument_list|,
name|bufsiz
operator|-
name|rc
argument_list|,
literal|"%s%s\n"
argument_list|,
operator|(
name|code
operator|>
literal|0
operator|)
condition|?
literal|": "
else|:
literal|""
argument_list|,
operator|(
name|code
operator|>
literal|0
operator|)
condition|?
name|strerror
argument_list|(
name|code
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc2
operator|>
literal|0
condition|)
name|rc
operator|+=
name|rc2
expr_stmt|;
block|}
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
literal|"message"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|bp
argument_list|,
name|rc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XO_STYLE_JSON
case|:
case|case
name|XO_STYLE_SDPARAMS
case|:
case|case
name|XO_STYLE_ENCODER
case|:
comment|/* No means of representing messages */
return|return;
case|case
name|XO_STYLE_TEXT
case|:
name|rc
operator|=
name|xo_printf_v
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * XXX need to handle UTF-8 widths 	 */
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|rc
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|rc
expr_stmt|;
block|}
if|if
condition|(
name|need_nl
operator|&&
name|code
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|": %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_nl
condition|)
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_DIV_OPEN
argument_list|)
condition|)
block|{
specifier|static
name|char
name|div_close
index|[]
init|=
literal|"</div>"
decl_stmt|;
name|XOIF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOIF_DIV_OPEN
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_close
argument_list|,
sizeof|sizeof
argument_list|(
name|div_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
operator|(
name|void
operator|)
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_message_hc
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_message_hcv
argument_list|(
name|xop
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_message_c
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_message_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_message_e
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|code
init|=
name|errno
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_message_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_message
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_message_hcv
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_failure
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_WARN
argument_list|)
condition|)
return|return;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|xop
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Create a handle for use by later libxo functions.  *  * Note: normal use of libxo does not require a distinct handle, since  * the default handle (used when NULL is passed) generates text on stdout.  *  * @style Style of output desired (XO_STYLE_* value)  * @flags Set of XOF_* flags in use with this handle  */
end_comment

begin_function
name|xo_handle_t
modifier|*
name|xo_create
parameter_list|(
name|xo_style_t
name|style
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xop
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|xop
condition|)
block|{
name|bzero
argument_list|(
name|xop
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xop
argument_list|)
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_style
operator|=
name|style
expr_stmt|;
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xo_init_handle
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_style
operator|=
name|style
expr_stmt|;
comment|/* Reset style (see LIBXO_OPTIONS) */
block|}
return|return
name|xop
return|;
block|}
end_function

begin_comment
comment|/**  * Create a handle that will write to the given file.  Use  * the XOF_CLOSE_FP flag to have the file closed on xo_destroy().  * @fp FILE pointer to use  * @style Style of output desired (XO_STYLE_* value)  * @flags Set of XOF_* flags to use with this handle  */
end_comment

begin_function
name|xo_handle_t
modifier|*
name|xo_create_to_file
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|xo_style_t
name|style
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
name|xo_create
argument_list|(
name|style
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|xop
condition|)
block|{
name|xop
operator|->
name|xo_opaque
operator|=
name|fp
expr_stmt|;
name|xop
operator|->
name|xo_write
operator|=
name|xo_write_to_file
expr_stmt|;
name|xop
operator|->
name|xo_close
operator|=
name|xo_close_file
expr_stmt|;
name|xop
operator|->
name|xo_flush
operator|=
name|xo_flush_file
expr_stmt|;
block|}
return|return
name|xop
return|;
block|}
end_function

begin_comment
comment|/**  * Set the default handler to output to a file.  * @xop libxo handle  * @fp FILE pointer to use  */
end_comment

begin_function
name|int
name|xo_set_file_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"xo_set_file: NULL fp"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|xop
operator|->
name|xo_opaque
operator|=
name|fp
expr_stmt|;
name|xop
operator|->
name|xo_write
operator|=
name|xo_write_to_file
expr_stmt|;
name|xop
operator|->
name|xo_close
operator|=
name|xo_close_file
expr_stmt|;
name|xop
operator|->
name|xo_flush
operator|=
name|xo_flush_file
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Set the default handler to output to a file.  * @fp FILE pointer to use  */
end_comment

begin_function
name|int
name|xo_set_file
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
return|return
name|xo_set_file_h
argument_list|(
name|NULL
argument_list|,
name|fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Release any resources held by the handle.  * @xop XO handle to alter (or NULL for default handle)  */
end_comment

begin_function
name|void
name|xo_destroy
parameter_list|(
name|xo_handle_t
modifier|*
name|xop_arg
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
name|xo_default
argument_list|(
name|xop_arg
argument_list|)
decl_stmt|;
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_close
operator|&&
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_CLOSE_FP
argument_list|)
condition|)
name|xop
operator|->
name|xo_close
argument_list|(
name|xop
operator|->
name|xo_opaque
argument_list|)
expr_stmt|;
name|xo_free
argument_list|(
name|xop
operator|->
name|xo_stack
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xop
operator|->
name|xo_fmt
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xop
operator|->
name|xo_predicate
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xop
operator|->
name|xo_attrs
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xop
operator|->
name|xo_color_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_version
condition|)
name|xo_free
argument_list|(
name|xop
operator|->
name|xo_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop_arg
operator|==
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|xo_default_handle
argument_list|,
sizeof|sizeof
argument_list|(
name|xo_default_handle
argument_list|)
argument_list|)
expr_stmt|;
name|xo_default_inited
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|xo_free
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Record a new output style to use for the given handle (or default if  * handle is NULL).  This output style will be used for any future output.  *  * @xop XO handle to alter (or NULL for default handle)  * @style new output style (XO_STYLE_*)  */
end_comment

begin_function
name|void
name|xo_set_style
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_style_t
name|style
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_style
operator|=
name|style
expr_stmt|;
block|}
end_function

begin_function
name|xo_style_t
name|xo_get_style
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
return|return
name|xo_style
argument_list|(
name|xop
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_name_to_style
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"xml"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_XML
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"json"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_JSON
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"encoder"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_ENCODER
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_TEXT
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"html"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_HTML
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sdparams"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_SDPARAMS
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Indicate if the style is an "encoding" one as opposed to a "display" one.  */
end_comment

begin_function
specifier|static
name|int
name|xo_style_is_encoding
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_JSON
operator|||
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_XML
operator|||
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_SDPARAMS
operator|||
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_ENCODER
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Simple name-value mapping */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_mapping_s
block|{
name|xo_xff_flags_t
name|xm_value
decl_stmt|;
specifier|const
name|char
modifier|*
name|xm_name
decl_stmt|;
block|}
name|xo_mapping_t
typedef|;
end_typedef

begin_function
specifier|static
name|xo_xff_flags_t
name|xo_name_lookup
parameter_list|(
name|xo_mapping_t
modifier|*
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|value
argument_list|)
condition|)
block|{
name|value
operator|+=
literal|1
expr_stmt|;
name|len
operator|-=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
name|value
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|map
operator|->
name|xm_name
condition|;
name|map
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|map
operator|->
name|xm_name
argument_list|,
name|value
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|map
operator|->
name|xm_value
return|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_NEEDED_YET
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xo_value_lookup
parameter_list|(
name|xo_mapping_t
modifier|*
name|map
parameter_list|,
name|xo_xff_flags_t
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
name|map
operator|->
name|xm_name
condition|;
name|map
operator|++
control|)
if|if
condition|(
name|map
operator|->
name|xm_value
operator|==
name|value
condition|)
return|return
name|map
operator|->
name|xm_name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOT_NEEDED_YET */
end_comment

begin_decl_stmt
specifier|static
name|xo_mapping_t
name|xo_xof_names
index|[]
init|=
block|{
block|{
name|XOF_COLOR_ALLOWED
block|,
literal|"color"
block|}
block|,
block|{
name|XOF_COLUMNS
block|,
literal|"columns"
block|}
block|,
block|{
name|XOF_DTRT
block|,
literal|"dtrt"
block|}
block|,
block|{
name|XOF_FLUSH
block|,
literal|"flush"
block|}
block|,
block|{
name|XOF_FLUSH_LINE
block|,
literal|"flush-line"
block|}
block|,
block|{
name|XOF_IGNORE_CLOSE
block|,
literal|"ignore-close"
block|}
block|,
block|{
name|XOF_INFO
block|,
literal|"info"
block|}
block|,
block|{
name|XOF_KEYS
block|,
literal|"keys"
block|}
block|,
block|{
name|XOF_LOG_GETTEXT
block|,
literal|"log-gettext"
block|}
block|,
block|{
name|XOF_LOG_SYSLOG
block|,
literal|"log-syslog"
block|}
block|,
block|{
name|XOF_NO_HUMANIZE
block|,
literal|"no-humanize"
block|}
block|,
block|{
name|XOF_NO_LOCALE
block|,
literal|"no-locale"
block|}
block|,
block|{
name|XOF_RETAIN_NONE
block|,
literal|"no-retain"
block|}
block|,
block|{
name|XOF_NO_TOP
block|,
literal|"no-top"
block|}
block|,
block|{
name|XOF_NOT_FIRST
block|,
literal|"not-first"
block|}
block|,
block|{
name|XOF_PRETTY
block|,
literal|"pretty"
block|}
block|,
block|{
name|XOF_RETAIN_ALL
block|,
literal|"retain"
block|}
block|,
block|{
name|XOF_UNDERSCORES
block|,
literal|"underscores"
block|}
block|,
block|{
name|XOF_UNITS
block|,
literal|"units"
block|}
block|,
block|{
name|XOF_WARN
block|,
literal|"warn"
block|}
block|,
block|{
name|XOF_WARN_XML
block|,
literal|"warn-xml"
block|}
block|,
block|{
name|XOF_XPATH
block|,
literal|"xpath"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Convert string name to XOF_* flag value.  * Not all are useful.  Or safe.  Or sane.  */
end_comment

begin_function
specifier|static
name|unsigned
name|xo_name_to_flag
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|unsigned
operator|)
name|xo_name_lookup
argument_list|(
name|xo_xof_names
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_set_style_name
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|style
init|=
name|xo_name_to_style
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|style
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|xo_set_style
argument_list|(
name|xop
argument_list|,
name|style
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set the options for a handle using a string of options  * passed in.  The input is a comma-separated set of names  * and optional values: "xml,pretty,indent=4"  */
end_comment

begin_function
name|int
name|xo_set_options
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|input
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|np
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|style
init|=
operator|-
literal|1
decl_stmt|,
name|new_style
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|xo_xof_flags_t
name|new_flag
decl_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBXO_COLOR_ON_BY_DEFAULT
comment|/* If the installer used --enable-color-on-by-default, then we allow it */
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_COLOR_ALLOWED
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LIBXO_COLOR_ON_BY_DEFAULT */
comment|/*      * We support a simpler, old-school style of giving option      * also, using a single character for each option.  It's      * ideal for lazy people, such as myself.      */
if|if
condition|(
operator|*
name|input
operator|==
literal|':'
condition|)
block|{
name|ssize_t
name|sz
decl_stmt|;
for|for
control|(
name|input
operator|++
init|;
operator|*
name|input
condition|;
name|input
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|input
condition|)
block|{
case|case
literal|'c'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_COLOR_ALLOWED
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_FLUSH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_FLUSH_LINE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_LOG_GETTEXT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|xop
operator|->
name|xo_style
operator|=
name|XO_STYLE_HTML
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_INFO
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|sz
operator|=
name|strspn
argument_list|(
name|input
operator|+
literal|1
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|xop
operator|->
name|xo_indent_by
operator|=
name|atoi
argument_list|(
name|input
operator|+
literal|1
argument_list|)
expr_stmt|;
name|input
operator|+=
name|sz
operator|-
literal|1
expr_stmt|;
comment|/* Skip value */
block|}
break|break;
case|case
literal|'J'
case|:
name|xop
operator|->
name|xo_style
operator|=
name|XO_STYLE_JSON
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_KEYS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_HUMANIZE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|xop
operator|->
name|xo_style
operator|=
name|XO_STYLE_TEXT
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_UNITS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_UNDERSCORES
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_WARN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|xop
operator|->
name|xo_style
operator|=
name|XO_STYLE_XML
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|XOF_XPATH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bp
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|bp
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
operator|-
literal|1
init|;
name|cp
operator|&&
name|cp
operator|<
name|ep
condition|;
name|cp
operator|=
name|np
control|)
block|{
name|np
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
operator|*
name|np
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
operator|*
name|vp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"colors"
argument_list|,
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX Look for colors=red-blue+green-yellow */
continue|continue;
block|}
comment|/* 	 * For options, we don't allow "encoder" since we want to 	 * handle it explicitly below as "encoder=xxx". 	 */
name|new_style
operator|=
name|xo_name_to_style
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_style
operator|>=
literal|0
operator|&&
name|new_style
operator|!=
name|XO_STYLE_ENCODER
condition|)
block|{
if|if
condition|(
name|style
operator|>=
literal|0
condition|)
name|xo_warnx
argument_list|(
literal|"ignoring multiple styles: '%s'"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|style
operator|=
name|new_style
expr_stmt|;
block|}
else|else
block|{
name|new_flag
operator|=
name|xo_name_to_flag
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_flag
operator|!=
literal|0
condition|)
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|new_flag
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"no-color"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|XOF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOF_COLOR_ALLOWED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"indent"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
condition|)
name|xop
operator|->
name|xo_indent_by
operator|=
name|atoi
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing value for indent option"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"encoder"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing value for encoder option"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|xo_encoder_init
argument_list|(
name|xop
argument_list|,
name|vp
argument_list|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"encoder not found: %s"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|xo_warnx
argument_list|(
literal|"unknown libxo option value: '%s'"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|style
operator|>
literal|0
condition|)
name|xop
operator|->
name|xo_style
operator|=
name|style
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * Set one or more flags for a given handle (or default if handle is NULL).  * These flags will affect future output.  *  * @xop XO handle to alter (or NULL for default handle)  * @flags Flags to be set (XOF_*)  */
end_comment

begin_function
name|void
name|xo_set_flags
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|XOF_SET
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|xo_xof_flags_t
name|xo_get_flags
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
return|return
name|xop
operator|->
name|xo_flags
return|;
block|}
end_function

begin_comment
comment|/*  * strndup with a twist: len< 0 means strlen  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xo_strndup
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|char
modifier|*
name|cp
init|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/**  * Record a leading prefix for the XPath we generate.  This allows the  * generated data to be placed within an XML hierarchy but still have  * accurate XPath expressions.  *  * @xop XO handle to alter (or NULL for default handle)  * @path The XPath expression  */
end_comment

begin_function
name|void
name|xo_set_leading_xpath
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_leading_xpath
condition|)
block|{
name|xo_free
argument_list|(
name|xop
operator|->
name|xo_leading_xpath
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_leading_xpath
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return;
name|xop
operator|->
name|xo_leading_xpath
operator|=
name|xo_strndup
argument_list|(
name|path
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Record the info data for a set of tags  *  * @xop XO handle to alter (or NULL for default handle)  * @info Info data (xo_info_t) to be recorded (or NULL) (MUST BE SORTED)  * @count Number of entries in info (or -1 to count them ourselves)  */
end_comment

begin_function
name|void
name|xo_set_info
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_info_t
modifier|*
name|infop
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|&&
name|infop
condition|)
block|{
name|xo_info_t
modifier|*
name|xip
decl_stmt|;
for|for
control|(
name|xip
operator|=
name|infop
operator|,
name|count
operator|=
literal|0
init|;
name|xip
operator|->
name|xi_name
condition|;
name|xip
operator|++
operator|,
name|count
operator|++
control|)
continue|continue;
block|}
name|xop
operator|->
name|xo_info
operator|=
name|infop
expr_stmt|;
name|xop
operator|->
name|xo_info_count
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set the formatter callback for a handle.  The callback should  * return a newly formatting contents of a formatting instruction,  * meaning the bits inside the braces.  */
end_comment

begin_function
name|void
name|xo_set_formatter
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_formatter_t
name|func
parameter_list|,
name|xo_checkpointer_t
name|cfunc
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_formatter
operator|=
name|func
expr_stmt|;
name|xop
operator|->
name|xo_checkpointer
operator|=
name|cfunc
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Clear one or more flags for a given handle (or default if handle is NULL).  * These flags will affect future output.  *  * @xop XO handle to alter (or NULL for default handle)  * @flags Flags to be cleared (XOF_*)  */
end_comment

begin_function
name|void
name|xo_clear_flags
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|XOF_CLEAR
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xo_state_name
parameter_list|(
name|xo_state_t
name|state
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|names
index|[]
init|=
block|{
literal|"init"
block|,
literal|"open_container"
block|,
literal|"close_container"
block|,
literal|"open_list"
block|,
literal|"close_list"
block|,
literal|"open_instance"
block|,
literal|"close_instance"
block|,
literal|"open_leaf_list"
block|,
literal|"close_leaf_list"
block|,
literal|"discarding"
block|,
literal|"marker"
block|,
literal|"emit"
block|,
literal|"emit_leaf_list"
block|,
literal|"finish"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|state
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
name|names
index|[
name|state
index|]
return|;
return|return
literal|"unknown"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_line_ensure_open
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xff_flags_t
name|flags
name|UNUSED
parameter_list|)
block|{
specifier|static
name|char
name|div_open
index|[]
init|=
literal|"<div class=\"line\">"
decl_stmt|;
specifier|static
name|char
name|div_open_blank
index|[]
init|=
literal|"<div class=\"blank-line\">"
decl_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_DIV_OPEN
argument_list|)
condition|)
return|return;
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|!=
name|XO_STYLE_HTML
condition|)
return|return;
name|XOIF_SET
argument_list|(
name|xop
argument_list|,
name|XOIF_DIV_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_BLANK_LINE
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_open_blank
argument_list|,
sizeof|sizeof
argument_list|(
name|div_open_blank
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_open
argument_list|,
sizeof|sizeof
argument_list|(
name|div_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_line_close
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
specifier|static
name|char
name|div_close
index|[]
init|=
literal|"</div>"
decl_stmt|;
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
operator|!
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_DIV_OPEN
argument_list|)
condition|)
name|xo_line_ensure_open
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XOIF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOIF_DIV_OPEN
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_close
argument_list|,
sizeof|sizeof
argument_list|(
name|div_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_TEXT
case|:
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xo_info_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|key
decl_stmt|;
specifier|const
name|xo_info_t
modifier|*
name|xip
init|=
name|data
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|name
argument_list|,
name|xip
operator|->
name|xi_name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|xo_info_t
modifier|*
name|xo_info_find
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ssize_t
name|nlen
parameter_list|)
block|{
name|xo_info_t
modifier|*
name|xip
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|nlen
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Need local copy for NUL termination */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|cp
index|[
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xip
operator|=
name|bsearch
argument_list|(
name|cp
argument_list|,
name|xop
operator|->
name|xo_info
argument_list|,
name|xop
operator|->
name|xo_info_count
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_info
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|xo_info_compare
argument_list|)
expr_stmt|;
return|return
name|xip
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CONVERT
parameter_list|(
name|_have
parameter_list|,
name|_need
parameter_list|)
value|(((_have)<< 8) | (_need))
end_define

begin_comment
comment|/*  * Check to see that the conversion is safe and sane.  */
end_comment

begin_function
specifier|static
name|int
name|xo_check_conversion
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|have_enc
parameter_list|,
name|int
name|need_enc
parameter_list|)
block|{
switch|switch
condition|(
name|CONVERT
argument_list|(
name|have_enc
argument_list|,
name|need_enc
argument_list|)
condition|)
block|{
case|case
name|CONVERT
argument_list|(
name|XF_ENC_UTF8
argument_list|,
name|XF_ENC_UTF8
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_UTF8
argument_list|,
name|XF_ENC_LOCALE
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_WIDE
argument_list|,
name|XF_ENC_UTF8
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_WIDE
argument_list|,
name|XF_ENC_LOCALE
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_LOCALE
argument_list|,
name|XF_ENC_LOCALE
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_LOCALE
argument_list|,
name|XF_ENC_UTF8
argument_list|)
case|:
return|return
literal|0
return|;
default|default:
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid conversion (%c:%c)"
argument_list|,
name|have_enc
argument_list|,
name|need_enc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xo_format_string_direct
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|wcp
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|need_enc
parameter_list|,
name|int
name|have_enc
parameter_list|)
block|{
name|int
name|cols
init|=
literal|0
decl_stmt|;
name|wchar_t
name|wc
init|=
literal|0
decl_stmt|;
name|ssize_t
name|ilen
decl_stmt|,
name|olen
decl_stmt|;
name|ssize_t
name|width
decl_stmt|;
name|int
name|attr
init|=
name|XOF_BIT_ISSET
argument_list|(
name|flags
argument_list|,
name|XFF_ATTR
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_UNESCAPE
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|||
operator|*
name|cp
operator|==
literal|'%'
operator|)
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
name|len
operator|-=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wcp
operator|&&
operator|*
name|wcp
operator|==
literal|L'
expr|\0'
condition|)
break|break;
name|ilen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|have_enc
condition|)
block|{
case|case
name|XF_ENC_WIDE
case|:
comment|/* Wide character */
name|wc
operator|=
operator|*
name|wcp
operator|++
expr_stmt|;
name|ilen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XF_ENC_UTF8
case|:
comment|/* UTF-8 */
name|ilen
operator|=
name|xo_utf8_to_wc_len
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilen
operator|<
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 character: %02hhx"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* Can't continue; we can't find the end */
block|}
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<
name|ilen
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Break out of the loop */
continue|continue;
block|}
name|wc
operator|=
name|xo_utf8_char
argument_list|(
name|cp
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
operator|(
name|wchar_t
operator|)
operator|-
literal|1
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 character: %02hhx/%d"
argument_list|,
operator|*
name|cp
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* Can't continue; we can't find the end */
block|}
name|cp
operator|+=
name|ilen
expr_stmt|;
break|break;
case|case
name|XF_ENC_LOCALE
case|:
comment|/* Native locale */
name|ilen
operator|=
operator|(
name|len
operator|>
literal|0
operator|)
condition|?
name|len
else|:
name|MB_LEN_MAX
expr_stmt|;
name|ilen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|cp
argument_list|,
name|ilen
argument_list|,
operator|&
name|xop
operator|->
name|xo_mbstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilen
operator|<
literal|0
condition|)
block|{
comment|/* Invalid data; skip */
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid mbs char: %02hhx"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|wc
operator|=
literal|L'
expr|?'
expr_stmt|;
name|ilen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ilen
operator|==
literal|0
condition|)
block|{
comment|/* Hit a wide NUL character */
name|len
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|ilen
expr_stmt|;
break|break;
block|}
comment|/* Reduce len, but not below zero */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|len
operator|-=
name|ilen
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Find the width-in-columns of this character, which must be done 	 * in wide characters, since we lack a mbswidth() function.  If 	 * it doesn't fit 	 */
name|width
operator|=
name|xo_wcwidth
argument_list|(
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
name|iswcntrl
argument_list|(
name|wc
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_TEXT
operator|||
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_HTML
condition|)
block|{
if|if
condition|(
name|max
operator|>
literal|0
operator|&&
name|cols
operator|+
name|width
operator|>
name|max
condition|)
break|break;
block|}
switch|switch
condition|(
name|need_enc
condition|)
block|{
case|case
name|XF_ENC_UTF8
case|:
comment|/* Output in UTF-8 needs to be escaped, based on the style */
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
name|wc
operator|==
literal|'<'
condition|)
name|sp
operator|=
name|xo_xml_lt
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|==
literal|'>'
condition|)
name|sp
operator|=
name|xo_xml_gt
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|==
literal|'&'
condition|)
name|sp
operator|=
name|xo_xml_amp
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&&
name|wc
operator|==
literal|'"'
condition|)
name|sp
operator|=
name|xo_xml_quot
expr_stmt|;
else|else
break|break;
name|ssize_t
name|slen
init|=
name|strlen
argument_list|(
name|sp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|slen
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|sp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|slen
expr_stmt|;
goto|goto
name|done_with_encoding
goto|;
comment|/* Need multi-level 'break' */
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
name|wc
operator|!=
literal|'\\'
operator|&&
name|wc
operator|!=
literal|'"'
operator|&&
name|wc
operator|!=
literal|'\n'
operator|&&
name|wc
operator|!=
literal|'\r'
condition|)
break|break;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|wc
operator|==
literal|'\n'
condition|)
name|wc
operator|=
literal|'n'
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|==
literal|'\r'
condition|)
name|wc
operator|=
literal|'r'
expr_stmt|;
else|else
name|wc
operator|=
name|wc
operator|&
literal|0x7f
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
name|wc
expr_stmt|;
goto|goto
name|done_with_encoding
goto|;
case|case
name|XO_STYLE_SDPARAMS
case|:
if|if
condition|(
name|wc
operator|!=
literal|'\\'
operator|&&
name|wc
operator|!=
literal|'"'
operator|&&
name|wc
operator|!=
literal|']'
condition|)
break|break;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|wc
operator|=
name|wc
operator|&
literal|0x7f
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
name|wc
expr_stmt|;
goto|goto
name|done_with_encoding
goto|;
block|}
name|olen
operator|=
name|xo_utf8_emit_len
argument_list|(
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|<
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"ignoring bad length"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|olen
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xo_utf8_emit_char
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|olen
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|olen
expr_stmt|;
break|break;
case|case
name|XF_ENC_LOCALE
case|:
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|MB_LEN_MAX
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|olen
operator|=
name|wcrtomb
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|wc
argument_list|,
operator|&
name|xop
operator|->
name|xo_mbstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|<=
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"could not convert wide char: %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wc
argument_list|)
expr_stmt|;
name|width
operator|=
literal|1
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
name|xbp
operator|->
name|xb_curp
operator|+=
name|olen
expr_stmt|;
break|break;
block|}
name|done_with_encoding
label|:
name|cols
operator|+=
name|width
expr_stmt|;
block|}
return|return
name|cols
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_needed_encoding
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_UTF8
argument_list|)
condition|)
comment|/* Check the override flag */
return|return
name|XF_ENC_UTF8
return|;
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_TEXT
condition|)
comment|/* Text means locale */
return|return
name|XF_ENC_LOCALE
return|;
return|return
name|XF_ENC_UTF8
return|;
comment|/* Otherwise, we love UTF-8 */
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_format_string
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|,
name|xo_format_t
modifier|*
name|xfp
parameter_list|)
block|{
specifier|static
name|char
name|null
index|[]
init|=
literal|"(null)"
decl_stmt|;
specifier|static
name|char
name|null_no_quotes
index|[]
init|=
literal|"null"
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|wchar_t
modifier|*
name|wcp
init|=
name|NULL
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|ssize_t
name|cols
init|=
literal|0
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|ssize_t
name|off
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|,
name|off2
decl_stmt|;
name|int
name|need_enc
init|=
name|xo_needed_encoding
argument_list|(
name|xop
argument_list|)
decl_stmt|;
if|if
condition|(
name|xo_check_conversion
argument_list|(
name|xop
argument_list|,
name|xfp
operator|->
name|xf_enc
argument_list|,
name|need_enc
argument_list|)
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_SIZE
index|]
expr_stmt|;
if|if
condition|(
name|xfp
operator|->
name|xf_fc
operator|==
literal|'m'
condition|)
block|{
name|cp
operator|=
name|strerror
argument_list|(
name|xop
operator|->
name|xo_errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
name|cp
condition|?
name|strlen
argument_list|(
name|cp
argument_list|)
else|:
literal|0
expr_stmt|;
goto|goto
name|normal_string
goto|;
block|}
elseif|else
if|if
condition|(
name|xfp
operator|->
name|xf_enc
operator|==
name|XF_ENC_WIDE
condition|)
block|{
name|wcp
operator|=
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|wchar_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfp
operator|->
name|xf_skip
condition|)
return|return
literal|0
return|;
comment|/* 	 * Dont' deref NULL; use the traditional "(null)" instead 	 * of the more accurate "who's been a naughty boy, then?". 	 */
if|if
condition|(
name|wcp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|null
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|null
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp
operator|=
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* UTF-8 or native */
name|normal_string
label|:
if|if
condition|(
name|xfp
operator|->
name|xf_skip
condition|)
return|return
literal|0
return|;
comment|/* Echo "Dont' deref NULL" logic */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_NOQUOTE
operator|)
operator|&&
name|xo_style_is_encoding
argument_list|(
name|xop
argument_list|)
condition|)
block|{
name|cp
operator|=
name|null_no_quotes
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|null_no_quotes
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|null
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|null
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Optimize the most common case, which is "%s".  We just 	 * need to copy the complete string to the output buffer. 	 */
if|if
condition|(
name|xfp
operator|->
name|xf_enc
operator|==
name|need_enc
operator|&&
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MIN
index|]
operator|<
literal|0
operator|&&
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_SIZE
index|]
operator|<
literal|0
operator|&&
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MAX
index|]
operator|<
literal|0
operator|&&
operator|!
operator|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
operator|||
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
operator|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|xo_buf_escape
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|cp
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	     * Our caller expects xb_curp left untouched, so we have 	     * to reset it and return the number of bytes written to 	     * the buffer. 	     */
name|off2
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
name|rc
operator|=
name|off2
operator|-
name|off
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|off
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
name|cols
operator|=
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|flags
argument_list|,
name|wcp
argument_list|,
name|cp
argument_list|,
name|len
argument_list|,
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MAX
index|]
argument_list|,
name|need_enc
argument_list|,
name|xfp
operator|->
name|xf_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|<
literal|0
condition|)
goto|goto
name|bail
goto|;
comment|/*      * xo_buf_append* will move xb_curp, so we save/restore it.      */
name|off2
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
name|rc
operator|=
name|off2
operator|-
name|off
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|cols
operator|<
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MIN
index|]
condition|)
block|{
comment|/* 	 * Find the number of columns needed to display the string. 	 * If we have the original wide string, we just call wcswidth, 	 * but if we did the work ourselves, then we need to do it. 	 */
name|int
name|delta
init|=
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MIN
index|]
operator|-
name|cols
decl_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MIN
index|]
argument_list|)
condition|)
goto|goto
name|bail
goto|;
comment|/* 	 * If seen_minus, then pad on the right; otherwise move it so 	 * we can pad on the left. 	 */
if|if
condition|(
name|xfp
operator|->
name|xf_seen_minus
condition|)
block|{
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
operator|+
name|rc
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_curp
operator|+
name|delta
argument_list|,
name|xbp
operator|->
name|xb_curp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* Set the padding */
name|memset
argument_list|(
name|cp
argument_list|,
operator|(
name|xfp
operator|->
name|xf_leading_zero
operator|>
literal|0
operator|)
condition|?
literal|'0'
else|:
literal|' '
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|rc
operator|+=
name|delta
expr_stmt|;
name|cols
operator|+=
name|delta
expr_stmt|;
block|}
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
return|return
name|rc
return|;
name|bail
label|:
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|off
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Look backwards in a buffer to find a numeric value  */
end_comment

begin_function
specifier|static
name|int
name|xo_buf_find_last_number
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|ssize_t
name|start_offset
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* Fail with zero */
name|int
name|digit
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|sp
init|=
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|sp
operator|+
name|start_offset
decl_stmt|;
while|while
condition|(
operator|--
name|cp
operator|>=
name|sp
condition|)
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
break|break;
for|for
control|(
init|;
name|cp
operator|>=
name|sp
condition|;
name|cp
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
break|break;
name|rc
operator|+=
operator|(
operator|*
name|cp
operator|-
literal|'0'
operator|)
operator|*
name|digit
expr_stmt|;
name|digit
operator|*=
literal|10
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_count_utf8_cols
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
name|ssize_t
name|tlen
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|ssize_t
name|cols
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ep
init|=
name|str
operator|+
name|len
decl_stmt|;
while|while
condition|(
name|str
operator|<
name|ep
condition|)
block|{
name|tlen
operator|=
name|xo_utf8_to_wc_len
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
literal|0
condition|)
comment|/* Broken input is very bad */
return|return
name|cols
return|;
name|wc
operator|=
name|xo_utf8_char
argument_list|(
name|str
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
operator|(
name|wchar_t
operator|)
operator|-
literal|1
condition|)
return|return
name|cols
return|;
comment|/* We only print printable characters */
if|if
condition|(
name|iswprint
argument_list|(
operator|(
name|wint_t
operator|)
name|wc
argument_list|)
condition|)
block|{
comment|/* 	     * Find the width-in-columns of this character, which must be done 	     * in wide characters, since we lack a mbswidth() function. 	     */
name|ssize_t
name|width
init|=
name|xo_wcwidth
argument_list|(
name|wc
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
name|iswcntrl
argument_list|(
name|wc
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|cols
operator|+=
name|width
expr_stmt|;
block|}
name|str
operator|+=
name|tlen
expr_stmt|;
block|}
return|return
name|cols
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETTEXT
end_ifdef

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|xo_dgettext
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|domainname
init|=
name|xop
operator|->
name|xo_gt_domain
decl_stmt|;
specifier|const
name|char
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|dgettext
argument_list|(
name|domainname
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_LOG_GETTEXT
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xo: gettext: %s%s%smsgid \"%s\" returns \"%s\"\n"
argument_list|,
name|domainname
condition|?
literal|"domain \""
else|:
literal|""
argument_list|,
name|xo_printable
argument_list|(
name|domainname
argument_list|)
argument_list|,
name|domainname
condition|?
literal|"\", "
else|:
literal|""
argument_list|,
name|xo_printable
argument_list|(
name|str
argument_list|)
argument_list|,
name|xo_printable
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|xo_dngettext
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|sing
parameter_list|,
specifier|const
name|char
modifier|*
name|plural
parameter_list|,
name|unsigned
name|long
name|int
name|n
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|domainname
init|=
name|xop
operator|->
name|xo_gt_domain
decl_stmt|;
specifier|const
name|char
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|dngettext
argument_list|(
name|domainname
argument_list|,
name|sing
argument_list|,
name|plural
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_LOG_GETTEXT
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xo: gettext: %s%s%s"
literal|"msgid \"%s\", msgid_plural \"%s\" (%lu) returns \"%s\"\n"
argument_list|,
name|domainname
condition|?
literal|"domain \""
else|:
literal|""
argument_list|,
name|xo_printable
argument_list|(
name|domainname
argument_list|)
argument_list|,
name|domainname
condition|?
literal|"\", "
else|:
literal|""
argument_list|,
name|xo_printable
argument_list|(
name|sing
argument_list|)
argument_list|,
name|xo_printable
argument_list|(
name|plural
argument_list|)
argument_list|,
name|n
argument_list|,
name|xo_printable
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_GETTEXT */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|xo_dgettext
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|xo_dngettext
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|singular
parameter_list|,
specifier|const
name|char
modifier|*
name|plural
parameter_list|,
name|unsigned
name|long
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
name|n
operator|==
literal|1
operator|)
condition|?
name|singular
else|:
name|plural
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GETTEXT */
end_comment

begin_comment
comment|/*  * This is really _re_formatting, since the normal format code has  * generated a beautiful string into xo_data, starting at  * start_offset.  We need to see if it's plural, which means  * comma-separated options, or singular.  Then we make the appropriate  * call to d[n]gettext() to get the locale-based version.  Note that  * both input and output of gettext() this should be UTF-8.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_format_gettext
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|,
name|ssize_t
name|start_offset
parameter_list|,
name|ssize_t
name|cols
parameter_list|,
name|int
name|need_enc
parameter_list|)
block|{
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|cols
return|;
name|xbp
operator|->
name|xb_curp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* NUL-terminate the input string */
name|char
modifier|*
name|cp
init|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|start_offset
decl_stmt|;
name|ssize_t
name|len
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|newstr
init|=
name|NULL
decl_stmt|;
comment|/*      * The plural flag asks us to look backwards at the last numeric      * value rendered and disect the string into two pieces.      */
if|if
condition|(
name|flags
operator|&
name|XFF_GT_PLURAL
condition|)
block|{
name|int
name|n
init|=
name|xo_buf_find_last_number
argument_list|(
name|xbp
argument_list|,
name|start_offset
argument_list|)
decl_stmt|;
name|char
modifier|*
name|two
init|=
name|memchr
argument_list|(
name|cp
argument_list|,
operator|(
name|int
operator|)
literal|','
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|two
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"no comma in plural gettext field: '%s'"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|cols
return|;
block|}
if|if
condition|(
name|two
operator|==
name|cp
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"nothing before comma in plural gettext "
literal|"field: '%s'"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|cols
return|;
block|}
if|if
condition|(
name|two
operator|==
name|xbp
operator|->
name|xb_curp
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"nothing after comma in plural gettext "
literal|"field: '%s'"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|cols
return|;
block|}
operator|*
name|two
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_GT_FIELD
condition|)
block|{
name|newstr
operator|=
name|xo_dngettext
argument_list|(
name|xop
argument_list|,
name|cp
argument_list|,
name|two
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't do a gettext() look up, just get the plural form */
name|newstr
operator|=
operator|(
name|n
operator|==
literal|1
operator|)
condition|?
name|cp
else|:
name|two
expr_stmt|;
block|}
comment|/* 	 * If we returned the first string, optimize a bit by 	 * backing up over comma 	 */
if|if
condition|(
name|newstr
operator|==
name|cp
condition|)
block|{
name|xbp
operator|->
name|xb_curp
operator|=
name|two
operator|-
literal|1
expr_stmt|;
comment|/* One for comma */
comment|/* 	     * If the caller wanted UTF8, we're done; nothing changed, 	     * but we need to count the columns used. 	     */
if|if
condition|(
name|need_enc
operator|==
name|XF_ENC_UTF8
condition|)
return|return
name|xo_count_utf8_cols
argument_list|(
name|cp
argument_list|,
name|xbp
operator|->
name|xb_curp
operator|-
name|cp
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* The simple case (singular) */
name|newstr
operator|=
name|xo_dgettext
argument_list|(
name|xop
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstr
operator|==
name|cp
condition|)
block|{
comment|/* If the caller wanted UTF8, we're done; nothing changed */
if|if
condition|(
name|need_enc
operator|==
name|XF_ENC_UTF8
condition|)
return|return
name|cols
return|;
block|}
block|}
comment|/*      * Since the new string string might be in gettext's buffer or      * in the buffer (as the plural form), we make a copy.      */
name|ssize_t
name|nlen
init|=
name|strlen
argument_list|(
name|newstr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newcopy
init|=
name|alloca
argument_list|(
name|nlen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newcopy
argument_list|,
name|newstr
argument_list|,
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|start_offset
expr_stmt|;
comment|/* Reset the buffer */
return|return
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|newcopy
argument_list|,
name|nlen
argument_list|,
literal|0
argument_list|,
name|need_enc
argument_list|,
name|XF_ENC_UTF8
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_data_append_content
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
name|int
name|cols
decl_stmt|;
name|int
name|need_enc
init|=
name|xo_needed_encoding
argument_list|(
name|xop
argument_list|)
decl_stmt|;
name|ssize_t
name|start_offset
init|=
name|xo_buf_offset
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
decl_stmt|;
name|cols
operator|=
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|XFF_UNESCAPE
operator||
name|flags
argument_list|,
name|NULL
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|,
name|need_enc
argument_list|,
name|XF_ENC_UTF8
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_GT_FLAGS
condition|)
name|cols
operator|=
name|xo_format_gettext
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|start_offset
argument_list|,
name|cols
argument_list|,
name|need_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_bump_width
parameter_list|(
name|xo_format_t
modifier|*
name|xfp
parameter_list|,
name|int
name|digit
parameter_list|)
block|{
name|int
modifier|*
name|ip
init|=
operator|&
name|xfp
operator|->
name|xf_width
index|[
name|xfp
operator|->
name|xf_dots
index|]
decl_stmt|;
operator|*
name|ip
operator|=
operator|(
operator|(
operator|*
name|ip
operator|>
literal|0
operator|)
condition|?
operator|*
name|ip
else|:
literal|0
operator|)
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_trim_ws
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|ssize_t
name|delta
decl_stmt|;
comment|/* First trim leading space */
for|for
control|(
name|cp
operator|=
name|sp
operator|=
name|xbp
operator|->
name|xb_curp
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|' '
condition|)
break|break;
block|}
name|delta
operator|=
name|cp
operator|-
name|sp
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|len
operator|-=
name|delta
expr_stmt|;
name|memmove
argument_list|(
name|sp
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Then trim off the end */
for|for
control|(
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
operator|,
name|sp
operator|=
name|ep
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|ep
operator|--
control|)
block|{
if|if
condition|(
name|ep
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
break|break;
block|}
name|delta
operator|=
name|sp
operator|-
name|ep
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|len
operator|-=
name|delta
expr_stmt|;
name|cp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Interface to format a single field.  The arguments are in xo_vap,  * and the format is in 'fmt'.  If 'xbp' is null, we use xop->xo_data;  * this is the most common case.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_do_format_field
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|ssize_t
name|flen
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
name|xo_format_t
name|xf
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|xp
init|=
name|NULL
decl_stmt|;
name|ssize_t
name|rc
decl_stmt|,
name|cols
decl_stmt|;
name|int
name|style
init|=
operator|(
name|flags
operator|&
name|XFF_XML
operator|)
condition|?
name|XO_STYLE_XML
else|:
name|xo_style
argument_list|(
name|xop
argument_list|)
decl_stmt|;
name|unsigned
name|make_output
init|=
operator|!
operator|(
name|flags
operator|&
name|XFF_NO_OUTPUT
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|need_enc
init|=
name|xo_needed_encoding
argument_list|(
name|xop
argument_list|)
decl_stmt|;
name|int
name|real_need_enc
init|=
name|need_enc
decl_stmt|;
name|ssize_t
name|old_cols
init|=
name|xop
operator|->
name|xo_columns
decl_stmt|;
comment|/* The gettext interface is UTF-8, so we'll need that for now */
if|if
condition|(
name|flags
operator|&
name|XFF_GT_FIELD
condition|)
name|need_enc
operator|=
name|XF_ENC_UTF8
expr_stmt|;
if|if
condition|(
name|xbp
operator|==
name|NULL
condition|)
name|xbp
operator|=
operator|&
name|xop
operator|->
name|xo_data
expr_stmt|;
name|ssize_t
name|start_offset
init|=
name|xo_buf_offset
argument_list|(
name|xbp
argument_list|)
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|fmt
operator|,
name|ep
operator|=
name|fmt
operator|+
name|flen
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
comment|/* 	 * Since we're starting a new field, save the starting offset. 	 * We'll need this later for field-related operations. 	 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'%'
condition|)
block|{
name|add_one
label|:
if|if
condition|(
name|xp
operator|==
name|NULL
condition|)
name|xp
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cp
operator|+
literal|1
operator|<
name|ep
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
goto|goto
name|add_one
goto|;
block|}
if|if
condition|(
name|xp
condition|)
block|{
if|if
condition|(
name|make_output
condition|)
block|{
name|cols
operator|=
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|flags
operator||
name|XFF_UNESCAPE
argument_list|,
name|NULL
argument_list|,
name|xp
argument_list|,
name|cp
operator|-
name|xp
argument_list|,
operator|-
literal|1
argument_list|,
name|need_enc
argument_list|,
name|XF_ENC_UTF8
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
block|}
name|xp
operator|=
name|NULL
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|xf
argument_list|,
sizeof|sizeof
argument_list|(
name|xf
argument_list|)
argument_list|)
expr_stmt|;
name|xf
operator|.
name|xf_leading_zero
operator|=
operator|-
literal|1
expr_stmt|;
name|xf
operator|.
name|xf_width
index|[
literal|0
index|]
operator|=
name|xf
operator|.
name|xf_width
index|[
literal|1
index|]
operator|=
name|xf
operator|.
name|xf_width
index|[
literal|2
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * "%@" starts an XO-specific set of flags: 	 *   @X@ - XML-only field; ignored if style isn't XML 	 */
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'@'
condition|)
block|{
for|for
control|(
name|cp
operator|+=
literal|2
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
comment|/* 		     * '*' means there's a "%*.*s" value in vap that 		     * we want to ignore 		     */
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_VA_ARG
argument_list|)
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Hidden fields are only visible to JSON and XML */
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XFF_ENCODE_ONLY
argument_list|)
condition|)
block|{
if|if
condition|(
name|style
operator|!=
name|XO_STYLE_XML
operator|&&
operator|!
name|xo_style_is_encoding
argument_list|(
name|xop
argument_list|)
condition|)
name|xf
operator|.
name|xf_skip
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XFF_DISPLAY_ONLY
argument_list|)
condition|)
block|{
if|if
condition|(
name|style
operator|!=
name|XO_STYLE_TEXT
operator|&&
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|!=
name|XO_STYLE_HTML
condition|)
name|xf
operator|.
name|xf_skip
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|make_output
condition|)
name|xf
operator|.
name|xf_skip
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Looking at one piece of a format; find the end and 	 * call snprintf.  Then advance xo_vap on our own. 	 * 	 * Note that 'n', 'v', and '$' are not supported. 	 */
name|sp
operator|=
name|cp
expr_stmt|;
comment|/* Save start pointer */
for|for
control|(
name|cp
operator|+=
literal|1
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'l'
condition|)
name|xf
operator|.
name|xf_lflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'h'
condition|)
name|xf
operator|.
name|xf_hflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'j'
condition|)
name|xf
operator|.
name|xf_jflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'t'
condition|)
name|xf
operator|.
name|xf_tflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'z'
condition|)
name|xf
operator|.
name|xf_zflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'q'
condition|)
name|xf
operator|.
name|xf_qflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|++
name|xf
operator|.
name|xf_dots
operator|>=
name|XF_WIDTH_NUM
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"Too many dots in format: '%s'"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|xf
operator|.
name|xf_seen_minus
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_leading_zero
operator|<
literal|0
condition|)
name|xf
operator|.
name|xf_leading_zero
operator|=
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
expr_stmt|;
name|xo_bump_width
argument_list|(
operator|&
name|xf
argument_list|,
operator|*
name|cp
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
name|xf
operator|.
name|xf_stars
operator|+=
literal|1
expr_stmt|;
name|xf
operator|.
name|xf_star
index|[
name|xf
operator|.
name|xf_dots
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"diouxXDOUeEfFgGaAcCsSpm"
argument_list|,
operator|*
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'n'
operator|||
operator|*
name|cp
operator|==
literal|'v'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"unsupported format: '%s'"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|cp
operator|==
name|ep
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"field format missing format character: %s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xf
operator|.
name|xf_fc
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_VA_ARG
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'s'
operator|||
operator|*
name|cp
operator|==
literal|'S'
condition|)
block|{
comment|/* Handle "%*.*.*s" */
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|XF_WIDTH_NUM
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_star
index|[
name|s
index|]
condition|)
block|{
name|xf
operator|.
name|xf_width
index|[
name|s
index|]
operator|=
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* Normalize a negative width value */
if|if
condition|(
name|xf
operator|.
name|xf_width
index|[
name|s
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|xf
operator|.
name|xf_width
index|[
literal|0
index|]
operator|=
operator|-
name|xf
operator|.
name|xf_width
index|[
literal|0
index|]
expr_stmt|;
name|xf
operator|.
name|xf_seen_minus
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|xf
operator|.
name|xf_width
index|[
name|s
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Ignore negative values */
block|}
block|}
block|}
block|}
block|}
comment|/* If no max is given, it defaults to size */
if|if
condition|(
name|xf
operator|.
name|xf_width
index|[
name|XF_WIDTH_MAX
index|]
operator|<
literal|0
operator|&&
name|xf
operator|.
name|xf_width
index|[
name|XF_WIDTH_SIZE
index|]
operator|>=
literal|0
condition|)
name|xf
operator|.
name|xf_width
index|[
name|XF_WIDTH_MAX
index|]
operator|=
name|xf
operator|.
name|xf_width
index|[
name|XF_WIDTH_SIZE
index|]
expr_stmt|;
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'D'
operator|||
name|xf
operator|.
name|xf_fc
operator|==
literal|'O'
operator|||
name|xf
operator|.
name|xf_fc
operator|==
literal|'U'
condition|)
name|xf
operator|.
name|xf_lflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|xf
operator|.
name|xf_skip
condition|)
block|{
name|xo_buffer_t
modifier|*
name|fbp
init|=
operator|&
name|xop
operator|->
name|xo_fmt
decl_stmt|;
name|ssize_t
name|len
init|=
name|cp
operator|-
name|sp
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|fbp
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|char
modifier|*
name|newfmt
init|=
name|fbp
operator|->
name|xb_curp
decl_stmt|;
name|memcpy
argument_list|(
name|newfmt
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newfmt
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
comment|/* If we skipped over a "%@...@s" format */
name|newfmt
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	     * Bad news: our strings are UTF-8, but the stock printf 	     * functions won't handle field widths for wide characters 	     * correctly.  So we have to handle this ourselves. 	     */
if|if
condition|(
name|xop
operator|->
name|xo_formatter
operator|==
name|NULL
operator|&&
operator|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'s'
operator|||
name|xf
operator|.
name|xf_fc
operator|==
literal|'S'
operator|||
name|xf
operator|.
name|xf_fc
operator|==
literal|'m'
operator|)
condition|)
block|{
name|xf
operator|.
name|xf_enc
operator|=
operator|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'m'
operator|)
condition|?
name|XF_ENC_UTF8
else|:
operator|(
name|xf
operator|.
name|xf_lflag
operator|||
operator|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'S'
operator|)
operator|)
condition|?
name|XF_ENC_WIDE
else|:
name|xf
operator|.
name|xf_hflag
condition|?
name|XF_ENC_LOCALE
else|:
name|XF_ENC_UTF8
expr_stmt|;
name|rc
operator|=
name|xo_format_string
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|flags
argument_list|,
operator|&
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_TRIM_WS
operator|)
operator|&&
name|xo_style_is_encoding
argument_list|(
name|xop
argument_list|)
condition|)
name|rc
operator|=
name|xo_trim_ws
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ssize_t
name|columns
init|=
name|rc
operator|=
name|xo_vsnprintf
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|newfmt
argument_list|,
name|xop
operator|->
name|xo_vap
argument_list|)
decl_stmt|;
comment|/* 		 * For XML and HTML, we need "&<>" processing; for JSON, 		 * it's quotes.  Text gets nothing. 		 */
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_TRIM_WS
condition|)
name|columns
operator|=
name|rc
operator|=
name|xo_trim_ws
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|XO_STYLE_HTML
case|:
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
operator|(
name|flags
operator|&
name|XFF_ATTR
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_TRIM_WS
condition|)
name|columns
operator|=
name|rc
operator|=
name|xo_trim_ws
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_escape_json
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_SDPARAMS
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_TRIM_WS
condition|)
name|columns
operator|=
name|rc
operator|=
name|xo_trim_ws
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_escape_sdparams
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_TRIM_WS
condition|)
name|columns
operator|=
name|rc
operator|=
name|xo_trim_ws
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * We can assume all the non-%s data we've 		 * added is ASCII, so the columns and bytes are the 		 * same.  xo_format_string handles all the fancy 		 * string conversions and updates xo_anchor_columns 		 * accordingly. 		 */
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|columns
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|columns
expr_stmt|;
block|}
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
block|}
comment|/* 	 * Now for the tricky part: we need to move the argument pointer 	 * along by the amount needed. 	 */
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_VA_ARG
argument_list|)
condition|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'s'
operator|||
name|xf
operator|.
name|xf_fc
operator|==
literal|'S'
condition|)
block|{
comment|/* 		 * The 'S' and 's' formats are normally handled in 		 * xo_format_string, but if we skipped it, then we 		 * need to pop it. 		 */
if|if
condition|(
name|xf
operator|.
name|xf_skip
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'m'
condition|)
block|{
comment|/* Nothing on the stack for "%m" */
block|}
else|else
block|{
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|XF_WIDTH_NUM
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_star
index|[
name|s
index|]
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
literal|"diouxXDOU"
argument_list|,
name|xf
operator|.
name|xf_fc
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_hflag
operator|>
literal|1
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_hflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_lflag
operator|>
literal|1
condition|)
block|{
name|va_arg
argument_list|(
argument|xop->xo_vap
argument_list|,
argument|unsigned long long
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_lflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
argument|xop->xo_vap
argument_list|,
argument|unsigned long
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_jflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|intmax_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_tflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|ptrdiff_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_zflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_qflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|quad_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"eEfFgGaA"
argument_list|,
name|xf
operator|.
name|xf_fc
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|xf
operator|.
name|xf_lflag
condition|)
name|va_arg
argument_list|(
argument|xop->xo_vap
argument_list|,
argument|long double
argument_list|)
empty_stmt|;
else|else
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|double
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'C'
operator|||
operator|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'c'
operator|&&
name|xf
operator|.
name|xf_lflag
operator|)
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|wint_t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'c'
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'p'
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|xp
condition|)
block|{
if|if
condition|(
name|make_output
condition|)
block|{
name|cols
operator|=
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|flags
operator||
name|XFF_UNESCAPE
argument_list|,
name|NULL
argument_list|,
name|xp
argument_list|,
name|cp
operator|-
name|xp
argument_list|,
operator|-
literal|1
argument_list|,
name|need_enc
argument_list|,
name|XF_ENC_UTF8
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
block|}
name|xp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|XFF_GT_FLAGS
condition|)
block|{
comment|/* 	 * Handle gettext()ing the field by looking up the value 	 * and then copying it in, while converting to locale, if 	 * needed. 	 */
name|ssize_t
name|new_cols
init|=
name|xo_format_gettext
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|start_offset
argument_list|,
name|old_cols
argument_list|,
name|real_need_enc
argument_list|)
decl_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|new_cols
operator|-
name|old_cols
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|new_cols
operator|-
name|old_cols
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xo_fix_encoding
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|encoding
decl_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'%'
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|cp
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|encoding
return|;
for|for
control|(
name|cp
operator|+=
literal|2
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
name|cp
operator|-=
literal|1
expr_stmt|;
operator|*
name|cp
operator|=
literal|'%'
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_color_append_html
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
comment|/*      * If the color buffer has content, we add it now.  It's already      * prebuilt and ready, since we want to add it to every<div>.      */
if|if
condition|(
operator|!
name|xo_buf_is_empty
argument_list|(
operator|&
name|xop
operator|->
name|xo_color_buf
argument_list|)
condition|)
block|{
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_color_buf
decl_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xbp
operator|->
name|xb_bufp
argument_list|,
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * A wrapper for humanize_number that autoscales, since the  * HN_AUTOSCALE flag scales as needed based on the size of  * the output buffer, not the size of the value.  I also  * wish HN_DECIMAL was more imperative, without the<10  * test.  But the boat only goes where we want when we hold  * the rudder, so xo_humanize fixes part of the problem.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_humanize
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|scale
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|uint64_t
name|left
init|=
name|value
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|HN_DIVISOR_1000
condition|)
block|{
for|for
control|(
init|;
name|left
condition|;
name|scale
operator|++
control|)
name|left
operator|/=
literal|1000
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|left
condition|;
name|scale
operator|++
control|)
name|left
operator|/=
literal|1024
expr_stmt|;
block|}
name|scale
operator|-=
literal|1
expr_stmt|;
block|}
return|return
name|xo_humanize_number
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|value
argument_list|,
literal|""
argument_list|,
name|scale
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is an area where we can save information from the handle for  * later restoration.  We need to know what data was rendered to know  * what needs cleaned up.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_humanize_save_s
block|{
name|ssize_t
name|xhs_offset
decl_stmt|;
comment|/* Saved xo_offset */
name|ssize_t
name|xhs_columns
decl_stmt|;
comment|/* Saved xo_columns */
name|ssize_t
name|xhs_anchor_columns
decl_stmt|;
comment|/* Saved xo_anchor_columns */
block|}
name|xo_humanize_save_t
typedef|;
end_typedef

begin_comment
comment|/*  * Format a "humanized" value for a numeric, meaning something nice  * like "44M" instead of "44470272".  We autoscale, choosing the  * most appropriate value for K/M/G/T/P/E based on the value given.  */
end_comment

begin_function
specifier|static
name|void
name|xo_format_humanize
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|xo_humanize_save_t
modifier|*
name|savep
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_HUMANIZE
argument_list|)
condition|)
return|return;
name|ssize_t
name|end_offset
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
if|if
condition|(
name|end_offset
operator|==
name|savep
operator|->
name|xhs_offset
condition|)
comment|/* Huh? Nothing to render */
return|return;
comment|/*      * We have a string that's allegedly a number. We want to      * humanize it, which means turning it back into a number      * and calling xo_humanize_number on it.      */
name|uint64_t
name|value
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NUL-terminate it */
name|value
operator|=
name|strtoull
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|savep
operator|->
name|xhs_offset
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|value
operator|==
name|ULLONG_MAX
operator|&&
name|errno
operator|==
name|ERANGE
operator|)
operator|&&
operator|(
name|ep
operator|!=
name|xbp
operator|->
name|xb_bufp
operator|+
name|savep
operator|->
name|xhs_offset
operator|)
condition|)
block|{
comment|/* 	 * There are few values where humanize_number needs 	 * more bytes than the original value.  I've used 	 * 10 as a rectal number to cover those scenarios. 	 */
if|if
condition|(
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|savep
operator|->
name|xhs_offset
expr_stmt|;
name|ssize_t
name|rc
decl_stmt|;
name|ssize_t
name|left
init|=
operator|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|xbp
operator|->
name|xb_size
operator|)
operator|-
name|xbp
operator|->
name|xb_curp
decl_stmt|;
name|int
name|hn_flags
init|=
name|HN_NOSPACE
decl_stmt|;
comment|/* On by default */
if|if
condition|(
name|flags
operator|&
name|XFF_HN_SPACE
condition|)
name|hn_flags
operator|&=
operator|~
name|HN_NOSPACE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_HN_DECIMAL
condition|)
name|hn_flags
operator||=
name|HN_DECIMAL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_HN_1000
condition|)
name|hn_flags
operator||=
name|HN_DIVISOR_1000
expr_stmt|;
name|rc
operator|=
name|xo_humanize
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|value
argument_list|,
name|hn_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
name|xop
operator|->
name|xo_columns
operator|=
name|savep
operator|->
name|xhs_columns
operator|+
name|rc
expr_stmt|;
name|xop
operator|->
name|xo_anchor_columns
operator|=
name|savep
operator|->
name|xhs_anchor_columns
operator|+
name|rc
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_buf_append_div
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|class
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ssize_t
name|nlen
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|ssize_t
name|vlen
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|ssize_t
name|elen
parameter_list|)
block|{
specifier|static
name|char
name|div_start
index|[]
init|=
literal|"<div class=\""
decl_stmt|;
specifier|static
name|char
name|div_tag
index|[]
init|=
literal|"\" data-tag=\""
decl_stmt|;
specifier|static
name|char
name|div_xpath
index|[]
init|=
literal|"\" data-xpath=\""
decl_stmt|;
specifier|static
name|char
name|div_key
index|[]
init|=
literal|"\" data-key=\"key"
decl_stmt|;
specifier|static
name|char
name|div_end
index|[]
init|=
literal|"\">"
decl_stmt|;
specifier|static
name|char
name|div_close
index|[]
init|=
literal|"</div>"
decl_stmt|;
comment|/* The encoding format defaults to the normal format */
if|if
condition|(
name|encoding
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|enc
init|=
name|alloca
argument_list|(
name|vlen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|enc
argument_list|,
name|value
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
name|enc
index|[
name|vlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|encoding
operator|=
name|xo_fix_encoding
argument_list|(
name|xop
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|elen
operator|=
name|strlen
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
block|}
comment|/*      * To build our XPath predicate, we need to save the va_list before      * we format our data, and then restore it before we format the      * xpath expression.      * Display-only keys implies that we've got an encode-only key      * elsewhere, so we don't use them from making predicates.      */
name|int
name|need_predidate
init|=
operator|(
name|name
operator|&&
operator|(
name|flags
operator|&
name|XFF_KEY
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|XFF_DISPLAY_ONLY
operator|)
operator|&&
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_XPATH
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|need_predidate
condition|)
block|{
name|va_list
name|va_local
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_checkpointer
condition|)
name|xop
operator|->
name|xo_checkpointer
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_vap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Build an XPath predicate expression to match this key. 	 * We use the format buffer. 	 */
name|xo_buffer_t
modifier|*
name|pbp
init|=
operator|&
name|xop
operator|->
name|xo_predicate
decl_stmt|;
name|pbp
operator|->
name|xb_curp
operator|=
name|pbp
operator|->
name|xb_bufp
expr_stmt|;
comment|/* Restart buffer */
name|xo_buf_append
argument_list|(
name|pbp
argument_list|,
literal|"["
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_buf_escape
argument_list|(
name|xop
argument_list|,
name|pbp
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_buf_append
argument_list|(
name|pbp
argument_list|,
literal|" = '"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|xo_buf_append
argument_list|(
name|pbp
argument_list|,
literal|"='"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xo_xff_flags_t
name|pflags
init|=
name|flags
operator||
name|XFF_XML
operator||
name|XFF_ATTR
decl_stmt|;
name|pflags
operator|&=
operator|~
operator|(
name|XFF_NO_OUTPUT
operator||
name|XFF_ENCODE_ONLY
operator|)
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|pbp
argument_list|,
name|encoding
argument_list|,
name|elen
argument_list|,
name|pflags
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|pbp
argument_list|,
literal|"']"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Now we record this predicate expression in the stack */
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
name|ssize_t
name|olen
init|=
name|xsp
operator|->
name|xs_keys
condition|?
name|strlen
argument_list|(
name|xsp
operator|->
name|xs_keys
argument_list|)
else|:
literal|0
decl_stmt|;
name|ssize_t
name|dlen
init|=
name|pbp
operator|->
name|xb_curp
operator|-
name|pbp
operator|->
name|xb_bufp
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|xo_realloc
argument_list|(
name|xsp
operator|->
name|xs_keys
argument_list|,
name|olen
operator|+
name|dlen
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|memcpy
argument_list|(
name|cp
operator|+
name|olen
argument_list|,
name|pbp
operator|->
name|xb_bufp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|cp
index|[
name|olen
operator|+
name|dlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xsp
operator|->
name|xs_keys
operator|=
name|cp
expr_stmt|;
block|}
comment|/* Now we reset the xo_vap as if we were never here */
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_checkpointer
condition|)
name|xop
operator|->
name|xo_checkpointer
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_vap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|XFF_ENCODE_ONLY
condition|)
block|{
comment|/* 	 * Even if this is encode-only, we need to go through the 	 * work of formatting it to make sure the args are cleared 	 * from xo_vap. 	 */
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|encoding
argument_list|,
name|elen
argument_list|,
name|flags
operator||
name|XFF_NO_OUTPUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|xo_line_ensure_open
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_indent_by
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_start
argument_list|,
sizeof|sizeof
argument_list|(
name|div_start
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|class
argument_list|,
name|strlen
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * If the color buffer has content, we add it now.  It's already      * prebuilt and ready, since we want to add it to every<div>.      */
if|if
condition|(
operator|!
name|xo_buf_is_empty
argument_list|(
operator|&
name|xop
operator|->
name|xo_color_buf
argument_list|)
condition|)
block|{
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_color_buf
decl_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xbp
operator|->
name|xb_bufp
argument_list|,
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|div_tag
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
comment|/* 	 * Save the offset at which we'd place units.  See xo_format_units. 	 */
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_UNITS
argument_list|)
condition|)
block|{
name|XOIF_SET
argument_list|(
name|xop
argument_list|,
name|XOIF_UNITS_PENDING
argument_list|)
expr_stmt|;
comment|/* 	     * Note: We need the '+1' here because we know we've not 	     * added the closing quote.  We add one, knowing the quote 	     * will be added shortly. 	     */
name|xop
operator|->
name|xo_units_offset
operator|=
name|xop
operator|->
name|xo_data
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_data
operator|.
name|xb_bufp
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_XPATH
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|xo_stack_t
modifier|*
name|xsp
decl_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_xpath
argument_list|,
sizeof|sizeof
argument_list|(
name|div_xpath
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_leading_xpath
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_leading_xpath
argument_list|,
name|strlen
argument_list|(
name|xop
operator|->
name|xo_leading_xpath
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|xop
operator|->
name|xo_depth
condition|;
name|i
operator|++
control|)
block|{
name|xsp
operator|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xsp
operator|->
name|xs_name
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * XSS_OPEN_LIST and XSS_OPEN_LEAF_LIST stack frames 		 * are directly under XSS_OPEN_INSTANCE frames so we 		 * don't need to put these in our XPath expressions. 		 */
if|if
condition|(
name|xsp
operator|->
name|xs_state
operator|==
name|XSS_OPEN_LIST
operator|||
name|xsp
operator|->
name|xs_state
operator|==
name|XSS_OPEN_LEAF_LIST
condition|)
continue|continue;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|xsp
operator|->
name|xs_name
argument_list|,
name|strlen
argument_list|(
name|xsp
operator|->
name|xs_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsp
operator|->
name|xs_keys
condition|)
block|{
comment|/* Don't show keys for the key field */
if|if
condition|(
name|i
operator|!=
name|xop
operator|->
name|xo_depth
operator|||
operator|!
operator|(
name|flags
operator|&
name|XFF_KEY
operator|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xsp
operator|->
name|xs_keys
argument_list|,
name|strlen
argument_list|(
name|xsp
operator|->
name|xs_keys
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_INFO
argument_list|)
operator|&&
name|xop
operator|->
name|xo_info
condition|)
block|{
specifier|static
name|char
name|in_type
index|[]
init|=
literal|"\" data-type=\""
decl_stmt|;
specifier|static
name|char
name|in_help
index|[]
init|=
literal|"\" data-help=\""
decl_stmt|;
name|xo_info_t
modifier|*
name|xip
init|=
name|xo_info_find
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|xip
condition|)
block|{
if|if
condition|(
name|xip
operator|->
name|xi_type
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|in_type
argument_list|,
sizeof|sizeof
argument_list|(
name|in_type
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|xip
operator|->
name|xi_type
argument_list|,
name|strlen
argument_list|(
name|xip
operator|->
name|xi_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xip
operator|->
name|xi_help
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|in_help
argument_list|,
sizeof|sizeof
argument_list|(
name|in_help
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|xip
operator|->
name|xi_help
argument_list|,
name|strlen
argument_list|(
name|xip
operator|->
name|xi_help
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_KEY
operator|)
operator|&&
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_KEYS
argument_list|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_key
argument_list|,
sizeof|sizeof
argument_list|(
name|div_key
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|ssize_t
name|base_offset
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_end
argument_list|,
sizeof|sizeof
argument_list|(
name|div_end
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_humanize_save_t
name|save
decl_stmt|;
comment|/* Save values for humanizing logic */
name|save
operator|.
name|xhs_offset
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
name|save
operator|.
name|xhs_columns
operator|=
name|xop
operator|->
name|xo_columns
expr_stmt|;
name|save
operator|.
name|xhs_anchor_columns
operator|=
name|xop
operator|->
name|xo_anchor_columns
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|value
argument_list|,
name|vlen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_HUMANIZE
condition|)
block|{
comment|/* 	 * Unlike text style, we want to retain the original value and 	 * stuff it into the "data-number" attribute. 	 */
specifier|static
specifier|const
name|char
name|div_number
index|[]
init|=
literal|"\" data-number=\""
decl_stmt|;
name|ssize_t
name|div_len
init|=
sizeof|sizeof
argument_list|(
name|div_number
argument_list|)
operator|-
literal|1
decl_stmt|;
name|ssize_t
name|end_offset
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|ssize_t
name|olen
init|=
name|end_offset
operator|-
name|save
operator|.
name|xhs_offset
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|olen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|save
operator|.
name|xhs_offset
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|cp
index|[
name|olen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xo_format_humanize
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
operator|&
name|save
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|div_len
operator|+
name|olen
argument_list|)
condition|)
block|{
name|ssize_t
name|new_offset
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
comment|/* Move the humanized string off to the left */
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|base_offset
operator|+
name|div_len
operator|+
name|olen
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|base_offset
argument_list|,
name|new_offset
operator|-
name|base_offset
argument_list|)
expr_stmt|;
comment|/* Copy the data_number attribute name */
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|base_offset
argument_list|,
name|div_number
argument_list|,
name|div_len
argument_list|)
expr_stmt|;
comment|/* Copy the original long value */
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|base_offset
operator|+
name|div_len
argument_list|,
name|cp
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|div_len
operator|+
name|olen
expr_stmt|;
block|}
block|}
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_close
argument_list|,
sizeof|sizeof
argument_list|(
name|div_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_text
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_TEXT
case|:
name|xo_buf_append_locale
argument_list|(
name|xop
argument_list|,
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
literal|"text"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_title
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|xfip
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|xfip
operator|->
name|xfi_format
decl_stmt|;
name|ssize_t
name|flen
init|=
name|xfip
operator|->
name|xfi_flen
decl_stmt|;
name|xo_xff_flags_t
name|flags
init|=
name|xfip
operator|->
name|xfi_flags
decl_stmt|;
specifier|static
name|char
name|div_open
index|[]
init|=
literal|"<div class=\"title"
decl_stmt|;
specifier|static
name|char
name|div_middle
index|[]
init|=
literal|"\">"
decl_stmt|;
specifier|static
name|char
name|div_close
index|[]
init|=
literal|"</div>"
decl_stmt|;
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
block|{
name|fmt
operator|=
literal|"%s"
expr_stmt|;
name|flen
operator|=
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
case|case
name|XO_STYLE_JSON
case|:
case|case
name|XO_STYLE_SDPARAMS
case|:
case|case
name|XO_STYLE_ENCODER
case|:
comment|/* 	 * Even though we don't care about text, we need to do 	 * enough parsing work to skip over the right bits of xo_vap. 	 */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|flags
operator||
name|XFF_NO_OUTPUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|ssize_t
name|start
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|ssize_t
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
name|start
decl_stmt|;
name|ssize_t
name|rc
decl_stmt|;
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_HTML
condition|)
block|{
name|xo_line_ensure_open
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_indent_by
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|div_open
argument_list|,
sizeof|sizeof
argument_list|(
name|div_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_color_append_html
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|div_middle
argument_list|,
sizeof|sizeof
argument_list|(
name|div_middle
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
comment|/* Reset start */
if|if
condition|(
name|len
condition|)
block|{
name|char
modifier|*
name|newfmt
init|=
name|alloca
argument_list|(
name|flen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newfmt
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|newfmt
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If len is non-zero, the format string apply to the name */
name|char
modifier|*
name|newstr
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newstr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|newstr
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|rc
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|newfmt
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
comment|/* 		 * We have to do this the hard way, since we might need 		 * the columns. 		 */
name|bp
operator|=
name|alloca
argument_list|(
name|rc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|snprintf
argument_list|(
name|bp
argument_list|,
name|rc
operator|+
literal|1
argument_list|,
name|newfmt
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
name|xo_data_append_content
argument_list|(
name|xop
argument_list|,
name|bp
argument_list|,
name|rc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
goto|goto
name|move_along
goto|;
block|}
else|else
block|{
name|rc
operator|=
name|snprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|newfmt
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
name|left
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
return|return;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
name|rc
operator|=
name|snprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|newfmt
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLUMNS
argument_list|)
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|rc
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|rc
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* xo_do_format_field moved curp, so we need to reset it */
name|rc
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
operator|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
operator|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
expr_stmt|;
block|}
comment|/* If we're styling HTML, then we need to escape it */
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_HTML
condition|)
block|{
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
name|move_along
label|:
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_HTML
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_close
argument_list|,
sizeof|sizeof
argument_list|(
name|div_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_prep
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFF_LEAF_LIST
operator|)
operator|&&
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Useful debugging function */
end_comment

begin_endif
unit|void xo_arg (xo_handle_t *xop); void xo_arg (xo_handle_t *xop) {     xop = xo_default(xop);     fprintf(stderr, "0x%x", va_arg(xop->xo_vap, unsigned)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|void
name|xo_format_value
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ssize_t
name|nlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|ssize_t
name|flen
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|ssize_t
name|elen
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
name|int
name|pretty
init|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
decl_stmt|;
name|int
name|quote
decl_stmt|;
comment|/*      * Before we emit a value, we need to know that the frame is ready.      */
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_LEAF_LIST
condition|)
block|{
comment|/* 	 * Check if we've already started to emit normal leafs 	 * or if we're not in a leaf list. 	 */
if|if
condition|(
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
operator|(
name|XSF_EMIT
operator||
name|XSF_EMIT_KEY
operator|)
operator|)
operator|||
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_EMIT_LEAF_LIST
operator|)
condition|)
block|{
name|char
name|nbuf
index|[
name|nlen
operator|+
literal|1
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|nbuf
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ssize_t
name|rc
init|=
name|xo_transition
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|nbuf
argument_list|,
name|XSS_EMIT_LEAF_LIST
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
name|flags
operator||=
name|XFF_DISPLAY_ONLY
operator||
name|XFF_ENCODE_ONLY
expr_stmt|;
else|else
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_EMIT_LEAF_LIST
expr_stmt|;
block|}
name|xsp
operator|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
expr_stmt|;
if|if
condition|(
name|xsp
operator|->
name|xs_name
condition|)
block|{
name|name
operator|=
name|xsp
operator|->
name|xs_name
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|XFF_KEY
condition|)
block|{
comment|/* Emitting a 'k' (key) field */
if|if
condition|(
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_EMIT
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|XFF_DISPLAY_ONLY
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"key field emitted after normal value field: '%.*s'"
argument_list|,
name|nlen
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_EMIT_KEY
operator|)
condition|)
block|{
name|char
name|nbuf
index|[
name|nlen
operator|+
literal|1
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|nbuf
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ssize_t
name|rc
init|=
name|xo_transition
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|nbuf
argument_list|,
name|XSS_EMIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
name|flags
operator||=
name|XFF_DISPLAY_ONLY
operator||
name|XFF_ENCODE_ONLY
expr_stmt|;
else|else
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_EMIT_KEY
expr_stmt|;
name|xsp
operator|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
expr_stmt|;
name|xsp
operator|->
name|xs_flags
operator||=
name|XSF_EMIT_KEY
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Emitting a normal value field */
if|if
condition|(
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_EMIT_LEAF_LIST
operator|)
operator|||
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_EMIT
operator|)
condition|)
block|{
name|char
name|nbuf
index|[
name|nlen
operator|+
literal|1
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|nbuf
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ssize_t
name|rc
init|=
name|xo_transition
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|nbuf
argument_list|,
name|XSS_EMIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
name|flags
operator||=
name|XFF_DISPLAY_ONLY
operator||
name|XFF_ENCODE_ONLY
expr_stmt|;
else|else
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_EMIT
expr_stmt|;
name|xsp
operator|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
expr_stmt|;
name|xsp
operator|->
name|xs_flags
operator||=
name|XSF_EMIT
expr_stmt|;
block|}
block|}
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|xo_humanize_save_t
name|save
decl_stmt|;
comment|/* Save values for humanizing logic */
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_TEXT
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_ENCODE_ONLY
condition|)
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|save
operator|.
name|xhs_offset
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
name|save
operator|.
name|xhs_columns
operator|=
name|xop
operator|->
name|xo_columns
expr_stmt|;
name|save
operator|.
name|xhs_anchor_columns
operator|=
name|xop
operator|->
name|xo_anchor_columns
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_HUMANIZE
condition|)
name|xo_format_humanize
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
operator|&
name|save
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_ENCODE_ONLY
condition|)
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
literal|"data"
argument_list|,
name|flags
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|encoding
argument_list|,
name|elen
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_XML
case|:
comment|/* 	 * Even though we're not making output, we still need to 	 * let the formatting code handle the va_arg popping. 	 */
if|if
condition|(
name|flags
operator|&
name|XFF_DISPLAY_ONLY
condition|)
block|{
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|encoding
condition|)
block|{
name|format
operator|=
name|encoding
expr_stmt|;
name|flen
operator|=
name|elen
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|enc
init|=
name|alloca
argument_list|(
name|flen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|enc
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|enc
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|format
operator|=
name|xo_fix_encoding
argument_list|(
name|xop
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
name|missing
index|[]
init|=
literal|"missing-field-name"
decl_stmt|;
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing field name: %s"
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|name
operator|=
name|missing
expr_stmt|;
name|nlen
operator|=
sizeof|sizeof
argument_list|(
name|missing
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pretty
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"<"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|!=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
argument_list|,
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
expr_stmt|;
block|}
comment|/* 	 * We indicate 'key' fields using the 'key' attribute.  While 	 * this is really committing the crime of mixing meta-data with 	 * data, it's often useful.  Especially when format meta-data is 	 * difficult to come by. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_KEY
operator|)
operator|&&
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_KEYS
argument_list|)
condition|)
block|{
specifier|static
name|char
name|attr
index|[]
init|=
literal|" key=\"key\""
decl_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|attr
argument_list|,
sizeof|sizeof
argument_list|(
name|attr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save the offset at which we'd place units.  See xo_format_units. 	 */
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_UNITS
argument_list|)
condition|)
block|{
name|XOIF_SET
argument_list|(
name|xop
argument_list|,
name|XOIF_UNITS_PENDING
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_units_offset
operator|=
name|xop
operator|->
name|xo_data
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_data
operator|.
name|xb_bufp
expr_stmt|;
block|}
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|">"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"</"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|">"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_DISPLAY_ONLY
condition|)
block|{
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|encoding
condition|)
block|{
name|format
operator|=
name|encoding
expr_stmt|;
name|flen
operator|=
name|elen
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|enc
init|=
name|alloca
argument_list|(
name|flen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|enc
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|enc
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|format
operator|=
name|xo_fix_encoding
argument_list|(
name|xop
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
name|int
name|first
init|=
operator|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|xo_format_prep
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_QUOTE
condition|)
name|quote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|XFF_NOQUOTE
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
block|{
name|quote
operator|=
literal|0
expr_stmt|;
name|format
operator|=
literal|"true"
expr_stmt|;
comment|/* JSON encodes empty tags as a boolean true */
name|flen
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"diouDOUeEfFgG"
argument_list|,
name|format
index|[
name|flen
operator|-
literal|1
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|quote
operator|=
literal|1
expr_stmt|;
else|else
name|quote
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
name|missing
index|[]
init|=
literal|"missing-field-name"
decl_stmt|;
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing field name: %s"
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|name
operator|=
name|missing
expr_stmt|;
name|nlen
operator|=
sizeof|sizeof
argument_list|(
name|missing
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|XFF_LEAF_LIST
condition|)
block|{
if|if
condition|(
operator|!
name|first
operator|&&
name|pretty
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pretty
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xbp
operator|=
operator|&
name|xop
operator|->
name|xo_data
expr_stmt|;
name|ssize_t
name|off
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_UNDERSCORES
argument_list|)
condition|)
block|{
name|ssize_t
name|coff
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
for|for
control|(
init|;
name|off
operator|<
name|coff
condition|;
name|off
operator|++
control|)
if|if
condition|(
name|xbp
operator|->
name|xb_bufp
index|[
name|off
index|]
operator|==
literal|'-'
condition|)
name|xbp
operator|->
name|xb_bufp
index|[
name|off
index|]
operator|=
literal|'_'
expr_stmt|;
block|}
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\":"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quote
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_SDPARAMS
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_DISPLAY_ONLY
condition|)
block|{
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|encoding
condition|)
block|{
name|format
operator|=
name|encoding
expr_stmt|;
name|flen
operator|=
name|elen
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|enc
init|=
name|alloca
argument_list|(
name|flen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|enc
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|enc
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|format
operator|=
name|xo_fix_encoding
argument_list|(
name|xop
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
name|missing
index|[]
init|=
literal|"missing-field-name"
decl_stmt|;
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing field name: %s"
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|name
operator|=
name|missing
expr_stmt|;
name|nlen
operator|=
sizeof|sizeof
argument_list|(
name|missing
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"=\""
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\" "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_DISPLAY_ONLY
condition|)
block|{
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|XFF_QUOTE
condition|)
name|quote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|XFF_NOQUOTE
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
block|{
name|quote
operator|=
literal|0
expr_stmt|;
name|format
operator|=
literal|"true"
expr_stmt|;
comment|/* JSON encodes empty tags as a boolean true */
name|flen
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"diouxXDOUeEfFgGaAcCp"
argument_list|,
name|format
index|[
name|flen
operator|-
literal|1
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|quote
operator|=
literal|1
expr_stmt|;
else|else
name|quote
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|encoding
condition|)
block|{
name|format
operator|=
name|encoding
expr_stmt|;
name|flen
operator|=
name|elen
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|enc
init|=
name|alloca
argument_list|(
name|flen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|enc
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|enc
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|format
operator|=
name|xo_fix_encoding
argument_list|(
name|xop
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
name|missing
index|[]
init|=
literal|"missing-field-name"
decl_stmt|;
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing field name: %s"
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|name
operator|=
name|missing
expr_stmt|;
name|nlen
operator|=
sizeof|sizeof
argument_list|(
name|missing
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|ssize_t
name|name_offset
init|=
name|xo_buf_offset
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
decl_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ssize_t
name|value_offset
init|=
name|xo_buf_offset
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
decl_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|quote
condition|?
name|XO_OP_STRING
else|:
name|XO_OP_CONTENT
argument_list|,
name|xo_buf_data
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|name_offset
argument_list|)
argument_list|,
name|xo_buf_data
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|value_offset
argument_list|)
argument_list|)
expr_stmt|;
name|xo_buf_reset
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_set_gettext_domain
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|xfip
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|xfip
operator|->
name|xfi_format
decl_stmt|;
name|ssize_t
name|flen
init|=
name|xfip
operator|->
name|xfi_flen
decl_stmt|;
comment|/* Start by discarding previous domain */
if|if
condition|(
name|xop
operator|->
name|xo_gt_domain
condition|)
block|{
name|xo_free
argument_list|(
name|xop
operator|->
name|xo_gt_domain
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_gt_domain
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* An empty {G:} means no domainname */
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|flen
operator|==
literal|0
condition|)
return|return;
name|ssize_t
name|start_offset
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|flen
operator|!=
literal|0
condition|)
block|{
comment|/* Need to do format the data to get the domainname from args */
name|start_offset
operator|=
name|xop
operator|->
name|xo_data
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_data
operator|.
name|xb_bufp
expr_stmt|;
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ssize_t
name|end_offset
init|=
name|xop
operator|->
name|xo_data
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_data
operator|.
name|xb_bufp
decl_stmt|;
name|len
operator|=
name|end_offset
operator|-
name|start_offset
expr_stmt|;
name|str
operator|=
name|xop
operator|->
name|xo_data
operator|.
name|xb_bufp
operator|+
name|start_offset
expr_stmt|;
block|}
name|xop
operator|->
name|xo_gt_domain
operator|=
name|xo_strndup
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Reset the current buffer point to avoid emitting the name as output */
if|if
condition|(
name|start_offset
operator|>=
literal|0
condition|)
name|xop
operator|->
name|xo_data
operator|.
name|xb_curp
operator|=
name|xop
operator|->
name|xo_data
operator|.
name|xb_bufp
operator|+
name|start_offset
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_content
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|class_name
parameter_list|,
specifier|const
name|char
modifier|*
name|tag_name
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|ssize_t
name|flen
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_TEXT
case|:
if|if
condition|(
name|len
condition|)
name|xo_data_append_content
argument_list|(
name|xop
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|fmt
expr_stmt|;
name|len
operator|=
name|flen
expr_stmt|;
block|}
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
name|class_name
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_XML
case|:
case|case
name|XO_STYLE_JSON
case|:
case|case
name|XO_STYLE_SDPARAMS
case|:
if|if
condition|(
name|tag_name
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|fmt
expr_stmt|;
name|len
operator|=
name|flen
expr_stmt|;
block|}
name|xo_open_container_h
argument_list|(
name|xop
argument_list|,
name|tag_name
argument_list|)
expr_stmt|;
name|xo_format_value
argument_list|(
name|xop
argument_list|,
literal|"message"
argument_list|,
literal|7
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xo_close_container_h
argument_list|(
name|xop
argument_list|,
name|tag_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Even though we don't care about labels, we need to do 	     * enough parsing work to skip over the right bits of xo_vap. 	     */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|flags
operator||
name|XFF_NO_OUTPUT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|flags
operator||
name|XFF_NO_OUTPUT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|xo_color_names
index|[]
init|=
block|{
literal|"default"
block|,
comment|/* XO_COL_DEFAULT */
literal|"black"
block|,
comment|/* XO_COL_BLACK */
literal|"red"
block|,
comment|/* XO_CLOR_RED */
literal|"green"
block|,
comment|/* XO_COL_GREEN */
literal|"yellow"
block|,
comment|/* XO_COL_YELLOW */
literal|"blue"
block|,
comment|/* XO_COL_BLUE */
literal|"magenta"
block|,
comment|/* XO_COL_MAGENTA */
literal|"cyan"
block|,
comment|/* XO_COL_CYAN */
literal|"white"
block|,
comment|/* XO_COL_WHITE */
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|xo_color_find
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xo_color_names
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|xo_color_names
index|[
name|i
index|]
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|xo_effect_names
index|[]
init|=
block|{
literal|"reset"
block|,
comment|/* XO_EFF_RESET */
literal|"normal"
block|,
comment|/* XO_EFF_NORMAL */
literal|"bold"
block|,
comment|/* XO_EFF_BOLD */
literal|"underline"
block|,
comment|/* XO_EFF_UNDERLINE */
literal|"inverse"
block|,
comment|/* XO_EFF_INVERSE */
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|xo_effect_on_codes
index|[]
init|=
block|{
literal|"0"
block|,
comment|/* XO_EFF_RESET */
literal|"0"
block|,
comment|/* XO_EFF_NORMAL */
literal|"1"
block|,
comment|/* XO_EFF_BOLD */
literal|"4"
block|,
comment|/* XO_EFF_UNDERLINE */
literal|"7"
block|,
comment|/* XO_EFF_INVERSE */
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * See comment below re: joy of terminal standards.  These can  * be use by just adding:  * +	if (newp->xoc_effects& bit)  *	    code = xo_effect_on_codes[i];  * +	else  * +	    code = xo_effect_off_codes[i];  * in xo_color_handle_text.  */
end_comment

begin_comment
unit|static const char *xo_effect_off_codes[] = {     "0",
comment|/* XO_EFF_RESET */
end_comment

begin_comment
unit|"0",
comment|/* XO_EFF_NORMAL */
end_comment

begin_comment
unit|"21",
comment|/* XO_EFF_BOLD */
end_comment

begin_comment
unit|"24",
comment|/* XO_EFF_UNDERLINE */
end_comment

begin_comment
unit|"27",
comment|/* XO_EFF_INVERSE */
end_comment

begin_endif
unit|NULL };
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|int
name|xo_effect_find
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|xo_effect_names
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|xo_effect_names
index|[
name|i
index|]
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_colors_parse
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_colors_t
modifier|*
name|xocp
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|LIBXO_TEXT_ONLY
return|return;
endif|#
directive|endif
comment|/* LIBXO_TEXT_ONLY */
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|np
decl_stmt|,
modifier|*
name|xp
decl_stmt|;
name|ssize_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/*      * Possible tokens: colors, bg-colors, effects, no-effects, "reset".      */
for|for
control|(
name|cp
operator|=
name|str
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
operator|-
literal|1
init|;
name|cp
operator|&&
name|cp
operator|<
name|ep
condition|;
name|cp
operator|=
name|np
control|)
block|{
comment|/* Trim leading whitespace */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|+=
literal|1
expr_stmt|;
name|np
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
operator|*
name|np
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Trim trailing whitespace */
name|xp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|xp
argument_list|)
operator|&&
name|xp
operator|>
name|cp
condition|)
operator|*
name|xp
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'g'
operator|&&
name|cp
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
block|{
name|rc
operator|=
name|xo_color_find
argument_list|(
name|cp
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
goto|goto
name|unknown
goto|;
name|xocp
operator|->
name|xoc_col_fg
operator|=
name|rc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'b'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'g'
operator|&&
name|cp
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
block|{
name|rc
operator|=
name|xo_color_find
argument_list|(
name|cp
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
goto|goto
name|unknown
goto|;
name|xocp
operator|->
name|xoc_col_bg
operator|=
name|rc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|cp
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
block|{
name|rc
operator|=
name|xo_effect_find
argument_list|(
name|cp
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
goto|goto
name|unknown
goto|;
name|xocp
operator|->
name|xoc_effects
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|rc
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|xo_effect_find
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
goto|goto
name|unknown
goto|;
name|xocp
operator|->
name|xoc_effects
operator||=
literal|1
operator|<<
name|rc
expr_stmt|;
switch|switch
condition|(
literal|1
operator|<<
name|rc
condition|)
block|{
case|case
name|XO_EFF_RESET
case|:
name|xocp
operator|->
name|xoc_col_fg
operator|=
name|xocp
operator|->
name|xoc_col_bg
operator|=
literal|0
expr_stmt|;
comment|/* Note: not "|=" since we want to wipe out the old value */
name|xocp
operator|->
name|xoc_effects
operator|=
name|XO_EFF_RESET
expr_stmt|;
break|break;
case|case
name|XO_EFF_NORMAL
case|:
name|xocp
operator|->
name|xoc_effects
operator|&=
operator|~
operator|(
name|XO_EFF_BOLD
operator||
name|XO_EFF_UNDERLINE
operator||
name|XO_EFF_INVERSE
operator||
name|XO_EFF_NORMAL
operator|)
expr_stmt|;
break|break;
block|}
block|}
continue|continue;
name|unknown
label|:
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_WARN
argument_list|)
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"unknown color/effect string detected: '%s'"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|xo_colors_enabled
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|LIBXO_TEXT_ONLY
return|return
literal|0
return|;
else|#
directive|else
comment|/* LIBXO_TEXT_ONLY */
return|return
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_COLOR
argument_list|)
return|;
endif|#
directive|endif
comment|/* LIBXO_TEXT_ONLY */
block|}
end_function

begin_function
specifier|static
name|void
name|xo_colors_handle_text
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_colors_t
modifier|*
name|newp
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|,
modifier|*
name|ep
init|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|bit
decl_stmt|;
name|xo_colors_t
modifier|*
name|oldp
init|=
operator|&
name|xop
operator|->
name|xo_colors
decl_stmt|;
specifier|const
name|char
modifier|*
name|code
init|=
name|NULL
decl_stmt|;
comment|/*      * Start the buffer with an escape.  We don't want to add the '['      * now, since we let xo_effect_text_add unconditionally add the ';'.      * We'll replace the first ';' with a '[' when we're done.      */
operator|*
name|cp
operator|++
operator|=
literal|0x1b
expr_stmt|;
comment|/* Escape */
comment|/*      * Terminals were designed back in the age before "certainty" was      * invented, when standards were more what you'd call "guidelines"      * than actual rules.  Anyway we can't depend on them to operate      * correctly.  So when display attributes are changed, we punt,      * reseting them all and turning back on the ones we want to keep.      * Longer, but should be completely reliable.  Savvy?      */
if|if
condition|(
name|oldp
operator|->
name|xoc_effects
operator|!=
operator|(
name|newp
operator|->
name|xoc_effects
operator|&
name|oldp
operator|->
name|xoc_effects
operator|)
condition|)
block|{
name|newp
operator|->
name|xoc_effects
operator||=
name|XO_EFF_RESET
expr_stmt|;
name|oldp
operator|->
name|xoc_effects
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit
operator|=
literal|1
init|;
name|xo_effect_names
index|[
name|i
index|]
condition|;
name|i
operator|++
operator|,
name|bit
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|newp
operator|->
name|xoc_effects
operator|&
name|bit
operator|)
operator|==
operator|(
name|oldp
operator|->
name|xoc_effects
operator|&
name|bit
operator|)
condition|)
continue|continue;
name|code
operator|=
name|xo_effect_on_codes
index|[
name|i
index|]
expr_stmt|;
name|cp
operator|+=
name|snprintf
argument_list|(
name|cp
argument_list|,
name|ep
operator|-
name|cp
argument_list|,
literal|";%s"
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
name|ep
condition|)
return|return;
comment|/* Should not occur */
if|if
condition|(
name|bit
operator|==
name|XO_EFF_RESET
condition|)
block|{
comment|/* Mark up the old value so we can detect current values as new */
name|oldp
operator|->
name|xoc_effects
operator|=
literal|0
expr_stmt|;
name|oldp
operator|->
name|xoc_col_fg
operator|=
name|oldp
operator|->
name|xoc_col_bg
operator|=
name|XO_COL_DEFAULT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newp
operator|->
name|xoc_col_fg
operator|!=
name|oldp
operator|->
name|xoc_col_fg
condition|)
block|{
name|cp
operator|+=
name|snprintf
argument_list|(
name|cp
argument_list|,
name|ep
operator|-
name|cp
argument_list|,
literal|";3%u"
argument_list|,
operator|(
name|newp
operator|->
name|xoc_col_fg
operator|!=
name|XO_COL_DEFAULT
operator|)
condition|?
name|newp
operator|->
name|xoc_col_fg
operator|-
literal|1
else|:
literal|9
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newp
operator|->
name|xoc_col_bg
operator|!=
name|oldp
operator|->
name|xoc_col_bg
condition|)
block|{
name|cp
operator|+=
name|snprintf
argument_list|(
name|cp
argument_list|,
name|ep
operator|-
name|cp
argument_list|,
literal|";4%u"
argument_list|,
operator|(
name|newp
operator|->
name|xoc_col_bg
operator|!=
name|XO_COL_DEFAULT
operator|)
condition|?
name|newp
operator|->
name|xoc_col_bg
operator|-
literal|1
else|:
literal|9
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|-
name|buf
operator|!=
literal|1
operator|&&
name|cp
operator|<
name|ep
operator|-
literal|3
condition|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
literal|'['
expr_stmt|;
comment|/* Overwrite leading ';' */
operator|*
name|cp
operator|++
operator|=
literal|'m'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|xo_buf_append
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|buf
argument_list|,
name|cp
operator|-
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_colors_handle_html
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_colors_t
modifier|*
name|newp
parameter_list|)
block|{
name|xo_colors_t
modifier|*
name|oldp
init|=
operator|&
name|xop
operator|->
name|xo_colors
decl_stmt|;
comment|/*      * HTML colors are mostly trivial: fill in xo_color_buf with      * a set of class tags representing the colors and effects.      */
comment|/* If nothing changed, then do nothing */
if|if
condition|(
name|oldp
operator|->
name|xoc_effects
operator|==
name|newp
operator|->
name|xoc_effects
operator|&&
name|oldp
operator|->
name|xoc_col_fg
operator|==
name|newp
operator|->
name|xoc_col_fg
operator|&&
name|oldp
operator|->
name|xoc_col_bg
operator|==
name|newp
operator|->
name|xoc_col_bg
condition|)
return|return;
name|unsigned
name|i
decl_stmt|,
name|bit
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_color_buf
decl_stmt|;
name|xo_buf_reset
argument_list|(
name|xbp
argument_list|)
expr_stmt|;
comment|/* We rebuild content after each change */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit
operator|=
literal|1
init|;
name|xo_effect_names
index|[
name|i
index|]
condition|;
name|i
operator|++
operator|,
name|bit
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|newp
operator|->
name|xoc_effects
operator|&
name|bit
operator|)
condition|)
continue|continue;
name|xo_buf_append_str
argument_list|(
name|xbp
argument_list|,
literal|" effect-"
argument_list|)
expr_stmt|;
name|xo_buf_append_str
argument_list|(
name|xbp
argument_list|,
name|xo_effect_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
specifier|const
name|char
modifier|*
name|fg
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|bg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|newp
operator|->
name|xoc_col_fg
operator|!=
name|XO_COL_DEFAULT
condition|)
name|fg
operator|=
name|xo_color_names
index|[
name|newp
operator|->
name|xoc_col_fg
index|]
expr_stmt|;
if|if
condition|(
name|newp
operator|->
name|xoc_col_bg
operator|!=
name|XO_COL_DEFAULT
condition|)
name|bg
operator|=
name|xo_color_names
index|[
name|newp
operator|->
name|xoc_col_bg
index|]
expr_stmt|;
if|if
condition|(
name|newp
operator|->
name|xoc_effects
operator|&
name|XO_EFF_INVERSE
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp
init|=
name|fg
decl_stmt|;
name|fg
operator|=
name|bg
expr_stmt|;
name|bg
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|fg
operator|==
name|NULL
condition|)
name|fg
operator|=
literal|"inverse"
expr_stmt|;
if|if
condition|(
name|bg
operator|==
name|NULL
condition|)
name|bg
operator|=
literal|"inverse"
expr_stmt|;
block|}
if|if
condition|(
name|fg
condition|)
block|{
name|xo_buf_append_str
argument_list|(
name|xbp
argument_list|,
literal|" color-fg-"
argument_list|)
expr_stmt|;
name|xo_buf_append_str
argument_list|(
name|xbp
argument_list|,
name|fg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bg
condition|)
block|{
name|xo_buf_append_str
argument_list|(
name|xbp
argument_list|,
literal|" color-bg-"
argument_list|)
expr_stmt|;
name|xo_buf_append_str
argument_list|(
name|xbp
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_colors
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|xfip
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|xfip
operator|->
name|xfi_format
decl_stmt|;
name|ssize_t
name|flen
init|=
name|xfip
operator|->
name|xfi_flen
decl_stmt|;
name|xo_buffer_t
name|xb
decl_stmt|;
comment|/* If the string is static and we've in an encoding style, bail */
if|if
condition|(
name|len
operator|!=
literal|0
operator|&&
name|xo_style_is_encoding
argument_list|(
name|xop
argument_list|)
condition|)
return|return;
name|xo_buf_init
argument_list|(
operator|&
name|xb
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|xo_buf_append
argument_list|(
operator|&
name|xb
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flen
condition|)
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
operator|&
name|xb
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|xo_buf_append
argument_list|(
operator|&
name|xb
argument_list|,
literal|"reset"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Default if empty */
if|if
condition|(
name|xo_colors_enabled
argument_list|(
name|xop
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_TEXT
case|:
case|case
name|XO_STYLE_HTML
case|:
name|xo_buf_append
argument_list|(
operator|&
name|xb
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_colors_t
name|xoc
init|=
name|xop
operator|->
name|xo_colors
decl_stmt|;
name|xo_colors_parse
argument_list|(
name|xop
argument_list|,
operator|&
name|xoc
argument_list|,
name|xb
operator|.
name|xb_bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_TEXT
condition|)
block|{
comment|/* 		 * Text mode means emitting the colors as ANSI character 		 * codes.  This will allow people who like colors to have 		 * colors.  The issue is, of course conflicting with the 		 * user's perfectly reasonable color scheme.  Which leads 		 * to the hell of LSCOLORS, where even app need to have 		 * customization hooks for adjusting colors.  Instead we 		 * provide a simpler-but-still-annoying answer where one 		 * can map colors to other colors. 		 */
name|xo_colors_handle_text
argument_list|(
name|xop
argument_list|,
operator|&
name|xoc
argument_list|)
expr_stmt|;
name|xoc
operator|.
name|xoc_effects
operator|&=
operator|~
name|XO_EFF_RESET
expr_stmt|;
comment|/* After handling it */
block|}
else|else
block|{
comment|/* 		 * HTML output is wrapped in divs, so the color information 		 * must appear in every div until cleared.  Most pathetic. 		 * Most unavoidable. 		 */
name|xoc
operator|.
name|xoc_effects
operator|&=
operator|~
name|XO_EFF_RESET
expr_stmt|;
comment|/* Before handling effects */
name|xo_colors_handle_html
argument_list|(
name|xop
argument_list|,
operator|&
name|xoc
argument_list|)
expr_stmt|;
block|}
name|xop
operator|->
name|xo_colors
operator|=
name|xoc
expr_stmt|;
break|break;
case|case
name|XO_STYLE_XML
case|:
case|case
name|XO_STYLE_JSON
case|:
case|case
name|XO_STYLE_SDPARAMS
case|:
case|case
name|XO_STYLE_ENCODER
case|:
comment|/* 	     * Nothing to do; we did all that work just to clear the stack of 	     * formatting arguments. 	     */
break|break;
block|}
block|}
name|xo_buf_cleanup
argument_list|(
operator|&
name|xb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_units
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|xfip
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|xfip
operator|->
name|xfi_format
decl_stmt|;
name|ssize_t
name|flen
init|=
name|xfip
operator|->
name|xfi_flen
decl_stmt|;
name|xo_xff_flags_t
name|flags
init|=
name|xfip
operator|->
name|xfi_flags
decl_stmt|;
specifier|static
name|char
name|units_start_xml
index|[]
init|=
literal|" units=\""
decl_stmt|;
specifier|static
name|char
name|units_start_html
index|[]
init|=
literal|" data-units=\""
decl_stmt|;
if|if
condition|(
operator|!
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_UNITS_PENDING
argument_list|)
condition|)
block|{
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"units"
argument_list|,
name|NULL
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|ssize_t
name|start
init|=
name|xop
operator|->
name|xo_units_offset
decl_stmt|;
name|ssize_t
name|stop
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_XML
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|units_start_xml
argument_list|,
sizeof|sizeof
argument_list|(
name|units_start_xml
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_HTML
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|units_start_html
argument_list|,
sizeof|sizeof
argument_list|(
name|units_start_html
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|len
condition|)
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|xo_do_format_field
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ssize_t
name|now
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|ssize_t
name|delta
init|=
name|now
operator|-
name|stop
decl_stmt|;
if|if
condition|(
name|delta
operator|<=
literal|0
condition|)
block|{
comment|/* Strange; no output to move */
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|stop
expr_stmt|;
comment|/* Reset buffer to prior state */
return|return;
block|}
comment|/*      * Now we're in it alright.  We've need to insert the unit value      * we just created into the right spot.  We make a local copy,      * move it and then insert our copy.  We know there's room in the      * buffer, since we're just moving this around.      */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|delta
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|stop
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
operator|+
name|delta
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
argument_list|,
name|stop
operator|-
name|start
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
argument_list|,
name|buf
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_find_width
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|xfip
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|xfip
operator|->
name|xfi_format
decl_stmt|;
name|ssize_t
name|flen
init|=
name|xfip
operator|->
name|xfi_flen
decl_stmt|;
name|long
name|width
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|bp
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Make local NUL-terminated copy of str */
name|memcpy
argument_list|(
name|bp
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|width
operator|=
name|strtol
argument_list|(
name|bp
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
name|LONG_MIN
operator|||
name|width
operator|==
name|LONG_MAX
operator|||
name|bp
operator|==
name|cp
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|width
operator|=
literal|0
expr_stmt|;
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid width for anchor: '%s'"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flen
condition|)
block|{
if|if
condition|(
name|flen
operator|!=
literal|2
operator|||
name|strncmp
argument_list|(
literal|"%d"
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|)
operator|!=
literal|0
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid width format: '%*.*s'"
argument_list|,
name|flen
argument_list|,
name|flen
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_VA_ARG
argument_list|)
condition|)
name|width
operator|=
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_anchor_clear
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|XOIF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_anchor_offset
operator|=
literal|0
expr_stmt|;
name|xop
operator|->
name|xo_anchor_columns
operator|=
literal|0
expr_stmt|;
name|xop
operator|->
name|xo_anchor_min_width
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * An anchor is a marker used to delay field width implications.  * Imagine the format string "{[:10}{min:%d}/{cur:%d}/{max:%d}{:]}".  * We are looking for output like "     1/4/5"  *  * To make this work, we record the anchor and then return to  * format it when the end anchor tag is seen.  */
end_comment

begin_function
specifier|static
name|void
name|xo_anchor_start
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|xfip
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|!=
name|XO_STYLE_TEXT
operator|&&
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|!=
name|XO_STYLE_HTML
condition|)
return|return;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"the anchor already recording is discarded"
argument_list|)
expr_stmt|;
name|XOIF_SET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
expr_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|xop
operator|->
name|xo_anchor_offset
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
name|xop
operator|->
name|xo_anchor_columns
operator|=
literal|0
expr_stmt|;
comment|/*      * Now we find the width, if possible.  If it's not there,      * we'll get it on the end anchor.      */
name|xop
operator|->
name|xo_anchor_min_width
operator|=
name|xo_find_width
argument_list|(
name|xop
argument_list|,
name|xfip
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_anchor_stop
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|xfip
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|!=
name|XO_STYLE_TEXT
operator|&&
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|!=
name|XO_STYLE_HTML
condition|)
return|return;
if|if
condition|(
operator|!
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"no start anchor"
argument_list|)
expr_stmt|;
return|return;
block|}
name|XOIF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOIF_UNITS_PENDING
argument_list|)
expr_stmt|;
name|ssize_t
name|width
init|=
name|xo_find_width
argument_list|(
name|xop
argument_list|,
name|xfip
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
name|xop
operator|->
name|xo_anchor_min_width
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
comment|/* No width given; nothing to do */
goto|goto
name|done
goto|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|ssize_t
name|start
init|=
name|xop
operator|->
name|xo_anchor_offset
decl_stmt|;
name|ssize_t
name|stop
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|ssize_t
name|abswidth
init|=
operator|(
name|width
operator|>
literal|0
operator|)
condition|?
name|width
else|:
operator|-
name|width
decl_stmt|;
name|ssize_t
name|blen
init|=
name|abswidth
operator|-
name|xop
operator|->
name|xo_anchor_columns
decl_stmt|;
if|if
condition|(
name|blen
operator|<=
literal|0
condition|)
comment|/* Already over width */
goto|goto
name|done
goto|;
if|if
condition|(
name|abswidth
operator|>
name|XO_MAX_ANCHOR_WIDTH
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"width over %u are not supported"
argument_list|,
name|XO_MAX_ANCHOR_WIDTH
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Make a suitable padding field and emit it */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|blen
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"padding"
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|blen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
comment|/* Already left justified */
goto|goto
name|done
goto|;
name|ssize_t
name|now
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|ssize_t
name|delta
init|=
name|now
operator|-
name|stop
decl_stmt|;
if|if
condition|(
name|delta
operator|<=
literal|0
condition|)
comment|/* Strange; no output to move */
goto|goto
name|done
goto|;
comment|/*      * Now we're in it alright.  We've need to insert the padding data      * we just created (which might be an HTML<div> or text) before      * the formatted data.  We make a local copy, move it and then      * insert our copy.  We know there's room in the buffer, since      * we're just moving this around.      */
if|if
condition|(
name|delta
operator|>
name|blen
condition|)
name|buf
operator|=
name|alloca
argument_list|(
name|delta
argument_list|)
expr_stmt|;
comment|/* Expand buffer if needed */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|stop
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
operator|+
name|delta
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
argument_list|,
name|stop
operator|-
name|start
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
argument_list|,
name|buf
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|done
label|:
name|xo_anchor_clear
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xo_class_name
parameter_list|(
name|int
name|ftype
parameter_list|)
block|{
switch|switch
condition|(
name|ftype
condition|)
block|{
case|case
literal|'D'
case|:
return|return
literal|"decoration"
return|;
case|case
literal|'E'
case|:
return|return
literal|"error"
return|;
case|case
literal|'L'
case|:
return|return
literal|"label"
return|;
case|case
literal|'N'
case|:
return|return
literal|"note"
return|;
case|case
literal|'P'
case|:
return|return
literal|"padding"
return|;
case|case
literal|'W'
case|:
return|return
literal|"warning"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xo_tag_name
parameter_list|(
name|int
name|ftype
parameter_list|)
block|{
switch|switch
condition|(
name|ftype
condition|)
block|{
case|case
literal|'E'
case|:
return|return
literal|"__error"
return|;
case|case
literal|'W'
case|:
return|return
literal|"__warning"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_role_wants_default_format
parameter_list|(
name|int
name|ftype
parameter_list|)
block|{
switch|switch
condition|(
name|ftype
condition|)
block|{
comment|/* These roles can be completely empty and/or without formatting */
case|case
literal|'C'
case|:
case|case
literal|'G'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|xo_mapping_t
name|xo_role_names
index|[]
init|=
block|{
block|{
literal|'C'
block|,
literal|"color"
block|}
block|,
block|{
literal|'D'
block|,
literal|"decoration"
block|}
block|,
block|{
literal|'E'
block|,
literal|"error"
block|}
block|,
block|{
literal|'L'
block|,
literal|"label"
block|}
block|,
block|{
literal|'N'
block|,
literal|"note"
block|}
block|,
block|{
literal|'P'
block|,
literal|"padding"
block|}
block|,
block|{
literal|'T'
block|,
literal|"title"
block|}
block|,
block|{
literal|'U'
block|,
literal|"units"
block|}
block|,
block|{
literal|'V'
block|,
literal|"value"
block|}
block|,
block|{
literal|'W'
block|,
literal|"warning"
block|}
block|,
block|{
literal|'['
block|,
literal|"start-anchor"
block|}
block|,
block|{
literal|']'
block|,
literal|"stop-anchor"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|XO_ROLE_EBRACE
value|'{'
end_define

begin_comment
comment|/* Escaped braces */
end_comment

begin_define
define|#
directive|define
name|XO_ROLE_TEXT
value|'+'
end_define

begin_define
define|#
directive|define
name|XO_ROLE_NEWLINE
value|'\n'
end_define

begin_decl_stmt
specifier|static
name|xo_mapping_t
name|xo_modifier_names
index|[]
init|=
block|{
block|{
name|XFF_ARGUMENT
block|,
literal|"argument"
block|}
block|,
block|{
name|XFF_COLON
block|,
literal|"colon"
block|}
block|,
block|{
name|XFF_COMMA
block|,
literal|"comma"
block|}
block|,
block|{
name|XFF_DISPLAY_ONLY
block|,
literal|"display"
block|}
block|,
block|{
name|XFF_ENCODE_ONLY
block|,
literal|"encoding"
block|}
block|,
block|{
name|XFF_GT_FIELD
block|,
literal|"gettext"
block|}
block|,
block|{
name|XFF_HUMANIZE
block|,
literal|"humanize"
block|}
block|,
block|{
name|XFF_HUMANIZE
block|,
literal|"hn"
block|}
block|,
block|{
name|XFF_HN_SPACE
block|,
literal|"hn-space"
block|}
block|,
block|{
name|XFF_HN_DECIMAL
block|,
literal|"hn-decimal"
block|}
block|,
block|{
name|XFF_HN_1000
block|,
literal|"hn-1000"
block|}
block|,
block|{
name|XFF_KEY
block|,
literal|"key"
block|}
block|,
block|{
name|XFF_LEAF_LIST
block|,
literal|"leaf-list"
block|}
block|,
block|{
name|XFF_LEAF_LIST
block|,
literal|"list"
block|}
block|,
block|{
name|XFF_NOQUOTE
block|,
literal|"no-quotes"
block|}
block|,
block|{
name|XFF_NOQUOTE
block|,
literal|"no-quote"
block|}
block|,
block|{
name|XFF_GT_PLURAL
block|,
literal|"plural"
block|}
block|,
block|{
name|XFF_QUOTE
block|,
literal|"quotes"
block|}
block|,
block|{
name|XFF_QUOTE
block|,
literal|"quote"
block|}
block|,
block|{
name|XFF_TRIM_WS
block|,
literal|"trim"
block|}
block|,
block|{
name|XFF_WS
block|,
literal|"white"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_NEEDED_YET
end_ifdef

begin_decl_stmt
specifier|static
name|xo_mapping_t
name|xo_modifier_short_names
index|[]
init|=
block|{
block|{
name|XFF_COLON
block|,
literal|"c"
block|}
block|,
block|{
name|XFF_DISPLAY_ONLY
block|,
literal|"d"
block|}
block|,
block|{
name|XFF_ENCODE_ONLY
block|,
literal|"e"
block|}
block|,
block|{
name|XFF_GT_FIELD
block|,
literal|"g"
block|}
block|,
block|{
name|XFF_HUMANIZE
block|,
literal|"h"
block|}
block|,
block|{
name|XFF_KEY
block|,
literal|"k"
block|}
block|,
block|{
name|XFF_LEAF_LIST
block|,
literal|"l"
block|}
block|,
block|{
name|XFF_NOQUOTE
block|,
literal|"n"
block|}
block|,
block|{
name|XFF_GT_PLURAL
block|,
literal|"p"
block|}
block|,
block|{
name|XFF_QUOTE
block|,
literal|"q"
block|}
block|,
block|{
name|XFF_TRIM_WS
block|,
literal|"t"
block|}
block|,
block|{
name|XFF_WS
block|,
literal|"w"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOT_NEEDED_YET */
end_comment

begin_function
specifier|static
name|int
name|xo_count_fields
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
name|int
name|rc
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|fmt
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'{'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|rc
operator|+=
literal|1
expr_stmt|;
return|return
name|rc
operator|*
literal|2
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The field format is:  *  '{' modifiers ':' content [ '/' print-fmt [ '/' encode-fmt ]] '}'  * Roles are optional and include the following field types:  *   'D': decoration; something non-text and non-data (colons, commmas)  *   'E': error message  *   'G': gettext() the entire string; optional domainname as content  *   'L': label; text preceding data  *   'N': note; text following data  *   'P': padding; whitespace  *   'T': Title, where 'content' is a column title  *   'U': Units, where 'content' is the unit label  *   'V': value, where 'content' is the name of the field (the default)  *   'W': warning message  *   '[': start a section of anchored text  *   ']': end a section of anchored text  * The following modifiers are also supported:  *   'a': content is provided via argument (const char *), not descriptor  *   'c': flag: emit a colon after the label  *   'd': field is only emitted for display styles (text and html)  *   'e': field is only emitted for encoding styles (xml and json)  *   'g': gettext() the field  *   'h': humanize a numeric value (only for display styles)  *   'k': this field is a key, suitable for XPath predicates  *   'l': a leaf-list, a simple list of values  *   'n': no quotes around this field  *   'p': the field has plural gettext semantics (ngettext)  *   'q': add quotes around this field  *   't': trim whitespace around the value  *   'w': emit a blank after the label  * The print-fmt and encode-fmt strings is the printf-style formating  * for this data.  JSON and XML will use the encoding-fmt, if present.  * If the encode-fmt is not provided, it defaults to the print-fmt.  * If the print-fmt is not provided, it defaults to 's'.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xo_parse_roles
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|basep
parameter_list|,
name|xo_field_info_t
modifier|*
name|xfip
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|ftype
init|=
literal|0
decl_stmt|;
name|xo_xff_flags_t
name|flags
init|=
literal|0
decl_stmt|;
name|uint8_t
name|fnum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|basep
init|;
name|sp
operator|&&
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|':'
operator|||
operator|*
name|sp
operator|==
literal|'/'
operator|||
operator|*
name|sp
operator|==
literal|'}'
condition|)
break|break;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"backslash at the end of string"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Anything backslashed is ignored */
name|sp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|','
condition|)
block|{
specifier|const
name|char
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|np
operator|=
operator|++
name|sp
init|;
operator|*
name|np
condition|;
name|np
operator|++
control|)
if|if
condition|(
operator|*
name|np
operator|==
literal|':'
operator|||
operator|*
name|np
operator|==
literal|'/'
operator|||
operator|*
name|np
operator|==
literal|'}'
operator|||
operator|*
name|np
operator|==
literal|','
condition|)
break|break;
name|ssize_t
name|slen
init|=
name|np
operator|-
name|sp
decl_stmt|;
if|if
condition|(
name|slen
operator|>
literal|0
condition|)
block|{
name|xo_xff_flags_t
name|value
decl_stmt|;
name|value
operator|=
name|xo_name_lookup
argument_list|(
name|xo_role_names
argument_list|,
name|sp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|ftype
operator|=
name|value
expr_stmt|;
else|else
block|{
name|value
operator|=
name|xo_name_lookup
argument_list|(
name|xo_modifier_names
argument_list|,
name|sp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|flags
operator||=
name|value
expr_stmt|;
else|else
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"unknown keyword ignored: '%.*s'"
argument_list|,
name|slen
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
name|sp
operator|=
name|np
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
operator|*
name|sp
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'G'
case|:
case|case
literal|'L'
case|:
case|case
literal|'N'
case|:
case|case
literal|'P'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
if|if
condition|(
name|ftype
operator|!=
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"field descriptor uses multiple types: '%s'"
argument_list|,
name|xo_printable
argument_list|(
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ftype
operator|=
operator|*
name|sp
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|fnum
operator|=
operator|(
name|fnum
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|sp
operator|-
literal|'0'
operator|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|flags
operator||=
name|XFF_ARGUMENT
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|flags
operator||=
name|XFF_COLON
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|flags
operator||=
name|XFF_DISPLAY_ONLY
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|flags
operator||=
name|XFF_ENCODE_ONLY
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|flags
operator||=
name|XFF_GT_FIELD
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|flags
operator||=
name|XFF_HUMANIZE
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|flags
operator||=
name|XFF_KEY
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|flags
operator||=
name|XFF_LEAF_LIST
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|flags
operator||=
name|XFF_NOQUOTE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flags
operator||=
name|XFF_GT_PLURAL
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|flags
operator||=
name|XFF_QUOTE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|flags
operator||=
name|XFF_TRIM_WS
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|flags
operator||=
name|XFF_WS
expr_stmt|;
break|break;
default|default:
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"field descriptor uses unknown modifier: '%s'"
argument_list|,
name|xo_printable
argument_list|(
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     * No good answer here; a bad format will likely 	     * mean a core file.  We just return and hope 	     * the caller notices there's no output, and while 	     * that seems, well, bad, there's nothing better. 	     */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ftype
operator|==
literal|'N'
operator|||
name|ftype
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFF_COLON
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"colon modifier on 'N' or 'U' field ignored: "
literal|"'%s'"
argument_list|,
name|xo_printable
argument_list|(
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|XFF_COLON
expr_stmt|;
block|}
block|}
block|}
name|xfip
operator|->
name|xfi_flags
operator|=
name|flags
expr_stmt|;
name|xfip
operator|->
name|xfi_ftype
operator|=
name|ftype
condition|?
else|:
literal|'V'
expr_stmt|;
name|xfip
operator|->
name|xfi_fnum
operator|=
name|fnum
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*  * Number any remaining fields that need numbers.  Note that some  * field types (text, newline, escaped braces) never get numbers.  */
end_comment

begin_function
specifier|static
name|void
name|xo_gettext_finish_numbering_fields
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
name|UNUSED
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
parameter_list|)
block|{
name|xo_field_info_t
modifier|*
name|xfip
decl_stmt|;
name|unsigned
name|fnum
decl_stmt|,
name|max_fields
decl_stmt|;
name|uint64_t
name|bits
init|=
literal|0
decl_stmt|;
comment|/* First make a list of add the explicitly used bits */
for|for
control|(
name|xfip
operator|=
name|fields
operator|,
name|fnum
operator|=
literal|0
init|;
name|xfip
operator|->
name|xfi_ftype
condition|;
name|xfip
operator|++
control|)
block|{
switch|switch
condition|(
name|xfip
operator|->
name|xfi_ftype
condition|)
block|{
case|case
name|XO_ROLE_NEWLINE
case|:
comment|/* Don't get numbered */
case|case
name|XO_ROLE_TEXT
case|:
case|case
name|XO_ROLE_EBRACE
case|:
case|case
literal|'G'
case|:
continue|continue;
block|}
name|fnum
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|fnum
operator|>=
literal|63
condition|)
break|break;
if|if
condition|(
name|xfip
operator|->
name|xfi_fnum
condition|)
name|bits
operator||=
literal|1
operator|<<
name|xfip
operator|->
name|xfi_fnum
expr_stmt|;
block|}
name|max_fields
operator|=
name|fnum
expr_stmt|;
for|for
control|(
name|xfip
operator|=
name|fields
operator|,
name|fnum
operator|=
literal|0
init|;
name|xfip
operator|->
name|xfi_ftype
condition|;
name|xfip
operator|++
control|)
block|{
switch|switch
condition|(
name|xfip
operator|->
name|xfi_ftype
condition|)
block|{
case|case
name|XO_ROLE_NEWLINE
case|:
comment|/* Don't get numbered */
case|case
name|XO_ROLE_TEXT
case|:
case|case
name|XO_ROLE_EBRACE
case|:
case|case
literal|'G'
case|:
continue|continue;
block|}
if|if
condition|(
name|xfip
operator|->
name|xfi_fnum
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Find the next unassigned field */
for|for
control|(
name|fnum
operator|++
init|;
name|bits
operator|&
operator|(
literal|1
operator|<<
name|fnum
operator|)
condition|;
name|fnum
operator|++
control|)
continue|continue;
if|if
condition|(
name|fnum
operator|>
name|max_fields
condition|)
break|break;
name|xfip
operator|->
name|xfi_fnum
operator|=
name|fnum
expr_stmt|;
comment|/* Mark the field number */
name|bits
operator||=
literal|1
operator|<<
name|fnum
expr_stmt|;
comment|/* Mark it used */
block|}
block|}
end_function

begin_comment
comment|/*  * The format string uses field numbers, so we need to whiffle through it  * and make sure everything's sane and lovely.  */
end_comment

begin_function
specifier|static
name|int
name|xo_parse_field_numbers
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
parameter_list|,
name|unsigned
name|num_fields
parameter_list|)
block|{
name|xo_field_info_t
modifier|*
name|xfip
decl_stmt|;
name|unsigned
name|field
decl_stmt|,
name|fnum
decl_stmt|;
name|uint64_t
name|bits
init|=
literal|0
decl_stmt|;
for|for
control|(
name|xfip
operator|=
name|fields
operator|,
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|num_fields
condition|;
name|xfip
operator|++
operator|,
name|field
operator|++
control|)
block|{
comment|/* Fields default to 1:1 with natural position */
if|if
condition|(
name|xfip
operator|->
name|xfi_fnum
operator|==
literal|0
condition|)
name|xfip
operator|->
name|xfi_fnum
operator|=
name|field
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|xfip
operator|->
name|xfi_fnum
operator|>
name|num_fields
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"field number exceeds number of fields: '%s'"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fnum
operator|=
name|xfip
operator|->
name|xfi_fnum
operator|-
literal|1
expr_stmt|;
comment|/* Move to zero origin */
if|if
condition|(
name|fnum
operator|<
literal|64
condition|)
block|{
comment|/* Only test what fits */
if|if
condition|(
name|bits
operator|&
operator|(
literal|1
operator|<<
name|fnum
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"field number %u reused: '%s'"
argument_list|,
name|xfip
operator|->
name|xfi_fnum
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bits
operator||=
literal|1
operator|<<
name|fnum
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_parse_fields
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
parameter_list|,
name|unsigned
name|num_fields
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|basep
decl_stmt|;
name|unsigned
name|field
init|=
literal|0
decl_stmt|;
name|xo_field_info_t
modifier|*
name|xfip
init|=
name|fields
decl_stmt|;
name|unsigned
name|seen_fnum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|fmt
init|;
operator|*
name|cp
operator|&&
name|field
operator|<
name|num_fields
condition|;
name|field
operator|++
operator|,
name|xfip
operator|++
control|)
block|{
name|xfip
operator|->
name|xfi_start
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|xfip
operator|->
name|xfi_ftype
operator|=
name|XO_ROLE_NEWLINE
expr_stmt|;
name|xfip
operator|->
name|xfi_len
operator|=
literal|1
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'{'
condition|)
block|{
comment|/* Normal text */
for|for
control|(
name|sp
operator|=
name|cp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'{'
operator|||
operator|*
name|sp
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|xfip
operator|->
name|xfi_ftype
operator|=
name|XO_ROLE_TEXT
expr_stmt|;
name|xfip
operator|->
name|xfi_content
operator|=
name|cp
expr_stmt|;
name|xfip
operator|->
name|xfi_clen
operator|=
name|sp
operator|-
name|cp
expr_stmt|;
name|xfip
operator|->
name|xfi_next
operator|=
name|sp
expr_stmt|;
name|cp
operator|=
name|sp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
comment|/* Start of {{escaped braces}} */
name|xfip
operator|->
name|xfi_start
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* Start at second brace */
name|xfip
operator|->
name|xfi_ftype
operator|=
name|XO_ROLE_EBRACE
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
comment|/* Skip over _both_ characters */
for|for
control|(
name|sp
operator|=
name|cp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
operator|&&
name|sp
index|[
literal|1
index|]
operator|==
literal|'}'
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\0'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing closing '}}': '%s'"
argument_list|,
name|xo_printable
argument_list|(
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|xfip
operator|->
name|xfi_len
operator|=
name|sp
operator|-
name|xfip
operator|->
name|xfi_start
operator|+
literal|1
expr_stmt|;
comment|/* Move along the string, but don't run off the end */
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
operator|&&
name|sp
index|[
literal|1
index|]
operator|==
literal|'}'
condition|)
name|sp
operator|+=
literal|2
expr_stmt|;
name|cp
operator|=
operator|*
name|sp
condition|?
name|sp
else|:
name|sp
expr_stmt|;
name|xfip
operator|->
name|xfi_next
operator|=
name|cp
expr_stmt|;
continue|continue;
block|}
comment|/* We are looking at the start of a field definition */
name|xfip
operator|->
name|xfi_start
operator|=
name|basep
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
specifier|const
name|char
modifier|*
name|format
init|=
name|NULL
decl_stmt|;
name|ssize_t
name|flen
init|=
literal|0
decl_stmt|;
comment|/* Looking at roles and modifiers */
name|sp
operator|=
name|xo_parse_roles
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|basep
argument_list|,
name|xfip
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
comment|/* xo_failure has already been called */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|xfip
operator|->
name|xfi_fnum
condition|)
name|seen_fnum
operator|=
literal|1
expr_stmt|;
comment|/* Looking at content */
if|if
condition|(
operator|*
name|sp
operator|==
literal|':'
condition|)
block|{
for|for
control|(
name|ep
operator|=
operator|++
name|sp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
operator|||
operator|*
name|sp
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"backslash at the end of string"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ep
operator|!=
name|sp
condition|)
block|{
name|xfip
operator|->
name|xfi_clen
operator|=
name|sp
operator|-
name|ep
expr_stmt|;
name|xfip
operator|->
name|xfi_content
operator|=
name|ep
expr_stmt|;
block|}
block|}
else|else
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing content (':'): '%s'"
argument_list|,
name|xo_printable
argument_list|(
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Looking at main (display) format */
if|if
condition|(
operator|*
name|sp
operator|==
literal|'/'
condition|)
block|{
for|for
control|(
name|ep
operator|=
operator|++
name|sp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
operator|||
operator|*
name|sp
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"backslash at the end of string"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|flen
operator|=
name|sp
operator|-
name|ep
expr_stmt|;
name|format
operator|=
name|ep
expr_stmt|;
block|}
comment|/* Looking at encoding format */
if|if
condition|(
operator|*
name|sp
operator|==
literal|'/'
condition|)
block|{
for|for
control|(
name|ep
operator|=
operator|++
name|sp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
condition|)
break|break;
block|}
name|xfip
operator|->
name|xfi_encoding
operator|=
name|ep
expr_stmt|;
name|xfip
operator|->
name|xfi_elen
operator|=
name|sp
operator|-
name|ep
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'}'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing closing '}': %s"
argument_list|,
name|xo_printable
argument_list|(
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|xfip
operator|->
name|xfi_len
operator|=
name|sp
operator|-
name|xfip
operator|->
name|xfi_start
expr_stmt|;
name|xfip
operator|->
name|xfi_next
operator|=
operator|++
name|sp
expr_stmt|;
comment|/* If we have content, then we have a default format */
if|if
condition|(
name|xfip
operator|->
name|xfi_clen
operator|||
name|format
operator|||
operator|(
name|xfip
operator|->
name|xfi_flags
operator|&
name|XFF_ARGUMENT
operator|)
condition|)
block|{
if|if
condition|(
name|format
condition|)
block|{
name|xfip
operator|->
name|xfi_format
operator|=
name|format
expr_stmt|;
name|xfip
operator|->
name|xfi_flen
operator|=
name|flen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xo_role_wants_default_format
argument_list|(
name|xfip
operator|->
name|xfi_ftype
argument_list|)
condition|)
block|{
name|xfip
operator|->
name|xfi_format
operator|=
name|xo_default_format
expr_stmt|;
name|xfip
operator|->
name|xfi_flen
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|cp
operator|=
name|sp
expr_stmt|;
block|}
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/*      * If we saw a field number on at least one field, then we need      * to enforce some rules and/or guidelines.      */
if|if
condition|(
name|seen_fnum
condition|)
name|rc
operator|=
name|xo_parse_field_numbers
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|fields
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * We are passed a pointer to a format string just past the "{G:}"  * field.  We build a simplified version of the format string.  */
end_comment

begin_function
specifier|static
name|int
name|xo_gettext_simplify_format
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
parameter_list|,
name|int
name|this_field
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
name|UNUSED
parameter_list|,
name|xo_simplify_field_func_t
name|field_cb
parameter_list|)
block|{
name|unsigned
name|ftype
decl_stmt|;
name|xo_xff_flags_t
name|flags
decl_stmt|;
name|int
name|field
init|=
name|this_field
operator|+
literal|1
decl_stmt|;
name|xo_field_info_t
modifier|*
name|xfip
decl_stmt|;
name|char
name|ch
decl_stmt|;
for|for
control|(
name|xfip
operator|=
operator|&
name|fields
index|[
name|field
index|]
init|;
name|xfip
operator|->
name|xfi_ftype
condition|;
name|xfip
operator|++
operator|,
name|field
operator|++
control|)
block|{
name|ftype
operator|=
name|xfip
operator|->
name|xfi_ftype
expr_stmt|;
name|flags
operator|=
name|xfip
operator|->
name|xfi_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_GT_FIELD
operator|)
operator|&&
name|xfip
operator|->
name|xfi_content
operator|&&
name|ftype
operator|!=
literal|'V'
condition|)
block|{
if|if
condition|(
name|field_cb
condition|)
name|field_cb
argument_list|(
name|xfip
operator|->
name|xfi_content
argument_list|,
name|xfip
operator|->
name|xfi_clen
argument_list|,
operator|(
name|flags
operator|&
name|XFF_GT_PLURAL
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ftype
condition|)
block|{
case|case
literal|'G'
case|:
comment|/* Ignore gettext roles */
break|break;
case|case
name|XO_ROLE_NEWLINE
case|:
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_ROLE_EBRACE
case|:
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"{"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|xfip
operator|->
name|xfi_content
argument_list|,
name|xfip
operator|->
name|xfi_clen
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"}"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_ROLE_TEXT
case|:
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|xfip
operator|->
name|xfi_content
argument_list|,
name|xfip
operator|->
name|xfi_clen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"{"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftype
operator|!=
literal|'V'
condition|)
block|{
name|ch
operator|=
name|ftype
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|unsigned
name|fnum
init|=
name|xfip
operator|->
name|xfi_fnum
condition|?
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|fnum
condition|)
block|{
name|char
name|num
index|[
literal|12
index|]
decl_stmt|;
comment|/* Field numbers are origin 1, not 0, following printf(3) */
name|snprintf
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|num
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|fnum
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|num
argument_list|,
name|strlen
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|xfip
operator|->
name|xfi_content
argument_list|,
name|xfip
operator|->
name|xfi_clen
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"}"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
name|void
name|xo_dump_fields
parameter_list|(
name|xo_field_info_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Fake prototype for debug function */
end_comment

begin_function
name|void
name|xo_dump_fields
parameter_list|(
name|xo_field_info_t
modifier|*
name|fields
parameter_list|)
block|{
name|xo_field_info_t
modifier|*
name|xfip
decl_stmt|;
for|for
control|(
name|xfip
operator|=
name|fields
init|;
name|xfip
operator|->
name|xfi_ftype
condition|;
name|xfip
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%lu(%u): %lx [%c/%u] [%.*s] [%.*s] [%.*s]\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|xfip
operator|-
name|fields
argument_list|)
argument_list|,
name|xfip
operator|->
name|xfi_fnum
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|xfip
operator|->
name|xfi_flags
argument_list|,
name|isprint
argument_list|(
operator|(
name|int
operator|)
name|xfip
operator|->
name|xfi_ftype
argument_list|)
condition|?
name|xfip
operator|->
name|xfi_ftype
else|:
literal|' '
argument_list|,
name|xfip
operator|->
name|xfi_ftype
argument_list|,
operator|(
name|int
operator|)
name|xfip
operator|->
name|xfi_clen
argument_list|,
name|xfip
operator|->
name|xfi_content
condition|?
else|:
literal|""
argument_list|,
operator|(
name|int
operator|)
name|xfip
operator|->
name|xfi_flen
argument_list|,
name|xfip
operator|->
name|xfi_format
condition|?
else|:
literal|""
argument_list|,
operator|(
name|int
operator|)
name|xfip
operator|->
name|xfi_elen
argument_list|,
name|xfip
operator|->
name|xfi_encoding
condition|?
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETTEXT
end_ifdef

begin_comment
comment|/*  * Find the field that matches the given field number  */
end_comment

begin_function
specifier|static
name|xo_field_info_t
modifier|*
name|xo_gettext_find_field
parameter_list|(
name|xo_field_info_t
modifier|*
name|fields
parameter_list|,
name|unsigned
name|fnum
parameter_list|)
block|{
name|xo_field_info_t
modifier|*
name|xfip
decl_stmt|;
for|for
control|(
name|xfip
operator|=
name|fields
init|;
name|xfip
operator|->
name|xfi_ftype
condition|;
name|xfip
operator|++
control|)
if|if
condition|(
name|xfip
operator|->
name|xfi_fnum
operator|==
name|fnum
condition|)
return|return
name|xfip
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * At this point, we need to consider if the fields have been reordered,  * such as "The {:adjective} {:noun}" to "La {:noun} {:adjective}".  *  * We need to rewrite the new_fields using the old fields order,  * so that we can render the message using the arguments as they  * appear on the stack.  It's a lot of work, but we don't really  * want to (eventually) fall into the standard printf code which  * means using the arguments straight (and in order) from the  * varargs we were originally passed.  */
end_comment

begin_function
specifier|static
name|void
name|xo_gettext_rewrite_fields
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
parameter_list|,
name|unsigned
name|max_fields
parameter_list|)
block|{
name|xo_field_info_t
name|tmp
index|[
name|max_fields
index|]
decl_stmt|;
name|bzero
argument_list|(
name|tmp
argument_list|,
name|max_fields
operator|*
sizeof|sizeof
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|fnum
init|=
literal|0
decl_stmt|;
name|xo_field_info_t
modifier|*
name|newp
decl_stmt|,
modifier|*
name|outp
decl_stmt|,
modifier|*
name|zp
decl_stmt|;
for|for
control|(
name|newp
operator|=
name|fields
operator|,
name|outp
operator|=
name|tmp
init|;
name|newp
operator|->
name|xfi_ftype
condition|;
name|newp
operator|++
operator|,
name|outp
operator|++
control|)
block|{
switch|switch
condition|(
name|newp
operator|->
name|xfi_ftype
condition|)
block|{
case|case
name|XO_ROLE_NEWLINE
case|:
comment|/* Don't get numbered */
case|case
name|XO_ROLE_TEXT
case|:
case|case
name|XO_ROLE_EBRACE
case|:
case|case
literal|'G'
case|:
operator|*
name|outp
operator|=
operator|*
name|newp
expr_stmt|;
name|outp
operator|->
name|xfi_renum
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|zp
operator|=
name|xo_gettext_find_field
argument_list|(
name|fields
argument_list|,
operator|++
name|fnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|==
name|NULL
condition|)
block|{
comment|/* Should not occur */
operator|*
name|outp
operator|=
operator|*
name|newp
expr_stmt|;
name|outp
operator|->
name|xfi_renum
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
operator|*
name|outp
operator|=
operator|*
name|zp
expr_stmt|;
name|outp
operator|->
name|xfi_renum
operator|=
name|newp
operator|->
name|xfi_fnum
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|fields
argument_list|,
name|tmp
argument_list|,
name|max_fields
operator|*
sizeof|sizeof
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We've got two lists of fields, the old list from the original  * format string and the new one from the parsed gettext reply.  The  * new list has the localized words, where the old list has the  * formatting information.  We need to combine them into a single list  * (the new list).  *  * If the list needs to be reordered, then we've got more serious work  * to do.  */
end_comment

begin_function
specifier|static
name|int
name|xo_gettext_combine_formats
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
name|UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|gtfmt
parameter_list|,
name|xo_field_info_t
modifier|*
name|old_fields
parameter_list|,
name|xo_field_info_t
modifier|*
name|new_fields
parameter_list|,
name|unsigned
name|new_max_fields
parameter_list|,
name|int
modifier|*
name|reorderedp
parameter_list|)
block|{
name|int
name|reordered
init|=
literal|0
decl_stmt|;
name|xo_field_info_t
modifier|*
name|newp
decl_stmt|,
modifier|*
name|oldp
decl_stmt|,
modifier|*
name|startp
init|=
name|old_fields
decl_stmt|;
name|xo_gettext_finish_numbering_fields
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|old_fields
argument_list|)
expr_stmt|;
for|for
control|(
name|newp
operator|=
name|new_fields
init|;
name|newp
operator|->
name|xfi_ftype
condition|;
name|newp
operator|++
control|)
block|{
switch|switch
condition|(
name|newp
operator|->
name|xfi_ftype
condition|)
block|{
case|case
name|XO_ROLE_NEWLINE
case|:
case|case
name|XO_ROLE_TEXT
case|:
case|case
name|XO_ROLE_EBRACE
case|:
continue|continue;
case|case
literal|'V'
case|:
for|for
control|(
name|oldp
operator|=
name|startp
init|;
name|oldp
operator|->
name|xfi_ftype
condition|;
name|oldp
operator|++
control|)
block|{
if|if
condition|(
name|oldp
operator|->
name|xfi_ftype
operator|!=
literal|'V'
condition|)
continue|continue;
if|if
condition|(
name|newp
operator|->
name|xfi_clen
operator|!=
name|oldp
operator|->
name|xfi_clen
operator|||
name|strncmp
argument_list|(
name|newp
operator|->
name|xfi_content
argument_list|,
name|oldp
operator|->
name|xfi_content
argument_list|,
name|oldp
operator|->
name|xfi_clen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|reordered
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|startp
operator|=
name|oldp
operator|+
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Didn't find it on the first pass (starting from start) */
if|if
condition|(
name|oldp
operator|->
name|xfi_ftype
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|oldp
operator|=
name|old_fields
init|;
name|oldp
operator|<
name|startp
condition|;
name|oldp
operator|++
control|)
block|{
if|if
condition|(
name|oldp
operator|->
name|xfi_ftype
operator|!=
literal|'V'
condition|)
continue|continue;
if|if
condition|(
name|newp
operator|->
name|xfi_clen
operator|!=
name|oldp
operator|->
name|xfi_clen
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|newp
operator|->
name|xfi_content
argument_list|,
name|oldp
operator|->
name|xfi_content
argument_list|,
name|oldp
operator|->
name|xfi_clen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|reordered
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|oldp
operator|==
name|startp
condition|)
block|{
comment|/* Field not found */
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"post-gettext format can't find field "
literal|"'%.*s' in format '%s'"
argument_list|,
name|newp
operator|->
name|xfi_clen
argument_list|,
name|newp
operator|->
name|xfi_content
argument_list|,
name|xo_printable
argument_list|(
name|gtfmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
break|break;
default|default:
comment|/* 	     * Other fields don't have names for us to use, so if 	     * the types aren't the same, then we'll have to assume 	     * the original field is a match. 	     */
for|for
control|(
name|oldp
operator|=
name|startp
init|;
name|oldp
operator|->
name|xfi_ftype
condition|;
name|oldp
operator|++
control|)
block|{
if|if
condition|(
name|oldp
operator|->
name|xfi_ftype
operator|==
literal|'V'
condition|)
comment|/* Can't go past these */
break|break;
if|if
condition|(
name|oldp
operator|->
name|xfi_ftype
operator|==
name|newp
operator|->
name|xfi_ftype
condition|)
goto|goto
name|copy_it
goto|;
comment|/* Assumably we have a match */
block|}
continue|continue;
block|}
comment|/* 	 * Found a match; copy over appropriate fields 	 */
name|copy_it
label|:
name|newp
operator|->
name|xfi_flags
operator|=
name|oldp
operator|->
name|xfi_flags
expr_stmt|;
name|newp
operator|->
name|xfi_fnum
operator|=
name|oldp
operator|->
name|xfi_fnum
expr_stmt|;
name|newp
operator|->
name|xfi_format
operator|=
name|oldp
operator|->
name|xfi_format
expr_stmt|;
name|newp
operator|->
name|xfi_flen
operator|=
name|oldp
operator|->
name|xfi_flen
expr_stmt|;
name|newp
operator|->
name|xfi_encoding
operator|=
name|oldp
operator|->
name|xfi_encoding
expr_stmt|;
name|newp
operator|->
name|xfi_elen
operator|=
name|oldp
operator|->
name|xfi_elen
expr_stmt|;
block|}
operator|*
name|reorderedp
operator|=
name|reordered
expr_stmt|;
if|if
condition|(
name|reordered
condition|)
block|{
name|xo_gettext_finish_numbering_fields
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|new_fields
argument_list|)
expr_stmt|;
name|xo_gettext_rewrite_fields
argument_list|(
name|xop
argument_list|,
name|new_fields
argument_list|,
name|new_max_fields
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * We don't want to make gettext() calls here with a complete format  * string, since that means changing a flag would mean a  * labor-intensive re-translation expense.  Instead we build a  * simplified form with a reduced level of detail, perform a lookup on  * that string and then re-insert the formating info.  *  * So something like:  *   xo_emit("{G:}close {:fd/%ld} returned {g:error/%m} {:test/%6.6s}\n", ...)  * would have a lookup string of:  *   "close {:fd} returned {:error} {:test}\n"  *  * We also need to handling reordering of fields, where the gettext()  * reply string uses fields in a different order than the original  * format string:  *   "cluse-a {:fd} retoorned {:test}.  Bork {:error} Bork. Bork.\n"  * If we have to reorder fields within the message, then things get  * complicated.  See xo_gettext_rewrite_fields.  *  * Summary: i18n aighn't cheap.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xo_gettext_build_format
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
parameter_list|,
name|int
name|this_field
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
modifier|*
name|new_fmtp
parameter_list|)
block|{
if|if
condition|(
name|xo_style_is_encoding
argument_list|(
name|xop
argument_list|)
condition|)
goto|goto
name|bail
goto|;
name|xo_buffer_t
name|xb
decl_stmt|;
name|xo_buf_init
argument_list|(
operator|&
name|xb
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_gettext_simplify_format
argument_list|(
name|xop
argument_list|,
operator|&
name|xb
argument_list|,
name|fields
argument_list|,
name|this_field
argument_list|,
name|fmt
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|bail2
goto|;
specifier|const
name|char
modifier|*
name|gtfmt
init|=
name|xo_dgettext
argument_list|(
name|xop
argument_list|,
name|xb
operator|.
name|xb_bufp
argument_list|)
decl_stmt|;
if|if
condition|(
name|gtfmt
operator|==
name|NULL
operator|||
name|gtfmt
operator|==
name|fmt
operator|||
name|strcmp
argument_list|(
name|gtfmt
argument_list|,
name|fmt
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bail2
goto|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xb
argument_list|)
expr_stmt|;
name|char
modifier|*
name|new_fmt
init|=
name|xo_strndup
argument_list|(
name|gtfmt
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_fmt
operator|==
name|NULL
condition|)
goto|goto
name|bail2
goto|;
operator|*
name|new_fmtp
operator|=
name|new_fmt
expr_stmt|;
return|return
name|new_fmt
return|;
name|bail2
label|:
name|xo_buf_cleanup
argument_list|(
operator|&
name|xb
argument_list|)
expr_stmt|;
name|bail
label|:
operator|*
name|new_fmtp
operator|=
name|NULL
expr_stmt|;
return|return
name|fmt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_gettext_rebuild_content
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
parameter_list|,
name|ssize_t
modifier|*
name|fstart
parameter_list|,
name|unsigned
name|min_fstart
parameter_list|,
name|ssize_t
modifier|*
name|fend
parameter_list|,
name|unsigned
name|max_fend
parameter_list|)
block|{
name|xo_field_info_t
modifier|*
name|xfip
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|ssize_t
name|base
init|=
name|fstart
index|[
name|min_fstart
index|]
decl_stmt|;
name|ssize_t
name|blen
init|=
name|fend
index|[
name|max_fend
index|]
operator|-
name|base
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
if|if
condition|(
name|blen
operator|==
literal|0
condition|)
return|return;
name|buf
operator|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
name|blen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|fstart
index|[
name|min_fstart
index|]
argument_list|,
name|blen
argument_list|)
expr_stmt|;
comment|/* Copy our data */
name|unsigned
name|field
init|=
name|min_fstart
decl_stmt|,
name|len
decl_stmt|,
name|fnum
decl_stmt|;
name|ssize_t
name|soff
decl_stmt|,
name|doff
init|=
name|base
decl_stmt|;
name|xo_field_info_t
modifier|*
name|zp
decl_stmt|;
comment|/*      * Be aware there are two competing views of "field number": we      * want the user to thing in terms of "The {1:size}" where {G:},      * newlines, escaped braces, and text don't have numbers.  But is      * also the internal view, where we have an array of      * xo_field_info_t and every field have an index.  fnum, fstart[]      * and fend[] are the latter, but xfi_renum is the former.      */
for|for
control|(
name|xfip
operator|=
name|fields
operator|+
name|field
init|;
name|xfip
operator|->
name|xfi_ftype
condition|;
name|xfip
operator|++
operator|,
name|field
operator|++
control|)
block|{
name|fnum
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|xfip
operator|->
name|xfi_renum
condition|)
block|{
name|zp
operator|=
name|xo_gettext_find_field
argument_list|(
name|fields
argument_list|,
name|xfip
operator|->
name|xfi_renum
argument_list|)
expr_stmt|;
name|fnum
operator|=
name|zp
condition|?
name|zp
operator|-
name|fields
else|:
name|field
expr_stmt|;
block|}
name|soff
operator|=
name|fstart
index|[
name|fnum
index|]
expr_stmt|;
name|len
operator|=
name|fend
index|[
name|fnum
index|]
operator|-
name|soff
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|soff
operator|-=
name|base
expr_stmt|;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|doff
argument_list|,
name|buf
operator|+
name|soff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|doff
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|xo_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_GETTEXT */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xo_gettext_build_format
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
name|UNUSED
parameter_list|,
name|int
name|this_field
name|UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
name|UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|new_fmtp
parameter_list|)
block|{
operator|*
name|new_fmtp
operator|=
name|NULL
expr_stmt|;
return|return
name|fmt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_gettext_combine_formats
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
name|UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|gtfmt
name|UNUSED
parameter_list|,
name|xo_field_info_t
modifier|*
name|old_fields
name|UNUSED
parameter_list|,
name|xo_field_info_t
modifier|*
name|new_fields
name|UNUSED
parameter_list|,
name|unsigned
name|new_max_fields
name|UNUSED
parameter_list|,
name|int
modifier|*
name|reorderedp
name|UNUSED
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_gettext_rebuild_content
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
name|UNUSED
parameter_list|,
name|ssize_t
modifier|*
name|fstart
name|UNUSED
parameter_list|,
name|unsigned
name|min_fstart
name|UNUSED
parameter_list|,
name|ssize_t
modifier|*
name|fend
name|UNUSED
parameter_list|,
name|unsigned
name|max_fend
name|UNUSED
parameter_list|)
block|{
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GETTEXT */
end_comment

begin_comment
comment|/*  * Emit a set of fields.  This is really the core of libxo.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_do_emit_fields
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_field_info_t
modifier|*
name|fields
parameter_list|,
name|unsigned
name|max_fields
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
name|int
name|gettext_inuse
init|=
literal|0
decl_stmt|;
name|int
name|gettext_changed
init|=
literal|0
decl_stmt|;
name|int
name|gettext_reordered
init|=
literal|0
decl_stmt|;
name|unsigned
name|ftype
decl_stmt|;
name|xo_xff_flags_t
name|flags
decl_stmt|;
name|xo_field_info_t
modifier|*
name|new_fields
init|=
name|NULL
decl_stmt|;
name|xo_field_info_t
modifier|*
name|xfip
decl_stmt|;
name|unsigned
name|field
decl_stmt|;
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|flush
init|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_FLUSH
argument_list|)
decl_stmt|;
name|int
name|flush_line
init|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_FLUSH_LINE
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_fmt
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_REORDER
argument_list|)
operator|||
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_ENCODER
condition|)
name|flush_line
operator|=
literal|0
expr_stmt|;
comment|/*      * Some overhead for gettext; if the fields in the msgstr returned      * by gettext are reordered, then we need to record start and end      * for each field.  We'll go ahead and render the fields in the      * normal order, but later we can then reconstruct the reordered      * fields using these fstart/fend values.      */
name|unsigned
name|flimit
init|=
name|max_fields
operator|*
literal|2
decl_stmt|;
comment|/* Pessimistic limit */
name|unsigned
name|min_fstart
init|=
name|flimit
operator|-
literal|1
decl_stmt|;
name|unsigned
name|max_fend
init|=
literal|0
decl_stmt|;
comment|/* Highest recorded fend[] entry */
name|ssize_t
name|fstart
index|[
name|flimit
index|]
decl_stmt|;
name|bzero
argument_list|(
name|fstart
argument_list|,
name|flimit
operator|*
sizeof|sizeof
argument_list|(
name|fstart
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ssize_t
name|fend
index|[
name|flimit
index|]
decl_stmt|;
name|bzero
argument_list|(
name|fend
argument_list|,
name|flimit
operator|*
sizeof|sizeof
argument_list|(
name|fend
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|xfip
operator|=
name|fields
operator|,
name|field
operator|=
literal|0
init|;
name|xfip
operator|->
name|xfi_ftype
operator|&&
name|field
operator|<
name|max_fields
condition|;
name|xfip
operator|++
operator|,
name|field
operator|++
control|)
block|{
name|ftype
operator|=
name|xfip
operator|->
name|xfi_ftype
expr_stmt|;
name|flags
operator|=
name|xfip
operator|->
name|xfi_flags
expr_stmt|;
comment|/* Record field start offset */
if|if
condition|(
name|gettext_reordered
condition|)
block|{
name|fstart
index|[
name|field
index|]
operator|=
name|xo_buf_offset
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_fstart
operator|>
name|field
condition|)
name|min_fstart
operator|=
name|field
expr_stmt|;
block|}
specifier|const
name|char
modifier|*
name|content
init|=
name|xfip
operator|->
name|xfi_content
decl_stmt|;
name|ssize_t
name|clen
init|=
name|xfip
operator|->
name|xfi_clen
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_ARGUMENT
condition|)
block|{
comment|/* 	     * Argument flag means the content isn't given in the descriptor, 	     * but as a UTF-8 string ('const char *') argument in xo_vap. 	     */
name|content
operator|=
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|clen
operator|=
name|content
condition|?
name|strlen
argument_list|(
name|content
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ftype
operator|==
name|XO_ROLE_NEWLINE
condition|)
block|{
name|xo_line_close
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush_line
operator|&&
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
goto|goto
name|bottom
goto|;
block|}
elseif|else
if|if
condition|(
name|ftype
operator|==
name|XO_ROLE_EBRACE
condition|)
block|{
name|xo_format_text
argument_list|(
name|xop
argument_list|,
name|xfip
operator|->
name|xfi_start
argument_list|,
name|xfip
operator|->
name|xfi_len
argument_list|)
expr_stmt|;
goto|goto
name|bottom
goto|;
block|}
elseif|else
if|if
condition|(
name|ftype
operator|==
name|XO_ROLE_TEXT
condition|)
block|{
comment|/* Normal text */
name|xo_format_text
argument_list|(
name|xop
argument_list|,
name|xfip
operator|->
name|xfi_content
argument_list|,
name|xfip
operator|->
name|xfi_clen
argument_list|)
expr_stmt|;
goto|goto
name|bottom
goto|;
block|}
comment|/* 	 * Notes and units need the 'w' flag handled before the content. 	 */
if|if
condition|(
name|ftype
operator|==
literal|'N'
operator|||
name|ftype
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFF_WS
condition|)
block|{
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"padding"
argument_list|,
name|NULL
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|XFF_WS
expr_stmt|;
comment|/* Block later handling of this */
block|}
block|}
if|if
condition|(
name|ftype
operator|==
literal|'V'
condition|)
name|xo_format_value
argument_list|(
name|xop
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|xfip
operator|->
name|xfi_format
argument_list|,
name|xfip
operator|->
name|xfi_flen
argument_list|,
name|xfip
operator|->
name|xfi_encoding
argument_list|,
name|xfip
operator|->
name|xfi_elen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'['
condition|)
name|xo_anchor_start
argument_list|(
name|xop
argument_list|,
name|xfip
argument_list|,
name|content
argument_list|,
name|clen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|']'
condition|)
name|xo_anchor_stop
argument_list|(
name|xop
argument_list|,
name|xfip
argument_list|,
name|content
argument_list|,
name|clen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'C'
condition|)
name|xo_format_colors
argument_list|(
name|xop
argument_list|,
name|xfip
argument_list|,
name|content
argument_list|,
name|clen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'G'
condition|)
block|{
comment|/* 	     * A {G:domain} field; disect the domain name and translate 	     * the remaining portion of the input string.  If the user 	     * didn't put the {G:} at the start of the format string, then 	     * assumably they just want us to translate the rest of it. 	     * Since gettext returns strings in a static buffer, we make 	     * a copy in new_fmt. 	     */
name|xo_set_gettext_domain
argument_list|(
name|xop
argument_list|,
name|xfip
argument_list|,
name|content
argument_list|,
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gettext_inuse
condition|)
block|{
comment|/* Only translate once */
name|gettext_inuse
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|new_fmt
condition|)
block|{
name|xo_free
argument_list|(
name|new_fmt
argument_list|)
expr_stmt|;
name|new_fmt
operator|=
name|NULL
expr_stmt|;
block|}
name|xo_gettext_build_format
argument_list|(
name|xop
argument_list|,
name|fields
argument_list|,
name|field
argument_list|,
name|xfip
operator|->
name|xfi_next
argument_list|,
operator|&
name|new_fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fmt
condition|)
block|{
name|gettext_changed
operator|=
literal|1
expr_stmt|;
name|unsigned
name|new_max_fields
init|=
name|xo_count_fields
argument_list|(
name|xop
argument_list|,
name|new_fmt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|new_max_fields
operator|<
name|max_fields
condition|)
name|new_max_fields
operator|=
name|max_fields
expr_stmt|;
comment|/* Leave a blank slot at the beginning */
name|ssize_t
name|sz
init|=
operator|(
name|new_max_fields
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xo_field_info_t
argument_list|)
decl_stmt|;
name|new_fields
operator|=
name|alloca
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|new_fields
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xo_parse_fields
argument_list|(
name|xop
argument_list|,
name|new_fields
operator|+
literal|1
argument_list|,
name|new_max_fields
argument_list|,
name|new_fmt
argument_list|)
condition|)
block|{
name|gettext_reordered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|xo_gettext_combine_formats
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|new_fmt
argument_list|,
name|fields
argument_list|,
name|new_fields
operator|+
literal|1
argument_list|,
name|new_max_fields
argument_list|,
operator|&
name|gettext_reordered
argument_list|)
condition|)
block|{
if|if
condition|(
name|gettext_reordered
condition|)
block|{
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_LOG_GETTEXT
argument_list|)
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"gettext finds reordered "
literal|"fields in '%s' and '%s'"
argument_list|,
name|xo_printable
argument_list|(
name|fmt
argument_list|)
argument_list|,
name|xo_printable
argument_list|(
name|new_fmt
argument_list|)
argument_list|)
expr_stmt|;
name|flush_line
operator|=
literal|0
expr_stmt|;
comment|/* Must keep at content */
name|XOIF_SET
argument_list|(
name|xop
argument_list|,
name|XOIF_REORDER
argument_list|)
expr_stmt|;
block|}
name|field
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Will be incremented at top of loop */
name|xfip
operator|=
name|new_fields
expr_stmt|;
name|max_fields
operator|=
name|new_max_fields
expr_stmt|;
block|}
block|}
block|}
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|clen
operator|||
name|xfip
operator|->
name|xfi_format
condition|)
block|{
specifier|const
name|char
modifier|*
name|class_name
init|=
name|xo_class_name
argument_list|(
name|ftype
argument_list|)
decl_stmt|;
if|if
condition|(
name|class_name
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
name|class_name
argument_list|,
name|xo_tag_name
argument_list|(
name|ftype
argument_list|)
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|xfip
operator|->
name|xfi_format
argument_list|,
name|xfip
operator|->
name|xfi_flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'T'
condition|)
name|xo_format_title
argument_list|(
name|xop
argument_list|,
name|xfip
argument_list|,
name|content
argument_list|,
name|clen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'U'
condition|)
name|xo_format_units
argument_list|(
name|xop
argument_list|,
name|xfip
argument_list|,
name|content
argument_list|,
name|clen
argument_list|)
expr_stmt|;
else|else
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"unknown field type: '%c'"
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|XFF_COLON
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"decoration"
argument_list|,
name|NULL
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_WS
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"padding"
argument_list|,
name|NULL
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bottom
label|:
comment|/* Record the end-of-field offset */
if|if
condition|(
name|gettext_reordered
condition|)
block|{
name|fend
index|[
name|field
index|]
operator|=
name|xo_buf_offset
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
expr_stmt|;
name|max_fend
operator|=
name|field
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gettext_changed
operator|&&
name|gettext_reordered
condition|)
block|{
comment|/* Final step: rebuild the content using the rendered fields */
name|xo_gettext_rebuild_content
argument_list|(
name|xop
argument_list|,
name|new_fields
operator|+
literal|1
argument_list|,
name|fstart
argument_list|,
name|min_fstart
argument_list|,
name|fend
argument_list|,
name|max_fend
argument_list|)
expr_stmt|;
block|}
name|XOIF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOIF_REORDER
argument_list|)
expr_stmt|;
comment|/*      * If we've got enough data, flush it.      */
if|if
condition|(
name|xo_buf_offset
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
operator|>
name|XO_BUF_HIGH_WATER
condition|)
name|flush
operator|=
literal|1
expr_stmt|;
comment|/* If we don't have an anchor, write the text out */
if|if
condition|(
name|flush
operator|&&
operator|!
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_ANCHOR
argument_list|)
condition|)
block|{
if|if
condition|(
name|xo_write
argument_list|(
name|xop
argument_list|)
operator|<
literal|0
condition|)
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Report failure */
elseif|else
if|if
condition|(
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
operator|<
literal|0
condition|)
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|new_fmt
condition|)
name|xo_free
argument_list|(
name|new_fmt
argument_list|)
expr_stmt|;
comment|/*      * We've carried the gettext domainname inside our handle just for      * convenience, but we need to ensure it doesn't survive across      * xo_emit calls.      */
if|if
condition|(
name|xop
operator|->
name|xo_gt_domain
condition|)
block|{
name|xo_free
argument_list|(
name|xop
operator|->
name|xo_gt_domain
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_gt_domain
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|<
literal|0
operator|)
condition|?
name|rc
else|:
name|xop
operator|->
name|xo_columns
return|;
block|}
end_function

begin_comment
comment|/*  * Parse and emit a set of fields  */
end_comment

begin_function
specifier|static
name|int
name|xo_do_emit
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_emit_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
name|xop
operator|->
name|xo_columns
operator|=
literal|0
expr_stmt|;
comment|/* Always reset it */
name|xop
operator|->
name|xo_errno
operator|=
name|errno
expr_stmt|;
comment|/* Save for "%m" */
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|unsigned
name|max_fields
decl_stmt|;
name|xo_field_info_t
modifier|*
name|fields
init|=
name|NULL
decl_stmt|;
comment|/* Adjust XOEF_RETAIN based on global flags */
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_RETAIN_ALL
argument_list|)
condition|)
name|flags
operator||=
name|XOEF_RETAIN
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_RETAIN_NONE
argument_list|)
condition|)
name|flags
operator|&=
operator|~
name|XOEF_RETAIN
expr_stmt|;
comment|/*      * Check for 'retain' flag, telling us to retain the field      * information.  If we've already saved it, then we can avoid      * re-parsing the format string.      */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XOEF_RETAIN
operator|)
operator|||
name|xo_retain_find
argument_list|(
name|fmt
argument_list|,
operator|&
name|fields
argument_list|,
operator|&
name|max_fields
argument_list|)
operator|!=
literal|0
operator|||
name|fields
operator|==
name|NULL
condition|)
block|{
comment|/* Nothing retained; parse the format string */
name|max_fields
operator|=
name|xo_count_fields
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|fields
operator|=
name|alloca
argument_list|(
name|max_fields
operator|*
sizeof|sizeof
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fields
argument_list|,
name|max_fields
operator|*
sizeof|sizeof
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_parse_fields
argument_list|(
name|xop
argument_list|,
name|fields
argument_list|,
name|max_fields
argument_list|,
name|fmt
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Warning already displayed */
if|if
condition|(
name|flags
operator|&
name|XOEF_RETAIN
condition|)
block|{
comment|/* Retain the info */
name|xo_retain_add
argument_list|(
name|fmt
argument_list|,
name|fields
argument_list|,
name|max_fields
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|xo_do_emit_fields
argument_list|(
name|xop
argument_list|,
name|fields
argument_list|,
name|max_fields
argument_list|,
name|fmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rebuild a format string in a gettext-friendly format.  This function  * is exposed to tools can perform this function.  See xo(1).  */
end_comment

begin_function
name|char
modifier|*
name|xo_simplify_format
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|with_numbers
parameter_list|,
name|xo_simplify_field_func_t
name|field_cb
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_columns
operator|=
literal|0
expr_stmt|;
comment|/* Always reset it */
name|xop
operator|->
name|xo_errno
operator|=
name|errno
expr_stmt|;
comment|/* Save for "%m" */
name|unsigned
name|max_fields
init|=
name|xo_count_fields
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|)
decl_stmt|;
name|xo_field_info_t
name|fields
index|[
name|max_fields
index|]
decl_stmt|;
name|bzero
argument_list|(
name|fields
argument_list|,
name|max_fields
operator|*
sizeof|sizeof
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_parse_fields
argument_list|(
name|xop
argument_list|,
name|fields
argument_list|,
name|max_fields
argument_list|,
name|fmt
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Warning already displayed */
name|xo_buffer_t
name|xb
decl_stmt|;
name|xo_buf_init
argument_list|(
operator|&
name|xb
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_numbers
condition|)
name|xo_gettext_finish_numbering_fields
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_gettext_simplify_format
argument_list|(
name|xop
argument_list|,
operator|&
name|xb
argument_list|,
name|fields
argument_list|,
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|field_cb
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|xb
operator|.
name|xb_bufp
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_emit_hv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_emit_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_emit
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
name|xo_default
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|ssize_t
name|rc
decl_stmt|;
name|va_start
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_emit_hvf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_emit_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_emit_hf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_emit_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_emit_f
parameter_list|(
name|xo_emit_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
name|xo_default
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|ssize_t
name|rc
decl_stmt|;
name|va_start
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * Emit a single field by providing the info information typically provided  * inside the field description (role, modifiers, and formats).  This is  * a convenience function to avoid callers using snprintf to build field  * descriptions.  */
end_comment

begin_function
name|xo_ssize_t
name|xo_emit_field_hv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|rolmod
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|efmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|rolmod
operator|==
name|NULL
condition|)
name|rolmod
operator|=
literal|"V"
expr_stmt|;
name|xo_field_info_t
name|xfi
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|xfi
argument_list|,
sizeof|sizeof
argument_list|(
name|xfi
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|xo_parse_roles
argument_list|(
name|xop
argument_list|,
name|rolmod
argument_list|,
name|rolmod
argument_list|,
operator|&
name|xfi
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|xfi
operator|.
name|xfi_start
operator|=
name|fmt
expr_stmt|;
name|xfi
operator|.
name|xfi_content
operator|=
name|contents
expr_stmt|;
name|xfi
operator|.
name|xfi_format
operator|=
name|fmt
expr_stmt|;
name|xfi
operator|.
name|xfi_encoding
operator|=
name|efmt
expr_stmt|;
name|xfi
operator|.
name|xfi_clen
operator|=
name|contents
condition|?
name|strlen
argument_list|(
name|contents
argument_list|)
else|:
literal|0
expr_stmt|;
name|xfi
operator|.
name|xfi_flen
operator|=
name|fmt
condition|?
name|strlen
argument_list|(
name|fmt
argument_list|)
else|:
literal|0
expr_stmt|;
name|xfi
operator|.
name|xfi_elen
operator|=
name|efmt
condition|?
name|strlen
argument_list|(
name|efmt
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* If we have content, then we have a default format */
if|if
condition|(
name|contents
operator|&&
name|fmt
operator|==
name|NULL
operator|&&
name|xo_role_wants_default_format
argument_list|(
name|xfi
operator|.
name|xfi_ftype
argument_list|)
condition|)
block|{
name|xfi
operator|.
name|xfi_format
operator|=
name|xo_default_format
expr_stmt|;
name|xfi
operator|.
name|xfi_flen
operator|=
literal|2
expr_stmt|;
block|}
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit_fields
argument_list|(
name|xop
argument_list|,
operator|&
name|xfi
argument_list|,
literal|1
argument_list|,
name|fmt
condition|?
else|:
name|contents
condition|?
else|:
literal|"field"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_emit_field_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|rolmod
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|efmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|efmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_emit_field_hv
argument_list|(
name|xop
argument_list|,
name|rolmod
argument_list|,
name|contents
argument_list|,
name|fmt
argument_list|,
name|efmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_emit_field
parameter_list|(
specifier|const
name|char
modifier|*
name|rolmod
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|efmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|efmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_emit_field_hv
argument_list|(
name|NULL
argument_list|,
name|rolmod
argument_list|,
name|contents
argument_list|,
name|fmt
argument_list|,
name|efmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_attr_hv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
specifier|const
name|ssize_t
name|extra
init|=
literal|5
decl_stmt|;
comment|/* space, equals, quote, quote, and nul */
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
name|ssize_t
name|nlen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_attrs
decl_stmt|;
name|ssize_t
name|name_offset
decl_stmt|,
name|value_offset
decl_stmt|;
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|nlen
operator|+
name|extra
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|nlen
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'"'
expr_stmt|;
name|rc
operator|=
name|xo_vsnprintf
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
block|{
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|=
literal|'\0'
expr_stmt|;
name|rc
operator|+=
name|nlen
operator|+
name|extra
expr_stmt|;
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|name_offset
operator|=
name|xo_buf_offset
argument_list|(
name|xbp
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value_offset
operator|=
name|xo_buf_offset
argument_list|(
name|xbp
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_vsnprintf
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
block|{
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|=
literal|'\0'
expr_stmt|;
name|rc
operator|=
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_ATTRIBUTE
argument_list|,
name|xo_buf_data
argument_list|(
name|xbp
argument_list|,
name|name_offset
argument_list|)
argument_list|,
name|xo_buf_data
argument_list|(
name|xbp
argument_list|,
name|value_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_attr_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_attr_hv
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_attr_hv
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_stack_set_flags
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NOT_FIRST
argument_list|)
condition|)
block|{
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
name|xsp
operator|->
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|XOF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOF_NOT_FIRST
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_depth_change
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
name|indent
parameter_list|,
name|xo_state_t
name|state
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|)
block|{
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_HTML
operator|||
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_TEXT
condition|)
name|indent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_DTRT
argument_list|)
condition|)
name|flags
operator||=
name|XSF_DTRT
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0
condition|)
block|{
comment|/* Push operation */
if|if
condition|(
name|xo_depth_check
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_depth
operator|+
name|delta
argument_list|)
condition|)
return|return;
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
operator|+
name|delta
index|]
decl_stmt|;
name|xsp
operator|->
name|xs_flags
operator|=
name|flags
expr_stmt|;
name|xsp
operator|->
name|xs_state
operator|=
name|state
expr_stmt|;
name|xo_stack_set_flags
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
name|xsp
operator|->
name|xs_name
operator|=
name|xo_strndup
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pop operation */
if|if
condition|(
name|xop
operator|->
name|xo_depth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_IGNORE_CLOSE
argument_list|)
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"close with empty stack: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
if|if
condition|(
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_WARN
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|top
init|=
name|xsp
operator|->
name|xs_name
decl_stmt|;
if|if
condition|(
name|top
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|top
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"incorrect close: '%s' .vs. '%s'"
argument_list|,
name|name
argument_list|,
name|top
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_LIST
operator|)
operator|!=
operator|(
name|flags
operator|&
name|XSF_LIST
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"list close on list confict: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_INSTANCE
operator|)
operator|!=
operator|(
name|flags
operator|&
name|XSF_INSTANCE
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"list close on instance confict: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|xsp
operator|->
name|xs_name
condition|)
block|{
name|xo_free
argument_list|(
name|xsp
operator|->
name|xs_name
argument_list|)
expr_stmt|;
name|xsp
operator|->
name|xs_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|xsp
operator|->
name|xs_keys
condition|)
block|{
name|xo_free
argument_list|(
name|xsp
operator|->
name|xs_keys
argument_list|)
expr_stmt|;
name|xsp
operator|->
name|xs_keys
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|xop
operator|->
name|xo_depth
operator|+=
name|delta
expr_stmt|;
comment|/* Record new depth */
name|xop
operator|->
name|xo_indent
operator|+=
name|indent
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_set_depth
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_depth_check
argument_list|(
name|xop
argument_list|,
name|depth
argument_list|)
condition|)
return|return;
name|xop
operator|->
name|xo_depth
operator|+=
name|depth
expr_stmt|;
name|xop
operator|->
name|xo_indent
operator|+=
name|depth
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|xo_xsf_flags_t
name|xo_stack_flags
parameter_list|(
name|xo_xof_flags_t
name|xflags
parameter_list|)
block|{
if|if
condition|(
name|xflags
operator|&
name|XOF_DTRT
condition|)
return|return
name|XSF_DTRT
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_emit_top
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|ppn
parameter_list|)
block|{
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s{%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|XOIF_SET
argument_list|(
name|xop
argument_list|,
name|XOIF_TOP_EMITTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_version
condition|)
block|{
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s\"__version\": \"%s\", %s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|xop
operator|->
name|xo_version
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xo_free
argument_list|(
name|xop
operator|->
name|xo_version
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_version
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_do_open_container
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"NULL passed for container name"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
name|flags
operator||=
name|xop
operator|->
name|xo_flags
expr_stmt|;
comment|/* Pick up handle flags */
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s<%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|!=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
condition|)
block|{
name|rc
operator|+=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
argument_list|,
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
expr_stmt|;
block|}
name|rc
operator|+=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|">%s"
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|xo_stack_set_flags
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_TOP
argument_list|)
operator|&&
operator|!
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_TOP_EMITTED
argument_list|)
condition|)
name|xo_emit_top
argument_list|(
name|xop
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|",\n"
else|:
literal|", "
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s\"%s\": {%s"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_SDPARAMS
case|:
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|rc
operator|=
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_OPEN_CONTAINER
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|XSS_OPEN_CONTAINER
argument_list|,
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_open_container_hf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_transition
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|,
name|XSS_OPEN_CONTAINER
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_container_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_container_hf
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_container
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_container_hf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_container_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_container_hf
argument_list|(
name|xop
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_container_d
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_container_hf
argument_list|(
name|NULL
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_do_close_container
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
name|name
operator|=
name|xsp
operator|->
name|xs_name
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|ssize_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* We need to make a local copy; xo_depth_change will free it */
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_DTRT
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing name without 'dtrt' mode"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s</%s>%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|pre_nl
operator|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
expr_stmt|;
name|ppn
operator|=
operator|(
name|xop
operator|->
name|xo_depth
operator|<=
literal|1
operator|)
condition|?
literal|"\n"
else|:
literal|""
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s}%s"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
case|case
name|XO_STYLE_TEXT
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_SDPARAMS
case|:
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_CLOSE_CONTAINER
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_container_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_transition
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_container
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_close_container_h
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_container_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
return|return
name|xo_close_container_h
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_container_d
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xo_close_container_h
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_do_open_list
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|indent
init|=
literal|0
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_JSON
case|:
name|indent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_TOP
argument_list|)
operator|&&
operator|!
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_TOP_EMITTED
argument_list|)
condition|)
name|xo_emit_top
argument_list|(
name|xop
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"NULL passed for list name"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
name|xo_stack_set_flags
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|",\n"
else|:
literal|", "
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s\"%s\": [%s"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|rc
operator|=
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_OPEN_LIST
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|indent
argument_list|,
name|XSS_OPEN_LIST
argument_list|,
name|XSF_LIST
operator||
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_open_list_hf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_transition
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|,
name|XSS_OPEN_LIST
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_list_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_list_hf
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_list
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_list_hf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_list_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_list_hf
argument_list|(
name|xop
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_list_d
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_list_hf
argument_list|(
name|NULL
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_do_close_list
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
name|name
operator|=
name|xsp
operator|->
name|xs_name
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|ssize_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* We need to make a local copy; xo_depth_change will free it */
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_DTRT
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing name without 'dtrt' mode"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|XSS_CLOSE_LIST
argument_list|,
name|XSF_LIST
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s]"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|XSS_CLOSE_LIST
argument_list|,
name|XSF_LIST
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_CLOSE_LIST
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|XSS_CLOSE_LIST
argument_list|,
name|XSF_LIST
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_list_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_transition
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|XSS_CLOSE_LIST
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_list
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_close_list_h
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_list_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
return|return
name|xo_close_list_h
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_list_d
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xo_close_list_h
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_do_open_leaf_list
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|indent
init|=
literal|0
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_JSON
case|:
name|indent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_TOP
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_TOP_EMITTED
argument_list|)
condition|)
block|{
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s{%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|XOIF_SET
argument_list|(
name|xop
argument_list|,
name|XOIF_TOP_EMITTED
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"NULL passed for list name"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
name|xo_stack_set_flags
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|",\n"
else|:
literal|", "
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s\"%s\": [%s"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|rc
operator|=
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_OPEN_LEAF_LIST
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|indent
argument_list|,
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSF_LIST
operator||
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_do_close_leaf_list
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
name|name
operator|=
name|xsp
operator|->
name|xs_name
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|ssize_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* We need to make a local copy; xo_depth_change will free it */
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_DTRT
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing name without 'dtrt' mode"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|XSS_CLOSE_LEAF_LIST
argument_list|,
name|XSF_LIST
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s]"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|rc
operator|=
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_CLOSE_LEAF_LIST
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
default|default:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|XSS_CLOSE_LEAF_LIST
argument_list|,
name|XSF_LIST
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_do_open_instance
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
name|flags
operator||=
name|xop
operator|->
name|xo_flags
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"NULL passed for instance name"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s<%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|!=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
condition|)
block|{
name|rc
operator|+=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
argument_list|,
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
expr_stmt|;
block|}
name|rc
operator|+=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|">%s"
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|xo_stack_set_flags
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|",\n"
else|:
literal|", "
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s{%s"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_SDPARAMS
case|:
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|rc
operator|=
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_OPEN_INSTANCE
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|XSS_OPEN_INSTANCE
argument_list|,
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_open_instance_hf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_transition
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|,
name|XSS_OPEN_INSTANCE
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_instance_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_instance_hf
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_instance
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_instance_hf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_instance_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_instance_hf
argument_list|(
name|xop
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_instance_d
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_instance_hf
argument_list|(
name|NULL
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_do_close_instance
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
name|name
operator|=
name|xsp
operator|->
name|xs_name
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|ssize_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* We need to make a local copy; xo_depth_change will free it */
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_DTRT
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing name without 'dtrt' mode"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s</%s>%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|pre_nl
operator|=
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_PRETTY
argument_list|)
condition|?
literal|"\n"
else|:
literal|""
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s}"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
case|case
name|XO_STYLE_TEXT
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_SDPARAMS
case|:
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_CLOSE_INSTANCE
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_instance_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_transition
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_instance
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_close_instance_h
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_instance_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
return|return
name|xo_close_instance_h
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_instance_d
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xo_close_instance_h
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_do_close_all
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_stack_t
modifier|*
name|limit
parameter_list|)
block|{
name|xo_stack_t
modifier|*
name|xsp
decl_stmt|;
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
name|xo_xsf_flags_t
name|flags
decl_stmt|;
for|for
control|(
name|xsp
operator|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
init|;
name|xsp
operator|>=
name|limit
condition|;
name|xsp
operator|--
control|)
block|{
switch|switch
condition|(
name|xsp
operator|->
name|xs_state
condition|)
block|{
case|case
name|XSS_INIT
case|:
comment|/* Nothing */
name|rc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XSS_OPEN_CONTAINER
case|:
name|rc
operator|=
name|xo_do_close_container
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_OPEN_LIST
case|:
name|rc
operator|=
name|xo_do_close_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_OPEN_INSTANCE
case|:
name|rc
operator|=
name|xo_do_close_instance
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_OPEN_LEAF_LIST
case|:
name|rc
operator|=
name|xo_do_close_leaf_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_MARKER
case|:
name|flags
operator|=
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_MARKER_FLAGS
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|xsp
operator|->
name|xs_name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|XSS_MARKER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|flags
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"close %d failed: %d"
argument_list|,
name|xsp
operator|->
name|xs_state
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This function is responsible for clearing out whatever is needed  * to get to the desired state, if possible.  */
end_comment

begin_function
specifier|static
name|int
name|xo_do_close
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|xo_state_t
name|new_state
parameter_list|)
block|{
name|xo_stack_t
modifier|*
name|xsp
decl_stmt|,
modifier|*
name|limit
init|=
name|NULL
decl_stmt|;
name|ssize_t
name|rc
decl_stmt|;
name|xo_state_t
name|need_state
init|=
name|new_state
decl_stmt|;
if|if
condition|(
name|new_state
operator|==
name|XSS_CLOSE_CONTAINER
condition|)
name|need_state
operator|=
name|XSS_OPEN_CONTAINER
expr_stmt|;
elseif|else
if|if
condition|(
name|new_state
operator|==
name|XSS_CLOSE_LIST
condition|)
name|need_state
operator|=
name|XSS_OPEN_LIST
expr_stmt|;
elseif|else
if|if
condition|(
name|new_state
operator|==
name|XSS_CLOSE_INSTANCE
condition|)
name|need_state
operator|=
name|XSS_OPEN_INSTANCE
expr_stmt|;
elseif|else
if|if
condition|(
name|new_state
operator|==
name|XSS_CLOSE_LEAF_LIST
condition|)
name|need_state
operator|=
name|XSS_OPEN_LEAF_LIST
expr_stmt|;
elseif|else
if|if
condition|(
name|new_state
operator|==
name|XSS_MARKER
condition|)
name|need_state
operator|=
name|XSS_MARKER
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* Unknown or useless new states are ignored */
for|for
control|(
name|xsp
operator|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
init|;
name|xsp
operator|>
name|xop
operator|->
name|xo_stack
condition|;
name|xsp
operator|--
control|)
block|{
comment|/* 	 * Marker's normally stop us from going any further, unless 	 * we are popping a marker (new_state == XSS_MARKER). 	 */
if|if
condition|(
name|xsp
operator|->
name|xs_state
operator|==
name|XSS_MARKER
operator|&&
name|need_state
operator|!=
name|XSS_MARKER
condition|)
block|{
if|if
condition|(
name|name
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"close (xo_%s) fails at marker '%s'; "
literal|"not found '%s'"
argument_list|,
name|xo_state_name
argument_list|(
name|new_state
argument_list|)
argument_list|,
name|xsp
operator|->
name|xs_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|limit
operator|=
name|xsp
expr_stmt|;
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"close stops at marker '%s'"
argument_list|,
name|xsp
operator|->
name|xs_name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|xsp
operator|->
name|xs_state
operator|!=
name|need_state
condition|)
continue|continue;
if|if
condition|(
name|name
operator|&&
name|xsp
operator|->
name|xs_name
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|xsp
operator|->
name|xs_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|limit
operator|=
name|xsp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|limit
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"xo_%s can't find match for '%s'"
argument_list|,
name|xo_state_name
argument_list|(
name|new_state
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rc
operator|=
name|xo_do_close_all
argument_list|(
name|xop
argument_list|,
name|limit
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * We are in a given state and need to transition to the new state.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|xo_transition
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|xo_state_t
name|new_state
parameter_list|)
block|{
name|xo_stack_t
modifier|*
name|xsp
decl_stmt|;
name|ssize_t
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|old_state
decl_stmt|,
name|on_marker
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xsp
operator|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
expr_stmt|;
name|old_state
operator|=
name|xsp
operator|->
name|xs_state
expr_stmt|;
name|on_marker
operator|=
operator|(
name|old_state
operator|==
name|XSS_MARKER
operator|)
expr_stmt|;
comment|/* If there's a marker on top of the stack, we need to find a real state */
while|while
condition|(
name|old_state
operator|==
name|XSS_MARKER
condition|)
block|{
if|if
condition|(
name|xsp
operator|==
name|xop
operator|->
name|xo_stack
condition|)
break|break;
name|xsp
operator|-=
literal|1
expr_stmt|;
name|old_state
operator|=
name|xsp
operator|->
name|xs_state
expr_stmt|;
block|}
comment|/*      * At this point, the list of possible states are:      *   XSS_INIT, XSS_OPEN_CONTAINER, XSS_OPEN_LIST,      *   XSS_OPEN_INSTANCE, XSS_OPEN_LEAF_LIST, XSS_DISCARDING      */
switch|switch
condition|(
name|XSS_TRANSITION
argument_list|(
name|old_state
argument_list|,
name|new_state
argument_list|)
condition|)
block|{
name|open_container
label|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_OPEN_CONTAINER
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_OPEN_CONTAINER
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_OPEN_CONTAINER
argument_list|)
case|:
name|rc
operator|=
name|xo_do_open_container
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_OPEN_CONTAINER
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
goto|goto
name|open_container
goto|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_OPEN_CONTAINER
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_leaf_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
goto|goto
name|open_container
goto|;
break|break;
comment|/*close_container:*/
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|)
case|:
comment|/* This is an exception for "xo --close" */
name|rc
operator|=
name|xo_do_close_container
argument_list|(
name|xop
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_CLOSE_CONTAINER
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_leaf_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
name|rc
operator|=
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
break|break;
name|open_list
label|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_OPEN_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_OPEN_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_OPEN_LIST
argument_list|)
case|:
name|rc
operator|=
name|xo_do_open_list
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_OPEN_LIST
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
goto|goto
name|open_list
goto|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_OPEN_LIST
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_leaf_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
goto|goto
name|open_list
goto|;
break|break;
comment|/*close_list:*/
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_CLOSE_LIST
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_CLOSE_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_CLOSE_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_CLOSE_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_CLOSE_LIST
argument_list|)
case|:
name|rc
operator|=
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
break|break;
name|open_instance
label|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_OPEN_INSTANCE
argument_list|)
case|:
name|rc
operator|=
name|xo_do_open_instance
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_OPEN_INSTANCE
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_OPEN_INSTANCE
argument_list|)
case|:
name|rc
operator|=
name|xo_do_open_list
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
goto|goto
name|open_instance
goto|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_OPEN_INSTANCE
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
block|{
name|rc
operator|=
name|xo_do_open_list
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|xo_do_close_instance
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
goto|goto
name|open_instance
goto|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_OPEN_INSTANCE
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_leaf_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
goto|goto
name|open_instance
goto|;
break|break;
comment|/*close_instance:*/
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_instance
argument_list|(
name|xop
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|)
case|:
comment|/* This one makes no sense; ignore it */
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"xo_close_instance ignored when called from "
literal|"initial state ('%s')"
argument_list|,
name|name
condition|?
else|:
literal|"(unknown)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_CLOSE_INSTANCE
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_leaf_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
name|rc
operator|=
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
break|break;
name|open_leaf_list
label|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_OPEN_LEAF_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_OPEN_LEAF_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_OPEN_LEAF_LIST
argument_list|)
case|:
name|rc
operator|=
name|xo_do_open_leaf_list
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_OPEN_LEAF_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_OPEN_LEAF_LIST
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
condition|)
goto|goto
name|open_leaf_list
goto|;
break|break;
comment|/*close_leaf_list:*/
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_CLOSE_LEAF_LIST
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_leaf_list
argument_list|(
name|xop
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_CLOSE_LEAF_LIST
argument_list|)
case|:
comment|/* Makes no sense; ignore */
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"xo_close_leaf_list ignored when called from "
literal|"initial state ('%s')"
argument_list|,
name|name
condition|?
else|:
literal|"(unknown)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_CLOSE_LEAF_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_CLOSE_LEAF_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_CLOSE_LEAF_LIST
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
break|break;
comment|/*emit:*/
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_EMIT
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_EMIT
argument_list|)
case|:
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_EMIT
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|XSS_CLOSE_LIST
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_EMIT
argument_list|)
case|:
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_EMIT
argument_list|)
case|:
if|if
condition|(
name|on_marker
condition|)
goto|goto
name|marker_prevents_close
goto|;
name|rc
operator|=
name|xo_do_close_leaf_list
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/*emit_leaf_list:*/
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_INIT
argument_list|,
name|XSS_EMIT_LEAF_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_CONTAINER
argument_list|,
name|XSS_EMIT_LEAF_LIST
argument_list|)
case|:
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_INSTANCE
argument_list|,
name|XSS_EMIT_LEAF_LIST
argument_list|)
case|:
name|rc
operator|=
name|xo_do_open_leaf_list
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LEAF_LIST
argument_list|,
name|XSS_EMIT_LEAF_LIST
argument_list|)
case|:
break|break;
case|case
name|XSS_TRANSITION
argument_list|(
name|XSS_OPEN_LIST
argument_list|,
name|XSS_EMIT_LEAF_LIST
argument_list|)
case|:
comment|/* 	 * We need to be backward compatible with the pre-xo_open_leaf_list 	 * API, where both lists and leaf-lists were opened as lists.  So 	 * if we find an open list that hasn't had anything written to it, 	 * we'll accept it. 	 */
break|break;
default|default:
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"unknown transition: (%u -> %u)"
argument_list|,
name|xsp
operator|->
name|xs_state
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
block|}
comment|/* Handle the flush flag */
if|if
condition|(
name|rc
operator|>=
literal|0
operator|&&
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_FLUSH
argument_list|)
condition|)
if|if
condition|(
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
condition|)
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|rc
return|;
name|marker_prevents_close
label|:
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"marker '%s' prevents transition from %s to %s"
argument_list|,
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_name
argument_list|,
name|xo_state_name
argument_list|(
name|old_state
argument_list|)
argument_list|,
name|xo_state_name
argument_list|(
name|new_state
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_marker_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|XSS_MARKER
argument_list|,
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_MARKER_FLAGS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_open_marker
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_marker_h
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_marker_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
return|return
name|xo_do_close
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|XSS_MARKER
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_close_marker
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_close_marker_h
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Record custom output functions into the xo handle, allowing  * integration with a variety of output frameworks.  */
end_comment

begin_function
name|void
name|xo_set_writer
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|,
name|xo_write_func_t
name|write_func
parameter_list|,
name|xo_close_func_t
name|close_func
parameter_list|,
name|xo_flush_func_t
name|flush_func
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_opaque
operator|=
name|opaque
expr_stmt|;
name|xop
operator|->
name|xo_write
operator|=
name|write_func
expr_stmt|;
name|xop
operator|->
name|xo_close
operator|=
name|close_func
expr_stmt|;
name|xop
operator|->
name|xo_flush
operator|=
name|flush_func
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_set_allocator
parameter_list|(
name|xo_realloc_func_t
name|realloc_func
parameter_list|,
name|xo_free_func_t
name|free_func
parameter_list|)
block|{
name|xo_realloc
operator|=
name|realloc_func
expr_stmt|;
name|xo_free
operator|=
name|free_func
expr_stmt|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_flush_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|ssize_t
name|rc
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_ENCODER
case|:
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_FLUSH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|xo_write
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
literal|0
operator|&&
name|xop
operator|->
name|xo_flush
condition|)
if|if
condition|(
name|xop
operator|->
name|xo_flush
argument_list|(
name|xop
operator|->
name|xo_opaque
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_flush
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xo_flush_h
argument_list|(
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_finish_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
init|=
literal|""
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_CLOSE
argument_list|)
condition|)
name|xo_do_close_all
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_stack
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
operator|!
name|XOF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOF_NO_TOP
argument_list|)
condition|)
block|{
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_TOP_EMITTED
argument_list|)
condition|)
name|XOIF_CLEAR
argument_list|(
name|xop
argument_list|,
name|XOIF_TOP_EMITTED
argument_list|)
expr_stmt|;
comment|/* Turn off before output */
else|else
name|cp
operator|=
literal|"{ "
expr_stmt|;
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s%s}\n"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_FINISH
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
return|;
block|}
end_function

begin_function
name|xo_ssize_t
name|xo_finish
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xo_finish_h
argument_list|(
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * xo_finish_atexit is suitable for atexit() calls, to force clear up  * and finalizing output.  */
end_comment

begin_function
name|void
name|xo_finish_atexit
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|xo_finish_h
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate an error message, such as would be displayed on stderr  */
end_comment

begin_function
name|void
name|xo_error_hv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
comment|/*      * If the format string doesn't end with a newline, we pop      * one on ourselves.      */
name|ssize_t
name|len
init|=
name|strlen
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|fmt
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|newfmt
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newfmt
argument_list|,
name|fmt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newfmt
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|newfmt
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fmt
operator|=
name|newfmt
expr_stmt|;
block|}
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_TEXT
case|:
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
literal|"error"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|strlen
argument_list|(
name|fmt
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XOIF_ISSET
argument_list|(
name|xop
argument_list|,
name|XOIF_DIV_OPEN
argument_list|)
condition|)
name|xo_line_close
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xo_write
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_XML
case|:
case|case
name|XO_STYLE_JSON
case|:
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|xo_open_container_h
argument_list|(
name|xop
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|xo_format_value
argument_list|(
name|xop
argument_list|,
literal|"message"
argument_list|,
literal|7
argument_list|,
name|fmt
argument_list|,
name|strlen
argument_list|(
name|fmt
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xo_close_container_h
argument_list|(
name|xop
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_SDPARAMS
case|:
case|case
name|XO_STYLE_ENCODER
case|:
break|break;
block|}
block|}
end_function

begin_function
name|void
name|xo_error_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_error_hv
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate an error message, such as would be displayed on stderr  */
end_comment

begin_function
name|void
name|xo_error
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_error_hv
argument_list|(
name|NULL
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse any libxo-specific options from the command line, removing them  * so the main() argument parsing won't see them.  We return the new value  * for argc or -1 for error.  If an error occurred, the program should  * exit.  A suitable error message has already been displayed.  */
end_comment

begin_function
name|int
name|xo_parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
name|char
name|libxo_opt
index|[]
init|=
literal|"--libxo"
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|save
decl_stmt|;
comment|/* Save our program name for xo_err and friends */
name|xo_program
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|xo_program
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|xo_program
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|save
operator|=
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|libxo_opt
argument_list|,
sizeof|sizeof
argument_list|(
name|libxo_opt
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|save
operator|!=
name|i
condition|)
name|argv
index|[
name|save
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|save
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
name|cp
operator|=
name|argv
index|[
name|i
index|]
operator|+
sizeof|sizeof
argument_list|(
name|libxo_opt
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|cp
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|xo_warnx
argument_list|(
literal|"missing libxo option"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|xo_set_options
argument_list|(
name|NULL
argument_list|,
name|cp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|xo_set_options
argument_list|(
name|NULL
argument_list|,
name|cp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|xo_set_options
argument_list|(
name|NULL
argument_list|,
operator|++
name|cp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"check"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exit
argument_list|(
name|XO_HAS_LIBXO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xo_warnx
argument_list|(
literal|"unknown libxo option: '%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|xo_warnx
argument_list|(
literal|"unknown libxo option: '%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|argv
index|[
name|save
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|save
return|;
block|}
end_function

begin_comment
comment|/*  * Debugging function that dumps the current stack of open libxo constructs,  * suitable for calling from the debugger.  */
end_comment

begin_function
name|void
name|xo_dump_stack
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xo_stack_t
modifier|*
name|xsp
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Stack dump:\n"
argument_list|)
expr_stmt|;
name|xsp
operator|=
name|xop
operator|->
name|xo_stack
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|xsp
operator|++
init|;
name|i
operator|<=
name|xop
operator|->
name|xo_depth
condition|;
name|i
operator|++
operator|,
name|xsp
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   [%d] %s '%s' [%x]\n"
argument_list|,
name|i
argument_list|,
name|xo_state_name
argument_list|(
name|xsp
operator|->
name|xs_state
argument_list|)
argument_list|,
name|xsp
operator|->
name|xs_name
condition|?
else|:
literal|"--"
argument_list|,
name|xsp
operator|->
name|xs_flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Record the program name used for error messages  */
end_comment

begin_function
name|void
name|xo_set_program
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xo_program
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_set_version_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|version
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
operator|||
name|strchr
argument_list|(
name|version
argument_list|,
literal|'"'
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|xo_style_is_encoding
argument_list|(
name|xop
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
comment|/* For XML, we record this as an attribute for the first tag */
name|xo_attr_h
argument_list|(
name|xop
argument_list|,
literal|"version"
argument_list|,
literal|"%s"
argument_list|,
name|version
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
comment|/* 	 * For JSON, we record the version string in our handle, and emit 	 * it in xo_emit_top. 	 */
name|xop
operator|->
name|xo_version
operator|=
name|xo_strndup
argument_list|(
name|version
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_ENCODER
case|:
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_VERSION
argument_list|,
name|NULL
argument_list|,
name|version
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the version number for the API content being carried through  * the xo handle.  */
end_comment

begin_function
name|void
name|xo_set_version
parameter_list|(
specifier|const
name|char
modifier|*
name|version
parameter_list|)
block|{
name|xo_set_version_h
argument_list|(
name|NULL
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a warning.  Normally, this is a text message written to  * standard error.  If the XOF_WARN_XML flag is set, then we generate  * XMLified content on standard output.  */
end_comment

begin_function
name|void
name|xo_emit_warn_hcv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|as_warning
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
return|return;
name|xo_open_marker_h
argument_list|(
name|xop
argument_list|,
literal|"xo_emit_warn_hcv"
argument_list|)
expr_stmt|;
name|xo_open_container_h
argument_list|(
name|xop
argument_list|,
name|as_warning
condition|?
literal|"__warning"
else|:
literal|"__error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_program
condition|)
name|xo_emit
argument_list|(
literal|"{wc:program}"
argument_list|,
name|xo_program
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_XML
operator|||
name|xo_style
argument_list|(
name|xop
argument_list|)
operator|==
name|XO_STYLE_JSON
condition|)
block|{
name|va_list
name|ap
decl_stmt|;
name|xo_handle_t
name|temp
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|xo_style
operator|=
name|XO_STYLE_TEXT
expr_stmt|;
name|xo_buf_init
argument_list|(
operator|&
name|temp
operator|.
name|xo_data
argument_list|)
expr_stmt|;
name|xo_depth_check
argument_list|(
operator|&
name|temp
argument_list|,
name|XO_DEPTH
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|ap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xo_emit_hv
argument_list|(
operator|&
name|temp
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|xo_buffer_t
modifier|*
name|src
init|=
operator|&
name|temp
operator|.
name|xo_data
decl_stmt|;
name|xo_format_value
argument_list|(
name|xop
argument_list|,
literal|"message"
argument_list|,
literal|7
argument_list|,
name|src
operator|->
name|xb_bufp
argument_list|,
name|src
operator|->
name|xb_curp
operator|-
name|src
operator|->
name|xb_bufp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xo_free
argument_list|(
name|temp
operator|.
name|xo_stack
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|xo_emit_hv
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|ssize_t
name|len
init|=
name|strlen
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|fmt
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|code
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
name|xo_emit_h
argument_list|(
name|xop
argument_list|,
literal|": {G:strerror}{g:error/%s}"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|xo_emit
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|xo_close_marker_h
argument_list|(
name|xop
argument_list|,
literal|"xo_emit_warn_hcv"
argument_list|)
expr_stmt|;
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_emit_warn_hc
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_emit_warn_hcv
argument_list|(
name|xop
argument_list|,
literal|1
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_emit_warn_c
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_emit_warn_hcv
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_emit_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|code
init|=
name|errno
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_emit_warn_hcv
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_emit_warnx
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_emit_warn_hcv
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_emit_err_v
parameter_list|(
name|int
name|eval
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|xo_emit_warn_hcv
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_emit_err
parameter_list|(
name|int
name|eval
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|code
init|=
name|errno
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_emit_err_v
argument_list|(
literal|0
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_emit_errx
parameter_list|(
name|int
name|eval
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_emit_err_v
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_emit_errc
parameter_list|(
name|int
name|eval
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_emit_warn_hcv
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the opaque private pointer for an xo handle  */
end_comment

begin_function
name|void
modifier|*
name|xo_get_private
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
return|return
name|xop
operator|->
name|xo_private
return|;
block|}
end_function

begin_comment
comment|/*  * Set the opaque private pointer for an xo handle.  */
end_comment

begin_function
name|void
name|xo_set_private
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_private
operator|=
name|opaque
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the encoder function  */
end_comment

begin_function
name|xo_encoder_func_t
name|xo_get_encoder
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
return|return
name|xop
operator|->
name|xo_encoder
return|;
block|}
end_function

begin_comment
comment|/*  * Record an encoder callback function in an xo handle.  */
end_comment

begin_function
name|void
name|xo_set_encoder
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_encoder_func_t
name|encoder
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_style
operator|=
name|XO_STYLE_ENCODER
expr_stmt|;
name|xop
operator|->
name|xo_encoder
operator|=
name|encoder
expr_stmt|;
block|}
end_function

end_unit

