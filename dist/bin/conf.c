begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: conf.c,v 1.24 2016/04/04 15:52:56 christos Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2015 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Christos Zoulas.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: conf.c,v 1.24 2016/04/04 15:52:56 christos Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBUTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIL_H
end_ifdef

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|"bl.h"
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_include
include|#
directive|include
file|"support.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_struct
struct|struct
name|sockaddr_if
block|{
name|uint8_t
name|sif_len
decl_stmt|;
name|sa_family_t
name|sif_family
decl_stmt|;
name|in_port_t
name|sif_port
decl_stmt|;
name|char
name|sif_name
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIF_NAME
parameter_list|(
name|a
parameter_list|)
define|\
value|((const struct sockaddr_if *)(const void *)(a))->sif_name
end_define

begin_function_decl
specifier|static
name|int
name|conf_is_interface
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FSTAR
value|-1
end_define

begin_define
define|#
directive|define
name|FEQUAL
value|-2
end_define

begin_function
specifier|static
name|void
name|advance
parameter_list|(
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|ep
init|=
operator|*
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|ep
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ep
argument_list|)
condition|)
name|ep
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ep
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ep
argument_list|)
condition|)
operator|*
name|ep
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|p
operator|=
name|ep
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|getnum
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
parameter_list|,
name|void
modifier|*
name|rp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|e
decl_stmt|;
name|intmax_t
name|im
decl_stmt|;
name|int
modifier|*
name|r
init|=
name|rp
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|r
operator|=
name|FSTAR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|local
condition|)
goto|goto
name|out
goto|;
operator|*
name|r
operator|=
name|FEQUAL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|im
operator|=
name|strtoi
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
block|{
operator|*
name|r
operator|=
operator|(
name|int
operator|)
name|im
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s, %zu: Bad number for %s [%s]"
argument_list|,
name|__func__
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|out
label|:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s, %zu: `=' for %s not allowed in local config"
argument_list|,
name|__func__
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getnfail
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
parameter_list|,
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
name|getnum
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
operator|&
name|c
operator|->
name|c_nfail
argument_list|,
literal|"nfail"
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getsecs
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
parameter_list|,
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|e
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|intmax_t
name|tot
decl_stmt|,
name|im
decl_stmt|;
name|tot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|c_duration
operator|=
name|FSTAR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|local
condition|)
goto|goto
name|out
goto|;
name|c
operator|->
name|c_duration
operator|=
name|FEQUAL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|again
label|:
name|im
operator|=
name|strtoi
argument_list|(
name|p
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|ENOTSUP
condition|)
block|{
switch|switch
condition|(
operator|*
name|ep
condition|)
block|{
case|case
literal|'d'
case|:
name|im
operator|*=
literal|24
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'h'
case|:
name|im
operator|*=
literal|60
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'m'
case|:
name|im
operator|*=
literal|60
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'s'
case|:
name|e
operator|=
literal|0
expr_stmt|;
name|tot
operator|+=
name|im
expr_stmt|;
if|if
condition|(
name|ep
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|=
name|ep
operator|+
literal|2
expr_stmt|;
goto|goto
name|again
goto|;
block|}
break|break;
block|}
block|}
else|else
name|tot
operator|=
name|im
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|c_duration
operator|=
operator|(
name|int
operator|)
name|tot
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s, %zu: Bad number [%s]"
argument_list|,
name|__func__
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|out
label|:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s, %zu: `=' duration not allowed in local"
literal|" config"
argument_list|,
name|__func__
argument_list|,
name|f
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getport
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
parameter_list|,
name|void
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|servent
modifier|*
name|sv
decl_stmt|;
comment|// XXX: Pass in the proto instead
if|if
condition|(
operator|(
name|sv
operator|=
name|getservbyname
argument_list|(
name|p
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|r
operator|=
name|ntohs
argument_list|(
name|sv
operator|->
name|s_port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|sv
operator|=
name|getservbyname
argument_list|(
name|p
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|r
operator|=
name|ntohs
argument_list|(
name|sv
operator|->
name|s_port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|getnum
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|r
argument_list|,
literal|"service"
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getmask
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|p
operator|=
name|d
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|d
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|mask
operator|=
name|FSTAR
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|getnum
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|mask
argument_list|,
literal|"mask"
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gethostport
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
parameter_list|,
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
comment|// XXX: Ok to write to string.
name|in_port_t
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|pstr
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|c_port
operator|=
name|FSTAR
expr_stmt|;
name|c
operator|->
name|c_lmask
operator|=
name|FSTAR
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|d
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|']'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pstr
operator|=
name|d
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|pstr
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|getmask
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
operator|&
name|pstr
argument_list|,
operator|&
name|c
operator|->
name|c_lmask
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|d
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|c
operator|->
name|c_ss
decl_stmt|;
if|if
condition|(
name|debug
condition|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: host6 %s"
argument_list|,
name|__func__
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"*"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|p
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_SA_LEN
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|port
operator|=
operator|&
name|sin6
operator|->
name|sin6_port
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pstr
operator|!=
name|p
operator|||
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
operator|||
name|conf_is_interface
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|pstr
operator|==
name|p
condition|)
name|pstr
operator|=
literal|"*"
expr_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|c
operator|->
name|c_ss
decl_stmt|;
name|struct
name|sockaddr_if
modifier|*
name|sif
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|c
operator|->
name|c_ss
decl_stmt|;
if|if
condition|(
name|debug
condition|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: host4 %s"
argument_list|,
name|__func__
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"*"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|conf_is_interface
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|local
condition|)
goto|goto
name|out2
goto|;
if|if
condition|(
name|debug
condition|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: interface %s"
argument_list|,
name|__func__
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lmask
operator|!=
name|FSTAR
condition|)
goto|goto
name|out1
goto|;
name|sif
operator|->
name|sif_family
operator|=
name|AF_MAX
expr_stmt|;
name|strlcpy
argument_list|(
name|sif
operator|->
name|sif_name
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|sif
operator|->
name|sif_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_SA_LEN
name|sif
operator|->
name|sif_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sif
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|port
operator|=
operator|&
name|sif
operator|->
name|sif_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|p
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_SA_LEN
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|port
operator|=
operator|&
name|sin
operator|->
name|sin_port
expr_stmt|;
block|}
else|else
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|getport
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
operator|&
name|c
operator|->
name|c_port
argument_list|,
name|pstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|port
operator|&&
name|c
operator|->
name|c_port
operator|!=
name|FSTAR
operator|&&
name|c
operator|->
name|c_port
operator|!=
name|FEQUAL
condition|)
operator|*
name|port
operator|=
name|htons
argument_list|(
operator|(
name|in_port_t
operator|)
name|c
operator|->
name|c_port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out
label|:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s, %zu: Bad address [%s]"
argument_list|,
name|__func__
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|pstr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|out1
label|:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s, %zu: Can't specify mask %d with "
literal|"interface [%s]"
argument_list|,
name|__func__
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|c
operator|->
name|c_lmask
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|out2
label|:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s, %zu: Interface spec does not make sense "
literal|"with remote config [%s]"
argument_list|,
name|__func__
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getproto
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
name|__unused
parameter_list|,
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"stream"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|c_proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"dgram"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|c_proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|getnum
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
operator|&
name|c
operator|->
name|c_proto
argument_list|,
literal|"protocol"
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getfamily
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
name|__unused
parameter_list|,
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"tcp"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"udp"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|c_family
operator|=
name|p
index|[
literal|3
index|]
operator|==
literal|'6'
condition|?
name|AF_INET6
else|:
name|AF_INET
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|getnum
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
operator|&
name|c
operator|->
name|c_family
argument_list|,
literal|"family"
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getuid
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
name|__unused
parameter_list|,
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|c
operator|->
name|c_uid
operator|=
operator|(
name|int
operator|)
name|pw
operator|->
name|pw_uid
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|getnum
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
operator|&
name|c
operator|->
name|c_uid
argument_list|,
literal|"user"
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getname
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
parameter_list|,
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|getmask
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|c
operator|->
name|c_rmask
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|c
operator|->
name|c_name
argument_list|,
name|rulename
argument_list|,
name|CONFNAMESZ
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|local
condition|)
goto|goto
name|out
goto|;
name|c
operator|->
name|c_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
name|snprintf
argument_list|(
name|c
operator|->
name|c_name
argument_list|,
name|CONFNAMESZ
argument_list|,
literal|"%s%s"
argument_list|,
operator|*
name|p
operator|==
literal|'-'
condition|?
name|rulename
else|:
literal|""
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out
label|:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s, %zu: `=' name not allowed in local"
literal|" config"
argument_list|,
name|__func__
argument_list|,
name|f
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getvalue
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|bool
name|local
parameter_list|,
name|void
modifier|*
name|r
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|int
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|bool
parameter_list|,
name|struct
name|conf
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|char
modifier|*
name|ep
init|=
operator|*
name|p
decl_stmt|;
name|advance
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|fun
call|)
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|r
argument_list|,
name|ep
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|conf_parseline
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|size_t
name|l
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|conf
modifier|*
name|c
parameter_list|,
name|bool
name|local
parameter_list|)
block|{
name|int
name|e
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|memset
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|getvalue
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|c
argument_list|,
operator|&
name|p
argument_list|,
name|gethostport
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|-
literal|1
return|;
name|e
operator|=
name|getvalue
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|c
argument_list|,
operator|&
name|p
argument_list|,
name|getproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|-
literal|1
return|;
name|e
operator|=
name|getvalue
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|c
argument_list|,
operator|&
name|p
argument_list|,
name|getfamily
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|-
literal|1
return|;
name|e
operator|=
name|getvalue
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|c
argument_list|,
operator|&
name|p
argument_list|,
name|getuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|-
literal|1
return|;
name|e
operator|=
name|getvalue
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|c
argument_list|,
operator|&
name|p
argument_list|,
name|getname
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|-
literal|1
return|;
name|e
operator|=
name|getvalue
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|c
argument_list|,
operator|&
name|p
argument_list|,
name|getnfail
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|-
literal|1
return|;
name|e
operator|=
name|getvalue
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|local
argument_list|,
name|c
argument_list|,
operator|&
name|p
argument_list|,
name|getsecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|conf_sort
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|struct
name|conf
modifier|*
name|c1
init|=
name|v1
decl_stmt|;
specifier|const
name|struct
name|conf
modifier|*
name|c2
init|=
name|v2
decl_stmt|;
define|#
directive|define
name|CMP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|f
parameter_list|)
define|\
value|if ((a)->f> (b)->f) return -1; \ 	else if ((a)->f< (b)->f) return 1
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_ss
operator|.
name|ss_family
argument_list|)
expr_stmt|;
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_lmask
argument_list|)
expr_stmt|;
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_port
argument_list|)
expr_stmt|;
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_proto
argument_list|)
expr_stmt|;
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_family
argument_list|)
expr_stmt|;
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_rmask
argument_list|)
expr_stmt|;
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_uid
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CMP
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|conf_is_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|ifaddrs
modifier|*
name|ifa
decl_stmt|;
for|for
control|(
name|ifa
operator|=
name|ifas
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MASK
parameter_list|(
name|m
parameter_list|)
value|((uint32_t)~((1<< (32 - (m))) - 1))
end_define

begin_function
specifier|static
name|int
name|conf_amask_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
specifier|const
name|uint32_t
modifier|*
name|a1
init|=
name|v1
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|a2
init|=
name|v2
decl_stmt|;
name|uint32_t
name|m
decl_stmt|;
name|int
name|omask
init|=
name|mask
decl_stmt|;
name|len
operator|>>=
literal|2
expr_stmt|;
switch|switch
condition|(
name|mask
condition|)
block|{
case|case
name|FSTAR
case|:
if|if
condition|(
name|memcmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
goto|goto
name|out
goto|;
case|case
name|FEQUAL
case|:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: Internal error: bad mask %d"
argument_list|,
name|__func__
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|>
literal|32
condition|)
block|{
name|m
operator|=
name|htonl
argument_list|(
operator|(
name|uint32_t
operator|)
operator|~
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|-=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
condition|)
block|{
name|m
operator|=
name|htonl
argument_list|(
name|MASK
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|a1
index|[
name|i
index|]
operator|&
name|m
operator|)
operator|!=
operator|(
name|a2
index|[
name|i
index|]
operator|&
name|m
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
return|return
literal|1
return|;
name|out
label|:
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|char
name|b1
index|[
literal|256
index|]
decl_stmt|,
name|b2
index|[
literal|256
index|]
decl_stmt|;
name|len
operator|<<=
literal|2
expr_stmt|;
name|blhexdump
argument_list|(
name|b1
argument_list|,
sizeof|sizeof
argument_list|(
name|b1
argument_list|)
argument_list|,
literal|"a1"
argument_list|,
name|v1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|blhexdump
argument_list|(
name|b2
argument_list|,
sizeof|sizeof
argument_list|(
name|b2
argument_list|)
argument_list|,
literal|"a2"
argument_list|,
name|v2
argument_list|,
name|len
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: %s != %s [0x%x]"
argument_list|,
name|__func__
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|,
name|omask
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Apply the mask to the given address  */
end_comment

begin_function
specifier|static
name|void
name|conf_apply_mask
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|uint32_t
modifier|*
name|a
init|=
name|v
decl_stmt|;
name|uint32_t
name|m
decl_stmt|;
switch|switch
condition|(
name|mask
condition|)
block|{
case|case
name|FSTAR
case|:
return|return;
case|case
name|FEQUAL
case|:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: Internal error: bad mask %d"
argument_list|,
name|__func__
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
name|len
operator|>>=
literal|2
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|>
literal|32
condition|)
block|{
name|m
operator|=
name|htonl
argument_list|(
operator|(
name|uint32_t
operator|)
operator|~
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|-=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
condition|)
block|{
name|m
operator|=
name|htonl
argument_list|(
name|MASK
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|m
operator|=
literal|0
expr_stmt|;
name|a
index|[
name|i
index|]
operator|&=
name|m
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * apply the mask and the port to the address given  */
end_comment

begin_function
specifier|static
name|void
name|conf_addr_set
parameter_list|(
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|struct
name|sockaddr_storage
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|in_port_t
modifier|*
name|port
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|alen
decl_stmt|;
name|c
operator|->
name|c_lmask
operator|=
name|c
operator|->
name|c_rmask
expr_stmt|;
name|c
operator|->
name|c_ss
operator|=
operator|*
name|ss
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_ss
operator|.
name|ss_family
operator|!=
name|c
operator|->
name|c_family
condition|)
block|{
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: Internal error: mismatched family "
literal|"%u != %u"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|c_ss
operator|.
name|ss_family
argument_list|,
name|c
operator|->
name|c_family
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|->
name|c_ss
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|c
operator|->
name|c_ss
expr_stmt|;
name|port
operator|=
operator|&
name|sin
operator|->
name|sin_port
expr_stmt|;
name|addr
operator|=
operator|&
name|sin
operator|->
name|sin_addr
expr_stmt|;
name|alen
operator|=
sizeof|sizeof
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|sin6
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|c
operator|->
name|c_ss
expr_stmt|;
name|port
operator|=
operator|&
name|sin6
operator|->
name|sin6_port
expr_stmt|;
name|addr
operator|=
operator|&
name|sin6
operator|->
name|sin6_addr
expr_stmt|;
name|alen
operator|=
sizeof|sizeof
argument_list|(
name|sin6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: Internal error: bad family %u"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|c_ss
operator|.
name|ss_family
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
operator|*
name|port
operator|=
name|htons
argument_list|(
operator|(
name|in_port_t
operator|)
name|c
operator|->
name|c_port
argument_list|)
expr_stmt|;
name|conf_apply_mask
argument_list|(
name|addr
argument_list|,
name|alen
argument_list|,
name|c
operator|->
name|c_lmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_lmask
operator|==
name|FSTAR
condition|)
name|c
operator|->
name|c_lmask
operator|=
call|(
name|int
call|)
argument_list|(
name|alen
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sockaddr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%a:%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|c
operator|->
name|c_ss
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Applied address %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compared two addresses for equality applying the mask  */
end_comment

begin_function
specifier|static
name|int
name|conf_inet_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa1
init|=
name|v1
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa2
init|=
name|v2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|sa1
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|s1
init|=
name|v1
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|s2
init|=
name|v2
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|s1
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
name|v1
operator|=
operator|&
name|s1
operator|->
name|sin_addr
expr_stmt|;
name|v2
operator|=
operator|&
name|s2
operator|->
name|sin_addr
expr_stmt|;
break|break;
block|}
case|case
name|AF_INET6
case|:
block|{
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|s1
init|=
name|v1
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|s2
init|=
name|v2
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|s1
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
name|v1
operator|=
operator|&
name|s1
operator|->
name|sin6_addr
expr_stmt|;
name|v2
operator|=
operator|&
name|s2
operator|->
name|sin6_addr
expr_stmt|;
break|break;
block|}
default|default:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: Internal error: bad family %u"
argument_list|,
name|__func__
argument_list|,
name|sa1
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|conf_amask_eq
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|size
argument_list|,
name|mask
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|conf_addr_in_interface
parameter_list|(
specifier|const
name|struct
name|sockaddr_storage
modifier|*
name|s1
parameter_list|,
specifier|const
name|struct
name|sockaddr_storage
modifier|*
name|s2
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|SIF_NAME
argument_list|(
name|s2
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ifaddrs
modifier|*
name|ifa
decl_stmt|;
for|for
control|(
name|ifa
operator|=
name|ifas
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s1
operator|->
name|ss_family
operator|!=
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
continue|continue;
name|bool
name|eq
decl_stmt|;
switch|switch
condition|(
name|s1
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
name|eq
operator|=
name|conf_inet_eq
argument_list|(
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|s1
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Bad family %u"
argument_list|,
name|s1
operator|->
name|ss_family
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|eq
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|conf_addr_eq
parameter_list|(
specifier|const
name|struct
name|sockaddr_storage
modifier|*
name|s1
parameter_list|,
specifier|const
name|struct
name|sockaddr_storage
modifier|*
name|s2
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
switch|switch
condition|(
name|s2
operator|->
name|ss_family
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|1
return|;
case|case
name|AF_MAX
case|:
return|return
name|conf_addr_in_interface
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|mask
argument_list|)
return|;
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
return|return
name|conf_inet_eq
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|mask
argument_list|)
return|;
default|default:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: Internal error: bad family %u"
argument_list|,
name|__func__
argument_list|,
name|s1
operator|->
name|ss_family
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|conf_eq
parameter_list|(
specifier|const
name|struct
name|conf
modifier|*
name|c1
parameter_list|,
specifier|const
name|struct
name|conf
modifier|*
name|c2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|conf_addr_eq
argument_list|(
operator|&
name|c1
operator|->
name|c_ss
argument_list|,
operator|&
name|c2
operator|->
name|c_ss
argument_list|,
name|c2
operator|->
name|c_lmask
argument_list|)
condition|)
return|return
literal|0
return|;
define|#
directive|define
name|CMP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|f
parameter_list|)
define|\
value|if ((a)->f != (b)->f&& (b)->f != FSTAR&& (b)->f != FEQUAL) { \ 		if (debug> 1) \ 			(*lfun)(LOG_DEBUG, "%s: %s fail %d != %d", __func__, \ 			    __STRING(f), (a)->f, (b)->f); \ 		return 0; \ 	}
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_port
argument_list|)
expr_stmt|;
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_proto
argument_list|)
expr_stmt|;
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_family
argument_list|)
expr_stmt|;
name|CMP
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|c_uid
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CMP
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|conf_num
parameter_list|(
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|l
parameter_list|,
name|int
name|n
parameter_list|)
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|FSTAR
case|:
return|return
literal|"*"
return|;
case|case
name|FEQUAL
case|:
return|return
literal|"="
return|;
default|default:
name|snprintf
argument_list|(
name|b
argument_list|,
name|l
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fmtname
parameter_list|(
specifier|const
name|char
modifier|*
name|n
parameter_list|)
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|rulename
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
literal|"*"
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|n
argument_list|,
name|rulename
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
index|[
name|l
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|n
operator|+
name|l
return|;
else|else
return|return
literal|"*"
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|n
condition|)
return|return
literal|"="
return|;
else|else
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fmtport
parameter_list|(
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|l
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|port
operator|==
name|FSTAR
condition|)
return|return;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|b
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|b
argument_list|,
name|l
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|":%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|b
argument_list|,
name|buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fmtmask
parameter_list|(
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|l
parameter_list|,
name|int
name|fam
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
switch|switch
condition|(
name|mask
condition|)
block|{
case|case
name|FSTAR
case|:
return|return
literal|""
return|;
case|case
name|FEQUAL
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|b
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|""
return|;
else|else
block|{
name|strlcat
argument_list|(
name|b
argument_list|,
literal|"/="
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
default|default:
break|break;
block|}
switch|switch
condition|(
name|fam
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|mask
operator|==
literal|32
condition|)
return|return
literal|""
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|mask
operator|==
literal|128
condition|)
return|return
literal|""
return|;
break|break;
default|default:
break|break;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/%d"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|b
argument_list|,
name|buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|conf_namemask
parameter_list|(
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|l
parameter_list|,
specifier|const
name|struct
name|conf
modifier|*
name|c
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|b
argument_list|,
name|fmtname
argument_list|(
name|c
operator|->
name|c_name
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|fmtmask
argument_list|(
name|b
argument_list|,
name|l
argument_list|,
name|c
operator|->
name|c_family
argument_list|,
name|c
operator|->
name|c_rmask
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|conf_print
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|pref
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
specifier|const
name|struct
name|conf
modifier|*
name|c
parameter_list|)
block|{
name|char
name|ha
index|[
literal|128
index|]
decl_stmt|,
name|hb
index|[
literal|32
index|]
decl_stmt|,
name|b
index|[
literal|5
index|]
index|[
literal|64
index|]
decl_stmt|;
name|int
name|sp
decl_stmt|;
define|#
directive|define
name|N
parameter_list|(
name|n
parameter_list|,
name|v
parameter_list|)
value|conf_num(b[n], sizeof(b[n]), (v))
switch|switch
condition|(
name|c
operator|->
name|c_ss
operator|.
name|ss_family
condition|)
block|{
case|case
literal|0
case|:
name|snprintf
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
argument_list|)
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_MAX
case|:
name|snprintf
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|SIF_NAME
argument_list|(
operator|&
name|c
operator|->
name|c_ss
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sockaddr_snprintf
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
argument_list|)
argument_list|,
literal|"%a"
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|c
operator|->
name|c_ss
argument_list|)
expr_stmt|;
break|break;
block|}
name|fmtmask
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
argument_list|)
argument_list|,
name|c
operator|->
name|c_family
argument_list|,
name|c
operator|->
name|c_lmask
argument_list|)
expr_stmt|;
name|fmtport
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
argument_list|)
argument_list|,
name|c
operator|->
name|c_port
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|*
name|delim
operator|==
literal|'\t'
condition|?
literal|20
else|:
operator|-
literal|1
expr_stmt|;
name|hb
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|delim
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s%*.*s%s%s%s"
literal|"%s%s%s%s"
literal|"%s%s"
literal|"%s%s%s"
argument_list|,
name|pref
argument_list|,
name|sp
argument_list|,
name|sp
argument_list|,
name|ha
argument_list|,
name|delim
argument_list|,
name|N
argument_list|(
literal|0
argument_list|,
name|c
operator|->
name|c_proto
argument_list|)
argument_list|,
name|delim
argument_list|,
name|N
argument_list|(
literal|1
argument_list|,
name|c
operator|->
name|c_family
argument_list|)
argument_list|,
name|delim
argument_list|,
name|N
argument_list|(
literal|2
argument_list|,
name|c
operator|->
name|c_uid
argument_list|)
argument_list|,
name|delim
argument_list|,
name|conf_namemask
argument_list|(
name|hb
argument_list|,
sizeof|sizeof
argument_list|(
name|hb
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|delim
argument_list|,
name|N
argument_list|(
literal|3
argument_list|,
name|c
operator|->
name|c_nfail
argument_list|)
argument_list|,
name|delim
argument_list|,
name|N
argument_list|(
literal|4
argument_list|,
name|c
operator|->
name|c_duration
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%starget:%s, proto:%s, family:%s, "
literal|"uid:%s, name:%s, nfail:%s, duration:%s"
argument_list|,
name|pref
argument_list|,
name|ha
argument_list|,
name|N
argument_list|(
literal|0
argument_list|,
name|c
operator|->
name|c_proto
argument_list|)
argument_list|,
name|N
argument_list|(
literal|1
argument_list|,
name|c
operator|->
name|c_family
argument_list|)
argument_list|,
name|N
argument_list|(
literal|2
argument_list|,
name|c
operator|->
name|c_uid
argument_list|)
argument_list|,
name|conf_namemask
argument_list|(
name|hb
argument_list|,
sizeof|sizeof
argument_list|(
name|hb
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|N
argument_list|(
literal|3
argument_list|,
name|c
operator|->
name|c_nfail
argument_list|)
argument_list|,
name|N
argument_list|(
literal|4
argument_list|,
name|c
operator|->
name|c_duration
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Apply the local config match to the result  */
end_comment

begin_function
specifier|static
name|void
name|conf_apply
parameter_list|(
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|struct
name|conf
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: %s"
argument_list|,
name|__func__
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"merge:\t"
argument_list|,
literal|""
argument_list|,
name|sc
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: %s"
argument_list|,
name|__func__
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"to:\t"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|c
operator|->
name|c_name
argument_list|,
name|sc
operator|->
name|c_name
argument_list|,
name|CONFNAMESZ
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_uid
operator|=
name|sc
operator|->
name|c_uid
expr_stmt|;
name|c
operator|->
name|c_rmask
operator|=
name|sc
operator|->
name|c_rmask
expr_stmt|;
name|c
operator|->
name|c_nfail
operator|=
name|sc
operator|->
name|c_nfail
expr_stmt|;
name|c
operator|->
name|c_duration
operator|=
name|sc
operator|->
name|c_duration
expr_stmt|;
if|if
condition|(
name|debug
condition|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: %s"
argument_list|,
name|__func__
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"result:\t"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Merge a remote configuration to the result  */
end_comment

begin_function
specifier|static
name|void
name|conf_merge
parameter_list|(
name|struct
name|conf
modifier|*
name|c
parameter_list|,
specifier|const
name|struct
name|conf
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: %s"
argument_list|,
name|__func__
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"merge:\t"
argument_list|,
literal|""
argument_list|,
name|sc
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: %s"
argument_list|,
name|__func__
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"to:\t"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|c_name
index|[
literal|0
index|]
condition|)
name|memcpy
argument_list|(
name|c
operator|->
name|c_name
argument_list|,
name|sc
operator|->
name|c_name
argument_list|,
name|CONFNAMESZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|c_uid
operator|!=
name|FEQUAL
condition|)
name|c
operator|->
name|c_uid
operator|=
name|sc
operator|->
name|c_uid
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|c_rmask
operator|!=
name|FEQUAL
condition|)
name|c
operator|->
name|c_lmask
operator|=
name|c
operator|->
name|c_rmask
operator|=
name|sc
operator|->
name|c_rmask
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|c_nfail
operator|!=
name|FEQUAL
condition|)
name|c
operator|->
name|c_nfail
operator|=
name|sc
operator|->
name|c_nfail
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|c_duration
operator|!=
name|FEQUAL
condition|)
name|c
operator|->
name|c_duration
operator|=
name|sc
operator|->
name|c_duration
expr_stmt|;
if|if
condition|(
name|debug
condition|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: %s"
argument_list|,
name|__func__
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"result:\t"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|confset_init
parameter_list|(
name|struct
name|confset
modifier|*
name|cs
parameter_list|)
block|{
name|cs
operator|->
name|cs_c
operator|=
name|NULL
expr_stmt|;
name|cs
operator|->
name|cs_n
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|cs_m
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|confset_grow
parameter_list|(
name|struct
name|confset
modifier|*
name|cs
parameter_list|)
block|{
name|void
modifier|*
name|tc
decl_stmt|;
name|cs
operator|->
name|cs_m
operator|+=
literal|10
expr_stmt|;
name|tc
operator|=
name|realloc
argument_list|(
name|cs
operator|->
name|cs_c
argument_list|,
name|cs
operator|->
name|cs_m
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cs
operator|->
name|cs_c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Can't grow confset (%m)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cs
operator|->
name|cs_c
operator|=
name|tc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|conf
modifier|*
name|confset_get
parameter_list|(
name|struct
name|confset
modifier|*
name|cs
parameter_list|)
block|{
return|return
operator|&
name|cs
operator|->
name|cs_c
index|[
name|cs
operator|->
name|cs_n
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|confset_full
parameter_list|(
specifier|const
name|struct
name|confset
modifier|*
name|cs
parameter_list|)
block|{
return|return
name|cs
operator|->
name|cs_n
operator|==
name|cs
operator|->
name|cs_m
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|confset_sort
parameter_list|(
name|struct
name|confset
modifier|*
name|cs
parameter_list|)
block|{
name|qsort
argument_list|(
name|cs
operator|->
name|cs_c
argument_list|,
name|cs
operator|->
name|cs_n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cs
operator|->
name|cs_c
argument_list|)
argument_list|,
name|conf_sort
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|confset_add
parameter_list|(
name|struct
name|confset
modifier|*
name|cs
parameter_list|)
block|{
name|cs
operator|->
name|cs_n
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|confset_free
parameter_list|(
name|struct
name|confset
modifier|*
name|cs
parameter_list|)
block|{
name|free
argument_list|(
name|cs
operator|->
name|cs_c
argument_list|)
expr_stmt|;
name|confset_init
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|confset_replace
parameter_list|(
name|struct
name|confset
modifier|*
name|dc
parameter_list|,
name|struct
name|confset
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|confset
name|tc
decl_stmt|;
name|tc
operator|=
operator|*
name|dc
expr_stmt|;
operator|*
name|dc
operator|=
operator|*
name|sc
expr_stmt|;
name|confset_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|confset_free
argument_list|(
operator|&
name|tc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|confset_list
parameter_list|(
specifier|const
name|struct
name|confset
modifier|*
name|cs
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"[%s]"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%20.20s\ttype\tproto\towner\tname\tnfail\tduration"
argument_list|,
name|where
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cs
operator|->
name|cs_n
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|"\t"
argument_list|,
operator|&
name|cs
operator|->
name|cs_c
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Match a configuration against the given list and apply the function  * to it, returning the matched entry number.  */
end_comment

begin_function
specifier|static
name|size_t
name|confset_match
parameter_list|(
specifier|const
name|struct
name|confset
modifier|*
name|cs
parameter_list|,
name|struct
name|conf
modifier|*
name|c
parameter_list|,
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|struct
name|conf
modifier|*
parameter_list|,
specifier|const
name|struct
name|conf
modifier|*
parameter_list|)
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cs
operator|->
name|cs_n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|debug
condition|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"check:\t"
argument_list|,
literal|""
argument_list|,
operator|&
name|cs
operator|->
name|cs_c
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf_eq
argument_list|(
name|c
argument_list|,
operator|&
name|cs
operator|->
name|cs_c
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"found:\t"
argument_list|,
literal|""
argument_list|,
operator|&
name|cs
operator|->
name|cs_c
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fun
call|)
argument_list|(
name|c
argument_list|,
operator|&
name|cs
operator|->
name|cs_c
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|conf
modifier|*
name|conf_find
parameter_list|(
name|int
name|fd
parameter_list|,
name|uid_t
name|uid
parameter_list|,
specifier|const
name|struct
name|sockaddr_storage
modifier|*
name|rss
parameter_list|,
name|struct
name|conf
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|proto
decl_stmt|;
name|socklen_t
name|slen
decl_stmt|;
name|struct
name|sockaddr_storage
name|lss
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|memset
argument_list|(
name|cr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cr
argument_list|)
argument_list|)
expr_stmt|;
name|slen
operator|=
sizeof|sizeof
argument_list|(
name|lss
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|lss
argument_list|,
literal|0
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|lss
argument_list|,
operator|&
name|slen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getsockname failed (%m)"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|slen
operator|=
sizeof|sizeof
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TYPE
argument_list|,
operator|&
name|proto
argument_list|,
operator|&
name|slen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getsockopt failed (%m)"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|sockaddr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%a:%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|lss
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"listening socket: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|SOCK_STREAM
case|:
name|cr
operator|->
name|c_proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
break|break;
case|case
name|SOCK_DGRAM
case|:
name|cr
operator|->
name|c_proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unsupported protocol %d"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|lss
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|cr
operator|->
name|c_port
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|lss
operator|)
operator|->
name|sin_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|cr
operator|->
name|c_port
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|lss
operator|)
operator|->
name|sin6_port
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unsupported family %d"
argument_list|,
name|lss
operator|.
name|ss_family
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cr
operator|->
name|c_ss
operator|=
name|lss
expr_stmt|;
name|cr
operator|->
name|c_lmask
operator|=
name|FSTAR
expr_stmt|;
name|cr
operator|->
name|c_uid
operator|=
operator|(
name|int
operator|)
name|uid
expr_stmt|;
name|cr
operator|->
name|c_family
operator|=
name|lss
operator|.
name|ss_family
expr_stmt|;
name|cr
operator|->
name|c_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cr
operator|->
name|c_rmask
operator|=
name|FSTAR
expr_stmt|;
name|cr
operator|->
name|c_nfail
operator|=
name|FSTAR
expr_stmt|;
name|cr
operator|->
name|c_duration
operator|=
name|FSTAR
expr_stmt|;
if|if
condition|(
name|debug
condition|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|conf_print
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"look:\t"
argument_list|,
literal|""
argument_list|,
name|cr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* match the local config */
name|i
operator|=
name|confset_match
argument_list|(
operator|&
name|lconf
argument_list|,
name|cr
argument_list|,
name|conf_apply
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|lconf
operator|.
name|cs_n
condition|)
block|{
if|if
condition|(
name|debug
condition|)
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"not found"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|conf_addr_set
argument_list|(
name|cr
argument_list|,
name|rss
argument_list|)
expr_stmt|;
comment|/* match the remote config */
name|confset_match
argument_list|(
operator|&
name|rconf
argument_list|,
name|cr
argument_list|,
name|conf_merge
argument_list|)
expr_stmt|;
comment|/* to apply the mask */
name|conf_addr_set
argument_list|(
name|cr
argument_list|,
operator|&
name|cr
operator|->
name|c_ss
argument_list|)
expr_stmt|;
return|return
name|cr
return|;
block|}
end_function

begin_function
name|void
name|conf_parse
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|lineno
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|confset
name|lc
decl_stmt|,
name|rc
decl_stmt|,
modifier|*
name|cs
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|lfun
call|)
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Cannot open `%s' (%m)"
argument_list|,
name|__func__
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
name|lineno
operator|=
literal|1
expr_stmt|;
name|confset_init
argument_list|(
operator|&
name|rc
argument_list|)
expr_stmt|;
name|confset_init
argument_list|(
operator|&
name|lc
argument_list|)
expr_stmt|;
name|cs
operator|=
operator|&
name|lc
expr_stmt|;
for|for
control|(
init|;
operator|(
name|line
operator|=
name|fparseln
argument_list|(
name|fp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|lineno
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|free
argument_list|(
name|line
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|line
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"[local]"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cs
operator|=
operator|&
name|lc
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"[remote]"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cs
operator|=
operator|&
name|rc
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|confset_full
argument_list|(
name|cs
argument_list|)
condition|)
block|{
if|if
condition|(
name|confset_grow
argument_list|(
name|cs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|confset_free
argument_list|(
operator|&
name|lc
argument_list|)
expr_stmt|;
name|confset_free
argument_list|(
operator|&
name|rc
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|conf_parseline
argument_list|(
name|f
argument_list|,
name|lineno
argument_list|,
name|line
argument_list|,
name|confset_get
argument_list|(
name|cs
argument_list|)
argument_list|,
name|cs
operator|==
operator|&
name|lc
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|confset_add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|confset_sort
argument_list|(
operator|&
name|lc
argument_list|)
expr_stmt|;
name|confset_sort
argument_list|(
operator|&
name|rc
argument_list|)
expr_stmt|;
name|confset_replace
argument_list|(
operator|&
name|rconf
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
name|confset_replace
argument_list|(
operator|&
name|lconf
argument_list|,
operator|&
name|lc
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|confset_list
argument_list|(
operator|&
name|lconf
argument_list|,
literal|"local"
argument_list|,
literal|"target"
argument_list|)
expr_stmt|;
name|confset_list
argument_list|(
operator|&
name|rconf
argument_list|,
literal|"remote"
argument_list|,
literal|"source"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

