begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: t_fmemopen.c,v 1.4 2013/10/19 17:45:00 christos Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c)2010 Takehiko NOZAKI,  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
end_if

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<features.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|ATF_TC
parameter_list|(
name|arg0
parameter_list|)
value|static void arg0##_head(void)
end_define

begin_define
define|#
directive|define
name|ATF_TC_HEAD
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|)
value|static void arg0##_head()
end_define

begin_define
define|#
directive|define
name|atf_tc_set_md_var
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|,
modifier|...
parameter_list|)
value|do {	\ 	printf(__VA_ARGS__);			\ 	puts("");				\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|ATF_TC_BODY
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|)
value|static void arg0##_body()
end_define

begin_define
define|#
directive|define
name|ATF_CHECK
parameter_list|(
name|arg0
parameter_list|)
value|assert(arg0)
end_define

begin_define
define|#
directive|define
name|ATF_TP_ADD_TCS
parameter_list|(
name|arg0
parameter_list|)
value|int main(void)
end_define

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|)
value|arg1##_head(); arg1##_body()
end_define

begin_define
define|#
directive|define
name|atf_no_error
parameter_list|()
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mode_rwa
index|[]
init|=
block|{
literal|"r"
block|,
literal|"rb"
block|,
literal|"r+"
block|,
literal|"rb+"
block|,
literal|"r+b"
block|,
literal|"w"
block|,
literal|"wb"
block|,
literal|"w+"
block|,
literal|"wb+"
block|,
literal|"w+b"
block|,
literal|"a"
block|,
literal|"ab"
block|,
literal|"a+"
block|,
literal|"ab+"
block|,
literal|"a+b"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mode_r
index|[]
init|=
block|{
literal|"r"
block|,
literal|"rb"
block|,
literal|"r+"
block|,
literal|"rb+"
block|,
literal|"r+b"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mode_w
index|[]
init|=
block|{
literal|"w"
block|,
literal|"wb"
block|,
literal|"w+"
block|,
literal|"wb+"
block|,
literal|"w+b"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mode_a
index|[]
init|=
block|{
literal|"a"
block|,
literal|"ab"
block|,
literal|"a+"
block|,
literal|"ab+"
block|,
literal|"a+b"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|testcase
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|off_t
name|n
decl_stmt|;
block|}
name|testcases
index|[]
init|=
block|{
define|#
directive|define
name|TESTSTR
parameter_list|(
name|s
parameter_list|)
value|{ s, sizeof(s)-1 }
name|TESTSTR
argument_list|(
literal|"\0he quick brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"T\0e quick brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"Th\0 quick brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The\0quick brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The \0uick brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The q\0ick brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The qu\0ck brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The qui\0k brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quic\0 brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick\0brown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick \0rown fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick b\0own fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick br\0wn fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick bro\0n fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brow\0 fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown\0fox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown \0ox jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown f\0x jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fo\0 jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox\0jumps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox \0umps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox j\0mps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox ju\0ps over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jum\0s over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jump\0 over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps\0over the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps \0ver the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps o\0er the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps ov\0r the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps ove\0 the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over\0the lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over \0he lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over t\0e lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over th\0 lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the\0lazy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the \0azy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the l\0zy dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the la\0y dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the laz\0 dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the lazy\0dog"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the lazy \0og"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the lazy d\0g"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the lazy do\0"
argument_list|)
block|,
name|TESTSTR
argument_list|(
literal|"The quick brown fox jumps over the lazy dog"
argument_list|)
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test00
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test00
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test00"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test00
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_rwa
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/*  * Upon successful completion, fmemopen() shall return a pointer to the  * object controlling the stream.  */
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test01
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test01
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test01"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test01
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
index|[]
init|=
block|{
literal|"r+"
block|,
literal|"rb+"
block|,
literal|"r+b"
block|,
literal|"w+"
block|,
literal|"wb+"
block|,
literal|"w+b"
block|,
literal|"a+"
block|,
literal|"ab+"
block|,
literal|"a+b"
block|,
name|NULL
block|}
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
comment|/*  * If a null pointer is specified as the buf argument, fmemopen() shall  * allocate size bytes of memory as if by a call to malloc().  */
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
name|BUFSIZ
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * If buf is a null pointer, the initial position shall always be set  * to the beginning of the buffer.  */
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test02
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test02
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test02"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test02
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_r
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memset
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|0x1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * This position is initially set to either the beginning of the buffer  * (for r and w modes)  */
name|ATF_CHECK
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|0
index|]
operator|==
literal|0x1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/*  * The stream also maintains the size of the current buffer contents.  * For modes r and r+ the size is set to the value given by the size argument.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test03
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test03
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test03"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test03
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_w
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memset
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|0x1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * This position is initially set to either the beginning of the buffer  * (for r and w modes)  */
name|ATF_CHECK
argument_list|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/*  * For modes w and w+ the initial size is zero  */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test04
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test04
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test04"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test04
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/*  * or to the first null byte in the buffer (for a modes)  */
for|for
control|(
name|p
operator|=
operator|&
name|mode_a
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memset
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|0x1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|0
index|]
operator|==
literal|0x1
argument_list|)
expr_stmt|;
comment|/* If no null byte is found in append mode,  * the initial position is set to one byte after the end of the buffer.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  * and for modes a and a+ the initial size is either the position of the  * first null byte in the buffer or the value of the size argument  * if no null byte is found.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test05
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test05
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test05"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test05
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_rwa
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
comment|/*  * Otherwise, a null pointer shall be returned, and errno shall be set  * to indicate the error.  */
name|errno
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|errno
operator|==
name|EINVAL
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|errno
operator|==
name|EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test06
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test06
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test06"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test06
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
index|[]
init|=
block|{
literal|""
block|,
literal|" "
block|,
literal|"???"
block|,
name|NULL
block|}
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
comment|/*  * The value of the mode argument is not valid.  */
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|errno
operator|==
name|EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test07
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test07
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test07"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test07
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
index|[]
init|=
block|{
literal|"r"
block|,
literal|"rb"
block|,
literal|"w"
block|,
literal|"wb"
block|,
literal|"a"
block|,
literal|"ab"
block|,
name|NULL
block|}
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
comment|/*  * Because this feature is only useful when the stream is opened for updating  * (because there is no way to get a pointer to the buffer) the fmemopen()  * call may fail if the mode argument does not include a '+' .   */
name|errno
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|errno
operator|==
name|EINVAL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test08
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test08
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test08"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test08
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
index|[]
init|=
block|{
literal|"r+"
block|,
literal|"rb+"
block|,
literal|"r+b"
block|,
literal|"w+"
block|,
literal|"wb+"
block|,
literal|"w+b"
block|,
literal|"a+"
block|,
literal|"ab+"
block|,
literal|"a+b"
block|,
name|NULL
block|}
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
comment|/*  * The buf argument is a null pointer and the allocation of a buffer of  * length size has failed.  */
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
name|SIZE_MAX
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|errno
operator|==
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * test09 - test14:  * An attempt to seek a memory buffer stream to a negative position or to a  * position larger than the buffer size given in the size argument shall fail.  */
end_comment

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test09
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test09
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test09"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test09
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|off_t
name|i
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|mode_rwa
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_seek(SEEK_SET)  */
comment|/* zero */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* positive */
for|for
control|(
name|i
operator|=
operator|(
name|off_t
operator|)
literal|1
init|;
name|i
operator|<=
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
name|i
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* positive + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
name|t
operator|->
name|n
operator|+
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
comment|/* negative + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mode_rw
index|[]
init|=
block|{
literal|"r"
block|,
literal|"rb"
block|,
literal|"r+"
block|,
literal|"rb+"
block|,
literal|"r+b"
block|,
literal|"w"
block|,
literal|"wb"
block|,
literal|"w+"
block|,
literal|"wb+"
block|,
literal|"w+b"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test10
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test10
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test10"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test10
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
name|off_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|mode_rw
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_seek(SEEK_CUR)  */
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* zero */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* negative& OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* positive */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* positive& OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test11
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test11
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test11"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test11
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
name|off_t
name|len
decl_stmt|,
name|rest
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* test fmemopen_seek(SEEK_CUR) */
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
name|len
operator|=
operator|(
name|off_t
operator|)
name|strnlen
argument_list|(
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|rest
operator|=
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|-
name|len
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_a
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_seek(SEEK_CUR)  */
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
if|if
condition|(
name|i
operator|<
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
condition|)
block|{
endif|#
directive|endif
comment|/* zero */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
comment|/* posive */
for|for
control|(
name|i
operator|=
operator|(
name|off_t
operator|)
literal|1
init|;
name|i
operator|<=
name|rest
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* positive + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
comment|/* negative */
for|for
control|(
name|i
operator|=
operator|(
name|off_t
operator|)
literal|1
init|;
name|i
operator|<=
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* negative + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
block|}
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test12
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test12
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test12"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test12
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
name|off_t
name|len
decl_stmt|,
name|rest
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* test fmemopen_seek(SEEK_END) */
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
name|len
operator|=
operator|(
name|off_t
operator|)
name|strnlen
argument_list|(
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|rest
operator|=
name|t
operator|->
name|n
operator|-
name|len
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_r
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_seek(SEEK_END)  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* zero */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
comment|/* positive + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
name|rest
operator|+
literal|1
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
comment|/* negative + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|-
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
comment|/* positive */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|rest
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
name|i
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* negative */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|-
name|i
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test13
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test13
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test13"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test13
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
name|off_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* test fmemopen_seek(SEEK_END) */
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|mode_w
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_seek(SEEK_END)  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* zero */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* positive + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|+
literal|1
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* negative + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|-
literal|1
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* positive */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|t
operator|->
name|n
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
name|i
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test14
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test14
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test14"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test14
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
name|off_t
name|len
decl_stmt|,
name|rest
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* test fmemopen_seek(SEEK_END) */
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
name|len
operator|=
operator|(
name|off_t
operator|)
name|strnlen
argument_list|(
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|rest
operator|=
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|-
name|len
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_a
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_seek(SEEK_END)  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
comment|/* zero */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
comment|/* positive + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
name|rest
operator|+
literal|1
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
comment|/* negative + OOB */
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|-
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
comment|/* positive */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|rest
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
name|i
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* negative */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|-
name|i
argument_list|,
name|SEEK_END
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mode_rw1
index|[]
init|=
block|{
literal|"r"
block|,
literal|"rb"
block|,
literal|"r+"
block|,
literal|"rb+"
block|,
literal|"r+b"
block|,
literal|"w+"
block|,
literal|"wb+"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* test15 - 18:  * When a stream open for writing is flushed or closed, a null byte is written  * at the current position or at the end of the buffer, depending on the size  * of the contents.  */
end_comment

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test15
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test15
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test15"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test15
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf0
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|mode_rw1
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf0
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf0
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_read + fgetc(3)  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|n
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|==
name|buf0
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK
argument_list|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test16
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test16"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test16
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf0
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|mode_rw1
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf0
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|buf1
index|[
name|t
operator|->
name|n
index|]
operator|=
literal|0x1
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf0
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_read + fread(4)  */
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fread
argument_list|(
operator|&
name|buf1
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
operator|(
name|size_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|memcmp
argument_list|(
operator|&
name|buf0
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf1
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf1
index|[
name|t
operator|->
name|n
index|]
operator|==
literal|0x1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mode_a1
index|[]
init|=
block|{
literal|"a+"
block|,
literal|"ab+"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test17
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test17
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test17"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test17
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
name|len
operator|=
name|strnlen
argument_list|(
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_a1
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_read + fgetc(3)  */
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
if|if
condition|(
name|i
operator|<
name|t
operator|->
name|n
condition|)
block|{
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|<
name|t
operator|->
name|n
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|==
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK
argument_list|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|n
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|==
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ATF_CHECK
argument_list|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
block|}
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test18
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test18
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test18"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test18
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf0
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
name|len
operator|=
name|strnlen
argument_list|(
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_a1
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf0
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|buf1
index|[
name|t
operator|->
name|n
operator|-
name|len
index|]
operator|=
literal|0x1
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf0
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_read + fread(3)  */
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
if|if
condition|(
name|i
operator|<
name|t
operator|->
name|n
condition|)
block|{
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fread
argument_list|(
operator|&
name|buf1
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|t
operator|->
name|n
operator|-
name|len
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|!
name|memcmp
argument_list|(
operator|&
name|buf0
index|[
name|len
index|]
argument_list|,
operator|&
name|buf1
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
operator|-
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf1
index|[
name|t
operator|->
name|n
operator|-
name|len
index|]
operator|==
literal|0x1
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|buf1
index|[
name|t
operator|->
name|n
index|]
operator|=
literal|0x1
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fread
argument_list|(
operator|&
name|buf1
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
operator|(
name|size_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|!
name|memcmp
argument_list|(
operator|&
name|buf0
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf1
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf1
index|[
name|t
operator|->
name|n
index|]
operator|==
literal|0x1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
block|}
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * test19 - test22:  * If a stream open for update is flushed or closed and the last write has  * advanced the current buffer size, a null byte is written at the end of the  * buffer if it fits.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mode_rw2
index|[]
init|=
block|{
literal|"r+"
block|,
literal|"rb+"
block|,
literal|"r+b"
block|,
literal|"w"
block|,
literal|"wb"
block|,
literal|"w+"
block|,
literal|"wb+"
block|,
literal|"w+b"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test19
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test19
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test19"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test19
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|mode_rw2
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|buf
index|[
name|t
operator|->
name|n
index|]
operator|=
literal|0x1
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
operator|+
literal|1
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_write + fputc(3)  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|n
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fputc
argument_list|(
name|t
operator|->
name|s
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
operator|==
name|t
operator|->
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|buf
index|[
name|i
index|]
operator|==
name|t
operator|->
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|buf
index|[
name|i
index|]
operator|==
name|t
operator|->
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
name|ATF_CHECK
argument_list|(
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* don't accept non nul character at end of buffer */
name|ATF_CHECK
argument_list|(
name|fputc
argument_list|(
literal|0x1
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* accept nul character at end of buffer */
name|ATF_CHECK
argument_list|(
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|fp
argument_list|)
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* reach EOF */
name|ATF_CHECK
argument_list|(
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* compare */
name|ATF_CHECK
argument_list|(
name|memcmp
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|buf
index|[
name|t
operator|->
name|n
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test20
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test20
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test20"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test20
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|mode_rw2
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|buf
index|[
name|t
operator|->
name|n
index|]
operator|=
literal|0x1
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
operator|+
literal|1
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fwrite
argument_list|(
name|t
operator|->
name|s
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|n
argument_list|,
name|fp
argument_list|)
operator|==
operator|(
name|size_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_write + fwrite(3)  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
name|ATF_CHECK
argument_list|(
name|buf
index|[
name|t
operator|->
name|n
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* don't accept non nul character at end of buffer */
name|ATF_CHECK
argument_list|(
name|fwrite
argument_list|(
literal|"\x1"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* accept nul character at end of buffer */
name|ATF_CHECK
argument_list|(
name|fwrite
argument_list|(
literal|"\x0"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* reach EOF */
name|ATF_CHECK
argument_list|(
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* compare */
name|ATF_CHECK
argument_list|(
name|memcmp
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|buf
index|[
name|t
operator|->
name|n
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test21
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test21
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test21"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test21
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
name|len
operator|=
name|strnlen
argument_list|(
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_a
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|s
argument_list|,
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_write + fputc(3)  */
if|if
condition|(
name|len
operator|<
name|t
operator|->
name|n
condition|)
block|{
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|<
name|t
operator|->
name|n
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fputc
argument_list|(
name|t
operator|->
name|s
index|[
name|i
operator|-
name|len
index|]
argument_list|,
name|fp
argument_list|)
operator|==
name|t
operator|->
name|s
index|[
name|i
operator|-
name|len
index|]
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|buf
index|[
name|i
index|]
operator|==
name|t
operator|->
name|s
index|[
name|i
operator|-
name|len
index|]
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
name|ATF_CHECK
argument_list|(
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* don't accept non nul character at end of buffer */
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fputc
argument_list|(
literal|0x1
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* accept nul character at end of buffer */
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|fp
argument_list|)
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* reach EOF */
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftello
argument_list|(
name|fp
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|t
operator|->
name|n
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|test22
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|test22
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"test22"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|test22
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|struct
name|testcase
modifier|*
name|t0
decl_stmt|,
modifier|*
name|t1
decl_stmt|;
name|size_t
name|len0
decl_stmt|,
name|len1
decl_stmt|,
name|nleft
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|t0
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t0
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t0
control|)
block|{
name|len0
operator|=
name|strnlen
argument_list|(
name|t0
operator|->
name|s
argument_list|,
name|t0
operator|->
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|t1
operator|=
operator|&
name|testcases
index|[
literal|0
index|]
init|;
name|t1
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|t1
control|)
block|{
name|len1
operator|=
name|strnlen
argument_list|(
name|t1
operator|->
name|s
argument_list|,
name|t1
operator|->
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mode_a
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t0
operator|->
name|s
argument_list|,
name|t0
operator|->
name|n
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|t0
operator|->
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * test fmemopen_write + fwrite(3)  */
name|nleft
operator|=
name|t0
operator|->
name|n
operator|-
name|len0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
if|if
condition|(
name|nleft
operator|==
literal|0
operator|||
name|len1
operator|==
name|nleft
operator|-
literal|1
condition|)
block|{
name|ATF_CHECK
argument_list|(
name|fwrite
argument_list|(
name|t1
operator|->
name|s
argument_list|,
literal|1
argument_list|,
name|t1
operator|->
name|n
argument_list|,
name|fp
argument_list|)
operator|==
name|nleft
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftell
argument_list|(
name|fp
argument_list|)
operator|==
name|t1
operator|->
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ATF_CHECK
argument_list|(
name|fwrite
argument_list|(
name|t1
operator|->
name|s
argument_list|,
literal|1
argument_list|,
name|t1
operator|->
name|n
argument_list|,
name|fp
argument_list|)
operator|==
name|nleft
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ATF_CHECK
argument_list|(
name|ftell
argument_list|(
name|fp
argument_list|)
operator|==
name|t1
operator|->
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ATF_CHECK
argument_list|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|ATF_TP_ADD_TCS
argument_list|(
argument|tp
argument_list|)
end_macro

begin_block
block|{
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test00
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test01
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test02
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test03
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test04
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test05
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test06
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test07
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test08
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test09
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test10
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test11
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test12
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test13
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test14
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test15
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test16
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test17
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test18
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test19
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test20
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test21
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|test22
argument_list|)
expr_stmt|;
return|return
name|atf_no_error
argument_list|()
return|;
block|}
end_block

end_unit

