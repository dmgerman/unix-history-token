begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: t_basedirname.c,v 1.2 2011/07/07 09:49:59 jruoho Exp $	*/
end_comment

begin_comment
comment|/*  * Regression test for basename(3).  *  * Written by Jason R. Thorpe<thorpej@NetBSD.org>, Oct. 2002.  * Public domain.  */
end_comment

begin_include
include|#
directive|include
file|<atf-c.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_struct
struct|struct
block|{
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
specifier|const
name|char
modifier|*
name|output
decl_stmt|;
block|}
name|test_basename_table
index|[]
init|=
block|{
comment|/*  * The following are taken from the "Sample Input and Output Strings  * for basename()" table in IEEE Std 1003.1-2001.  */
block|{
literal|"/usr/lib"
block|,
literal|"lib"
block|}
block|,
block|{
literal|"/usr/"
block|,
literal|"usr"
block|}
block|,
block|{
literal|"/"
block|,
literal|"/"
block|}
block|,
block|{
literal|"///"
block|,
literal|"/"
block|}
block|,
block|{
literal|"//usr//lib//"
block|,
literal|"lib"
block|}
block|,
comment|/*  * IEEE Std 1003.1-2001:  *  *	If path is a null pointer or points to an empty string,  *	basename() shall return a pointer to the string "." .  */
block|{
literal|""
block|,
literal|"."
block|}
block|,
block|{
name|NULL
block|,
literal|"."
block|}
block|,
comment|/*  * IEEE Std 1003.1-2001:  *  *	If the string is exactly "//", it is implementation-defined  *	whether "/" or "//" is returned.  *  * The NetBSD implementation returns "/".  */
block|{
literal|"//"
block|,
literal|"/"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_struct
struct|struct
block|{
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
specifier|const
name|char
modifier|*
name|output
decl_stmt|;
block|}
name|test_dirname_table
index|[]
init|=
block|{
comment|/*  * The following are taken from the "Sample Input and Output Strings  * for dirname()" table in IEEE Std 1003.1-2001.  */
block|{
literal|"/usr/lib"
block|,
literal|"/usr"
block|}
block|,
block|{
literal|"/usr/"
block|,
literal|"/"
block|}
block|,
block|{
literal|"usr"
block|,
literal|"."
block|}
block|,
block|{
literal|"/"
block|,
literal|"/"
block|}
block|,
block|{
literal|"."
block|,
literal|"."
block|}
block|,
block|{
literal|".."
block|,
literal|"."
block|}
block|,
comment|/*  * IEEE Std 1003.1-2001:  *  *	If path is a null pointer or points to an empty string,  *	dirname() shall return a pointer to the string "." .  */
block|{
literal|""
block|,
literal|"."
block|}
block|,
block|{
name|NULL
block|,
literal|"."
block|}
block|,
comment|/*  * IEEE Std 1003.1-2001:  *  *	Since the meaning of the leading "//" is implementation-defined,  *	dirname("//foo") may return either "//" or "/" (but nothing else).  *  * The NetBSD implementation returns "/".  */
block|{
literal|"//foo"
block|,
literal|"/"
block|}
block|,
comment|/*  * Make sure the trailing slashes after the directory name component  * get trimmed.  The Std does not talk about this, but this is what  * Solaris 8's dirname(3) does.  */
block|{
literal|"/usr///lib"
block|,
literal|"/usr"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|ATF_TC
argument_list|(
name|basename_posix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|basename_posix
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Test basename(3) with POSIX examples"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|basename_posix
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|char
name|testbuf
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|test_basename_table
index|[
name|i
index|]
operator|.
name|output
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|test_basename_table
index|[
name|i
index|]
operator|.
name|input
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|test_basename_table
index|[
name|i
index|]
operator|.
name|input
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|testbuf
argument_list|)
condition|)
name|atf_tc_skip
argument_list|(
literal|"Testbuf too small!"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|testbuf
argument_list|,
name|test_basename_table
index|[
name|i
index|]
operator|.
name|input
argument_list|)
expr_stmt|;
name|base
operator|=
name|basename
argument_list|(
name|testbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|base
operator|=
name|basename
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * basename(3) is allowed to modify the input buffer. 		 * However, that is considered hostile by some programs, 		 * and so we elect to consider this an error. 		 * 		 * This is not a problem, as basename(3) is also allowed 		 * to return a pointer to a statically-allocated buffer 		 * (it is explicitly not required to be reentrant). 		 */
if|if
condition|(
name|test_basename_table
index|[
name|i
index|]
operator|.
name|input
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|test_basename_table
index|[
name|i
index|]
operator|.
name|input
argument_list|,
name|testbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Input buffer for \"%s\" was modified\n"
argument_list|,
name|test_basename_table
index|[
name|i
index|]
operator|.
name|input
argument_list|)
expr_stmt|;
name|atf_tc_fail
argument_list|(
literal|"Input buffer was modified."
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the result is correct. */
if|if
condition|(
name|strcmp
argument_list|(
name|test_basename_table
index|[
name|i
index|]
operator|.
name|output
argument_list|,
name|base
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Input \"%s\", output \"%s\", expected \"%s\"\n"
argument_list|,
name|test_basename_table
index|[
name|i
index|]
operator|.
name|input
operator|==
name|NULL
condition|?
literal|"(null)"
else|:
name|test_basename_table
index|[
name|i
index|]
operator|.
name|input
argument_list|,
name|base
argument_list|,
name|test_basename_table
index|[
name|i
index|]
operator|.
name|output
argument_list|)
expr_stmt|;
name|atf_tc_fail
argument_list|(
literal|"Output does not match expected value."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ATF_TC
argument_list|(
name|dirname_posix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ATF_TC_HEAD
argument_list|(
argument|dirname_posix
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|atf_tc_set_md_var
argument_list|(
name|tc
argument_list|,
literal|"descr"
argument_list|,
literal|"Test dirname(3) with POSIX examples"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ATF_TC_BODY
argument_list|(
argument|dirname_posix
argument_list|,
argument|tc
argument_list|)
end_macro

begin_block
block|{
name|char
name|testbuf
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|output
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|input
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|input
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|testbuf
argument_list|)
condition|)
name|atf_tc_skip
argument_list|(
literal|"Testbuf too small!"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|testbuf
argument_list|,
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|input
argument_list|)
expr_stmt|;
name|base
operator|=
name|dirname
argument_list|(
name|testbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|base
operator|=
name|dirname
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * dirname(3) is allowed to modify the input buffer. 		 * However, that is considered hostile by some programs, 		 * and so we elect to consider this an error. 		 * 		 * This is not a problem, as dirname(3) is also allowed 		 * to return a pointer to a statically-allocated buffer 		 * (it is explicitly not required to be reentrant). 		 */
if|if
condition|(
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|input
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|input
argument_list|,
name|testbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Input buffer for \"%s\" was modified\n"
argument_list|,
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|input
argument_list|)
expr_stmt|;
name|atf_tc_fail
argument_list|(
literal|"Input buffer was modified."
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the result is correct. */
if|if
condition|(
name|strcmp
argument_list|(
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|output
argument_list|,
name|base
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Input \"%s\", output \"%s\", expected \"%s\"\n"
argument_list|,
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|input
operator|==
name|NULL
condition|?
literal|"(null)"
else|:
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|input
argument_list|,
name|base
argument_list|,
name|test_dirname_table
index|[
name|i
index|]
operator|.
name|output
argument_list|)
expr_stmt|;
name|atf_tc_fail
argument_list|(
literal|"Output does not match expected value."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|ATF_TP_ADD_TCS
argument_list|(
argument|tp
argument_list|)
end_macro

begin_block
block|{
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|basename_posix
argument_list|)
expr_stmt|;
name|ATF_TP_ADD_TC
argument_list|(
name|tp
argument_list|,
name|dirname_posix
argument_list|)
expr_stmt|;
return|return
name|atf_no_error
argument_list|()
return|;
block|}
end_block

end_unit

