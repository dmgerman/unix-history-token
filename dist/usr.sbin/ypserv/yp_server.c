begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"yp_extern.h"
end_include

begin_include
include|#
directive|include
file|"yp.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: yp_server.c,v 1.18 1995/12/16 04:01:55 wpaul Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_decl_stmt
name|int
name|forked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|children
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DB
modifier|*
name|spec_dbp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Special global DB handle for ypproc_all. */
end_comment

begin_function
name|void
modifier|*
name|ypproc_null_2_svc
parameter_list|(
name|void
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|result
decl_stmt|;
specifier|static
name|char
name|rval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|result
operator|=
operator|&
name|rval
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
modifier|*
name|ypproc_domain_2_svc
parameter_list|(
name|domainname
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|bool_t
name|result
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|==
name|NULL
operator|||
name|yp_validdomain
argument_list|(
operator|*
name|argp
argument_list|)
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
else|else
name|result
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
modifier|*
name|ypproc_domain_nonack_2_svc
parameter_list|(
name|domainname
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|bool_t
name|result
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|argp
operator|==
name|NULL
operator|||
name|yp_validdomain
argument_list|(
operator|*
name|argp
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
name|result
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|ypresp_val
modifier|*
name|ypproc_match_2_svc
parameter_list|(
name|ypreq_key
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_val
name|result
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
operator|||
name|argp
operator|->
name|map
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
name|argp
operator|->
name|domain
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|key
operator|.
name|size
operator|=
name|argp
operator|->
name|key
operator|.
name|keydat_len
expr_stmt|;
name|key
operator|.
name|data
operator|=
name|argp
operator|->
name|key
operator|.
name|keydat_val
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|yp_get_record
argument_list|(
name|argp
operator|->
name|domain
argument_list|,
name|argp
operator|->
name|map
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|data
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|data
operator|.
name|data
expr_stmt|;
block|}
comment|/* 	 * Do DNS lookups for hosts maps if database lookup failed. 	 */
if|if
condition|(
name|do_dns
operator|&&
name|result
operator|.
name|stat
operator|!=
name|YP_TRUE
operator|&&
name|strstr
argument_list|(
name|argp
operator|->
name|map
argument_list|,
literal|"hosts"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|rval
decl_stmt|;
comment|/* DNS lookups can take time -- do them in a subprocess */
if|if
condition|(
operator|!
name|debug
operator|&&
name|children
operator|<
name|MAX_CHILDREN
operator|&&
name|fork
argument_list|()
condition|)
block|{
name|children
operator|++
expr_stmt|;
name|forked
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Returning NULL here prevents svc_sendreply() 			 * from being called by the parent. This is vital 			 * since having both the parent and the child process 			 * call it would confuse the client. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|forked
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"Doing DNS lookup of %.*s"
argument_list|,
name|argp
operator|->
name|key
operator|.
name|keydat_len
argument_list|,
name|argp
operator|->
name|key
operator|.
name|keydat_val
argument_list|)
expr_stmt|;
comment|/* NUL terminate! NUL terminate!! NUL TERMINATE!!! */
name|argp
operator|->
name|key
operator|.
name|keydat_val
index|[
name|argp
operator|->
name|key
operator|.
name|keydat_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argp
operator|->
name|map
argument_list|,
literal|"hosts.byname"
argument_list|)
condition|)
name|rval
operator|=
name|yp_dnsname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argp
operator|->
name|key
operator|.
name|keydat_val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argp
operator|->
name|map
argument_list|,
literal|"hosts.byaddr"
argument_list|)
condition|)
name|rval
operator|=
name|yp_dnsaddr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|argp
operator|->
name|key
operator|.
name|keydat_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"DNS lookup successful. Result: %s"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|strlen
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|rval
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|YP_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"DNS lookup failed."
argument_list|)
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|YP_NOKEY
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|ypresp_key_val
modifier|*
name|ypproc_first_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_key_val
name|result
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|DB
modifier|*
name|dbp
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
name|argp
operator|->
name|domain
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dbp
operator|=
name|yp_open_db
argument_list|(
name|argp
operator|->
name|domain
argument_list|,
name|argp
operator|->
name|map
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|yp_errno
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|key
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|key
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|yp_first_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|key
operator|.
name|keydat_len
operator|=
name|key
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|key
operator|.
name|keydat_val
operator|=
name|key
operator|.
name|data
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|data
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|data
operator|.
name|data
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|ypresp_key_val
modifier|*
name|ypproc_next_2_svc
parameter_list|(
name|ypreq_key
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_key_val
name|result
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|DB
modifier|*
name|dbp
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
operator|||
name|argp
operator|->
name|map
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
name|argp
operator|->
name|domain
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dbp
operator|=
name|yp_open_db
argument_list|(
name|argp
operator|->
name|domain
argument_list|,
name|argp
operator|->
name|map
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|yp_errno
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|key
operator|.
name|size
operator|=
name|argp
operator|->
name|key
operator|.
name|keydat_len
expr_stmt|;
name|key
operator|.
name|data
operator|=
name|argp
operator|->
name|key
operator|.
name|keydat_val
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|yp_next_record
argument_list|(
name|dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|dbp
operator|->
name|close
argument_list|)
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|key
operator|.
name|keydat_len
operator|=
name|key
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|key
operator|.
name|keydat_val
operator|=
name|key
operator|.
name|data
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|data
operator|.
name|size
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|data
operator|.
name|data
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|ypresp_xfr
modifier|*
name|ypproc_xfr_2_svc
parameter_list|(
name|ypreq_xfr
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_xfr
name|result
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map_parms
operator|.
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_REFUSED
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|map_parms
operator|.
name|domain
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
name|argp
operator|->
name|map_parms
operator|.
name|domain
argument_list|)
condition|)
block|{
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_NODOM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|g
index|[
literal|11
index|]
decl_stmt|,
name|t
index|[
literal|11
index|]
decl_stmt|,
name|p
index|[
literal|11
index|]
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|char
name|ypxfr_command
index|[
name|MAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ypxfr_command
argument_list|,
literal|"%sypxfr"
argument_list|,
name|_PATH_LIBEXEC
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%u"
argument_list|,
name|argp
operator|->
name|transid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|g
argument_list|,
literal|"%u"
argument_list|,
name|argp
operator|->
name|prog
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%u"
argument_list|,
name|argp
operator|->
name|port
argument_list|)
expr_stmt|;
name|children
operator|++
expr_stmt|;
name|forked
operator|=
literal|0
expr_stmt|;
name|execl
argument_list|(
name|ypxfr_command
argument_list|,
literal|"ypxfr"
argument_list|,
literal|"-d"
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|domain
argument_list|,
literal|"-h"
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|peer
argument_list|,
literal|"-f"
argument_list|,
literal|"-C"
argument_list|,
name|t
argument_list|,
name|g
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|p
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|yp_error
argument_list|(
literal|"ypxfr execl(): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
case|case
operator|-
literal|1
case|:
name|yp_error
argument_list|(
literal|"ypxfr fork(): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_XFRERR
expr_stmt|;
break|break;
default|default:
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_SUCC
expr_stmt|;
name|forked
operator|++
expr_stmt|;
break|break;
block|}
name|result
operator|.
name|transid
operator|=
name|argp
operator|->
name|transid
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ypproc_clear_2_svc
parameter_list|(
name|void
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|result
decl_stmt|;
specifier|static
name|char
name|rval
init|=
literal|0
decl_stmt|;
comment|/* 	 * We don't have to do anything for ypproc_clear. Unlike 	 * the SunOS ypserv, we don't hold out database descriptors 	 * open forever. 	 */
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|result
operator|=
operator|&
name|rval
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For ypproc_all, we have to send a stream of ypresp_all structures  * via TCP, but the XDR filter generated from the yp.x protocol  * definition file only serializes one such structure. This means that  * to send the whole stream, you need a wrapper which feeds all the  * records into the underlying XDR routine until it hits an 'EOF.'  * But to use the wrapper, you have to violate the boundaries between  * RPC layers by calling svc_sendreply() directly from the ypproc_all  * service routine instead of letting the RPC dispatcher do it.  *  * Bleah.  */
end_comment

begin_comment
comment|/*  * Custom XDR routine for serialzing results of ypproc_all: keep  * reading from the database and spew until we run out of records  * or encounter an error.  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdr_my_ypresp_all
parameter_list|(
specifier|register
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|ypresp_all
modifier|*
name|objp
parameter_list|)
block|{
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get a record. */
name|key
operator|.
name|size
operator|=
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
operator|.
name|keydat_len
expr_stmt|;
name|key
operator|.
name|data
operator|=
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
operator|.
name|keydat_val
expr_stmt|;
if|if
condition|(
operator|(
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|yp_next_record
argument_list|(
name|spec_dbp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|YP_TRUE
condition|)
block|{
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|data
operator|.
name|size
expr_stmt|;
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|data
operator|.
name|data
expr_stmt|;
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
operator|.
name|keydat_len
operator|=
name|key
operator|.
name|size
expr_stmt|;
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
operator|.
name|keydat_val
operator|=
name|key
operator|.
name|data
expr_stmt|;
name|objp
operator|->
name|more
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|objp
operator|->
name|more
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Serialize. */
if|if
condition|(
operator|!
name|xdr_ypresp_all
argument_list|(
name|xdrs
argument_list|,
name|objp
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|objp
operator|->
name|more
operator|==
name|FALSE
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
end_function

begin_function
name|ypresp_all
modifier|*
name|ypproc_all_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_all
name|result
decl_stmt|;
comment|/* 	 * Set this here so that the client will be forced to make 	 * at least one attempt to read from us even if all we're 	 * doing is returning an error. 	 */
name|result
operator|.
name|more
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
operator|||
name|argp
operator|->
name|map
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
name|argp
operator|->
name|domain
argument_list|)
condition|)
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* 	 * The ypproc_all procedure can take a while to complete. 	 * Best to handle it in a subprocess so the parent doesn't 	 * block. We fork() here so we don't end up sharing a 	 * DB file handle with the parent. 	 */
if|if
condition|(
operator|!
name|debug
operator|&&
name|children
operator|<
name|MAX_CHILDREN
operator|&&
name|fork
argument_list|()
condition|)
block|{
name|children
operator|++
expr_stmt|;
name|forked
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|forked
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spec_dbp
operator|=
name|yp_open_db
argument_list|(
name|argp
operator|->
name|domain
argument_list|,
name|argp
operator|->
name|map
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|yp_errno
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* Kick off the actual data transfer. */
name|svc_sendreply
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|,
name|xdr_my_ypresp_all
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|result
argument_list|)
expr_stmt|;
comment|/* Close database when done. */
call|(
name|void
call|)
argument_list|(
name|spec_dbp
operator|->
name|close
argument_list|)
argument_list|(
name|spec_dbp
argument_list|)
expr_stmt|;
comment|/* 	 * Returning NULL prevents the dispatcher from calling 	 * svc_sendreply() since we already did it. 	 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|ypresp_master
modifier|*
name|ypproc_master_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_master
name|result
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
name|argp
operator|->
name|domain
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|key
operator|.
name|data
operator|=
literal|"YP_MASTER_NAME"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_MASTER_NAME"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|yp_get_record
argument_list|(
name|argp
operator|->
name|domain
argument_list|,
name|argp
operator|->
name|map
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|peer
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|.
name|data
expr_stmt|;
name|result
operator|.
name|peer
index|[
name|data
operator|.
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|result
operator|.
name|peer
operator|=
literal|""
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|ypresp_order
modifier|*
name|ypproc_order_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_order
name|result
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
name|argp
operator|->
name|domain
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* 	 * We could just check the timestamp on the map file, 	 * but that's a hack: we'll only know the last time the file 	 * was touched, not the last time the database contents were 	 * updated. 	 */
name|key
operator|.
name|data
operator|=
literal|"YP_LAST_MODIFIED"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_LAST_MODIFIED"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|yp_get_record
argument_list|(
name|argp
operator|->
name|domain
argument_list|,
name|argp
operator|->
name|map
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
name|result
operator|.
name|ordernum
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|result
operator|.
name|ordernum
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|yp_maplist_free
parameter_list|(
name|yp_maplist
parameter_list|)
name|struct
name|ypmaplist
modifier|*
name|yp_maplist
decl_stmt|;
block|{
specifier|register
name|struct
name|ypmaplist
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|yp_maplist
condition|)
block|{
name|next
operator|=
name|yp_maplist
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|yp_maplist
operator|->
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yp_maplist
argument_list|)
expr_stmt|;
name|yp_maplist
operator|=
name|next
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|ypmaplist
modifier|*
name|yp_maplist_create
parameter_list|(
name|domain
parameter_list|)
specifier|const
name|char
modifier|*
name|domain
decl_stmt|;
block|{
name|char
name|yp_mapdir
index|[
name|MAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|yp_mapname
index|[
name|MAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|ypmaplist
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
name|struct
name|ypmaplist
modifier|*
name|yp_maplist
init|=
name|NULL
decl_stmt|;
name|DIR
modifier|*
name|dird
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dirp
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|snprintf
argument_list|(
name|yp_mapdir
argument_list|,
sizeof|sizeof
argument_list|(
name|yp_mapdir
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|yp_dir
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dird
operator|=
name|opendir
argument_list|(
name|yp_mapdir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"opendir(%s) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|dirp
operator|=
name|readdir
argument_list|(
name|dird
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|yp_mapname
argument_list|,
sizeof|sizeof
argument_list|(
name|yp_mapname
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|yp_mapdir
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|yp_mapname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cur
operator|=
operator|(
expr|struct
name|ypmaplist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ypmaplist
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|yp_error
argument_list|(
literal|"malloc() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dird
argument_list|)
expr_stmt|;
name|yp_maplist_free
argument_list|(
name|yp_maplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cur
operator|->
name|map
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"strdup() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dird
argument_list|)
expr_stmt|;
name|yp_maplist_free
argument_list|(
name|yp_maplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cur
operator|->
name|next
operator|=
name|yp_maplist
expr_stmt|;
name|yp_maplist
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"map: %s"
argument_list|,
name|yp_maplist
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|dird
argument_list|)
expr_stmt|;
return|return
operator|(
name|yp_maplist
operator|)
return|;
block|}
end_function

begin_function
name|ypresp_maplist
modifier|*
name|ypproc_maplist_2_svc
parameter_list|(
name|domainname
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_maplist
name|result
decl_stmt|;
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
operator|*
name|argp
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* 	 * We have to construct a linked list for the ypproc_maplist 	 * procedure using dynamically allocated memory. Since the XDR 	 * layer won't free this list for us, we have to deal with it 	 * ourselves. We call yp_maplist_free() first to free any 	 * previously allocated data we may have accumulated to insure 	 * that we have only one linked list in memory at any given 	 * time. 	 */
name|yp_maplist_free
argument_list|(
name|result
operator|.
name|maps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|.
name|maps
operator|=
name|yp_maplist_create
argument_list|(
operator|*
name|argp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"yp_maplist_create failed"
argument_list|)
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
else|else
name|result
operator|.
name|stat
operator|=
name|YP_TRUE
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

end_unit

