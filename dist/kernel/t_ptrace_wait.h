begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: t_ptrace_wait.h,v 1.7 2017/01/09 22:09:20 kamil Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2016 The NetBSD Foundation, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* Detect plain wait(2) use-case */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TWAIT_WAITPID
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|TWAIT_WAITID
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|TWAIT_WAIT3
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|TWAIT_WAIT4
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|TWAIT_WAIT6
argument_list|)
end_if

begin_define
define|#
directive|define
name|TWAIT_WAIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * There are two classes of wait(2)-like functions:  * - wait4(2)-like accepting pid_t, optional options parameter, struct rusage*  * - wait6(2)-like accepting idtype_t, id_t, struct wrusage, mandatory options  *  * The TWAIT_FNAME value is to be used for convenience in debug messages.  *  * The TWAIT_GENERIC() macro is designed to reuse the same unmodified  * code with as many wait(2)-like functions as possible.  *  * In a common use-case wait4(2) and wait6(2)-like function can work the almost  * the same way, however there are few important differences:  * wait6(2) must specify P_PID for idtype to match wpid from wait4(2).  * To behave like wait4(2), wait6(2) the 'options' to wait must include  * WEXITED|WTRUNCATED.  *  * There are two helper macros (they purpose it to mach more than one  * wait(2)-like function):  * The TWAIT_HAVE_STATUS - specifies whether a function can retrieve  *                         status (as integer value).  * The TWAIT_HAVE_PID    - specifies whether a function can request  *                         exact process identifier  * The TWAIT_HAVE_RUSAGE - specifies whether a function can request  *                         the struct rusage value  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TWAIT_WAIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TWAIT_FNAME
value|"wait"
end_define

begin_define
define|#
directive|define
name|TWAIT_WAIT4TYPE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|wait((b))
end_define

begin_define
define|#
directive|define
name|TWAIT_GENERIC
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|wait((b))
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_STATUS
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TWAIT_WAITPID
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TWAIT_FNAME
value|"waitpid"
end_define

begin_define
define|#
directive|define
name|TWAIT_WAIT4TYPE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|waitpid((a),(b),(c))
end_define

begin_define
define|#
directive|define
name|TWAIT_GENERIC
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|waitpid((a),(b),(c))
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_PID
value|1
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_STATUS
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TWAIT_WAITID
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TWAIT_FNAME
value|"waitid"
end_define

begin_define
define|#
directive|define
name|TWAIT_GENERIC
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|waitid(P_PID,(a),NULL,(c)|WEXITED|WTRAPPED)
end_define

begin_define
define|#
directive|define
name|TWAIT_WAIT6TYPE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
value|waitid((a),(b),(f),(d))
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_PID
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TWAIT_WAIT3
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TWAIT_FNAME
value|"wait3"
end_define

begin_define
define|#
directive|define
name|TWAIT_WAIT4TYPE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|wait3((b),(c),(d))
end_define

begin_define
define|#
directive|define
name|TWAIT_GENERIC
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|wait3((b),(c),NULL)
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_STATUS
value|1
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_RUSAGE
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TWAIT_WAIT4
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TWAIT_FNAME
value|"wait4"
end_define

begin_define
define|#
directive|define
name|TWAIT_WAIT4TYPE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|wait4((a),(b),(c),(d))
end_define

begin_define
define|#
directive|define
name|TWAIT_GENERIC
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|wait4((a),(b),(c),NULL)
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_PID
value|1
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_STATUS
value|1
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_RUSAGE
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TWAIT_WAIT6
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TWAIT_FNAME
value|"wait6"
end_define

begin_define
define|#
directive|define
name|TWAIT_WAIT6TYPE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
value|wait6((a),(b),(c),(d),(e),(f))
end_define

begin_define
define|#
directive|define
name|TWAIT_GENERIC
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|wait6(P_PID,(a),(b),(c)|WEXITED|WTRAPPED,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_PID
value|1
end_define

begin_define
define|#
directive|define
name|TWAIT_HAVE_STATUS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * There are 3 groups of tests:  * - TWAIT_GENERIC()	(wait, wait2, waitpid, wait3, wait4, wait6)  * - TWAIT_WAIT4TYPE()	(wait2, waitpid, wait3, wait4)  * - TWAIT_WAIT6TYPE()	(waitid, wait6)  *  * Tests only in the above categories are allowed. However some tests are not  * possible in the context requested functionality to be verified, therefore  * there are helper macros:  * - TWAIT_HAVE_PID	(wait2, waitpid, waitid, wait4, wait6)  * - TWAIT_HAVE_STATUS	(wait, wait2, waitpid, wait3, wait4, wait6)  * - TWAIT_HAVE_RUSAGE	(wait3, wait4)  * - TWAIT_HAVE_RETPID	(wait, wait2, waitpid, wait3, wait4, wait6)  *  * If there is an intention to test e.g. wait6(2) specific features in the  * ptrace(2) context, find the most matching group and with #ifdefs reduce  * functionality of less featured than wait6(2) interface (TWAIT_WAIT6TYPE).  *  * For clarity never use negative preprocessor checks, like:  *     #if !defined(TWAIT_WAIT4)  * always refer to checks for positive values.  */
end_comment

begin_define
define|#
directive|define
name|TEST_REQUIRE_EQ
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|do {									\ 	uintmax_t vx = (x);						\ 	uintmax_t vy = (y);						\ 	int ret = vx == vy;						\ 	if (!ret)							\ 		ATF_REQUIRE_EQ_MSG(vx, vy, "%s(%ju) == %s(%ju)", 	\ 		    #x, vx, #y, vy);					\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_comment
comment|/*  * A child process cannot call atf functions and expect them to magically  * work like in the parent.  * The printf(3) messaging from a child will not work out of the box as well  * without estabilishing a communication protocol with its parent. To not  * overcomplicate the tests - do not log from a child and use err(3)/errx(3)  * wrapped with FORKEE_ASSERT()/FORKEE_ASSERTX() as that is guaranteed to work.  */
end_comment

begin_define
define|#
directive|define
name|FORKEE_ASSERT_EQ
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|do {									\ 	uintmax_t vx = (x);						\ 	uintmax_t vy = (y);						\ 	int ret = vx == vy;						\ 	if (!ret)							\ 		errx(EXIT_FAILURE, "%s:%d %s(): Assertion failed for: "	\ 		    "%s(%ju) == %s(%ju)", __FILE__, __LINE__, __func__,	\ 		    #x, vx, #y, vy);					\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|FORKEE_ASSERTX
parameter_list|(
name|x
parameter_list|)
define|\
value|do {									\ 	int ret = (x);							\ 	if (!ret)							\ 		errx(EXIT_FAILURE, "%s:%d %s(): Assertion failed for: %s",\ 		     __FILE__, __LINE__, __func__, #x);			\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|FORKEE_ASSERT
parameter_list|(
name|x
parameter_list|)
define|\
value|do {									\ 	int ret = (x);							\ 	if (!ret)							\ 		err(EXIT_FAILURE, "%s:%d %s(): Assertion failed for: %s",\ 		     __FILE__, __LINE__, __func__, #x);			\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_comment
comment|/*  * Simplify logic for functions using general purpose registers add HAVE_GPREGS  *  * For platforms that do not implement all needed calls for simplicity assume  * that they are unsupported at all.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PT_GETREGS
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|PT_SETREGS
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|PTRACE_REG_PC
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|PTRACE_REG_SET_PC
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|PTRACE_REG_SP
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|PTRACE_REG_INTRV
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_GPREGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add guards for floating point registers */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PT_GETFPREGS
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|PT_SETFPREGS
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_FPREGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add guards for cpu debug registers */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PT_GETDBREGS
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|PT_SETDBREGS
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_DBREGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * If waitid(2) returns because one or more processes have a state change to  * report, 0 is returned.  If an error is detected, a value of -1 is returned  * and errno is set to indicate the error. If WNOHANG is specified and there  * are no stopped, continued or exited children, 0 is returned.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TWAIT_WAITID
argument_list|)
end_if

begin_define
define|#
directive|define
name|TWAIT_REQUIRE_SUCCESS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|TEST_REQUIRE_EQ((a), 0)
end_define

begin_define
define|#
directive|define
name|TWAIT_REQUIRE_FAILURE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ATF_REQUIRE_ERRNO((a),(b) == -1)
end_define

begin_define
define|#
directive|define
name|FORKEE_REQUIRE_SUCCESS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|FORKEE_ASSERT_EQ(a, 0)
end_define

begin_define
define|#
directive|define
name|FORKEE_REQUIRE_FAILURE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|FORKEE_ASSERTX(((a) == errno)&& ((b) == -1))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TWAIT_REQUIRE_SUCCESS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|TEST_REQUIRE_EQ((a), (b))
end_define

begin_define
define|#
directive|define
name|TWAIT_REQUIRE_FAILURE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ATF_REQUIRE_ERRNO((a),(b) == -1)
end_define

begin_define
define|#
directive|define
name|FORKEE_REQUIRE_SUCCESS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|FORKEE_ASSERT_EQ(a, b)
end_define

begin_define
define|#
directive|define
name|FORKEE_REQUIRE_FAILURE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|FORKEE_ASSERTX(((a) == errno)&& ((b) == -1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Helper tools to verify whether status reports exited value  */
end_comment

begin_if
if|#
directive|if
name|TWAIT_HAVE_STATUS
end_if

begin_function
specifier|static
name|void
name|__used
name|validate_status_exited
parameter_list|(
name|int
name|status
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
name|ATF_REQUIRE_MSG
argument_list|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported !exited process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFCONTINUED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported continued process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported signaled process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported stopped process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ_MSG
argument_list|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|,
name|expected
argument_list|,
literal|"The process has exited with invalid value %d != %d"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__used
name|forkee_status_exited
parameter_list|(
name|int
name|status
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
name|FORKEE_ASSERTX
argument_list|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFCONTINUED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERT_EQ
argument_list|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__used
name|validate_status_continued
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported exited process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
name|WIFCONTINUED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported !continued process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported signaled process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported stopped process"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__used
name|forkee_status_continued
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
name|WIFCONTINUED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__used
name|validate_status_signaled
parameter_list|(
name|int
name|status
parameter_list|,
name|int
name|expected_termsig
parameter_list|,
name|int
name|expected_core
parameter_list|)
block|{
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported exited process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFCONTINUED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported continued process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported !signaled process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported stopped process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ_MSG
argument_list|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|,
name|expected_termsig
argument_list|,
literal|"Unexpected signal received"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ_MSG
argument_list|(
name|WCOREDUMP
argument_list|(
name|status
argument_list|)
argument_list|,
name|expected_core
argument_list|,
literal|"Unexpectedly core file %s generated"
argument_list|,
name|expected_core
condition|?
literal|"not"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__used
name|forkee_status_signaled
parameter_list|(
name|int
name|status
parameter_list|,
name|int
name|expected_termsig
parameter_list|,
name|int
name|expected_core
parameter_list|)
block|{
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFCONTINUED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERT_EQ
argument_list|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|,
name|expected_termsig
argument_list|)
expr_stmt|;
name|FORKEE_ASSERT_EQ
argument_list|(
name|WCOREDUMP
argument_list|(
name|status
argument_list|)
argument_list|,
name|expected_core
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__used
name|validate_status_stopped
parameter_list|(
name|int
name|status
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported exited process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFCONTINUED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported continued process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
operator|!
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported signaled process"
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_MSG
argument_list|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"Reported !stopped process"
argument_list|)
expr_stmt|;
name|char
name|st
index|[
literal|128
index|]
decl_stmt|,
name|ex
index|[
literal|128
index|]
decl_stmt|;
name|strlcpy
argument_list|(
name|st
argument_list|,
name|strsignal
argument_list|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ex
argument_list|,
name|strsignal
argument_list|(
name|expected
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
name|ATF_REQUIRE_EQ_MSG
argument_list|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|,
name|expected
argument_list|,
literal|"Unexpected stop signal received [%s] != [%s]"
argument_list|,
name|st
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__used
name|forkee_status_stopped
parameter_list|(
name|int
name|status
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFCONTINUED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
operator|!
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERTX
argument_list|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|FORKEE_ASSERT_EQ
argument_list|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|validate_status_exited
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|forkee_status_exited
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|validate_status_continued
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|forkee_status_continued
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|validate_status_signaled
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_define
define|#
directive|define
name|forkee_status_signaled
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_define
define|#
directive|define
name|validate_status_stopped
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|forkee_status_stopped
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is currently designed to be run in the main/parent process */
end_comment

begin_function
specifier|static
name|void
name|__used
name|await_zombie
parameter_list|(
name|pid_t
name|process
parameter_list|)
block|{
name|struct
name|kinfo_proc2
name|p
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|const
name|int
name|name
index|[]
init|=
block|{
index|[
literal|0
index|]
operator|=
name|CTL_KERN
block|,
index|[
literal|1
index|]
operator|=
name|KERN_PROC2
block|,
index|[
literal|2
index|]
operator|=
name|KERN_PROC_PID
block|,
index|[
literal|3
index|]
operator|=
name|process
block|,
index|[
literal|4
index|]
operator|=
sizeof|sizeof
argument_list|(
name|p
argument_list|)
block|,
index|[
literal|5
index|]
operator|=
literal|1
block|}
decl_stmt|;
specifier|const
name|size_t
name|namelen
init|=
name|__arraycount
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* Await the process becoming a zombie */
while|while
condition|(
literal|1
condition|)
block|{
name|ATF_REQUIRE
argument_list|(
name|sysctl
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|p_stat
operator|==
name|LSZOMB
condition|)
break|break;
name|ATF_REQUIRE
argument_list|(
name|usleep
argument_list|(
literal|1000
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Happy number sequence -- this function is used to just consume cpu cycles */
end_comment

begin_define
define|#
directive|define
name|HAPPY_NUMBER
value|1
end_define

begin_comment
comment|/* If n is not happy then its sequence ends in the cycle:  * 4, 16, 37, 58, 89, 145, 42, 20, 4, ... */
end_comment

begin_define
define|#
directive|define
name|SAD_NUMBER
value|4
end_define

begin_comment
comment|/* Calculate the sum of the squares of the digits of n */
end_comment

begin_function
specifier|static
name|unsigned
name|__used
name|dsum
parameter_list|(
name|unsigned
name|n
parameter_list|)
block|{
name|unsigned
name|sum
decl_stmt|,
name|x
decl_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
init|;
name|n
condition|;
name|n
operator|/=
literal|10
control|)
block|{
name|x
operator|=
name|n
operator|%
literal|10
expr_stmt|;
name|sum
operator|+=
name|x
operator|*
name|x
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: Disabled optimization is required to make tests for hardware assisted  * traps in .text functional  *  * Tested with GCC 5.4 on NetBSD 7.99.47 amd64  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|__used
ifdef|#
directive|ifdef
name|__clang__
name|__attribute__
argument_list|(
operator|(
name|__optnone__
operator|)
argument_list|)
else|#
directive|else
name|__attribute__
argument_list|(
operator|(
name|__optimize__
argument_list|(
literal|"O0"
argument_list|)
operator|)
argument_list|)
endif|#
directive|endif
name|check_happy
argument_list|(
name|unsigned
name|n
argument_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|total
init|=
name|dsum
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|total
operator|==
name|HAPPY_NUMBER
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|total
operator|==
name|SAD_NUMBER
condition|)
return|return
literal|0
return|;
name|n
operator|=
name|total
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TWAIT_HAVE_PID
argument_list|)
end_if

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_HAVE_PID
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ATF_TP_ADD_TC(a,b)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_HAVE_PID
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GPREGS
argument_list|)
end_if

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_HAVE_GPREGS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ATF_TP_ADD_TC(a,b)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_HAVE_GPREGS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FPREGS
argument_list|)
end_if

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_HAVE_FPREGS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ATF_TP_ADD_TC(a,b)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_HAVE_FPREGS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PT_STEP
argument_list|)
end_if

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_PT_STEP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ATF_TP_ADD_TC(a,b)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_PT_STEP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__HAVE_PTRACE_WATCHPOINTS
argument_list|)
end_if

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_HAVE_PTRACE_WATCHPOINTS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ATF_TP_ADD_TC(a,b)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATF_TP_ADD_TC_HAVE_PTRACE_WATCHPOINTS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

end_unit

