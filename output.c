begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: output.c,v 1.65 2014/04/09 21:10:48 tom Exp $ */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_define
define|#
directive|define
name|StaticOrR
value|(rflag ? "" : "static ")
end_define

begin_define
define|#
directive|define
name|CountLine
parameter_list|(
name|fp
parameter_list|)
value|(!rflag || ((fp) == code_file))
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PER_STATE
value|3
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PER_STATE
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|nvectors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nentries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
modifier|*
name|froms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
modifier|*
name|tos
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
name|conflicts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
name|nconflicts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
name|tally
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
name|width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
name|state_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
name|order
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Value_t
modifier|*
name|check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lowzero
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|high
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|putc_code
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
name|fp
operator|==
name|code_file
operator|)
condition|)
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putl_code
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|fp
operator|==
name|code_file
condition|)
operator|++
name|outline
expr_stmt|;
name|fputs
argument_list|(
name|s
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|puts_code
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fputs
argument_list|(
name|s
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_code_lineno
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lflag
operator|&&
operator|(
name|fp
operator|==
name|code_file
operator|)
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|line_format
argument_list|,
name|outline
operator|+
literal|1
argument_list|,
name|code_file_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_input_lineno
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lflag
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|define_prefixed
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|bump_line
init|=
name|CountLine
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|bump_line
condition|)
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bump_line
condition|)
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#ifndef %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bump_line
condition|)
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define %-10s %s%s\n"
argument_list|,
name|name
argument_list|,
name|symbol_prefix
argument_list|,
name|name
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bump_line
condition|)
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#endif /* %s */\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_prefix
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|symbol_prefix
operator|==
name|NULL
condition|)
block|{
name|symbol_prefix
operator|=
literal|"yy"
expr_stmt|;
block|}
else|else
block|{
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yyparse"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yylex"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yyerror"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yychar"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yyval"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yylval"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yydebug"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yynerrs"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yyerrflag"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yylhs"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yylen"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yydefred"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yystos"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yydgoto"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yysindex"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yyrindex"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yygindex"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yytable"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yycheck"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yyname"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yyrule"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
block|{
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yyloc"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yylloc"
argument_list|)
expr_stmt|;
block|}
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#if YYBTYACC\n"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yycindex"
argument_list|)
expr_stmt|;
name|define_prefixed
argument_list|(
name|fp
argument_list|,
literal|"yyctable"
argument_list|)
expr_stmt|;
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#endif /* YYBTYACC */\n"
argument_list|)
expr_stmt|;
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|CountLine
argument_list|(
name|fp
argument_list|)
condition|)
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define YYPREFIX \"%s\"\n"
argument_list|,
name|symbol_prefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_newline
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rflag
condition|)
operator|++
name|outline
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_line
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|fputs
argument_list|(
name|value
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|output_newline
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_int
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%5d,"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_int_table
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|need
init|=
literal|34
operator|-
call|(
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|symbol_prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|need
operator|<
literal|6
condition|)
name|need
operator|=
literal|6
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%sconst YYINT %s%s[] = {%*d,"
argument_list|,
name|StaticOrR
argument_list|,
name|symbol_prefix
argument_list|,
name|name
argument_list|,
name|need
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_str_table
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"%sconst char *const %s%s[] = {"
argument_list|,
name|StaticOrR
argument_list|,
name|symbol_prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|output_newline
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_table
parameter_list|(
name|void
parameter_list|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|output_line
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_YYINT_typedef
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
comment|/* generate the type used to index the various parser tables */
if|if
condition|(
name|CountLine
argument_list|(
name|fp
argument_list|)
condition|)
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"typedef %s YYINT;\n"
argument_list|,
name|CONCAT1
argument_list|(
literal|""
argument_list|,
name|YYINT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_rule_data
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|output_YYINT_typedef
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
name|start_int_table
argument_list|(
literal|"lhs"
argument_list|,
name|symbol_value
index|[
name|start_symbol
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|nrules
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|output_int
argument_list|(
name|symbol_value
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|start_int_table
argument_list|(
literal|"len"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|nrules
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|j
operator|++
expr_stmt|;
name|output_int
argument_list|(
name|rrhs
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|rrhs
index|[
name|i
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_yydefred
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|start_int_table
argument_list|(
literal|"defred"
argument_list|,
operator|(
name|defred
index|[
literal|0
index|]
condition|?
name|defred
index|[
literal|0
index|]
operator|-
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
literal|10
condition|)
operator|++
name|j
expr_stmt|;
else|else
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
name|output_int
argument_list|(
operator|(
name|defred
index|[
name|i
index|]
condition|?
name|defred
index|[
name|i
index|]
operator|-
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|void
name|output_accessing_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
modifier|*
name|translate
decl_stmt|;
if|if
condition|(
name|nstates
operator|!=
literal|0
condition|)
block|{
name|translate
operator|=
name|TMALLOC
argument_list|(
name|int
argument_list|,
name|nstates
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|translate
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
operator|++
name|i
control|)
block|{
name|int
name|gsymb
init|=
name|accessing_symbol
index|[
name|i
index|]
decl_stmt|;
name|translate
index|[
name|i
index|]
operator|=
name|symbol_pval
index|[
name|gsymb
index|]
expr_stmt|;
block|}
comment|/* yystos[] may be unused, depending on compile-time defines */
name|start_int_table
argument_list|(
literal|"stos"
argument_list|,
name|translate
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nstates
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|j
operator|<
literal|10
condition|)
operator|++
name|j
expr_stmt|;
else|else
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
name|output_int
argument_list|(
name|translate
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|translate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|Value_t
name|find_conflict_base
parameter_list|(
name|Value_t
name|cbase
parameter_list|)
block|{
name|Value_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cbase
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|+
name|cbase
operator|<
name|nconflicts
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|conflicts
index|[
name|i
operator|+
name|j
index|]
operator|!=
name|conflicts
index|[
name|cbase
operator|+
name|j
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|+
name|cbase
operator|>=
name|nconflicts
condition|)
return|return
name|i
return|;
block|}
return|return
name|cbase
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|token_actions
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Value_t
name|shiftcount
decl_stmt|,
name|reducecount
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|Value_t
name|conflictcount
init|=
literal|0
decl_stmt|;
name|Value_t
name|csym
init|=
operator|-
literal|1
decl_stmt|;
name|Value_t
name|cbase
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|max
decl_stmt|,
name|min
decl_stmt|;
name|Value_t
modifier|*
name|actionrow
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|action
modifier|*
name|p
decl_stmt|;
name|actionrow
operator|=
name|NEW2
argument_list|(
name|PER_STATE
operator|*
name|ntokens
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|parser
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PER_STATE
operator|*
name|ntokens
condition|;
operator|++
name|j
control|)
name|actionrow
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|shiftcount
operator|=
literal|0
expr_stmt|;
name|reducecount
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
condition|)
block|{
name|conflictcount
operator|=
literal|0
expr_stmt|;
name|csym
operator|=
operator|-
literal|1
expr_stmt|;
name|cbase
operator|=
name|nconflicts
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|parser
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
condition|)
block|{
if|if
condition|(
name|csym
operator|!=
operator|-
literal|1
operator|&&
name|csym
operator|!=
name|p
operator|->
name|symbol
condition|)
block|{
name|conflictcount
operator|++
expr_stmt|;
name|conflicts
index|[
name|nconflicts
operator|++
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|j
operator|=
name|find_conflict_base
argument_list|(
name|cbase
argument_list|)
expr_stmt|;
name|actionrow
index|[
name|csym
operator|+
literal|2
operator|*
name|ntokens
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|cbase
condition|)
block|{
name|cbase
operator|=
name|nconflicts
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|conflicts
index|[
name|cbase
index|]
operator|==
operator|-
literal|1
condition|)
name|cbase
operator|++
expr_stmt|;
name|nconflicts
operator|=
name|cbase
expr_stmt|;
block|}
name|csym
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|suppressed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|action_code
operator|==
name|SHIFT
condition|)
block|{
operator|++
name|shiftcount
expr_stmt|;
name|actionrow
index|[
name|p
operator|->
name|symbol
index|]
operator|=
name|p
operator|->
name|number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|action_code
operator|==
name|REDUCE
operator|&&
name|p
operator|->
name|number
operator|!=
name|defred
index|[
name|i
index|]
condition|)
block|{
operator|++
name|reducecount
expr_stmt|;
name|actionrow
index|[
name|p
operator|->
name|symbol
operator|+
name|ntokens
index|]
operator|=
name|p
operator|->
name|number
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
elseif|else
if|if
condition|(
name|backtrack
operator|&&
name|p
operator|->
name|suppressed
operator|==
literal|1
condition|)
block|{
name|csym
operator|=
name|p
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|action_code
operator|==
name|SHIFT
condition|)
block|{
name|conflicts
index|[
name|nconflicts
operator|++
index|]
operator|=
name|p
operator|->
name|number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|action_code
operator|==
name|REDUCE
operator|&&
name|p
operator|->
name|number
operator|!=
name|defred
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|cbase
operator|==
name|nconflicts
condition|)
block|{
if|if
condition|(
name|cbase
condition|)
name|cbase
operator|--
expr_stmt|;
else|else
name|conflicts
index|[
name|nconflicts
operator|++
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|conflicts
index|[
name|nconflicts
operator|++
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|p
operator|->
name|number
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
operator|&&
name|csym
operator|!=
operator|-
literal|1
condition|)
block|{
name|conflictcount
operator|++
expr_stmt|;
name|conflicts
index|[
name|nconflicts
operator|++
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|j
operator|=
name|find_conflict_base
argument_list|(
name|cbase
argument_list|)
expr_stmt|;
name|actionrow
index|[
name|csym
operator|+
literal|2
operator|*
name|ntokens
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|cbase
condition|)
block|{
name|cbase
operator|=
name|nconflicts
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|conflicts
index|[
name|cbase
index|]
operator|==
operator|-
literal|1
condition|)
name|cbase
operator|++
expr_stmt|;
name|nconflicts
operator|=
name|cbase
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|tally
index|[
name|i
index|]
operator|=
name|shiftcount
expr_stmt|;
name|tally
index|[
name|nstates
operator|+
name|i
index|]
operator|=
name|reducecount
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
condition|)
name|tally
index|[
literal|2
operator|*
name|nstates
operator|+
name|i
index|]
operator|=
name|conflictcount
expr_stmt|;
endif|#
directive|endif
name|width
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|width
index|[
name|nstates
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
condition|)
name|width
index|[
literal|2
operator|*
name|nstates
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|shiftcount
operator|>
literal|0
condition|)
block|{
name|froms
index|[
name|i
index|]
operator|=
name|r
operator|=
name|NEW2
argument_list|(
name|shiftcount
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|tos
index|[
name|i
index|]
operator|=
name|s
operator|=
name|NEW2
argument_list|(
name|shiftcount
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|min
operator|=
name|MAXYYINT
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actionrow
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|min
operator|>
name|symbol_value
index|[
name|j
index|]
condition|)
name|min
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|symbol_value
index|[
name|j
index|]
condition|)
name|max
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|r
operator|++
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|actionrow
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|width
index|[
name|i
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|max
operator|-
name|min
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reducecount
operator|>
literal|0
condition|)
block|{
name|froms
index|[
name|nstates
operator|+
name|i
index|]
operator|=
name|r
operator|=
name|NEW2
argument_list|(
name|reducecount
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|tos
index|[
name|nstates
operator|+
name|i
index|]
operator|=
name|s
operator|=
name|NEW2
argument_list|(
name|reducecount
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|min
operator|=
name|MAXYYINT
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actionrow
index|[
name|ntokens
operator|+
name|j
index|]
condition|)
block|{
if|if
condition|(
name|min
operator|>
name|symbol_value
index|[
name|j
index|]
condition|)
name|min
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|symbol_value
index|[
name|j
index|]
condition|)
name|max
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|r
operator|++
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|s
operator|++
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|actionrow
index|[
name|ntokens
operator|+
name|j
index|]
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|width
index|[
name|nstates
operator|+
name|i
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|max
operator|-
name|min
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
operator|&&
name|conflictcount
operator|>
literal|0
condition|)
block|{
name|froms
index|[
literal|2
operator|*
name|nstates
operator|+
name|i
index|]
operator|=
name|r
operator|=
name|NEW2
argument_list|(
name|conflictcount
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|tos
index|[
literal|2
operator|*
name|nstates
operator|+
name|i
index|]
operator|=
name|s
operator|=
name|NEW2
argument_list|(
name|conflictcount
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|min
operator|=
name|MAXYYINT
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntokens
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actionrow
index|[
literal|2
operator|*
name|ntokens
operator|+
name|j
index|]
condition|)
block|{
if|if
condition|(
name|min
operator|>
name|symbol_value
index|[
name|j
index|]
condition|)
name|min
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|symbol_value
index|[
name|j
index|]
condition|)
name|max
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|r
operator|++
operator|=
name|symbol_value
index|[
name|j
index|]
expr_stmt|;
operator|*
name|s
operator|++
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|actionrow
index|[
literal|2
operator|*
name|ntokens
operator|+
name|j
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|width
index|[
literal|2
operator|*
name|nstates
operator|+
name|i
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|max
operator|-
name|min
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|FREE
argument_list|(
name|actionrow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|default_goto
parameter_list|(
name|int
name|symbol
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|default_state
decl_stmt|;
name|int
name|max
decl_stmt|;
name|m
operator|=
name|goto_map
index|[
name|symbol
index|]
expr_stmt|;
name|n
operator|=
name|goto_map
index|[
name|symbol
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
name|state_count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|state_count
index|[
name|to_state
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
name|default_state
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|state_count
index|[
name|i
index|]
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|state_count
index|[
name|i
index|]
expr_stmt|;
name|default_state
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
operator|(
name|default_state
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_column
parameter_list|(
name|int
name|symbol
parameter_list|,
name|int
name|default_state
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|n
decl_stmt|;
name|Value_t
modifier|*
name|sp
decl_stmt|;
name|Value_t
modifier|*
name|sp1
decl_stmt|;
name|Value_t
modifier|*
name|sp2
decl_stmt|;
name|Value_t
name|count
decl_stmt|;
name|int
name|symno
decl_stmt|;
name|m
operator|=
name|goto_map
index|[
name|symbol
index|]
expr_stmt|;
name|n
operator|=
name|goto_map
index|[
name|symbol
operator|+
literal|1
index|]
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|to_state
index|[
name|i
index|]
operator|!=
name|default_state
condition|)
operator|++
name|count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|symno
operator|=
name|symbol_value
index|[
name|symbol
index|]
operator|+
name|PER_STATE
operator|*
name|nstates
expr_stmt|;
name|froms
index|[
name|symno
index|]
operator|=
name|sp1
operator|=
name|sp
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|tos
index|[
name|symno
index|]
operator|=
name|sp2
operator|=
name|NEW2
argument_list|(
name|count
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|to_state
index|[
name|i
index|]
operator|!=
name|default_state
condition|)
block|{
operator|*
name|sp1
operator|++
operator|=
name|from_state
index|[
name|i
index|]
expr_stmt|;
operator|*
name|sp2
operator|++
operator|=
name|to_state
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|tally
index|[
name|symno
index|]
operator|=
name|count
expr_stmt|;
name|width
index|[
name|symno
index|]
operator|=
call|(
name|Value_t
call|)
argument_list|(
name|sp1
index|[
operator|-
literal|1
index|]
operator|-
name|sp
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|goto_actions
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|state_count
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|k
operator|=
name|default_goto
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|)
expr_stmt|;
name|start_int_table
argument_list|(
literal|"dgoto"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|save_column
argument_list|(
name|start_symbol
operator|+
literal|1
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start_symbol
operator|+
literal|2
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|k
operator|=
name|default_goto
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|output_int
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|save_column
argument_list|(
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|state_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sort_actions
parameter_list|(
name|void
parameter_list|)
block|{
name|Value_t
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|w
decl_stmt|;
name|order
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|nentries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvectors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tally
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|tally
index|[
name|i
index|]
expr_stmt|;
name|w
operator|=
name|width
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|nentries
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
operator|&&
operator|(
name|width
index|[
name|order
index|[
name|j
index|]
index|]
operator|<
name|w
operator|)
condition|)
name|j
operator|--
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
operator|&&
operator|(
name|width
index|[
name|order
index|[
name|j
index|]
index|]
operator|==
name|w
operator|)
operator|&&
operator|(
name|tally
index|[
name|order
index|[
name|j
index|]
index|]
operator|<
name|t
operator|)
condition|)
name|j
operator|--
expr_stmt|;
for|for
control|(
name|k
operator|=
name|nentries
operator|-
literal|1
init|;
name|k
operator|>
name|j
condition|;
name|k
operator|--
control|)
name|order
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|order
index|[
name|k
index|]
expr_stmt|;
name|order
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|nentries
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  The function matching_vector determines if the vector specified by	*/
end_comment

begin_comment
comment|/*  the input parameter matches a previously considered	vector.  The	*/
end_comment

begin_comment
comment|/*  test at the start of the function checks if the vector represents	*/
end_comment

begin_comment
comment|/*  a row of shifts over terminal symbols or a row of reductions, or a	*/
end_comment

begin_comment
comment|/*  column of shifts over a nonterminal symbol.  Berkeley Yacc does not	*/
end_comment

begin_comment
comment|/*  check if a column of shifts over a nonterminal symbols matches a	*/
end_comment

begin_comment
comment|/*  previously considered vector.  Because of the nature of LR parsing	*/
end_comment

begin_comment
comment|/*  tables, no two columns can match.  Therefore, the only possible	*/
end_comment

begin_comment
comment|/*  match would be between a row and a column.  Such matches are	*/
end_comment

begin_comment
comment|/*  unlikely.  Therefore, to save time, no attempt is made to see if a	*/
end_comment

begin_comment
comment|/*  column matches a previously considered vector.			*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Matching_vector is poorly designed.  The test could easily be made	*/
end_comment

begin_comment
comment|/*  faster.  Also, it depends on the vectors being in a specific	*/
end_comment

begin_comment
comment|/*  order.								*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Not really any point in checking for matching conflicts -- it is    */
end_comment

begin_comment
comment|/*  extremely unlikely to occur, and conflicts are (hopefully) rare.    */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|matching_vector
parameter_list|(
name|int
name|vector
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|w
decl_stmt|;
name|int
name|match
decl_stmt|;
name|int
name|prev
decl_stmt|;
name|i
operator|=
name|order
index|[
name|vector
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|2
operator|*
name|nstates
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|t
operator|=
name|tally
index|[
name|i
index|]
expr_stmt|;
name|w
operator|=
name|width
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|vector
operator|-
literal|1
init|;
name|prev
operator|>=
literal|0
condition|;
name|prev
operator|--
control|)
block|{
name|j
operator|=
name|order
index|[
name|prev
index|]
expr_stmt|;
if|if
condition|(
name|width
index|[
name|j
index|]
operator|!=
name|w
operator|||
name|tally
index|[
name|j
index|]
operator|!=
name|t
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|match
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|match
operator|&&
name|k
operator|<
name|t
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|tos
index|[
name|j
index|]
index|[
name|k
index|]
operator|!=
name|tos
index|[
name|i
index|]
index|[
name|k
index|]
operator|||
name|froms
index|[
name|j
index|]
index|[
name|k
index|]
operator|!=
name|froms
index|[
name|i
index|]
index|[
name|k
index|]
condition|)
name|match
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
return|return
operator|(
name|j
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pack_vector
parameter_list|(
name|int
name|vector
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|loc
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|Value_t
modifier|*
name|from
decl_stmt|;
name|Value_t
modifier|*
name|to
decl_stmt|;
name|int
name|newmax
decl_stmt|;
name|i
operator|=
name|order
index|[
name|vector
index|]
expr_stmt|;
name|t
operator|=
name|tally
index|[
name|i
index|]
expr_stmt|;
name|assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|from
operator|=
name|froms
index|[
name|i
index|]
expr_stmt|;
name|to
operator|=
name|tos
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|lowzero
operator|-
name|from
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|t
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|lowzero
operator|-
name|from
index|[
name|k
index|]
operator|>
name|j
condition|)
name|j
operator|=
name|lowzero
operator|-
name|from
index|[
name|k
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
continue|continue;
name|ok
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|ok
operator|&&
name|k
operator|<
name|t
condition|;
name|k
operator|++
control|)
block|{
name|loc
operator|=
name|j
operator|+
name|from
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|loc
operator|>=
name|maxtable
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|loc
operator|>=
name|MAXTABLE
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"maximum table size exceeded"
argument_list|)
expr_stmt|;
name|newmax
operator|=
name|maxtable
expr_stmt|;
do|do
block|{
name|newmax
operator|+=
literal|200
expr_stmt|;
block|}
do|while
condition|(
name|newmax
operator|<=
name|loc
condition|)
do|;
name|table
operator|=
name|TREALLOC
argument_list|(
name|Value_t
argument_list|,
name|table
argument_list|,
name|newmax
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|check
operator|=
name|TREALLOC
argument_list|(
name|Value_t
argument_list|,
name|check
argument_list|,
name|newmax
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|check
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|maxtable
init|;
name|l
operator|<
name|newmax
condition|;
operator|++
name|l
control|)
block|{
name|table
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
name|check
index|[
name|l
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|maxtable
operator|=
name|newmax
expr_stmt|;
block|}
if|if
condition|(
name|check
index|[
name|loc
index|]
operator|!=
operator|-
literal|1
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|ok
operator|&&
name|k
operator|<
name|vector
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|pos
index|[
name|k
index|]
operator|==
name|j
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|t
condition|;
name|k
operator|++
control|)
block|{
name|loc
operator|=
name|j
operator|+
name|from
index|[
name|k
index|]
expr_stmt|;
name|table
index|[
name|loc
index|]
operator|=
name|to
index|[
name|k
index|]
expr_stmt|;
name|check
index|[
name|loc
index|]
operator|=
name|from
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|loc
operator|>
name|high
condition|)
name|high
operator|=
name|loc
expr_stmt|;
block|}
while|while
condition|(
name|check
index|[
name|lowzero
index|]
operator|!=
operator|-
literal|1
condition|)
operator|++
name|lowzero
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pack_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Value_t
name|place
decl_stmt|;
name|int
name|state
decl_stmt|;
name|base
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|pos
operator|=
name|NEW2
argument_list|(
name|nentries
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|maxtable
operator|=
literal|1000
expr_stmt|;
name|table
operator|=
name|NEW2
argument_list|(
name|maxtable
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|check
operator|=
name|NEW2
argument_list|(
name|maxtable
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|lowzero
operator|=
literal|0
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxtable
condition|;
name|i
operator|++
control|)
name|check
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|state
operator|=
name|matching_vector
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|<
literal|0
condition|)
name|place
operator|=
operator|(
name|Value_t
operator|)
name|pack_vector
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|place
operator|=
name|base
index|[
name|state
index|]
expr_stmt|;
name|pos
index|[
name|i
index|]
operator|=
name|place
expr_stmt|;
name|base
index|[
name|order
index|[
name|i
index|]
index|]
operator|=
name|place
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvectors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|froms
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|froms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tos
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|tos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DO_FREE
argument_list|(
name|froms
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|tos
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|tally
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_base
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|start_int_table
argument_list|(
literal|"sindex"
argument_list|,
name|base
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|output_int
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|start_int_table
argument_list|(
literal|"rindex"
argument_list|,
name|base
index|[
name|nstates
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nstates
operator|+
literal|1
init|;
name|i
operator|<
literal|2
operator|*
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|output_int
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|output_line
argument_list|(
literal|"#if YYBTYACC"
argument_list|)
expr_stmt|;
name|start_int_table
argument_list|(
literal|"cindex"
argument_list|,
name|base
index|[
literal|2
operator|*
name|nstates
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
operator|*
name|nstates
operator|+
literal|1
init|;
name|i
operator|<
literal|3
operator|*
name|nstates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|output_int
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|output_line
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|start_int_table
argument_list|(
literal|"gindex"
argument_list|,
name|base
index|[
name|PER_STATE
operator|*
name|nstates
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PER_STATE
operator|*
name|nstates
operator|+
literal|1
init|;
name|i
operator|<
name|nvectors
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|output_int
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|high
operator|>=
name|MAXYYINT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YYTABLESIZE: %ld\n"
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Table is longer than %d elements.\n"
argument_list|,
name|MAXYYINT
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
literal|"#define YYTABLESIZE %ld\n"
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|start_int_table
argument_list|(
literal|"table"
argument_list|,
name|table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|output_int
argument_list|(
name|table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_check
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|start_int_table
argument_list|(
literal|"check"
argument_list|,
name|check
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|output_int
argument_list|(
name|check
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|check
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|void
name|output_ctable
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|conflicts
condition|)
block|{
name|output_line
argument_list|(
literal|"#if YYBTYACC"
argument_list|)
expr_stmt|;
name|start_int_table
argument_list|(
literal|"ctable"
argument_list|,
name|conflicts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nconflicts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|10
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|++
name|j
expr_stmt|;
name|output_int
argument_list|(
name|conflicts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|output_line
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|conflicts
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|output_actions
parameter_list|(
name|void
parameter_list|)
block|{
name|nvectors
operator|=
name|PER_STATE
operator|*
name|nstates
operator|+
name|nvars
expr_stmt|;
name|froms
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|Value_t
operator|*
argument_list|)
expr_stmt|;
name|tos
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|Value_t
operator|*
argument_list|)
expr_stmt|;
name|tally
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
name|width
operator|=
name|NEW2
argument_list|(
name|nvectors
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
operator|&&
operator|(
name|SRtotal
operator|+
name|RRtotal
operator|)
operator|!=
literal|0
condition|)
name|conflicts
operator|=
name|NEW2
argument_list|(
literal|4
operator|*
operator|(
name|SRtotal
operator|+
name|RRtotal
operator|)
argument_list|,
name|Value_t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|token_actions
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|lookaheads
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|LA
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|LAruleno
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|accessing_symbol
argument_list|)
expr_stmt|;
name|goto_actions
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|goto_map
operator|+
name|ntokens
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|from_state
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|to_state
argument_list|)
expr_stmt|;
name|sort_actions
argument_list|()
expr_stmt|;
name|pack_table
argument_list|()
expr_stmt|;
name|output_base
argument_list|()
expr_stmt|;
name|output_table
argument_list|()
expr_stmt|;
name|output_check
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|output_ctable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|is_C_identifier
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|s
operator|=
name|name
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_HEADER_GUARDS
end_if

begin_function
specifier|static
name|void
name|start_defines_file
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|defines_file
argument_list|,
literal|"#ifndef _%s_defines_h_\n"
argument_list|,
name|symbol_prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|defines_file
argument_list|,
literal|"#define _%s_defines_h_\n\n"
argument_list|,
name|symbol_prefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_defines_file
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|defines_file
argument_list|,
literal|"\n#endif /* _%s_defines_h_ */\n"
argument_list|,
name|symbol_prefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|start_defines_file
parameter_list|()
end_define

begin_comment
comment|/* nothing */
end_comment

begin_define
define|#
directive|define
name|end_defines_file
parameter_list|()
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|output_defines
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|=
name|symbol_name
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|is_C_identifier
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
operator|!
name|sflag
operator|||
operator|*
name|s
operator|!=
literal|'"'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define "
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|!=
literal|'"'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|!=
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|fp
operator|==
name|code_file
condition|)
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %d\n"
argument_list|,
name|symbol_value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp
operator|==
name|code_file
condition|)
operator|++
name|outline
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|defines_file
operator|||
name|iflag
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define YYERRCODE %d\n"
argument_list|,
name|symbol_value
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|defines_file
operator|||
operator|(
name|iflag
operator|&&
operator|!
name|dflag
operator|)
condition|)
block|{
if|if
condition|(
name|unionized
condition|)
block|{
if|if
condition|(
name|union_file
operator|!=
literal|0
condition|)
block|{
name|rewind
argument_list|(
name|union_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|union_file
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc_code
argument_list|(
name|fp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"extern YYSTYPE %slval;\n"
argument_list|,
name|symbol_prefix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_stored_text
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|rewind
argument_list|(
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_file
operator|==
name|NULL
condition|)
name|open_error
argument_list|(
literal|"text_file"
argument_list|)
expr_stmt|;
name|in
operator|=
name|text_file
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
name|putc_code
argument_list|(
name|fp
argument_list|,
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putc_code
argument_list|(
name|fp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|write_code_lineno
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_debug
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|max
decl_stmt|,
name|maxtok
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|symnam
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
literal|"#define YYFINAL %d\n"
argument_list|,
name|final_state
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"#ifndef YYDEBUG\n"
argument_list|)
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
literal|"#define YYDEBUG %d\n"
argument_list|,
name|tflag
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#ifndef YYDEBUG\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#define YYDEBUG %d\n"
argument_list|,
name|tflag
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
name|maxtok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|symbol_value
index|[
name|i
index|]
operator|>
name|maxtok
condition|)
name|maxtok
operator|=
name|symbol_value
index|[
name|i
index|]
expr_stmt|;
comment|/* symbol_value[$accept] = -1         */
comment|/* symbol_value[<goal>]  = 0          */
comment|/* remaining non-terminals start at 1 */
name|max
operator|=
name|maxtok
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
operator|(
name|maxtok
operator|+
literal|1
operator|)
operator|+
operator|(
name|symbol_value
index|[
name|i
index|]
operator|+
literal|1
operator|)
operator|)
operator|>
name|max
condition|)
name|max
operator|=
operator|(
name|maxtok
operator|+
literal|1
operator|)
operator|+
operator|(
name|symbol_value
index|[
name|i
index|]
operator|+
literal|1
operator|)
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
literal|"#define YYMAXTOKEN %d\n"
argument_list|,
name|maxtok
argument_list|)
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
literal|"#define YYUNDFTOKEN %d\n"
argument_list|,
name|max
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
literal|"#define YYTRANSLATE(a) ((a)> YYMAXTOKEN ? "
literal|"YYUNDFTOKEN : (a))\n"
argument_list|)
expr_stmt|;
name|symnam
operator|=
name|TMALLOC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|max
operator|+
literal|2
argument_list|)
expr_stmt|;
name|NO_SPACE
argument_list|(
name|symnam
argument_list|)
expr_stmt|;
comment|/* Note that it is not necessary to initialize the element          */
comment|/* symnam[max].                                                     */
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
name|symnam
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nsyms
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|symnam
index|[
name|symbol_pval
index|[
name|i
index|]
index|]
operator|=
name|symbol_name
index|[
name|i
index|]
expr_stmt|;
name|symnam
index|[
name|max
operator|+
literal|1
index|]
operator|=
literal|"illegal-symbol"
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
condition|;
operator|++
name|i
control|)
name|symnam
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
operator|-
literal|1
init|;
name|i
operator|>=
literal|2
condition|;
operator|--
name|i
control|)
name|symnam
index|[
name|symbol_value
index|[
name|i
index|]
index|]
operator|=
name|symbol_name
index|[
name|i
index|]
expr_stmt|;
name|symnam
index|[
literal|0
index|]
operator|=
literal|"end-of-file"
expr_stmt|;
name|symnam
index|[
name|max
operator|+
literal|1
index|]
operator|=
literal|"illegal-symbol"
expr_stmt|;
endif|#
directive|endif
comment|/*      * bison's yytname[] array is roughly the same as byacc's yyname[] array.      * The difference is that byacc does not predefine "$undefined".      *      * If the grammar declares "%token-table", define symbol "yytname" so      * an application such as ntpd can build.      */
if|if
condition|(
name|token_table
condition|)
block|{
name|output_line
argument_list|(
literal|"#undef yytname"
argument_list|)
expr_stmt|;
name|output_line
argument_list|(
literal|"#define yytname yyname"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_line
argument_list|(
literal|"#if YYDEBUG"
argument_list|)
expr_stmt|;
block|}
name|start_str_table
argument_list|(
literal|"name"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|80
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
operator|+
literal|1
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|symnam
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
name|k
operator|=
literal|7
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'"'
condition|)
block|{
operator|++
name|k
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\\'
condition|)
operator|++
name|k
expr_stmt|;
block|}
block|}
name|j
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\"\\\""
argument_list|)
expr_stmt|;
name|s
operator|=
name|symnam
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\"\","
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
block|{
name|j
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|7
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\"'\\\"'\","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|k
operator|=
literal|5
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'\''
condition|)
block|{
operator|++
name|k
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\\'
condition|)
operator|++
name|k
expr_stmt|;
block|}
block|}
name|j
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\"'"
argument_list|)
expr_stmt|;
name|s
operator|=
name|symnam
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'\''
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"'\","
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|k
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|3
expr_stmt|;
name|j
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'"'
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
do|do
block|{
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|s
condition|)
do|;
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\","
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|j
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|80
condition|)
block|{
name|output_newline
argument_list|()
expr_stmt|;
name|j
operator|=
literal|2
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"0,"
argument_list|)
expr_stmt|;
block|}
block|}
name|end_table
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|symnam
argument_list|)
expr_stmt|;
if|if
condition|(
name|token_table
condition|)
name|output_line
argument_list|(
literal|"#if YYDEBUG"
argument_list|)
expr_stmt|;
name|start_str_table
argument_list|(
literal|"rule"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nrules
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\"%s :"
argument_list|,
name|symbol_name
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|rrhs
index|[
name|i
index|]
init|;
name|ritem
index|[
name|j
index|]
operator|>
literal|0
condition|;
operator|++
name|j
control|)
block|{
name|s
operator|=
name|symbol_name
index|[
name|ritem
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" \\\""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\\\\\"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\\%c"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" '\\\"'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'\\'
condition|)
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" '\\\\\\\\"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" '\\\\%c"
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|'\''
condition|)
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\''
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" '%c'"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|" %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output_file
argument_list|,
literal|"\","
argument_list|)
expr_stmt|;
name|output_newline
argument_list|()
expr_stmt|;
block|}
name|end_table
argument_list|()
expr_stmt|;
name|output_line
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|void
name|output_backtracking_parser
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#undef YYBTYACC\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|backtrack
condition|)
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYBTYACC 1\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYDEBUGSTR (yytrial ? YYPREFIX \"debug(trial)\" : YYPREFIX \"debug\")\n"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYBTYACC 0\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYDEBUGSTR YYPREFIX \"debug\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|output_pure_parser
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|code_file
condition|)
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define YYPURE %d\n"
argument_list|,
name|pure_parser
argument_list|)
expr_stmt|;
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_stype
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|unionized
operator|&&
name|ntags
operator|==
literal|0
condition|)
block|{
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#if "
literal|"! defined(YYSTYPE)&& "
literal|"! defined(YYSTYPE_IS_DECLARED)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"/* Default: YYSTYPE is the semantic value type. */\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"typedef int YYSTYPE;\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYSTYPE_IS_DECLARED 1\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|void
name|output_ltype
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#if ! defined YYLTYPE&& ! defined YYLTYPE_IS_DECLARED\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"/* Default: YYLTYPE is the text position type. */\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"typedef struct YYLTYPE\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"    int first_line;\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"    int first_column;\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"    int last_line;\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"    int last_column;\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"} YYLTYPE;\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYLTYPE_IS_DECLARED 1\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|output_trailing_text
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|last
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return;
name|in
operator|=
name|input_file
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|lineno
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
name|write_input_lineno
argument_list|()
expr_stmt|;
name|putc_code
argument_list|(
name|code_file
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|write_input_lineno
argument_list|()
expr_stmt|;
do|do
block|{
name|putc_code
argument_list|(
name|code_file
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
operator|!=
literal|'\n'
condition|)
do|;
name|putc_code
argument_list|(
name|code_file
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|last
operator|=
literal|'\n'
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putc_code
argument_list|(
name|code_file
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|!=
literal|'\n'
condition|)
block|{
name|putc_code
argument_list|(
name|code_file
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|write_code_lineno
argument_list|(
name|code_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_semantic_actions
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|last
decl_stmt|;
name|rewind
argument_list|(
name|action_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|action_file
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
name|last
operator|=
name|c
expr_stmt|;
name|putc_code
argument_list|(
name|code_file
argument_list|,
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|action_file
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putc_code
argument_list|(
name|code_file
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|!=
literal|'\n'
condition|)
block|{
name|putc_code
argument_list|(
name|code_file
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|write_code_lineno
argument_list|(
name|code_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_parse_decl
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"/* compatibility with bison */\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#ifdef YYPARSE_PARAM\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"/* compatibility with FreeBSD */\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# ifdef YYPARSE_PARAM_TYPE\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# else\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# endif\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYPARSE_DECL() yyparse("
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_param
condition|)
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
else|else
block|{
name|param
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|parse_param
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %s%s%s"
argument_list|,
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|type2
argument_list|,
name|p
operator|->
name|next
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_lex_decl
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"/* Parameters sent to lex. */\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#ifdef YYLEX_PARAM\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pure_parser
condition|)
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# ifdef YYLEX_PARAM_TYPE\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#  define YYLEX_DECL() yylex(YYSTYPE *yylval, YYLTYPE *yylloc,"
literal|" YYLEX_PARAM_TYPE YYLEX_PARAM)\n"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#  define YYLEX_DECL() yylex(YYSTYPE *yylval,"
literal|" YYLEX_PARAM_TYPE YYLEX_PARAM)\n"
argument_list|)
expr_stmt|;
block|}
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# else\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#  define YYLEX_DECL() yylex(YYSTYPE *yylval, YYLTYPE *yylloc,"
literal|" void * YYLEX_PARAM)\n"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#  define YYLEX_DECL() yylex(YYSTYPE *yylval,"
literal|" void * YYLEX_PARAM)\n"
argument_list|)
expr_stmt|;
block|}
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# endif\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX yylex(&yylval,&yylloc, YYLEX_PARAM)\n"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX yylex(&yylval, YYLEX_PARAM)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX_DECL() yylex(void *YYLEX_PARAM)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX yylex(YYLEX_PARAM)\n"
argument_list|)
expr_stmt|;
block|}
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pure_parser
operator|&&
name|lex_param
condition|)
block|{
name|param
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX_DECL() yylex(YYSTYPE *yylval, YYLTYPE *yylloc, "
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX_DECL() yylex(YYSTYPE *yylval, "
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lex_param
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %s%s%s"
argument_list|,
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|type2
argument_list|,
name|p
operator|->
name|next
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX yylex(&yylval,&yylloc, "
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX yylex(&yylval, "
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lex_param
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|next
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pure_parser
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX_DECL() yylex(YYSTYPE *yylval, YYLTYPE *yylloc)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX yylex(&yylval,&yylloc)\n"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX_DECL() yylex(YYSTYPE *yylval)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX yylex(&yylval)\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lex_param
condition|)
block|{
name|param
modifier|*
name|p
decl_stmt|;
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX_DECL() yylex("
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lex_param
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %s%s%s"
argument_list|,
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|type2
argument_list|,
name|p
operator|->
name|next
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX yylex("
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lex_param
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|next
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX_DECL() yylex(void)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"# define YYLEX yylex()\n"
argument_list|)
expr_stmt|;
block|}
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_error_decl
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|param
modifier|*
name|p
decl_stmt|;
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"/* Parameters sent to yyerror. */\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#ifndef YYERROR_DECL\n"
argument_list|)
expr_stmt|;
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYERROR_DECL() yyerror("
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"YYLTYPE loc, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|parse_param
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %s%s, "
argument_list|,
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|type2
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"const char *s)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#ifndef YYERROR_CALL\n"
argument_list|)
expr_stmt|;
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYERROR_CALL(msg) yyerror("
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
name|puts_code
argument_list|(
name|fp
argument_list|,
literal|"yylloc, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|parse_param
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s, "
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"msg)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
end_if

begin_function
specifier|static
name|void
name|output_yydestruct_decl
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|putc_code
argument_list|(
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#ifndef YYDESTRUCT_DECL\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYDESTRUCT_DECL() yydestruct(const char *msg, int psymb, YYSTYPE *val, YYLTYPE *loc)\n"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYDESTRUCT_DECL() yydestruct(const char *msg, int psymb, YYSTYPE *val)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#ifndef YYDESTRUCT_CALL\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYDESTRUCT_CALL(msg, psymb, val, loc) yydestruct(msg, psymb, val, loc)\n"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#define YYDESTRUCT_CALL(msg, psymb, val) yydestruct(msg, psymb, val)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|fp
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_yydestruct_impl
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|destructor_code
decl_stmt|;
name|putc_code
argument_list|(
name|code_file
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"/* Release memory associated with symbol. */\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"#if ! defined YYDESTRUCT_IS_DECLARED\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"static void\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"YYDESTRUCT_DECL()\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"    switch (psymb)\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|destructor_code
operator|=
name|symbol_destructor
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
literal|"\tcase %d:\n"
argument_list|,
name|symbol_pval
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* comprehend the number of lines in the destructor code */
for|for
control|(
name|s
operator|=
name|destructor_code
init|;
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|s
operator|++
control|)
operator|++
name|outline
expr_stmt|;
name|puts_code
argument_list|(
name|code_file
argument_list|,
name|destructor_code
argument_list|)
expr_stmt|;
name|putc_code
argument_list|(
name|code_file
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"\tbreak;\n"
argument_list|)
expr_stmt|;
name|write_code_lineno
argument_list|(
name|code_file
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|destructor_code
argument_list|)
expr_stmt|;
block|}
block|}
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"    }\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"#define YYDESTRUCT_IS_DECLARED 1\n"
argument_list|)
expr_stmt|;
name|putl_code
argument_list|(
name|code_file
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|symbol_destructor
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|free_itemsets
parameter_list|(
name|void
parameter_list|)
block|{
name|core
modifier|*
name|cp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|FREE
argument_list|(
name|state_table
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|first_state
init|;
name|cp
condition|;
name|cp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|cp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_shifts
parameter_list|(
name|void
parameter_list|)
block|{
name|shifts
modifier|*
name|sp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|FREE
argument_list|(
name|shift_table
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_shift
init|;
name|sp
condition|;
name|sp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_reductions
parameter_list|(
name|void
parameter_list|)
block|{
name|reductions
modifier|*
name|rp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|FREE
argument_list|(
name|reduction_table
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|first_reduction
init|;
name|rp
condition|;
name|rp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|rp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_externs
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|section
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|s
operator|=
name|section
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
comment|/* prefix non-blank lines that don't start with 	   C pre-processor directives with 'extern ' */
if|if
condition|(
operator|*
name|s
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'#'
operator|)
condition|)
name|fputs
argument_list|(
literal|"extern\t"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|code_file
condition|)
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|output
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|free_itemsets
argument_list|()
expr_stmt|;
name|free_shifts
argument_list|()
expr_stmt|;
name|free_reductions
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|output_backtracking_parser
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|output_backtracking_parser
argument_list|(
name|code_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iflag
condition|)
block|{
name|write_code_lineno
argument_list|(
name|code_file
argument_list|)
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|externs_file_name
argument_list|)
expr_stmt|;
name|fp
operator|=
name|externs_file
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|code_file
expr_stmt|;
name|output_prefix
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|output_pure_parser
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|output_stored_text
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|output_stype
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|locations
condition|)
name|output_ltype
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|output_parse_decl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|output_lex_decl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|output_error_decl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|destructor
condition|)
name|output_yydestruct_decl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iflag
operator|||
operator|!
name|rflag
condition|)
block|{
name|write_section
argument_list|(
name|fp
argument_list|,
name|xdecls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iflag
condition|)
block|{
name|output_externs
argument_list|(
name|externs_file
argument_list|,
name|global_vars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pure_parser
condition|)
name|output_externs
argument_list|(
name|externs_file
argument_list|,
name|impure_vars
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iflag
condition|)
block|{
if|if
condition|(
name|dflag
condition|)
block|{
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|code_file
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|defines_file_name
argument_list|)
expr_stmt|;
block|}
else|else
name|output_defines
argument_list|(
name|externs_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc_code
argument_list|(
name|code_file
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|output_defines
argument_list|(
name|code_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dflag
condition|)
block|{
name|start_defines_file
argument_list|()
expr_stmt|;
name|output_defines
argument_list|(
name|defines_file
argument_list|)
expr_stmt|;
name|end_defines_file
argument_list|()
expr_stmt|;
block|}
name|output_rule_data
argument_list|()
expr_stmt|;
name|output_yydefred
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
name|output_accessing_symbols
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|output_actions
argument_list|()
expr_stmt|;
name|free_parser
argument_list|()
expr_stmt|;
name|output_debug
argument_list|()
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|write_section
argument_list|(
name|code_file
argument_list|,
name|xdecls
argument_list|)
expr_stmt|;
name|output_YYINT_typedef
argument_list|(
name|code_file
argument_list|)
expr_stmt|;
name|write_section
argument_list|(
name|code_file
argument_list|,
name|tables
argument_list|)
expr_stmt|;
block|}
name|write_section
argument_list|(
name|code_file
argument_list|,
name|global_vars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pure_parser
condition|)
block|{
name|write_section
argument_list|(
name|code_file
argument_list|,
name|impure_vars
argument_list|)
expr_stmt|;
block|}
name|write_section
argument_list|(
name|code_file
argument_list|,
name|hdr_defs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pure_parser
condition|)
block|{
name|write_section
argument_list|(
name|code_file
argument_list|,
name|hdr_vars
argument_list|)
expr_stmt|;
block|}
name|output_trailing_text
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|YYBTYACC
argument_list|)
if|if
condition|(
name|destructor
condition|)
name|output_yydestruct_impl
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|write_section
argument_list|(
name|code_file
argument_list|,
name|body_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pure_parser
condition|)
block|{
name|write_section
argument_list|(
name|code_file
argument_list|,
name|body_vars
argument_list|)
expr_stmt|;
block|}
name|write_section
argument_list|(
name|code_file
argument_list|,
name|body_2
argument_list|)
expr_stmt|;
name|output_semantic_actions
argument_list|()
expr_stmt|;
name|write_section
argument_list|(
name|code_file
argument_list|,
name|trailer
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_LEAKS
end_ifdef

begin_function
name|void
name|output_leaks
parameter_list|(
name|void
parameter_list|)
block|{
name|DO_FREE
argument_list|(
name|tally
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|DO_FREE
argument_list|(
name|order
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

