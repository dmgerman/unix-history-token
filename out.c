begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: out.c,v 1.70 2017/06/27 18:25:02 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2011, 2014, 2015, 2017 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"out.h"
end_include

begin_function_decl
specifier|static
name|void
name|tblcalc_data
parameter_list|(
name|struct
name|rofftbl
modifier|*
parameter_list|,
name|struct
name|roffcol
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_opts
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tblcalc_literal
parameter_list|(
name|struct
name|rofftbl
modifier|*
parameter_list|,
name|struct
name|roffcol
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tblcalc_number
parameter_list|(
name|struct
name|rofftbl
modifier|*
parameter_list|,
name|struct
name|roffcol
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_opts
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Parse the *src string and store a scaling unit into *dst.  * If the string doesn't specify the unit, use the default.  * If no default is specified, fail.  * Return a pointer to the byte after the last byte used,  * or NULL on total failure.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|a2roffsu
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|struct
name|roffsu
modifier|*
name|dst
parameter_list|,
name|enum
name|roffscale
name|def
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|dst
operator|->
name|unit
operator|=
name|def
operator|==
name|SCALE_MAX
condition|?
name|SCALE_BU
else|:
name|def
expr_stmt|;
name|dst
operator|->
name|scale
operator|=
name|strtod
argument_list|(
name|src
argument_list|,
operator|&
name|endptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|endptr
operator|==
name|src
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
operator|*
name|endptr
operator|++
condition|)
block|{
case|case
literal|'c'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_CM
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_IN
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_FS
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_MM
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_EM
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_EN
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_PC
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_PT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_BU
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|dst
operator|->
name|unit
operator|=
name|SCALE_VS
expr_stmt|;
break|break;
default|default:
name|endptr
operator|--
expr_stmt|;
if|if
condition|(
name|SCALE_MAX
operator|==
name|def
condition|)
return|return
name|NULL
return|;
name|dst
operator|->
name|unit
operator|=
name|def
expr_stmt|;
break|break;
block|}
return|return
name|endptr
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the abstract widths and decimal positions of columns in a  * table.  This routine allocates the columns structures then runs over  * all rows and cells in the table.  The function pointers in "tbl" are  * used for the actual width calculations.  */
end_comment

begin_function
name|void
name|tblcalc
parameter_list|(
name|struct
name|rofftbl
modifier|*
name|tbl
parameter_list|,
specifier|const
name|struct
name|tbl_span
modifier|*
name|sp
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|size_t
name|rmargin
parameter_list|)
block|{
name|struct
name|roffsu
name|su
decl_stmt|;
specifier|const
name|struct
name|tbl_opts
modifier|*
name|opts
decl_stmt|;
specifier|const
name|struct
name|tbl_dat
modifier|*
name|dp
decl_stmt|;
name|struct
name|roffcol
modifier|*
name|col
decl_stmt|;
name|size_t
name|ewidth
decl_stmt|,
name|xwidth
decl_stmt|;
name|int
name|spans
decl_stmt|;
name|int
name|icol
decl_stmt|,
name|maxcol
decl_stmt|,
name|necol
decl_stmt|,
name|nxcol
decl_stmt|,
name|quirkcol
decl_stmt|;
comment|/* 	 * Allocate the master column specifiers.  These will hold the 	 * widths and decimal positions for all cells in the column.  It 	 * must be freed and nullified by the caller. 	 */
name|assert
argument_list|(
name|NULL
operator|==
name|tbl
operator|->
name|cols
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|cols
operator|=
name|mandoc_calloc
argument_list|(
operator|(
name|size_t
operator|)
name|sp
operator|->
name|opts
operator|->
name|cols
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|roffcol
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|=
name|sp
operator|->
name|opts
expr_stmt|;
for|for
control|(
name|maxcol
operator|=
operator|-
literal|1
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TBL_SPAN_DATA
operator|!=
name|sp
operator|->
name|pos
condition|)
continue|continue;
name|spans
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Account for the data cells in the layout, matching it 		 * to data cells in the data section. 		 */
for|for
control|(
name|dp
operator|=
name|sp
operator|->
name|first
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{
comment|/* Do not used spanned cells in the calculation. */
if|if
condition|(
literal|0
operator|<
operator|--
name|spans
condition|)
continue|continue;
name|spans
operator|=
name|dp
operator|->
name|spans
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|spans
condition|)
continue|continue;
name|icol
operator|=
name|dp
operator|->
name|layout
operator|->
name|col
expr_stmt|;
while|while
condition|(
name|maxcol
operator|<
name|icol
condition|)
name|tbl
operator|->
name|cols
index|[
operator|++
name|maxcol
index|]
operator|.
name|spacing
operator|=
name|SIZE_MAX
expr_stmt|;
name|col
operator|=
name|tbl
operator|->
name|cols
operator|+
name|icol
expr_stmt|;
name|col
operator|->
name|flags
operator||=
name|dp
operator|->
name|layout
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|layout
operator|->
name|flags
operator|&
name|TBL_CELL_WIGN
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|layout
operator|->
name|wstr
operator|!=
name|NULL
operator|&&
name|dp
operator|->
name|layout
operator|->
name|width
operator|==
literal|0
operator|&&
name|a2roffsu
argument_list|(
name|dp
operator|->
name|layout
operator|->
name|wstr
argument_list|,
operator|&
name|su
argument_list|,
name|SCALE_EN
argument_list|)
operator|!=
name|NULL
condition|)
name|dp
operator|->
name|layout
operator|->
name|width
operator|=
call|(
modifier|*
name|tbl
operator|->
name|sulen
call|)
argument_list|(
operator|&
name|su
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|width
operator|<
name|dp
operator|->
name|layout
operator|->
name|width
condition|)
name|col
operator|->
name|width
operator|=
name|dp
operator|->
name|layout
operator|->
name|width
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|layout
operator|->
name|spacing
operator|!=
name|SIZE_MAX
operator|&&
operator|(
name|col
operator|->
name|spacing
operator|==
name|SIZE_MAX
operator|||
name|col
operator|->
name|spacing
operator|<
name|dp
operator|->
name|layout
operator|->
name|spacing
operator|)
condition|)
name|col
operator|->
name|spacing
operator|=
name|dp
operator|->
name|layout
operator|->
name|spacing
expr_stmt|;
name|tblcalc_data
argument_list|(
name|tbl
argument_list|,
name|col
argument_list|,
name|opts
argument_list|,
name|dp
argument_list|,
name|dp
operator|->
name|block
operator|==
literal|0
condition|?
literal|0
else|:
name|dp
operator|->
name|layout
operator|->
name|width
condition|?
name|dp
operator|->
name|layout
operator|->
name|width
else|:
name|rmargin
condition|?
operator|(
name|rmargin
operator|+
name|sp
operator|->
name|opts
operator|->
name|cols
operator|/
literal|2
operator|)
operator|/
operator|(
name|sp
operator|->
name|opts
operator|->
name|cols
operator|+
literal|1
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Count columns to equalize and columns to maximize. 	 * Find maximum width of the columns to equalize. 	 * Find total width of the columns *not* to maximize. 	 */
name|necol
operator|=
name|nxcol
operator|=
literal|0
expr_stmt|;
name|ewidth
operator|=
name|xwidth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<=
name|maxcol
condition|;
name|icol
operator|++
control|)
block|{
name|col
operator|=
name|tbl
operator|->
name|cols
operator|+
name|icol
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|spacing
operator|==
name|SIZE_MAX
operator|||
name|icol
operator|==
name|maxcol
condition|)
name|col
operator|->
name|spacing
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|flags
operator|&
name|TBL_CELL_EQUAL
condition|)
block|{
name|necol
operator|++
expr_stmt|;
if|if
condition|(
name|ewidth
operator|<
name|col
operator|->
name|width
condition|)
name|ewidth
operator|=
name|col
operator|->
name|width
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|->
name|flags
operator|&
name|TBL_CELL_WMAX
condition|)
name|nxcol
operator|++
expr_stmt|;
else|else
name|xwidth
operator|+=
name|col
operator|->
name|width
expr_stmt|;
block|}
comment|/* 	 * Equalize columns, if requested for any of them. 	 * Update total width of the columns not to maximize. 	 */
if|if
condition|(
name|necol
condition|)
block|{
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<=
name|maxcol
condition|;
name|icol
operator|++
control|)
block|{
name|col
operator|=
name|tbl
operator|->
name|cols
operator|+
name|icol
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|col
operator|->
name|flags
operator|&
name|TBL_CELL_EQUAL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|col
operator|->
name|width
operator|==
name|ewidth
condition|)
continue|continue;
if|if
condition|(
name|nxcol
operator|&&
name|rmargin
condition|)
name|xwidth
operator|+=
name|ewidth
operator|-
name|col
operator|->
name|width
expr_stmt|;
name|col
operator|->
name|width
operator|=
name|ewidth
expr_stmt|;
block|}
block|}
comment|/* 	 * If there are any columns to maximize, find the total 	 * available width, deducting 3n margins between columns. 	 * Distribute the available width evenly. 	 */
if|if
condition|(
name|nxcol
operator|&&
name|rmargin
condition|)
block|{
name|xwidth
operator|+=
literal|3
operator|*
name|maxcol
operator|+
operator|(
name|opts
operator|->
name|opts
operator|&
operator|(
name|TBL_OPT_BOX
operator||
name|TBL_OPT_DBOX
operator|)
condition|?
literal|2
else|:
operator|!
operator|!
name|opts
operator|->
name|lvert
operator|+
operator|!
operator|!
name|opts
operator|->
name|rvert
operator|)
expr_stmt|;
if|if
condition|(
name|rmargin
operator|<=
name|offset
operator|+
name|xwidth
condition|)
return|return;
name|xwidth
operator|=
name|rmargin
operator|-
name|offset
operator|-
name|xwidth
expr_stmt|;
comment|/* 		 * Emulate a bug in GNU tbl width calculation that 		 * manifests itself for large numbers of x-columns. 		 * Emulating it for 5 x-columns gives identical 		 * behaviour for up to 6 x-columns. 		 */
if|if
condition|(
name|nxcol
operator|==
literal|5
condition|)
block|{
name|quirkcol
operator|=
name|xwidth
operator|%
name|nxcol
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|quirkcol
operator|!=
literal|3
operator|&&
name|quirkcol
operator|!=
literal|4
condition|)
name|quirkcol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|quirkcol
operator|=
operator|-
literal|1
expr_stmt|;
name|necol
operator|=
literal|0
expr_stmt|;
name|ewidth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<=
name|maxcol
condition|;
name|icol
operator|++
control|)
block|{
name|col
operator|=
name|tbl
operator|->
name|cols
operator|+
name|icol
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|col
operator|->
name|flags
operator|&
name|TBL_CELL_WMAX
operator|)
condition|)
continue|continue;
name|col
operator|->
name|width
operator|=
operator|(
name|double
operator|)
name|xwidth
operator|*
operator|++
name|necol
operator|/
name|nxcol
operator|-
name|ewidth
operator|+
literal|0.4995
expr_stmt|;
if|if
condition|(
name|necol
operator|==
name|quirkcol
condition|)
name|col
operator|->
name|width
operator|--
expr_stmt|;
name|ewidth
operator|+=
name|col
operator|->
name|width
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tblcalc_data
parameter_list|(
name|struct
name|rofftbl
modifier|*
name|tbl
parameter_list|,
name|struct
name|roffcol
modifier|*
name|col
parameter_list|,
specifier|const
name|struct
name|tbl_opts
modifier|*
name|opts
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
name|dp
parameter_list|,
name|size_t
name|mw
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
comment|/* Branch down into data sub-types. */
switch|switch
condition|(
name|dp
operator|->
name|layout
operator|->
name|pos
condition|)
block|{
case|case
name|TBL_CELL_HORIZ
case|:
case|case
name|TBL_CELL_DHORIZ
case|:
name|sz
operator|=
call|(
modifier|*
name|tbl
operator|->
name|len
call|)
argument_list|(
literal|1
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|width
operator|<
name|sz
condition|)
name|col
operator|->
name|width
operator|=
name|sz
expr_stmt|;
break|break;
case|case
name|TBL_CELL_LONG
case|:
case|case
name|TBL_CELL_CENTRE
case|:
case|case
name|TBL_CELL_LEFT
case|:
case|case
name|TBL_CELL_RIGHT
case|:
name|tblcalc_literal
argument_list|(
name|tbl
argument_list|,
name|col
argument_list|,
name|dp
argument_list|,
name|mw
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_CELL_NUMBER
case|:
name|tblcalc_number
argument_list|(
name|tbl
argument_list|,
name|col
argument_list|,
name|opts
argument_list|,
name|dp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_CELL_DOWN
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tblcalc_literal
parameter_list|(
name|struct
name|rofftbl
modifier|*
name|tbl
parameter_list|,
name|struct
name|roffcol
modifier|*
name|col
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
name|dp
parameter_list|,
name|size_t
name|mw
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Beginning of the first line. */
specifier|const
name|char
modifier|*
name|beg
decl_stmt|;
comment|/* Beginning of the current line. */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* End of the current line. */
name|size_t
name|lsz
decl_stmt|;
comment|/* Length of the current line. */
name|size_t
name|wsz
decl_stmt|;
comment|/* Length of the current word. */
if|if
condition|(
name|dp
operator|->
name|string
operator|==
name|NULL
operator|||
operator|*
name|dp
operator|->
name|string
operator|==
literal|'\0'
condition|)
return|return;
name|str
operator|=
name|mw
condition|?
name|mandoc_strdup
argument_list|(
name|dp
operator|->
name|string
argument_list|)
else|:
name|dp
operator|->
name|string
expr_stmt|;
name|lsz
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|beg
operator|=
name|str
init|;
name|beg
operator|!=
name|NULL
operator|&&
operator|*
name|beg
operator|!=
literal|'\0'
condition|;
name|beg
operator|=
name|end
control|)
block|{
name|end
operator|=
name|mw
condition|?
name|strchr
argument_list|(
name|beg
argument_list|,
literal|' '
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
block|{
operator|*
name|end
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|end
operator|==
literal|' '
condition|)
name|end
operator|++
expr_stmt|;
block|}
name|wsz
operator|=
call|(
modifier|*
name|tbl
operator|->
name|slen
call|)
argument_list|(
name|beg
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mw
operator|&&
name|lsz
operator|&&
name|lsz
operator|+
literal|1
operator|+
name|wsz
operator|<=
name|mw
condition|)
name|lsz
operator|+=
literal|1
operator|+
name|wsz
expr_stmt|;
else|else
name|lsz
operator|=
name|wsz
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|width
operator|<
name|lsz
condition|)
name|col
operator|->
name|width
operator|=
name|lsz
expr_stmt|;
block|}
if|if
condition|(
name|mw
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tblcalc_number
parameter_list|(
name|struct
name|rofftbl
modifier|*
name|tbl
parameter_list|,
name|struct
name|roffcol
modifier|*
name|col
parameter_list|,
specifier|const
name|struct
name|tbl_opts
modifier|*
name|opts
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
name|dp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|psz
decl_stmt|,
name|ssz
decl_stmt|,
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 * First calculate number width and decimal place (last + 1 for 	 * non-decimal numbers).  If the stored decimal is subsequent to 	 * ours, make our size longer by that difference 	 * (right-"shifting"); similarly, if ours is subsequent the 	 * stored, then extend the stored size by the difference. 	 * Finally, re-assign the stored values. 	 */
name|str
operator|=
name|dp
operator|->
name|string
condition|?
name|dp
operator|->
name|string
else|:
literal|""
expr_stmt|;
name|sz
operator|=
call|(
modifier|*
name|tbl
operator|->
name|slen
call|)
argument_list|(
name|str
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
comment|/* FIXME: TBL_DATA_HORIZ et al.? */
name|buf
index|[
literal|0
index|]
operator|=
name|opts
operator|->
name|decimal
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|psz
operator|=
call|(
modifier|*
name|tbl
operator|->
name|slen
call|)
argument_list|(
name|buf
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|str
argument_list|,
name|opts
operator|->
name|decimal
argument_list|)
operator|)
condition|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ssz
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|cp
operator|!=
operator|&
name|str
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|ssz
operator|+=
call|(
modifier|*
name|tbl
operator|->
name|slen
call|)
argument_list|(
name|buf
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|ssz
operator|+
name|psz
expr_stmt|;
block|}
else|else
name|d
operator|=
name|sz
operator|+
name|psz
expr_stmt|;
comment|/* Adjust the settings for this column. */
if|if
condition|(
name|col
operator|->
name|decimal
operator|>
name|d
condition|)
block|{
name|sz
operator|+=
name|col
operator|->
name|decimal
operator|-
name|d
expr_stmt|;
name|d
operator|=
name|col
operator|->
name|decimal
expr_stmt|;
block|}
else|else
name|col
operator|->
name|width
operator|+=
name|d
operator|-
name|col
operator|->
name|decimal
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|col
operator|->
name|width
condition|)
name|col
operator|->
name|width
operator|=
name|sz
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|col
operator|->
name|decimal
condition|)
name|col
operator|->
name|decimal
operator|=
name|d
expr_stmt|;
block|}
end_function

end_unit

