begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: auth2-jpake.c,v 1.3 2009/03/05 07:18:19 djm Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008 Damien Miller.  All rights reserved.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Server side of zero-knowledge password auth using J-PAKE protocol  * as described in:  *  * F. Hao, P. Ryan, "Password Authenticated Key Exchange by Juggling",  * 16th Workshop on Security Protocols, Cambridge, April 2008  *  * http://grouper.ieee.org/groups/1363/Research/contributions/hao-ryan-2008.pdf  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JPAKE
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<login_cap.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"auth-options.h"
end_include

begin_include
include|#
directive|include
file|"canohost.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_include
include|#
directive|include
file|"ssh-gss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"monitor_wrap.h"
end_include

begin_include
include|#
directive|include
file|"schnorr.h"
end_include

begin_include
include|#
directive|include
file|"jpake.h"
end_include

begin_comment
comment|/*  * XXX options->permit_empty_passwd (at the moment, they will be refused  * anyway because they will mismatch on fake salt.  */
end_comment

begin_comment
comment|/* Dispatch handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|input_userauth_jpake_client_step1
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|input_userauth_jpake_client_step2
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|input_userauth_jpake_client_confirm
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|auth2_jpake_start
parameter_list|(
name|Authctxt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* import */
end_comment

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
modifier|*
name|session_id2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_int
name|session_id2_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Attempt J-PAKE authentication.  */
end_comment

begin_function
specifier|static
name|int
name|userauth_jpake
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|)
block|{
name|int
name|authenticated
init|=
literal|0
decl_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"jpake-01@openssh.com requested"
argument_list|)
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|user
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|authctxt
operator|->
name|jpake_ctx
operator|==
name|NULL
condition|)
name|authctxt
operator|->
name|jpake_ctx
operator|=
name|jpake_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|zero_knowledge_password_authentication
condition|)
name|authenticated
operator|=
name|auth2_jpake_start
argument_list|(
name|authctxt
argument_list|)
expr_stmt|;
block|}
return|return
name|authenticated
return|;
block|}
end_function

begin_decl_stmt
name|Authmethod
name|method_jpake
init|=
block|{
literal|"jpake-01@openssh.com"
block|,
name|userauth_jpake
block|,
operator|&
name|options
operator|.
name|zero_knowledge_password_authentication
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear context and callbacks */
end_comment

begin_function
name|void
name|auth2_jpake_stop
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|)
block|{
comment|/* unregister callbacks */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_CLIENT_CONFIRM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|jpake_ctx
operator|!=
name|NULL
condition|)
block|{
name|jpake_free
argument_list|(
name|authctxt
operator|->
name|jpake_ctx
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|jpake_ctx
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns 1 if 'c' is a valid crypt(3) salt character, 0 otherwise */
end_comment

begin_function
specifier|static
name|int
name|valid_crypt_salt
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|>=
literal|'.'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Derive fake salt as H(username || first_private_host_key)  * This provides relatively stable fake salts for non-existent  * users and avoids the jpake method becoming an account validity  * oracle.  */
end_comment

begin_function
specifier|static
name|void
name|derive_rawsalt
parameter_list|(
specifier|const
name|char
modifier|*
name|username
parameter_list|,
name|u_char
modifier|*
name|rawsalt
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|digest
decl_stmt|;
name|u_int
name|digest_len
decl_stmt|;
name|Buffer
name|b
decl_stmt|;
name|Key
modifier|*
name|k
decl_stmt|;
name|buffer_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|buffer_put_cstring
argument_list|(
operator|&
name|b
argument_list|,
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|get_hostkey_by_index
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|k
operator|->
name|flags
operator|&
name|KEY_FLAG_EXT
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s: no hostkeys"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|k
operator|->
name|type
condition|)
block|{
case|case
name|KEY_RSA1
case|:
case|case
name|KEY_RSA
case|:
if|if
condition|(
name|k
operator|->
name|rsa
operator|->
name|p
operator|==
name|NULL
operator|||
name|k
operator|->
name|rsa
operator|->
name|q
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: RSA key missing p and/or q"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|k
operator|->
name|rsa
operator|->
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_DSA
case|:
if|if
condition|(
name|k
operator|->
name|dsa
operator|->
name|priv_key
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: DSA key missing priv_key"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|buffer_put_bignum2
argument_list|(
operator|&
name|b
argument_list|,
name|k
operator|->
name|dsa
operator|->
name|priv_key
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"%s: unknown key type %d"
argument_list|,
name|__func__
argument_list|,
name|k
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hash_buffer
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|b
argument_list|)
argument_list|,
name|EVP_sha256
argument_list|()
argument_list|,
operator|&
name|digest
argument_list|,
operator|&
name|digest_len
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: hash_buffer"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|digest_len
condition|)
name|fatal
argument_list|(
literal|"%s: not enough bytes for rawsalt (want %u have %u)"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|,
name|digest_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rawsalt
argument_list|,
name|digest
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|digest
argument_list|,
name|digest_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|digest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASCII an integer [0, 64) for inclusion in a password/salt */
end_comment

begin_function
specifier|static
name|char
name|pw_encode64
parameter_list|(
name|u_int
name|i64
parameter_list|)
block|{
specifier|const
name|u_char
name|e64
index|[]
init|=
literal|"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
decl_stmt|;
return|return
name|e64
index|[
name|i64
operator|%
literal|64
index|]
return|;
block|}
end_function

begin_comment
comment|/* Generate ASCII salt bytes for user */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|makesalt
parameter_list|(
name|u_int
name|want
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|)
block|{
name|u_char
name|rawsalt
index|[
literal|32
index|]
decl_stmt|;
specifier|static
name|char
name|ret
index|[
literal|33
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|want
operator|>
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: want %u"
argument_list|,
name|__func__
argument_list|,
name|want
argument_list|)
expr_stmt|;
name|derive_rawsalt
argument_list|(
name|user
argument_list|,
name|rawsalt
argument_list|,
sizeof|sizeof
argument_list|(
name|rawsalt
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|want
condition|;
name|i
operator|++
control|)
name|ret
index|[
name|i
index|]
operator|=
name|pw_encode64
argument_list|(
name|rawsalt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rawsalt
argument_list|,
sizeof|sizeof
argument_list|(
name|rawsalt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Select the system's default password hashing scheme and generate  * a stable fake salt under it for use by a non-existent account.  * Prevents jpake method being used to infer the validity of accounts.  */
end_comment

begin_function
specifier|static
name|void
name|fake_salt_and_scheme
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|,
name|char
modifier|*
modifier|*
name|salt
parameter_list|,
name|char
modifier|*
modifier|*
name|scheme
parameter_list|)
block|{
name|char
modifier|*
name|rounds_s
decl_stmt|,
modifier|*
name|style
decl_stmt|;
name|long
name|long
name|rounds
decl_stmt|;
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
if|if
condition|(
operator|(
name|lc
operator|=
name|login_getclass
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_class
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|lc
operator|=
name|login_getclass
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: login_getclass failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|style
operator|=
name|login_getcapstr
argument_list|(
name|lc
argument_list|,
literal|"localcipher"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|NULL
condition|)
name|style
operator|=
name|xstrdup
argument_list|(
literal|"blowfish,6"
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rounds_s
operator|=
name|strchr
argument_list|(
name|style
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|rounds_s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|rounds
operator|=
name|strtonum
argument_list|(
name|rounds_s
argument_list|,
literal|1
argument_list|,
literal|1
operator|<<
literal|31
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|style
argument_list|,
literal|"md5"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xasprintf
argument_list|(
name|salt
argument_list|,
literal|"$1$%s$"
argument_list|,
name|makesalt
argument_list|(
literal|8
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|scheme
operator|=
name|xstrdup
argument_list|(
literal|"md5"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|style
argument_list|,
literal|"old"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|salt
operator|=
name|xstrdup
argument_list|(
name|makesalt
argument_list|(
literal|2
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|scheme
operator|=
name|xstrdup
argument_list|(
literal|"crypt"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|style
argument_list|,
literal|"newsalt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rounds
operator|=
name|MAX
argument_list|(
name|rounds
argument_list|,
literal|7250
argument_list|)
expr_stmt|;
name|rounds
operator|=
name|MIN
argument_list|(
name|rounds
argument_list|,
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
name|salt
argument_list|,
literal|"_%c%c%c%c%s"
argument_list|,
name|pw_encode64
argument_list|(
name|rounds
argument_list|)
argument_list|,
name|pw_encode64
argument_list|(
name|rounds
operator|>>
literal|6
argument_list|)
argument_list|,
name|pw_encode64
argument_list|(
name|rounds
operator|>>
literal|12
argument_list|)
argument_list|,
name|pw_encode64
argument_list|(
name|rounds
operator|>>
literal|18
argument_list|)
argument_list|,
name|makesalt
argument_list|(
literal|4
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|scheme
operator|=
name|xstrdup
argument_list|(
literal|"crypt-extended"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Default to blowfish */
name|rounds
operator|=
name|MAX
argument_list|(
name|rounds
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|rounds
operator|=
name|MIN
argument_list|(
name|rounds
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
name|salt
argument_list|,
literal|"$2a$%02lld$%s"
argument_list|,
name|rounds
argument_list|,
name|makesalt
argument_list|(
literal|22
argument_list|,
name|authctxt
operator|->
name|user
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|scheme
operator|=
name|xstrdup
argument_list|(
literal|"bcrypt"
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|style
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: fake %s salt for user %s: %s"
argument_list|,
name|__func__
argument_list|,
operator|*
name|scheme
argument_list|,
name|authctxt
operator|->
name|user
argument_list|,
operator|*
name|salt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch password hashing scheme, password salt and derive shared secret  * for user. If user does not exist, a fake but stable and user-unique  * salt will be returned.  */
end_comment

begin_function
name|void
name|auth2_jpake_get_pwdata
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|,
name|BIGNUM
modifier|*
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|hash_scheme
parameter_list|,
name|char
modifier|*
modifier|*
name|salt
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|secret
decl_stmt|;
name|u_int
name|secret_len
decl_stmt|,
name|salt_len
decl_stmt|;
ifdef|#
directive|ifdef
name|JPAKE_DEBUG
name|debug3
argument_list|(
literal|"%s: valid %d pw %.5s..."
argument_list|,
name|__func__
argument_list|,
name|authctxt
operator|->
name|valid
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|salt
operator|=
name|NULL
expr_stmt|;
operator|*
name|hash_scheme
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|authctxt
operator|->
name|valid
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
literal|"$2$"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|)
operator|>
literal|28
condition|)
block|{
comment|/* 			 * old-variant bcrypt: 			 *     "$2$", 2 digit rounds, "$", 22 bytes salt 			 */
name|salt_len
operator|=
literal|3
operator|+
literal|2
operator|+
literal|1
operator|+
literal|22
operator|+
literal|1
expr_stmt|;
operator|*
name|salt
operator|=
name|xmalloc
argument_list|(
name|salt_len
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|*
name|salt
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
operator|*
name|hash_scheme
operator|=
name|xstrdup
argument_list|(
literal|"bcrypt"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
literal|"$2a$"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|)
operator|>
literal|29
condition|)
block|{
comment|/* 			 * current-variant bcrypt: 			 *     "$2a$", 2 digit rounds, "$", 22 bytes salt 			 */
name|salt_len
operator|=
literal|4
operator|+
literal|2
operator|+
literal|1
operator|+
literal|22
operator|+
literal|1
expr_stmt|;
operator|*
name|salt
operator|=
name|xmalloc
argument_list|(
name|salt_len
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|*
name|salt
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
operator|*
name|hash_scheme
operator|=
name|xstrdup
argument_list|(
literal|"bcrypt"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
literal|"$1$"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|)
operator|>
literal|5
condition|)
block|{
comment|/* 			 * md5crypt: 			 *     "$1$", salt until "$" 			 */
name|cp
operator|=
name|strchr
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
operator|+
literal|3
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|salt_len
operator|=
operator|(
name|cp
operator|-
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
operator|)
operator|+
literal|1
expr_stmt|;
operator|*
name|salt
operator|=
name|xmalloc
argument_list|(
name|salt_len
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|*
name|salt
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
operator|*
name|hash_scheme
operator|=
name|xstrdup
argument_list|(
literal|"md5crypt"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
literal|"_"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|)
operator|>
literal|9
condition|)
block|{
comment|/* 			 * BSDI extended crypt: 			 *     "_", 4 digits count, 4 chars salt 			 */
name|salt_len
operator|=
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|1
expr_stmt|;
operator|*
name|salt
operator|=
name|xmalloc
argument_list|(
name|salt_len
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|*
name|salt
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
operator|*
name|hash_scheme
operator|=
name|xstrdup
argument_list|(
literal|"crypt-extended"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|)
operator|==
literal|13
operator|&&
name|valid_crypt_salt
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
index|[
literal|0
index|]
argument_list|)
operator|&&
name|valid_crypt_salt
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 			 * traditional crypt: 			 *     2 chars salt 			 */
name|salt_len
operator|=
literal|2
operator|+
literal|1
expr_stmt|;
operator|*
name|salt
operator|=
name|xmalloc
argument_list|(
name|salt_len
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|*
name|salt
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
operator|*
name|hash_scheme
operator|=
name|xstrdup
argument_list|(
literal|"crypt"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|salt
operator|==
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"%s: unrecognised crypt scheme for user %s"
argument_list|,
name|__func__
argument_list|,
name|authctxt
operator|->
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|salt
operator|==
name|NULL
condition|)
name|fake_salt_and_scheme
argument_list|(
name|authctxt
argument_list|,
name|salt
argument_list|,
name|hash_scheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_buffer
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|,
name|strlen
argument_list|(
name|authctxt
operator|->
name|pw
operator|->
name|pw_passwd
argument_list|)
argument_list|,
name|EVP_sha256
argument_list|()
argument_list|,
operator|&
name|secret
argument_list|,
operator|&
name|secret_len
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: hash_buffer"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|=
name|BN_bin2bn
argument_list|(
name|secret
argument_list|,
name|secret_len
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_bin2bn (secret)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JPAKE_DEBUG
name|debug3
argument_list|(
literal|"%s: salt = %s (len %u)"
argument_list|,
name|__func__
argument_list|,
operator|*
name|salt
argument_list|,
operator|(
name|u_int
operator|)
name|strlen
argument_list|(
operator|*
name|salt
argument_list|)
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: scheme = %s"
argument_list|,
name|__func__
argument_list|,
operator|*
name|hash_scheme
argument_list|)
expr_stmt|;
name|JPAKE_DEBUG_BN
argument_list|(
operator|(
operator|*
name|s
operator|,
literal|"%s: s = "
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|secret
argument_list|,
name|secret_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|secret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Begin authentication attempt.  * Note, sets authctxt->postponed while in subprotocol  */
end_comment

begin_function
specifier|static
name|int
name|auth2_jpake_start
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|)
block|{
name|struct
name|jpake_ctx
modifier|*
name|pctx
init|=
name|authctxt
operator|->
name|jpake_ctx
decl_stmt|;
name|u_char
modifier|*
name|x3_proof
decl_stmt|,
modifier|*
name|x4_proof
decl_stmt|;
name|u_int
name|x3_proof_len
decl_stmt|,
name|x4_proof_len
decl_stmt|;
name|char
modifier|*
name|salt
decl_stmt|,
modifier|*
name|hash_scheme
decl_stmt|;
name|debug
argument_list|(
literal|"%s: start"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|PRIVSEP
argument_list|(
name|jpake_step1
argument_list|(
name|pctx
operator|->
name|grp
argument_list|,
operator|&
name|pctx
operator|->
name|server_id
argument_list|,
operator|&
name|pctx
operator|->
name|server_id_len
argument_list|,
operator|&
name|pctx
operator|->
name|x3
argument_list|,
operator|&
name|pctx
operator|->
name|x4
argument_list|,
operator|&
name|pctx
operator|->
name|g_x3
argument_list|,
operator|&
name|pctx
operator|->
name|g_x4
argument_list|,
operator|&
name|x3_proof
argument_list|,
operator|&
name|x3_proof_len
argument_list|,
operator|&
name|x4_proof
argument_list|,
operator|&
name|x4_proof_len
argument_list|)
argument_list|)
expr_stmt|;
name|PRIVSEP
argument_list|(
name|auth2_jpake_get_pwdata
argument_list|(
name|authctxt
argument_list|,
operator|&
name|pctx
operator|->
name|s
argument_list|,
operator|&
name|hash_scheme
argument_list|,
operator|&
name|salt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_privsep
condition|)
name|JPAKE_DEBUG_CTX
argument_list|(
operator|(
name|pctx
operator|,
literal|"step 1 sending in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP1
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|hash_scheme
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
name|salt
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|pctx
operator|->
name|server_id
argument_list|,
name|pctx
operator|->
name|server_id_len
argument_list|)
expr_stmt|;
name|packet_put_bignum2
argument_list|(
name|pctx
operator|->
name|g_x3
argument_list|)
expr_stmt|;
name|packet_put_bignum2
argument_list|(
name|pctx
operator|->
name|g_x4
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|x3_proof
argument_list|,
name|x3_proof_len
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|x4_proof
argument_list|,
name|x4_proof_len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|hash_scheme
argument_list|,
name|strlen
argument_list|(
name|hash_scheme
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|salt
argument_list|,
name|strlen
argument_list|(
name|salt
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|hash_scheme
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|salt
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|x3_proof
argument_list|,
name|x3_proof_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|x4_proof
argument_list|,
name|x4_proof_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|x3_proof
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|x4_proof
argument_list|)
expr_stmt|;
comment|/* Expect step 1 packet from peer */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP1
argument_list|,
name|input_userauth_jpake_client_step1
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|postponed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|input_userauth_jpake_client_step1
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Authctxt
modifier|*
name|authctxt
init|=
name|ctxt
decl_stmt|;
name|struct
name|jpake_ctx
modifier|*
name|pctx
init|=
name|authctxt
operator|->
name|jpake_ctx
decl_stmt|;
name|u_char
modifier|*
name|x1_proof
decl_stmt|,
modifier|*
name|x2_proof
decl_stmt|,
modifier|*
name|x4_s_proof
decl_stmt|;
name|u_int
name|x1_proof_len
decl_stmt|,
name|x2_proof_len
decl_stmt|,
name|x4_s_proof_len
decl_stmt|;
comment|/* Disable this message */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fetch step 1 values */
if|if
condition|(
operator|(
name|pctx
operator|->
name|g_x1
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pctx
operator|->
name|g_x2
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|pctx
operator|->
name|client_id
operator|=
name|packet_get_string
argument_list|(
operator|&
name|pctx
operator|->
name|client_id_len
argument_list|)
expr_stmt|;
name|packet_get_bignum2
argument_list|(
name|pctx
operator|->
name|g_x1
argument_list|)
expr_stmt|;
name|packet_get_bignum2
argument_list|(
name|pctx
operator|->
name|g_x2
argument_list|)
expr_stmt|;
name|x1_proof
operator|=
name|packet_get_string
argument_list|(
operator|&
name|x1_proof_len
argument_list|)
expr_stmt|;
name|x2_proof
operator|=
name|packet_get_string
argument_list|(
operator|&
name|x2_proof_len
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|use_privsep
condition|)
name|JPAKE_DEBUG_CTX
argument_list|(
operator|(
name|pctx
operator|,
literal|"step 1 received in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PRIVSEP
argument_list|(
name|jpake_step2
argument_list|(
name|pctx
operator|->
name|grp
argument_list|,
name|pctx
operator|->
name|s
argument_list|,
name|pctx
operator|->
name|g_x3
argument_list|,
name|pctx
operator|->
name|g_x1
argument_list|,
name|pctx
operator|->
name|g_x2
argument_list|,
name|pctx
operator|->
name|x4
argument_list|,
name|pctx
operator|->
name|client_id
argument_list|,
name|pctx
operator|->
name|client_id_len
argument_list|,
name|pctx
operator|->
name|server_id
argument_list|,
name|pctx
operator|->
name|server_id_len
argument_list|,
name|x1_proof
argument_list|,
name|x1_proof_len
argument_list|,
name|x2_proof
argument_list|,
name|x2_proof_len
argument_list|,
operator|&
name|pctx
operator|->
name|b
argument_list|,
operator|&
name|x4_s_proof
argument_list|,
operator|&
name|x4_s_proof_len
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|x1_proof
argument_list|,
name|x1_proof_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|x2_proof
argument_list|,
name|x2_proof_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|x1_proof
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|x2_proof
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_privsep
condition|)
name|JPAKE_DEBUG_CTX
argument_list|(
operator|(
name|pctx
operator|,
literal|"step 2 sending in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Send values for step 2 */
name|packet_start
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_SERVER_STEP2
argument_list|)
expr_stmt|;
name|packet_put_bignum2
argument_list|(
name|pctx
operator|->
name|b
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|x4_s_proof
argument_list|,
name|x4_s_proof_len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|x4_s_proof
argument_list|,
name|x4_s_proof_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|x4_s_proof
argument_list|)
expr_stmt|;
comment|/* Expect step 2 packet from peer */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP2
argument_list|,
name|input_userauth_jpake_client_step2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|input_userauth_jpake_client_step2
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Authctxt
modifier|*
name|authctxt
init|=
name|ctxt
decl_stmt|;
name|struct
name|jpake_ctx
modifier|*
name|pctx
init|=
name|authctxt
operator|->
name|jpake_ctx
decl_stmt|;
name|u_char
modifier|*
name|x2_s_proof
decl_stmt|;
name|u_int
name|x2_s_proof_len
decl_stmt|;
comment|/* Disable this message */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_CLIENT_STEP2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pctx
operator|->
name|a
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: BN_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Fetch step 2 values */
name|packet_get_bignum2
argument_list|(
name|pctx
operator|->
name|a
argument_list|)
expr_stmt|;
name|x2_s_proof
operator|=
name|packet_get_string
argument_list|(
operator|&
name|x2_s_proof_len
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|use_privsep
condition|)
name|JPAKE_DEBUG_CTX
argument_list|(
operator|(
name|pctx
operator|,
literal|"step 2 received in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Derive shared key and calculate confirmation hash */
name|PRIVSEP
argument_list|(
name|jpake_key_confirm
argument_list|(
name|pctx
operator|->
name|grp
argument_list|,
name|pctx
operator|->
name|s
argument_list|,
name|pctx
operator|->
name|a
argument_list|,
name|pctx
operator|->
name|x4
argument_list|,
name|pctx
operator|->
name|g_x3
argument_list|,
name|pctx
operator|->
name|g_x4
argument_list|,
name|pctx
operator|->
name|g_x1
argument_list|,
name|pctx
operator|->
name|g_x2
argument_list|,
name|pctx
operator|->
name|server_id
argument_list|,
name|pctx
operator|->
name|server_id_len
argument_list|,
name|pctx
operator|->
name|client_id
argument_list|,
name|pctx
operator|->
name|client_id_len
argument_list|,
name|session_id2
argument_list|,
name|session_id2_len
argument_list|,
name|x2_s_proof
argument_list|,
name|x2_s_proof_len
argument_list|,
operator|&
name|pctx
operator|->
name|k
argument_list|,
operator|&
name|pctx
operator|->
name|h_k_sid_sessid
argument_list|,
operator|&
name|pctx
operator|->
name|h_k_sid_sessid_len
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|x2_s_proof
argument_list|,
name|x2_s_proof_len
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|x2_s_proof
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_privsep
condition|)
name|JPAKE_DEBUG_CTX
argument_list|(
operator|(
name|pctx
operator|,
literal|"confirm sending in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Send key confirmation proof */
name|packet_start
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_SERVER_CONFIRM
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|pctx
operator|->
name|h_k_sid_sessid
argument_list|,
name|pctx
operator|->
name|h_k_sid_sessid_len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* Expect confirmation from peer */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_CLIENT_CONFIRM
argument_list|,
name|input_userauth_jpake_client_confirm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|input_userauth_jpake_client_confirm
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Authctxt
modifier|*
name|authctxt
init|=
name|ctxt
decl_stmt|;
name|struct
name|jpake_ctx
modifier|*
name|pctx
init|=
name|authctxt
operator|->
name|jpake_ctx
decl_stmt|;
name|int
name|authenticated
init|=
literal|0
decl_stmt|;
comment|/* Disable this message */
name|dispatch_set
argument_list|(
name|SSH2_MSG_USERAUTH_JPAKE_CLIENT_CONFIRM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pctx
operator|->
name|h_k_cid_sessid
operator|=
name|packet_get_string
argument_list|(
operator|&
name|pctx
operator|->
name|h_k_cid_sessid_len
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|use_privsep
condition|)
name|JPAKE_DEBUG_CTX
argument_list|(
operator|(
name|pctx
operator|,
literal|"confirm received in %s"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Verify expected confirmation hash */
if|if
condition|(
name|PRIVSEP
argument_list|(
name|jpake_check_confirm
argument_list|(
name|pctx
operator|->
name|k
argument_list|,
name|pctx
operator|->
name|client_id
argument_list|,
name|pctx
operator|->
name|client_id_len
argument_list|,
name|session_id2
argument_list|,
name|session_id2_len
argument_list|,
name|pctx
operator|->
name|h_k_cid_sessid
argument_list|,
name|pctx
operator|->
name|h_k_cid_sessid_len
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|authenticated
operator|=
name|authctxt
operator|->
name|valid
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|debug
argument_list|(
literal|"%s: confirmation mismatch"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* done */
name|authctxt
operator|->
name|postponed
operator|=
literal|0
expr_stmt|;
name|jpake_free
argument_list|(
name|authctxt
operator|->
name|jpake_ctx
argument_list|)
expr_stmt|;
name|authctxt
operator|->
name|jpake_ctx
operator|=
name|NULL
expr_stmt|;
name|userauth_finish
argument_list|(
name|authctxt
argument_list|,
name|authenticated
argument_list|,
name|method_jpake
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JPAKE */
end_comment

end_unit

