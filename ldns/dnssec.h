begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * dnssec.h -- defines for the Domain Name System (SEC) (DNSSEC)  *  * Copyright (c) 2005-2008, NLnet Labs. All rights reserved.  *  * See LICENSE for the license.  *  * A bunch of defines that are used in the DNS  */
end_comment

begin_comment
comment|/**  * \file dnssec.h  *  * This module contains base functions for DNSSEC operations  * (RFC4033 t/m RFC4035).  *   * Since those functions heavily rely op cryptographic operations,  * this module is dependent on openssl.  *   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LDNS_DNSSEC_H
end_ifndef

begin_define
define|#
directive|define
name|LDNS_DNSSEC_H
end_define

begin_include
include|#
directive|include
file|<ldns/common.h>
end_include

begin_if
if|#
directive|if
name|LDNS_BUILD_CONFIG_HAVE_SSL
end_if

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDNS_BUILD_CONFIG_HAVE_SSL */
end_comment

begin_include
include|#
directive|include
file|<ldns/packet.h>
end_include

begin_include
include|#
directive|include
file|<ldns/keys.h>
end_include

begin_include
include|#
directive|include
file|<ldns/zone.h>
end_include

begin_include
include|#
directive|include
file|<ldns/resolver.h>
end_include

begin_include
include|#
directive|include
file|<ldns/dnssec_zone.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|LDNS_MAX_KEYLEN
value|2048
define|#
directive|define
name|LDNS_DNSSEC_KEYPROTO
value|3
comment|/* default time before sigs expire */
define|#
directive|define
name|LDNS_DEFAULT_EXP_TIME
value|2419200
comment|/* 4 weeks */
comment|/** return values for the old-signature callback */
define|#
directive|define
name|LDNS_SIGNATURE_LEAVE_ADD_NEW
value|0
define|#
directive|define
name|LDNS_SIGNATURE_LEAVE_NO_ADD
value|1
define|#
directive|define
name|LDNS_SIGNATURE_REMOVE_ADD_NEW
value|2
define|#
directive|define
name|LDNS_SIGNATURE_REMOVE_NO_ADD
value|3
comment|/**  * Returns the first RRSIG rr that corresponds to the rrset   * with the given name and type  *   * \param[in] name The dname of the RRset covered by the RRSIG to find  * \param[in] type The type of the RRset covered by the RRSIG to find  * \param[in] rrs List of rrs to search in  * \returns Pointer to the first RRsig ldns_rr found, or NULL if it is  * not present  */
name|ldns_rr
modifier|*
name|ldns_dnssec_get_rrsig_for_name_and_type
parameter_list|(
specifier|const
name|ldns_rdf
modifier|*
name|name
parameter_list|,
specifier|const
name|ldns_rr_type
name|type
parameter_list|,
specifier|const
name|ldns_rr_list
modifier|*
name|rrs
parameter_list|)
function_decl|;
comment|/**  * Returns the DNSKEY that corresponds to the given RRSIG rr from the list, if  * any  *  * \param[in] rrsig The rrsig to find the DNSKEY for  * \param[in] rrs The rr list to find the key in  * \return The DNSKEY that corresponds to the given RRSIG, or NULL if it was  *         not found.  */
name|ldns_rr
modifier|*
name|ldns_dnssec_get_dnskey_for_rrsig
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|rrsig
parameter_list|,
specifier|const
name|ldns_rr_list
modifier|*
name|rrs
parameter_list|)
function_decl|;
comment|/**  * Returns the rdata field that contains the bitmap of the covered types of  * the given NSEC record  *  * \param[in] nsec The nsec to get the covered type bitmap of  * \return An ldns_rdf containing the bitmap, or NULL on error  */
name|ldns_rdf
modifier|*
name|ldns_nsec_get_bitmap
parameter_list|(
name|ldns_rr
modifier|*
name|nsec
parameter_list|)
function_decl|;
define|#
directive|define
name|LDNS_NSEC3_MAX_ITERATIONS
value|65535
comment|/**  * Returns the dname of the closest (provable) encloser  */
name|ldns_rdf
modifier|*
name|ldns_dnssec_nsec3_closest_encloser
parameter_list|(
name|ldns_rdf
modifier|*
name|qname
parameter_list|,
name|ldns_rr_type
name|qtype
parameter_list|,
name|ldns_rr_list
modifier|*
name|nsec3s
parameter_list|)
function_decl|;
comment|/**  * Checks whether the packet contains rrsigs  */
name|bool
name|ldns_dnssec_pkt_has_rrsigs
parameter_list|(
specifier|const
name|ldns_pkt
modifier|*
name|pkt
parameter_list|)
function_decl|;
comment|/**  * Returns a ldns_rr_list containing the signatures covering the given name  * and type  */
name|ldns_rr_list
modifier|*
name|ldns_dnssec_pkt_get_rrsigs_for_name_and_type
parameter_list|(
specifier|const
name|ldns_pkt
modifier|*
name|pkt
parameter_list|,
name|ldns_rdf
modifier|*
name|name
parameter_list|,
name|ldns_rr_type
name|type
parameter_list|)
function_decl|;
comment|/**  * Returns a ldns_rr_list containing the signatures covering the given type  */
name|ldns_rr_list
modifier|*
name|ldns_dnssec_pkt_get_rrsigs_for_type
parameter_list|(
specifier|const
name|ldns_pkt
modifier|*
name|pkt
parameter_list|,
name|ldns_rr_type
name|type
parameter_list|)
function_decl|;
comment|/**   * calculates a keytag of a key for use in DNSSEC.  *  * \param[in] key the key as an RR to use for the calc.  * \return the keytag  */
name|uint16_t
name|ldns_calc_keytag
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|key
parameter_list|)
function_decl|;
comment|/**  * Calculates keytag of DNSSEC key, operates on wireformat rdata.  * \param[in] key the key as uncompressed wireformat rdata.  * \param[in] keysize length of key data.  * \return the keytag  */
name|uint16_t
name|ldns_calc_keytag_raw
parameter_list|(
name|uint8_t
modifier|*
name|key
parameter_list|,
name|size_t
name|keysize
parameter_list|)
function_decl|;
if|#
directive|if
name|LDNS_BUILD_CONFIG_HAVE_SSL
comment|/**  * converts a buffer holding key material to a DSA key in openssl.  *  * \param[in] key the key to convert  * \return a DSA * structure with the key material  */
name|DSA
modifier|*
name|ldns_key_buf2dsa
parameter_list|(
name|ldns_buffer
modifier|*
name|key
parameter_list|)
function_decl|;
comment|/**  * Like ldns_key_buf2dsa, but uses raw buffer.  * \param[in] key the uncompressed wireformat of the key.  * \param[in] len length of key data  * \return a DSA * structure with the key material  */
name|DSA
modifier|*
name|ldns_key_buf2dsa_raw
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
comment|/**  * Utility function to calculate hash using generic EVP_MD pointer.  * \param[in] data the data to hash.  * \param[in] len  length of data.  * \param[out] dest the destination of the hash, must be large enough.  * \param[in] md the message digest to use.  * \return true if worked, false on failure.  */
name|int
name|ldns_digest_evp
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|md
parameter_list|)
function_decl|;
comment|/**  * Converts a holding buffer with key material to EVP PKEY in openssl.  * Only available if ldns was compiled with GOST.  * \param[in] key data to convert  * \param[in] keylen length of the key data  * \return the key or NULL on error.  */
name|EVP_PKEY
modifier|*
name|ldns_gost2pkey_raw
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|keylen
parameter_list|)
function_decl|;
comment|/**  * Converts a holding buffer with key material to EVP PKEY in openssl.  * Only available if ldns was compiled with ECDSA.  * \param[in] key data to convert  * \param[in] keylen length of the key data  * \param[in] algo precise algorithm to initialize ECC group values.  * \return the key or NULL on error.  */
name|EVP_PKEY
modifier|*
name|ldns_ecdsa2pkey_raw
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|keylen
parameter_list|,
name|uint8_t
name|algo
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* LDNS_BUILD_CONFIG_HAVE_SSL */
if|#
directive|if
name|LDNS_BUILD_CONFIG_HAVE_SSL
comment|/**  * converts a buffer holding key material to a RSA key in openssl.  *  * \param[in] key the key to convert  * \return a RSA * structure with the key material  */
name|RSA
modifier|*
name|ldns_key_buf2rsa
parameter_list|(
name|ldns_buffer
modifier|*
name|key
parameter_list|)
function_decl|;
comment|/**  * Like ldns_key_buf2rsa, but uses raw buffer.  * \param[in] key the uncompressed wireformat of the key.  * \param[in] len length of key data  * \return a RSA * structure with the key material  */
name|RSA
modifier|*
name|ldns_key_buf2rsa_raw
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* LDNS_BUILD_CONFIG_HAVE_SSL */
comment|/**   * returns a new DS rr that represents the given key rr.  *  * \param[in] *key the key to convert  * \param[in] h the hash to use LDNS_SHA1/LDNS_SHA256  *  * \return ldns_rr* a new rr pointer to a DS  */
name|ldns_rr
modifier|*
name|ldns_key_rr2ds
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|key
parameter_list|,
name|ldns_hash
name|h
parameter_list|)
function_decl|;
comment|/**  * Create the type bitmap for an NSEC(3) record  */
name|ldns_rdf
modifier|*
name|ldns_dnssec_create_nsec_bitmap
parameter_list|(
name|ldns_rr_type
name|rr_type_list
index|[]
parameter_list|,
name|size_t
name|size
parameter_list|,
name|ldns_rr_type
name|nsec_type
parameter_list|)
function_decl|;
comment|/**  * returns whether a rrset of the given type is found in the rrsets.  *  * \param[in] rrsets the rrsets to be tested  * \param[in] type the type to test for  * \return int 1 if the type was found, 0 otherwise.  */
name|int
name|ldns_dnssec_rrsets_contains_type
parameter_list|(
name|ldns_dnssec_rrsets
modifier|*
name|rrsets
parameter_list|,
name|ldns_rr_type
name|type
parameter_list|)
function_decl|;
comment|/**  * Creates NSEC  */
name|ldns_rr
modifier|*
name|ldns_dnssec_create_nsec
parameter_list|(
name|ldns_dnssec_name
modifier|*
name|from
parameter_list|,
name|ldns_dnssec_name
modifier|*
name|to
parameter_list|,
name|ldns_rr_type
name|nsec_type
parameter_list|)
function_decl|;
comment|/**  * Creates NSEC3  */
name|ldns_rr
modifier|*
name|ldns_dnssec_create_nsec3
parameter_list|(
name|ldns_dnssec_name
modifier|*
name|from
parameter_list|,
name|ldns_dnssec_name
modifier|*
name|to
parameter_list|,
name|ldns_rdf
modifier|*
name|zone_name
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|)
function_decl|;
comment|/**  * Create a NSEC record  * \param[in] cur_owner the current owner which should be taken as the starting point  * \param[in] next_owner the rrlist which the nsec rr should point to   * \param[in] rrs all rrs from the zone, to find all RR types of cur_owner in  * \return a ldns_rr with the nsec record in it  */
name|ldns_rr
modifier|*
name|ldns_create_nsec
parameter_list|(
name|ldns_rdf
modifier|*
name|cur_owner
parameter_list|,
name|ldns_rdf
modifier|*
name|next_owner
parameter_list|,
name|ldns_rr_list
modifier|*
name|rrs
parameter_list|)
function_decl|;
comment|/**  * Calculates the hashed name using the given parameters  * \param[in] *name The owner name to calculate the hash for   * \param[in] algorithm The hash algorithm to use  * \param[in] iterations The number of hash iterations to use  * \param[in] salt_length The length of the salt in bytes  * \param[in] salt The salt to use  * \return The hashed owner name rdf, without the domain name  */
name|ldns_rdf
modifier|*
name|ldns_nsec3_hash_name
parameter_list|(
name|ldns_rdf
modifier|*
name|name
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|)
function_decl|;
comment|/**  * Sets all the NSEC3 options. The rr to set them in must be initialized with _new() and  * type LDNS_RR_TYPE_NSEC3  * \param[in] *rr The RR to set the values in  * \param[in] algorithm The NSEC3 hash algorithm   * \param[in] flags The flags field   * \param[in] iterations The number of hash iterations  * \param[in] salt_length The length of the salt in bytes   * \param[in] salt The salt bytes  */
name|void
name|ldns_nsec3_add_param_rdfs
parameter_list|(
name|ldns_rr
modifier|*
name|rr
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|)
function_decl|;
comment|/* this will NOT return the NSEC3  completed, you will have to run the    finalize function on the rrlist later! */
name|ldns_rr
modifier|*
name|ldns_create_nsec3
parameter_list|(
name|ldns_rdf
modifier|*
name|cur_owner
parameter_list|,
name|ldns_rdf
modifier|*
name|cur_zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|rrs
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|,
name|bool
name|emptynonterminal
parameter_list|)
function_decl|;
comment|/**  * Returns the hash algorithm used in the given NSEC3 RR  * \param[in] *nsec3_rr The RR to read from  * \return The algorithm identifier, or 0 on error  */
name|uint8_t
name|ldns_nsec3_algorithm
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec3_rr
parameter_list|)
function_decl|;
comment|/**  * Returns flags field  */
name|uint8_t
name|ldns_nsec3_flags
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec3_rr
parameter_list|)
function_decl|;
comment|/**  * Returns true if the opt-out flag has been set in the given NSEC3 RR  * \param[in] *nsec3_rr The RR to read from  * \return true if the RR has type NSEC3 and the opt-out bit has been set, false otherwise  */
name|bool
name|ldns_nsec3_optout
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec3_rr
parameter_list|)
function_decl|;
comment|/**  * Returns the number of hash iterations used in the given NSEC3 RR  * \param[in] *nsec3_rr The RR to read from  * \return The number of iterations  */
name|uint16_t
name|ldns_nsec3_iterations
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec3_rr
parameter_list|)
function_decl|;
comment|/**  * Returns the salt used in the given NSEC3 RR  * \param[in] *nsec3_rr The RR to read from  * \return The salt rdf, or NULL on error  */
name|ldns_rdf
modifier|*
name|ldns_nsec3_salt
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec3_rr
parameter_list|)
function_decl|;
comment|/**  * Returns the length of the salt used in the given NSEC3 RR  * \param[in] *nsec3_rr The RR to read from  * \return The length of the salt in bytes  */
name|uint8_t
name|ldns_nsec3_salt_length
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec3_rr
parameter_list|)
function_decl|;
comment|/**  * Returns the salt bytes used in the given NSEC3 RR  * \param[in] *nsec3_rr The RR to read from  * \return The salt in bytes, this is alloced, so you need to free it  */
name|uint8_t
modifier|*
name|ldns_nsec3_salt_data
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec3_rr
parameter_list|)
function_decl|;
comment|/**  * Returns the first label of the next ownername in the NSEC3 chain (ie. without the domain)  * \param[in] nsec3_rr The RR to read from  * \return The first label of the next owner name in the NSEC3 chain, or NULL on error   */
name|ldns_rdf
modifier|*
name|ldns_nsec3_next_owner
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec3_rr
parameter_list|)
function_decl|;
comment|/**  * Returns the bitmap specifying the covered types of the given NSEC3 RR  * \param[in] *nsec3_rr The RR to read from  * \return The covered type bitmap rdf  */
name|ldns_rdf
modifier|*
name|ldns_nsec3_bitmap
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec3_rr
parameter_list|)
function_decl|;
comment|/**  * Calculates the hashed name using the parameters of the given NSEC3 RR  * \param[in] *nsec The RR to use the parameters from  * \param[in] *name The owner name to calculate the hash for   * \return The hashed owner name rdf, without the domain name  */
name|ldns_rdf
modifier|*
name|ldns_nsec3_hash_name_frm_nsec3
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec
parameter_list|,
name|ldns_rdf
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/**  * Check if RR type t is enumerated and set in the RR type bitmap rdf.  * \param[in] bitmap the RR type bitmap rdf to look in  * \param[in] type the type to check for  * \return true when t is found and set, otherwise return false  */
name|bool
name|ldns_nsec_bitmap_covers_type
parameter_list|(
specifier|const
name|ldns_rdf
modifier|*
name|bitmap
parameter_list|,
name|ldns_rr_type
name|type
parameter_list|)
function_decl|;
comment|/**  * Checks if RR type t is enumerated in the type bitmap rdf and sets the bit.  * \param[in] bitmap the RR type bitmap rdf to look in  * \param[in] type the type to for which the bit to set  * \return LDNS_STATUS_OK on success. LDNS_STATUS_TYPE_NOT_IN_BITMAP is   *         returned when the bitmap does not contain the bit to set.  */
name|ldns_status
name|ldns_nsec_bitmap_set_type
parameter_list|(
name|ldns_rdf
modifier|*
name|bitmap
parameter_list|,
name|ldns_rr_type
name|type
parameter_list|)
function_decl|;
comment|/**  * Checks if RR type t is enumerated in the type bitmap rdf and clears the bit.  * \param[in] bitmap the RR type bitmap rdf to look in  * \param[in] type the type to for which the bit to clear  * \return LDNS_STATUS_OK on success. LDNS_STATUS_TYPE_NOT_IN_BITMAP is   *         returned when the bitmap does not contain the bit to clear.  */
name|ldns_status
name|ldns_nsec_bitmap_clear_type
parameter_list|(
name|ldns_rdf
modifier|*
name|bitmap
parameter_list|,
name|ldns_rr_type
name|type
parameter_list|)
function_decl|;
comment|/**  * Checks coverage of NSEC(3) RR name span  * Remember that nsec and name must both be in canonical form (ie use  * \ref ldns_rr2canonical and \ref ldns_dname2canonical prior to calling this  * function)  *  * \param[in] nsec The NSEC RR to check  * \param[in] name The owner dname to check, if the nsec record is a NSEC3 record, this should be the hashed name  * \return true if the NSEC RR covers the owner name  */
name|bool
name|ldns_nsec_covers_name
parameter_list|(
specifier|const
name|ldns_rr
modifier|*
name|nsec
parameter_list|,
specifier|const
name|ldns_rdf
modifier|*
name|name
parameter_list|)
function_decl|;
if|#
directive|if
name|LDNS_BUILD_CONFIG_HAVE_SSL
comment|/**  * verify a packet   * \param[in] p the packet  * \param[in] t the rr set type to check  * \param[in] o the rr set name to check  * \param[in] k list of keys  * \param[in] s list of sigs (may be null)  * \param[out] good_keys keys which validated the packet  * \return status   *   */
name|ldns_status
name|ldns_pkt_verify
parameter_list|(
name|ldns_pkt
modifier|*
name|p
parameter_list|,
name|ldns_rr_type
name|t
parameter_list|,
name|ldns_rdf
modifier|*
name|o
parameter_list|,
name|ldns_rr_list
modifier|*
name|k
parameter_list|,
name|ldns_rr_list
modifier|*
name|s
parameter_list|,
name|ldns_rr_list
modifier|*
name|good_keys
parameter_list|)
function_decl|;
comment|/**  * verify a packet   * \param[in] p the packet  * \param[in] t the rr set type to check  * \param[in] o the rr set name to check  * \param[in] k list of keys  * \param[in] s list of sigs (may be null)  * \param[in] check_time the time for which the validation is performed  * \param[out] good_keys keys which validated the packet  * \return status   *   */
name|ldns_status
name|ldns_pkt_verify_time
parameter_list|(
name|ldns_pkt
modifier|*
name|p
parameter_list|,
name|ldns_rr_type
name|t
parameter_list|,
name|ldns_rdf
modifier|*
name|o
parameter_list|,
name|ldns_rr_list
modifier|*
name|k
parameter_list|,
name|ldns_rr_list
modifier|*
name|s
parameter_list|,
name|time_t
name|check_time
parameter_list|,
name|ldns_rr_list
modifier|*
name|good_keys
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/**  * chains nsec3 list  */
name|ldns_status
name|ldns_dnssec_chain_nsec3_list
parameter_list|(
name|ldns_rr_list
modifier|*
name|nsec3_rrs
parameter_list|)
function_decl|;
comment|/**  * compare for nsec3 sort  */
name|int
name|qsort_rr_compare_nsec3
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/**  * sort nsec3 list  */
name|void
name|ldns_rr_list_sort_nsec3
parameter_list|(
name|ldns_rr_list
modifier|*
name|unsorted
parameter_list|)
function_decl|;
comment|/**   * Default callback function to always leave present signatures, and  * add new ones  * \param[in] sig The signature to check for removal (unused)  * \param[in] n Optional argument (unused)  * \return LDNS_SIGNATURE_LEAVE_ADD_NEW  */
name|int
name|ldns_dnssec_default_add_to_signatures
parameter_list|(
name|ldns_rr
modifier|*
name|sig
parameter_list|,
name|void
modifier|*
name|n
parameter_list|)
function_decl|;
comment|/**   * Default callback function to always leave present signatures, and  * add no new ones for the keys of these signatures  * \param[in] sig The signature to check for removal (unused)  * \param[in] n Optional argument (unused)  * \return LDNS_SIGNATURE_LEAVE_NO_ADD  */
name|int
name|ldns_dnssec_default_leave_signatures
parameter_list|(
name|ldns_rr
modifier|*
name|sig
parameter_list|,
name|void
modifier|*
name|n
parameter_list|)
function_decl|;
comment|/**   * Default callback function to always remove present signatures, but  * add no new ones  * \param[in] sig The signature to check for removal (unused)  * \param[in] n Optional argument (unused)  * \return LDNS_SIGNATURE_REMOVE_NO_ADD  */
name|int
name|ldns_dnssec_default_delete_signatures
parameter_list|(
name|ldns_rr
modifier|*
name|sig
parameter_list|,
name|void
modifier|*
name|n
parameter_list|)
function_decl|;
comment|/**   * Default callback function to always leave present signatures, and  * add new ones  * \param[in] sig The signature to check for removal (unused)  * \param[in] n Optional argument (unused)  * \return LDNS_SIGNATURE_REMOVE_ADD_NEW  */
name|int
name|ldns_dnssec_default_replace_signatures
parameter_list|(
name|ldns_rr
modifier|*
name|sig
parameter_list|,
name|void
modifier|*
name|n
parameter_list|)
function_decl|;
if|#
directive|if
name|LDNS_BUILD_CONFIG_HAVE_SSL
comment|/**  * Converts the DSA signature from ASN1 representation (RFC2459, as   * used by OpenSSL) to raw signature data as used in DNS (rfc2536)  *  * \param[in] sig The signature in RFC2459 format  * \param[in] sig_len The length of the signature  * \return a new rdf with the signature  */
name|ldns_rdf
modifier|*
name|ldns_convert_dsa_rrsig_asn12rdf
parameter_list|(
specifier|const
name|ldns_buffer
modifier|*
name|sig
parameter_list|,
specifier|const
name|long
name|sig_len
parameter_list|)
function_decl|;
comment|/**  * Converts the RRSIG signature RDF (in rfc2536 format) to a buffer  * with the signature in rfc2459 format  *  * \param[out] target_buffer buffer to place the signature data  * \param[in] sig_rdf The signature rdf to convert  * \return LDNS_STATUS_OK on success, error code otherwise  */
name|ldns_status
name|ldns_convert_dsa_rrsig_rdf2asn1
parameter_list|(
name|ldns_buffer
modifier|*
name|target_buffer
parameter_list|,
specifier|const
name|ldns_rdf
modifier|*
name|sig_rdf
parameter_list|)
function_decl|;
comment|/**  * Converts the ECDSA signature from ASN1 representation (as   * used by OpenSSL) to raw signature data as used in DNS  * This routine is only present if ldns is compiled with ecdsa support.  *  * \param[in] sig The signature in ASN1 format  * \param[in] sig_len The length of the signature  * \return a new rdf with the signature  */
name|ldns_rdf
modifier|*
name|ldns_convert_ecdsa_rrsig_asn12rdf
parameter_list|(
specifier|const
name|ldns_buffer
modifier|*
name|sig
parameter_list|,
specifier|const
name|long
name|sig_len
parameter_list|)
function_decl|;
comment|/**  * Converts the RRSIG signature RDF (from DNS) to a buffer with the   * signature in ASN1 format as openssl uses it.  * This routine is only present if ldns is compiled with ecdsa support.  *  * \param[out] target_buffer buffer to place the signature data in ASN1.  * \param[in] sig_rdf The signature rdf to convert  * \return LDNS_STATUS_OK on success, error code otherwise  */
name|ldns_status
name|ldns_convert_ecdsa_rrsig_rdf2asn1
parameter_list|(
name|ldns_buffer
modifier|*
name|target_buffer
parameter_list|,
specifier|const
name|ldns_rdf
modifier|*
name|sig_rdf
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* LDNS_BUILD_CONFIG_HAVE_SSL */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDNS_DNSSEC_H */
end_comment

end_unit

