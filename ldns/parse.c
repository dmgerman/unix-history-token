begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * a generic (simple) parser. Use to parse rr's, private key  * information and /etc/resolv.conf files  *  * a Net::DNS like library for C  * LibDNS Team @ NLnet Labs  * (c) NLnet Labs, 2005-2006  * See the file LICENSE for the license  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ldns/parse.h"
end_include

begin_include
include|#
directive|include
file|"ldns/parseutil.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_decl_stmt
name|sldns_lookup_table
name|sldns_directive_types
index|[]
init|=
block|{
block|{
name|LDNS_DIR_TTL
block|,
literal|"$TTL"
block|}
block|,
block|{
name|LDNS_DIR_ORIGIN
block|,
literal|"$ORIGIN"
block|}
block|,
block|{
name|LDNS_DIR_INCLUDE
block|,
literal|"$INCLUDE"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add max_limit here? */
end_comment

begin_function
name|ssize_t
name|sldns_fget_token
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
return|return
name|sldns_fget_token_l
argument_list|(
name|f
argument_list|,
name|token
argument_list|,
name|delim
argument_list|,
name|limit
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|sldns_fget_token_l
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
name|limit
parameter_list|,
name|int
modifier|*
name|line_nr
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|prev_c
decl_stmt|;
name|int
name|p
decl_stmt|;
comment|/* 0 -> no parenthese seen,>0 nr of ( seen */
name|int
name|com
decl_stmt|,
name|quoted
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|del
decl_stmt|;
comment|/* standard delimeters */
if|if
condition|(
operator|!
name|delim
condition|)
block|{
comment|/* from isspace(3) */
name|del
operator|=
name|LDNS_PARSE_NORMAL
expr_stmt|;
block|}
else|else
block|{
name|del
operator|=
name|delim
expr_stmt|;
block|}
name|p
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|com
operator|=
literal|0
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
name|prev_c
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|token
expr_stmt|;
if|if
condition|(
name|del
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
comment|/* carriage return */
name|c
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
operator|&&
name|prev_c
operator|!=
literal|'\\'
operator|&&
operator|!
name|quoted
condition|)
block|{
comment|/* this only counts for non-comments */
if|if
condition|(
name|com
operator|==
literal|0
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|prev_c
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|')'
operator|&&
name|prev_c
operator|!=
literal|'\\'
operator|&&
operator|!
name|quoted
condition|)
block|{
comment|/* this only counts for non-comments */
if|if
condition|(
name|com
operator|==
literal|0
condition|)
block|{
name|p
operator|--
expr_stmt|;
block|}
name|prev_c
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|<
literal|0
condition|)
block|{
comment|/* more ) then ( - close off the string */
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* do something with comments ; */
if|if
condition|(
name|c
operator|==
literal|';'
operator|&&
name|quoted
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev_c
operator|!=
literal|'\\'
condition|)
block|{
name|com
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|&&
name|com
operator|==
literal|0
operator|&&
name|prev_c
operator|!=
literal|'\\'
condition|)
block|{
name|quoted
operator|=
literal|1
operator|-
name|quoted
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|com
operator|!=
literal|0
condition|)
block|{
comment|/* comments */
name|com
operator|=
literal|0
expr_stmt|;
operator|*
name|t
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|line_nr
condition|)
block|{
operator|*
name|line_nr
operator|=
operator|*
name|line_nr
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
goto|goto
name|tokenread
goto|;
block|}
else|else
block|{
name|prev_c
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|com
operator|==
literal|1
condition|)
block|{
operator|*
name|t
operator|=
literal|' '
expr_stmt|;
name|prev_c
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|p
operator|!=
literal|0
operator|&&
name|t
operator|>
name|token
condition|)
block|{
comment|/* in parentheses */
if|if
condition|(
name|line_nr
condition|)
block|{
operator|*
name|line_nr
operator|=
operator|*
name|line_nr
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
name|prev_c
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
comment|/* check if we hit the delim */
for|for
control|(
name|d
operator|=
name|del
init|;
operator|*
name|d
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
name|d
operator|&&
name|i
operator|>
literal|0
operator|&&
name|prev_c
operator|!=
literal|'\\'
operator|&&
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|line_nr
condition|)
block|{
operator|*
name|line_nr
operator|=
operator|*
name|line_nr
operator|+
literal|1
expr_stmt|;
block|}
goto|goto
name|tokenread
goto|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|>
literal|0
operator|&&
operator|(
name|i
operator|>=
name|limit
operator|||
call|(
name|size_t
call|)
argument_list|(
name|t
operator|-
name|token
argument_list|)
operator|>=
name|limit
operator|)
condition|)
block|{
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|t
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|prev_c
operator|==
literal|'\\'
condition|)
name|prev_c
operator|=
literal|0
expr_stmt|;
else|else
name|prev_c
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
return|return
operator|(
name|ssize_t
operator|)
name|i
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* nothing read */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|ssize_t
operator|)
name|i
return|;
name|tokenread
label|:
if|if
condition|(
operator|*
name|del
operator|==
literal|'"'
condition|)
comment|/* do not skip over quotes after the string, they are part 		 * of the next string.  But skip over whitespace (if needed)*/
name|sldns_fskipcs_l
argument_list|(
name|f
argument_list|,
name|del
operator|+
literal|1
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
else|else
name|sldns_fskipcs_l
argument_list|(
name|f
argument_list|,
name|del
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|ssize_t
operator|)
name|i
return|;
block|}
end_function

begin_function
name|ssize_t
name|sldns_fget_keyword_data
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|k_del
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|d_del
parameter_list|,
name|size_t
name|data_limit
parameter_list|)
block|{
return|return
name|sldns_fget_keyword_data_l
argument_list|(
name|f
argument_list|,
name|keyword
argument_list|,
name|k_del
argument_list|,
name|data
argument_list|,
name|d_del
argument_list|,
name|data_limit
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|sldns_fget_keyword_data_l
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|k_del
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|d_del
parameter_list|,
name|size_t
name|data_limit
parameter_list|,
name|int
modifier|*
name|line_nr
parameter_list|)
block|{
comment|/* we assume: keyword|sep|data */
name|char
modifier|*
name|fkeyword
decl_stmt|;
name|ssize_t
name|i
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|keyword
argument_list|)
operator|>=
name|LDNS_MAX_KEYWORDLEN
condition|)
return|return
operator|-
literal|1
return|;
name|fkeyword
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|LDNS_MAX_KEYWORDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fkeyword
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
name|sldns_fget_token
argument_list|(
name|f
argument_list|,
name|fkeyword
argument_list|,
name|k_del
argument_list|,
name|LDNS_MAX_KEYWORDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|fkeyword
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* case??? i instead of strlen? */
if|if
condition|(
name|strncmp
argument_list|(
name|fkeyword
argument_list|,
name|keyword
argument_list|,
name|LDNS_MAX_KEYWORDLEN
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* whee! */
comment|/* printf("%s\n%s\n", "Matching keyword", fkeyword); */
name|i
operator|=
name|sldns_fget_token_l
argument_list|(
name|f
argument_list|,
name|data
argument_list|,
name|d_del
argument_list|,
name|data_limit
argument_list|,
name|line_nr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fkeyword
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
else|else
block|{
comment|/*printf("no match for %s (read: %s)\n", keyword, fkeyword);*/
name|free
argument_list|(
name|fkeyword
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|sldns_bgetc
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
condition|)
block|{
name|sldns_buffer_set_position
argument_list|(
name|buffer
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sldns_buffer_rewind(buffer);*/
return|return
name|EOF
return|;
block|}
return|return
operator|(
name|int
operator|)
name|sldns_buffer_read_u8
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|sldns_bget_token
parameter_list|(
name|sldns_buffer
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
return|return
name|sldns_bget_token_par
argument_list|(
name|b
argument_list|,
name|token
argument_list|,
name|delim
argument_list|,
name|limit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|sldns_bget_token_par
parameter_list|(
name|sldns_buffer
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
name|limit
parameter_list|,
name|int
modifier|*
name|par
parameter_list|,
specifier|const
name|char
modifier|*
name|skipw
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|lc
decl_stmt|;
name|int
name|p
decl_stmt|;
comment|/* 0 -> no parenthese seen,>0 nr of ( seen */
name|int
name|com
decl_stmt|,
name|quoted
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|del
decl_stmt|;
comment|/* standard delimiters */
if|if
condition|(
operator|!
name|delim
condition|)
block|{
comment|/* from isspace(3) */
name|del
operator|=
name|LDNS_PARSE_NORMAL
expr_stmt|;
block|}
else|else
block|{
name|del
operator|=
name|delim
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|par
condition|?
operator|*
name|par
else|:
literal|0
operator|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|com
operator|=
literal|0
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|token
expr_stmt|;
name|lc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|del
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|sldns_bgetc
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
comment|/* carriage return */
name|c
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
operator|&&
name|lc
operator|!=
literal|'\\'
operator|&&
operator|!
name|quoted
condition|)
block|{
comment|/* this only counts for non-comments */
if|if
condition|(
name|com
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|par
condition|)
operator|(
operator|*
name|par
operator|)
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|lc
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|')'
operator|&&
name|lc
operator|!=
literal|'\\'
operator|&&
operator|!
name|quoted
condition|)
block|{
comment|/* this only counts for non-comments */
if|if
condition|(
name|com
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|par
condition|)
operator|(
operator|*
name|par
operator|)
operator|--
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
name|lc
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|<
literal|0
condition|)
block|{
comment|/* more ) then ( */
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* do something with comments ; */
if|if
condition|(
name|c
operator|==
literal|';'
operator|&&
name|quoted
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lc
operator|!=
literal|'\\'
condition|)
block|{
name|com
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
operator|&&
name|com
operator|==
literal|0
operator|&&
name|lc
operator|!=
literal|'\\'
condition|)
block|{
name|quoted
operator|=
literal|1
operator|-
name|quoted
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|com
operator|!=
literal|0
condition|)
block|{
comment|/* comments */
name|com
operator|=
literal|0
expr_stmt|;
operator|*
name|t
operator|=
literal|' '
expr_stmt|;
name|lc
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|com
operator|==
literal|1
condition|)
block|{
operator|*
name|t
operator|=
literal|' '
expr_stmt|;
name|lc
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|p
operator|!=
literal|0
condition|)
block|{
comment|/* in parentheses */
comment|/* do not write ' ' if we want to skip spaces */
if|if
condition|(
operator|!
operator|(
name|skipw
operator|&&
operator|(
name|strchr
argument_list|(
name|skipw
argument_list|,
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
name|skipw
argument_list|,
literal|' '
argument_list|)
operator|)
operator|)
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
name|lc
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
comment|/* check to skip whitespace at start, but also after ( */
if|if
condition|(
name|skipw
operator|&&
name|i
operator|==
literal|0
operator|&&
operator|!
name|com
operator|&&
operator|!
name|quoted
operator|&&
name|lc
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|skipw
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|lc
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* check if we hit the delim */
for|for
control|(
name|d
operator|=
name|del
init|;
operator|*
name|d
condition|;
name|d
operator|++
control|)
block|{
comment|/* we can only exit if no parens or user tracks them */
if|if
condition|(
name|c
operator|==
operator|*
name|d
operator|&&
name|lc
operator|!=
literal|'\\'
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|par
operator|)
condition|)
block|{
goto|goto
name|tokenread
goto|;
block|}
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|limit
operator|>
literal|0
operator|&&
operator|(
name|i
operator|>=
name|limit
operator|||
call|(
name|size_t
call|)
argument_list|(
name|t
operator|-
name|token
argument_list|)
operator|>=
name|limit
operator|)
condition|)
block|{
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|t
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|lc
operator|==
literal|'\\'
condition|)
block|{
name|lc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lc
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* nothing read */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|par
operator|&&
name|p
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|ssize_t
operator|)
name|i
return|;
name|tokenread
label|:
if|if
condition|(
operator|*
name|del
operator|==
literal|'"'
condition|)
comment|/* do not skip over quotes after the string, they are part 		 * of the next string.  But skip over whitespace (if needed)*/
name|sldns_bskipcs
argument_list|(
name|b
argument_list|,
name|del
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sldns_bskipcs
argument_list|(
name|b
argument_list|,
name|del
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|par
operator|&&
name|p
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|ssize_t
operator|)
name|i
return|;
block|}
end_function

begin_function
name|void
name|sldns_bskipcs
parameter_list|(
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
while|while
condition|(
name|sldns_buffer_available_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
condition|)
block|{
name|c
operator|=
operator|(
name|char
operator|)
name|sldns_buffer_read_u8_at
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|_position
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|s
init|;
operator|*
name|d
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
name|c
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|&&
name|buffer
operator|->
name|_limit
operator|>
name|buffer
operator|->
name|_position
condition|)
block|{
name|buffer
operator|->
name|_position
operator|+=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sldns_fskipcs
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|sldns_fskipcs_l
argument_list|(
name|fp
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sldns_fskipcs_l
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|line_nr
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|line_nr
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|line_nr
operator|=
operator|*
name|line_nr
operator|+
literal|1
expr_stmt|;
block|}
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|s
init|;
operator|*
name|d
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
name|c
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* with getc, we've read too far */
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
name|ssize_t
name|sldns_bget_keyword_data
parameter_list|(
name|sldns_buffer
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|k_del
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|d_del
parameter_list|,
name|size_t
name|data_limit
parameter_list|)
block|{
comment|/* we assume: keyword|sep|data */
name|char
modifier|*
name|fkeyword
decl_stmt|;
name|ssize_t
name|i
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|keyword
argument_list|)
operator|>=
name|LDNS_MAX_KEYWORDLEN
condition|)
return|return
operator|-
literal|1
return|;
name|fkeyword
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|LDNS_MAX_KEYWORDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fkeyword
condition|)
return|return
operator|-
literal|1
return|;
comment|/* out of memory */
name|i
operator|=
name|sldns_bget_token
argument_list|(
name|b
argument_list|,
name|fkeyword
argument_list|,
name|k_del
argument_list|,
name|data_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|fkeyword
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* nothing read */
block|}
comment|/* case??? */
if|if
condition|(
name|strncmp
argument_list|(
name|fkeyword
argument_list|,
name|keyword
argument_list|,
name|strlen
argument_list|(
name|keyword
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|fkeyword
argument_list|)
expr_stmt|;
comment|/* whee, the match! */
comment|/* retrieve it's data */
name|i
operator|=
name|sldns_bget_token
argument_list|(
name|b
argument_list|,
name|data
argument_list|,
name|d_del
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|fkeyword
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

end_unit

