begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * parse.h   *  * a Net::DNS like library for C  * LibDNS Team @ NLnet Labs  * (c) NLnet Labs, 2005-2006  * See the file LICENSE for the license  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LDNS_PARSE_H
end_ifndef

begin_define
define|#
directive|define
name|LDNS_PARSE_H
end_define

begin_struct_decl
struct_decl|struct
name|sldns_buffer
struct_decl|;
end_struct_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|LDNS_PARSE_SKIP_SPACE
value|"\f\n\r\v"
define|#
directive|define
name|LDNS_PARSE_NORMAL
value|" \f\n\r\t\v"
define|#
directive|define
name|LDNS_PARSE_NO_NL
value|" \t"
define|#
directive|define
name|LDNS_MAX_LINELEN
value|10230
define|#
directive|define
name|LDNS_MAX_KEYWORDLEN
value|32
comment|/**  * \file  *  * Contains some low-level parsing functions, mostly used in the _frm_str  * family of functions.  */
comment|/**  * different type of directives in zone files  * We now deal with $TTL, $ORIGIN and $INCLUDE.  * The latter is not implemented in ldns (yet)  */
enum|enum
name|sldns_enum_directive
block|{
name|LDNS_DIR_TTL
block|,
name|LDNS_DIR_ORIGIN
block|,
name|LDNS_DIR_INCLUDE
block|}
enum|;
typedef|typedef
name|enum
name|sldns_enum_directive
name|sldns_directive
typedef|;
comment|/**   * returns a token/char from the stream F.  * This function deals with ( and ) in the stream,  * and ignores them when encountered  * \param[in] *f the file to read from  * \param[out] *token the read token is put here  * \param[in] *delim chars at which the parsing should stop  * \param[in] *limit how much to read. If 0 the builtin maximum is used  * \return 0 on error of EOF of the stream F.  Otherwise return the length of what is read  */
name|ssize_t
name|sldns_fget_token
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
name|limit
parameter_list|)
function_decl|;
comment|/**   * returns a token/char from the stream F.  * This function deals with ( and ) in the stream,  * and ignores when it finds them.  * \param[in] *f the file to read from  * \param[out] *token the token is put here  * \param[in] *delim chars at which the parsing should stop  * \param[in] *limit how much to read. If 0 use builtin maximum  * \param[in] line_nr pointer to an integer containing the current line number (for debugging purposes)  * \return 0 on error of EOF of F otherwise return the length of what is read  */
name|ssize_t
name|sldns_fget_token_l
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
name|limit
parameter_list|,
name|int
modifier|*
name|line_nr
parameter_list|)
function_decl|;
comment|/**  * returns a token/char from the buffer b.  * This function deals with ( and ) in the buffer,  * and ignores when it finds them.  * \param[in] *b the buffer to read from  * \param[out] *token the token is put here  * \param[in] *delim chars at which the parsing should stop  * \param[in] *limit how much to read. If 0 the builtin maximum is used  * \param[in] *par if you pass nonNULL, set to 0 on first call, the parenthesis  * state is stored in it, for use on next call.  User must check it is back  * to zero after last bget in string (for parse error).  If you pass NULL,  * the entire parenthesized string is read in.  * \param[in] skipw string with whitespace to skip before the start of the  * token, like " ", or " \t", or NULL for none.    * \returns 0 on error of EOF of b. Otherwise return the length of what is read  */
name|ssize_t
name|sldns_bget_token_par
parameter_list|(
name|struct
name|sldns_buffer
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
name|limit
parameter_list|,
name|int
modifier|*
name|par
parameter_list|,
specifier|const
name|char
modifier|*
name|skipw
parameter_list|)
function_decl|;
comment|/**  * returns a token/char from the buffer b.  * This function deals with ( and ) in the buffer,  * and ignores when it finds them.  * \param[in] *b the buffer to read from  * \param[out] *token the token is put here  * \param[in] *delim chars at which the parsing should stop  * \param[in] *limit how much to read. If 0 the builtin maximum is used  * \returns 0 on error of EOF of b. Otherwise return the length of what is read  */
name|ssize_t
name|sldns_bget_token
parameter_list|(
name|struct
name|sldns_buffer
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|size_t
name|limit
parameter_list|)
function_decl|;
comment|/*  * searches for keyword and delim in a file. Gives everything back  * after the keyword + k_del until we hit d_del  * \param[in] f file pointer to read from  * \param[in] keyword keyword to look for  * \param[in] k_del keyword delimeter   * \param[out] data the data found   * \param[in] d_del the data delimeter  * \param[in] data_limit maximum size the the data buffer  * \return the number of character read  */
name|ssize_t
name|sldns_fget_keyword_data
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|k_del
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|d_del
parameter_list|,
name|size_t
name|data_limit
parameter_list|)
function_decl|;
comment|/*  * searches for keyword and delim. Gives everything back  * after the keyword + k_del until we hit d_del  * \param[in] f file pointer to read from  * \param[in] keyword keyword to look for  * \param[in] k_del keyword delimeter   * \param[out] data the data found   * \param[in] d_del the data delimeter  * \param[in] data_limit maximum size the the data buffer  * \param[in] line_nr pointer to an integer containing the current line number (for debugging purposes)  * \return the number of character read  */
name|ssize_t
name|sldns_fget_keyword_data_l
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|k_del
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|d_del
parameter_list|,
name|size_t
name|data_limit
parameter_list|,
name|int
modifier|*
name|line_nr
parameter_list|)
function_decl|;
comment|/*  * searches for keyword and delim in a buffer. Gives everything back  * after the keyword + k_del until we hit d_del  * \param[in] b buffer pointer to read from  * \param[in] keyword keyword to look for  * \param[in] k_del keyword delimeter   * \param[out] data the data found   * \param[in] d_del the data delimeter  * \param[in] data_limit maximum size the the data buffer  * \return the number of character read  */
name|ssize_t
name|sldns_bget_keyword_data
parameter_list|(
name|struct
name|sldns_buffer
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|k_del
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|d_del
parameter_list|,
name|size_t
name|data_limit
parameter_list|)
function_decl|;
comment|/**  * returns the next character from a buffer. Advances the position pointer with 1.  * When end of buffer is reached returns EOF. This is the buffer's equivalent  * for getc().  * \param[in] *buffer buffer to read from  * \return EOF on failure otherwise return the character  */
name|int
name|sldns_bgetc
parameter_list|(
name|struct
name|sldns_buffer
modifier|*
name|buffer
parameter_list|)
function_decl|;
comment|/**  * skips all of the characters in the given string in the buffer, moving  * the position to the first character that is not in *s.  * \param[in] *buffer buffer to use  * \param[in] *s characters to skip  * \return void  */
name|void
name|sldns_bskipcs
parameter_list|(
name|struct
name|sldns_buffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
comment|/**  * skips all of the characters in the given string in the fp, moving  * the position to the first character that is not in *s.  * \param[in] *fp file to use  * \param[in] *s characters to skip  * \return void  */
name|void
name|sldns_fskipcs
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
comment|/**  * skips all of the characters in the given string in the fp, moving  * the position to the first character that is not in *s.  * \param[in] *fp file to use  * \param[in] *s characters to skip  * \param[in] line_nr pointer to an integer containing the current line number (for debugging purposes)  * \return void  */
name|void
name|sldns_fskipcs_l
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|line_nr
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDNS_PARSE_H */
end_comment

end_unit

