begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: preconv.c,v 1.12 2014/11/14 04:24:04 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2014 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_function
name|int
name|preconv_encode
parameter_list|(
name|struct
name|buf
modifier|*
name|ib
parameter_list|,
name|size_t
modifier|*
name|ii
parameter_list|,
name|struct
name|buf
modifier|*
name|ob
parameter_list|,
name|size_t
modifier|*
name|oi
parameter_list|,
name|int
modifier|*
name|filenc
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|state
decl_stmt|;
name|unsigned
name|int
name|accum
decl_stmt|;
name|unsigned
name|char
name|cu
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|filenc
operator|&
name|MPARSE_UTF8
operator|)
condition|)
goto|goto
name|latin
goto|;
name|state
operator|=
literal|0
expr_stmt|;
name|accum
operator|=
literal|0U
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|ii
init|;
name|i
operator|<
name|ib
operator|->
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|cu
operator|=
name|ib
operator|->
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cu
operator|&
literal|128
operator|)
operator|||
operator|(
name|cu
operator|&
literal|64
operator|)
condition|)
block|{
comment|/* Bad sequence header. */
break|break;
block|}
comment|/* Accept only legitimate bit patterns. */
if|if
condition|(
name|cu
operator|>
literal|191
operator|||
name|cu
operator|<
literal|128
condition|)
block|{
comment|/* Bad in-sequence bits. */
break|break;
block|}
name|accum
operator||=
operator|(
name|cu
operator|&
literal|63
operator|)
operator|<<
operator|--
name|state
operator|*
literal|6
expr_stmt|;
if|if
condition|(
name|state
condition|)
continue|continue;
if|if
condition|(
name|accum
operator|<
literal|0x80
condition|)
name|ob
operator|->
name|buf
index|[
operator|(
operator|*
name|oi
operator|)
operator|++
index|]
operator|=
name|accum
expr_stmt|;
else|else
operator|*
name|oi
operator|+=
name|snprintf
argument_list|(
name|ob
operator|->
name|buf
operator|+
operator|*
name|oi
argument_list|,
literal|11
argument_list|,
literal|"\\[u%.4X]"
argument_list|,
name|accum
argument_list|)
expr_stmt|;
operator|*
name|ii
operator|=
name|i
operator|+
literal|1
expr_stmt|;
operator|*
name|filenc
operator|&=
operator|~
name|MPARSE_LATIN1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * Entering a UTF-8 state:  if we encounter a 			 * UTF-8 bitmask, calculate the expected UTF-8 			 * state from it. 			 */
for|for
control|(
name|state
operator|=
literal|0
init|;
name|state
operator|<
literal|7
condition|;
name|state
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|cu
operator|&
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
name|state
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* Accept only legitimate bit patterns. */
switch|switch
condition|(
name|state
operator|--
condition|)
block|{
case|case
operator|(
literal|4
operator|)
case|:
if|if
condition|(
name|cu
operator|<=
literal|244
operator|&&
name|cu
operator|>=
literal|240
condition|)
block|{
name|accum
operator|=
operator|(
name|cu
operator|&
literal|7
operator|)
operator|<<
literal|18
expr_stmt|;
continue|continue;
block|}
comment|/* Bad 4-sequence start bits. */
break|break;
case|case
operator|(
literal|3
operator|)
case|:
if|if
condition|(
name|cu
operator|<=
literal|239
operator|&&
name|cu
operator|>=
literal|224
condition|)
block|{
name|accum
operator|=
operator|(
name|cu
operator|&
literal|15
operator|)
operator|<<
literal|12
expr_stmt|;
continue|continue;
block|}
comment|/* Bad 3-sequence start bits. */
break|break;
case|case
operator|(
literal|2
operator|)
case|:
if|if
condition|(
name|cu
operator|<=
literal|223
operator|&&
name|cu
operator|>=
literal|194
condition|)
block|{
name|accum
operator|=
operator|(
name|cu
operator|&
literal|31
operator|)
operator|<<
literal|6
expr_stmt|;
continue|continue;
block|}
comment|/* Bad 2-sequence start bits. */
break|break;
default|default:
comment|/* Bad sequence bit mask. */
break|break;
block|}
break|break;
block|}
block|}
comment|/* FALLTHROUGH: Invalid or incomplete UTF-8 sequence. */
name|latin
label|:
if|if
condition|(
operator|!
operator|(
operator|*
name|filenc
operator|&
name|MPARSE_LATIN1
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|oi
operator|+=
name|snprintf
argument_list|(
name|ob
operator|->
name|buf
operator|+
operator|*
name|oi
argument_list|,
literal|11
argument_list|,
literal|"\\[u%.4X]"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|ib
operator|->
name|buf
index|[
operator|(
operator|*
name|ii
operator|)
operator|++
index|]
argument_list|)
expr_stmt|;
operator|*
name|filenc
operator|&=
operator|~
name|MPARSE_UTF8
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|preconv_cue
parameter_list|(
specifier|const
name|struct
name|buf
modifier|*
name|b
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ln
decl_stmt|,
modifier|*
name|eoln
decl_stmt|,
modifier|*
name|eoph
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|phsz
decl_stmt|;
name|ln
operator|=
name|b
operator|->
name|buf
operator|+
name|offset
expr_stmt|;
name|sz
operator|=
name|b
operator|->
name|sz
operator|-
name|offset
expr_stmt|;
comment|/* Look for the end-of-line. */
if|if
condition|(
name|NULL
operator|==
operator|(
name|eoln
operator|=
name|memchr
argument_list|(
name|ln
argument_list|,
literal|'\n'
argument_list|,
name|sz
argument_list|)
operator|)
condition|)
name|eoln
operator|=
name|ln
operator|+
name|sz
expr_stmt|;
comment|/* Check if we have the correct header/trailer. */
if|if
condition|(
operator|(
name|sz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|eoln
operator|-
name|ln
argument_list|)
operator|)
operator|<
literal|10
operator|||
name|memcmp
argument_list|(
name|ln
argument_list|,
literal|".\\\" -*-"
argument_list|,
literal|7
argument_list|)
operator|||
name|memcmp
argument_list|(
name|eoln
operator|-
literal|3
argument_list|,
literal|"-*-"
argument_list|,
literal|3
argument_list|)
condition|)
return|return
operator|(
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
operator|)
return|;
comment|/* Move after the header and adjust for the trailer. */
name|ln
operator|+=
literal|7
expr_stmt|;
name|sz
operator|-=
literal|10
expr_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|sz
operator|>
literal|0
operator|&&
literal|' '
operator|==
operator|*
name|ln
condition|)
block|{
name|ln
operator|++
expr_stmt|;
name|sz
operator|--
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
break|break;
comment|/* Find the end-of-phrase marker (or eoln). */
if|if
condition|(
name|NULL
operator|==
operator|(
name|eoph
operator|=
name|memchr
argument_list|(
name|ln
argument_list|,
literal|';'
argument_list|,
name|sz
argument_list|)
operator|)
condition|)
name|eoph
operator|=
name|eoln
operator|-
literal|3
expr_stmt|;
else|else
name|eoph
operator|++
expr_stmt|;
comment|/* Only account for the "coding" phrase. */
if|if
condition|(
operator|(
name|phsz
operator|=
name|eoph
operator|-
name|ln
operator|)
operator|<
literal|7
operator|||
name|strncasecmp
argument_list|(
name|ln
argument_list|,
literal|"coding:"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|sz
operator|-=
name|phsz
expr_stmt|;
name|ln
operator|+=
name|phsz
expr_stmt|;
continue|continue;
block|}
name|sz
operator|-=
literal|7
expr_stmt|;
name|ln
operator|+=
literal|7
expr_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
operator|&&
literal|' '
operator|==
operator|*
name|ln
condition|)
block|{
name|ln
operator|++
expr_stmt|;
name|sz
operator|--
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check us against known encodings. */
if|if
condition|(
name|phsz
operator|>
literal|4
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|ln
argument_list|,
literal|"utf-8"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
operator|(
name|MPARSE_UTF8
operator|)
return|;
if|if
condition|(
name|phsz
operator|>
literal|10
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|ln
argument_list|,
literal|"iso-latin-1"
argument_list|,
literal|11
argument_list|)
condition|)
return|return
operator|(
name|MPARSE_LATIN1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
operator|)
return|;
block|}
end_function

end_unit

