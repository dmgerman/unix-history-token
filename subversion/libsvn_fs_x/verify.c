begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* verify.c --- verification of FSX filesystems  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"verify.h"
end_include

begin_include
include|#
directive|include
file|"fs_x.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"rep-cache.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/** Verifying. **/
end_comment

begin_comment
comment|/* Baton type expected by verify_walker().  The purpose is to limit the  * number of notifications sent.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|verify_walker_baton_t
block|{
comment|/* number of calls to verify_walker() since the last clean */
name|int
name|iteration_count
decl_stmt|;
comment|/* progress notification callback to invoke periodically (may be NULL) */
name|svn_fs_progress_notify_func_t
name|notify_func
decl_stmt|;
comment|/* baton to use with NOTIFY_FUNC */
name|void
modifier|*
name|notify_baton
decl_stmt|;
comment|/* remember the last revision for which we called notify_func */
name|svn_revnum_t
name|last_notified_revision
decl_stmt|;
block|}
name|verify_walker_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Used by svn_fs_x__verify().    Implements svn_fs_x__walk_rep_reference().walker.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_walker
parameter_list|(
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|verify_walker_baton_t
modifier|*
name|walker_baton
init|=
name|baton
decl_stmt|;
comment|/* notify and free resources periodically */
if|if
condition|(
name|walker_baton
operator|->
name|iteration_count
operator|>
literal|1000
condition|)
block|{
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
decl_stmt|;
if|if
condition|(
name|walker_baton
operator|->
name|notify_func
operator|&&
name|revision
operator|!=
name|walker_baton
operator|->
name|last_notified_revision
condition|)
block|{
name|walker_baton
operator|->
name|notify_func
argument_list|(
name|revision
argument_list|,
name|walker_baton
operator|->
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|walker_baton
operator|->
name|last_notified_revision
operator|=
name|revision
expr_stmt|;
block|}
name|walker_baton
operator|->
name|iteration_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* access the repo data */
name|SVN_ERR
argument_list|(
name|svn_fs_x__check_rep
argument_list|(
name|rep
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update resource usage counters */
name|walker_baton
operator|->
name|iteration_count
operator|++
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify the rep cache DB's consistency with our rev / pack data.  * The function signature is similar to svn_fs_x__verify.  * The values of START and END have already been auto-selected and  * verified.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_rep_cache
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_fs_progress_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|exists
decl_stmt|;
comment|/* rep-cache verification. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__exists_rep_cache
argument_list|(
operator|&
name|exists
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
comment|/* provide a baton to allow the reuse of open file handles between          iterations (saves 2/3 of OS level file operations). */
name|verify_walker_baton_t
modifier|*
name|baton
init|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
decl_stmt|;
name|baton
operator|->
name|last_notified_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|baton
operator|->
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|baton
operator|->
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
comment|/* tell the user that we are now ready to do *something* */
if|if
condition|(
name|notify_func
condition|)
name|notify_func
argument_list|(
name|SVN_INVALID_REVNUM
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Do not attempt to walk the rep-cache database if its file does          not exist,  since doing so would create it --- which may confuse          the administrator.   Don't take any lock. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__walk_rep_reference
argument_list|(
name|fs
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|verify_walker
argument_list|,
name|baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that the MD5 checksum of the data between offsets START and END  * in FILE matches the EXPECTED checksum.  If there is a mismatch use the  * indedx NAME in the error message.  Supports cancellation with CANCEL_FUNC  * and CANCEL_BATON.  SCRATCH_POOL is for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_index_checksum
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_off_t
name|start
parameter_list|,
name|apr_off_t
name|end
parameter_list|,
name|svn_checksum_t
modifier|*
name|expected
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
name|SVN__STREAM_CHUNK_SIZE
index|]
decl_stmt|;
name|apr_off_t
name|size
init|=
name|end
operator|-
name|start
decl_stmt|;
name|svn_checksum_t
modifier|*
name|actual
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|context
init|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Calculate the index checksum. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|to_read
init|=
name|size
operator|>
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
else|:
operator|(
name|apr_size_t
operator|)
name|size
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|to_read
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|context
argument_list|,
name|buffer
argument_list|,
name|to_read
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|to_read
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|actual
argument_list|,
name|context
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify that it matches the expected checksum. */
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|file_name
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_mismatch_err
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"%s checksum mismatch in file %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|file_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify the MD5 checksums of the index data in the rev / pack file  * containing revision START in FS.  If given, invoke CANCEL_FUNC with  * CANCEL_BATON at regular intervals.  Use SCRATCH_POOL for temporary  * allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_index_checksums
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
comment|/* Open the rev / pack file and read the footer */
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|start
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__auto_read_footer
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify the index contents against the checksum from the footer. */
name|SVN_ERR
argument_list|(
name|verify_index_checksum
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
literal|"L2P index"
argument_list|,
name|rev_file
operator|->
name|l2p_offset
argument_list|,
name|rev_file
operator|->
name|p2l_offset
argument_list|,
name|rev_file
operator|->
name|l2p_checksum
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_index_checksum
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
literal|"P2L index"
argument_list|,
name|rev_file
operator|->
name|p2l_offset
argument_list|,
name|rev_file
operator|->
name|footer_offset
argument_list|,
name|rev_file
operator|->
name|p2l_checksum
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Done. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that for all log-to-phys index entries for revisions START to  * START + COUNT-1 in FS there is a consistent entry in the phys-to-log  * index.  If given, invoke CANCEL_FUNC with CANCEL_BATON at regular  * intervals. Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|compare_l2p_to_p2l_index
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|count
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_revnum_t
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|max_ids
decl_stmt|;
comment|/* common file access structure */
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|start
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* determine the range of items to check for each revision */
name|SVN_ERR
argument_list|(
name|svn_fs_x__l2p_get_max_ids
argument_list|(
operator|&
name|max_ids
argument_list|,
name|fs
argument_list|,
name|start
argument_list|,
name|count
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check all items in all revisions if the given range */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_ids
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|apr_uint64_t
name|k
decl_stmt|;
name|apr_uint64_t
name|max_id
init|=
name|APR_ARRAY_IDX
argument_list|(
name|max_ids
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|start
operator|+
name|i
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max_id
condition|;
operator|++
name|k
control|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|apr_uint32_t
name|sub_item
decl_stmt|;
name|svn_fs_x__id_t
name|l2p_item
decl_stmt|;
name|svn_fs_x__id_t
modifier|*
name|p2l_item
decl_stmt|;
name|l2p_item
operator|.
name|change_set
operator|=
name|svn_fs_x__change_set_by_rev
argument_list|(
name|revision
argument_list|)
expr_stmt|;
name|l2p_item
operator|.
name|number
operator|=
name|k
expr_stmt|;
comment|/* get L2P entry.  Ignore unused entries. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
operator|&
name|l2p_item
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* find the corresponding P2L entry */
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_item_lookup
argument_list|(
operator|&
name|p2l_item
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|revision
argument_list|,
name|offset
argument_list|,
name|sub_item
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2l_item
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_INCONSISTENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"p2l index entry not found for "
literal|"PHYS o%s:s%ld returned by "
literal|"l2p index for LOG r%ld:i%ld"
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|offset
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|sub_item
argument_list|,
name|revision
argument_list|,
operator|(
name|long
operator|)
name|k
argument_list|)
return|;
if|if
condition|(
operator|!
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|l2p_item
argument_list|,
name|p2l_item
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_INCONSISTENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"p2l index info LOG r%ld:i%ld"
literal|" does not match "
literal|"l2p index for LOG r%ld:i%ld"
argument_list|)
argument_list|,
name|svn_fs_x__get_revnum
argument_list|(
name|p2l_item
operator|->
name|change_set
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|p2l_item
operator|->
name|number
argument_list|,
name|revision
argument_list|,
operator|(
name|long
operator|)
name|k
argument_list|)
return|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that for all phys-to-log index entries for revisions START to  * START + COUNT-1 in FS there is a consistent entry in the log-to-phys  * index.  If given, invoke CANCEL_FUNC with CANCEL_BATON at regular  * intervals. Use SCRATCH_POOL for temporary allocations.  *  * Please note that we can only check on pack / rev file granularity and  * must only be called for a single rev / pack file.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|compare_p2l_to_l2p_index
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|count
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool2
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_off_t
name|max_offset
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
comment|/* common file access structure */
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|start
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get the size of the rev / pack file as covered by the P2L index */
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_get_max_offset
argument_list|(
operator|&
name|max_offset
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for all offsets in the file, get the P2L index entries and check      them against the L2P index */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|max_offset
condition|;
control|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|last_entry
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* get all entries for the current block */
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_index_lookup
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|start
argument_list|,
name|offset
argument_list|,
name|ffd
operator|->
name|p2l_page_size
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"p2l does not cover offset %s"
literal|" for revision %ld"
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|offset
argument_list|)
argument_list|,
name|start
argument_list|)
return|;
comment|/* process all entries (and later continue with the next block) */
name|last_entry
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|entries
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_fs_x__p2l_entry_t
argument_list|)
expr_stmt|;
name|offset
operator|=
name|last_entry
operator|->
name|offset
operator|+
name|last_entry
operator|->
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|apr_uint32_t
name|k
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
argument_list|)
decl_stmt|;
comment|/* check all sub-items for consist entries in the L2P index */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|entry
operator|->
name|item_count
condition|;
operator|++
name|k
control|)
block|{
name|apr_off_t
name|l2p_offset
decl_stmt|;
name|apr_uint32_t
name|sub_item
decl_stmt|;
name|svn_fs_x__id_t
modifier|*
name|p2l_item
init|=
operator|&
name|entry
operator|->
name|items
index|[
name|k
index|]
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|p2l_item
operator|->
name|change_set
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|l2p_offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|p2l_item
argument_list|,
name|iterpool2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_item
operator|!=
name|k
operator|||
name|l2p_offset
operator|!=
name|entry
operator|->
name|offset
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_INCONSISTENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"l2p index entry PHYS o%s:s%ld "
literal|"does not match p2l index value "
literal|"LOG r%ld:i%ld for PHYS o%s:s%ld"
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|l2p_offset
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|sub_item
argument_list|,
name|revision
argument_list|,
operator|(
name|long
operator|)
name|p2l_item
operator|->
name|number
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|entry
operator|->
name|offset
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|k
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Items smaller than this can be read at once into a buffer and directly  * be checksummed.  Larger items require stream processing.  * Must be a multiple of 8. */
end_comment

begin_define
define|#
directive|define
name|STREAM_THRESHOLD
value|4096
end_define

begin_comment
comment|/* Verify that the next SIZE bytes read from FILE are NUL.  SIZE must not  * exceed STREAM_THRESHOLD.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|expect_buffer_nul
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_off_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
union|union
block|{
name|unsigned
name|char
name|buffer
index|[
name|STREAM_THRESHOLD
index|]
decl_stmt|;
name|apr_uint64_t
name|chunks
index|[
name|STREAM_THRESHOLD
operator|/
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
index|]
decl_stmt|;
block|}
name|data
union|;
name|apr_size_t
name|i
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|size
operator|<=
name|STREAM_THRESHOLD
argument_list|)
expr_stmt|;
comment|/* read the whole data block; error out on failure */
name|data
operator|.
name|chunks
index|[
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
name|data
operator|.
name|buffer
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chunky check */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|data
operator|.
name|chunks
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
comment|/* byte-wise check upon mismatch or at the end of the block */
for|for
control|(
name|i
operator|*=
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|data
operator|.
name|buffer
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|file_name
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|size
operator|-
name|i
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Empty section in file %s contains "
literal|"non-NUL data at offset %s"
argument_list|)
argument_list|,
name|file_name
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that the next SIZE bytes read from FILE are NUL.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_all_nul
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_off_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
for|for
control|(
init|;
name|size
operator|>=
name|STREAM_THRESHOLD
condition|;
name|size
operator|-=
name|STREAM_THRESHOLD
control|)
name|SVN_ERR
argument_list|(
name|expect_buffer_nul
argument_list|(
name|file
argument_list|,
name|STREAM_THRESHOLD
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|SVN_ERR
argument_list|(
name|expect_buffer_nul
argument_list|(
name|file
argument_list|,
name|size
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compare the ACTUAL checksum with the one expected by ENTRY.  * Return an error in case of mismatch.  Use the name of FILE  * in error message.  Allocate temporary data in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|expected_checksum
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_uint32_t
name|actual
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|actual
operator|!=
name|entry
operator|->
name|fnv1_checksum
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|file_name
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|file_name
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch in item at offset %s of "
literal|"length %s bytes in file %s"
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|entry
operator|->
name|offset
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|entry
operator|->
name|size
argument_list|)
argument_list|,
name|file_name
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that the FNV checksum over the next ENTRY->SIZE bytes read  * from FILE will match ENTRY's expected checksum.  SIZE must not  * exceed STREAM_THRESHOLD.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|expected_buffered_checksum
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
name|STREAM_THRESHOLD
index|]
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|size
operator|<=
name|STREAM_THRESHOLD
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
operator|(
name|apr_size_t
operator|)
name|entry
operator|->
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|expected_checksum
argument_list|(
name|file
argument_list|,
name|entry
argument_list|,
name|svn__fnv1a_32x4
argument_list|(
name|buffer
argument_list|,
operator|(
name|apr_size_t
operator|)
name|entry
operator|->
name|size
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that the FNV checksum over the next ENTRY->SIZE bytes read from  * FILE will match ENTRY's expected checksum.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|expected_streamed_checksum
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
name|STREAM_THRESHOLD
index|]
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|context
init|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_fnv1a_32x4
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_off_t
name|size
init|=
name|entry
operator|->
name|size
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|to_read
init|=
name|size
operator|>
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
else|:
operator|(
name|apr_size_t
operator|)
name|size
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|to_read
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|context
argument_list|,
name|buffer
argument_list|,
name|to_read
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|to_read
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|checksum
argument_list|,
name|context
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|expected_checksum
argument_list|(
name|file
argument_list|,
name|entry
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
specifier|const
name|apr_uint32_t
operator|*
operator|)
name|checksum
operator|->
name|digest
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that for all phys-to-log index entries for revisions START to  * START + COUNT-1 in FS match the actual pack / rev file contents.  * If given, invoke CANCEL_FUNC with CANCEL_BATON at regular intervals.  * Use SCRATCH_POOL for temporary allocations.  *  * Please note that we can only check on pack / rev file granularity and  * must only be called for a single rev / pack file.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|compare_p2l_to_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|count
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_off_t
name|max_offset
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
comment|/* open the pack / rev file that is covered by the p2l index */
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|start
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check file size vs. range covered by index */
name|SVN_ERR
argument_list|(
name|svn_fs_x__auto_read_footer
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_get_max_offset
argument_list|(
operator|&
name|max_offset
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev_file
operator|->
name|l2p_offset
operator|!=
name|max_offset
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_INCONSISTENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"File size of %s for revision r%ld does "
literal|"not match p2l index size of %s"
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|rev_file
operator|->
name|l2p_offset
argument_list|)
argument_list|,
name|start
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|max_offset
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_file_aligned_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for all offsets in the file, get the P2L index entries and check      them against the L2P index */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|max_offset
condition|;
control|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* get all entries for the current block */
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_index_lookup
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|start
argument_list|,
name|offset
argument_list|,
name|ffd
operator|->
name|p2l_page_size
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The above might have moved the file pointer.        * Ensure we actually start reading at OFFSET.  */
name|SVN_ERR
argument_list|(
name|svn_io_file_aligned_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* process all entries (and later continue with the next block) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
argument_list|)
decl_stmt|;
comment|/* skip bits we previously checked */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|entry
operator|->
name|offset
operator|<
name|offset
condition|)
continue|continue;
comment|/* skip zero-sized entries */
if|if
condition|(
name|entry
operator|->
name|size
operator|==
literal|0
condition|)
continue|continue;
comment|/* p2l index must cover all rev / pack file offsets exactly once */
if|if
condition|(
name|entry
operator|->
name|offset
operator|!=
name|offset
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_INCONSISTENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"p2l index entry for revision r%ld"
literal|" is non-contiguous between offsets "
literal|" %s and %s"
argument_list|)
argument_list|,
name|start
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|offset
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|entry
operator|->
name|offset
argument_list|)
argument_list|)
return|;
comment|/* empty sections must contain NUL bytes only */
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_UNUSED
condition|)
block|{
comment|/* skip filler entry at the end of the p2l index */
if|if
condition|(
name|entry
operator|->
name|offset
operator|!=
name|max_offset
condition|)
name|SVN_ERR
argument_list|(
name|read_all_nul
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|size
operator|<
name|STREAM_THRESHOLD
condition|)
name|SVN_ERR
argument_list|(
name|expected_buffered_checksum
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|expected_streamed_checksum
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* advance offset */
name|offset
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that the revprops of the revisions START to END in FS can be  * accessed.  Invoke CANCEL_FUNC with CANCEL_BATON at regular intervals.  *  * The values of START and END have already been auto-selected and  * verified.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_revnum_t
name|revision
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|revision
operator|=
name|start
init|;
name|revision
operator|<
name|end
condition|;
operator|++
name|revision
control|)
block|{
name|svn_string_t
modifier|*
name|date
decl_stmt|;
name|apr_time_t
name|timetemp
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Access the svn:date revprop.        * This implies parsing all revprops for that revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__revision_prop
argument_list|(
operator|&
name|date
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The time stamp is the only revprop that, if given, needs to        * have a valid content. */
if|if
condition|(
name|date
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|timetemp
argument_list|,
name|date
operator|->
name|data
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that on-disk representation has not been tempered with (in a way  * that leaves the repository in a corrupted state).  This compares log-to-  * phys with phys-to-log indexes, verifies the low-level checksums and  * checks that all revprops are available.  The function signature is  * similar to svn_fs_x__verify.  *  * The values of START and END have already been auto-selected and  * verified.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_metadata_consistency
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_fs_progress_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|,
name|next_revision
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|revision
operator|=
name|start
init|;
name|revision
operator|<=
name|end
condition|;
name|revision
operator|=
name|next_revision
control|)
block|{
name|svn_revnum_t
name|count
init|=
name|svn_fs_x__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|pack_start
init|=
name|count
decl_stmt|;
name|svn_revnum_t
name|pack_end
init|=
name|pack_start
operator|+
name|svn_fs_x__pack_size
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
operator|&&
operator|(
name|pack_start
operator|%
name|ffd
operator|->
name|max_files_per_dir
operator|==
literal|0
operator|)
condition|)
name|notify_func
argument_list|(
name|pack_start
argument_list|,
name|notify_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Check for external corruption to the indexes. */
name|err
operator|=
name|verify_index_checksums
argument_list|(
name|fs
argument_list|,
name|pack_start
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* two-way index check */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|compare_l2p_to_p2l_index
argument_list|(
name|fs
argument_list|,
name|pack_start
argument_list|,
name|pack_end
operator|-
name|pack_start
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|compare_p2l_to_l2p_index
argument_list|(
name|fs
argument_list|,
name|pack_start
argument_list|,
name|pack_end
operator|-
name|pack_start
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* verify in-index checksums and types vs. actual rev / pack files */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|compare_p2l_to_rev
argument_list|(
name|fs
argument_list|,
name|pack_start
argument_list|,
name|pack_end
operator|-
name|pack_start
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* ensure that revprops are available and accessible */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|verify_revprops
argument_list|(
name|fs
argument_list|,
name|pack_start
argument_list|,
name|pack_end
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* concurrent packing is one of the reasons why verification may fail.          Make sure, we operate on up-to-date information. */
if|if
condition|(
name|err
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_min_unpacked_rev
argument_list|(
operator|&
name|ffd
operator|->
name|min_unpacked_rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* retry the whole shard if it got packed in the meantime */
if|if
condition|(
name|err
operator|&&
name|count
operator|!=
name|svn_fs_x__pack_size
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We could simply assign revision here but the code below is              more intuitive to maintainers. */
name|next_revision
operator|=
name|svn_fs_x__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|next_revision
operator|=
name|pack_end
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__verify
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_fs_progress_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_revnum_t
name|youngest
init|=
name|ffd
operator|->
name|youngest_rev_cache
decl_stmt|;
comment|/* cache is current */
comment|/* Input validation. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start
argument_list|)
condition|)
name|start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end
argument_list|)
condition|)
name|end
operator|=
name|youngest
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__ensure_revision_exists
argument_list|(
name|start
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__ensure_revision_exists
argument_list|(
name|end
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* log/phys index consistency.  We need to check them first to make      sure we can access the rev / pack files in format7. */
name|SVN_ERR
argument_list|(
name|verify_metadata_consistency
argument_list|(
name|fs
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* rep cache consistency */
name|SVN_ERR
argument_list|(
name|verify_rep_cache
argument_list|(
name|fs
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

