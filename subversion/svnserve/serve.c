begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * serve.c :  Functions for serving the Subversion protocol  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_comment
comment|/* for UINT_MAX */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"svn_compat.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* For SVN_PATH_LOCAL_SEPARATOR */
end_comment

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_comment
comment|/* for SVN_RA_CAPABILITY_* */
end_comment

begin_include
include|#
directive|include
file|"svn_ra_svn.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_user.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_log.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_svn_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* For getpid() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|commit_callback_baton_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_revnum_t
modifier|*
name|new_rev
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|author
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|post_commit_err
decl_stmt|;
block|}
name|commit_callback_baton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|report_driver_baton_t
block|{
name|server_baton_t
modifier|*
name|sb
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_url
decl_stmt|;
comment|/* Decoded repository URL. */
name|void
modifier|*
name|report_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* so update() can distinguish checkout from update in logging */
name|int
name|entry_counter
decl_stmt|;
name|svn_boolean_t
name|only_empty_entries
decl_stmt|;
comment|/* for diff() logging */
name|svn_revnum_t
modifier|*
name|from_rev
decl_stmt|;
block|}
name|report_driver_baton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|log_baton_t
block|{
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|int
name|stack_depth
decl_stmt|;
block|}
name|log_baton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|file_revs_baton_t
block|{
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Pool provided in the handler call. */
block|}
name|file_revs_baton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|fs_warning_baton_t
block|{
name|server_baton_t
modifier|*
name|server
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|fs_warning_baton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|authz_baton_t
block|{
name|server_baton_t
modifier|*
name|server
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
block|}
name|authz_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Write LEN bytes of ERRSTR to LOG_FILE with svn_io_file_write(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_write
parameter_list|(
name|apr_file_t
modifier|*
name|log_file
parameter_list|,
specifier|const
name|char
modifier|*
name|errstr
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_io_file_write
argument_list|(
name|log_file
argument_list|,
name|errstr
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|log_error
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|apr_file_t
modifier|*
name|log_file
parameter_list|,
specifier|const
name|char
modifier|*
name|remote_host
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
specifier|const
name|char
modifier|*
name|repos
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|timestr
decl_stmt|,
modifier|*
name|continuation
decl_stmt|;
name|char
name|errbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* 8192 from MAX_STRING_LEN in from httpd-2.2.4/include/httpd.h */
name|char
name|errstr
index|[
literal|8192
index|]
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
return|return;
if|if
condition|(
name|log_file
operator|==
name|NULL
condition|)
return|return;
name|timestr
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|remote_host
operator|=
operator|(
name|remote_host
condition|?
name|remote_host
else|:
literal|"-"
operator|)
expr_stmt|;
name|user
operator|=
operator|(
name|user
condition|?
name|user
else|:
literal|"-"
operator|)
expr_stmt|;
name|repos
operator|=
operator|(
name|repos
condition|?
name|repos
else|:
literal|"-"
operator|)
expr_stmt|;
name|continuation
operator|=
literal|""
expr_stmt|;
while|while
condition|(
name|err
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|message
init|=
name|svn_err_best_message
argument_list|(
name|err
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|)
decl_stmt|;
comment|/* based on httpd-2.2.4/server/log.c:log_error_core */
name|apr_size_t
name|len
init|=
name|apr_snprintf
argument_list|(
name|errstr
argument_list|,
sizeof|sizeof
argument_list|(
name|errstr
argument_list|)
argument_list|,
literal|"%"
name|APR_PID_T_FMT
literal|" %s %s %s %s ERR%s %s %ld %d "
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|timestr
argument_list|,
name|remote_host
argument_list|,
name|user
argument_list|,
name|repos
argument_list|,
name|continuation
argument_list|,
name|err
operator|->
name|file
condition|?
name|err
operator|->
name|file
else|:
literal|"-"
argument_list|,
name|err
operator|->
name|line
argument_list|,
name|err
operator|->
name|apr_err
argument_list|)
decl_stmt|;
name|len
operator|+=
name|escape_errorlog_item
argument_list|(
name|errstr
operator|+
name|len
argument_list|,
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|errstr
argument_list|)
operator|-
name|len
argument_list|)
expr_stmt|;
comment|/* Truncate for the terminator (as apr_snprintf does) */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|errstr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|APR_EOL_STR
argument_list|)
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|errstr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|APR_EOL_STR
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|errstr
operator|+
name|len
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|log_write
argument_list|(
name|log_file
argument_list|,
name|errstr
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|continuation
operator|=
literal|"-"
expr_stmt|;
name|err
operator|=
name|err
operator|->
name|child
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call log_error with log_file, remote_host, user, and repos    arguments from SERVER and CONN. */
end_comment

begin_function
specifier|static
name|void
name|log_server_error
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|server_baton_t
modifier|*
name|server
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|log_error
argument_list|(
name|err
argument_list|,
name|server
operator|->
name|log_file
argument_list|,
name|svn_ra_svn_conn_remote_host
argument_list|(
name|conn
argument_list|)
argument_list|,
name|server
operator|->
name|user
argument_list|,
name|server
operator|->
name|repos_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* svn_error_create() a new error, log_server_error() it, and    return it. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|error_create_and_log
parameter_list|(
name|apr_status_t
name|apr_err
parameter_list|,
name|svn_error_t
modifier|*
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|server_baton_t
modifier|*
name|server
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|child
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|log_server_error
argument_list|(
name|err
argument_list|,
name|server
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Log a failure ERR, transmit ERR back to the client (as part of a    "failure" notification), consume ERR, and flush the connection. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_fail_and_flush
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|server_baton_t
modifier|*
name|server
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|io_err
decl_stmt|;
name|log_server_error
argument_list|(
name|err
argument_list|,
name|server
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|io_err
operator|=
name|svn_ra_svn__write_cmd_failure
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|io_err
argument_list|)
expr_stmt|;
return|return
name|svn_ra_svn__flush
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Log a client command. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_command
parameter_list|(
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|remote_host
decl_stmt|,
modifier|*
name|timestr
decl_stmt|,
modifier|*
name|log
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|apr_size_t
name|nbytes
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|log_file
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|remote_host
operator|=
name|svn_ra_svn_conn_remote_host
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|timestr
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|log
operator|=
name|apr_pvsprintf
argument_list|(
name|pool
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|line
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_PID_T_FMT
literal|" %s %s %s %s %s"
name|APR_EOL_STR
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|timestr
argument_list|,
operator|(
name|remote_host
condition|?
name|remote_host
else|:
literal|"-"
operator|)
argument_list|,
operator|(
name|b
operator|->
name|user
condition|?
name|b
operator|->
name|user
else|:
literal|"-"
operator|)
argument_list|,
name|b
operator|->
name|repos_name
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|log_write
argument_list|(
name|b
operator|->
name|log_file
argument_list|,
name|line
argument_list|,
name|nbytes
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Log an authz failure */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_authz_denied
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_repos_authz_access_t
name|required
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|timestr
decl_stmt|,
modifier|*
name|remote_host
decl_stmt|,
modifier|*
name|line
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|log_file
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
name|b
operator|->
name|user
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|timestr
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|remote_host
operator|=
name|svn_ra_svn_conn_remote_host
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|line
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_PID_T_FMT
literal|" %s %s %s %s Authorization Failed %s%s %s"
name|APR_EOL_STR
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|timestr
argument_list|,
operator|(
name|remote_host
condition|?
name|remote_host
else|:
literal|"-"
operator|)
argument_list|,
operator|(
name|b
operator|->
name|user
condition|?
name|b
operator|->
name|user
else|:
literal|"-"
operator|)
argument_list|,
name|b
operator|->
name|repos_name
argument_list|,
operator|(
name|required
operator|&
name|svn_authz_recursive
condition|?
literal|"recursive "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|required
operator|&
name|svn_authz_write
condition|?
literal|"write"
else|:
literal|"read"
operator|)
argument_list|,
operator|(
name|path
operator|&&
name|path
index|[
literal|0
index|]
condition|?
name|path
else|:
literal|"/"
operator|)
argument_list|)
expr_stmt|;
return|return
name|log_write
argument_list|(
name|b
operator|->
name|log_file
argument_list|,
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|load_pwdb_config
parameter_list|(
name|server_baton_t
modifier|*
name|server
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pwdb_path
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_config_get
argument_list|(
name|server
operator|->
name|cfg
argument_list|,
operator|&
name|pwdb_path
argument_list|,
name|SVN_CONFIG_SECTION_GENERAL
argument_list|,
name|SVN_CONFIG_OPTION_PASSWORD_DB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|server
operator|->
name|pwdb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pwdb_path
condition|)
block|{
name|pwdb_path
operator|=
name|svn_dirent_internal_style
argument_list|(
name|pwdb_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|pwdb_path
operator|=
name|svn_dirent_join
argument_list|(
name|server
operator|->
name|base
argument_list|,
name|pwdb_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_config_read3
argument_list|(
operator|&
name|server
operator|->
name|pwdb
argument_list|,
name|pwdb_path
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log_server_error
argument_list|(
name|err
argument_list|,
name|server
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Because it may be possible to read the pwdb file with some              access methods and not others, ignore errors reading the pwdb              file and just don't present password authentication as an              option.  Also, some authentications (e.g. --tunnel) can              proceed without it anyway.               ### Not entirely sure why SVN_ERR_BAD_FILENAME is checked              ### for here.  That seems to have been introduced in r856914,              ### and only in r870942 was the APR_EACCES check introduced. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_BAD_FILENAME
operator|&&
operator|!
name|APR_STATUS_IS_EACCES
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* Now that we've logged the error, clear it and return a                  * nice, generic error to the user:                  * http://subversion.tigris.org/issues/show_bug.cgi?id=2271 */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHN_FAILED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
else|else
comment|/* Ignore SVN_ERR_BAD_FILENAME and APR_EACCES and proceed. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize *ACCESS_FILE based on the type of argument.  Results are  * placed in *ACCESS_FILE.  SERVER baton is used to convert relative paths to  * absolute paths rooted at the server root.  REPOS_ROOT is used to calculate  * an absolute URL for repos-relative URLs. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|canonicalize_access_file
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|access_file
parameter_list|,
name|server_baton_t
modifier|*
name|server
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
operator|*
name|access_file
argument_list|)
condition|)
block|{
operator|*
name|access_file
operator|=
name|svn_uri_canonicalize
argument_list|(
operator|*
name|access_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svn_path_is_repos_relative_url
argument_list|(
operator|*
name|access_file
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_uri_get_file_url_from_dirent
argument_list|(
operator|&
name|repos_root_url
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_path_resolve_repos_relative_url
argument_list|(
name|access_file
argument_list|,
operator|*
name|access_file
argument_list|,
name|repos_root_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|access_file
operator|=
name|svn_uri_canonicalize
argument_list|(
operator|*
name|access_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|access_file
operator|=
name|svn_dirent_internal_style
argument_list|(
operator|*
name|access_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|access_file
operator|=
name|svn_dirent_join
argument_list|(
name|server
operator|->
name|base
argument_list|,
operator|*
name|access_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|load_authz_config
parameter_list|(
name|server_baton_t
modifier|*
name|server
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|authzdb_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|groupsdb_path
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Read authz configuration. */
name|svn_config_get
argument_list|(
name|server
operator|->
name|cfg
argument_list|,
operator|&
name|authzdb_path
argument_list|,
name|SVN_CONFIG_SECTION_GENERAL
argument_list|,
name|SVN_CONFIG_OPTION_AUTHZ_DB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|server
operator|->
name|cfg
argument_list|,
operator|&
name|groupsdb_path
argument_list|,
name|SVN_CONFIG_SECTION_GENERAL
argument_list|,
name|SVN_CONFIG_OPTION_GROUPS_DB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|authzdb_path
condition|)
block|{
specifier|const
name|char
modifier|*
name|case_force_val
decl_stmt|;
comment|/* Canonicalize and add the base onto the authzdb_path (if needed). */
name|err
operator|=
name|canonicalize_access_file
argument_list|(
operator|&
name|authzdb_path
argument_list|,
name|server
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Same for the groupsdb_path if it is present. */
if|if
condition|(
name|groupsdb_path
operator|&&
operator|!
name|err
condition|)
name|err
operator|=
name|canonicalize_access_file
argument_list|(
operator|&
name|groupsdb_path
argument_list|,
name|server
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_repos_authz_read2
argument_list|(
operator|&
name|server
operator|->
name|authzdb
argument_list|,
name|authzdb_path
argument_list|,
name|groupsdb_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|log_server_error
argument_list|(
name|err
argument_list|,
name|server
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_INVALID_CONFIG
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* Are we going to be case-normalizing usernames when we consult        * this authz file? */
name|svn_config_get
argument_list|(
name|server
operator|->
name|cfg
argument_list|,
operator|&
name|case_force_val
argument_list|,
name|SVN_CONFIG_SECTION_GENERAL
argument_list|,
name|SVN_CONFIG_OPTION_FORCE_USERNAME_CASE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_force_val
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|case_force_val
argument_list|,
literal|"upper"
argument_list|)
operator|==
literal|0
condition|)
name|server
operator|->
name|username_case
operator|=
name|CASE_FORCE_UPPER
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|case_force_val
argument_list|,
literal|"lower"
argument_list|)
operator|==
literal|0
condition|)
name|server
operator|->
name|username_case
operator|=
name|CASE_FORCE_LOWER
expr_stmt|;
else|else
name|server
operator|->
name|username_case
operator|=
name|CASE_ASIS
expr_stmt|;
block|}
block|}
else|else
block|{
name|server
operator|->
name|authzdb
operator|=
name|NULL
expr_stmt|;
name|server
operator|->
name|username_case
operator|=
name|CASE_ASIS
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *FS_PATH to the portion of URL that is the path within the    repository, if URL is inside REPOS_URL (if URL is not inside    REPOS_URL, then error, with the effect on *FS_PATH undefined).     If the resultant fs path would be the empty string (i.e., URL and    REPOS_URL are the same), then set *FS_PATH to "/".     Assume that REPOS_URL and URL are already URI-decoded. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_fs_path
parameter_list|(
specifier|const
name|char
modifier|*
name|repos_url
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fs_path
parameter_list|)
block|{
name|apr_size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|repos_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|url
argument_list|,
name|repos_url
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not the same repository as '%s'"
argument_list|,
name|url
argument_list|,
name|repos_url
argument_list|)
return|;
operator|*
name|fs_path
operator|=
name|url
operator|+
name|len
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|*
name|fs_path
condition|)
operator|*
name|fs_path
operator|=
literal|"/"
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- AUTHENTICATION AND AUTHORIZATION FUNCTIONS --- */
end_comment

begin_comment
comment|/* Convert TEXT to upper case if TO_UPPERCASE is TRUE, else    converts it to lower case. */
end_comment

begin_function
specifier|static
name|void
name|convert_case
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|svn_boolean_t
name|to_uppercase
parameter_list|)
block|{
name|char
modifier|*
name|c
init|=
name|text
decl_stmt|;
while|while
condition|(
operator|*
name|c
condition|)
block|{
operator|*
name|c
operator|=
call|(
name|char
call|)
argument_list|(
name|to_uppercase
condition|?
name|apr_toupper
argument_list|(
operator|*
name|c
argument_list|)
else|:
name|apr_tolower
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set *ALLOWED to TRUE if PATH is accessible in the REQUIRED mode to    the user described in BATON according to the authz rules in BATON.    Use POOL for temporary allocations only.  If no authz rules are    present in BATON, grant access by default. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|authz_check_access
parameter_list|(
name|svn_boolean_t
modifier|*
name|allowed
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_repos_authz_access_t
name|required
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* If authz cannot be performed, grant access.  This is NOT the same      as the default policy when authz is performed on a path with no      rules.  In the latter case, the default is to deny access, and is      set by svn_repos_authz_check_access. */
if|if
condition|(
operator|!
name|b
operator|->
name|authzdb
condition|)
block|{
operator|*
name|allowed
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If the authz request is for the empty path (ie. ""), replace it      with the root path.  This happens because of stripping done at      various levels in svnserve that remove the leading / on an      absolute path. Passing such a malformed path to the authz      routines throws them into an infinite loop and makes them miss      ACLs. */
if|if
condition|(
name|path
condition|)
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we have a username, and we've not yet used it + any username      case normalization that might be requested to determine "the      username we used for authz purposes", do so now. */
if|if
condition|(
name|b
operator|->
name|user
operator|&&
operator|(
operator|!
name|b
operator|->
name|authz_user
operator|)
condition|)
block|{
name|char
modifier|*
name|authz_user
init|=
name|apr_pstrdup
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|b
operator|->
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|username_case
operator|==
name|CASE_FORCE_UPPER
condition|)
name|convert_case
argument_list|(
name|authz_user
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|username_case
operator|==
name|CASE_FORCE_LOWER
condition|)
name|convert_case
argument_list|(
name|authz_user
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|b
operator|->
name|authz_user
operator|=
name|authz_user
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_repos_authz_check_access
argument_list|(
name|b
operator|->
name|authzdb
argument_list|,
name|b
operator|->
name|authz_repos_name
argument_list|,
name|path
argument_list|,
name|b
operator|->
name|authz_user
argument_list|,
name|required
argument_list|,
name|allowed
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|allowed
condition|)
name|SVN_ERR
argument_list|(
name|log_authz_denied
argument_list|(
name|path
argument_list|,
name|required
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *ALLOWED to TRUE if PATH is readable by the user described in  * BATON.  Use POOL for temporary allocations only.  ROOT is not used.  * Implements the svn_repos_authz_func_t interface.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|authz_check_access_cb
parameter_list|(
name|svn_boolean_t
modifier|*
name|allowed
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|authz_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
return|return
name|authz_check_access
argument_list|(
name|allowed
argument_list|,
name|path
argument_list|,
name|svn_authz_read
argument_list|,
name|sb
operator|->
name|server
argument_list|,
name|sb
operator|->
name|conn
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If authz is enabled in the specified BATON, return a read authorization    function. Otherwise, return NULL. */
end_comment

begin_function
specifier|static
name|svn_repos_authz_func_t
name|authz_check_access_cb_func
parameter_list|(
name|server_baton_t
modifier|*
name|baton
parameter_list|)
block|{
if|if
condition|(
name|baton
operator|->
name|authzdb
condition|)
return|return
name|authz_check_access_cb
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set *ALLOWED to TRUE if the REQUIRED access to PATH is granted,  * according to the state in BATON.  Use POOL for temporary  * allocations only.  ROOT is not used.  Implements the  * svn_repos_authz_callback_t interface.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|authz_commit_cb
parameter_list|(
name|svn_repos_authz_access_t
name|required
parameter_list|,
name|svn_boolean_t
modifier|*
name|allowed
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|authz_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
return|return
name|authz_check_access
argument_list|(
name|allowed
argument_list|,
name|path
argument_list|,
name|required
argument_list|,
name|sb
operator|->
name|server
argument_list|,
name|sb
operator|->
name|conn
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|access_type
name|get_access
parameter_list|(
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|enum
name|authn_type
name|auth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|var
init|=
operator|(
name|auth
operator|==
name|AUTHENTICATED
operator|)
condition|?
name|SVN_CONFIG_OPTION_AUTH_ACCESS
else|:
name|SVN_CONFIG_OPTION_ANON_ACCESS
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|def
init|=
operator|(
name|auth
operator|==
name|AUTHENTICATED
operator|)
condition|?
literal|"write"
else|:
literal|"read"
decl_stmt|;
name|enum
name|access_type
name|result
decl_stmt|;
name|svn_config_get
argument_list|(
name|b
operator|->
name|cfg
argument_list|,
operator|&
name|val
argument_list|,
name|SVN_CONFIG_SECTION_GENERAL
argument_list|,
name|var
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"write"
argument_list|)
operator|==
literal|0
condition|?
name|WRITE_ACCESS
else|:
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"read"
argument_list|)
operator|==
literal|0
condition|?
name|READ_ACCESS
else|:
name|NO_ACCESS
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|==
name|WRITE_ACCESS
operator|&&
name|b
operator|->
name|read_only
operator|)
condition|?
name|READ_ACCESS
else|:
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|access_type
name|current_access
parameter_list|(
name|server_baton_t
modifier|*
name|b
parameter_list|)
block|{
return|return
name|get_access
argument_list|(
name|b
argument_list|,
operator|(
name|b
operator|->
name|user
operator|)
condition|?
name|AUTHENTICATED
else|:
name|UNAUTHENTICATED
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send authentication mechs for ACCESS_TYPE to the client.  If NEEDS_USERNAME    is true, don't send anonymous mech even if that would give the desired    access. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_mechs
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|enum
name|access_type
name|required
parameter_list|,
name|svn_boolean_t
name|needs_username
parameter_list|)
block|{
if|if
condition|(
operator|!
name|needs_username
operator|&&
name|get_access
argument_list|(
name|b
argument_list|,
name|UNAUTHENTICATED
argument_list|)
operator|>=
name|required
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"ANONYMOUS"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|tunnel_user
operator|&&
name|get_access
argument_list|(
name|b
argument_list|,
name|AUTHENTICATED
argument_list|)
operator|>=
name|required
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"EXTERNAL"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|pwdb
operator|&&
name|get_access
argument_list|(
name|b
argument_list|,
name|AUTHENTICATED
argument_list|)
operator|>=
name|required
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"CRAM-MD5"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Context for cleanup handler. */
end_comment

begin_struct
struct|struct
name|cleanup_fs_access_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Pool cleanup handler.  Make sure fs's access_t points to NULL when    the command pool is destroyed. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|cleanup_fs_access
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|serr
decl_stmt|;
name|struct
name|cleanup_fs_access_baton
modifier|*
name|baton
init|=
name|data
decl_stmt|;
name|serr
operator|=
name|svn_fs_set_access
argument_list|(
name|baton
operator|->
name|fs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|serr
condition|)
block|{
name|apr_status_t
name|apr_err
init|=
name|serr
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|serr
argument_list|)
expr_stmt|;
return|return
name|apr_err
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Create an svn_fs_access_t in POOL for USER and associate it with    B's filesystem.  Also, register a cleanup handler with POOL which    de-associates the svn_fs_access_t from B's filesystem. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_fs_access
parameter_list|(
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_access_t
modifier|*
name|fs_access
decl_stmt|;
name|struct
name|cleanup_fs_access_baton
modifier|*
name|cleanup_baton
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|user
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_create_access
argument_list|(
operator|&
name|fs_access
argument_list|,
name|b
operator|->
name|user
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_set_access
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|fs_access
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_baton
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cleanup_baton
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|cleanup_baton
operator|->
name|fs
operator|=
name|b
operator|->
name|fs
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|cleanup_baton
argument_list|,
name|cleanup_fs_access
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Authenticate, once the client has chosen a mechanism and possibly  * sent an initial mechanism token.  On success, set *success to true  * and b->user to the authenticated username (or NULL for anonymous).  * On authentication failure, report failure to the client and set  * *success to FALSE.  On communications failure, return an error.  * If NEEDS_USERNAME is TRUE, don't allow anonymous authentication. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auth
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|mech
parameter_list|,
specifier|const
name|char
modifier|*
name|mecharg
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|enum
name|access_type
name|required
parameter_list|,
name|svn_boolean_t
name|needs_username
parameter_list|,
name|svn_boolean_t
modifier|*
name|success
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|user
decl_stmt|;
operator|*
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|get_access
argument_list|(
name|b
argument_list|,
name|AUTHENTICATED
argument_list|)
operator|>=
name|required
operator|&&
name|b
operator|->
name|tunnel_user
operator|&&
name|strcmp
argument_list|(
name|mech
argument_list|,
literal|"EXTERNAL"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|mecharg
operator|&&
name|strcmp
argument_list|(
name|mecharg
argument_list|,
name|b
operator|->
name|tunnel_user
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(c)"
argument_list|,
literal|"failure"
argument_list|,
literal|"Requested username does not match"
argument_list|)
return|;
name|b
operator|->
name|user
operator|=
name|b
operator|->
name|tunnel_user
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w()"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|success
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|get_access
argument_list|(
name|b
argument_list|,
name|UNAUTHENTICATED
argument_list|)
operator|>=
name|required
operator|&&
name|strcmp
argument_list|(
name|mech
argument_list|,
literal|"ANONYMOUS"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|needs_username
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w()"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|success
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|get_access
argument_list|(
name|b
argument_list|,
name|AUTHENTICATED
argument_list|)
operator|>=
name|required
operator|&&
name|b
operator|->
name|pwdb
operator|&&
name|strcmp
argument_list|(
name|mech
argument_list|,
literal|"CRAM-MD5"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn_cram_server
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|pwdb
argument_list|,
operator|&
name|user
argument_list|,
name|success
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|user
operator|=
name|apr_pstrdup
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(c)"
argument_list|,
literal|"failure"
argument_list|,
literal|"Must authenticate with listed mechanism"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform an authentication request using the built-in SASL implementation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|internal_auth_request
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|enum
name|access_type
name|required
parameter_list|,
name|svn_boolean_t
name|needs_username
parameter_list|)
block|{
name|svn_boolean_t
name|success
decl_stmt|;
specifier|const
name|char
modifier|*
name|mech
decl_stmt|,
modifier|*
name|mecharg
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w((!"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|send_mechs
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|required
argument_list|,
name|needs_username
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)c)"
argument_list|,
name|b
operator|->
name|realm
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(?c)"
argument_list|,
operator|&
name|mech
argument_list|,
operator|&
name|mecharg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|mech
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|auth
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|mech
argument_list|,
name|mecharg
argument_list|,
name|b
argument_list|,
name|required
argument_list|,
name|needs_username
argument_list|,
operator|&
name|success
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|success
condition|)
do|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform an authentication request in order to get an access level of  * REQUIRED or higher.  Since the client may escape the authentication  * exchange, the caller should check current_access(b) to see if  * authentication succeeded. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auth_request
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|enum
name|access_type
name|required
parameter_list|,
name|svn_boolean_t
name|needs_username
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
if|if
condition|(
name|b
operator|->
name|use_sasl
condition|)
return|return
name|cyrus_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|required
argument_list|,
name|needs_username
argument_list|)
return|;
endif|#
directive|endif
return|return
name|internal_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|required
argument_list|,
name|needs_username
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send a trivial auth notification on CONN which lists no mechanisms,  * indicating that authentication is unnecessary.  Usually called in  * response to invocation of a svnserve command.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|trivial_auth_request
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|)
block|{
return|return
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"()c"
argument_list|,
literal|""
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ensure that the client has the REQUIRED access by checking the  * access directives (both blanket and per-directory) in BATON.  If  * PATH is NULL, then only the blanket access configuration will  * impact the result.  *  * If NEEDS_USERNAME is TRUE, then a lookup is only successful if the  * user described in BATON is authenticated and, well, has a username  * assigned to him.  *  * Use POOL for temporary allocations only.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|lookup_access
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|server_baton_t
modifier|*
name|baton
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|svn_repos_authz_access_t
name|required
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|needs_username
parameter_list|)
block|{
name|enum
name|access_type
name|req
init|=
operator|(
name|required
operator|&
name|svn_authz_write
operator|)
condition|?
name|WRITE_ACCESS
else|:
name|READ_ACCESS
decl_stmt|;
name|svn_boolean_t
name|authorized
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Get authz's opinion on the access. */
name|err
operator|=
name|authz_check_access
argument_list|(
operator|&
name|authorized
argument_list|,
name|path
argument_list|,
name|required
argument_list|,
name|baton
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If an error made lookup fail, deny access. */
if|if
condition|(
name|err
condition|)
block|{
name|log_server_error
argument_list|(
name|err
argument_list|,
name|baton
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If the required access is blanket-granted AND granted by authz      AND we already have a username if one is required, then the      lookup has succeeded. */
if|if
condition|(
name|current_access
argument_list|(
name|baton
argument_list|)
operator|>=
name|req
operator|&&
name|authorized
operator|&&
operator|(
operator|!
name|needs_username
operator|||
name|baton
operator|->
name|user
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Check that the client has the REQUIRED access by consulting the  * authentication and authorization states stored in BATON.  If the  * client does not have the required access credentials, attempt to  * authenticate the client to get that access, using CONN for  * communication.  *  * This function is supposed to be called to handle the authentication  * half of a standard svn protocol reply.  If an error is returned, it  * probably means that the server can terminate the client connection  * with an apologetic error, as it implies an authentication failure.  *  * PATH and NEEDS_USERNAME are passed along to lookup_access, their  * behaviour is documented there.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|must_have_access
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|svn_repos_authz_access_t
name|required
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|needs_username
parameter_list|)
block|{
name|enum
name|access_type
name|req
init|=
operator|(
name|required
operator|&
name|svn_authz_write
operator|)
condition|?
name|WRITE_ACCESS
else|:
name|READ_ACCESS
decl_stmt|;
comment|/* See whether the user already has the required access.  If so,      nothing needs to be done.  Create the FS access and send a      trivial auth request. */
if|if
condition|(
name|lookup_access
argument_list|(
name|pool
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|required
argument_list|,
name|path
argument_list|,
name|needs_username
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|create_fs_access
argument_list|(
name|b
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
return|;
block|}
comment|/* If the required blanket access can be obtained by authenticating,      try that.  Unfortunately, we can't tell until after      authentication whether authz will work or not.  We force      requiring a username because we need one to be able to check      authz configuration again with a different user credentials than      the first time round. */
if|if
condition|(
name|b
operator|->
name|user
operator|==
name|NULL
operator|&&
name|get_access
argument_list|(
name|b
argument_list|,
name|AUTHENTICATED
argument_list|)
operator|>=
name|req
operator|&&
operator|(
name|b
operator|->
name|tunnel_user
operator|||
name|b
operator|->
name|pwdb
operator|||
name|b
operator|->
name|use_sasl
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|req
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now that an authentication has been done get the new take of      authz on the request. */
if|if
condition|(
operator|!
name|lookup_access
argument_list|(
name|pool
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|required
argument_list|,
name|path
argument_list|,
name|needs_username
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_CMD_ERR
argument_list|,
name|error_create_and_log
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Else, access is granted, and there is much rejoicing. */
name|SVN_ERR
argument_list|(
name|create_fs_access
argument_list|(
name|b
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- REPORTER COMMAND SET --- */
end_comment

begin_comment
comment|/* To allow for pipelining, reporter commands have no reponses.  If we  * get an error, we ignore all subsequent reporter commands and return  * the error finish_report, to be handled by the calling command.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_path
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|report_driver_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|lock_token
decl_stmt|,
modifier|*
name|depth_word
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
comment|/* Default to infinity, for old clients that don't send depth. */
name|svn_depth_t
name|depth
init|=
name|svn_depth_infinity
decl_stmt|;
name|svn_boolean_t
name|start_empty
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"crb?(?c)?w"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|start_empty
argument_list|,
operator|&
name|lock_token
argument_list|,
operator|&
name|depth_word
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_word
condition|)
name|depth
operator|=
name|svn_depth_from_word
argument_list|(
name|depth_word
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|from_rev
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|b
operator|->
name|from_rev
operator|=
name|rev
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|err
condition|)
name|b
operator|->
name|err
operator|=
name|svn_repos_set_path3
argument_list|(
name|b
operator|->
name|report_baton
argument_list|,
name|path
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|entry_counter
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|start_empty
condition|)
name|b
operator|->
name|only_empty_entries
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_path
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|report_driver_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c"
argument_list|,
operator|&
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|err
condition|)
name|b
operator|->
name|err
operator|=
name|svn_repos_delete_path
argument_list|(
name|b
operator|->
name|report_baton
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|link_path
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|report_driver_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|url
decl_stmt|,
modifier|*
name|lock_token
decl_stmt|,
modifier|*
name|fs_path
decl_stmt|,
modifier|*
name|depth_word
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|svn_boolean_t
name|start_empty
decl_stmt|;
comment|/* Default to infinity, for old clients that don't send depth. */
name|svn_depth_t
name|depth
init|=
name|svn_depth_infinity
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"ccrb?(?c)?w"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|url
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|start_empty
argument_list|,
operator|&
name|lock_token
argument_list|,
operator|&
name|depth_word
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### WHAT?!  The link path is an absolute URL?!  Didn't see that      coming...   -- cmpilato  */
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_word
condition|)
name|depth
operator|=
name|svn_depth_from_word
argument_list|(
name|depth_word
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|err
condition|)
name|b
operator|->
name|err
operator|=
name|get_fs_path
argument_list|(
name|svn_path_uri_decode
argument_list|(
name|b
operator|->
name|repos_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_path_uri_decode
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|fs_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|err
condition|)
name|b
operator|->
name|err
operator|=
name|svn_repos_link_path3
argument_list|(
name|b
operator|->
name|report_baton
argument_list|,
name|path
argument_list|,
name|fs_path
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|entry_counter
operator|++
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|finish_report
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|report_driver_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* No arguments to parse. */
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|err
condition|)
name|b
operator|->
name|err
operator|=
name|svn_repos_finish_report
argument_list|(
name|b
operator|->
name|report_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_report
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|report_driver_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* No arguments to parse. */
name|svn_error_clear
argument_list|(
name|svn_repos_abort_report
argument_list|(
name|b
operator|->
name|report_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_svn_cmd_entry_t
name|report_commands
index|[]
init|=
block|{
block|{
literal|"set-path"
block|,
name|set_path
block|}
block|,
block|{
literal|"delete-path"
block|,
name|delete_path
block|}
block|,
block|{
literal|"link-path"
block|,
name|link_path
block|}
block|,
block|{
literal|"finish-report"
block|,
name|finish_report
block|,
name|TRUE
block|}
block|,
block|{
literal|"abort-report"
block|,
name|abort_report
block|,
name|TRUE
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Accept a report from the client, drive the network editor with the  * result, and then write an empty command response.  If there is a  * non-protocol failure, accept_report will abort the edit and return  * a command error to be reported by handle_commands().  *  * If only_empty_entry is not NULL and the report contains only one  * item, and that item is empty, set *only_empty_entry to TRUE, else  * set it to FALSE.  *  * If from_rev is not NULL, set *from_rev to the revision number from  * the set-path on ""; if somehow set-path "" never happens, set  * *from_rev to SVN_INVALID_REVNUM.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|accept_report
parameter_list|(
name|svn_boolean_t
modifier|*
name|only_empty_entry
parameter_list|,
name|svn_revnum_t
modifier|*
name|from_rev
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|tgt_path
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|,
modifier|*
name|report_baton
decl_stmt|;
name|report_driver_baton_t
name|rb
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
comment|/* Make an svn_repos report baton.  Tell it to drive the network editor    * when the report is complete. */
name|svn_ra_svn_get_editor
argument_list|(
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_begin_report3
argument_list|(
operator|&
name|report_baton
argument_list|,
name|rev
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|target
argument_list|,
name|tgt_path
argument_list|,
name|text_deltas
argument_list|,
name|depth
argument_list|,
name|ignore_ancestry
argument_list|,
name|send_copyfrom_args
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|svn_ra_svn_zero_copy_limit
argument_list|(
name|conn
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|.
name|sb
operator|=
name|b
expr_stmt|;
name|rb
operator|.
name|repos_url
operator|=
name|svn_path_uri_decode
argument_list|(
name|b
operator|->
name|repos_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|rb
operator|.
name|report_baton
operator|=
name|report_baton
expr_stmt|;
name|rb
operator|.
name|err
operator|=
name|NULL
expr_stmt|;
name|rb
operator|.
name|entry_counter
operator|=
literal|0
expr_stmt|;
name|rb
operator|.
name|only_empty_entries
operator|=
name|TRUE
expr_stmt|;
name|rb
operator|.
name|from_rev
operator|=
name|from_rev
expr_stmt|;
if|if
condition|(
name|from_rev
condition|)
operator|*
name|from_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|err
operator|=
name|svn_ra_svn__handle_commands2
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|report_commands
argument_list|,
operator|&
name|rb
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Network or protocol error while handling commands. */
name|svn_error_clear
argument_list|(
name|rb
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
elseif|else
if|if
condition|(
name|rb
operator|.
name|err
condition|)
block|{
comment|/* Some failure during the reporting or editing operations. */
name|SVN_CMD_ERR
argument_list|(
name|rb
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_empty_entry
condition|)
operator|*
name|only_empty_entry
operator|=
name|rb
operator|.
name|entry_counter
operator|==
literal|1
operator|&&
name|rb
operator|.
name|only_empty_entries
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- MAIN COMMAND SET --- */
end_comment

begin_comment
comment|/* Write out a list of property diffs.  PROPDIFFS is an array of svn_prop_t  * values. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_prop_diffs
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|propdiffs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|propdiffs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|propdiffs
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"c(?s)"
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out a lock to the client. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_lock
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cdate
decl_stmt|,
modifier|*
name|edate
decl_stmt|;
name|cdate
operator|=
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|creation_date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|edate
operator|=
name|lock
operator|->
name|expiration_date
condition|?
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|expiration_date
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"ccc(?c)c(?c)"
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|lock
operator|->
name|token
argument_list|,
name|lock
operator|->
name|owner
argument_list|,
name|lock
operator|->
name|comment
argument_list|,
name|cdate
argument_list|,
name|edate
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ### This really belongs in libsvn_repos. */
end_comment

begin_comment
comment|/* Get the explicit properties and/or inherited properties for a PATH in    ROOT, with hardcoded committed-info values. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|iprops
parameter_list|,
name|authz_baton_t
modifier|*
name|b
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Get the explicit properties. */
if|if
condition|(
name|props
condition|)
block|{
name|svn_string_t
modifier|*
name|str
decl_stmt|;
name|svn_revnum_t
name|crev
decl_stmt|;
specifier|const
name|char
modifier|*
name|cdate
decl_stmt|,
modifier|*
name|cauthor
decl_stmt|,
modifier|*
name|uuid
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
name|props
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Hardcode the values for the committed revision, date, and author. */
name|SVN_ERR
argument_list|(
name|svn_repos_get_committed_info
argument_list|(
operator|&
name|crev
argument_list|,
operator|&
name|cdate
argument_list|,
operator|&
name|cauthor
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_string_create
argument_list|(
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|crev
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|props
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|cdate
operator|)
condition|?
name|svn_string_create
argument_list|(
name|cdate
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|props
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|cauthor
operator|)
condition|?
name|svn_string_create
argument_list|(
name|cauthor
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|props
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Hardcode the values for the UUID. */
name|SVN_ERR
argument_list|(
name|svn_fs_get_uuid
argument_list|(
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
argument_list|,
operator|&
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|uuid
operator|)
condition|?
name|svn_string_create
argument_list|(
name|uuid
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|props
argument_list|,
name|SVN_PROP_ENTRY_UUID
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* Get any inherited properties the user is authorized to. */
if|if
condition|(
name|iprops
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_repos_fs_get_inherited_props
argument_list|(
name|iprops
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
operator|->
name|server
argument_list|)
argument_list|,
name|b
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set BATON->FS_PATH for the repository URL found in PARAMS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reparent
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c"
argument_list|,
operator|&
name|url
argument_list|)
argument_list|)
expr_stmt|;
name|url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|get_fs_path
argument_list|(
name|svn_path_uri_decode
argument_list|(
name|b
operator|->
name|repos_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_path_uri_decode
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|fs_path
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__reparent
argument_list|(
name|fs_path
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_set
argument_list|(
name|b
operator|->
name|fs_path
argument_list|,
name|fs_path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_latest_rev
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"get-latest-rev"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"r"
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dated_rev
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_time_t
name|tm
decl_stmt|;
specifier|const
name|char
modifier|*
name|timestr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c"
argument_list|,
operator|&
name|timestr
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"get-dated-rev %s"
argument_list|,
name|timestr
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|tm
argument_list|,
name|timestr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_dated_revision
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|tm
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"r"
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Common logic for change_rev_prop() and change_rev_prop2(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_change_rev_prop
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_write
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__change_rev_prop
argument_list|(
name|rev
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_fs_change_rev_prop4
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|rev
argument_list|,
name|b
operator|->
name|user
argument_list|,
name|name
argument_list|,
name|old_value_p
argument_list|,
name|value
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_rev_prop2
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
decl_stmt|;
name|svn_string_t
modifier|*
name|old_value
decl_stmt|;
name|svn_boolean_t
name|dont_care
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"rc(?s)(b?s)"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|dont_care
argument_list|,
operator|&
name|old_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Argument parsing. */
if|if
condition|(
name|dont_care
condition|)
name|old_value_p
operator|=
name|NULL
expr_stmt|;
else|else
name|old_value_p
operator|=
operator|(
specifier|const
name|svn_string_t
operator|*
specifier|const
operator|*
operator|)
operator|&
name|old_value
expr_stmt|;
comment|/* Input validation. */
if|if
condition|(
name|dont_care
operator|&&
name|old_value
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"'previous-value' and 'dont-care' cannot both be "
literal|"set in 'change-rev-prop2' request"
argument_list|)
expr_stmt|;
return|return
name|log_fail_and_flush
argument_list|(
name|err
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
return|;
block|}
comment|/* Do it. */
name|SVN_ERR
argument_list|(
name|do_change_rev_prop
argument_list|(
name|conn
argument_list|,
name|b
argument_list|,
name|rev
argument_list|,
name|name
argument_list|,
name|old_value_p
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_rev_prop
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
comment|/* Because the revprop value was at one time mandatory, the usual      optional element pattern "(?s)" isn't used. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"rc?s"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_change_rev_prop
argument_list|(
name|conn
argument_list|,
name|b
argument_list|,
name|rev
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rev_proplist
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"r"
argument_list|,
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__rev_proplist
argument_list|(
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_fs_revision_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|rev
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w((!"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rev_prop
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"rc"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__rev_prop
argument_list|(
name|rev
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_fs_revision_prop
argument_list|(
operator|&
name|value
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|rev
argument_list|,
name|name
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"(?s)"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit_done
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|commit_callback_baton_t
modifier|*
name|ccb
init|=
name|baton
decl_stmt|;
operator|*
name|ccb
operator|->
name|new_rev
operator|=
name|commit_info
operator|->
name|revision
expr_stmt|;
operator|*
name|ccb
operator|->
name|date
operator|=
name|commit_info
operator|->
name|date
condition|?
name|apr_pstrdup
argument_list|(
name|ccb
operator|->
name|pool
argument_list|,
name|commit_info
operator|->
name|date
argument_list|)
else|:
name|NULL
expr_stmt|;
operator|*
name|ccb
operator|->
name|author
operator|=
name|commit_info
operator|->
name|author
condition|?
name|apr_pstrdup
argument_list|(
name|ccb
operator|->
name|pool
argument_list|,
name|commit_info
operator|->
name|author
argument_list|)
else|:
name|NULL
expr_stmt|;
operator|*
name|ccb
operator|->
name|post_commit_err
operator|=
name|commit_info
operator|->
name|post_commit_err
condition|?
name|apr_pstrdup
argument_list|(
name|ccb
operator|->
name|pool
argument_list|,
name|commit_info
operator|->
name|post_commit_err
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add the LOCK_TOKENS (if any) to the filesystem access context,  * checking path authorizations using the state in SB as we go.  * LOCK_TOKENS is an array of svn_ra_svn_item_t structs.  Return a  * client error if LOCK_TOKENS is not a list of lists.  If a lock  * violates the authz configuration, return SVN_ERR_RA_NOT_AUTHORIZED  * to the client.  Use POOL for temporary allocations only.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_lock_tokens
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|lock_tokens
parameter_list|,
name|server_baton_t
modifier|*
name|sb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_fs_access_t
modifier|*
name|fs_access
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_access
argument_list|(
operator|&
name|fs_access
argument_list|,
name|sb
operator|->
name|fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is no access context, nowhere to add the tokens. */
if|if
condition|(
operator|!
name|fs_access
condition|)
return|return
name|SVN_NO_ERROR
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lock_tokens
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|full_path
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|path_item
decl_stmt|,
modifier|*
name|token_item
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|item
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|lock_tokens
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
literal|"Lock tokens aren't a list of lists"
argument_list|)
return|;
name|path_item
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
literal|0
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_STRING
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
literal|"Lock path isn't a string"
argument_list|)
return|;
name|token_item
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
literal|1
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|token_item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_STRING
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
literal|"Lock token isn't a string"
argument_list|)
return|;
name|path
operator|=
name|path_item
operator|->
name|u
operator|.
name|string
operator|->
name|data
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|sb
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lookup_access
argument_list|(
name|pool
argument_list|,
name|sb
argument_list|,
name|conn
argument_list|,
name|svn_authz_write
argument_list|,
name|full_path
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|error_create_and_log
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|sb
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
return|;
name|token
operator|=
name|token_item
operator|->
name|u
operator|.
name|string
operator|->
name|data
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_access_add_lock_token2
argument_list|(
name|fs_access
argument_list|,
name|path
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Unlock the paths with lock tokens in LOCK_TOKENS, ignoring any errors.    LOCK_TOKENS contains svn_ra_svn_item_t elements, assumed to be lists. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_paths
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|lock_tokens
parameter_list|,
name|server_baton_t
modifier|*
name|sb
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lock_tokens
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|item
decl_stmt|,
modifier|*
name|path_item
decl_stmt|,
modifier|*
name|token_item
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|full_path
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|item
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|lock_tokens
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
name|path_item
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
literal|0
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
name|token_item
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
literal|1
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
name|path
operator|=
name|path_item
operator|->
name|u
operator|.
name|string
operator|->
name|data
expr_stmt|;
name|token
operator|=
name|token_item
operator|->
name|u
operator|.
name|string
operator|->
name|data
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|sb
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* The lock may have become defunct after the commit, so ignore such          errors. */
name|err
operator|=
name|svn_repos_fs_unlock
argument_list|(
name|sb
operator|->
name|repos
argument_list|,
name|full_path
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|log_server_error
argument_list|(
name|err
argument_list|,
name|sb
argument_list|,
name|conn
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|log_msg
init|=
name|NULL
decl_stmt|,
modifier|*
name|date
init|=
name|NULL
decl_stmt|,
modifier|*
name|author
init|=
name|NULL
decl_stmt|,
modifier|*
name|post_commit_err
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|lock_tokens
decl_stmt|;
name|svn_boolean_t
name|keep_locks
decl_stmt|;
name|apr_array_header_t
modifier|*
name|revprop_list
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|revprop_table
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|svn_boolean_t
name|aborted
decl_stmt|;
name|commit_callback_baton_t
name|ccb
decl_stmt|;
name|svn_revnum_t
name|new_rev
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
comment|/* Clients before 1.2 don't send lock-tokens, keep-locks,          and rev-props fields. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c"
argument_list|,
operator|&
name|log_msg
argument_list|)
argument_list|)
expr_stmt|;
name|lock_tokens
operator|=
name|NULL
expr_stmt|;
name|keep_locks
operator|=
name|TRUE
expr_stmt|;
name|revprop_list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Clients before 1.5 don't send the rev-props field. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"clb?l"
argument_list|,
operator|&
name|log_msg
argument_list|,
operator|&
name|lock_tokens
argument_list|,
operator|&
name|keep_locks
argument_list|,
operator|&
name|revprop_list
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The handling for locks is a little problematic, because the      protocol won't let us send several auth requests once one has      succeeded.  So we request write access and a username before      adding tokens (if we have any), and subsequently fail if a lock      violates authz. */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_write
argument_list|,
name|NULL
argument_list|,
operator|(
name|lock_tokens
operator|&&
name|lock_tokens
operator|->
name|nelts
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Authorize the lock tokens and give them to the FS if we got      any. */
if|if
condition|(
name|lock_tokens
operator|&&
name|lock_tokens
operator|->
name|nelts
condition|)
name|SVN_CMD_ERR
argument_list|(
name|add_lock_tokens
argument_list|(
name|conn
argument_list|,
name|lock_tokens
argument_list|,
name|b
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore LOG_MSG, per the protocol.  See ra_svn_commit(). */
if|if
condition|(
name|revprop_list
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_proplist
argument_list|(
name|revprop_list
argument_list|,
name|pool
argument_list|,
operator|&
name|revprop_table
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|revprop_table
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|svn_string_create
argument_list|(
name|log_msg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get author from the baton, making sure clients can't circumvent      the authentication via the revision props. */
name|svn_hash_sets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|b
operator|->
name|user
condition|?
name|svn_string_create
argument_list|(
name|b
operator|->
name|user
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|ccb
operator|.
name|new_rev
operator|=
operator|&
name|new_rev
expr_stmt|;
name|ccb
operator|.
name|date
operator|=
operator|&
name|date
expr_stmt|;
name|ccb
operator|.
name|author
operator|=
operator|&
name|author
expr_stmt|;
name|ccb
operator|.
name|post_commit_err
operator|=
operator|&
name|post_commit_err
expr_stmt|;
comment|/* ### Note that svn_repos_get_commit_editor5 actually wants a decoded URL. */
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_get_commit_editor5
argument_list|(
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|NULL
argument_list|,
name|svn_path_uri_decode
argument_list|(
name|b
operator|->
name|repos_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|revprop_table
argument_list|,
name|commit_done
argument_list|,
operator|&
name|ccb
argument_list|,
name|authz_commit_cb
argument_list|,
operator|&
name|ab
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn_drive_editor2
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|&
name|aborted
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aborted
condition|)
block|{
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__commit
argument_list|(
name|new_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In tunnel mode, deltify before answering the client, because          answering may cause the client to terminate the connection          and thus kill the server.  But otherwise, deltify after          answering the client, to avoid user-visible delay. */
if|if
condition|(
name|b
operator|->
name|tunnel
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_deltify_revision
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unlock the paths. */
if|if
condition|(
operator|!
name|keep_locks
operator|&&
name|lock_tokens
operator|&&
name|lock_tokens
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|unlock_paths
argument_list|(
name|lock_tokens
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"r(?c)(?c)(?c)"
argument_list|,
name|new_rev
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|post_commit_err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|tunnel
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_deltify_revision
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|full_path
decl_stmt|,
modifier|*
name|hex_digest
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
decl_stmt|;
name|svn_string_t
name|write_str
decl_stmt|;
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_boolean_t
name|want_props
decl_stmt|,
name|want_contents
decl_stmt|;
name|apr_uint64_t
name|wants_inherited_props
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|write_err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
comment|/* Parse arguments. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?r)bb?B"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|want_props
argument_list|,
operator|&
name|want_contents
argument_list|,
operator|&
name|wants_inherited_props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wants_inherited_props
operator|==
name|SVN_RA_SVN_UNSPECIFIED_NUMBER
condition|)
name|wants_inherited_props
operator|=
name|FALSE
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check authorizations */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_read
argument_list|,
name|full_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__get_file
argument_list|(
name|full_path
argument_list|,
name|rev
argument_list|,
name|want_contents
argument_list|,
name|want_props
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the properties and a stream for the contents. */
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|root
argument_list|,
name|full_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring_display
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Fetch the file's explicit and/or inherited properties if      requested.  Although the wants-iprops boolean was added to the      protocol in 1.8 a standard 1.8 client never requests iprops. */
if|if
condition|(
name|want_props
operator|||
name|wants_inherited_props
condition|)
name|SVN_CMD_ERR
argument_list|(
name|get_props
argument_list|(
name|want_props
condition|?
operator|&
name|props
else|:
name|NULL
argument_list|,
name|wants_inherited_props
condition|?
operator|&
name|inherited_props
else|:
name|NULL
argument_list|,
operator|&
name|ab
argument_list|,
name|root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_contents
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send successful command response with revision and props. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w((?c)r(!"
argument_list|,
literal|"success"
argument_list|,
name|hex_digest
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wants_inherited_props
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)(?!"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inherited_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|iprop
init|=
name|APR_ARRAY_IDX
argument_list|(
name|inherited_props
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"!(c(!"
argument_list|,
name|iprop
operator|->
name|path_or_url
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
name|iprop
operator|->
name|prop_hash
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"!))!"
argument_list|,
name|iprop
operator|->
name|path_or_url
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now send the file's contents. */
if|if
condition|(
name|want_contents
condition|)
block|{
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_stream_read
argument_list|(
name|contents
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|write_str
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|write_str
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_string
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
operator|&
name|write_str
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|err
operator|=
name|svn_stream_close
argument_list|(
name|contents
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|write_err
operator|=
name|svn_ra_svn__write_cstring
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|write_err
return|;
block|}
name|SVN_CMD_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dir
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|full_path
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|,
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|svn_boolean_t
name|want_props
decl_stmt|,
name|want_contents
decl_stmt|;
name|apr_uint64_t
name|wants_inherited_props
decl_stmt|;
name|apr_uint64_t
name|dirent_fields
decl_stmt|;
name|apr_array_header_t
modifier|*
name|dirent_fields_list
init|=
name|NULL
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|elt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?r)bb?l?B"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|want_props
argument_list|,
operator|&
name|want_contents
argument_list|,
operator|&
name|dirent_fields_list
argument_list|,
operator|&
name|wants_inherited_props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wants_inherited_props
operator|==
name|SVN_RA_SVN_UNSPECIFIED_NUMBER
condition|)
name|wants_inherited_props
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|dirent_fields_list
condition|)
block|{
name|dirent_fields
operator|=
name|SVN_DIRENT_ALL
expr_stmt|;
block|}
else|else
block|{
name|dirent_fields
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dirent_fields_list
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|elt
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|dirent_fields_list
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_WORD
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
literal|"Dirent field not a string"
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|SVN_RA_SVN_DIRENT_KIND
argument_list|,
name|elt
operator|->
name|u
operator|.
name|word
argument_list|)
operator|==
literal|0
condition|)
name|dirent_fields
operator||=
name|SVN_DIRENT_KIND
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SVN_RA_SVN_DIRENT_SIZE
argument_list|,
name|elt
operator|->
name|u
operator|.
name|word
argument_list|)
operator|==
literal|0
condition|)
name|dirent_fields
operator||=
name|SVN_DIRENT_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SVN_RA_SVN_DIRENT_HAS_PROPS
argument_list|,
name|elt
operator|->
name|u
operator|.
name|word
argument_list|)
operator|==
literal|0
condition|)
name|dirent_fields
operator||=
name|SVN_DIRENT_HAS_PROPS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SVN_RA_SVN_DIRENT_CREATED_REV
argument_list|,
name|elt
operator|->
name|u
operator|.
name|word
argument_list|)
operator|==
literal|0
condition|)
name|dirent_fields
operator||=
name|SVN_DIRENT_CREATED_REV
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SVN_RA_SVN_DIRENT_TIME
argument_list|,
name|elt
operator|->
name|u
operator|.
name|word
argument_list|)
operator|==
literal|0
condition|)
name|dirent_fields
operator||=
name|SVN_DIRENT_TIME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SVN_RA_SVN_DIRENT_LAST_AUTHOR
argument_list|,
name|elt
operator|->
name|u
operator|.
name|word
argument_list|)
operator|==
literal|0
condition|)
name|dirent_fields
operator||=
name|SVN_DIRENT_LAST_AUTHOR
expr_stmt|;
block|}
block|}
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check authorizations */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_read
argument_list|,
name|full_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__get_dir
argument_list|(
name|full_path
argument_list|,
name|rev
argument_list|,
name|want_contents
argument_list|,
name|want_props
argument_list|,
name|dirent_fields
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the root of the appropriate revision. */
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the directory's explicit and/or inherited properties if      requested.  Although the wants-iprops boolean was added to the      protocol in 1.8 a standard 1.8 client never requests iprops. */
if|if
condition|(
name|want_props
operator|||
name|wants_inherited_props
condition|)
name|SVN_CMD_ERR
argument_list|(
name|get_props
argument_list|(
name|want_props
condition|?
operator|&
name|props
else|:
name|NULL
argument_list|,
name|wants_inherited_props
condition|?
operator|&
name|inherited_props
else|:
name|NULL
argument_list|,
operator|&
name|ab
argument_list|,
name|root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Begin response ... */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(r(!"
argument_list|,
literal|"success"
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)(!"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the directory entries if requested and send them immediately. */
if|if
condition|(
name|want_contents
condition|)
block|{
comment|/* Use epoch for a placeholder for a missing date.  */
specifier|const
name|char
modifier|*
name|missing_date
init|=
name|svn_time_to_cstring
argument_list|(
literal|0
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Transform the hash table's FS entries into dirents.  This probably        * belongs in libsvn_repos. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|fsent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_path
decl_stmt|;
comment|/* The fields in the entry tuple.  */
name|svn_node_kind_t
name|entry_kind
init|=
name|svn_node_none
decl_stmt|;
name|svn_filesize_t
name|entry_size
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|has_props
init|=
name|FALSE
decl_stmt|;
comment|/* If 'created rev' was not requested, send 0.  We can't use            * SVN_INVALID_REVNUM as the tuple field is not optional.            * See the email thread on dev@, 2012-03-28, subject            * "buildbot failure in ASF Buildbot on svn-slik-w2k3-x64-ra",            *<http://svn.haxx.se/dev/archive-2012-03/0655.shtml>. */
name|svn_revnum_t
name|created_rev
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|cdate
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_author
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|file_path
operator|=
name|svn_fspath__join
argument_list|(
name|full_path
argument_list|,
name|name
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lookup_access
argument_list|(
name|subpool
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|svn_authz_read
argument_list|,
name|file_path
argument_list|,
name|FALSE
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_KIND
condition|)
name|entry_kind
operator|=
name|fsent
operator|->
name|kind
expr_stmt|;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_SIZE
condition|)
if|if
condition|(
name|entry_kind
operator|!=
name|svn_node_dir
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_file_length
argument_list|(
operator|&
name|entry_size
argument_list|,
name|root
argument_list|,
name|file_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_HAS_PROPS
condition|)
block|{
name|apr_hash_t
modifier|*
name|file_props
decl_stmt|;
comment|/* has_props */
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|file_props
argument_list|,
name|root
argument_list|,
name|file_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|has_props
operator|=
operator|(
name|apr_hash_count
argument_list|(
name|file_props
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dirent_fields
operator|&
name|SVN_DIRENT_LAST_AUTHOR
operator|)
operator|||
operator|(
name|dirent_fields
operator|&
name|SVN_DIRENT_TIME
operator|)
operator|||
operator|(
name|dirent_fields
operator|&
name|SVN_DIRENT_CREATED_REV
operator|)
condition|)
block|{
comment|/* created_rev, last_author, time */
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_get_committed_info
argument_list|(
operator|&
name|created_rev
argument_list|,
operator|&
name|cdate
argument_list|,
operator|&
name|last_author
argument_list|,
name|root
argument_list|,
name|file_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The client does not properly handle a missing CDATE. For              interoperability purposes, we must fill in some junk.               See libsvn_ra_svn/client.c:ra_svn_get_dir()  */
if|if
condition|(
name|cdate
operator|==
name|NULL
condition|)
name|cdate
operator|=
name|missing_date
expr_stmt|;
comment|/* Send the entry. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"cwnbr(?c)(?c)"
argument_list|,
name|name
argument_list|,
name|svn_node_kind_to_word
argument_list|(
name|entry_kind
argument_list|)
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|entry_size
argument_list|,
name|has_props
argument_list|,
name|created_rev
argument_list|,
name|cdate
argument_list|,
name|last_author
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wants_inherited_props
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)(?!"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inherited_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|iprop
init|=
name|APR_ARRAY_IDX
argument_list|(
name|inherited_props
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"!(c(!"
argument_list|,
name|iprop
operator|->
name|path_or_url
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
name|iprop
operator|->
name|prop_hash
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"!))!"
argument_list|,
name|iprop
operator|->
name|path_or_url
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* Finish response. */
return|return
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|full_path
decl_stmt|,
modifier|*
name|depth_word
decl_stmt|;
name|svn_boolean_t
name|recurse
decl_stmt|;
name|apr_uint64_t
name|send_copyfrom_args
decl_stmt|;
comment|/* Optional; default FALSE */
name|apr_uint64_t
name|ignore_ancestry
decl_stmt|;
comment|/* Optional; default FALSE */
comment|/* Default to unknown.  Old clients won't send depth, but we'll      handle that by converting recurse if necessary. */
name|svn_depth_t
name|depth
init|=
name|svn_depth_unknown
decl_stmt|;
name|svn_boolean_t
name|is_checkout
decl_stmt|;
comment|/* Parse the arguments. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"(?r)cb?wB?B"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|recurse
argument_list|,
operator|&
name|depth_word
argument_list|,
operator|&
name|send_copyfrom_args
argument_list|,
operator|&
name|ignore_ancestry
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_word
condition|)
name|depth
operator|=
name|svn_depth_from_word
argument_list|(
name|depth_word
argument_list|)
expr_stmt|;
else|else
name|depth
operator|=
name|SVN_DEPTH_INFINITY_OR_FILES
argument_list|(
name|recurse
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check authorization and authenticate the user if necessary. */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_read
argument_list|,
name|full_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|accept_report
argument_list|(
operator|&
name|is_checkout
argument_list|,
name|NULL
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|rev
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|depth
argument_list|,
operator|(
name|send_copyfrom_args
operator|==
name|TRUE
operator|)
comment|/* send_copyfrom_args */
argument_list|,
operator|(
name|ignore_ancestry
operator|==
name|TRUE
operator|)
comment|/* ignore_ancestry */
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_checkout
condition|)
block|{
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__checkout
argument_list|(
name|full_path
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__update
argument_list|(
name|full_path
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|send_copyfrom_args
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|switch_cmd
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|depth_word
decl_stmt|;
specifier|const
name|char
modifier|*
name|switch_url
decl_stmt|,
modifier|*
name|switch_path
decl_stmt|;
name|svn_boolean_t
name|recurse
decl_stmt|;
comment|/* Default to unknown.  Old clients won't send depth, but we'll      handle that by converting recurse if necessary. */
name|svn_depth_t
name|depth
init|=
name|svn_depth_unknown
decl_stmt|;
name|apr_uint64_t
name|send_copyfrom_args
decl_stmt|;
comment|/* Optional; default FALSE */
name|apr_uint64_t
name|ignore_ancestry
decl_stmt|;
comment|/* Optional; default TRUE */
comment|/* Parse the arguments. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"(?r)cbc?w?BB"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|recurse
argument_list|,
operator|&
name|switch_url
argument_list|,
operator|&
name|depth_word
argument_list|,
operator|&
name|send_copyfrom_args
argument_list|,
operator|&
name|ignore_ancestry
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|switch_url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|switch_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_word
condition|)
name|depth
operator|=
name|svn_depth_from_word
argument_list|(
name|depth_word
argument_list|)
expr_stmt|;
else|else
name|depth
operator|=
name|SVN_DEPTH_INFINITY_OR_FILES
argument_list|(
name|recurse
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|get_fs_path
argument_list|(
name|svn_path_uri_decode
argument_list|(
name|b
operator|->
name|repos_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_path_uri_decode
argument_list|(
name|switch_url
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|switch_path
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|full_path
init|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__switch
argument_list|(
name|full_path
argument_list|,
name|switch_path
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|accept_report
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|rev
argument_list|,
name|target
argument_list|,
name|switch_path
argument_list|,
name|TRUE
argument_list|,
name|depth
argument_list|,
operator|(
name|send_copyfrom_args
operator|==
name|TRUE
operator|)
comment|/* send_copyfrom_args */
argument_list|,
operator|(
name|ignore_ancestry
operator|!=
name|FALSE
operator|)
comment|/* ignore_ancestry */
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|status
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|depth_word
decl_stmt|;
name|svn_boolean_t
name|recurse
decl_stmt|;
comment|/* Default to unknown.  Old clients won't send depth, but we'll      handle that by converting recurse if necessary. */
name|svn_depth_t
name|depth
init|=
name|svn_depth_unknown
decl_stmt|;
comment|/* Parse the arguments. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"cb?(?r)?w"
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|recurse
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|depth_word
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_word
condition|)
name|depth
operator|=
name|svn_depth_from_word
argument_list|(
name|depth_word
argument_list|)
expr_stmt|;
else|else
name|depth
operator|=
name|SVN_DEPTH_INFINITY_OR_EMPTY
argument_list|(
name|recurse
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|full_path
init|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__status
argument_list|(
name|full_path
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|accept_report
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|rev
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|diff
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|versus_url
decl_stmt|,
modifier|*
name|versus_path
decl_stmt|,
modifier|*
name|depth_word
decl_stmt|;
name|svn_boolean_t
name|recurse
decl_stmt|,
name|ignore_ancestry
decl_stmt|;
name|svn_boolean_t
name|text_deltas
decl_stmt|;
comment|/* Default to unknown.  Old clients won't send depth, but we'll      handle that by converting recurse if necessary. */
name|svn_depth_t
name|depth
init|=
name|svn_depth_unknown
decl_stmt|;
comment|/* Parse the arguments. */
if|if
condition|(
name|params
operator|->
name|nelts
operator|==
literal|5
condition|)
block|{
comment|/* Clients before 1.4 don't send the text_deltas boolean or depth. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"(?r)cbbc"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|recurse
argument_list|,
operator|&
name|ignore_ancestry
argument_list|,
operator|&
name|versus_url
argument_list|)
argument_list|)
expr_stmt|;
name|text_deltas
operator|=
name|TRUE
expr_stmt|;
name|depth_word
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"(?r)cbbcb?w"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|recurse
argument_list|,
operator|&
name|ignore_ancestry
argument_list|,
operator|&
name|versus_url
argument_list|,
operator|&
name|text_deltas
argument_list|,
operator|&
name|depth_word
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|target
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|versus_url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|versus_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth_word
condition|)
name|depth
operator|=
name|svn_depth_from_word
argument_list|(
name|depth_word
argument_list|)
expr_stmt|;
else|else
name|depth
operator|=
name|SVN_DEPTH_INFINITY_OR_FILES
argument_list|(
name|recurse
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|get_fs_path
argument_list|(
name|svn_path_uri_decode
argument_list|(
name|b
operator|->
name|repos_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_path_uri_decode
argument_list|(
name|versus_url
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|versus_path
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|full_path
init|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|from_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|accept_report
argument_list|(
name|NULL
argument_list|,
operator|&
name|from_rev
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|rev
argument_list|,
name|target
argument_list|,
name|versus_path
argument_list|,
name|text_deltas
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|ignore_ancestry
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__diff
argument_list|(
name|full_path
argument_list|,
name|from_rev
argument_list|,
name|versus_path
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|ignore_ancestry
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Regardless of whether a client's capabilities indicate an    understanding of this command (by way of SVN_RA_SVN_CAP_MERGEINFO),    we provide a response.     ASSUMPTION: When performing a 'merge' with two URLs at different    revisions, the client will call this command more than once. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfo
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|,
modifier|*
name|canonical_paths
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|mergeinfo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|inherit_word
decl_stmt|;
name|svn_mergeinfo_inheritance_t
name|inherit
decl_stmt|;
name|svn_boolean_t
name|include_descendants
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"l(?r)wb"
argument_list|,
operator|&
name|paths
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|inherit_word
argument_list|,
operator|&
name|include_descendants
argument_list|)
argument_list|)
expr_stmt|;
name|inherit
operator|=
name|svn_inheritance_from_word
argument_list|(
name|inherit_word
argument_list|)
expr_stmt|;
comment|/* Canonicalize the paths which mergeinfo has been requested for. */
name|canonical_paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|paths
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|item
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_STRING
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path is not a string"
argument_list|)
argument_list|)
return|;
name|full_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|canonical_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|full_path
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__get_mergeinfo
argument_list|(
name|canonical_paths
argument_list|,
name|inherit
argument_list|,
name|include_descendants
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_fs_get_mergeinfo
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|canonical_paths
argument_list|,
name|rev
argument_list|,
name|inherit
argument_list|,
name|include_descendants
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__remove_prefix_from_catalog
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w((!"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|value
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|mergeinfo_string
argument_list|,
name|value
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"cs"
argument_list|,
name|key
argument_list|,
name|mergeinfo_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Send a log entry to the client. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|log_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|b
operator|->
name|conn
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|h
decl_stmt|;
name|svn_boolean_t
name|invalid_revnum
init|=
name|FALSE
decl_stmt|;
name|char
name|action
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|author
decl_stmt|,
modifier|*
name|date
decl_stmt|,
modifier|*
name|message
decl_stmt|;
name|apr_uint64_t
name|revprop_count
decl_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
comment|/* If the stack depth is zero, we've seen the last revision, so don't          send it, just return. */
if|if
condition|(
name|b
operator|->
name|stack_depth
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Because the svn protocol won't let us send an invalid revnum, we have          to fudge here and send an additional flag. */
name|log_entry
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
name|invalid_revnum
operator|=
name|TRUE
expr_stmt|;
name|b
operator|->
name|stack_depth
operator|--
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"(!"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|changed_paths2
condition|)
block|{
for|for
control|(
name|h
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|)
init|;
name|h
condition|;
name|h
operator|=
name|apr_hash_next
argument_list|(
name|h
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|svn_log_changed_path2_t
modifier|*
name|change
init|=
name|svn__apr_hash_index_val
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|action
index|[
literal|0
index|]
operator|=
name|change
operator|->
name|action
expr_stmt|;
name|action
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"cw(?cr)(cbb)"
argument_list|,
name|path
argument_list|,
name|action
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|change
operator|->
name|copyfrom_rev
argument_list|,
name|svn_node_kind_to_word
argument_list|(
name|change
operator|->
name|node_kind
argument_list|)
argument_list|,
comment|/* text_modified and props_modified are never unknown */
name|change
operator|->
name|text_modified
operator|==
name|svn_tristate_true
argument_list|,
name|change
operator|->
name|props_modified
operator|==
name|svn_tristate_true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_compat_log_revprops_out
argument_list|(
operator|&
name|author
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|message
argument_list|,
name|log_entry
operator|->
name|revprops
argument_list|)
expr_stmt|;
name|svn_compat_log_revprops_clear
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revprops
condition|)
name|revprop_count
operator|=
name|apr_hash_count
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|)
expr_stmt|;
else|else
name|revprop_count
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)r(?c)(?c)(?c)bbn(!"
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|author
argument_list|,
name|date
argument_list|,
name|message
argument_list|,
name|log_entry
operator|->
name|has_children
argument_list|,
name|invalid_revnum
argument_list|,
name|revprop_count
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|log_entry
operator|->
name|revprops
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)b"
argument_list|,
name|log_entry
operator|->
name|subtractive_merge
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|has_children
condition|)
name|b
operator|->
name|stack_depth
operator|++
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_cmd
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|write_err
decl_stmt|;
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|svn_boolean_t
name|send_changed_paths
decl_stmt|,
name|strict_node
decl_stmt|,
name|include_merged_revisions
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|,
modifier|*
name|full_paths
decl_stmt|,
modifier|*
name|revprop_items
decl_stmt|,
modifier|*
name|revprops
decl_stmt|;
name|char
modifier|*
name|revprop_word
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|elt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_uint64_t
name|limit
decl_stmt|,
name|include_merged_revs_param
decl_stmt|;
name|log_baton_t
name|lb
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"l(?r)(?r)bb?n?Bwl"
argument_list|,
operator|&
name|paths
argument_list|,
operator|&
name|start_rev
argument_list|,
operator|&
name|end_rev
argument_list|,
operator|&
name|send_changed_paths
argument_list|,
operator|&
name|strict_node
argument_list|,
operator|&
name|limit
argument_list|,
operator|&
name|include_merged_revs_param
argument_list|,
operator|&
name|revprop_word
argument_list|,
operator|&
name|revprop_items
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_merged_revs_param
operator|==
name|SVN_RA_SVN_UNSPECIFIED_NUMBER
condition|)
name|include_merged_revisions
operator|=
name|FALSE
expr_stmt|;
else|else
name|include_merged_revisions
operator|=
operator|(
name|svn_boolean_t
operator|)
name|include_merged_revs_param
expr_stmt|;
if|if
condition|(
name|revprop_word
operator|==
name|NULL
condition|)
comment|/* pre-1.5 client */
name|revprops
operator|=
name|svn_compat_log_revprops_in
argument_list|(
name|pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|revprop_word
argument_list|,
literal|"all-revprops"
argument_list|)
operator|==
literal|0
condition|)
name|revprops
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|revprop_word
argument_list|,
literal|"revprops"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|revprop_items
argument_list|)
expr_stmt|;
name|revprops
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|revprop_items
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revprop_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|elt
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|revprop_items
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_STRING
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Log revprop entry not a string"
argument_list|)
argument_list|)
return|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|elt
operator|->
name|u
operator|.
name|string
operator|->
name|data
expr_stmt|;
block|}
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown revprop word '%s' in log command"
argument_list|)
argument_list|,
name|revprop_word
argument_list|)
return|;
comment|/* If we got an unspecified number then the user didn't send us anything,      so we assume no limit.  If it's larger than INT_MAX then someone is      messing with us, since we know the svn client libraries will never send      us anything that big, so play it safe and default to no limit. */
if|if
condition|(
name|limit
operator|==
name|SVN_RA_SVN_UNSPECIFIED_NUMBER
operator|||
name|limit
operator|>
name|INT_MAX
condition|)
name|limit
operator|=
literal|0
expr_stmt|;
name|full_paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|paths
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|elt
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_STRING
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Log path entry not a string"
argument_list|)
argument_list|)
return|;
name|full_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|elt
operator|->
name|u
operator|.
name|string
operator|->
name|data
argument_list|,
name|pool
argument_list|)
operator|,
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|full_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|full_path
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__log
argument_list|(
name|full_paths
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
operator|(
name|int
operator|)
name|limit
argument_list|,
name|send_changed_paths
argument_list|,
name|strict_node
argument_list|,
name|include_merged_revisions
argument_list|,
name|revprops
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get logs.  (Can't report errors back to the client at this point.) */
name|lb
operator|.
name|fs_path
operator|=
name|b
operator|->
name|fs_path
operator|->
name|data
expr_stmt|;
name|lb
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|lb
operator|.
name|stack_depth
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|svn_repos_get_logs4
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|full_paths
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
operator|(
name|int
operator|)
name|limit
argument_list|,
name|send_changed_paths
argument_list|,
name|strict_node
argument_list|,
name|include_merged_revisions
argument_list|,
name|revprops
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|log_receiver
argument_list|,
operator|&
name|lb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|write_err
operator|=
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|write_err
return|;
block|}
name|SVN_CMD_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_path
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|full_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?r)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check authorizations */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_read
argument_list|,
name|full_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"check-path %s@%d"
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w"
argument_list|,
name|svn_node_kind_to_word
argument_list|(
name|kind
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stat_cmd
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|full_path
decl_stmt|,
modifier|*
name|cdate
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_dirent_t
modifier|*
name|dirent
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?r)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check authorizations */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_read
argument_list|,
name|full_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"stat %s@%d"
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_stat
argument_list|(
operator|&
name|dirent
argument_list|,
name|root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Need to return the equivalent of "(?l)", since that's what the      client is reading.  */
if|if
condition|(
name|dirent
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"()"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|cdate
operator|=
operator|(
name|dirent
operator|->
name|time
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
operator|)
condition|?
name|NULL
else|:
name|svn_time_to_cstring
argument_list|(
name|dirent
operator|->
name|time
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"((wnbr(?c)(?c)))"
argument_list|,
name|svn_node_kind_to_word
argument_list|(
name|dirent
operator|->
name|kind
argument_list|)
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|dirent
operator|->
name|size
argument_list|,
name|dirent
operator|->
name|has_props
argument_list|,
name|dirent
operator|->
name|created_rev
argument_list|,
name|cdate
argument_list|,
name|dirent
operator|->
name|last_author
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_locations
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|write_err
decl_stmt|;
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|apr_array_header_t
modifier|*
name|location_revisions
decl_stmt|,
modifier|*
name|loc_revs_proto
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|elt
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|relative_path
decl_stmt|;
name|svn_revnum_t
name|peg_revision
decl_stmt|;
name|apr_hash_t
modifier|*
name|fs_locations
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
comment|/* Parse the arguments. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"crl"
argument_list|,
operator|&
name|relative_path
argument_list|,
operator|&
name|peg_revision
argument_list|,
operator|&
name|loc_revs_proto
argument_list|)
argument_list|)
expr_stmt|;
name|relative_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|relative_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|abs_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|relative_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|location_revisions
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|loc_revs_proto
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loc_revs_proto
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|elt
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|loc_revs_proto
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_NUMBER
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
literal|"Get-locations location revisions entry "
literal|"not a revision number"
argument_list|)
return|;
name|revision
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|elt
operator|->
name|u
operator|.
name|number
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|location_revisions
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|revision
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__get_locations
argument_list|(
name|abs_path
argument_list|,
name|peg_revision
argument_list|,
name|location_revisions
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All the parameters are fine - let's perform the query against the    * repository. */
comment|/* We store both err and write_err here, so the client will get    * the "done" even if there was an error in fetching the results. */
name|err
operator|=
name|svn_repos_trace_node_locations
argument_list|(
name|b
operator|->
name|fs
argument_list|,
operator|&
name|fs_locations
argument_list|,
name|abs_path
argument_list|,
name|peg_revision
argument_list|,
name|location_revisions
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Now, write the results to the connection. */
if|if
condition|(
operator|!
name|err
condition|)
block|{
if|if
condition|(
name|fs_locations
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|iter
decl_stmt|;
for|for
control|(
name|iter
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|fs_locations
argument_list|)
init|;
name|iter
condition|;
name|iter
operator|=
name|apr_hash_next
argument_list|(
name|iter
argument_list|)
control|)
block|{
specifier|const
name|svn_revnum_t
modifier|*
name|iter_key
init|=
name|svn__apr_hash_index_key
argument_list|(
name|iter
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|iter_value
init|=
name|svn__apr_hash_index_val
argument_list|(
name|iter
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"rc"
argument_list|,
operator|*
name|iter_key
argument_list|,
name|iter_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|write_err
operator|=
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|write_err
return|;
block|}
name|SVN_CMD_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|gls_receiver
parameter_list|(
name|svn_location_segment_t
modifier|*
name|segment
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|baton
decl_stmt|;
return|return
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"rr(?c)"
argument_list|,
name|segment
operator|->
name|range_start
argument_list|,
name|segment
operator|->
name|range_end
argument_list|,
name|segment
operator|->
name|path
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_location_segments
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|write_err
decl_stmt|;
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_revnum_t
name|peg_revision
decl_stmt|,
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|relative_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
comment|/* Parse the arguments. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?r)(?r)(?r)"
argument_list|,
operator|&
name|relative_path
argument_list|,
operator|&
name|peg_revision
argument_list|,
operator|&
name|start_rev
argument_list|,
operator|&
name|end_rev
argument_list|)
argument_list|)
expr_stmt|;
name|relative_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|relative_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|abs_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|relative_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
operator|&&
operator|(
name|end_rev
operator|>
name|start_rev
operator|)
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"Get-location-segments end revision must not be "
literal|"younger than start revision"
argument_list|)
expr_stmt|;
return|return
name|log_fail_and_flush
argument_list|(
name|err
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
return|;
block|}
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|peg_revision
argument_list|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
operator|&&
operator|(
name|start_rev
operator|>
name|peg_revision
operator|)
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"Get-location-segments start revision must not "
literal|"be younger than peg revision"
argument_list|)
expr_stmt|;
return|return
name|log_fail_and_flush
argument_list|(
name|err
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|baton
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__get_location_segments
argument_list|(
name|abs_path
argument_list|,
name|peg_revision
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All the parameters are fine - let's perform the query against the    * repository. */
comment|/* We store both err and write_err here, so the client will get    * the "done" even if there was an error in fetching the results. */
name|err
operator|=
name|svn_repos_node_location_segments
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|abs_path
argument_list|,
name|peg_revision
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|gls_receiver
argument_list|,
operator|(
name|void
operator|*
operator|)
name|conn
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|write_err
operator|=
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|write_err
return|;
block|}
name|SVN_CMD_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_write_fn_t.  Write LEN bytes starting at DATA to the    client as a string. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svndiff_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|file_revs_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_string_t
name|str
decl_stmt|;
name|str
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|str
operator|.
name|len
operator|=
operator|*
name|len
expr_stmt|;
return|return
name|svn_ra_svn__write_string
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|b
operator|->
name|pool
argument_list|,
operator|&
name|str
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_close_fn_t.  Mark the end of the data by writing an    empty string to the client. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svndiff_close_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|file_revs_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cstring
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|b
operator|->
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements the svn_repos_file_rev_handler_t interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_rev_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|svn_boolean_t
name|merged_revision
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|d_handler
parameter_list|,
name|void
modifier|*
modifier|*
name|d_baton
parameter_list|,
name|apr_array_header_t
modifier|*
name|prop_diffs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|file_revs_baton_t
modifier|*
name|frb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|frb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|"cr(!"
argument_list|,
name|path
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|frb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|rev_props
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|frb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)(!"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_prop_diffs
argument_list|(
name|frb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|prop_diffs
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|frb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)b"
argument_list|,
name|merged_revision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the pool for the delta stream. */
name|frb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Prepare for the delta or just write an empty string. */
if|if
condition|(
name|d_handler
condition|)
block|{
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|svndiff_handler
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|svndiff_close_handler
argument_list|)
expr_stmt|;
comment|/* If the connection does not support SVNDIFF1 or if we don't want to use        * compression, use the non-compressing "version 0" implementation */
if|if
condition|(
name|svn_ra_svn_compression_level
argument_list|(
name|frb
operator|->
name|conn
argument_list|)
operator|>
literal|0
operator|&&
name|svn_ra_svn_has_capability
argument_list|(
name|frb
operator|->
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_SVNDIFF1
argument_list|)
condition|)
name|svn_txdelta_to_svndiff3
argument_list|(
name|d_handler
argument_list|,
name|d_baton
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|,
name|svn_ra_svn_compression_level
argument_list|(
name|frb
operator|->
name|conn
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_txdelta_to_svndiff3
argument_list|(
name|d_handler
argument_list|,
name|d_baton
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|svn_ra_svn_compression_level
argument_list|(
name|frb
operator|->
name|conn
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cstring
argument_list|(
name|frb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_revs
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|write_err
decl_stmt|;
name|file_revs_baton_t
name|frb
decl_stmt|;
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|apr_uint64_t
name|include_merged_revs_param
decl_stmt|;
name|svn_boolean_t
name|include_merged_revisions
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
comment|/* Parse arguments. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?r)(?r)?B"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|start_rev
argument_list|,
operator|&
name|end_rev
argument_list|,
operator|&
name|include_merged_revs_param
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_merged_revs_param
operator|==
name|SVN_RA_SVN_UNSPECIFIED_NUMBER
condition|)
name|include_merged_revisions
operator|=
name|FALSE
expr_stmt|;
else|else
name|include_merged_revisions
operator|=
operator|(
name|svn_boolean_t
operator|)
name|include_merged_revs_param
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__get_file_revs
argument_list|(
name|full_path
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|include_merged_revisions
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|frb
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|frb
operator|.
name|pool
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|svn_repos_get_file_revs2
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|full_path
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|include_merged_revisions
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|file_rev_handler
argument_list|,
operator|&
name|frb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|write_err
operator|=
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|write_err
return|;
block|}
name|SVN_CMD_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lock
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|svn_boolean_t
name|steal_lock
decl_stmt|;
name|svn_revnum_t
name|current_rev
decl_stmt|;
name|svn_lock_t
modifier|*
name|l
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?c)b(?r)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|comment
argument_list|,
operator|&
name|steal_lock
argument_list|,
operator|&
name|current_rev
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_write
argument_list|,
name|full_path
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__lock_one_path
argument_list|(
name|full_path
argument_list|,
name|steal_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_fs_lock
argument_list|(
operator|&
name|l
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|full_path
argument_list|,
name|NULL
argument_list|,
name|comment
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* No expiration time. */
name|current_rev
argument_list|,
name|steal_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(!"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_lock
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lock_many
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|path_revs
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|svn_boolean_t
name|steal_lock
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|svn_revnum_t
name|current_rev
decl_stmt|;
name|apr_array_header_t
modifier|*
name|log_paths
decl_stmt|;
name|svn_lock_t
modifier|*
name|l
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|,
modifier|*
name|write_err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"(?c)bl"
argument_list|,
operator|&
name|comment
argument_list|,
operator|&
name|steal_lock
argument_list|,
operator|&
name|path_revs
argument_list|)
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Because we can only send a single auth reply per request, we send      a reply before parsing the lock commands.  This means an authz      access denial will abort the processing of the locks and return      an error. */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_write
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop through the lock requests. */
name|log_paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|path_revs
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|full_path
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_revs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|item
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|path_revs
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
literal|"Lock requests should be list of lists"
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
name|pool
argument_list|,
literal|"c(?r)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|current_rev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the full_path out of pool so it will survive for use        * by operational logging, after this loop. */
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|log_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|full_path
expr_stmt|;
if|if
condition|(
operator|!
name|lookup_access
argument_list|(
name|pool
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|svn_authz_write
argument_list|,
name|full_path
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|err
operator|=
name|error_create_and_log
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|svn_repos_fs_lock
argument_list|(
operator|&
name|l
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|full_path
argument_list|,
name|NULL
argument_list|,
name|comment
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
comment|/* No expiration time. */
name|current_rev
argument_list|,
name|steal_lock
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|SVN_ERR_IS_LOCK_ERROR
argument_list|(
name|err
argument_list|)
condition|)
block|{
name|write_err
operator|=
name|svn_ra_svn__write_cmd_failure
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_err
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|subpool
argument_list|,
literal|"w!"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_lock
argument_list|(
name|conn
argument_list|,
name|subpool
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|subpool
argument_list|,
literal|"!"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__lock
argument_list|(
name|log_paths
argument_list|,
name|steal_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: err might contain a fatal locking error from the loop above. */
name|write_err
operator|=
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"done"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|write_err
condition|)
name|SVN_CMD_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|full_path
decl_stmt|;
name|svn_boolean_t
name|break_lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?c)b"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|break_lock
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Username required unless break_lock was specified. */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_write
argument_list|,
name|full_path
argument_list|,
operator|!
name|break_lock
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__unlock_one_path
argument_list|(
name|full_path
argument_list|,
name|break_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_fs_unlock
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|full_path
argument_list|,
name|token
argument_list|,
name|break_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_many
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_boolean_t
name|break_lock
decl_stmt|;
name|apr_array_header_t
modifier|*
name|unlock_tokens
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|apr_array_header_t
modifier|*
name|log_paths
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|,
modifier|*
name|write_err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"bl"
argument_list|,
operator|&
name|break_lock
argument_list|,
operator|&
name|unlock_tokens
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Username required unless break_lock was specified. */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_write
argument_list|,
name|NULL
argument_list|,
operator|!
name|break_lock
argument_list|)
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Loop through the unlock requests. */
name|log_paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|unlock_tokens
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|full_path
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unlock_tokens
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|item
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|unlock_tokens
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
literal|"Unlock request should be a list of lists"
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
name|subpool
argument_list|,
literal|"c(?c)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|token
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the full_path out of pool so it will survive for use        * by operational logging, after this loop. */
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|log_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|full_path
expr_stmt|;
if|if
condition|(
operator|!
name|lookup_access
argument_list|(
name|subpool
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|svn_authz_write
argument_list|,
name|full_path
argument_list|,
operator|!
name|break_lock
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_CMD_ERR
argument_list|,
name|error_create_and_log
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
name|err
operator|=
name|svn_repos_fs_unlock
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|full_path
argument_list|,
name|token
argument_list|,
name|break_lock
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|SVN_ERR_IS_UNLOCK_ERROR
argument_list|(
name|err
argument_list|)
condition|)
block|{
name|write_err
operator|=
name|svn_ra_svn__write_cmd_failure
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_err
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|subpool
argument_list|,
literal|"w(c)"
argument_list|,
literal|"success"
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__unlock
argument_list|(
name|log_paths
argument_list|,
name|break_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: err might contain a fatal unlocking error from the loop above. */
name|write_err
operator|=
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"done"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|write_err
condition|)
name|SVN_CMD_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|svn_lock_t
modifier|*
name|l
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c"
argument_list|,
operator|&
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|,
name|svn_authz_read
argument_list|,
name|full_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"get-lock %s"
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_get_lock
argument_list|(
operator|&
name|l
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w((!"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|SVN_ERR
argument_list|(
name|write_lock
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_locks
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|depth_word
decl_stmt|;
name|svn_depth_t
name|depth
decl_stmt|;
name|apr_hash_t
modifier|*
name|locks
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c?(?w)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|depth_word
argument_list|)
argument_list|)
expr_stmt|;
name|depth
operator|=
name|depth_word
condition|?
name|svn_depth_from_word
argument_list|(
name|depth_word
argument_list|)
else|:
name|svn_depth_infinity
expr_stmt|;
if|if
condition|(
operator|(
name|depth
operator|!=
name|svn_depth_empty
operator|)
operator|&&
operator|(
name|depth
operator|!=
name|svn_depth_files
operator|)
operator|&&
operator|(
name|depth
operator|!=
name|svn_depth_immediates
operator|)
operator|&&
operator|(
name|depth
operator|!=
name|svn_depth_infinity
operator|)
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"Invalid 'depth' specified in get-locks request"
argument_list|)
expr_stmt|;
return|return
name|log_fail_and_flush
argument_list|(
name|err
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
return|;
block|}
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"get-locks %s"
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_fs_get_locks2
argument_list|(
operator|&
name|locks
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|full_path
argument_list|,
name|depth
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w((!"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|locks
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_lock_t
modifier|*
name|l
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|write_lock
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_one_revision
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
name|svn_log__replay
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_svn_get_editor
argument_list|(
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_repos_replay2
argument_list|(
name|root
argument_list|,
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|low_water_mark
argument_list|,
name|send_deltas
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_ra_svn__write_cmd_finish_replay
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|svn_revnum_t
name|rev
decl_stmt|,
name|low_water_mark
decl_stmt|;
name|svn_boolean_t
name|send_deltas
decl_stmt|;
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"rrb"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|low_water_mark
argument_list|,
operator|&
name|send_deltas
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|replay_one_revision
argument_list|(
name|conn
argument_list|,
name|b
argument_list|,
name|rev
argument_list|,
name|low_water_mark
argument_list|,
name|send_deltas
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_range
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|,
name|rev
decl_stmt|,
name|low_water_mark
decl_stmt|;
name|svn_boolean_t
name|send_deltas
decl_stmt|;
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"rrrb"
argument_list|,
operator|&
name|start_rev
argument_list|,
operator|&
name|end_rev
argument_list|,
operator|&
name|low_water_mark
argument_list|,
operator|&
name|send_deltas
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|svn_repos_fs_revision_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|b
operator|->
name|repos
argument_list|,
name|rev
argument_list|,
name|authz_check_access_cb_func
argument_list|(
name|b
argument_list|)
argument_list|,
operator|&
name|ab
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"w(!"
argument_list|,
literal|"revprops"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"!)"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|replay_one_revision
argument_list|(
name|conn
argument_list|,
name|b
argument_list|,
name|rev
argument_list|,
name|low_water_mark
argument_list|,
name|send_deltas
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_deleted_rev
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|full_path
decl_stmt|;
name|svn_revnum_t
name|peg_revision
decl_stmt|;
name|svn_revnum_t
name|end_revision
decl_stmt|;
name|svn_revnum_t
name|revision_deleted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"crr"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|peg_revision
argument_list|,
operator|&
name|end_revision
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"get-deleted-rev"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|trivial_auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_deleted_rev
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|full_path
argument_list|,
name|peg_revision
argument_list|,
name|end_revision
argument_list|,
operator|&
name|revision_deleted
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"r"
argument_list|,
name|revision_deleted
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_inherited_props
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|full_path
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|authz_baton_t
name|ab
decl_stmt|;
name|ab
operator|.
name|server
operator|=
name|b
expr_stmt|;
name|ab
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
comment|/* Parse arguments. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|iterpool
argument_list|,
literal|"c(?r)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_fspath__join
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check authorizations */
name|SVN_ERR
argument_list|(
name|must_have_access
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
name|b
argument_list|,
name|svn_authz_read
argument_list|,
name|full_path
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|rev
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|svn_log__get_inherited_props
argument_list|(
name|full_path
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the properties and a stream for the contents. */
name|SVN_CMD_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|get_props
argument_list|(
name|NULL
argument_list|,
operator|&
name|inherited_props
argument_list|,
operator|&
name|ab
argument_list|,
name|root
argument_list|,
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send successful command response with revision and props. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"w(!"
argument_list|,
literal|"success"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"!(?!"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inherited_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|iprop
init|=
name|APR_ARRAY_IDX
argument_list|(
name|inherited_props
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"!(c(!"
argument_list|,
name|iprop
operator|->
name|path_or_url
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
name|iprop
operator|->
name|prop_hash
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"!))!"
argument_list|,
name|iprop
operator|->
name|path_or_url
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_svn_cmd_entry_t
name|main_commands
index|[]
init|=
block|{
block|{
literal|"reparent"
block|,
name|reparent
block|}
block|,
block|{
literal|"get-latest-rev"
block|,
name|get_latest_rev
block|}
block|,
block|{
literal|"get-dated-rev"
block|,
name|get_dated_rev
block|}
block|,
block|{
literal|"change-rev-prop"
block|,
name|change_rev_prop
block|}
block|,
block|{
literal|"change-rev-prop2"
block|,
name|change_rev_prop2
block|}
block|,
block|{
literal|"rev-proplist"
block|,
name|rev_proplist
block|}
block|,
block|{
literal|"rev-prop"
block|,
name|rev_prop
block|}
block|,
block|{
literal|"commit"
block|,
name|commit
block|}
block|,
block|{
literal|"get-file"
block|,
name|get_file
block|}
block|,
block|{
literal|"get-dir"
block|,
name|get_dir
block|}
block|,
block|{
literal|"update"
block|,
name|update
block|}
block|,
block|{
literal|"switch"
block|,
name|switch_cmd
block|}
block|,
block|{
literal|"status"
block|,
name|status
block|}
block|,
block|{
literal|"diff"
block|,
name|diff
block|}
block|,
block|{
literal|"get-mergeinfo"
block|,
name|get_mergeinfo
block|}
block|,
block|{
literal|"log"
block|,
name|log_cmd
block|}
block|,
block|{
literal|"check-path"
block|,
name|check_path
block|}
block|,
block|{
literal|"stat"
block|,
name|stat_cmd
block|}
block|,
block|{
literal|"get-locations"
block|,
name|get_locations
block|}
block|,
block|{
literal|"get-location-segments"
block|,
name|get_location_segments
block|}
block|,
block|{
literal|"get-file-revs"
block|,
name|get_file_revs
block|}
block|,
block|{
literal|"lock"
block|,
name|lock
block|}
block|,
block|{
literal|"lock-many"
block|,
name|lock_many
block|}
block|,
block|{
literal|"unlock"
block|,
name|unlock
block|}
block|,
block|{
literal|"unlock-many"
block|,
name|unlock_many
block|}
block|,
block|{
literal|"get-lock"
block|,
name|get_lock
block|}
block|,
block|{
literal|"get-locks"
block|,
name|get_locks
block|}
block|,
block|{
literal|"replay"
block|,
name|replay
block|}
block|,
block|{
literal|"replay-range"
block|,
name|replay_range
block|}
block|,
block|{
literal|"get-deleted-rev"
block|,
name|get_deleted_rev
block|}
block|,
block|{
literal|"get-iprops"
block|,
name|get_inherited_props
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Skip past the scheme part of a URL, including the tunnel specification  * if present.  Return NULL if the scheme part is invalid for ra_svn. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skip_scheme_part
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|url
argument_list|,
literal|"svn"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|url
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|url
operator|==
literal|'+'
condition|)
name|url
operator|+=
name|strcspn
argument_list|(
name|url
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|url
argument_list|,
literal|"://"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|url
operator|+
literal|3
return|;
block|}
end_function

begin_comment
comment|/* Check that PATH is a valid repository path, meaning it doesn't contain any    '..' path segments.    NOTE: This is similar to svn_path_is_backpath_present, but that function    assumes the path separator is '/'.  This function also checks for    segments delimited by the local path separator. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|repos_path_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|path
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
comment|/* Scan for the end of the segment. */
while|while
condition|(
operator|*
name|path
operator|&&
operator|*
name|path
operator|!=
literal|'/'
operator|&&
operator|*
name|path
operator|!=
name|SVN_PATH_LOCAL_SEPARATOR
condition|)
operator|++
name|path
expr_stmt|;
comment|/* Check for '..'. */
ifdef|#
directive|ifdef
name|WIN32
comment|/* On Windows, don't allow sequences of more than one character          consisting of just dots and spaces.  Win32 functions treat          paths such as ".. " and "......." inconsistently.  Make sure          no one can escape out of the root. */
if|if
condition|(
name|path
operator|-
name|s
operator|>=
literal|2
operator|&&
name|strspn
argument_list|(
name|s
argument_list|,
literal|". "
argument_list|)
operator|==
call|(
name|size_t
call|)
argument_list|(
name|path
operator|-
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
else|#
directive|else
comment|/* ! WIN32 */
if|if
condition|(
name|path
operator|-
name|s
operator|==
literal|2
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/* Skip all separators. */
while|while
condition|(
operator|*
name|path
operator|&&
operator|(
operator|*
name|path
operator|==
literal|'/'
operator|||
operator|*
name|path
operator|==
name|SVN_PATH_LOCAL_SEPARATOR
operator|)
condition|)
operator|++
name|path
expr_stmt|;
name|s
operator|=
name|path
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look for the repository given by URL, using ROOT as the virtual  * repository root.  If we find one, fill in the repos, fs, cfg,  * repos_url, and fs_path fields of B.  Set B->repos's client  * capabilities to CAPABILITIES, which must be at least as long-lived  * as POOL, and whose elements are SVN_RA_CAPABILITY_*.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_repos
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|root
parameter_list|,
name|server_baton_t
modifier|*
name|b
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|capabilities
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|full_path
decl_stmt|,
modifier|*
name|repos_root
decl_stmt|,
modifier|*
name|fs_path
decl_stmt|,
modifier|*
name|hooks_env
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|url_buf
decl_stmt|;
comment|/* Skip past the scheme and authority part. */
name|path
operator|=
name|skip_scheme_part
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"Non-svn URL passed to svn server: '%s'"
argument_list|,
name|url
argument_list|)
return|;
if|if
condition|(
operator|!
name|b
operator|->
name|vhost
condition|)
block|{
name|path
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
literal|""
expr_stmt|;
block|}
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_path_uri_decode
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Ensure that it isn't possible to escape the root by disallowing      '..' segments. */
if|if
condition|(
operator|!
name|repos_path_valid
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_FILENAME
argument_list|,
name|NULL
argument_list|,
literal|"Couldn't determine repository path"
argument_list|)
return|;
comment|/* Join the server-configured root with the client path. */
name|full_path
operator|=
name|svn_dirent_join
argument_list|(
name|svn_dirent_canonicalize
argument_list|(
name|root
argument_list|,
name|pool
argument_list|)
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Search for a repository in the full path. */
name|repos_root
operator|=
name|svn_repos_find_root_path
argument_list|(
name|full_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|repos_root
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_SVN_REPOS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
literal|"No repository found in '%s'"
argument_list|,
name|url
argument_list|)
return|;
comment|/* Open the repository and fill in b with the resulting information. */
name|SVN_ERR
argument_list|(
name|svn_repos_open2
argument_list|(
operator|&
name|b
operator|->
name|repos
argument_list|,
name|repos_root
argument_list|,
name|b
operator|->
name|fs_config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_remember_client_capabilities
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|capabilities
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|b
operator|->
name|repos
argument_list|)
expr_stmt|;
name|fs_path
operator|=
name|full_path
operator|+
name|strlen
argument_list|(
name|repos_root
argument_list|)
expr_stmt|;
name|b
operator|->
name|fs_path
operator|=
name|svn_stringbuf_create
argument_list|(
operator|*
name|fs_path
condition|?
name|fs_path
else|:
literal|"/"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|url_buf
operator|=
name|svn_stringbuf_create
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_path_remove_components
argument_list|(
name|url_buf
argument_list|,
name|svn_path_component_count
argument_list|(
name|b
operator|->
name|fs_path
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|repos_url
operator|=
name|url_buf
operator|->
name|data
expr_stmt|;
name|b
operator|->
name|authz_repos_name
operator|=
name|svn_dirent_is_child
argument_list|(
name|root
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|authz_repos_name
operator|==
name|NULL
condition|)
name|b
operator|->
name|repos_name
operator|=
name|svn_dirent_basename
argument_list|(
name|repos_root
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|repos_name
operator|=
name|b
operator|->
name|authz_repos_name
expr_stmt|;
name|b
operator|->
name|repos_name
operator|=
name|svn_path_uri_encode
argument_list|(
name|b
operator|->
name|repos_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If the svnserve configuration has not been loaded then load it from the    * repository. */
if|if
condition|(
name|NULL
operator|==
name|b
operator|->
name|cfg
condition|)
block|{
name|b
operator|->
name|base
operator|=
name|svn_repos_conf_dir
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
operator|&
name|b
operator|->
name|cfg
argument_list|,
name|svn_repos_svnserve_conf
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
comment|/* must_exist */
name|FALSE
argument_list|,
comment|/* section_names_case_sensitive */
name|FALSE
argument_list|,
comment|/* option_names_case_sensitive */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|load_pwdb_config
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|load_authz_config
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* svnserve.conf has been loaded via the --config-file option so need    * to load pwdb and authz. */
else|else
block|{
name|SVN_ERR
argument_list|(
name|load_pwdb_config
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|load_authz_config
argument_list|(
name|b
argument_list|,
name|conn
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
comment|/* Should we use Cyrus SASL? */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|b
operator|->
name|cfg
argument_list|,
operator|&
name|b
operator|->
name|use_sasl
argument_list|,
name|SVN_CONFIG_SECTION_SASL
argument_list|,
name|SVN_CONFIG_OPTION_USE_SASL
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Use the repository UUID as the default realm. */
name|SVN_ERR
argument_list|(
name|svn_fs_get_uuid
argument_list|(
name|b
operator|->
name|fs
argument_list|,
operator|&
name|b
operator|->
name|realm
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|b
operator|->
name|cfg
argument_list|,
operator|&
name|b
operator|->
name|realm
argument_list|,
name|SVN_CONFIG_SECTION_GENERAL
argument_list|,
name|SVN_CONFIG_OPTION_REALM
argument_list|,
name|b
operator|->
name|realm
argument_list|)
expr_stmt|;
comment|/* Make sure it's possible for the client to authenticate.  Note      that this doesn't take into account any authz configuration read      above, because we can't know about access it grants until paths      are given by the client. */
if|if
condition|(
name|get_access
argument_list|(
name|b
argument_list|,
name|UNAUTHENTICATED
argument_list|)
operator|==
name|NO_ACCESS
operator|&&
operator|(
name|get_access
argument_list|(
name|b
argument_list|,
name|AUTHENTICATED
argument_list|)
operator|==
name|NO_ACCESS
operator|||
operator|(
operator|!
name|b
operator|->
name|tunnel_user
operator|&&
operator|!
name|b
operator|->
name|pwdb
operator|&&
operator|!
name|b
operator|->
name|use_sasl
operator|)
operator|)
condition|)
return|return
name|error_create_and_log
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
literal|"No access allowed to this repository"
argument_list|,
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
return|;
comment|/* Configure hook script environment variables. */
name|svn_config_get
argument_list|(
name|b
operator|->
name|cfg
argument_list|,
operator|&
name|hooks_env
argument_list|,
name|SVN_CONFIG_SECTION_GENERAL
argument_list|,
name|SVN_CONFIG_OPTION_HOOKS_ENV
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hooks_env
condition|)
name|hooks_env
operator|=
name|svn_dirent_internal_style
argument_list|(
name|hooks_env
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_hooks_setenv
argument_list|(
name|b
operator|->
name|repos
argument_list|,
name|hooks_env
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compute the authentication name EXTERNAL should be able to get, if any. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_tunnel_user
parameter_list|(
name|serve_params_t
modifier|*
name|params
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Only offer EXTERNAL for connections tunneled over a login agent. */
if|if
condition|(
operator|!
name|params
operator|->
name|tunnel
condition|)
return|return
name|NULL
return|;
comment|/* If a tunnel user was provided on the command line, use that. */
if|if
condition|(
name|params
operator|->
name|tunnel_user
condition|)
return|return
name|params
operator|->
name|tunnel_user
return|;
return|return
name|svn_user_get_name
argument_list|(
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fs_warning_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
name|fs_warning_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|log_server_error
argument_list|(
name|err
argument_list|,
name|b
operator|->
name|server
argument_list|,
name|b
operator|->
name|conn
argument_list|,
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* TODO: Keep log_pool in the server baton, cleared after every log? */
name|svn_pool_clear
argument_list|(
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the normalized repository-relative path for the given PATH  * (may be a URL, full path or relative path) and fs contained in the  * server baton BATON. Allocate the result in POOL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_normalized_repo_rel_path
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|/* This is a copyfrom URL. */
name|path
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|sb
operator|->
name|repos_url
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a base-relative path. */
if|if
condition|(
operator|(
name|path
operator|)
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
comment|/* Get an absolute path for use in the FS. */
name|path
operator|=
name|svn_fspath__join
argument_list|(
name|sb
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/* Get the revision root for REVISION in fs given by server baton BATON  * and return it in *FS_ROOT. Use HEAD if REVISION is SVN_INVALID_REVNUM.  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_revision_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|fs_root
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|server_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|revision
argument_list|,
name|sb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
name|fs_root
argument_list|,
name|sb
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|path
operator|=
name|get_normalized_repo_rel_path
argument_list|(
name|baton
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|baton
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_node_proplist
argument_list|(
name|props
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
name|path
operator|=
name|get_normalized_repo_rel_path
argument_list|(
name|baton
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|baton
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
name|kind
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_filename
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|path
operator|=
name|get_normalized_repo_rel_path
argument_list|(
name|baton
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|baton
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|file_stream
argument_list|,
operator|&
name|tmp_filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|file_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|tmp_filename
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|serve
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|serve_params_t
modifier|*
name|params
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|io_err
decl_stmt|;
name|apr_uint64_t
name|ver
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|,
modifier|*
name|client_url
decl_stmt|,
modifier|*
name|ra_client_string
decl_stmt|,
modifier|*
name|client_string
decl_stmt|;
name|apr_array_header_t
modifier|*
name|caplist
decl_stmt|,
modifier|*
name|cap_words
decl_stmt|;
name|server_baton_t
name|b
decl_stmt|;
name|fs_warning_baton_t
name|warn_baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|cap_log
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|b
operator|.
name|tunnel
operator|=
name|params
operator|->
name|tunnel
expr_stmt|;
name|b
operator|.
name|tunnel_user
operator|=
name|get_tunnel_user
argument_list|(
name|params
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|.
name|read_only
operator|=
name|params
operator|->
name|read_only
expr_stmt|;
name|b
operator|.
name|user
operator|=
name|NULL
expr_stmt|;
name|b
operator|.
name|username_case
operator|=
name|params
operator|->
name|username_case
expr_stmt|;
name|b
operator|.
name|authz_user
operator|=
name|NULL
expr_stmt|;
name|b
operator|.
name|base
operator|=
name|params
operator|->
name|base
expr_stmt|;
name|b
operator|.
name|cfg
operator|=
name|params
operator|->
name|cfg
expr_stmt|;
name|b
operator|.
name|pwdb
operator|=
name|NULL
expr_stmt|;
name|b
operator|.
name|authzdb
operator|=
name|NULL
expr_stmt|;
name|b
operator|.
name|realm
operator|=
name|NULL
expr_stmt|;
name|b
operator|.
name|log_file
operator|=
name|params
operator|->
name|log_file
expr_stmt|;
name|b
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|b
operator|.
name|use_sasl
operator|=
name|FALSE
expr_stmt|;
name|b
operator|.
name|vhost
operator|=
name|params
operator|->
name|vhost
expr_stmt|;
comment|/* construct FS configuration parameters */
name|b
operator|.
name|fs_config
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|b
operator|.
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_DELTAS
argument_list|,
name|params
operator|->
name|cache_txdeltas
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|b
operator|.
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS
argument_list|,
name|params
operator|->
name|cache_fulltexts
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|b
operator|.
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_REVPROPS
argument_list|,
name|params
operator|->
name|cache_revprops
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
comment|/* Send greeting.  We don't support version 1 any more, so we can    * send an empty mechlist. */
if|if
condition|(
name|params
operator|->
name|compression_level
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"nn()(wwwwwwwwwww)"
argument_list|,
operator|(
name|apr_uint64_t
operator|)
literal|2
argument_list|,
operator|(
name|apr_uint64_t
operator|)
literal|2
argument_list|,
name|SVN_RA_SVN_CAP_EDIT_PIPELINE
argument_list|,
name|SVN_RA_SVN_CAP_SVNDIFF1
argument_list|,
name|SVN_RA_SVN_CAP_ABSENT_ENTRIES
argument_list|,
name|SVN_RA_SVN_CAP_COMMIT_REVPROPS
argument_list|,
name|SVN_RA_SVN_CAP_DEPTH
argument_list|,
name|SVN_RA_SVN_CAP_LOG_REVPROPS
argument_list|,
name|SVN_RA_SVN_CAP_ATOMIC_REVPROPS
argument_list|,
name|SVN_RA_SVN_CAP_PARTIAL_REPLAY
argument_list|,
name|SVN_RA_SVN_CAP_INHERITED_PROPS
argument_list|,
name|SVN_RA_SVN_CAP_EPHEMERAL_TXNPROPS
argument_list|,
name|SVN_RA_SVN_CAP_GET_FILE_REVS_REVERSE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"nn()(wwwwwwwwww)"
argument_list|,
operator|(
name|apr_uint64_t
operator|)
literal|2
argument_list|,
operator|(
name|apr_uint64_t
operator|)
literal|2
argument_list|,
name|SVN_RA_SVN_CAP_EDIT_PIPELINE
argument_list|,
name|SVN_RA_SVN_CAP_ABSENT_ENTRIES
argument_list|,
name|SVN_RA_SVN_CAP_COMMIT_REVPROPS
argument_list|,
name|SVN_RA_SVN_CAP_DEPTH
argument_list|,
name|SVN_RA_SVN_CAP_LOG_REVPROPS
argument_list|,
name|SVN_RA_SVN_CAP_ATOMIC_REVPROPS
argument_list|,
name|SVN_RA_SVN_CAP_PARTIAL_REPLAY
argument_list|,
name|SVN_RA_SVN_CAP_INHERITED_PROPS
argument_list|,
name|SVN_RA_SVN_CAP_EPHEMERAL_TXNPROPS
argument_list|,
name|SVN_RA_SVN_CAP_GET_FILE_REVS_REVERSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read client response, which we assume to be in version 2 format:    * version, capability list, and client URL; then we do an auth    * request. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"nlc?c(?c)"
argument_list|,
operator|&
name|ver
argument_list|,
operator|&
name|caplist
argument_list|,
operator|&
name|client_url
argument_list|,
operator|&
name|ra_client_string
argument_list|,
operator|&
name|client_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|!=
literal|2
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|client_url
operator|=
name|svn_uri_canonicalize
argument_list|(
name|client_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn_set_capabilities
argument_list|(
name|conn
argument_list|,
name|caplist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All released versions of Subversion support edit-pipeline,    * so we do not accept connections from clients that do not. */
if|if
condition|(
operator|!
name|svn_ra_svn_has_capability
argument_list|(
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_EDIT_PIPELINE
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* find_repos needs the capabilities as a list of words (eventually      they get handed to the start-commit hook).  While we could add a      new interface to re-retrieve them from conn and convert the      result to a list, it's simpler to just convert caplist by hand      here, since we already have it and turning 'svn_ra_svn_item_t's      into 'const char *'s is pretty easy.       We only record capabilities we care about.  The client may report      more (because it doesn't know what the server cares about). */
block|{
name|int
name|i
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|item
decl_stmt|;
name|cap_words
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|caplist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|caplist
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
expr_stmt|;
comment|/* ra_svn_set_capabilities() already type-checked for us */
if|if
condition|(
name|strcmp
argument_list|(
name|item
operator|->
name|u
operator|.
name|word
argument_list|,
name|SVN_RA_SVN_CAP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|cap_words
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|SVN_RA_CAPABILITY_MERGEINFO
expr_stmt|;
block|}
comment|/* Save for operational log. */
if|if
condition|(
name|cap_log
operator|->
name|len
operator|>
literal|0
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|cap_log
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|cap_log
argument_list|,
name|item
operator|->
name|u
operator|.
name|word
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|find_repos
argument_list|(
name|client_url
argument_list|,
name|params
operator|->
name|root
argument_list|,
operator|&
name|b
argument_list|,
name|conn
argument_list|,
name|cap_words
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|SVN_ERR
argument_list|(
name|auth_request
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
operator|&
name|b
argument_list|,
name|READ_ACCESS
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_access
argument_list|(
operator|&
name|b
argument_list|)
operator|==
name|NO_ACCESS
condition|)
name|err
operator|=
name|error_create_and_log
argument_list|(
name|SVN_ERR_RA_NOT_AUTHORIZED
argument_list|,
name|NULL
argument_list|,
literal|"Not authorized for access"
argument_list|,
operator|&
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|log_error
argument_list|(
name|err
argument_list|,
name|b
operator|.
name|log_file
argument_list|,
name|svn_ra_svn_conn_remote_host
argument_list|(
name|conn
argument_list|)
argument_list|,
name|b
operator|.
name|user
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|io_err
operator|=
name|svn_ra_svn__write_cmd_failure
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|io_err
argument_list|)
expr_stmt|;
return|return
name|svn_ra_svn__flush
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|)
return|;
block|}
comment|/* Log the open. */
if|if
condition|(
name|ra_client_string
operator|==
name|NULL
operator|||
name|ra_client_string
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|ra_client_string
operator|=
literal|"-"
expr_stmt|;
else|else
name|ra_client_string
operator|=
name|svn_path_uri_encode
argument_list|(
name|ra_client_string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_string
operator|==
name|NULL
operator|||
name|client_string
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|client_string
operator|=
literal|"-"
expr_stmt|;
else|else
name|client_string
operator|=
name|svn_path_uri_encode
argument_list|(
name|client_string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|log_command
argument_list|(
operator|&
name|b
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
literal|"open %"
name|APR_UINT64_T_FMT
literal|" cap=(%s) %s %s %s"
argument_list|,
name|ver
argument_list|,
name|cap_log
operator|->
name|data
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|b
operator|.
name|fs_path
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ra_client_string
argument_list|,
name|client_string
argument_list|)
argument_list|)
expr_stmt|;
name|warn_baton
operator|.
name|server
operator|=
operator|&
name|b
expr_stmt|;
name|warn_baton
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|warn_baton
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_fs_set_warning_func
argument_list|(
name|b
operator|.
name|fs
argument_list|,
name|fs_warning_func
argument_list|,
operator|&
name|warn_baton
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_uuid
argument_list|(
name|b
operator|.
name|fs
argument_list|,
operator|&
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't claim mergeinfo capability until we know whether the      repository supports mergeinfo (i.e., is not a 1.4 repository),      but we don't get the repository url from the client until after      we've already sent the initial list of server capabilities.  So      we list repository capabilities here, in our first response after      the client has sent the url. */
block|{
name|svn_boolean_t
name|supports_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_has_capability
argument_list|(
name|b
operator|.
name|repos
argument_list|,
operator|&
name|supports_mergeinfo
argument_list|,
name|SVN_REPOS_CAPABILITY_MERGEINFO
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(cc(!"
argument_list|,
literal|"success"
argument_list|,
name|uuid
argument_list|,
name|b
operator|.
name|repos_url
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|supports_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|SVN_RA_SVN_CAP_MERGEINFO
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set up editor shims. */
block|{
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_baton
operator|=
operator|&
name|b
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__set_shim_callbacks
argument_list|(
name|conn
argument_list|,
name|callbacks
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_ra_svn__handle_commands2
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|main_commands
argument_list|,
operator|&
name|b
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

end_unit

