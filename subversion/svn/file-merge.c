begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * file-merge.c: internal file merge tool  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* This is an interactive file merge tool with an interface similar to  * the interactive mode of the UNIX sdiff ("side-by-side diff") utility.  * The merge tool is driven by Subversion's diff code and user input. */
end_comment

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_SYS_IOCTL_H
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* Baton for functions in this file which implement svn_diff_output_fns_t. */
end_comment

begin_struct
struct|struct
name|file_merge_baton
block|{
comment|/* The files being merged. */
name|apr_file_t
modifier|*
name|original_file
decl_stmt|;
name|apr_file_t
modifier|*
name|modified_file
decl_stmt|;
name|apr_file_t
modifier|*
name|latest_file
decl_stmt|;
comment|/* Counters to keep track of the current line in each file. */
name|svn_linenum_t
name|current_line_original
decl_stmt|;
name|svn_linenum_t
name|current_line_modified
decl_stmt|;
name|svn_linenum_t
name|current_line_latest
decl_stmt|;
comment|/* The merge result is written to this file. */
name|apr_file_t
modifier|*
name|merged_file
decl_stmt|;
comment|/* Whether the merged file remains in conflict after the merge. */
name|svn_boolean_t
name|remains_in_conflict
decl_stmt|;
comment|/* External editor command for editing chunks. */
specifier|const
name|char
modifier|*
name|editor_cmd
decl_stmt|;
comment|/* The client configuration hash. */
name|apr_hash_t
modifier|*
name|config
decl_stmt|;
comment|/* Wether the merge should be aborted. */
name|svn_boolean_t
name|abort_merge
decl_stmt|;
comment|/* Pool for temporary allocations. */
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
block|}
name|file_merge_baton
struct|;
end_struct

begin_comment
comment|/* Copy LEN lines from SOURCE_FILE to the MERGED_FILE, starting at  * line START. The CURRENT_LINE is the current line in the source file.  * The new current line is returned in *NEW_CURRENT_LINE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_to_merged_file
parameter_list|(
name|svn_linenum_t
modifier|*
name|new_current_line
parameter_list|,
name|apr_file_t
modifier|*
name|merged_file
parameter_list|,
name|apr_file_t
modifier|*
name|source_file
parameter_list|,
name|apr_off_t
name|start
parameter_list|,
name|apr_off_t
name|len
parameter_list|,
name|svn_linenum_t
name|current_line
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
name|apr_size_t
name|lines_read
decl_stmt|;
name|apr_size_t
name|lines_copied
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|svn_linenum_t
name|orig_current_line
init|=
name|current_line
decl_stmt|;
name|lines_read
operator|=
literal|0
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_line
operator|<
name|start
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_readline
argument_list|(
name|source_file
argument_list|,
operator|&
name|line
argument_list|,
name|NULL
argument_list|,
operator|&
name|eof
argument_list|,
name|APR_SIZE_MAX
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
break|break;
name|current_line
operator|++
expr_stmt|;
name|lines_read
operator|++
expr_stmt|;
block|}
name|lines_copied
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lines_copied
operator|<
name|len
condition|)
block|{
name|apr_size_t
name|bytes_written
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_readline
argument_list|(
name|source_file
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|eof
argument_list|,
name|APR_SIZE_MAX
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_str
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|line
argument_list|,
name|eol_str
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|merged_file
argument_list|,
name|line
operator|->
name|data
argument_list|,
name|line
operator|->
name|len
argument_list|,
operator|&
name|bytes_written
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|!=
name|line
operator|->
name|len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not write data to merged file"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|eof
condition|)
break|break;
name|lines_copied
operator|++
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|new_current_line
operator|=
name|orig_current_line
operator|+
name|lines_read
operator|+
name|lines_copied
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy common data to the merged file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_merge_output_common
parameter_list|(
name|void
modifier|*
name|output_baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
name|struct
name|file_merge_baton
modifier|*
name|b
init|=
name|output_baton
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|abort_merge
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|copy_to_merged_file
argument_list|(
operator|&
name|b
operator|->
name|current_line_original
argument_list|,
name|b
operator|->
name|merged_file
argument_list|,
name|b
operator|->
name|original_file
argument_list|,
name|original_start
argument_list|,
name|original_length
argument_list|,
name|b
operator|->
name|current_line_original
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Original/latest match up, but modified differs.  * Copy modified data to the merged file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_merge_output_diff_modified
parameter_list|(
name|void
modifier|*
name|output_baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
name|struct
name|file_merge_baton
modifier|*
name|b
init|=
name|output_baton
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|abort_merge
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|copy_to_merged_file
argument_list|(
operator|&
name|b
operator|->
name|current_line_modified
argument_list|,
name|b
operator|->
name|merged_file
argument_list|,
name|b
operator|->
name|modified_file
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|,
name|b
operator|->
name|current_line_modified
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Original/modified match up, but latest differs.  * Copy latest data to the merged file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_merge_output_diff_latest
parameter_list|(
name|void
modifier|*
name|output_baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
name|struct
name|file_merge_baton
modifier|*
name|b
init|=
name|output_baton
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|abort_merge
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|copy_to_merged_file
argument_list|(
operator|&
name|b
operator|->
name|current_line_latest
argument_list|,
name|b
operator|->
name|merged_file
argument_list|,
name|b
operator|->
name|latest_file
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|,
name|b
operator|->
name|current_line_latest
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Modified/latest match up, but original differs.  * Copy latest data to the merged file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_merge_output_diff_common
parameter_list|(
name|void
modifier|*
name|output_baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
name|struct
name|file_merge_baton
modifier|*
name|b
init|=
name|output_baton
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|abort_merge
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|copy_to_merged_file
argument_list|(
operator|&
name|b
operator|->
name|current_line_latest
argument_list|,
name|b
operator|->
name|merged_file
argument_list|,
name|b
operator|->
name|latest_file
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|,
name|b
operator|->
name|current_line_latest
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return LEN lines within the diff chunk staring at line START  * in a *LINES array of svn_stringbuf_t* elements.  * Store the resulting current in in *NEW_CURRENT_LINE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_diff_chunk
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|lines
parameter_list|,
name|svn_linenum_t
modifier|*
name|new_current_line
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_linenum_t
name|current_line
parameter_list|,
name|apr_off_t
name|start
parameter_list|,
name|apr_off_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
operator|*
name|lines
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_stringbuf_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip lines before start of range. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_line
operator|<
name|start
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_readline
argument_list|(
name|file
argument_list|,
operator|&
name|line
argument_list|,
name|NULL
argument_list|,
operator|&
name|eof
argument_list|,
name|APR_SIZE_MAX
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|current_line
operator|++
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Now read the lines. */
do|do
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_readline
argument_list|(
name|file
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|eof
argument_list|,
name|APR_SIZE_MAX
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_str
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|line
argument_list|,
name|eol_str
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|lines
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|eof
condition|)
break|break;
name|current_line
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|lines
operator|)
operator|->
name|nelts
operator|<
name|len
condition|)
do|;
operator|*
name|new_current_line
operator|=
name|current_line
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the terminal width in number of columns. */
end_comment

begin_function
specifier|static
name|int
name|get_term_width
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|columns_env
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ws
operator|.
name|ws_col
operator|<
literal|80
condition|)
return|return
literal|80
return|;
return|return
name|ws
operator|.
name|ws_col
return|;
block|}
block|}
elif|#
directive|elif
name|defined
name|WIN32
name|CONSOLE_SCREEN_BUFFER_INFO
name|csbi
decl_stmt|;
if|if
condition|(
name|GetConsoleScreenBufferInfo
argument_list|(
name|GetStdHandle
argument_list|(
name|STD_OUTPUT_HANDLE
argument_list|)
argument_list|,
operator|&
name|csbi
argument_list|)
condition|)
block|{
if|if
condition|(
name|csbi
operator|.
name|dwSize
operator|.
name|X
operator|<
literal|80
condition|)
return|return
literal|80
return|;
return|return
name|csbi
operator|.
name|dwSize
operator|.
name|X
return|;
block|}
endif|#
directive|endif
name|columns_env
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|columns_env
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|cols
decl_stmt|;
name|err
operator|=
name|svn_cstring_atoi
argument_list|(
operator|&
name|cols
argument_list|,
name|columns_env
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
literal|80
return|;
block|}
if|if
condition|(
name|cols
operator|<
literal|80
condition|)
return|return
literal|80
return|;
return|return
name|cols
return|;
block|}
else|else
return|return
literal|80
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LINE_DISPLAY_WIDTH
value|((get_term_width() / 2) - 2)
end_define

begin_comment
comment|/* Prepare LINE for display, pruning or extending it to an appropriate  * display width, and stripping the EOL marker, if any.  * This function assumes that the data in LINE is encoded in UTF-8. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|prepare_line_for_display
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|buf
init|=
name|svn_stringbuf_create
argument_list|(
name|line
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|size_t
name|width
decl_stmt|;
name|size_t
name|line_width
init|=
name|LINE_DISPLAY_WIDTH
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Trim EOL. */
if|if
condition|(
name|buf
operator|->
name|len
operator|>=
literal|2
operator|&&
name|buf
operator|->
name|data
index|[
name|buf
operator|->
name|len
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|buf
operator|->
name|data
index|[
name|buf
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|svn_stringbuf_chop
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
operator|->
name|len
operator|>=
literal|1
operator|&&
operator|(
name|buf
operator|->
name|data
index|[
name|buf
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|buf
operator|->
name|data
index|[
name|buf
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
condition|)
name|svn_stringbuf_chop
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Determine the on-screen width of the line. */
name|width
operator|=
name|svn_utf_cstring_utf8_width
argument_list|(
name|buf
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Determining the width failed. Try to get rid of unprintable        * characters in the line buffer. */
name|buf
operator|=
name|svn_stringbuf_create
argument_list|(
name|svn_xml_fuzzy_escape
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|width
operator|=
name|svn_utf_cstring_utf8_width
argument_list|(
name|buf
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
operator|-
literal|1
condition|)
name|width
operator|=
name|buf
operator|->
name|len
expr_stmt|;
comment|/* fallback: buffer length */
block|}
comment|/* Trim further in case line is still too long, or add padding in case    * it is too short. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|width
operator|>
name|line_width
condition|)
block|{
specifier|const
name|char
modifier|*
name|last_valid
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_stringbuf_chop
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Be careful not to invalidate the UTF-8 string by trimming        * just part of a character. */
name|last_valid
operator|=
name|svn_utf__last_valid
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_valid
operator|<
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|len
condition|)
name|svn_stringbuf_chop
argument_list|(
name|buf
argument_list|,
operator|(
name|buf
operator|->
name|data
operator|+
name|buf
operator|->
name|len
operator|)
operator|-
name|last_valid
argument_list|)
expr_stmt|;
name|width
operator|=
name|svn_utf_cstring_utf8_width
argument_list|(
name|buf
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
operator|-
literal|1
condition|)
name|width
operator|=
name|buf
operator|->
name|len
expr_stmt|;
comment|/* fallback: buffer length */
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
while|while
condition|(
name|width
operator|==
literal|0
operator|||
name|width
operator|<
name|line_width
condition|)
block|{
name|svn_stringbuf_appendbyte
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|width
operator|++
expr_stmt|;
block|}
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|width
operator|==
name|line_width
argument_list|)
expr_stmt|;
return|return
name|buf
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Merge CHUNK1 and CHUNK2 into a new chunk with conflict markers. */
end_comment

begin_function
specifier|static
name|apr_array_header_t
modifier|*
name|merge_chunks_with_conflict_markers
parameter_list|(
name|apr_array_header_t
modifier|*
name|chunk1
parameter_list|,
name|apr_array_header_t
modifier|*
name|chunk2
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|merged_chunk
decl_stmt|;
name|int
name|i
decl_stmt|;
name|merged_chunk
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_stringbuf_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### would be nice to show filenames next to conflict markers */
name|APR_ARRAY_PUSH
argument_list|(
name|merged_chunk
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
operator|=
name|svn_stringbuf_create
argument_list|(
literal|"<<<<<<<\n"
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunk1
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|merged_chunk
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|chunk1
argument_list|,
name|i
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|merged_chunk
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
operator|=
name|svn_stringbuf_create
argument_list|(
literal|"=======\n"
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunk2
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|merged_chunk
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|chunk2
argument_list|,
name|i
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|merged_chunk
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
operator|=
name|svn_stringbuf_create
argument_list|(
literal|">>>>>>>\n"
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|merged_chunk
return|;
block|}
end_function

begin_comment
comment|/* Edit CHUNK and return the result in *MERGED_CHUNK allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|edit_chunk
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|merged_chunk
parameter_list|,
name|apr_array_header_t
modifier|*
name|chunk
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|temp_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_file_name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_off_t
name|pos
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|temp_file
argument_list|,
operator|&
name|temp_file_name
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunk
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_stringbuf_t
modifier|*
name|line
init|=
name|APR_ARRAY_IDX
argument_list|(
name|chunk
argument_list|,
name|i
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
decl_stmt|;
name|apr_size_t
name|bytes_written
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|temp_file
argument_list|,
name|line
operator|->
name|data
argument_list|,
name|line
operator|->
name|len
argument_list|,
operator|&
name|bytes_written
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|len
operator|!=
name|bytes_written
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not write data to temporary file"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|temp_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_cmdline__edit_file_externally
argument_list|(
name|temp_file_name
argument_list|,
name|editor_cmd
argument_list|,
name|config
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_NO_EXTERNAL_EDITOR
operator|)
condition|)
block|{
name|svn_error_t
modifier|*
name|root_err
init|=
name|svn_error_root_cause
argument_list|(
name|err
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s\n"
argument_list|,
name|root_err
operator|->
name|message
condition|?
name|root_err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"No editor found."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|merged_chunk
operator|=
name|NULL
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_EXTERNAL_PROGRAM
operator|)
condition|)
block|{
name|svn_error_t
modifier|*
name|root_err
init|=
name|svn_error_root_cause
argument_list|(
name|err
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s\n"
argument_list|,
name|root_err
operator|->
name|message
condition|?
name|root_err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"Error running editor."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|merged_chunk
operator|=
name|NULL
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
operator|*
name|merged_chunk
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_stringbuf_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|temp_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_readline
argument_list|(
name|temp_file
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|eof
argument_list|,
name|APR_SIZE_MAX
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_str
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|line
argument_list|,
name|eol_str
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|merged_chunk
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
operator|=
name|line
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|temp_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a separator string of the appropriate length. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sep_string
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|int
name|line_width
init|=
name|LINE_DISPLAY_WIDTH
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|line_width
condition|;
name|i
operator|++
control|)
name|svn_stringbuf_appendbyte
argument_list|(
name|buf
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|buf
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|line_width
condition|;
name|i
operator|++
control|)
name|svn_stringbuf_appendbyte
argument_list|(
name|buf
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
name|buf
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Merge chunks CHUNK1 and CHUNK2.  * Each lines array contains elements of type svn_stringbuf_t*.  * Return the result in *MERGED_CHUNK, or set *MERGED_CHUNK to NULL in  * case the user chooses to postpone resolution of this chunk.  * If the user wants to abort the merge, set *ABORT_MERGE to TRUE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_chunks
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|merged_chunk
parameter_list|,
name|svn_boolean_t
modifier|*
name|abort_merge
parameter_list|,
name|apr_array_header_t
modifier|*
name|chunk1
parameter_list|,
name|apr_array_header_t
modifier|*
name|chunk2
parameter_list|,
name|svn_linenum_t
name|current_line1
parameter_list|,
name|svn_linenum_t
name|current_line2
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|prompt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|max_chunk_lines
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|max_chunk_lines
operator|=
name|chunk1
operator|->
name|nelts
operator|>
name|chunk2
operator|->
name|nelts
condition|?
name|chunk1
operator|->
name|nelts
else|:
name|chunk2
operator|->
name|nelts
expr_stmt|;
operator|*
name|abort_merge
operator|=
name|FALSE
expr_stmt|;
comment|/*    * Prepare the selection prompt.    */
name|prompt
operator|=
name|svn_stringbuf_create
argument_list|(
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%s\n%s|%s\n%s"
argument_list|,
name|_
argument_list|(
literal|"Conflicting section found during merge:"
argument_list|)
argument_list|,
name|prepare_line_for_display
argument_list|(
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"(1) their version (at line %lu)"
argument_list|)
argument_list|,
name|current_line1
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|prepare_line_for_display
argument_list|(
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"(2) your version (at line %lu)"
argument_list|)
argument_list|,
name|current_line2
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|get_sep_string
argument_list|(
name|scratch_pool
argument_list|)
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_chunk_lines
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|line1
decl_stmt|;
specifier|const
name|char
modifier|*
name|line2
decl_stmt|;
specifier|const
name|char
modifier|*
name|prompt_line
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|chunk1
operator|->
name|nelts
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|line_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_stringbuf_to_utf8
argument_list|(
operator|&
name|line_utf8
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|chunk1
argument_list|,
name|i
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|line1
operator|=
name|prepare_line_for_display
argument_list|(
name|line_utf8
operator|->
name|data
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
name|line1
operator|=
name|prepare_line_for_display
argument_list|(
literal|""
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|chunk2
operator|->
name|nelts
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|line_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_stringbuf_to_utf8
argument_list|(
operator|&
name|line_utf8
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|chunk2
argument_list|,
name|i
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|line2
operator|=
name|prepare_line_for_display
argument_list|(
name|line_utf8
operator|->
name|data
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
name|line2
operator|=
name|prepare_line_for_display
argument_list|(
literal|""
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|prompt_line
operator|=
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%s|%s\n"
argument_list|,
name|line1
argument_list|,
name|line2
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|prompt
argument_list|,
name|prompt_line
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendcstr
argument_list|(
name|prompt
argument_list|,
name|get_sep_string
argument_list|(
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|prompt
argument_list|,
name|_
argument_list|(
literal|"Select: (1) use their version, (2) use your version,\n"
literal|"        (e1) edit their version and use the result,\n"
literal|"        (e2) edit your version and use the result,\n"
literal|"        (eb) edit both versions and use the result,\n"
literal|"        (p) postpone this conflicting section leaving conflict markers,\n"
literal|"        (a) abort file merge and return to main menu: "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now let's see what the user wants to do with this conflict. */
while|while
condition|(
name|TRUE
condition|)
block|{
specifier|const
name|char
modifier|*
name|answer
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_prompt_user2
argument_list|(
operator|&
name|answer
argument_list|,
name|prompt
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|answer
argument_list|,
literal|"1"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|merged_chunk
operator|=
name|chunk1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|answer
argument_list|,
literal|"2"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|merged_chunk
operator|=
name|chunk2
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|answer
argument_list|,
literal|"p"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|merged_chunk
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|answer
argument_list|,
literal|"e1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|edit_chunk
argument_list|(
name|merged_chunk
argument_list|,
name|chunk1
argument_list|,
name|editor_cmd
argument_list|,
name|config
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|merged_chunk
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|answer
argument_list|,
literal|"e2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|edit_chunk
argument_list|(
name|merged_chunk
argument_list|,
name|chunk2
argument_list|,
name|editor_cmd
argument_list|,
name|config
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|merged_chunk
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|answer
argument_list|,
literal|"eb"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_array_header_t
modifier|*
name|conflict_chunk
decl_stmt|;
name|conflict_chunk
operator|=
name|merge_chunks_with_conflict_markers
argument_list|(
name|chunk1
argument_list|,
name|chunk2
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|edit_chunk
argument_list|(
name|merged_chunk
argument_list|,
name|conflict_chunk
argument_list|,
name|editor_cmd
argument_list|,
name|config
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|merged_chunk
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|answer
argument_list|,
literal|"a"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|abort_merge
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform a merge of chunks from FILE1 and FILE2, specified by START1/LEN1  * and START2/LEN2, respectively. Append the result to MERGED_FILE.  * The current line numbers for FILE1 and FILE2 are passed in *CURRENT_LINE1  * and *CURRENT_LINE2, and will be updated to new values upon return.  * If the user wants to abort the merge, set *ABORT_MERGE to TRUE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_file_chunks
parameter_list|(
name|svn_boolean_t
modifier|*
name|remains_in_conflict
parameter_list|,
name|svn_boolean_t
modifier|*
name|abort_merge
parameter_list|,
name|apr_file_t
modifier|*
name|merged_file
parameter_list|,
name|apr_file_t
modifier|*
name|file1
parameter_list|,
name|apr_file_t
modifier|*
name|file2
parameter_list|,
name|apr_off_t
name|start1
parameter_list|,
name|apr_off_t
name|len1
parameter_list|,
name|apr_off_t
name|start2
parameter_list|,
name|apr_off_t
name|len2
parameter_list|,
name|svn_linenum_t
modifier|*
name|current_line1
parameter_list|,
name|svn_linenum_t
modifier|*
name|current_line2
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|chunk1
decl_stmt|;
name|apr_array_header_t
modifier|*
name|chunk2
decl_stmt|;
name|apr_array_header_t
modifier|*
name|merged_chunk
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_diff_chunk
argument_list|(
operator|&
name|chunk1
argument_list|,
name|current_line1
argument_list|,
name|file1
argument_list|,
operator|*
name|current_line1
argument_list|,
name|start1
argument_list|,
name|len1
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_diff_chunk
argument_list|(
operator|&
name|chunk2
argument_list|,
name|current_line2
argument_list|,
name|file2
argument_list|,
operator|*
name|current_line2
argument_list|,
name|start2
argument_list|,
name|len2
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|merge_chunks
argument_list|(
operator|&
name|merged_chunk
argument_list|,
name|abort_merge
argument_list|,
name|chunk1
argument_list|,
name|chunk2
argument_list|,
operator|*
name|current_line1
argument_list|,
operator|*
name|current_line2
argument_list|,
name|editor_cmd
argument_list|,
name|config
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_merge
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the user chose 'postpone' put conflict markers and left/right    * versions into the merged file. */
if|if
condition|(
name|merged_chunk
operator|==
name|NULL
condition|)
block|{
operator|*
name|remains_in_conflict
operator|=
name|TRUE
expr_stmt|;
name|merged_chunk
operator|=
name|merge_chunks_with_conflict_markers
argument_list|(
name|chunk1
argument_list|,
name|chunk2
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|merged_chunk
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|apr_size_t
name|bytes_written
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|line
init|=
name|APR_ARRAY_IDX
argument_list|(
name|merged_chunk
argument_list|,
name|i
argument_list|,
name|svn_stringbuf_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|merged_file
argument_list|,
name|line
operator|->
name|data
argument_list|,
name|line
operator|->
name|len
argument_list|,
operator|&
name|bytes_written
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|len
operator|!=
name|bytes_written
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not write data to merged file"
argument_list|)
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Original, modified, and latest all differ from one another.  * This is a conflict and we'll need to ask the user to merge it. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_merge_output_conflict
parameter_list|(
name|void
modifier|*
name|output_baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|,
name|svn_diff_t
modifier|*
name|resolved_diff
parameter_list|)
block|{
name|struct
name|file_merge_baton
modifier|*
name|b
init|=
name|output_baton
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|abort_merge
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|merge_file_chunks
argument_list|(
operator|&
name|b
operator|->
name|remains_in_conflict
argument_list|,
operator|&
name|b
operator|->
name|abort_merge
argument_list|,
name|b
operator|->
name|merged_file
argument_list|,
name|b
operator|->
name|modified_file
argument_list|,
name|b
operator|->
name|latest_file
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|,
name|latest_start
argument_list|,
name|latest_length
argument_list|,
operator|&
name|b
operator|->
name|current_line_modified
argument_list|,
operator|&
name|b
operator|->
name|current_line_latest
argument_list|,
name|b
operator|->
name|editor_cmd
argument_list|,
name|b
operator|->
name|config
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Our collection of diff output functions that get driven during the merge. */
end_comment

begin_decl_stmt
specifier|static
name|svn_diff_output_fns_t
name|file_merge_diff_output_fns
init|=
block|{
name|file_merge_output_common
block|,
name|file_merge_output_diff_modified
block|,
name|file_merge_output_diff_latest
block|,
name|file_merge_output_diff_common
block|,
name|file_merge_output_conflict
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_cl__merge_file
parameter_list|(
specifier|const
name|char
modifier|*
name|base_path
parameter_list|,
specifier|const
name|char
modifier|*
name|their_path
parameter_list|,
specifier|const
name|char
modifier|*
name|my_path
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_path
parameter_list|,
specifier|const
name|char
modifier|*
name|wc_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|svn_boolean_t
modifier|*
name|remains_in_conflict
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|diff_options
decl_stmt|;
name|apr_file_t
modifier|*
name|original_file
decl_stmt|;
name|apr_file_t
modifier|*
name|modified_file
decl_stmt|;
name|apr_file_t
modifier|*
name|latest_file
decl_stmt|;
name|apr_file_t
modifier|*
name|merged_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|merged_file_name
decl_stmt|;
name|struct
name|file_merge_baton
name|fmb
decl_stmt|;
name|svn_boolean_t
name|executable
decl_stmt|;
specifier|const
name|char
modifier|*
name|merged_path_local_style
decl_stmt|;
specifier|const
name|char
modifier|*
name|merged_rel_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|wc_path_local_style
decl_stmt|;
specifier|const
name|char
modifier|*
name|wc_rel_path
init|=
name|svn_dirent_skip_ancestor
argument_list|(
name|path_prefix
argument_list|,
name|wc_path
argument_list|)
decl_stmt|;
comment|/* PATH_PREFIX may not be an ancestor of WC_PATH, just use the      full WC_PATH in that case. */
if|if
condition|(
name|wc_rel_path
condition|)
name|wc_path_local_style
operator|=
name|svn_dirent_local_style
argument_list|(
name|wc_rel_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|wc_path_local_style
operator|=
name|svn_dirent_local_style
argument_list|(
name|wc_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Merging '%s'.\n"
argument_list|)
argument_list|,
name|wc_path_local_style
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|original_file
argument_list|,
name|base_path
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|modified_file
argument_list|,
name|their_path
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|latest_file
argument_list|,
name|my_path
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|merged_file
argument_list|,
operator|&
name|merged_file_name
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|diff_options
operator|=
name|svn_diff_file_options_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff3_2
argument_list|(
operator|&
name|diff
argument_list|,
name|base_path
argument_list|,
name|their_path
argument_list|,
name|my_path
argument_list|,
name|diff_options
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fmb
operator|.
name|original_file
operator|=
name|original_file
expr_stmt|;
name|fmb
operator|.
name|modified_file
operator|=
name|modified_file
expr_stmt|;
name|fmb
operator|.
name|latest_file
operator|=
name|latest_file
expr_stmt|;
name|fmb
operator|.
name|current_line_original
operator|=
literal|0
expr_stmt|;
name|fmb
operator|.
name|current_line_modified
operator|=
literal|0
expr_stmt|;
name|fmb
operator|.
name|current_line_latest
operator|=
literal|0
expr_stmt|;
name|fmb
operator|.
name|merged_file
operator|=
name|merged_file
expr_stmt|;
name|fmb
operator|.
name|remains_in_conflict
operator|=
name|FALSE
expr_stmt|;
name|fmb
operator|.
name|editor_cmd
operator|=
name|editor_cmd
expr_stmt|;
name|fmb
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|fmb
operator|.
name|abort_merge
operator|=
name|FALSE
expr_stmt|;
name|fmb
operator|.
name|scratch_pool
operator|=
name|scratch_pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_output
argument_list|(
name|diff
argument_list|,
operator|&
name|fmb
argument_list|,
operator|&
name|file_merge_diff_output_fns
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|original_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|modified_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|latest_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|merged_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start out assuming that conflicts remain. */
if|if
condition|(
name|remains_in_conflict
condition|)
operator|*
name|remains_in_conflict
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fmb
operator|.
name|abort_merge
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|merged_file_name
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Merge of '%s' aborted.\n"
argument_list|)
argument_list|,
name|wc_path_local_style
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_is_file_executable
argument_list|(
operator|&
name|executable
argument_list|,
name|merged_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|merged_rel_path
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|path_prefix
argument_list|,
name|merged_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|merged_rel_path
condition|)
name|merged_path_local_style
operator|=
name|svn_dirent_local_style
argument_list|(
name|merged_rel_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|merged_path_local_style
operator|=
name|svn_dirent_local_style
argument_list|(
name|merged_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR_W
argument_list|(
name|svn_io_copy_file
argument_list|(
name|merged_file_name
argument_list|,
name|merged_path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Could not write merged result to '%s', saved "
literal|"instead at '%s'.\n'%s' remains in conflict.\n"
argument_list|)
argument_list|,
name|merged_path_local_style
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|merged_file_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|wc_path_local_style
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_set_file_executable
argument_list|(
name|merged_path
argument_list|,
name|executable
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|merged_file_name
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The merge was not aborted and we could install the merged result. The    * file remains in conflict unless all conflicting sections were resolved. */
if|if
condition|(
name|remains_in_conflict
condition|)
operator|*
name|remains_in_conflict
operator|=
name|fmb
operator|.
name|remains_in_conflict
expr_stmt|;
if|if
condition|(
name|fmb
operator|.
name|remains_in_conflict
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Merge of '%s' completed (remains in conflict).\n"
argument_list|)
argument_list|,
name|wc_path_local_style
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Merge of '%s' completed.\n"
argument_list|)
argument_list|,
name|wc_path_local_style
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

