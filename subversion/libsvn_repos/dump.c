begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dump.c --- writing filesystem contents into a portable 'dumpfile' format.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_iter.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_private.h"
end_include

begin_define
define|#
directive|define
name|ARE_VALID_COPY_ARGS
parameter_list|(
name|p
parameter_list|,
name|r
parameter_list|)
value|((p)&& SVN_IS_VALID_REVNUM(r))
end_define

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/* Compute the delta between OLDROOT/OLDPATH and NEWROOT/NEWPATH and    store it into a new temporary file *TEMPFILE.  OLDROOT may be NULL,    in which case the delta will be computed against an empty file, as    per the svn_fs_get_file_delta_stream docstring.  Record the length    of the temporary file in *LEN, and rewind the file before    returning. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_delta
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|tempfile
parameter_list|,
name|svn_filesize_t
modifier|*
name|len
parameter_list|,
name|svn_fs_root_t
modifier|*
name|oldroot
parameter_list|,
specifier|const
name|char
modifier|*
name|oldpath
parameter_list|,
name|svn_fs_root_t
modifier|*
name|newroot
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|temp_stream
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
decl_stmt|;
name|svn_txdelta_window_handler_t
name|wh
decl_stmt|;
name|void
modifier|*
name|whb
decl_stmt|;
comment|/* Create a temporary file and open a stream to it. Note that we need      the file handle in order to rewind it. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|tempfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|temp_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
operator|*
name|tempfile
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Compute the delta and send it to the temporary file. */
name|SVN_ERR
argument_list|(
name|svn_fs_get_file_delta_stream
argument_list|(
operator|&
name|delta_stream
argument_list|,
name|oldroot
argument_list|,
name|oldpath
argument_list|,
name|newroot
argument_list|,
name|newpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_txdelta_to_svndiff3
argument_list|(
operator|&
name|wh
argument_list|,
operator|&
name|whb
argument_list|,
name|temp_stream
argument_list|,
literal|0
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_txstream
argument_list|(
name|delta_stream
argument_list|,
name|wh
argument_list|,
name|whb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the length of the temporary file and rewind it. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
operator|*
name|tempfile
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|svn_io_file_seek
argument_list|(
operator|*
name|tempfile
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** An editor which dumps node-data in 'dumpfile format' to a file. **/
end_comment

begin_comment
comment|/* Look, mom!  No file batons! */
end_comment

begin_struct
struct|struct
name|edit_baton
block|{
comment|/* The relpath which implicitly prepends all full paths coming into      this editor.  This will almost always be "".  */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The stream to dump to. */
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* Send feedback here, if non-NULL */
name|svn_repos_notify_func_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
comment|/* The fs revision root, so we can read the contents of paths. */
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
name|svn_revnum_t
name|current_rev
decl_stmt|;
comment|/* The fs, so we can grab historic information if needed. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* True if dumped nodes should output deltas instead of full text. */
name|svn_boolean_t
name|use_deltas
decl_stmt|;
comment|/* True if this "dump" is in fact a verify. */
name|svn_boolean_t
name|verify
decl_stmt|;
comment|/* The first revision dumped in this dumpstream. */
name|svn_revnum_t
name|oldest_dumped_rev
decl_stmt|;
comment|/* If not NULL, set to true if any references to revisions older than      OLDEST_DUMPED_REV were found in the dumpstream. */
name|svn_boolean_t
modifier|*
name|found_old_reference
decl_stmt|;
comment|/* If not NULL, set to true if any mergeinfo was dumped which contains      revisions older than OLDEST_DUMPED_REV. */
name|svn_boolean_t
modifier|*
name|found_old_mergeinfo
decl_stmt|;
comment|/* reusable buffer for writing file contents */
name|char
name|buffer
index|[
name|SVN__STREAM_CHUNK_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|bufsize
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dir_baton
block|{
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|parent_dir_baton
decl_stmt|;
comment|/* is this directory a new addition to this revision? */
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* has this directory been written to the output stream? */
name|svn_boolean_t
name|written_out
decl_stmt|;
comment|/* the repository relpath associated with this directory */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The comparison repository relpath and revision of this directory.      If both of these are valid, use them as a source against which to      compare the directory instead of the default comparison source of      PATH in the previous revision. */
specifier|const
name|char
modifier|*
name|cmp_path
decl_stmt|;
name|svn_revnum_t
name|cmp_rev
decl_stmt|;
comment|/* hash of paths that need to be deleted, though some -might- be      replaced.  maps const char * paths to this dir_baton.  (they're      full paths, because that's what the editor driver gives us.  but      really, they're all within this directory.) */
name|apr_hash_t
modifier|*
name|deleted_entries
decl_stmt|;
comment|/* pool to be used for deleting the hash items */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make a directory baton to represent the directory was path    (relative to EDIT_BATON's path) is PATH.     CMP_PATH/CMP_REV are the path/revision against which this directory    should be compared for changes.  If either is omitted (NULL for the    path, SVN_INVALID_REVNUM for the rev), just compare this directory    PATH against itself in the previous revision.     PARENT_DIR_BATON is the directory baton of this directory's parent,    or NULL if this is the top-level directory of the edit.  ADDED    indicated if this directory is newly added in this revision.    Perform all allocations in POOL.  */
end_comment

begin_function
specifier|static
name|struct
name|dir_baton
modifier|*
name|make_dir_baton
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|cmp_path
parameter_list|,
name|svn_revnum_t
name|cmp_rev
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|void
modifier|*
name|parent_dir_baton
parameter_list|,
name|svn_boolean_t
name|added
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_dir_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_db
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
comment|/* A path relative to nothing?  I don't think so. */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
operator|!
name|path
operator|||
name|pb
argument_list|)
expr_stmt|;
comment|/* Construct the full path of this node. */
if|if
condition|(
name|pb
condition|)
name|full_path
operator|=
name|svn_relpath_join
argument_list|(
name|eb
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|full_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|eb
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* Remove leading slashes from copyfrom paths. */
if|if
condition|(
name|cmp_path
condition|)
name|cmp_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|cmp_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_db
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
name|new_db
operator|->
name|parent_dir_baton
operator|=
name|pb
expr_stmt|;
name|new_db
operator|->
name|path
operator|=
name|full_path
expr_stmt|;
name|new_db
operator|->
name|cmp_path
operator|=
name|cmp_path
expr_stmt|;
name|new_db
operator|->
name|cmp_rev
operator|=
name|cmp_rev
expr_stmt|;
name|new_db
operator|->
name|added
operator|=
name|added
expr_stmt|;
name|new_db
operator|->
name|written_out
operator|=
name|FALSE
expr_stmt|;
name|new_db
operator|->
name|deleted_entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|new_db
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|new_db
return|;
block|}
end_function

begin_comment
comment|/* If the mergeinfo in MERGEINFO_STR refers to any revisions older than  * OLDEST_DUMPED_REV, issue a warning and set *FOUND_OLD_MERGEINFO to TRUE,  * otherwise leave *FOUND_OLD_MERGEINFO unchanged.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_mergeinfo_revisions
parameter_list|(
name|svn_boolean_t
modifier|*
name|found_old_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|mergeinfo_str
parameter_list|,
name|svn_revnum_t
name|oldest_dumped_rev
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|,
name|old_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo_str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|old_mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|oldest_dumped_rev
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|old_mergeinfo
argument_list|)
condition|)
block|{
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_warning
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|warning
operator|=
name|svn_repos_notify_warning_found_old_mergeinfo
expr_stmt|;
name|notify
operator|->
name|warning_str
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Mergeinfo referencing revision(s) prior "
literal|"to the oldest dumped revision (r%ld). "
literal|"Loading this dump may result in invalid "
literal|"mergeinfo."
argument_list|)
argument_list|,
name|oldest_dumped_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_old_mergeinfo
condition|)
operator|*
name|found_old_mergeinfo
operator|=
name|TRUE
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This helper is the main "meat" of the editor -- it does all the    work of writing a node record.     Write out a node record for PATH of type KIND under EB->FS_ROOT.    ACTION describes what is happening to the node (see enum svn_node_action).    Write record to writable EB->STREAM, using EB->BUFFER to write in chunks.     If the node was itself copied, IS_COPY is TRUE and the    path/revision of the copy source are in CMP_PATH/CMP_REV.  If    IS_COPY is FALSE, yet CMP_PATH/CMP_REV are valid, this node is part    of a copied subtree.   */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_node
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|enum
name|svn_node_action
name|action
parameter_list|,
name|svn_boolean_t
name|is_copy
parameter_list|,
specifier|const
name|char
modifier|*
name|cmp_path
parameter_list|,
name|svn_revnum_t
name|cmp_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|propstring
decl_stmt|;
name|svn_filesize_t
name|content_length
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_boolean_t
name|must_dump_text
init|=
name|FALSE
decl_stmt|,
name|must_dump_props
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|compare_path
init|=
name|path
decl_stmt|;
name|svn_revnum_t
name|compare_rev
init|=
name|eb
operator|->
name|current_rev
operator|-
literal|1
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|compare_root
init|=
name|NULL
decl_stmt|;
name|apr_file_t
modifier|*
name|delta_file
init|=
name|NULL
decl_stmt|;
comment|/* Maybe validate the path. */
if|if
condition|(
name|eb
operator|->
name|verify
operator|||
name|eb
operator|->
name|notify_func
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs__path_valid
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|eb
operator|->
name|notify_func
condition|)
block|{
name|char
name|errbuf
index|[
literal|512
index|]
decl_stmt|;
comment|/* ### svn_strerror() magic number  */
name|svn_repos_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_warning
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|warning
operator|=
name|svn_repos_notify_warning_invalid_fspath
expr_stmt|;
name|notify
operator|->
name|warning_str
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"E%06d: While validating fspath '%s': %s"
argument_list|)
argument_list|,
name|err
operator|->
name|apr_err
argument_list|,
name|path
argument_list|,
name|svn_err_best_message
argument_list|(
name|err
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|notify_func
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Return the error in addition to notifying about it. */
if|if
condition|(
name|eb
operator|->
name|verify
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
else|else
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write out metadata headers for this file node. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
literal|": %s\n"
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
literal|": file\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
literal|": dir\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove leading slashes from copyfrom paths. */
if|if
condition|(
name|cmp_path
condition|)
name|cmp_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|cmp_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Validate the comparison path/rev. */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|cmp_path
argument_list|,
name|cmp_rev
argument_list|)
condition|)
block|{
name|compare_path
operator|=
name|cmp_path
expr_stmt|;
name|compare_rev
operator|=
name|cmp_rev
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
name|svn_node_action_change
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": change\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* either the text or props changed, or possibly both. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|compare_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|eb
operator|->
name|fs_root
argument_list|)
argument_list|,
name|compare_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_props_changed
argument_list|(
operator|&
name|must_dump_props
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_contents_changed
argument_list|(
operator|&
name|must_dump_text
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|svn_node_action_replace
condition|)
block|{
if|if
condition|(
operator|!
name|is_copy
condition|)
block|{
comment|/* a simple delete+add, implied by a single 'replace' action. */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": replace\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* definitely need to dump all content for a replace. */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|must_dump_text
operator|=
name|TRUE
expr_stmt|;
name|must_dump_props
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* more complex:  delete original, then add-with-history.  */
comment|/* the path& kind headers have already been printed;  just              add a delete action, and end the current record.*/
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": delete\n\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* recurse:  print an additional add-with-history record. */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|kind
argument_list|,
name|svn_node_action_add
argument_list|,
name|is_copy
argument_list|,
name|compare_path
argument_list|,
name|compare_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we can leave this routine quietly now, don't need to dump              any content;  that was already done in the second record. */
name|must_dump_text
operator|=
name|FALSE
expr_stmt|;
name|must_dump_props
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|svn_node_action_delete
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": delete\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we can leave this routine quietly now, don't need to dump          any content. */
name|must_dump_text
operator|=
name|FALSE
expr_stmt|;
name|must_dump_props
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|svn_node_action_add
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
literal|": add\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_copy
condition|)
block|{
comment|/* Dump all contents for a simple 'add'. */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|must_dump_text
operator|=
name|TRUE
expr_stmt|;
name|must_dump_props
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|eb
operator|->
name|verify
operator|&&
name|cmp_rev
operator|<
name|eb
operator|->
name|oldest_dumped_rev
operator|&&
name|eb
operator|->
name|notify_func
condition|)
block|{
name|svn_repos_notify_t
modifier|*
name|notify
init|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_warning
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|warning
operator|=
name|svn_repos_notify_warning_found_old_reference
expr_stmt|;
name|notify
operator|->
name|warning_str
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Referencing data in revision %ld,"
literal|" which is older than the oldest"
literal|" dumped revision (r%ld).  Loading this dump"
literal|" into an empty repository"
literal|" will fail."
argument_list|)
argument_list|,
name|cmp_rev
argument_list|,
name|eb
operator|->
name|oldest_dumped_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|found_old_reference
condition|)
operator|*
name|eb
operator|->
name|found_old_reference
operator|=
name|TRUE
expr_stmt|;
name|eb
operator|->
name|notify_func
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
literal|": %ld\n"
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH
literal|": %s\n"
argument_list|,
name|cmp_rev
argument_list|,
name|cmp_path
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|compare_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|eb
operator|->
name|fs_root
argument_list|)
argument_list|,
name|compare_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Need to decide if the copied node had any extra textual or              property mods as well.  */
name|SVN_ERR
argument_list|(
name|svn_fs_props_changed
argument_list|(
operator|&
name|must_dump_props
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex_digest
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_contents_changed
argument_list|(
operator|&
name|must_dump_text
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_MD5
literal|": %s\n"
argument_list|,
name|hex_digest
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_SHA1
literal|": %s\n"
argument_list|,
name|hex_digest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|must_dump_text
operator|)
operator|&&
operator|(
operator|!
name|must_dump_props
operator|)
condition|)
block|{
comment|/* If we're not supposed to dump text or props, so be it, we can          just go home.  However, if either one needs to be dumped,          then our dumpstream format demands that at a *minimum*, we          see a lone "PROPS-END" as a divider between text and props          content within the content-block. */
name|len
operator|=
literal|2
expr_stmt|;
return|return
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
literal|"\n\n"
argument_list|,
operator|&
name|len
argument_list|)
return|;
comment|/* ### needed? */
block|}
comment|/*** Start prepping content to dump... ***/
comment|/* If we are supposed to dump properties, write out a property      length header and generate a stringbuf that contains those      property values here. */
if|if
condition|(
name|must_dump_props
condition|)
block|{
name|apr_hash_t
modifier|*
name|prophash
decl_stmt|,
modifier|*
name|oldhash
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|proplen
decl_stmt|;
name|svn_stream_t
modifier|*
name|propstream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|prophash
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a partial dump, then issue a warning if we dump mergeinfo          properties that refer to revisions older than the first revision          dumped. */
if|if
condition|(
operator|!
name|eb
operator|->
name|verify
operator|&&
name|eb
operator|->
name|notify_func
operator|&&
name|eb
operator|->
name|oldest_dumped_rev
operator|>
literal|1
condition|)
block|{
name|svn_string_t
modifier|*
name|mergeinfo_str
init|=
name|svn_hash_gets
argument_list|(
name|prophash
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergeinfo_str
condition|)
block|{
comment|/* An error in verifying the mergeinfo must not prevent dumping                  the data. Ignore any such error. */
name|svn_error_clear
argument_list|(
name|verify_mergeinfo_revisions
argument_list|(
name|eb
operator|->
name|found_old_mergeinfo
argument_list|,
name|mergeinfo_str
operator|->
name|data
argument_list|,
name|eb
operator|->
name|oldest_dumped_rev
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eb
operator|->
name|use_deltas
operator|&&
name|compare_root
condition|)
block|{
comment|/* Fetch the old property hash to diff against and output a header              saying that our property contents are a delta. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|oldhash
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_DELTA
literal|": true\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|oldhash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|propstring
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|propstream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|propstring
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write_incremental
argument_list|(
name|prophash
argument_list|,
name|oldhash
argument_list|,
name|propstream
argument_list|,
literal|"PROPS-END"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|propstream
argument_list|)
argument_list|)
expr_stmt|;
name|proplen
operator|=
name|propstring
operator|->
name|len
expr_stmt|;
name|content_length
operator|+=
name|proplen
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
literal|": %"
name|APR_SIZE_T_FMT
literal|"\n"
argument_list|,
name|proplen
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are supposed to dump text, write out a text length header      here, and an MD5 checksum (if available). */
if|if
condition|(
name|must_dump_text
operator|&&
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex_digest
decl_stmt|;
name|svn_filesize_t
name|textlen
decl_stmt|;
if|if
condition|(
name|eb
operator|->
name|use_deltas
condition|)
block|{
comment|/* Compute the text delta now and write it into a temporary              file, so that we can find its length.  Output a header              saying our text contents are a delta. */
name|SVN_ERR
argument_list|(
name|store_delta
argument_list|(
operator|&
name|delta_file
argument_list|,
operator|&
name|textlen
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA
literal|": true\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_root
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_MD5
literal|": %s\n"
argument_list|,
name|hex_digest
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|compare_root
argument_list|,
name|compare_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_SHA1
literal|": %s\n"
argument_list|,
name|hex_digest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just fetch the length of the file. */
name|SVN_ERR
argument_list|(
name|svn_fs_file_length
argument_list|(
operator|&
name|textlen
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|content_length
operator|+=
name|textlen
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH
literal|": %"
name|SVN_FILESIZE_T_FMT
literal|"\n"
argument_list|,
name|textlen
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_MD5
literal|": %s\n"
argument_list|,
name|hex_digest
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_digest
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_SHA1
literal|": %s\n"
argument_list|,
name|hex_digest
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 'Content-length:' is the last header before we dump the content,      and is the sum of the text and prop contents lengths.  We write      this only for the benefit of non-Subversion RFC-822 parsers. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
literal|": %"
name|SVN_FILESIZE_T_FMT
literal|"\n\n"
argument_list|,
name|content_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump property content if we're supposed to do so. */
if|if
condition|(
name|must_dump_props
condition|)
block|{
name|len
operator|=
name|propstring
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|propstring
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Dump text content */
if|if
condition|(
name|must_dump_text
operator|&&
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
condition|)
block|{
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
name|delta_file
condition|)
block|{
comment|/* Make sure to close the underlying file when the stream is              closed. */
name|contents
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|delta_file
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|eb
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|svn_stream_disown
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
literal|2
expr_stmt|;
return|return
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|stream
argument_list|,
literal|"\n\n"
argument_list|,
operator|&
name|len
argument_list|)
return|;
comment|/* ### needed? */
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
operator|*
name|root_baton
operator|=
name|make_dir_baton
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|mypath
init|=
name|apr_pstrdup
argument_list|(
name|pb
operator|->
name|pool
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|/* remember this path needs to be deleted. */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|mypath
argument_list|,
name|pb
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_boolean_t
name|is_copy
init|=
name|FALSE
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
init|=
name|make_dir_baton
argument_list|(
name|path
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|eb
argument_list|,
name|pb
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* This might be a replacement -- is the path already deleted? */
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Detect an add-with-history. */
name|is_copy
operator|=
name|ARE_VALID_COPY_ARGS
argument_list|(
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|)
expr_stmt|;
comment|/* Dump the node. */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|svn_node_dir
argument_list|,
name|val
condition|?
name|svn_node_action_replace
else|:
name|svn_node_action_add
argument_list|,
name|is_copy
argument_list|,
name|is_copy
condition|?
name|copyfrom_path
else|:
name|NULL
argument_list|,
name|is_copy
condition|?
name|copyfrom_rev
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
comment|/* Delete the path, it's now been dumped. */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_db
operator|->
name|written_out
operator|=
name|TRUE
expr_stmt|;
operator|*
name|child_baton
operator|=
name|new_db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|new_db
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmp_path
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|cmp_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* If the parent directory has explicit comparison path and rev,      record the same for this one. */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|pb
operator|->
name|cmp_path
argument_list|,
name|pb
operator|->
name|cmp_rev
argument_list|)
condition|)
block|{
name|cmp_path
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|cmp_path
argument_list|,
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|cmp_rev
operator|=
name|pb
operator|->
name|cmp_rev
expr_stmt|;
block|}
name|new_db
operator|=
name|make_dir_baton
argument_list|(
name|path
argument_list|,
name|cmp_path
argument_list|,
name|cmp_rev
argument_list|,
name|eb
argument_list|,
name|pb
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|new_db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_entries
decl_stmt|;
comment|/* Sort entries lexically instead of as paths. Even though the entries    * are full paths they're all in the same directory (see comment in struct    * dir_baton definition). So we really want to sort by basename, in which    * case the lexical sort function is more efficient. */
name|sorted_entries
operator|=
name|svn_sort__hash
argument_list|(
name|db
operator|->
name|deleted_entries
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_entries
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_entries
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|.
name|key
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* By sending 'svn_node_unknown', the Node-kind: header simply won't          be written out.  No big deal at all, really.  The loader          shouldn't care.  */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_node_action_delete
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_boolean_t
name|is_copy
init|=
name|FALSE
decl_stmt|;
comment|/* This might be a replacement -- is the path already deleted? */
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Detect add-with-history. */
name|is_copy
operator|=
name|ARE_VALID_COPY_ARGS
argument_list|(
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|)
expr_stmt|;
comment|/* Dump the node. */
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|svn_node_file
argument_list|,
name|val
condition|?
name|svn_node_action_replace
else|:
name|svn_node_action_add
argument_list|,
name|is_copy
argument_list|,
name|is_copy
condition|?
name|copyfrom_path
else|:
name|NULL
argument_list|,
name|is_copy
condition|?
name|copyfrom_rev
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
comment|/* delete the path, it's now been dumped. */
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|deleted_entries
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|NULL
expr_stmt|;
comment|/* muhahahaha */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|ancestor_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmp_path
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|cmp_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* If the parent directory has explicit comparison path and rev,      record the same for this one. */
if|if
condition|(
name|ARE_VALID_COPY_ARGS
argument_list|(
name|pb
operator|->
name|cmp_path
argument_list|,
name|pb
operator|->
name|cmp_rev
argument_list|)
condition|)
block|{
name|cmp_path
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|cmp_path
argument_list|,
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|cmp_rev
operator|=
name|pb
operator|->
name|cmp_rev
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|path
argument_list|,
name|svn_node_file
argument_list|,
name|svn_node_action_change
argument_list|,
name|FALSE
argument_list|,
name|cmp_path
argument_list|,
name|cmp_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|NULL
expr_stmt|;
comment|/* muhahahaha again */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
comment|/* This function is what distinguishes between a directory that is      opened to merely get somewhere, vs. one that is opened because it      *actually* changed by itself.  */
if|if
condition|(
operator|!
name|db
operator|->
name|written_out
condition|)
block|{
name|SVN_ERR
argument_list|(
name|dump_node
argument_list|(
name|eb
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_node_action_change
argument_list|,
name|FALSE
argument_list|,
name|db
operator|->
name|cmp_path
argument_list|,
name|db
operator|->
name|cmp_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|written_out
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|current_rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_node_proplist
argument_list|(
name|props
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|current_rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
name|kind
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_filename
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|fs_root
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|eb
operator|->
name|current_rev
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|fs_root
argument_list|,
name|eb
operator|->
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|fs_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|file_stream
argument_list|,
operator|&
name|tmp_filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|file_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|tmp_filename
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dump_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|to_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|root_path
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_boolean_t
modifier|*
name|found_old_reference
parameter_list|,
name|svn_boolean_t
modifier|*
name|found_old_mergeinfo
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|custom_close_directory
function_decl|)
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_revnum_t
name|oldest_dumped_rev
parameter_list|,
name|svn_boolean_t
name|use_deltas
parameter_list|,
name|svn_boolean_t
name|verify
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Allocate an edit baton to be stored in every directory baton.      Set it up for the directory baton we create here, which is the      root baton. */
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
name|svn_delta_editor_t
modifier|*
name|dump_editor
init|=
name|svn_delta_default_editor
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Set up the edit baton. */
name|eb
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|eb
operator|->
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|eb
operator|->
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|eb
operator|->
name|oldest_dumped_rev
operator|=
name|oldest_dumped_rev
expr_stmt|;
name|eb
operator|->
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|eb
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|eb
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|root_path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
operator|(
name|eb
operator|->
name|fs_root
operator|)
argument_list|,
name|fs
argument_list|,
name|to_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|eb
operator|->
name|current_rev
operator|=
name|to_rev
expr_stmt|;
name|eb
operator|->
name|use_deltas
operator|=
name|use_deltas
expr_stmt|;
name|eb
operator|->
name|verify
operator|=
name|verify
expr_stmt|;
name|eb
operator|->
name|found_old_reference
operator|=
name|found_old_reference
expr_stmt|;
name|eb
operator|->
name|found_old_mergeinfo
operator|=
name|found_old_mergeinfo
expr_stmt|;
comment|/* Set up the editor. */
name|dump_editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|dump_editor
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|dump_editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|dump_editor
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
if|if
condition|(
name|custom_close_directory
condition|)
name|dump_editor
operator|->
name|close_directory
operator|=
name|custom_close_directory
expr_stmt|;
else|else
name|dump_editor
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|dump_editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|dump_editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|dump_editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|editor
operator|=
name|dump_editor
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|shim_callbacks
operator|->
name|fetch_baton
operator|=
name|eb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor__insert_shims
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|*
name|editor
argument_list|,
operator|*
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|shim_callbacks
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** The main dumping routine, svn_repos_dump_fs. **/
end_comment

begin_comment
comment|/* Helper for svn_repos_dump_fs.     Write a revision record of REV in FS to writable STREAM, using POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revision_record
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|encoded_prophash
decl_stmt|;
name|apr_time_t
name|timetemp
decl_stmt|;
name|svn_string_t
modifier|*
name|datevalue
decl_stmt|;
name|svn_stream_t
modifier|*
name|propstream
decl_stmt|;
comment|/* Read the revision props even if we're aren't going to dump      them for verification purposes */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run revision date properties through the time conversion to      canonicalize them. */
comment|/* ### Remove this when it is no longer needed for sure. */
name|datevalue
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|datevalue
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|timetemp
argument_list|,
name|datevalue
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|datevalue
operator|=
name|svn_string_create
argument_list|(
name|svn_time_to_cstring
argument_list|(
name|timetemp
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|datevalue
argument_list|)
expr_stmt|;
block|}
name|encoded_prophash
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|propstream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|encoded_prophash
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|props
argument_list|,
name|propstream
argument_list|,
literal|"PROPS-END"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|propstream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### someday write a revision-content-checksum */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
literal|": %ld\n"
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
literal|": %"
name|APR_SIZE_T_FMT
literal|"\n"
argument_list|,
name|encoded_prophash
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out a regular Content-length header for the benefit of      non-Subversion RFC-822 parsers. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
literal|": %"
name|APR_SIZE_T_FMT
literal|"\n\n"
argument_list|,
name|encoded_prophash
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|encoded_prophash
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|encoded_prophash
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
return|return
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The main dumper. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_repos_dump_fs3
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
name|svn_boolean_t
name|use_deltas
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|dump_editor
decl_stmt|;
name|void
modifier|*
name|dump_edit_baton
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|i
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
name|int
name|version
decl_stmt|;
name|svn_boolean_t
name|found_old_reference
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|found_old_mergeinfo
init|=
name|FALSE
decl_stmt|;
name|svn_repos_notify_t
modifier|*
name|notify
decl_stmt|;
comment|/* Determine the current youngest revision of the filesystem. */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use default vals if necessary. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
condition|)
name|start_rev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
condition|)
name|end_rev
operator|=
name|youngest
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
name|stream
operator|=
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Validate the revisions. */
if|if
condition|(
name|start_rev
operator|>
name|end_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Start revision %ld"
literal|" is greater than end revision %ld"
argument_list|)
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|)
return|;
if|if
condition|(
name|end_rev
operator|>
name|youngest
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"End revision %ld is invalid "
literal|"(youngest revision is %ld)"
argument_list|)
argument_list|,
name|end_rev
argument_list|,
name|youngest
argument_list|)
return|;
if|if
condition|(
operator|(
name|start_rev
operator|==
literal|0
operator|)
operator|&&
name|incremental
condition|)
name|incremental
operator|=
name|FALSE
expr_stmt|;
comment|/* revision 0 looks the same regardless of                             whether or not this is an incremental                             dump, so just simplify things. */
comment|/* Write out the UUID. */
name|SVN_ERR
argument_list|(
name|svn_fs_get_uuid
argument_list|(
name|fs
argument_list|,
operator|&
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're not using deltas, use the previous version, for      compatibility with svn 1.0.x. */
name|version
operator|=
name|SVN_REPOS_DUMPFILE_FORMAT_VERSION
expr_stmt|;
if|if
condition|(
operator|!
name|use_deltas
condition|)
name|version
operator|--
expr_stmt|;
comment|/* Write out "general" metadata for the dumpfile.  In this case, a      magic header followed by a dumpfile format version. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_MAGIC_HEADER
literal|": %d\n\n"
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_UUID
literal|": %s\n\n"
argument_list|,
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a notify object that we can reuse in the loop. */
if|if
condition|(
name|notify_func
condition|)
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_dump_rev_end
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Main loop:  we're going to dump revision i.  */
for|for
control|(
name|i
operator|=
name|start_rev
init|;
name|i
operator|<=
name|end_rev
condition|;
name|i
operator|++
control|)
block|{
name|svn_revnum_t
name|from_rev
decl_stmt|,
name|to_rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|to_root
decl_stmt|;
name|svn_boolean_t
name|use_deltas_for_rev
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Check for cancellation. */
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special-case the initial revision dump: it needs to contain          *all* nodes, because it's the foundation of all future          revisions in the dumpfile. */
if|if
condition|(
operator|(
name|i
operator|==
name|start_rev
operator|)
operator|&&
operator|(
operator|!
name|incremental
operator|)
condition|)
block|{
comment|/* Special-special-case a dump of revision 0. */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* Just write out the one revision 0 record and move on.                  The parser might want to use its properties. */
name|SVN_ERR
argument_list|(
name|write_revision_record
argument_list|(
name|stream
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|to_rev
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop_end
goto|;
block|}
comment|/* Compare START_REV to revision 0, so that everything              appears to be added.  */
name|from_rev
operator|=
literal|0
expr_stmt|;
name|to_rev
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
comment|/* In the normal case, we want to compare consecutive revs. */
name|from_rev
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|to_rev
operator|=
name|i
expr_stmt|;
block|}
comment|/* Write the revision record. */
name|SVN_ERR
argument_list|(
name|write_revision_record
argument_list|(
name|stream
argument_list|,
name|fs
argument_list|,
name|to_rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the editor which dumps nodes to a file.  Regardless of          what we've been told, don't use deltas for the first rev of a          non-incremental dump. */
name|use_deltas_for_rev
operator|=
name|use_deltas
operator|&&
operator|(
name|incremental
operator|||
name|i
operator|!=
name|start_rev
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dump_editor
argument_list|(
operator|&
name|dump_editor
argument_list|,
operator|&
name|dump_edit_baton
argument_list|,
name|fs
argument_list|,
name|to_rev
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|&
name|found_old_reference
argument_list|,
operator|&
name|found_old_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|start_rev
argument_list|,
name|use_deltas_for_rev
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Drive the editor in one way or another. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|to_root
argument_list|,
name|fs
argument_list|,
name|to_rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is the first revision of a non-incremental dump,          we're in for a full tree dump.  Otherwise, we want to simply          replay the revision.  */
if|if
condition|(
operator|(
name|i
operator|==
name|start_rev
operator|)
operator|&&
operator|(
operator|!
name|incremental
operator|)
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|from_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|from_root
argument_list|,
name|fs
argument_list|,
name|from_rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_dir_delta2
argument_list|(
name|from_root
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|to_root
argument_list|,
literal|""
argument_list|,
name|dump_editor
argument_list|,
name|dump_edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
comment|/* don't send text-deltas */
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
comment|/* don't send entry props */
name|FALSE
argument_list|,
comment|/* don't ignore ancestry */
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_repos_replay2
argument_list|(
name|to_root
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|FALSE
argument_list|,
name|dump_editor
argument_list|,
name|dump_edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* While our editor close_edit implementation is a no-op, we still              do this for completeness. */
name|SVN_ERR
argument_list|(
name|dump_editor
operator|->
name|close_edit
argument_list|(
name|dump_edit_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|loop_end
label|:
if|if
condition|(
name|notify_func
condition|)
block|{
name|notify
operator|->
name|revision
operator|=
name|to_rev
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|notify_func
condition|)
block|{
comment|/* Did we issue any warnings about references to revisions older than          the oldest dumped revision?  If so, then issue a final generic          warning, since the inline warnings already issued might easily be          missed. */
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_dump_end
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_old_reference
condition|)
block|{
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_warning
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|warning
operator|=
name|svn_repos_notify_warning_found_old_reference
expr_stmt|;
name|notify
operator|->
name|warning_str
operator|=
name|_
argument_list|(
literal|"The range of revisions dumped "
literal|"contained references to "
literal|"copy sources outside that "
literal|"range."
argument_list|)
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* Ditto if we issued any warnings about old revisions referenced          in dumped mergeinfo. */
if|if
condition|(
name|found_old_mergeinfo
condition|)
block|{
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_warning
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|warning
operator|=
name|svn_repos_notify_warning_found_old_mergeinfo
expr_stmt|;
name|notify
operator|->
name|warning_str
operator|=
name|_
argument_list|(
literal|"The range of revisions dumped "
literal|"contained mergeinfo "
literal|"which reference revisions outside "
literal|"that range."
argument_list|)
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/* verify, based on dump */
end_comment

begin_comment
comment|/* Creating a new revision that changes /A/B/E/bravo means creating new    directory listings for /, /A, /A/B, and /A/B/E in the new revision, with    each entry not changed in the new revision a link back to the entry in a    previous revision.  svn_repos_replay()ing a revision does not verify that    those links are correct.     For paths actually changed in the revision we verify, we get directory    contents or file length twice: once in the dump editor, and once here.    We could create a new verify baton, store in it the changed paths, and    skip those here, but that means building an entire wrapper editor and    managing two levels of batons.  The impact from checking these entries    twice should be minimal, while the code to avoid it is not. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_directory_entry
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|baton
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
operator|(
name|svn_fs_dirent_t
operator|*
operator|)
name|val
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|svn_relpath_join
argument_list|(
name|db
operator|->
name|path
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|svn_filesize_t
name|len
decl_stmt|;
comment|/* since we can't access the directory entries directly by their ID,      we need to navigate from the FS_ROOT to them (relatively expensive      because we may start at a never rev than the last change to node). */
switch|switch
condition|(
name|dirent
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_dir
case|:
comment|/* Getting this directory's contents is enough to ensure that our        link to it is correct. */
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|dirents
argument_list|,
name|db
operator|->
name|edit_baton
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_file
case|:
comment|/* Getting this file's size is enough to ensure that our link to it        is correct. */
name|SVN_ERR
argument_list|(
name|svn_fs_file_length
argument_list|(
operator|&
name|len
argument_list|,
name|db
operator|->
name|edit_baton
operator|->
name|fs_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected node kind %d for '%s'"
argument_list|)
argument_list|,
name|dirent
operator|->
name|kind
argument_list|,
name|path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|dirents
argument_list|,
name|db
operator|->
name|edit_baton
operator|->
name|fs_root
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_iter_apr_hash
argument_list|(
name|NULL
argument_list|,
name|dirents
argument_list|,
name|verify_directory_entry
argument_list|,
name|dir_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|close_directory
argument_list|(
name|dir_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton type used for forwarding notifications from FS API to REPOS API. */
end_comment

begin_struct
struct|struct
name|verify_fs2_notify_func_baton_t
block|{
comment|/* notification function to call (must not be NULL) */
name|svn_repos_notify_func_t
name|notify_func
decl_stmt|;
comment|/* baton to use for it */
name|void
modifier|*
name|notify_baton
decl_stmt|;
comment|/* type of notification to send (we will simply plug in the revision) */
name|svn_repos_notify_t
modifier|*
name|notify
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward the notification to BATON. */
end_comment

begin_function
specifier|static
name|void
name|verify_fs2_notify_func
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|verify_fs2_notify_func_baton_t
modifier|*
name|notify_baton
init|=
name|baton
decl_stmt|;
name|notify_baton
operator|->
name|notify
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|notify_baton
operator|->
name|notify_func
argument_list|(
name|notify_baton
operator|->
name|notify_baton
argument_list|,
name|notify_baton
operator|->
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_verify_fs2
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_repos_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_repos_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_fs_progress_notify_func_t
name|verify_notify
init|=
name|NULL
decl_stmt|;
name|struct
name|verify_fs2_notify_func_baton_t
modifier|*
name|verify_notify_baton
init|=
name|NULL
decl_stmt|;
comment|/* Determine the current youngest revision of the filesystem. */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use default vals if necessary. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
condition|)
name|start_rev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
condition|)
name|end_rev
operator|=
name|youngest
expr_stmt|;
comment|/* Validate the revisions. */
if|if
condition|(
name|start_rev
operator|>
name|end_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Start revision %ld"
literal|" is greater than end revision %ld"
argument_list|)
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|)
return|;
if|if
condition|(
name|end_rev
operator|>
name|youngest
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REPOS_BAD_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"End revision %ld is invalid "
literal|"(youngest revision is %ld)"
argument_list|)
argument_list|,
name|end_rev
argument_list|,
name|youngest
argument_list|)
return|;
comment|/* Create a notify object that we can reuse within the loop and a      forwarding structure for notifications from inside svn_fs_verify(). */
if|if
condition|(
name|notify_func
condition|)
block|{
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_verify_rev_end
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|verify_notify
operator|=
name|verify_fs2_notify_func
expr_stmt|;
name|verify_notify_baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|verify_notify_baton
argument_list|)
argument_list|)
expr_stmt|;
name|verify_notify_baton
operator|->
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|verify_notify_baton
operator|->
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|verify_notify_baton
operator|->
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_verify_rev_structure
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Verify global metadata and backend-specific data first. */
name|SVN_ERR
argument_list|(
name|svn_fs_verify
argument_list|(
name|svn_fs_path
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_fs_config
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|verify_notify
argument_list|,
name|verify_notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|dump_editor
decl_stmt|;
name|void
modifier|*
name|dump_edit_baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|cancel_editor
decl_stmt|;
name|void
modifier|*
name|cancel_edit_baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|to_root
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get cancellable dump editor, but with our close_directory handler. */
name|SVN_ERR
argument_list|(
name|get_dump_editor
argument_list|(
operator|&
name|dump_editor
argument_list|,
operator|&
name|dump_edit_baton
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
literal|""
argument_list|,
name|svn_stream_empty
argument_list|(
name|iterpool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|verify_close_directory
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|start_rev
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
comment|/* use_deltas, verify */
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta_get_cancellation_editor
argument_list|(
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|dump_editor
argument_list|,
name|dump_edit_baton
argument_list|,
operator|&
name|cancel_editor
argument_list|,
operator|&
name|cancel_edit_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|to_root
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_verify_root
argument_list|(
name|to_root
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_replay2
argument_list|(
name|to_root
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|FALSE
argument_list|,
name|cancel_editor
argument_list|,
name|cancel_edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* While our editor close_edit implementation is a no-op, we still          do this for completeness. */
name|SVN_ERR
argument_list|(
name|cancel_editor
operator|->
name|close_edit
argument_list|(
name|cancel_edit_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
block|{
name|notify
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We're done. */
if|if
condition|(
name|notify_func
condition|)
block|{
name|notify
operator|=
name|svn_repos_notify_create
argument_list|(
name|svn_repos_notify_verify_end
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* Per-backend verification. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

