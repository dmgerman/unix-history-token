begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * replay.c:   an editor driver for changes made in a given revision  *             or transaction  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_delta_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Backstory ***/
end_comment

begin_comment
comment|/* The year was 2003.  Subversion usage was rampant in the world, and    there was a rapidly growing issues database to prove it.  To make    matters worse, svn_repos_dir_delta() had simply outgrown itself.    No longer content to simply describe the differences between two    trees, the function had been slowly bearing the added    responsibility of representing the actions that had been taken to    cause those differences -- a burden it was never meant to bear.    Now grown into a twisted mess of razor-sharp metal and glass, and    trembling with a sort of momentarily stayed spring force,    svn_repos_dir_delta was a timebomb poised for total annihilation of    the American Midwest.     Subversion needed a change.     Changes, in fact.  And not just in the literary segue sense.  What    Subversion desperately needed was a new mechanism solely    responsible for replaying repository actions back to some    interested party -- to translate and retransmit the contents of the    Berkeley 'changes' database file. */
end_comment

begin_comment
comment|/*** Overview ***/
end_comment

begin_comment
comment|/* The filesystem keeps a record of high-level actions that affect the    files and directories in itself.  The 'changes' table records    additions, deletions, textual and property modifications, and so    on.  The goal of the functions in this file is to examine those    change records, and use them to drive an editor interface in such a    way as to effectively replay those actions.     This is critically different than what svn_repos_dir_delta() was    designed to do.  That function describes, in the simplest way it    can, how to transform one tree into another.  It doesn't care    whether or not this was the same way a user might have done this    transformation.  More to the point, it doesn't care if this is how    those differences *did* come into being.  And it is for this reason    that it cannot be relied upon for tasks such as the repository    dumpfile-generation code, which is supposed to represent not    changes, but actions that cause changes.     So, what's the plan here?     First, we fetch the changes for a particular revision or    transaction.  We get these as an array, sorted chronologically.    From this array we will build a hash, keyed on the path associated    with each change item, and whose values are arrays of changes made    to that path, again preserving the chronological ordering.     Once our hash is built, we then sort all the keys of the hash (the    paths) using a depth-first directory sort routine.     Finally, we drive an editor, moving down our list of sorted paths,    and manufacturing any intermediate editor calls (directory openings    and closures) needed to navigate between each successive path.  For    each path, we replay the sorted actions that occurred at that path.     When we've finished the editor drive, we should have fully replayed    the filesystem events that occurred in that revision or transaction    (though not necessarily in the same order in which they    occurred). */
end_comment

begin_comment
comment|/* #define USE_EV2_IMPL */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Helper functions. ***/
end_comment

begin_comment
comment|/* Information for an active copy, that is a directory which we are currently    working on and which was added with history. */
end_comment

begin_struct
struct|struct
name|copy_info
block|{
comment|/* Destination relpath (relative to the root of the  . */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Copy source path (expressed as an absolute FS path) or revision.      NULL and SVN_INVALID_REVNUM if this is an add without history,      nested inside an add with history. */
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|path_driver_cb_baton
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
comment|/* The root of the revision we're replaying. */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
comment|/* The root of the previous revision.  If this is non-NULL it means that      we are supposed to generate props and text deltas relative to it. */
name|svn_fs_root_t
modifier|*
name|compare_root
decl_stmt|;
name|apr_hash_t
modifier|*
name|changed_paths
decl_stmt|;
name|svn_repos_authz_func_t
name|authz_read_func
decl_stmt|;
name|void
modifier|*
name|authz_read_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_path
decl_stmt|;
comment|/* relpath */
name|svn_revnum_t
name|low_water_mark
decl_stmt|;
comment|/* Stack of active copy operations. */
name|apr_array_header_t
modifier|*
name|copies
decl_stmt|;
comment|/* The global pool for this replay operation. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Recursively traverse EDIT_PATH (as it exists under SOURCE_ROOT) emitting    the appropriate editor calls to add it and its children without any    history.  This is meant to be used when either a subset of the tree    has been ignored and we need to copy something from that subset to    the part of the tree we do care about, or if a subset of the tree is    unavailable because of authz and we need to use it as the source of    a copy. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_subdir
parameter_list|(
name|svn_fs_root_t
modifier|*
name|source_root
parameter_list|,
name|svn_fs_root_t
modifier|*
name|target_root
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|source_fspath
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|,
modifier|*
name|phi
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_directory
argument_list|(
name|edit_path
argument_list|,
name|parent_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|target_root
argument_list|,
name|edit_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|props
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|apr_hash_next
argument_list|(
name|phi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|phi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_dir_prop
argument_list|(
operator|*
name|dir_baton
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We have to get the dirents from the source path, not the target,      because we want nested copies from *readable* paths to be handled by      path_driver_cb_func, not add_subdir (in order to preserve history). */
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|dirents
argument_list|,
name|source_root
argument_list|,
name|source_fspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|svn_boolean_t
name|readable
init|=
name|TRUE
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dent
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_edit_path
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|dent
operator|=
name|val
expr_stmt|;
name|new_edit_path
operator|=
name|svn_relpath_join
argument_list|(
name|edit_path
argument_list|,
name|dent
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* If a file or subdirectory of the copied directory is listed as a          changed path (because it was modified after the copy but before the          commit), we remove it from the changed_paths hash so that future          calls to path_driver_cb_func will ignore it. */
name|change
operator|=
name|svn_hash_gets
argument_list|(
name|changed_paths
argument_list|,
name|new_edit_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|changed_paths
argument_list|,
name|new_edit_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If it's a delete, skip this entry. */
if|if
condition|(
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_delete
condition|)
continue|continue;
comment|/* If it's a replacement, check for copyfrom info (if we              don't have it already. */
if|if
condition|(
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_replace
condition|)
block|{
if|if
condition|(
operator|!
name|change
operator|->
name|copyfrom_known
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_copied_from
argument_list|(
operator|&
name|change
operator|->
name|copyfrom_rev
argument_list|,
operator|&
name|change
operator|->
name|copyfrom_path
argument_list|,
name|target_root
argument_list|,
name|new_edit_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|change
operator|->
name|copyfrom_known
operator|=
name|TRUE
expr_stmt|;
block|}
name|copyfrom_path
operator|=
name|change
operator|->
name|copyfrom_path
expr_stmt|;
name|copyfrom_rev
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
block|}
if|if
condition|(
name|authz_read_func
condition|)
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|target_root
argument_list|,
name|new_edit_path
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
continue|continue;
if|if
condition|(
name|dent
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|new_source_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_source_fspath
decl_stmt|;
name|void
modifier|*
name|new_dir_baton
decl_stmt|;
if|if
condition|(
name|copyfrom_path
condition|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_root_fs
argument_list|(
name|source_root
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|new_source_root
argument_list|,
name|fs
argument_list|,
name|copyfrom_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_source_fspath
operator|=
name|copyfrom_path
expr_stmt|;
block|}
else|else
block|{
name|new_source_root
operator|=
name|source_root
expr_stmt|;
name|new_source_fspath
operator|=
name|svn_fspath__join
argument_list|(
name|source_fspath
argument_list|,
name|dent
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* ### authz considerations?            *            * I think not; when path_driver_cb_func() calls add_subdir(), it            * passes SOURCE_ROOT and SOURCE_FSPATH that are unreadable.            */
if|if
condition|(
name|change
operator|&&
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_replace
operator|&&
name|copyfrom_path
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_directory
argument_list|(
name|new_edit_path
argument_list|,
operator|*
name|dir_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|subpool
argument_list|,
operator|&
name|new_dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|add_subdir
argument_list|(
name|new_source_root
argument_list|,
name|target_root
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|new_edit_path
argument_list|,
operator|*
name|dir_baton
argument_list|,
name|new_source_fspath
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|changed_paths
argument_list|,
name|subpool
argument_list|,
operator|&
name|new_dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_directory
argument_list|(
name|new_dir_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dent
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_txdelta_window_handler_t
name|delta_handler
decl_stmt|;
name|void
modifier|*
name|delta_handler_baton
decl_stmt|,
modifier|*
name|file_baton
decl_stmt|;
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_file
argument_list|(
name|new_edit_path
argument_list|,
operator|*
name|dir_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|target_root
argument_list|,
name|new_edit_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|props
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|apr_hash_next
argument_list|(
name|phi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_hash_this
argument_list|(
name|phi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|,
operator|&
name|delta_handler
argument_list|,
operator|&
name|delta_handler_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_file_delta_stream
argument_list|(
operator|&
name|delta_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|target_root
argument_list|,
name|new_edit_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_txstream
argument_list|(
name|delta_stream
argument_list|,
name|delta_handler
argument_list|,
name|delta_handler_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|target_root
argument_list|,
name|new_edit_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given PATH deleted under ROOT, return in READABLE whether the path was    readable prior to the deletion.  Consult COPIES (a stack of 'struct    copy_info') and AUTHZ_READ_FUNC. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|was_readable
parameter_list|(
name|svn_boolean_t
modifier|*
name|readable
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_array_header_t
modifier|*
name|copies
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|inquire_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|inquire_path
decl_stmt|;
name|struct
name|copy_info
modifier|*
name|info
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
comment|/* Short circuit. */
if|if
condition|(
operator|!
name|authz_read_func
condition|)
block|{
operator|*
name|readable
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|copies
operator|->
name|nelts
operator|!=
literal|0
condition|)
name|info
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|copies
argument_list|,
name|copies
operator|->
name|nelts
operator|-
literal|1
argument_list|,
expr|struct
name|copy_info
operator|*
argument_list|)
expr_stmt|;
comment|/* Are we under a copy? */
if|if
condition|(
name|info
operator|&&
operator|(
name|relpath
operator|=
name|svn_relpath_skip_ancestor
argument_list|(
name|info
operator|->
name|path
argument_list|,
name|path
argument_list|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|inquire_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
argument_list|,
name|info
operator|->
name|copyfrom_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|inquire_path
operator|=
name|svn_fspath__join
argument_list|(
name|info
operator|->
name|copyfrom_path
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute the revision that ROOT is based on.  (Note that ROOT is not          r0's root, since this function is only called for deletions.)          ### Need a more succinct way to express this */
name|svn_revnum_t
name|inquire_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
if|if
condition|(
name|svn_fs_is_txn_root
argument_list|(
name|root
argument_list|)
condition|)
name|inquire_rev
operator|=
name|svn_fs_txn_root_base_revision
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_is_revision_root
argument_list|(
name|root
argument_list|)
condition|)
name|inquire_rev
operator|=
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
operator|-
literal|1
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|inquire_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|inquire_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
argument_list|,
name|inquire_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|inquire_path
operator|=
name|path
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
name|readable
argument_list|,
name|inquire_root
argument_list|,
name|inquire_path
argument_list|,
name|authz_read_baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Initialize COPYFROM_ROOT, COPYFROM_PATH, and COPYFROM_REV with the    revision root, fspath, and revnum of the copyfrom of CHANGE, which    corresponds to PATH under ROOT.  If the copyfrom info is valid    (i.e., is not (NULL, SVN_INVALID_REVNUM)), then initialize SRC_READABLE    too, consulting AUTHZ_READ_FUNC and AUTHZ_READ_BATON if provided.     NOTE: If the copyfrom information in CHANGE is marked as unknown    (meaning, its ->copyfrom_rev and ->copyfrom_path cannot be    trusted), this function will also update those members of the    CHANGE structure to carry accurate copyfrom information.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fill_copyfrom
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|copyfrom_root
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
modifier|*
name|copyfrom_rev
parameter_list|,
name|svn_boolean_t
modifier|*
name|src_readable
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|svn_fs_path_change2_t
modifier|*
name|change
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|change
operator|->
name|copyfrom_known
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_copied_from
argument_list|(
operator|&
operator|(
name|change
operator|->
name|copyfrom_rev
operator|)
argument_list|,
operator|&
operator|(
name|change
operator|->
name|copyfrom_path
operator|)
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|change
operator|->
name|copyfrom_known
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|copyfrom_rev
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
operator|*
name|copyfrom_path
operator|=
name|change
operator|->
name|copyfrom_path
expr_stmt|;
if|if
condition|(
operator|*
name|copyfrom_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
name|copyfrom_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
argument_list|,
operator|*
name|copyfrom_rev
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
name|src_readable
argument_list|,
operator|*
name|copyfrom_root
argument_list|,
operator|*
name|copyfrom_path
argument_list|,
name|authz_read_baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|src_readable
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|copyfrom_root
operator|=
name|NULL
expr_stmt|;
comment|/* SRC_READABLE left uninitialized */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|path_driver_cb_func
parameter_list|(
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|path_driver_cb_baton
modifier|*
name|cb
init|=
name|callback_baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|cb
operator|->
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
init|=
name|cb
operator|->
name|edit_baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
init|=
name|cb
operator|->
name|root
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|svn_boolean_t
name|do_add
init|=
name|FALSE
decl_stmt|,
name|do_delete
init|=
name|FALSE
decl_stmt|;
name|void
modifier|*
name|file_baton
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|source_root
init|=
name|cb
operator|->
name|compare_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_fspath
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_path
init|=
name|cb
operator|->
name|base_path
decl_stmt|;
operator|*
name|dir_baton
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize SOURCE_FSPATH. */
if|if
condition|(
name|source_root
condition|)
name|source_fspath
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|edit_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* First, flush the copies stack so it only contains ancestors of path. */
while|while
condition|(
name|cb
operator|->
name|copies
operator|->
name|nelts
operator|>
literal|0
operator|&&
operator|!
name|svn_dirent_is_ancestor
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|cb
operator|->
name|copies
argument_list|,
name|cb
operator|->
name|copies
operator|->
name|nelts
operator|-
literal|1
argument_list|,
expr|struct
name|copy_info
operator|*
argument_list|)
operator|->
name|path
argument_list|,
name|edit_path
argument_list|)
condition|)
name|apr_array_pop
argument_list|(
name|cb
operator|->
name|copies
argument_list|)
expr_stmt|;
name|change
operator|=
name|svn_hash_gets
argument_list|(
name|cb
operator|->
name|changed_paths
argument_list|,
name|edit_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|change
condition|)
block|{
comment|/* This can only happen if the path was removed from cb->changed_paths          by an earlier call to add_subdir, which means the path was already          handled and we should simply ignore it. */
return|return
name|SVN_NO_ERROR
return|;
block|}
switch|switch
condition|(
name|change
operator|->
name|change_kind
condition|)
block|{
case|case
name|svn_fs_path_change_add
case|:
name|do_add
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_delete
case|:
name|do_delete
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_replace
case|:
name|do_add
operator|=
name|TRUE
expr_stmt|;
name|do_delete
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_modify
case|:
default|default:
comment|/* do nothing */
break|break;
block|}
comment|/* Handle any deletions. */
if|if
condition|(
name|do_delete
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
comment|/* Issue #4121: delete under under a copy, of a path that was unreadable          at its pre-copy location. */
name|SVN_ERR
argument_list|(
name|was_readable
argument_list|(
operator|&
name|readable
argument_list|,
name|root
argument_list|,
name|edit_path
argument_list|,
name|cb
operator|->
name|copies
argument_list|,
name|cb
operator|->
name|authz_read_func
argument_list|,
name|cb
operator|->
name|authz_read_baton
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readable
condition|)
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|delete_entry
argument_list|(
name|edit_path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|parent_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fetch the node kind if it makes sense to do so. */
if|if
condition|(
operator|!
name|do_delete
operator|||
name|do_add
condition|)
block|{
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_unknown
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
operator|(
name|change
operator|->
name|node_kind
operator|)
argument_list|,
name|root
argument_list|,
name|edit_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|change
operator|->
name|node_kind
operator|!=
name|svn_node_dir
operator|)
operator|&&
operator|(
name|change
operator|->
name|node_kind
operator|!=
name|svn_node_file
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Filesystem path '%s' is neither a file "
literal|"nor a directory"
argument_list|)
argument_list|,
name|edit_path
argument_list|)
return|;
block|}
comment|/* Handle any adds/opens. */
if|if
condition|(
name|do_add
condition|)
block|{
name|svn_boolean_t
name|src_readable
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copyfrom_root
decl_stmt|;
comment|/* Was this node copied? */
name|SVN_ERR
argument_list|(
name|fill_copyfrom
argument_list|(
operator|&
name|copyfrom_root
argument_list|,
operator|&
name|copyfrom_path
argument_list|,
operator|&
name|copyfrom_rev
argument_list|,
operator|&
name|src_readable
argument_list|,
name|root
argument_list|,
name|change
argument_list|,
name|cb
operator|->
name|authz_read_func
argument_list|,
name|cb
operator|->
name|authz_read_baton
argument_list|,
name|edit_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a copyfrom path, and we can't read it or we're just          ignoring it, or the copyfrom rev is prior to the low water mark          then we just null them out and do a raw add with no history at          all. */
if|if
condition|(
name|copyfrom_path
operator|&&
operator|(
operator|(
operator|!
name|src_readable
operator|)
operator|||
operator|(
name|svn_relpath_skip_ancestor
argument_list|(
name|base_path
argument_list|,
name|copyfrom_path
operator|+
literal|1
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cb
operator|->
name|low_water_mark
operator|>
name|copyfrom_rev
operator|)
operator|)
condition|)
block|{
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* Do the right thing based on the path KIND. */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* If this is a copy, but we can't represent it as such,              then we just do a recursive add of the source path              contents. */
if|if
condition|(
name|change
operator|->
name|copyfrom_path
operator|&&
operator|!
name|copyfrom_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|add_subdir
argument_list|(
name|copyfrom_root
argument_list|,
name|root
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|edit_path
argument_list|,
name|parent_baton
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|cb
operator|->
name|authz_read_func
argument_list|,
name|cb
operator|->
name|authz_read_baton
argument_list|,
name|cb
operator|->
name|changed_paths
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_directory
argument_list|(
name|edit_path
argument_list|,
name|parent_baton
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_file
argument_list|(
name|edit_path
argument_list|,
name|parent_baton
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we represent this as a copy... */
if|if
condition|(
name|copyfrom_path
condition|)
block|{
comment|/* If it is a directory, make sure descendants get the correct              delta source by remembering that we are operating inside a              (possibly nested) copy operation. */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|struct
name|copy_info
modifier|*
name|info
init|=
name|apr_pcalloc
argument_list|(
name|cb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|cb
operator|->
name|pool
argument_list|,
name|edit_path
argument_list|)
expr_stmt|;
name|info
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|cb
operator|->
name|pool
argument_list|,
name|copyfrom_path
argument_list|)
expr_stmt|;
name|info
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|cb
operator|->
name|copies
argument_list|,
expr|struct
name|copy_info
operator|*
argument_list|)
operator|=
name|info
expr_stmt|;
block|}
comment|/* Save the source so that we can use it later, when we              need to generate text and prop deltas. */
name|source_root
operator|=
name|copyfrom_root
expr_stmt|;
name|source_fspath
operator|=
name|copyfrom_path
expr_stmt|;
block|}
else|else
comment|/* Else, we are an add without history... */
block|{
comment|/* If an ancestor is added with history, we need to forget about              that here, go on with life and repeat all the mistakes of our              past... */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
operator|&&
name|cb
operator|->
name|copies
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|struct
name|copy_info
modifier|*
name|info
init|=
name|apr_pcalloc
argument_list|(
name|cb
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|cb
operator|->
name|pool
argument_list|,
name|edit_path
argument_list|)
expr_stmt|;
name|info
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|cb
operator|->
name|copies
argument_list|,
expr|struct
name|copy_info
operator|*
argument_list|)
operator|=
name|info
expr_stmt|;
block|}
name|source_root
operator|=
name|NULL
expr_stmt|;
name|source_fspath
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|do_delete
condition|)
block|{
comment|/* Do the right thing based on the path KIND (and the presence          of a PARENT_BATON). */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
name|parent_baton
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_directory
argument_list|(
name|edit_path
argument_list|,
name|parent_baton
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|edit_baton
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_file
argument_list|(
name|edit_path
argument_list|,
name|parent_baton
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are inside an add with history, we need to adjust the          delta source. */
if|if
condition|(
name|cb
operator|->
name|copies
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|struct
name|copy_info
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|cb
operator|->
name|copies
argument_list|,
name|cb
operator|->
name|copies
operator|->
name|nelts
operator|-
literal|1
argument_list|,
expr|struct
name|copy_info
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|copyfrom_path
condition|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_relpath_skip_ancestor
argument_list|(
name|info
operator|->
name|path
argument_list|,
name|edit_path
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|relpath
operator|&&
operator|*
name|relpath
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|source_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
argument_list|,
name|info
operator|->
name|copyfrom_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|source_fspath
operator|=
name|svn_fspath__join
argument_list|(
name|info
operator|->
name|copyfrom_path
argument_list|,
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an add without history, nested inside an                  add with history.  We have no delta source in this case. */
name|source_root
operator|=
name|NULL
expr_stmt|;
name|source_fspath
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|do_delete
operator|||
name|do_add
condition|)
block|{
comment|/* Is this a copy that was downgraded to a raw add?  (If so,          we'll need to transmit properties and file contents and such          for it regardless of what the CHANGE structure's text_mod          and prop_mod flags say.)  */
name|svn_boolean_t
name|downgraded_copy
init|=
operator|(
name|change
operator|->
name|copyfrom_known
operator|&&
name|change
operator|->
name|copyfrom_path
operator|&&
operator|(
operator|!
name|copyfrom_path
operator|)
operator|)
decl_stmt|;
comment|/* Handle property modifications. */
if|if
condition|(
name|change
operator|->
name|prop_mod
operator|||
name|downgraded_copy
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|compare_root
condition|)
block|{
name|apr_array_header_t
modifier|*
name|prop_diffs
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_props
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|source_root
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|old_props
argument_list|,
name|source_root
argument_list|,
name|source_fspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|new_props
argument_list|,
name|root
argument_list|,
name|edit_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|prop_diffs
argument_list|,
name|new_props
argument_list|,
name|old_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_diffs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_prop_t
modifier|*
name|pc
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|prop_diffs
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_dir_prop
argument_list|(
operator|*
name|dir_baton
argument_list|,
name|pc
operator|->
name|name
argument_list|,
name|pc
operator|->
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
name|pc
operator|->
name|name
argument_list|,
name|pc
operator|->
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just do a dummy prop change to signal that there are *any*                  propmods. */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_dir_prop
argument_list|(
operator|*
name|dir_baton
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle textual modifications. */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_file
operator|&&
operator|(
name|change
operator|->
name|text_mod
operator|||
name|downgraded_copy
operator|)
condition|)
block|{
name|svn_txdelta_window_handler_t
name|delta_handler
decl_stmt|;
name|void
modifier|*
name|delta_handler_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex_digest
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|compare_root
operator|&&
name|source_root
operator|&&
name|source_fspath
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|source_root
argument_list|,
name|source_fspath
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hex_digest
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|file_baton
argument_list|,
name|hex_digest
argument_list|,
name|pool
argument_list|,
operator|&
name|delta_handler
argument_list|,
operator|&
name|delta_handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|compare_root
condition|)
block|{
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_file_delta_stream
argument_list|(
operator|&
name|delta_stream
argument_list|,
name|source_root
argument_list|,
name|source_fspath
argument_list|,
name|root
argument_list|,
name|edit_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_txstream
argument_list|(
name|delta_stream
argument_list|,
name|delta_handler
argument_list|,
name|delta_handler_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|delta_handler
argument_list|(
name|NULL
argument_list|,
name|delta_handler_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Close the file baton if we opened it. */
if|if
condition|(
name|file_baton
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|root
argument_list|,
name|edit_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_EV2_IMPL
end_ifdef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|prev_root
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|prev_root
argument_list|,
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
name|kind
argument_list|,
name|prev_root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|prev_root
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
operator|-
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|prev_root
argument_list|,
name|fs
argument_list|,
name|base_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
name|props
argument_list|,
name|prev_root
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|svn_error_t
modifier|*
name|svn_repos_replay2
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|base_path
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|USE_EV2_IMPL
name|apr_hash_t
modifier|*
name|fs_changes
decl_stmt|;
name|apr_hash_t
modifier|*
name|changed_paths
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|;
name|struct
name|path_driver_cb_baton
name|cb_baton
decl_stmt|;
comment|/* Special-case r0, which we know is an empty revision; if we don't      special-case it we might end up trying to compare it to "r-1". */
if|if
condition|(
name|svn_fs_is_revision_root
argument_list|(
name|root
argument_list|)
operator|&&
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|set_target_revision
argument_list|(
name|edit_baton
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Fetch the paths changed under ROOT. */
name|SVN_ERR
argument_list|(
name|svn_fs_paths_changed2
argument_list|(
operator|&
name|fs_changes
argument_list|,
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_path
condition|)
name|base_path
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|base_path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|++
name|base_path
expr_stmt|;
comment|/* Make an array from the keys of our CHANGED_PATHS hash, and copy      the values into a new hash whose keys have no leading slashes. */
name|paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|apr_hash_count
argument_list|(
name|fs_changes
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|changed_paths
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|fs_changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_ssize_t
name|keylen
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|svn_boolean_t
name|allowed
init|=
name|TRUE
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|keylen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
name|change
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|allowed
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowed
condition|)
block|{
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|path
operator|++
expr_stmt|;
name|keylen
operator|--
expr_stmt|;
block|}
comment|/* If the base_path doesn't match the top directory of this path              we don't want anything to do with it... */
if|if
condition|(
name|svn_relpath_skip_ancestor
argument_list|(
name|base_path
argument_list|,
name|path
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
argument_list|,
name|keylen
argument_list|,
name|change
argument_list|)
expr_stmt|;
block|}
comment|/* ...unless this was a change to one of the parent directories of              base_path. */
elseif|else
if|if
condition|(
name|svn_relpath_skip_ancestor
argument_list|(
name|path
argument_list|,
name|base_path
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
argument_list|,
name|keylen
argument_list|,
name|change
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we were not given a low water mark, assume that everything is there,      all the way back to revision 0. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|low_water_mark
argument_list|)
condition|)
name|low_water_mark
operator|=
literal|0
expr_stmt|;
comment|/* Initialize our callback baton. */
name|cb_baton
operator|.
name|editor
operator|=
name|editor
expr_stmt|;
name|cb_baton
operator|.
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|cb_baton
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|cb_baton
operator|.
name|changed_paths
operator|=
name|changed_paths
expr_stmt|;
name|cb_baton
operator|.
name|authz_read_func
operator|=
name|authz_read_func
expr_stmt|;
name|cb_baton
operator|.
name|authz_read_baton
operator|=
name|authz_read_baton
expr_stmt|;
name|cb_baton
operator|.
name|base_path
operator|=
name|base_path
expr_stmt|;
name|cb_baton
operator|.
name|low_water_mark
operator|=
name|low_water_mark
expr_stmt|;
name|cb_baton
operator|.
name|compare_root
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|send_deltas
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|cb_baton
operator|.
name|compare_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
argument_list|,
name|svn_fs_is_revision_root
argument_list|(
name|root
argument_list|)
condition|?
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
operator|-
literal|1
else|:
name|svn_fs_txn_root_base_revision
argument_list|(
name|root
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cb_baton
operator|.
name|copies
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|copy_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cb_baton
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Determine the revision to use throughout the edit, and call      EDITOR's set_target_revision() function.  */
if|if
condition|(
name|svn_fs_is_revision_root
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|revision
init|=
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|set_target_revision
argument_list|(
name|edit_baton
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Call the path-based editor driver. */
return|return
name|svn_delta_path_driver2
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|paths
argument_list|,
name|TRUE
argument_list|,
name|path_driver_cb_func
argument_list|,
operator|&
name|cb_baton
argument_list|,
name|pool
argument_list|)
return|;
else|#
directive|else
name|svn_editor_t
modifier|*
name|editorv2
decl_stmt|;
name|struct
name|svn_delta__extra_baton
modifier|*
name|exb
decl_stmt|;
name|svn_delta__unlock_func_t
name|unlock_func
decl_stmt|;
name|svn_boolean_t
name|send_abs_paths
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
init|=
literal|""
decl_stmt|;
name|void
modifier|*
name|unlock_baton
decl_stmt|;
comment|/* Special-case r0, which we know is an empty revision; if we don't      special-case it we might end up trying to compare it to "r-1". */
if|if
condition|(
name|svn_fs_is_revision_root
argument_list|(
name|root
argument_list|)
operator|&&
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|set_target_revision
argument_list|(
name|edit_baton
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Determine the revision to use throughout the edit, and call      EDITOR's set_target_revision() function.  */
if|if
condition|(
name|svn_fs_is_revision_root
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|revision
init|=
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|set_target_revision
argument_list|(
name|edit_baton
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|base_path
condition|)
name|base_path
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|base_path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|++
name|base_path
expr_stmt|;
comment|/* Use the shim to convert our editor to an Ev2 editor, and pass it down      the stack. */
name|SVN_ERR
argument_list|(
name|svn_delta__editor_from_delta
argument_list|(
operator|&
name|editorv2
argument_list|,
operator|&
name|exb
argument_list|,
operator|&
name|unlock_func
argument_list|,
operator|&
name|unlock_baton
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|&
name|send_abs_paths
argument_list|,
name|repos_root
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|fetch_kind_func
argument_list|,
name|root
argument_list|,
name|fetch_props_func
argument_list|,
name|root
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the shim that we're starting the process. */
name|SVN_ERR
argument_list|(
name|exb
operator|->
name|start_edit
argument_list|(
name|exb
operator|->
name|baton
argument_list|,
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### We're ignoring SEND_DELTAS here. */
name|SVN_ERR
argument_list|(
name|svn_repos__replay_ev2
argument_list|(
name|root
argument_list|,
name|base_path
argument_list|,
name|low_water_mark
argument_list|,
name|editorv2
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*****************************************************************  *                      Ev2 Implementation                       *  *****************************************************************/
end_comment

begin_comment
comment|/* Recursively traverse EDIT_PATH (as it exists under SOURCE_ROOT) emitting    the appropriate editor calls to add it and its children without any    history.  This is meant to be used when either a subset of the tree    has been ignored and we need to copy something from that subset to    the part of the tree we do care about, or if a subset of the tree is    unavailable because of authz and we need to use it as the source of    a copy. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_subdir_ev2
parameter_list|(
name|svn_fs_root_t
modifier|*
name|source_root
parameter_list|,
name|svn_fs_root_t
modifier|*
name|target_root
parameter_list|,
name|svn_editor_t
modifier|*
name|editor
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|source_fspath
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|children
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|target_root
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_add_directory
argument_list|(
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|children
argument_list|,
name|props
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have to get the dirents from the source path, not the target,      because we want nested copies from *readable* paths to be handled by      path_driver_cb_func, not add_subdir (in order to preserve history). */
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|dirents
argument_list|,
name|source_root
argument_list|,
name|source_fspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|svn_boolean_t
name|readable
init|=
name|TRUE
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_relpath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|child_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|repos_relpath
argument_list|,
name|dent
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If a file or subdirectory of the copied directory is listed as a          changed path (because it was modified after the copy but before the          commit), we remove it from the changed_paths hash so that future          calls to path_driver_cb_func will ignore it. */
name|change
operator|=
name|svn_hash_gets
argument_list|(
name|changed_paths
argument_list|,
name|child_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|changed_paths
argument_list|,
name|child_relpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If it's a delete, skip this entry. */
if|if
condition|(
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_delete
condition|)
continue|continue;
comment|/* If it's a replacement, check for copyfrom info (if we              don't have it already. */
if|if
condition|(
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_replace
condition|)
block|{
if|if
condition|(
operator|!
name|change
operator|->
name|copyfrom_known
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_copied_from
argument_list|(
operator|&
name|change
operator|->
name|copyfrom_rev
argument_list|,
operator|&
name|change
operator|->
name|copyfrom_path
argument_list|,
name|target_root
argument_list|,
name|child_relpath
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|change
operator|->
name|copyfrom_known
operator|=
name|TRUE
expr_stmt|;
block|}
name|copyfrom_path
operator|=
name|change
operator|->
name|copyfrom_path
expr_stmt|;
name|copyfrom_rev
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
block|}
if|if
condition|(
name|authz_read_func
condition|)
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|target_root
argument_list|,
name|child_relpath
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
continue|continue;
if|if
condition|(
name|dent
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|new_source_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_source_fspath
decl_stmt|;
if|if
condition|(
name|copyfrom_path
condition|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_root_fs
argument_list|(
name|source_root
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|new_source_root
argument_list|,
name|fs
argument_list|,
name|copyfrom_rev
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_source_fspath
operator|=
name|copyfrom_path
expr_stmt|;
block|}
else|else
block|{
name|new_source_root
operator|=
name|source_root
expr_stmt|;
name|new_source_fspath
operator|=
name|svn_fspath__join
argument_list|(
name|source_fspath
argument_list|,
name|dent
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* ### authz considerations?            *            * I think not; when path_driver_cb_func() calls add_subdir(), it            * passes SOURCE_ROOT and SOURCE_FSPATH that are unreadable.            */
if|if
condition|(
name|change
operator|&&
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_replace
operator|&&
name|copyfrom_path
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_editor_add_directory
argument_list|(
name|editor
argument_list|,
name|child_relpath
argument_list|,
name|children
argument_list|,
name|props
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|add_subdir_ev2
argument_list|(
name|new_source_root
argument_list|,
name|target_root
argument_list|,
name|editor
argument_list|,
name|child_relpath
argument_list|,
name|new_source_fspath
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|changed_paths
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dent
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|target_root
argument_list|,
name|child_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|target_root
argument_list|,
name|child_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|target_root
argument_list|,
name|child_relpath
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_add_file
argument_list|(
name|editor
argument_list|,
name|child_relpath
argument_list|,
name|checksum
argument_list|,
name|contents
argument_list|,
name|props
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|replay_node
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|svn_editor_t
modifier|*
name|editor
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
specifier|const
name|char
modifier|*
name|base_repos_relpath
parameter_list|,
name|apr_array_header_t
modifier|*
name|copies
parameter_list|,
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|svn_boolean_t
name|do_add
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|do_delete
init|=
name|FALSE
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|svn_revnum_t
name|replaces_rev
decl_stmt|;
comment|/* First, flush the copies stack so it only contains ancestors of path. */
while|while
condition|(
name|copies
operator|->
name|nelts
operator|>
literal|0
operator|&&
operator|(
name|svn_relpath_skip_ancestor
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|copies
argument_list|,
name|copies
operator|->
name|nelts
operator|-
literal|1
argument_list|,
expr|struct
name|copy_info
operator|*
argument_list|)
operator|->
name|path
argument_list|,
name|repos_relpath
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|apr_array_pop
argument_list|(
name|copies
argument_list|)
expr_stmt|;
name|change
operator|=
name|svn_hash_gets
argument_list|(
name|changed_paths
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|change
condition|)
block|{
comment|/* This can only happen if the path was removed from changed_paths          by an earlier call to add_subdir, which means the path was already          handled and we should simply ignore it. */
return|return
name|SVN_NO_ERROR
return|;
block|}
switch|switch
condition|(
name|change
operator|->
name|change_kind
condition|)
block|{
case|case
name|svn_fs_path_change_add
case|:
name|do_add
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_delete
case|:
name|do_delete
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_replace
case|:
name|do_add
operator|=
name|TRUE
expr_stmt|;
name|do_delete
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_modify
case|:
default|default:
comment|/* do nothing */
break|break;
block|}
comment|/* Handle any deletions. */
if|if
condition|(
name|do_delete
operator|&&
operator|!
name|do_add
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
comment|/* Issue #4121: delete under under a copy, of a path that was unreadable          at its pre-copy location. */
name|SVN_ERR
argument_list|(
name|was_readable
argument_list|(
operator|&
name|readable
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|copies
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readable
condition|)
name|SVN_ERR
argument_list|(
name|svn_editor_delete
argument_list|(
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Handle replacements. */
if|if
condition|(
name|do_delete
operator|&&
name|do_add
condition|)
name|replaces_rev
operator|=
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
expr_stmt|;
else|else
name|replaces_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Fetch the node kind if it makes sense to do so. */
if|if
condition|(
operator|!
name|do_delete
operator|||
name|do_add
condition|)
block|{
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_unknown
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
operator|(
name|change
operator|->
name|node_kind
operator|)
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|change
operator|->
name|node_kind
operator|!=
name|svn_node_dir
operator|)
operator|&&
operator|(
name|change
operator|->
name|node_kind
operator|!=
name|svn_node_file
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Filesystem path '%s' is neither a file "
literal|"nor a directory"
argument_list|)
argument_list|,
name|repos_relpath
argument_list|)
return|;
block|}
comment|/* Handle any adds/opens. */
if|if
condition|(
name|do_add
condition|)
block|{
name|svn_boolean_t
name|src_readable
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copyfrom_root
decl_stmt|;
comment|/* Was this node copied? */
name|SVN_ERR
argument_list|(
name|fill_copyfrom
argument_list|(
operator|&
name|copyfrom_root
argument_list|,
operator|&
name|copyfrom_path
argument_list|,
operator|&
name|copyfrom_rev
argument_list|,
operator|&
name|src_readable
argument_list|,
name|root
argument_list|,
name|change
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a copyfrom path, and we can't read it or we're just          ignoring it, or the copyfrom rev is prior to the low water mark          then we just null them out and do a raw add with no history at          all. */
if|if
condition|(
name|copyfrom_path
operator|&&
operator|(
operator|(
operator|!
name|src_readable
operator|)
operator|||
operator|(
name|svn_relpath_skip_ancestor
argument_list|(
name|base_repos_relpath
argument_list|,
name|copyfrom_path
operator|+
literal|1
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|low_water_mark
operator|>
name|copyfrom_rev
operator|)
operator|)
condition|)
block|{
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* Do the right thing based on the path KIND. */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* If this is a copy, but we can't represent it as such,              then we just do a recursive add of the source path              contents. */
if|if
condition|(
name|change
operator|->
name|copyfrom_path
operator|&&
operator|!
name|copyfrom_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|add_subdir_ev2
argument_list|(
name|copyfrom_root
argument_list|,
name|root
argument_list|,
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|changed_paths
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|copyfrom_path
condition|)
block|{
if|if
condition|(
name|copyfrom_path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|++
name|copyfrom_path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_copy
argument_list|(
name|editor
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|repos_relpath
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|dirents
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_keys
argument_list|(
operator|&
name|children
argument_list|,
name|dirents
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_add_directory
argument_list|(
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|children
argument_list|,
name|props
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|copyfrom_path
condition|)
block|{
if|if
condition|(
name|copyfrom_path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|++
name|copyfrom_path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_copy
argument_list|(
name|editor
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_rev
argument_list|,
name|repos_relpath
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_add_file
argument_list|(
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|checksum
argument_list|,
name|contents
argument_list|,
name|props
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we represent this as a copy... */
if|if
condition|(
name|copyfrom_path
condition|)
block|{
comment|/* If it is a directory, make sure descendants get the correct              delta source by remembering that we are operating inside a              (possibly nested) copy operation. */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|struct
name|copy_info
modifier|*
name|info
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
name|info
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|copyfrom_path
argument_list|)
expr_stmt|;
name|info
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|copies
argument_list|,
expr|struct
name|copy_info
operator|*
argument_list|)
operator|=
name|info
expr_stmt|;
block|}
block|}
else|else
comment|/* Else, we are an add without history... */
block|{
comment|/* If an ancestor is added with history, we need to forget about              that here, go on with life and repeat all the mistakes of our              past... */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
operator|&&
name|copies
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|struct
name|copy_info
modifier|*
name|info
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
name|info
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|copies
argument_list|,
expr|struct
name|copy_info
operator|*
argument_list|)
operator|=
name|info
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|do_delete
condition|)
block|{
comment|/* If we are inside an add with history, we need to adjust the          delta source. */
if|if
condition|(
name|copies
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|struct
name|copy_info
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|copies
argument_list|,
name|copies
operator|->
name|nelts
operator|-
literal|1
argument_list|,
expr|struct
name|copy_info
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|copyfrom_path
condition|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_relpath_skip_ancestor
argument_list|(
name|info
operator|->
name|path
argument_list|,
name|repos_relpath
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|relpath
operator|&&
operator|*
name|relpath
argument_list|)
expr_stmt|;
name|repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|info
operator|->
name|copyfrom_path
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|do_delete
operator|&&
operator|!
name|do_add
condition|)
block|{
name|apr_hash_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
comment|/* Is this a copy that was downgraded to a raw add?  (If so,          we'll need to transmit properties and file contents and such          for it regardless of what the CHANGE structure's text_mod          and prop_mod flags say.)  */
name|svn_boolean_t
name|downgraded_copy
init|=
operator|(
name|change
operator|->
name|copyfrom_known
operator|&&
name|change
operator|->
name|copyfrom_path
operator|&&
operator|(
operator|!
name|copyfrom_path
operator|)
operator|)
decl_stmt|;
comment|/* Handle property modifications. */
if|if
condition|(
name|change
operator|->
name|prop_mod
operator|||
name|downgraded_copy
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle textual modifications. */
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_file
operator|&&
operator|(
name|change
operator|->
name|text_mod
operator|||
name|change
operator|->
name|prop_mod
operator|||
name|downgraded_copy
operator|)
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
init|=
name|NULL
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|change
operator|->
name|text_mod
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_editor_alter_file
argument_list|(
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|props
argument_list|,
name|checksum
argument_list|,
name|contents
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
operator|&&
operator|(
name|change
operator|->
name|prop_mod
operator|||
name|downgraded_copy
operator|)
condition|)
block|{
name|apr_array_header_t
modifier|*
name|children
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_alter_directory
argument_list|(
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|children
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos__replay_ev2
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|base_repos_relpath
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_editor_t
modifier|*
name|editor
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|fs_changes
decl_stmt|;
name|apr_hash_t
modifier|*
name|changed_paths
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|;
name|apr_array_header_t
modifier|*
name|copies
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|svn_dirent_is_absolute
argument_list|(
name|base_repos_relpath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special-case r0, which we know is an empty revision; if we don't      special-case it we might end up trying to compare it to "r-1". */
if|if
condition|(
name|svn_fs_is_revision_root
argument_list|(
name|root
argument_list|)
operator|&&
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Fetch the paths changed under ROOT. */
name|SVN_ERR
argument_list|(
name|svn_fs_paths_changed2
argument_list|(
operator|&
name|fs_changes
argument_list|,
name|root
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make an array from the keys of our CHANGED_PATHS hash, and copy      the values into a new hash whose keys have no leading slashes. */
name|paths
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|apr_hash_count
argument_list|(
name|fs_changes
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|changed_paths
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|fs_changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_ssize_t
name|keylen
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|svn_boolean_t
name|allowed
init|=
name|TRUE
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|keylen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
name|change
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|allowed
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|authz_read_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowed
condition|)
block|{
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|path
operator|++
expr_stmt|;
name|keylen
operator|--
expr_stmt|;
block|}
comment|/* If the base_path doesn't match the top directory of this path              we don't want anything to do with it... */
if|if
condition|(
name|svn_relpath_skip_ancestor
argument_list|(
name|base_repos_relpath
argument_list|,
name|path
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
argument_list|,
name|keylen
argument_list|,
name|change
argument_list|)
expr_stmt|;
block|}
comment|/* ...unless this was a change to one of the parent directories of              base_path. */
elseif|else
if|if
condition|(
name|svn_relpath_skip_ancestor
argument_list|(
name|path
argument_list|,
name|base_repos_relpath
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
argument_list|,
name|keylen
argument_list|,
name|change
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we were not given a low water mark, assume that everything is there,      all the way back to revision 0. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|low_water_mark
argument_list|)
condition|)
name|low_water_mark
operator|=
literal|0
expr_stmt|;
name|copies
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|copy_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sort the paths.  Although not strictly required by the API, this has      the pleasant side effect of maintaining a consistent ordering of      dumpfile contents. */
name|qsort
argument_list|(
name|paths
operator|->
name|elts
argument_list|,
name|paths
operator|->
name|nelts
argument_list|,
name|paths
operator|->
name|elt_size
argument_list|,
name|svn_sort_compare_paths
argument_list|)
expr_stmt|;
comment|/* Now actually handle the various paths. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|replay_node
argument_list|(
name|root
argument_list|,
name|repos_relpath
argument_list|,
name|editor
argument_list|,
name|low_water_mark
argument_list|,
name|base_repos_relpath
argument_list|,
name|copies
argument_list|,
name|changed_paths
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_editor_abort
argument_list|(
name|editor
argument_list|)
argument_list|)
return|;
else|else
name|SVN_ERR
argument_list|(
name|svn_editor_complete
argument_list|(
name|editor
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

