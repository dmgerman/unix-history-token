begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* log.c --- retrieving log messages  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|"svn_compat.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"repos.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_escape
end_escape

begin_function
name|svn_error_t
modifier|*
name|svn_repos_check_revision_access
parameter_list|(
name|svn_repos_revision_access_level_t
modifier|*
name|access_level
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|rev_root
decl_stmt|;
name|apr_hash_t
modifier|*
name|changes
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|found_readable
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|found_unreadable
init|=
name|FALSE
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
comment|/* By default, we'll grant full read access to REVISION. */
operator|*
name|access_level
operator|=
name|svn_repos_revision_access_full
expr_stmt|;
comment|/* No auth-checking function?  We're done. */
if|if
condition|(
operator|!
name|authz_read_func
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Fetch the changes associated with REVISION. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|rev_root
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_paths_changed2
argument_list|(
operator|&
name|changes
argument_list|,
name|rev_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No changed paths?  We're done. */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|changes
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Otherwise, we have to check the readability of each changed      path, or at least enough to answer the question asked. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|readable
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|rev_root
argument_list|,
name|key
argument_list|,
name|authz_read_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
name|found_unreadable
operator|=
name|TRUE
expr_stmt|;
else|else
name|found_readable
operator|=
name|TRUE
expr_stmt|;
comment|/* If we have at least one of each (readable/unreadable), we          have our answer. */
if|if
condition|(
name|found_readable
operator|&&
name|found_unreadable
condition|)
goto|goto
name|decision
goto|;
switch|switch
condition|(
name|change
operator|->
name|change_kind
condition|)
block|{
case|case
name|svn_fs_path_change_add
case|:
case|case
name|svn_fs_path_change_replace
case|:
block|{
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_copied_from
argument_list|(
operator|&
name|copyfrom_rev
argument_list|,
operator|&
name|copyfrom_path
argument_list|,
name|rev_root
argument_list|,
name|key
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyfrom_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|copyfrom_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|copyfrom_root
argument_list|,
name|fs
argument_list|,
name|copyfrom_rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|copyfrom_root
argument_list|,
name|copyfrom_path
argument_list|,
name|authz_read_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
name|found_unreadable
operator|=
name|TRUE
expr_stmt|;
comment|/* If we have at least one of each (readable/unreadable), we                    have our answer. */
if|if
condition|(
name|found_readable
operator|&&
name|found_unreadable
condition|)
goto|goto
name|decision
goto|;
block|}
block|}
break|break;
case|case
name|svn_fs_path_change_delete
case|:
case|case
name|svn_fs_path_change_modify
case|:
default|default:
break|break;
block|}
block|}
name|decision
label|:
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Either every changed path was unreadable... */
if|if
condition|(
operator|!
name|found_readable
condition|)
operator|*
name|access_level
operator|=
name|svn_repos_revision_access_none
expr_stmt|;
comment|/* ... or some changed path was unreadable... */
elseif|else
if|if
condition|(
name|found_unreadable
condition|)
operator|*
name|access_level
operator|=
name|svn_repos_revision_access_partial
expr_stmt|;
comment|/* ... or every changed path was readable (the default). */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store as keys in CHANGED the paths of all node in ROOT that show a  * significant change.  "Significant" means that the text or  * properties of the node were changed, or that the node was added or  * deleted.  *  * The CHANGED hash set and its keys and values are allocated in POOL;  * keys are const char * paths and values are svn_log_changed_path_t.  *  * To prevent changes from being processed over and over again, the  * changed paths for ROOT may be passed in PREFETCHED_CHANGES.  If the  * latter is NULL, we will request the list inside this function.  *  * If optional AUTHZ_READ_FUNC is non-NULL, then use it (with  * AUTHZ_READ_BATON and FS) to check whether each changed-path (and  * copyfrom_path) is readable:  *  *     - If absolutely every changed-path (and copyfrom_path) is  *     readable, then return the full CHANGED hash, and set  *     *ACCESS_LEVEL to svn_repos_revision_access_full.  *  *     - If some paths are readable and some are not, then silently  *     omit the unreadable paths from the CHANGED hash, and set  *     *ACCESS_LEVEL to svn_repos_revision_access_partial.  *  *     - If absolutely every changed-path (and copyfrom_path) is  *     unreadable, then return an empty CHANGED hash, and set  *     *ACCESS_LEVEL to svn_repos_revision_access_none.  (This is  *     to distinguish a revision which truly has no changed paths  *     from a revision in which all paths are unreadable.)  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|detect_changed
parameter_list|(
name|svn_repos_revision_access_level_t
modifier|*
name|access_level
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|changed
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|prefetched_changes
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|changes
init|=
name|prefetched_changes
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|found_readable
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|found_unreadable
init|=
name|FALSE
decl_stmt|;
comment|/* If we create the CHANGES hash ourselves, we can reuse it as the    * result hash as it contains the exact same keys - but with _all_    * values being replaced by structs of a different type. */
if|if
condition|(
name|changes
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_paths_changed2
argument_list|(
operator|&
name|changes
argument_list|,
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are going to filter the results, we won't use the exact        * same keys but put them into a new hash. */
if|if
condition|(
name|authz_read_func
condition|)
operator|*
name|changed
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
else|else
operator|*
name|changed
operator|=
name|changes
expr_stmt|;
block|}
else|else
block|{
operator|*
name|changed
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|changes
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* No paths changed in this revision?  Uh, sure, I guess the          revision is readable, then.  */
operator|*
name|access_level
operator|=
name|svn_repos_revision_access_full
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
comment|/* NOTE:  Much of this loop is going to look quite similar to          svn_repos_check_revision_access(), but we have to do more things          here, so we'll live with the duplication. */
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|path_len
init|=
name|apr_hash_this_key_len
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|char
name|action
decl_stmt|;
name|svn_log_changed_path2_t
modifier|*
name|item
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Skip path if unreadable. */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
block|{
name|found_unreadable
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* At least one changed-path was readable. */
name|found_readable
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|change
operator|->
name|change_kind
condition|)
block|{
case|case
name|svn_fs_path_change_reset
case|:
continue|continue;
case|case
name|svn_fs_path_change_add
case|:
name|action
operator|=
literal|'A'
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_replace
case|:
name|action
operator|=
literal|'R'
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_delete
case|:
name|action
operator|=
literal|'D'
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_modify
case|:
default|default:
name|action
operator|=
literal|'M'
expr_stmt|;
break|break;
block|}
name|item
operator|=
name|svn_log_changed_path2_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|action
operator|=
name|action
expr_stmt|;
name|item
operator|->
name|node_kind
operator|=
name|change
operator|->
name|node_kind
expr_stmt|;
name|item
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|item
operator|->
name|text_modified
operator|=
name|change
operator|->
name|text_mod
condition|?
name|svn_tristate_true
else|:
name|svn_tristate_false
expr_stmt|;
name|item
operator|->
name|props_modified
operator|=
name|change
operator|->
name|prop_mod
condition|?
name|svn_tristate_true
else|:
name|svn_tristate_false
expr_stmt|;
comment|/* Pre-1.6 revision files don't store the change path kind, so fetch          it manually. */
if|if
condition|(
name|item
operator|->
name|node_kind
operator|==
name|svn_node_unknown
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|check_root
init|=
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|check_path
init|=
name|path
decl_stmt|;
comment|/* Deleted items don't exist so check earlier revision.  We              know the parent must exist and could be a copy */
if|if
condition|(
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_delete
condition|)
block|{
name|svn_fs_history_t
modifier|*
name|history
decl_stmt|;
name|svn_revnum_t
name|prev_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_path
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|svn_fspath__split
argument_list|(
operator|&
name|parent_path
argument_list|,
operator|&
name|name
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_history2
argument_list|(
operator|&
name|history
argument_list|,
name|root
argument_list|,
name|parent_path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Two calls because the first call returns the original                  revision as the deleted child means it is 'interesting' */
name|SVN_ERR
argument_list|(
name|svn_fs_history_prev2
argument_list|(
operator|&
name|history
argument_list|,
name|history
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_history_prev2
argument_list|(
operator|&
name|history
argument_list|,
name|history
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_history_location
argument_list|(
operator|&
name|parent_path
argument_list|,
operator|&
name|prev_rev
argument_list|,
name|history
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|check_root
argument_list|,
name|fs
argument_list|,
name|prev_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|check_path
operator|=
name|svn_fspath__join
argument_list|(
name|parent_path
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|item
operator|->
name|node_kind
argument_list|,
name|check_root
argument_list|,
name|check_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|action
operator|==
literal|'A'
operator|)
operator|||
operator|(
name|action
operator|==
literal|'R'
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|copyfrom_path
init|=
name|change
operator|->
name|copyfrom_path
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
init|=
name|change
operator|->
name|copyfrom_rev
decl_stmt|;
comment|/* the following is a potentially expensive operation since on FSFS              we will follow the DAG from ROOT to PATH and that requires              actually reading the directories along the way. */
if|if
condition|(
operator|!
name|change
operator|->
name|copyfrom_known
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_copied_from
argument_list|(
operator|&
name|copyfrom_rev
argument_list|,
operator|&
name|copyfrom_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|copyfrom_path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copyfrom_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|readable
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|copyfrom_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|copyfrom_root
argument_list|,
name|fs
argument_list|,
name|copyfrom_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|copyfrom_root
argument_list|,
name|copyfrom_path
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
name|found_unreadable
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|readable
condition|)
block|{
name|item
operator|->
name|copyfrom_path
operator|=
name|copyfrom_path
expr_stmt|;
name|item
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
block|}
block|}
block|}
name|apr_hash_set
argument_list|(
operator|*
name|changed
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found_readable
condition|)
block|{
comment|/* Every changed-path was unreadable. */
operator|*
name|access_level
operator|=
name|svn_repos_revision_access_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found_unreadable
condition|)
block|{
comment|/* At least one changed-path was unreadable. */
operator|*
name|access_level
operator|=
name|svn_repos_revision_access_partial
expr_stmt|;
block|}
else|else
block|{
comment|/* Every changed-path was readable. */
operator|*
name|access_level
operator|=
name|svn_repos_revision_access_full
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is used by svn_repos_get_logs to keep track of multiple  * path history information while working through history.  *  * The two pools are swapped after each iteration through history because  * to get the next history requires the previous one.  */
end_comment

begin_struct
struct|struct
name|path_info
block|{
name|svn_stringbuf_t
modifier|*
name|path
decl_stmt|;
name|svn_revnum_t
name|history_rev
decl_stmt|;
name|svn_boolean_t
name|done
decl_stmt|;
name|svn_boolean_t
name|first_time
decl_stmt|;
comment|/* If possible, we like to keep open the history object for each path,      since it avoids needed to open and close it many times as we walk      backwards in time.  To do so we need two pools, so that we can clear      one each time through.  If we're not holding the history open for      this path then these three pointers will be NULL. */
name|svn_fs_history_t
modifier|*
name|hist
decl_stmt|;
name|apr_pool_t
modifier|*
name|newpool
decl_stmt|;
name|apr_pool_t
modifier|*
name|oldpool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Advance to the next history for the path.  *  * If INFO->HIST is not NULL we do this using that existing history object,  * otherwise we open a new one.  *  * If no more history is available or the history revision is less  * (earlier) than START, or the history is not available due  * to authorization, then INFO->DONE is set to TRUE.  *  * A STRICT value of FALSE will indicate to follow history across copied  * paths.  *  * If optional AUTHZ_READ_FUNC is non-NULL, then use it (with  * AUTHZ_READ_BATON and FS) to check whether INFO->PATH is still readable if  * we do indeed find more history for the path.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_history
parameter_list|(
name|struct
name|path_info
modifier|*
name|info
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_boolean_t
name|strict
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|history_root
init|=
name|NULL
decl_stmt|;
name|svn_fs_history_t
modifier|*
name|hist
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|hist
condition|)
block|{
name|subpool
operator|=
name|info
operator|->
name|newpool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_history_prev2
argument_list|(
operator|&
name|info
operator|->
name|hist
argument_list|,
name|info
operator|->
name|hist
argument_list|,
operator|!
name|strict
argument_list|,
name|subpool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|hist
operator|=
name|info
operator|->
name|hist
expr_stmt|;
block|}
else|else
block|{
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Open the history located at the last rev we were at. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|history_root
argument_list|,
name|fs
argument_list|,
name|info
operator|->
name|history_rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_history2
argument_list|(
operator|&
name|hist
argument_list|,
name|history_root
argument_list|,
name|info
operator|->
name|path
operator|->
name|data
argument_list|,
name|subpool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_history_prev2
argument_list|(
operator|&
name|hist
argument_list|,
name|hist
argument_list|,
operator|!
name|strict
argument_list|,
name|subpool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_time
condition|)
name|info
operator|->
name|first_time
operator|=
name|FALSE
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_history_prev2
argument_list|(
operator|&
name|hist
argument_list|,
name|hist
argument_list|,
operator|!
name|strict
argument_list|,
name|subpool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hist
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|oldpool
condition|)
name|svn_pool_destroy
argument_list|(
name|info
operator|->
name|oldpool
argument_list|)
expr_stmt|;
name|info
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Fetch the location information for this history step. */
name|SVN_ERR
argument_list|(
name|svn_fs_history_location
argument_list|(
operator|&
name|path
argument_list|,
operator|&
name|info
operator|->
name|history_rev
argument_list|,
name|hist
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_set
argument_list|(
name|info
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* If this history item predates our START revision then      don't fetch any more for this path. */
if|if
condition|(
name|info
operator|->
name|history_rev
operator|<
name|start
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|oldpool
condition|)
name|svn_pool_destroy
argument_list|(
name|info
operator|->
name|oldpool
argument_list|)
expr_stmt|;
name|info
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Is the history item readable?  If not, done with path. */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|history_root
argument_list|,
name|fs
argument_list|,
name|info
operator|->
name|history_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|history_root
argument_list|,
name|info
operator|->
name|path
operator|->
name|data
argument_list|,
name|authz_read_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
name|info
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|hist
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_pool_t
modifier|*
name|temppool
init|=
name|info
operator|->
name|oldpool
decl_stmt|;
name|info
operator|->
name|oldpool
operator|=
name|info
operator|->
name|newpool
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|temppool
argument_list|)
expr_stmt|;
name|info
operator|->
name|newpool
operator|=
name|temppool
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set INFO->HIST to the next history for the path *if* there is history  * available and INFO->HISTORY_REV is equal to or greater than CURRENT.  *  * *CHANGED is set to TRUE if the path has history in the CURRENT revision,  * otherwise it is not touched.  *  * If we do need to get the next history revision for the path, call  * get_history to do it -- see it for details.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_history
parameter_list|(
name|svn_boolean_t
modifier|*
name|changed
parameter_list|,
name|struct
name|path_info
modifier|*
name|info
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|current
parameter_list|,
name|svn_boolean_t
name|strict
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* If we're already done with histories for this path,      don't try to fetch any more. */
if|if
condition|(
name|info
operator|->
name|done
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the last rev we got for this path is less than CURRENT,      then just return and don't fetch history for this path.      The caller will get to this rev eventually or else reach      the limit. */
if|if
condition|(
name|info
operator|->
name|history_rev
operator|<
name|current
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the last rev we got for this path is equal to CURRENT      then set *CHANGED to true and get the next history      rev where this path was changed. */
operator|*
name|changed
operator|=
name|TRUE
expr_stmt|;
return|return
name|get_history
argument_list|(
name|info
argument_list|,
name|fs
argument_list|,
name|strict
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|start
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the next interesting revision in our list of HISTORIES. */
end_comment

begin_function
specifier|static
name|svn_revnum_t
name|next_history_rev
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|histories
parameter_list|)
block|{
name|svn_revnum_t
name|next_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|histories
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|path_info
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|histories
argument_list|,
name|i
argument_list|,
expr|struct
name|path_info
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|done
condition|)
continue|continue;
if|if
condition|(
name|info
operator|->
name|history_rev
operator|>
name|next_rev
condition|)
name|next_rev
operator|=
name|info
operator|->
name|history_rev
expr_stmt|;
block|}
return|return
name|next_rev
return|;
block|}
end_function

begin_comment
comment|/* Set *DELETED_MERGEINFO_CATALOG and *ADDED_MERGEINFO_CATALOG to    catalogs describing how mergeinfo values on paths (which are the    keys of those catalogs) were changed in REV.  If *PREFETCHED_CHANGES    already contains the changed paths for REV, use that.  Otherwise,    request that data and return it in *PREFETCHED_CHANGES. */
end_comment

begin_comment
comment|/* ### TODO: This would make a *great*, useful public function,    ### svn_repos_fs_mergeinfo_changed()!  -- cmpilato  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_mergeinfo_changed
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|deleted_mergeinfo_catalog
parameter_list|,
name|svn_mergeinfo_catalog_t
modifier|*
name|added_mergeinfo_catalog
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|prefetched_changes
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|any_mergeinfo
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|any_copy
init|=
name|FALSE
decl_stmt|;
comment|/* Initialize return variables. */
operator|*
name|deleted_mergeinfo_catalog
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|added_mergeinfo_catalog
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Revision 0 has no mergeinfo and no mergeinfo changes. */
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* We're going to use the changed-paths information for REV to      narrow down our search. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prefetched_changes
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_paths_changed2
argument_list|(
name|prefetched_changes
argument_list|,
name|root
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for copies and (potential) mergeinfo changes.      We will use both flags to take shortcuts further down the road. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
operator|*
name|prefetched_changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_path_change2_t
modifier|*
name|change
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
comment|/* If there was a prop change and we are not positive that _no_          mergeinfo change happened, we must assume that it might have. */
if|if
condition|(
name|change
operator|->
name|mergeinfo_mod
operator|!=
name|svn_tristate_false
operator|&&
name|change
operator|->
name|prop_mod
condition|)
name|any_mergeinfo
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|change
operator|->
name|change_kind
condition|)
block|{
case|case
name|svn_fs_path_change_add
case|:
case|case
name|svn_fs_path_change_replace
case|:
name|any_copy
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* No potential mergeinfo changes?  We're done. */
if|if
condition|(
operator|!
name|any_mergeinfo
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Loop over changes, looking for anything that might carry an      svn:mergeinfo change and is one of our paths of interest, or a      child or [grand]parent directory thereof. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
operator|*
name|prefetched_changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|changed_path
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_path
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|base_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|base_root
init|=
name|NULL
decl_stmt|;
name|svn_string_t
modifier|*
name|prev_mergeinfo_value
init|=
name|NULL
decl_stmt|,
modifier|*
name|mergeinfo_value
decl_stmt|;
comment|/* Cheap pre-checks that don't require memory allocation etc. */
comment|/* No mergeinfo change? -> nothing to do here. */
if|if
condition|(
name|change
operator|->
name|mergeinfo_mod
operator|==
name|svn_tristate_false
condition|)
continue|continue;
comment|/* If there was no property change on this item, ignore it. */
if|if
condition|(
operator|!
name|change
operator|->
name|prop_mod
condition|)
continue|continue;
comment|/* Begin actual processing */
name|changed_path
operator|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|change
operator|->
name|change_kind
condition|)
block|{
comment|/* ### TODO: Can the add, replace, and modify cases be joined            ### together to all use svn_repos__prev_location()?  The            ### difference would be the fallback case (path/rev-1 for            ### modifies, NULL otherwise).  -- cmpilato  */
comment|/* If the path was merely modified, see if its previous            location was affected by a copy which happened in this            revision before assuming it holds the same path it did the            previous revision. */
case|case
name|svn_fs_path_change_modify
case|:
block|{
name|svn_revnum_t
name|appeared_rev
decl_stmt|;
comment|/* If there were no copies in this revision, the path will have                existed in the previous rev.  Otherwise, we might just got                copied here and need to check for that eventuality. */
if|if
condition|(
name|any_copy
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_repos__prev_location
argument_list|(
operator|&
name|appeared_rev
argument_list|,
operator|&
name|base_path
argument_list|,
operator|&
name|base_rev
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|changed_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this path isn't the result of a copy that occurred                    in this revision, we can find the previous version of                    it in REV - 1 at the same path. */
if|if
condition|(
operator|!
operator|(
name|base_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_rev
argument_list|)
operator|&&
operator|(
name|appeared_rev
operator|==
name|rev
operator|)
operator|)
condition|)
block|{
name|base_path
operator|=
name|changed_path
expr_stmt|;
name|base_rev
operator|=
name|rev
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|base_path
operator|=
name|changed_path
expr_stmt|;
name|base_rev
operator|=
name|rev
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* If the path was added or replaced, see if it was created via            copy.  If so, set BASE_REV/BASE_PATH to its previous location.            If not, there's no previous location to examine -- leave            BASE_REV/BASE_PATH = -1/NULL.  */
case|case
name|svn_fs_path_change_add
case|:
case|case
name|svn_fs_path_change_replace
case|:
block|{
if|if
condition|(
name|change
operator|->
name|copyfrom_known
condition|)
block|{
name|base_rev
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
name|base_path
operator|=
name|change
operator|->
name|copyfrom_path
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_copied_from
argument_list|(
operator|&
name|base_rev
argument_list|,
operator|&
name|base_path
argument_list|,
name|root
argument_list|,
name|changed_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* We don't care about any of the other cases. */
case|case
name|svn_fs_path_change_delete
case|:
case|case
name|svn_fs_path_change_reset
case|:
default|default:
continue|continue;
block|}
comment|/* If there was a base location, fetch its mergeinfo property value. */
if|if
condition|(
name|base_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_rev
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|base_root
argument_list|,
name|fs
argument_list|,
name|base_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_prop
argument_list|(
operator|&
name|prev_mergeinfo_value
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now fetch the current (as of REV) mergeinfo property value. */
name|SVN_ERR
argument_list|(
name|svn_fs_node_prop
argument_list|(
operator|&
name|mergeinfo_value
argument_list|,
name|root
argument_list|,
name|changed_path
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No mergeinfo on either the new or previous location?  Just          skip it.  (If there *was* a change, it would have been in          inherited mergeinfo only, which should be picked up by the          iteration of this loop that finds the parent paths that          really got changed.)  */
if|if
condition|(
operator|!
operator|(
name|mergeinfo_value
operator|||
name|prev_mergeinfo_value
operator|)
condition|)
continue|continue;
comment|/* Mergeinfo on both sides but it did not change? Skip that too. */
if|if
condition|(
name|mergeinfo_value
operator|&&
name|prev_mergeinfo_value
operator|&&
name|svn_string_compare
argument_list|(
name|mergeinfo_value
argument_list|,
name|prev_mergeinfo_value
argument_list|)
condition|)
continue|continue;
comment|/* If mergeinfo was explicitly added or removed on this path, we          need to check to see if that was a real semantic change of          meaning.  So, fill in the "missing" mergeinfo value with the          inherited mergeinfo for that path/revision.  */
if|if
condition|(
name|prev_mergeinfo_value
operator|&&
operator|(
operator|!
name|mergeinfo_value
operator|)
condition|)
block|{
name|svn_mergeinfo_t
name|tmp_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__get_mergeinfo_for_path
argument_list|(
operator|&
name|tmp_mergeinfo
argument_list|,
name|root
argument_list|,
name|changed_path
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|mergeinfo_value
argument_list|,
name|tmp_mergeinfo
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mergeinfo_value
operator|&&
operator|(
operator|!
name|prev_mergeinfo_value
operator|)
operator|&&
name|base_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_rev
argument_list|)
condition|)
block|{
name|svn_mergeinfo_t
name|tmp_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__get_mergeinfo_for_path
argument_list|(
operator|&
name|tmp_mergeinfo
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|prev_mergeinfo_value
argument_list|,
name|tmp_mergeinfo
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Old and new mergeinfo probably differ in some way (we already          checked for textual equality further up). Store the before and          after mergeinfo values in our return hashes.  They may still be          equal as manual intervention may have only changed the formatting          but not the relevant contents. */
block|{
name|svn_mergeinfo_t
name|prev_mergeinfo
init|=
name|NULL
decl_stmt|,
name|mergeinfo
init|=
name|NULL
decl_stmt|;
name|svn_mergeinfo_t
name|deleted
decl_stmt|,
name|added
decl_stmt|;
specifier|const
name|char
modifier|*
name|hash_path
decl_stmt|;
if|if
condition|(
name|mergeinfo_value
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo_value
operator|->
name|data
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_mergeinfo_value
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|prev_mergeinfo
argument_list|,
name|prev_mergeinfo_value
operator|->
name|data
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_diff2
argument_list|(
operator|&
name|deleted
argument_list|,
operator|&
name|added
argument_list|,
name|prev_mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Toss interesting stuff into our return catalogs. */
name|hash_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|changed_path
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|deleted_mergeinfo_catalog
argument_list|,
name|hash_path
argument_list|,
name|deleted
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|added_mergeinfo_catalog
argument_list|,
name|hash_path
argument_list|,
name|added
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Determine what (if any) mergeinfo for PATHS was modified in    revision REV, returning the differences for added mergeinfo in    *ADDED_MERGEINFO and deleted mergeinfo in *DELETED_MERGEINFO.    If *PREFETCHED_CHANGES already contains the changed paths for    REV, use that.  Otherwise, request that data and return it in    *PREFETCHED_CHANGES. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_combined_mergeinfo_changes
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|added_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
modifier|*
name|deleted_mergeinfo
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|prefetched_changes
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_catalog_t
name|added_mergeinfo_catalog
decl_stmt|,
name|deleted_mergeinfo_catalog
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Initialize return value. */
operator|*
name|added_mergeinfo
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|deleted_mergeinfo
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* If we're asking about revision 0, there's no mergeinfo to be found. */
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* No paths?  No mergeinfo. */
if|if
condition|(
operator|!
name|paths
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Fetch the mergeinfo changes for REV. */
name|err
operator|=
name|fs_mergeinfo_changed
argument_list|(
operator|&
name|deleted_mergeinfo_catalog
argument_list|,
operator|&
name|added_mergeinfo_catalog
argument_list|,
name|prefetched_changes
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
comment|/* Issue #3896: If invalid mergeinfo is encountered the              best we can do is ignore it and act as if there were              no mergeinfo modifications. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* In most revisions, there will be no mergeinfo change at all. */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|deleted_mergeinfo_catalog
argument_list|)
operator|==
literal|0
operator|&&
name|apr_hash_count
argument_list|(
name|added_mergeinfo_catalog
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Create a work subpool and get a root for REV. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check our PATHS for any changes to their inherited mergeinfo.      (We deal with changes to mergeinfo directly *on* the paths in the      following loop.)  */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|prev_path
decl_stmt|;
name|svn_revnum_t
name|appeared_rev
decl_stmt|,
name|prev_rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|prev_root
decl_stmt|;
name|svn_mergeinfo_t
name|prev_mergeinfo
decl_stmt|,
name|mergeinfo
decl_stmt|,
name|deleted
decl_stmt|,
name|added
decl_stmt|,
name|prev_inherited_mergeinfo
decl_stmt|,
name|inherited_mergeinfo
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If this path is represented in the changed-mergeinfo hashes,          we'll deal with it in the loop below. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|deleted_mergeinfo_catalog
argument_list|,
name|path
argument_list|)
condition|)
continue|continue;
comment|/* Figure out what path/rev to compare against.  Ignore          not-found errors returned by the filesystem.  */
name|err
operator|=
name|svn_repos__prev_location
argument_list|(
operator|&
name|appeared_rev
argument_list|,
operator|&
name|prev_path
argument_list|,
operator|&
name|prev_rev
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_DIRECTORY
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
continue|continue;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* If this path isn't the result of a copy that occurred in this          revision, we can find the previous version of it in REV - 1          at the same path. */
if|if
condition|(
operator|!
operator|(
name|prev_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|prev_rev
argument_list|)
operator|&&
operator|(
name|appeared_rev
operator|==
name|rev
operator|)
operator|)
condition|)
block|{
name|prev_path
operator|=
name|path
expr_stmt|;
name|prev_rev
operator|=
name|rev
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Fetch the previous mergeinfo (including inherited stuff) for          this path.  Ignore not-found errors returned by the          filesystem or invalid mergeinfo (Issue #3896).*/
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|prev_root
argument_list|,
name|fs
argument_list|,
name|prev_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs__get_mergeinfo_for_path
argument_list|(
operator|&
name|prev_mergeinfo
argument_list|,
name|prev_root
argument_list|,
name|prev_path
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_DIRECTORY
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
continue|continue;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Issue #4022 'svn log -g interprets change in inherited mergeinfo due          to move as a merge': A copy where the source and destination inherit          mergeinfo from the same parent means the inherited mergeinfo of the          source and destination will differ, but this diffrence is not          indicative of a merge unless the mergeinfo on the inherited parent          has actually changed.           To check for this we must fetch the "raw" previous inherited          mergeinfo and the "raw" mergeinfo @REV then compare these. */
name|SVN_ERR
argument_list|(
name|svn_fs__get_mergeinfo_for_path
argument_list|(
operator|&
name|prev_inherited_mergeinfo
argument_list|,
name|prev_root
argument_list|,
name|prev_path
argument_list|,
name|svn_mergeinfo_nearest_ancestor
argument_list|,
name|FALSE
argument_list|,
comment|/* adjust_inherited_mergeinfo */
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the current mergeinfo (as of REV, and including          inherited stuff) for this path. */
name|SVN_ERR
argument_list|(
name|svn_fs__get_mergeinfo_for_path
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Issue #4022 again, fetch the raw inherited mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_fs__get_mergeinfo_for_path
argument_list|(
operator|&
name|inherited_mergeinfo
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|svn_mergeinfo_nearest_ancestor
argument_list|,
name|FALSE
argument_list|,
comment|/* adjust_inherited_mergeinfo */
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev_mergeinfo
operator|&&
operator|!
name|mergeinfo
condition|)
continue|continue;
comment|/* Last bit of issue #4022 checking. */
if|if
condition|(
name|prev_inherited_mergeinfo
operator|&&
name|inherited_mergeinfo
condition|)
block|{
name|svn_boolean_t
name|inherits_same_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__equals
argument_list|(
operator|&
name|inherits_same_mergeinfo
argument_list|,
name|prev_inherited_mergeinfo
argument_list|,
name|inherited_mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a copy rather than an actual merge brought about an              inherited mergeinfo change then we are finished. */
if|if
condition|(
name|inherits_same_mergeinfo
condition|)
continue|continue;
block|}
else|else
block|{
name|svn_boolean_t
name|same_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__equals
argument_list|(
operator|&
name|same_mergeinfo
argument_list|,
name|prev_inherited_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_mergeinfo
condition|)
continue|continue;
block|}
comment|/* Compare, constrast, and combine the results. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_diff2
argument_list|(
operator|&
name|deleted
argument_list|,
operator|&
name|added
argument_list|,
name|prev_mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
operator|*
name|deleted_mergeinfo
argument_list|,
name|deleted
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
operator|*
name|added_mergeinfo
argument_list|,
name|added
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Merge all the mergeinfos which are, or are children of, one of      our paths of interest into one giant delta mergeinfo.  */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|added_mergeinfo_catalog
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|changed_path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|klen
init|=
name|apr_hash_this_key_len
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|added
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|deleted
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|svn_fspath__skip_ancestor
argument_list|(
name|path
argument_list|,
name|changed_path
argument_list|)
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|deleted
operator|=
name|apr_hash_get
argument_list|(
name|deleted_mergeinfo_catalog
argument_list|,
name|changed_path
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
operator|*
name|deleted_mergeinfo
argument_list|,
name|svn_mergeinfo_dup
argument_list|(
name|deleted
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
operator|*
name|added_mergeinfo
argument_list|,
name|svn_mergeinfo_dup
argument_list|(
name|added
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fill LOG_ENTRY with history information in FS at REV. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fill_log_entry
parameter_list|(
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|prefetched_changes
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|r_props
decl_stmt|,
modifier|*
name|changed_paths
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|get_revprops
init|=
name|TRUE
decl_stmt|,
name|censor_revprops
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|want_revprops
init|=
operator|!
name|revprops
operator|||
name|revprops
operator|->
name|nelts
decl_stmt|;
comment|/* Discover changed paths if the user requested them      or if we need to check that they are readable. */
if|if
condition|(
operator|(
name|rev
operator|>
literal|0
operator|)
operator|&&
operator|(
name|authz_read_func
operator|||
name|discover_changed_paths
operator|)
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|newroot
decl_stmt|;
name|svn_repos_revision_access_level_t
name|access_level
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|newroot
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|detect_changed
argument_list|(
operator|&
name|access_level
argument_list|,
operator|&
name|changed_paths
argument_list|,
name|newroot
argument_list|,
name|fs
argument_list|,
name|prefetched_changes
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_level
operator|==
name|svn_repos_revision_access_none
condition|)
block|{
comment|/* All changed-paths are unreadable, so clear all fields. */
name|changed_paths
operator|=
name|NULL
expr_stmt|;
name|get_revprops
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|access_level
operator|==
name|svn_repos_revision_access_partial
condition|)
block|{
comment|/* At least one changed-path was unreadable, so censor all              but author and date.  (The unreadable paths are already              missing from the hash.) */
name|censor_revprops
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* It may be the case that an authz func was passed in, but          the user still doesn't want to see any changed-paths. */
if|if
condition|(
operator|!
name|discover_changed_paths
condition|)
name|changed_paths
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|get_revprops
operator|&&
name|want_revprops
condition|)
block|{
comment|/* User is allowed to see at least some revprops. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|r_props
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|revprops
operator|==
name|NULL
condition|)
block|{
comment|/* Requested all revprops... */
if|if
condition|(
name|censor_revprops
condition|)
block|{
comment|/* ... but we can only return author/date. */
name|log_entry
operator|->
name|revprops
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|svn_hash_gets
argument_list|(
name|r_props
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|svn_hash_gets
argument_list|(
name|r_props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* ... so return all we got. */
name|log_entry
operator|->
name|revprops
operator|=
name|r_props
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Requested only some revprops... */
comment|/* Make "svn:author" and "svn:date" available as svn_string_t              for efficient comparison via svn_string_compare().  Note that              we want static initialization here and must therefore emulate              strlen(x) by sizeof(x)-1. */
specifier|static
specifier|const
name|svn_string_t
name|svn_prop_revision_author
init|=
block|{
name|SVN_PROP_REVISION_AUTHOR
block|,
sizeof|sizeof
argument_list|(
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
operator|-
literal|1
block|}
decl_stmt|;
specifier|static
specifier|const
name|svn_string_t
name|svn_prop_revision_date
init|=
block|{
name|SVN_PROP_REVISION_DATE
block|,
sizeof|sizeof
argument_list|(
name|SVN_PROP_REVISION_DATE
argument_list|)
operator|-
literal|1
block|}
decl_stmt|;
comment|/* often only the standard revprops got requested and delivered.              In that case, we can simply pass the hash on. */
if|if
condition|(
name|revprops
operator|->
name|nelts
operator|==
name|apr_hash_count
argument_list|(
name|r_props
argument_list|)
operator|&&
operator|!
name|censor_revprops
condition|)
block|{
name|log_entry
operator|->
name|revprops
operator|=
name|r_props
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revprops
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_string_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|apr_hash_get
argument_list|(
name|r_props
argument_list|,
name|name
operator|->
name|data
argument_list|,
name|name
operator|->
name|len
argument_list|)
condition|)
block|{
comment|/* hash does not match list of revprops we want */
name|log_entry
operator|->
name|revprops
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* slow, revprop-by-revprop filtering */
if|if
condition|(
name|log_entry
operator|->
name|revprops
operator|==
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revprops
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_string_t
operator|*
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|value
init|=
name|apr_hash_get
argument_list|(
name|r_props
argument_list|,
name|name
operator|->
name|data
argument_list|,
name|name
operator|->
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|censor_revprops
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|name
argument_list|,
operator|&
name|svn_prop_revision_author
argument_list|)
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|name
argument_list|,
operator|&
name|svn_prop_revision_date
argument_list|)
condition|)
comment|/* ... but we can only return author/date. */
continue|continue;
if|if
condition|(
name|log_entry
operator|->
name|revprops
operator|==
name|NULL
condition|)
name|log_entry
operator|->
name|revprops
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|name
operator|->
name|data
argument_list|,
name|name
operator|->
name|len
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|log_entry
operator|->
name|changed_paths
operator|=
name|changed_paths
expr_stmt|;
name|log_entry
operator|->
name|changed_paths2
operator|=
name|changed_paths
expr_stmt|;
name|log_entry
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Send a log message for REV to RECEIVER with its RECEIVER_BATON.     FS is used with REV to fetch the interesting history information,    such as changed paths, revprops, etc.     The detect_changed function is used if either AUTHZ_READ_FUNC is    not NULL, or if DISCOVER_CHANGED_PATHS is TRUE.  See it for details.     If DESCENDING_ORDER is true, send child messages in descending order.     If REVPROPS is NULL, retrieve all revision properties; else, retrieve    only the revision properties named by the (const char *) array elements    (i.e. retrieve none if the array is empty).     LOG_TARGET_HISTORY_AS_MERGEINFO, HANDLING_MERGED_REVISION, and    NESTED_MERGES are as per the arguments of the same name to DO_LOGS.    If HANDLING_MERGED_REVISION is true and *all* changed paths within REV are    already represented in LOG_TARGET_HISTORY_AS_MERGEINFO, then don't send    the log message for REV.  If SUBTRACTIVE_MERGE is true, then REV was    reverse merged.     If HANDLING_MERGED_REVISIONS is FALSE then ignore NESTED_MERGES.  Otherwise    if NESTED_MERGES is not NULL and REV is contained in it, then don't send    the log for REV, otherwise send it normally and add REV to    NESTED_MERGES. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_log
parameter_list|(
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|prefetched_changes
parameter_list|,
name|svn_mergeinfo_t
name|log_target_history_as_mergeinfo
parameter_list|,
name|svn_bit_array__t
modifier|*
name|nested_merges
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|subtractive_merge
parameter_list|,
name|svn_boolean_t
name|handling_merged_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_boolean_t
name|has_children
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_log_entry_t
modifier|*
name|log_entry
decl_stmt|;
comment|/* Assume we want to send the log for REV. */
name|svn_boolean_t
name|found_rev_of_interest
init|=
name|TRUE
decl_stmt|;
name|log_entry
operator|=
name|svn_log_entry_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fill_log_entry
argument_list|(
name|log_entry
argument_list|,
name|rev
argument_list|,
name|fs
argument_list|,
name|prefetched_changes
argument_list|,
name|discover_changed_paths
operator|||
name|handling_merged_revision
argument_list|,
name|revprops
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|log_entry
operator|->
name|has_children
operator|=
name|has_children
expr_stmt|;
name|log_entry
operator|->
name|subtractive_merge
operator|=
name|subtractive_merge
expr_stmt|;
comment|/* Is REV a merged revision that is already part of      LOG_TARGET_HISTORY_AS_MERGEINFO?  If so then there is no      need to send it, since it already was (or will be) sent. */
if|if
condition|(
name|handling_merged_revision
operator|&&
name|log_entry
operator|->
name|changed_paths2
operator|&&
name|log_target_history_as_mergeinfo
operator|&&
name|apr_hash_count
argument_list|(
name|log_target_history_as_mergeinfo
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* REV was merged in, but it might already be part of the log target's          natural history, so change our starting assumption. */
name|found_rev_of_interest
operator|=
name|FALSE
expr_stmt|;
comment|/* Look at each changed path in REV. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_boolean_t
name|path_is_in_history
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|changed_path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi2
decl_stmt|;
comment|/* Look at each path on the log target's mergeinfo. */
for|for
control|(
name|hi2
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|log_target_history_as_mergeinfo
argument_list|)
init|;
name|hi2
condition|;
name|hi2
operator|=
name|apr_hash_next
argument_list|(
name|hi2
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|mergeinfo_path
init|=
name|apr_hash_this_key
argument_list|(
name|hi2
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|apr_hash_this_val
argument_list|(
name|hi2
argument_list|)
decl_stmt|;
comment|/* Check whether CHANGED_PATH at revision REV is a child of                  a (path, revision) tuple in LOG_TARGET_HISTORY_AS_MERGEINFO. */
if|if
condition|(
name|svn_fspath__skip_ancestor
argument_list|(
name|mergeinfo_path
argument_list|,
name|changed_path
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|>
name|range
operator|->
name|start
operator|&&
name|rev
operator|<=
name|range
operator|->
name|end
condition|)
block|{
name|path_is_in_history
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|path_is_in_history
condition|)
break|break;
block|}
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path_is_in_history
condition|)
block|{
comment|/* If even one path in LOG_ENTRY->CHANGED_PATHS2 is not part of                  LOG_TARGET_HISTORY_AS_MERGEINFO, then we want to send the                  log for REV. */
name|found_rev_of_interest
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* If we only got changed paths the sake of detecting redundant merged      revisions, then be sure we don't send that info to the receiver. */
if|if
condition|(
operator|!
name|discover_changed_paths
operator|&&
name|handling_merged_revision
condition|)
name|log_entry
operator|->
name|changed_paths
operator|=
name|log_entry
operator|->
name|changed_paths2
operator|=
name|NULL
expr_stmt|;
comment|/* Send the entry to the receiver, unless it is a redundant merged      revision. */
if|if
condition|(
name|found_rev_of_interest
condition|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
comment|/* Is REV a merged revision we've already sent? */
if|if
condition|(
name|nested_merges
operator|&&
name|handling_merged_revision
condition|)
block|{
if|if
condition|(
name|svn_bit_array__get
argument_list|(
name|nested_merges
argument_list|,
name|rev
argument_list|)
condition|)
block|{
comment|/* We already sent REV. */
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* NESTED_REVS needs to last across all the send_log, do_logs,                  handle_merged_revisions() recursions, so use the pool it                  was created in at the top of the recursion. */
name|svn_bit_array__set
argument_list|(
name|nested_merges
argument_list|,
name|rev
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pass a scratch pool to ensure no temporary state stored          by the receiver callback persists. */
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|receiver
argument_list|(
name|receiver_baton
argument_list|,
name|log_entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This controls how many history objects we keep open.  For any targets    over this number we have to open and close their histories as needed,    which is CPU intensive, but keeps us from using an unbounded amount of    memory. */
end_comment

begin_define
define|#
directive|define
name|MAX_OPEN_HISTORIES
value|32
end_define

begin_comment
comment|/* Get the histories for PATHS, and store them in *HISTORIES.     If IGNORE_MISSING_LOCATIONS is set, don't treat requests for bogus    repository locations as fatal -- just ignore them.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_path_histories
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|histories
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|hist_start
parameter_list|,
name|svn_revnum_t
name|hist_end
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|ignore_missing_locations
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create a history object for each path so we can walk through      them all at the same time until we have all changes or LIMIT      is reached.       There is some pool fun going on due to the fact that we have      to hold on to the old pool with the history before we can      get the next history.   */
operator|*
name|histories
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|paths
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|hist_end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|this_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|struct
name|path_info
modifier|*
name|info
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_info
argument_list|)
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|root
argument_list|,
name|this_path
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_UNREADABLE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|info
operator|->
name|path
operator|=
name|svn_stringbuf_create
argument_list|(
name|this_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|info
operator|->
name|done
operator|=
name|FALSE
expr_stmt|;
name|info
operator|->
name|history_rev
operator|=
name|hist_end
expr_stmt|;
name|info
operator|->
name|first_time
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|MAX_OPEN_HISTORIES
condition|)
block|{
name|err
operator|=
name|svn_fs_node_history2
argument_list|(
operator|&
name|info
operator|->
name|hist
argument_list|,
name|root
argument_list|,
name|this_path
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|ignore_missing_locations
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_DIRECTORY
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_REVISION
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|info
operator|->
name|newpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|info
operator|->
name|oldpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|->
name|hist
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|oldpool
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|newpool
operator|=
name|NULL
expr_stmt|;
block|}
name|err
operator|=
name|get_history
argument_list|(
name|info
argument_list|,
name|fs
argument_list|,
name|strict_node_history
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|hist_start
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|ignore_missing_locations
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_DIRECTORY
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_REVISION
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|histories
argument_list|,
expr|struct
name|path_info
operator|*
argument_list|)
operator|=
name|info
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove and return the first item from ARR. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|array_pop_front
parameter_list|(
name|apr_array_header_t
modifier|*
name|arr
parameter_list|)
block|{
name|void
modifier|*
name|item
init|=
name|arr
operator|->
name|elts
decl_stmt|;
if|if
condition|(
name|apr_is_empty_array
argument_list|(
name|arr
argument_list|)
condition|)
return|return
name|NULL
return|;
name|arr
operator|->
name|elts
operator|+=
name|arr
operator|->
name|elt_size
expr_stmt|;
name|arr
operator|->
name|nelts
operator|-=
literal|1
expr_stmt|;
name|arr
operator|->
name|nalloc
operator|-=
literal|1
expr_stmt|;
return|return
name|item
return|;
block|}
end_function

begin_comment
comment|/* A struct which represents a single revision range, and the paths which    have mergeinfo in that range. */
end_comment

begin_struct
struct|struct
name|path_list_range
block|{
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|;
name|svn_merge_range_t
name|range
decl_stmt|;
comment|/* Is RANGE the result of a reverse merge? */
name|svn_boolean_t
name|reverse_merge
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A struct which represents "inverse mergeinfo", that is, instead of having    a path->revision_range_list mapping, which is the way mergeinfo is commonly    represented, this struct enables a revision_range_list,path tuple, where    the paths can be accessed by revision. */
end_comment

begin_struct
struct|struct
name|rangelist_path
block|{
name|svn_rangelist_t
modifier|*
name|rangelist
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Comparator function for combine_mergeinfo_path_lists().  Sorts    rangelist_path structs in increasing order based upon starting revision,    then ending revision of the first element in the rangelist.     This does not sort rangelists based upon subsequent elements, only the    first range.  We'll sort any subsequent ranges in the correct order    when they get bumped up to the front by removal of earlier ones, so we    don't really have to sort them here.  See combine_mergeinfo_path_lists()    for details. */
end_comment

begin_function
specifier|static
name|int
name|compare_rangelist_paths
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|rangelist_path
modifier|*
name|rpa
init|=
operator|*
operator|(
operator|(
expr|struct
name|rangelist_path
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
name|struct
name|rangelist_path
modifier|*
name|rpb
init|=
operator|*
operator|(
operator|(
expr|struct
name|rangelist_path
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|mra
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rpa
operator|->
name|rangelist
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|mrb
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rpb
operator|->
name|rangelist
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|mra
operator|->
name|start
operator|<
name|mrb
operator|->
name|start
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|mra
operator|->
name|start
operator|>
name|mrb
operator|->
name|start
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mra
operator|->
name|end
operator|<
name|mrb
operator|->
name|end
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|mra
operator|->
name|end
operator|>
name|mrb
operator|->
name|end
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* From MERGEINFO, return in *COMBINED_LIST, allocated in POOL, a list of    'struct path_list_range's.  This list represents the rangelists in    MERGEINFO and each path which has mergeinfo in that range.    If REVERSE_MERGE is true, then MERGEINFO represents mergeinfo removed    as the result of a reverse merge. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|combine_mergeinfo_path_lists
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|combined_list
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|svn_boolean_t
name|reverse_merge
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|rangelist_paths
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Create a list of (revision range, path) tuples from MERGEINFO. */
name|rangelist_paths
operator|=
name|apr_array_make
argument_list|(
name|subpool
argument_list|,
name|apr_hash_count
argument_list|(
name|mergeinfo
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rangelist_path
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|rangelist_path
modifier|*
name|rp
init|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|)
decl_stmt|;
name|rp
operator|->
name|path
operator|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rangelist
operator|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist_paths
argument_list|,
expr|struct
name|rangelist_path
operator|*
argument_list|)
operator|=
name|rp
expr_stmt|;
comment|/* We need to make local copies of the rangelist, since we will be          modifying it, below. */
name|rp
operator|->
name|rangelist
operator|=
name|svn_rangelist_dup
argument_list|(
name|rp
operator|->
name|rangelist
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* Make all of the rangelists inclusive, both start and end. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rp
operator|->
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
name|APR_ARRAY_IDX
argument_list|(
name|rp
operator|->
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|->
name|start
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Loop over the (revision range, path) tuples, chopping them into      (revision range, paths) tuples, and appending those to the output      list. */
if|if
condition|(
operator|!
operator|*
name|combined_list
condition|)
operator|*
name|combined_list
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_list_range
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|rangelist_paths
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
name|svn_revnum_t
name|youngest
decl_stmt|,
name|next_youngest
decl_stmt|,
name|tail
decl_stmt|,
name|youngest_end
decl_stmt|;
name|struct
name|path_list_range
modifier|*
name|plr
decl_stmt|;
name|struct
name|rangelist_path
modifier|*
name|rp
decl_stmt|;
name|int
name|num_revs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First, sort the list such that the start revision of the first          revision arrays are sorted. */
name|svn_sort__array
argument_list|(
name|rangelist_paths
argument_list|,
name|compare_rangelist_paths
argument_list|)
expr_stmt|;
comment|/* Next, find the number of revision ranges which start with the same          revision. */
name|rp
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist_paths
argument_list|,
literal|0
argument_list|,
expr|struct
name|rangelist_path
operator|*
argument_list|)
expr_stmt|;
name|youngest
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rp
operator|->
name|rangelist
argument_list|,
literal|0
argument_list|,
expr|struct
name|svn_merge_range_t
operator|*
argument_list|)
operator|->
name|start
expr_stmt|;
name|next_youngest
operator|=
name|youngest
expr_stmt|;
for|for
control|(
name|num_revs
operator|=
literal|1
init|;
name|next_youngest
operator|==
name|youngest
condition|;
name|num_revs
operator|++
control|)
block|{
if|if
condition|(
name|num_revs
operator|==
name|rangelist_paths
operator|->
name|nelts
condition|)
block|{
name|num_revs
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
name|rp
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist_paths
argument_list|,
name|num_revs
argument_list|,
expr|struct
name|rangelist_path
operator|*
argument_list|)
expr_stmt|;
name|next_youngest
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rp
operator|->
name|rangelist
argument_list|,
literal|0
argument_list|,
expr|struct
name|svn_merge_range_t
operator|*
argument_list|)
operator|->
name|start
expr_stmt|;
block|}
name|num_revs
operator|-=
literal|1
expr_stmt|;
comment|/* The start of the new range will be YOUNGEST, and we now find the end          of the new range, which should be either one less than the next          earliest start of a rangelist, or the end of the first rangelist. */
name|youngest_end
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|rangelist_paths
argument_list|,
literal|0
argument_list|,
expr|struct
name|rangelist_path
operator|*
argument_list|)
operator|->
name|rangelist
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|->
name|end
expr_stmt|;
if|if
condition|(
operator|(
name|next_youngest
operator|==
name|youngest
operator|)
operator|||
operator|(
name|youngest_end
operator|<
name|next_youngest
operator|)
condition|)
name|tail
operator|=
name|youngest_end
expr_stmt|;
else|else
name|tail
operator|=
name|next_youngest
operator|-
literal|1
expr_stmt|;
comment|/* Insert the (earliest, tail) tuple into the output list, along with          a list of paths which match it. */
name|plr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|plr
argument_list|)
argument_list|)
expr_stmt|;
name|plr
operator|->
name|reverse_merge
operator|=
name|reverse_merge
expr_stmt|;
name|plr
operator|->
name|range
operator|.
name|start
operator|=
name|youngest
expr_stmt|;
name|plr
operator|->
name|range
operator|.
name|end
operator|=
name|tail
expr_stmt|;
name|plr
operator|->
name|paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|num_revs
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_revs
condition|;
name|i
operator|++
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|plr
operator|->
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist_paths
argument_list|,
name|i
argument_list|,
expr|struct
name|rangelist_path
operator|*
argument_list|)
operator|->
name|path
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|combined_list
argument_list|,
expr|struct
name|path_list_range
operator|*
argument_list|)
operator|=
name|plr
expr_stmt|;
comment|/* Now, check to see which (rangelist path) combinations we can remove,          and do so. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_revs
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
decl_stmt|;
name|rp
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist_paths
argument_list|,
name|i
argument_list|,
expr|struct
name|rangelist_path
operator|*
argument_list|)
expr_stmt|;
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rp
operator|->
name|rangelist
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Set the start of the range to beyond the end of the range we              just built.  If the range is now "inverted", we can get pop it              off the list. */
name|range
operator|->
name|start
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|start
operator|>
name|range
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|rangelist
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
comment|/* The range is the only on its list, so we should remove                      the entire rangelist_path, adjusting our loop control                      variables appropriately. */
name|array_pop_front
argument_list|(
name|rangelist_paths
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|num_revs
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* We have more than one range on the list, so just remove                      the first one. */
name|array_pop_front
argument_list|(
name|rp
operator|->
name|rangelist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Finally, add the last remaining (revision range, path) to the output      list. */
if|if
condition|(
name|rangelist_paths
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|struct
name|rangelist_path
modifier|*
name|first_rp
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist_paths
argument_list|,
literal|0
argument_list|,
expr|struct
name|rangelist_path
operator|*
argument_list|)
decl_stmt|;
while|while
condition|(
name|first_rp
operator|->
name|rangelist
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|struct
name|path_list_range
modifier|*
name|plr
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|plr
argument_list|)
argument_list|)
decl_stmt|;
name|plr
operator|->
name|reverse_merge
operator|=
name|reverse_merge
expr_stmt|;
name|plr
operator|->
name|paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|plr
operator|->
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|first_rp
operator|->
name|path
expr_stmt|;
name|plr
operator|->
name|range
operator|=
operator|*
name|APR_ARRAY_IDX
argument_list|(
name|first_rp
operator|->
name|rangelist
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
name|array_pop_front
argument_list|(
name|first_rp
operator|->
name|rangelist
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|combined_list
argument_list|,
expr|struct
name|path_list_range
operator|*
argument_list|)
operator|=
name|plr
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Pity that C is so ... linear. */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|do_logs
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_mergeinfo_t
name|log_target_history_as_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|processed
parameter_list|,
name|svn_bit_array__t
modifier|*
name|nested_merges
parameter_list|,
name|svn_revnum_t
name|hist_start
parameter_list|,
name|svn_revnum_t
name|hist_end
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
name|svn_boolean_t
name|handling_merged_revisions
parameter_list|,
name|svn_boolean_t
name|subtractive_merge
parameter_list|,
name|svn_boolean_t
name|ignore_missing_locations
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_boolean_t
name|descending_order
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Comparator function for handle_merged_revisions().  Sorts path_list_range    structs in increasing order based on the struct's RANGE.START revision,    then RANGE.END revision. */
end_comment

begin_function
specifier|static
name|int
name|compare_path_list_range
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|path_list_range
modifier|*
name|plr_a
init|=
operator|*
operator|(
operator|(
expr|struct
name|path_list_range
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
name|struct
name|path_list_range
modifier|*
name|plr_b
init|=
operator|*
operator|(
operator|(
expr|struct
name|path_list_range
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
if|if
condition|(
name|plr_a
operator|->
name|range
operator|.
name|start
operator|<
name|plr_b
operator|->
name|range
operator|.
name|start
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|plr_a
operator|->
name|range
operator|.
name|start
operator|>
name|plr_b
operator|->
name|range
operator|.
name|start
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|plr_a
operator|->
name|range
operator|.
name|end
operator|<
name|plr_b
operator|->
name|range
operator|.
name|end
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|plr_a
operator|->
name|range
operator|.
name|end
operator|>
name|plr_b
operator|->
name|range
operator|.
name|end
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Examine the ADDED_MERGEINFO and DELETED_MERGEINFO for revision REV in FS    (as collected by examining paths of interest to a log operation), and    determine which revisions to report as having been merged or reverse-merged    via the commit resulting in REV.     Silently ignore some failures to find the revisions mentioned in the    added/deleted mergeinfos, as might happen if there is invalid mergeinfo.     Other parameters are as described by do_logs(), around which this    is a recursion wrapper. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_merged_revisions
parameter_list|(
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_mergeinfo_t
name|log_target_history_as_mergeinfo
parameter_list|,
name|svn_bit_array__t
modifier|*
name|nested_merges
parameter_list|,
name|svn_mergeinfo_t
name|processed
parameter_list|,
name|svn_mergeinfo_t
name|added_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|deleted_mergeinfo
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|combined_list
init|=
name|NULL
decl_stmt|;
name|svn_log_entry_t
modifier|*
name|empty_log_entry
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|added_mergeinfo
argument_list|)
operator|==
literal|0
operator|&&
name|apr_hash_count
argument_list|(
name|deleted_mergeinfo
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|added_mergeinfo
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|combine_mergeinfo_path_lists
argument_list|(
operator|&
name|combined_list
argument_list|,
name|added_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|deleted_mergeinfo
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|combine_mergeinfo_path_lists
argument_list|(
operator|&
name|combined_list
argument_list|,
name|deleted_mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|combined_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|svn_sort__array
argument_list|(
name|combined_list
argument_list|,
name|compare_path_list_range
argument_list|)
expr_stmt|;
comment|/* Because the combined_lists are ordered youngest to oldest,      iterate over them in reverse. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|combined_list
operator|->
name|nelts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|path_list_range
modifier|*
name|pl_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|combined_list
argument_list|,
name|i
argument_list|,
expr|struct
name|path_list_range
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_logs
argument_list|(
name|fs
argument_list|,
name|pl_range
operator|->
name|paths
argument_list|,
name|log_target_history_as_mergeinfo
argument_list|,
name|processed
argument_list|,
name|nested_merges
argument_list|,
name|pl_range
operator|->
name|range
operator|.
name|start
argument_list|,
name|pl_range
operator|->
name|range
operator|.
name|end
argument_list|,
literal|0
argument_list|,
name|discover_changed_paths
argument_list|,
name|strict_node_history
argument_list|,
name|TRUE
argument_list|,
name|pl_range
operator|->
name|reverse_merge
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|revprops
argument_list|,
name|TRUE
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Send the empty revision.  */
name|empty_log_entry
operator|=
name|svn_log_entry_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|empty_log_entry
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
return|return
call|(
modifier|*
name|receiver
call|)
argument_list|(
name|receiver_baton
argument_list|,
name|empty_log_entry
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is used by do_logs to differentiate between forward and    reverse merges. */
end_comment

begin_struct
struct|struct
name|added_deleted_mergeinfo
block|{
name|svn_mergeinfo_t
name|added_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|deleted_mergeinfo
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Reduce the search range PATHS, HIST_START, HIST_END by removing    parts already covered by PROCESSED.  If reduction is possible    elements may be removed from PATHS and *START_REDUCED and    *END_REDUCED may be set to a narrower range. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reduce_search
parameter_list|(
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
modifier|*
name|hist_start
parameter_list|,
name|svn_revnum_t
modifier|*
name|hist_end
parameter_list|,
name|svn_mergeinfo_t
name|processed
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* We add 1 to end to compensate for store_search */
name|svn_revnum_t
name|start
init|=
operator|*
name|hist_start
operator|<=
operator|*
name|hist_end
condition|?
operator|*
name|hist_start
else|:
operator|*
name|hist_end
decl_stmt|;
name|svn_revnum_t
name|end
init|=
operator|*
name|hist_start
operator|<=
operator|*
name|hist_end
condition|?
operator|*
name|hist_end
operator|+
literal|1
else|:
operator|*
name|hist_start
operator|+
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|ranges
init|=
name|svn_hash_gets
argument_list|(
name|processed
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|ranges
condition|)
continue|continue;
comment|/* ranges is ordered, could we use some sort of binary search          rather than iterating? */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ranges
operator|->
name|nelts
condition|;
operator|++
name|j
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|ranges
argument_list|,
name|j
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|start
operator|<=
name|start
operator|&&
name|range
operator|->
name|end
operator|>=
name|end
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|paths
operator|->
name|nelts
operator|-
literal|1
condition|;
operator|++
name|j
control|)
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|j
operator|+
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
operator|--
name|paths
operator|->
name|nelts
expr_stmt|;
operator|--
name|i
expr_stmt|;
break|break;
block|}
comment|/* If there is only one path then we also check for a              partial overlap rather than the full overlap above, and              reduce the [hist_start, hist_end] range rather than              dropping the path. */
if|if
condition|(
name|paths
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|range
operator|->
name|start
operator|<=
name|start
operator|&&
name|range
operator|->
name|end
operator|>
name|start
condition|)
block|{
if|if
condition|(
name|start
operator|==
operator|*
name|hist_start
condition|)
operator|*
name|hist_start
operator|=
name|range
operator|->
name|end
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|hist_end
operator|=
name|range
operator|->
name|end
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|range
operator|->
name|start
operator|<
name|end
operator|&&
name|range
operator|->
name|end
operator|>=
name|end
condition|)
block|{
if|if
condition|(
name|start
operator|==
operator|*
name|hist_start
condition|)
operator|*
name|hist_end
operator|=
name|range
operator|->
name|start
expr_stmt|;
else|else
operator|*
name|hist_start
operator|=
name|range
operator|->
name|start
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Extend PROCESSED to cover PATHS from HIST_START to HIST_END */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_search
parameter_list|(
name|svn_mergeinfo_t
name|processed
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|hist_start
parameter_list|,
name|svn_revnum_t
name|hist_end
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* We add 1 to end so that we can use the mergeinfo API to handle      singe revisions where HIST_START is equal to HIST_END. */
name|svn_revnum_t
name|start
init|=
name|hist_start
operator|<=
name|hist_end
condition|?
name|hist_start
else|:
name|hist_end
decl_stmt|;
name|svn_revnum_t
name|end
init|=
name|hist_start
operator|<=
name|hist_end
condition|?
name|hist_end
operator|+
literal|1
else|:
name|hist_start
operator|+
literal|1
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
init|=
name|svn_hash__make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|processed_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|processed
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|ranges
init|=
name|apr_array_make
argument_list|(
name|processed_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
init|=
name|apr_palloc
argument_list|(
name|processed_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
argument_list|)
argument_list|)
decl_stmt|;
name|range
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|range
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|range
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|ranges
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|range
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|mergeinfo
argument_list|,
name|apr_pstrdup
argument_list|(
name|processed_pool
argument_list|,
name|path
argument_list|)
argument_list|,
name|ranges
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|processed
argument_list|,
name|mergeinfo
argument_list|,
name|apr_hash_pool_get
argument_list|(
name|processed
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find logs for PATHS from HIST_START to HIST_END in FS, and invoke    RECEIVER with RECEIVER_BATON on them.  If DESCENDING_ORDER is TRUE, send    the logs back as we find them, else buffer the logs and send them back    in youngest->oldest order.     If IGNORE_MISSING_LOCATIONS is set, don't treat requests for bogus    repository locations as fatal -- just ignore them.     If LOG_TARGET_HISTORY_AS_MERGEINFO is not NULL then it contains mergeinfo    representing the history of PATHS between HIST_START and HIST_END.     If HANDLING_MERGED_REVISIONS is TRUE then this is a recursive call for    merged revisions, see INCLUDE_MERGED_REVISIONS argument to    svn_repos_get_logs4().  If SUBTRACTIVE_MERGE is true, then this is a    recursive call for reverse merged revisions.     If NESTED_MERGES is not NULL then it is a hash of revisions (svn_revnum_t *    mapped to svn_revnum_t *) for logs that were previously sent.  On the first    call to do_logs it should always be NULL.  If INCLUDE_MERGED_REVISIONS is    TRUE, then NESTED_MERGES will be created on the first call to do_logs,    allocated in POOL.  It is then shared across    do_logs()/send_logs()/handle_merge_revisions() recursions, see also the    argument of the same name in send_logs().     PROCESSED is a mergeinfo hash that represents the paths and    revisions that have already been searched.  Allocated like    NESTED_MERGES above.     All other parameters are the same as svn_repos_get_logs4().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_logs
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_mergeinfo_t
name|log_target_history_as_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|processed
parameter_list|,
name|svn_bit_array__t
modifier|*
name|nested_merges
parameter_list|,
name|svn_revnum_t
name|hist_start
parameter_list|,
name|svn_revnum_t
name|hist_end
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
name|svn_boolean_t
name|subtractive_merge
parameter_list|,
name|svn_boolean_t
name|handling_merged_revisions
parameter_list|,
name|svn_boolean_t
name|ignore_missing_locations
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_boolean_t
name|descending_order
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|,
modifier|*
name|iterpool2
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|revs
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|rev_mergeinfo
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|current
decl_stmt|;
name|apr_array_header_t
modifier|*
name|histories
decl_stmt|;
name|svn_boolean_t
name|any_histories_left
init|=
name|TRUE
decl_stmt|;
name|int
name|send_count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|processed
condition|)
block|{
comment|/* Casting away const. This only happens on recursive calls when          it is known to be safe because we allocated paths. */
name|SVN_ERR
argument_list|(
name|reduce_search
argument_list|(
operator|(
name|apr_array_header_t
operator|*
operator|)
name|paths
argument_list|,
operator|&
name|hist_start
argument_list|,
operator|&
name|hist_end
argument_list|,
name|processed
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|paths
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|processed
condition|)
name|SVN_ERR
argument_list|(
name|store_search
argument_list|(
name|processed
argument_list|,
name|paths
argument_list|,
name|hist_start
argument_list|,
name|hist_end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have a list of paths and a revision range.  But we don't care      about all the revisions in the range -- only the ones in which      one of our paths was changed.  So let's go figure out which      revisions contain real changes to at least one of our paths.  */
name|SVN_ERR
argument_list|(
name|get_path_histories
argument_list|(
operator|&
name|histories
argument_list|,
name|fs
argument_list|,
name|paths
argument_list|,
name|hist_start
argument_list|,
name|hist_end
argument_list|,
name|strict_node_history
argument_list|,
name|ignore_missing_locations
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop through all the revisions in the range and add any      where a path was changed to the array, or if they wanted      history in reverse order just send it to them right away. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|iterpool2
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|current
operator|=
name|hist_end
init|;
name|any_histories_left
condition|;
name|current
operator|=
name|next_history_rev
argument_list|(
name|histories
argument_list|)
control|)
block|{
name|svn_boolean_t
name|changed
init|=
name|FALSE
decl_stmt|;
name|any_histories_left
operator|=
name|FALSE
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|histories
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|path_info
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|histories
argument_list|,
name|i
argument_list|,
expr|struct
name|path_info
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
comment|/* Check history for this path in current rev. */
name|SVN_ERR
argument_list|(
name|check_history
argument_list|(
operator|&
name|changed
argument_list|,
name|info
argument_list|,
name|fs
argument_list|,
name|current
argument_list|,
name|strict_node_history
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|hist_start
argument_list|,
name|pool
argument_list|,
name|iterpool2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|done
condition|)
name|any_histories_left
operator|=
name|TRUE
expr_stmt|;
block|}
name|svn_pool_clear
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
comment|/* If any of the paths changed in this rev then add or send it. */
if|if
condition|(
name|changed
condition|)
block|{
name|svn_mergeinfo_t
name|added_mergeinfo
init|=
name|NULL
decl_stmt|;
name|svn_mergeinfo_t
name|deleted_mergeinfo
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|has_children
init|=
name|FALSE
decl_stmt|;
name|apr_hash_t
modifier|*
name|changes
init|=
name|NULL
decl_stmt|;
comment|/* If we're including merged revisions, we need to calculate              the mergeinfo deltas committed in this revision to our              various paths. */
if|if
condition|(
name|include_merged_revisions
condition|)
block|{
name|apr_array_header_t
modifier|*
name|cur_paths
init|=
name|apr_array_make
argument_list|(
name|iterpool
argument_list|,
name|paths
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Get the current paths of our history objects so we can                  query mergeinfo. */
comment|/* ### TODO: Should this be ignoring depleted history items? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|histories
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|path_info
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|histories
argument_list|,
name|i
argument_list|,
expr|struct
name|path_info
operator|*
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|cur_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|info
operator|->
name|path
operator|->
name|data
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|get_combined_mergeinfo_changes
argument_list|(
operator|&
name|added_mergeinfo
argument_list|,
operator|&
name|deleted_mergeinfo
argument_list|,
operator|&
name|changes
argument_list|,
name|fs
argument_list|,
name|cur_paths
argument_list|,
name|current
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|has_children
operator|=
operator|(
name|apr_hash_count
argument_list|(
name|added_mergeinfo
argument_list|)
operator|>
literal|0
operator|||
name|apr_hash_count
argument_list|(
name|deleted_mergeinfo
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
block|}
comment|/* If our caller wants logs in descending order, we can send              'em now (because that's the order we're crawling history              in anyway). */
if|if
condition|(
name|descending_order
condition|)
block|{
name|SVN_ERR
argument_list|(
name|send_log
argument_list|(
name|current
argument_list|,
name|fs
argument_list|,
name|changes
argument_list|,
name|log_target_history_as_mergeinfo
argument_list|,
name|nested_merges
argument_list|,
name|discover_changed_paths
argument_list|,
name|subtractive_merge
argument_list|,
name|handling_merged_revisions
argument_list|,
name|revprops
argument_list|,
name|has_children
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_children
condition|)
comment|/* Implies include_merged_revisions == TRUE */
block|{
if|if
condition|(
operator|!
name|nested_merges
condition|)
block|{
comment|/* We're at the start of the recursion stack, create a                          single hash to be shared across all of the merged                          recursions so we can track and squelch duplicates. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|nested_merges
operator|=
name|svn_bit_array__create
argument_list|(
name|hist_end
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|processed
operator|=
name|svn_hash__make
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|handle_merged_revisions
argument_list|(
name|current
argument_list|,
name|fs
argument_list|,
name|log_target_history_as_mergeinfo
argument_list|,
name|nested_merges
argument_list|,
name|processed
argument_list|,
name|added_mergeinfo
argument_list|,
name|deleted_mergeinfo
argument_list|,
name|discover_changed_paths
argument_list|,
name|strict_node_history
argument_list|,
name|revprops
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|&&
operator|++
name|send_count
operator|>=
name|limit
condition|)
break|break;
block|}
comment|/* Otherwise, the caller wanted logs in ascending order, so              we have to buffer up a list of revs and (if doing              mergeinfo) a hash of related mergeinfo deltas, and              process them later. */
else|else
block|{
if|if
condition|(
operator|!
name|revs
condition|)
name|revs
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|64
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revs
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|added_mergeinfo
operator|||
name|deleted_mergeinfo
condition|)
block|{
name|svn_revnum_t
modifier|*
name|cur_rev
init|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
operator|&
name|current
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_rev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|added_deleted_mergeinfo
modifier|*
name|add_and_del_mergeinfo
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|add_and_del_mergeinfo
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we have added or deleted mergeinfo, both are non-null */
name|SVN_ERR_ASSERT
argument_list|(
name|added_mergeinfo
operator|&&
name|deleted_mergeinfo
argument_list|)
expr_stmt|;
name|add_and_del_mergeinfo
operator|->
name|added_mergeinfo
operator|=
name|svn_mergeinfo_dup
argument_list|(
name|added_mergeinfo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|add_and_del_mergeinfo
operator|->
name|deleted_mergeinfo
operator|=
name|svn_mergeinfo_dup
argument_list|(
name|deleted_mergeinfo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev_mergeinfo
condition|)
name|rev_mergeinfo
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|rev_mergeinfo
argument_list|,
name|cur_rev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cur_rev
argument_list|)
argument_list|,
name|add_and_del_mergeinfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|subpool
condition|)
block|{
name|nested_merges
operator|=
name|NULL
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|revs
condition|)
block|{
comment|/* Work loop for processing the revisions we found since they wanted          history in forward order. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_mergeinfo_t
name|added_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|deleted_mergeinfo
decl_stmt|;
name|svn_boolean_t
name|has_children
init|=
name|FALSE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|current
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|revs
argument_list|,
name|revs
operator|->
name|nelts
operator|-
name|i
operator|-
literal|1
argument_list|,
name|svn_revnum_t
argument_list|)
expr_stmt|;
comment|/* If we've got a hash of revision mergeinfo (which can only              happen if INCLUDE_MERGED_REVISIONS was set), we check to              see if this revision is one which merged in other              revisions we need to handle recursively. */
if|if
condition|(
name|rev_mergeinfo
condition|)
block|{
name|struct
name|added_deleted_mergeinfo
modifier|*
name|add_and_del_mergeinfo
init|=
name|apr_hash_get
argument_list|(
name|rev_mergeinfo
argument_list|,
operator|&
name|current
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
decl_stmt|;
name|added_mergeinfo
operator|=
name|add_and_del_mergeinfo
operator|->
name|added_mergeinfo
expr_stmt|;
name|deleted_mergeinfo
operator|=
name|add_and_del_mergeinfo
operator|->
name|deleted_mergeinfo
expr_stmt|;
name|has_children
operator|=
operator|(
name|apr_hash_count
argument_list|(
name|added_mergeinfo
argument_list|)
operator|>
literal|0
operator|||
name|apr_hash_count
argument_list|(
name|deleted_mergeinfo
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|send_log
argument_list|(
name|current
argument_list|,
name|fs
argument_list|,
name|NULL
argument_list|,
name|log_target_history_as_mergeinfo
argument_list|,
name|nested_merges
argument_list|,
name|discover_changed_paths
argument_list|,
name|subtractive_merge
argument_list|,
name|handling_merged_revisions
argument_list|,
name|revprops
argument_list|,
name|has_children
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_children
condition|)
block|{
if|if
condition|(
operator|!
name|nested_merges
condition|)
block|{
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|nested_merges
operator|=
name|svn_bit_array__create
argument_list|(
name|current
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|handle_merged_revisions
argument_list|(
name|current
argument_list|,
name|fs
argument_list|,
name|log_target_history_as_mergeinfo
argument_list|,
name|nested_merges
argument_list|,
name|processed
argument_list|,
name|added_mergeinfo
argument_list|,
name|deleted_mergeinfo
argument_list|,
name|discover_changed_paths
argument_list|,
name|strict_node_history
argument_list|,
name|revprops
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|&&
name|i
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|location_segment_baton
block|{
name|apr_array_header_t
modifier|*
name|history_segments
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* svn_location_segment_receiver_t implementation for svn_repos_get_logs4. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|location_segment_receiver
parameter_list|(
name|svn_location_segment_t
modifier|*
name|segment
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|location_segment_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|b
operator|->
name|history_segments
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
operator|=
name|svn_location_segment_dup
argument_list|(
name|segment
argument_list|,
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Populate *PATHS_HISTORY_MERGEINFO with mergeinfo representing the combined    history of each path in PATHS between START_REV and END_REV in REPOS's    filesystem.  START_REV and END_REV must be valid revisions.  RESULT_POOL    is used to allocate *PATHS_HISTORY_MERGEINFO, SCRATCH_POOL is used for all    other (temporary) allocations.  Other parameters are the same as    svn_repos_get_logs4(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_paths_history_as_mergeinfo
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|paths_history_mergeinfo
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_mergeinfo_t
name|path_history_mergeinfo
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end_rev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ensure START_REV is the youngest revision, as required by      svn_repos_node_location_segments, for which this is an iterative      wrapper. */
if|if
condition|(
name|start_rev
operator|<
name|end_rev
condition|)
block|{
name|svn_revnum_t
name|tmp_rev
init|=
name|start_rev
decl_stmt|;
name|start_rev
operator|=
name|end_rev
expr_stmt|;
name|end_rev
operator|=
name|tmp_rev
expr_stmt|;
block|}
operator|*
name|paths_history_mergeinfo
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|this_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|struct
name|location_segment_baton
name|loc_seg_baton
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|loc_seg_baton
operator|.
name|pool
operator|=
name|scratch_pool
expr_stmt|;
name|loc_seg_baton
operator|.
name|history_segments
operator|=
name|apr_array_make
argument_list|(
name|iterpool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_location_segment_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_node_location_segments
argument_list|(
name|repos
argument_list|,
name|this_path
argument_list|,
name|start_rev
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|location_segment_receiver
argument_list|,
operator|&
name|loc_seg_baton
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__mergeinfo_from_segments
argument_list|(
operator|&
name|path_history_mergeinfo
argument_list|,
name|loc_seg_baton
operator|.
name|history_segments
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
operator|*
name|paths_history_mergeinfo
argument_list|,
name|svn_mergeinfo_dup
argument_list|(
name|path_history_mergeinfo
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_repos_get_logs4
parameter_list|(
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_repos_authz_func_t
name|authz_read_func
parameter_list|,
name|void
modifier|*
name|authz_read_baton
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|head
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|repos
operator|->
name|fs
decl_stmt|;
name|svn_boolean_t
name|descending_order
decl_stmt|;
name|svn_mergeinfo_t
name|paths_history_mergeinfo
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|revprops
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|new_revprops
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|revprops
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_string_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revprops
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|new_revprops
argument_list|,
name|svn_string_t
operator|*
argument_list|)
operator|=
name|svn_string_create
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|revprops
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|revprops
operator|=
name|new_revprops
expr_stmt|;
block|}
comment|/* Setup log range. */
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|head
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start
argument_list|)
condition|)
name|start
operator|=
name|head
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end
argument_list|)
condition|)
name|end
operator|=
name|head
expr_stmt|;
comment|/* Check that revisions are sane before ever invoking receiver. */
if|if
condition|(
name|start
operator|>
name|head
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"No such revision %ld"
argument_list|)
argument_list|,
name|start
argument_list|)
return|;
if|if
condition|(
name|end
operator|>
name|head
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"No such revision %ld"
argument_list|)
argument_list|,
name|end
argument_list|)
return|;
comment|/* Ensure a youngest-to-oldest revision crawl ordering using our      (possibly sanitized) range values. */
name|descending_order
operator|=
name|start
operator|>=
name|end
expr_stmt|;
if|if
condition|(
name|descending_order
condition|)
block|{
name|svn_revnum_t
name|tmp_rev
init|=
name|start
decl_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|tmp_rev
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|paths
condition|)
name|paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're not including merged revisions, and we were given no      paths or a single empty (or "/") path, then we can bypass a bunch      of complexity because we already know in which revisions the root      directory was changed -- all of them.  */
if|if
condition|(
operator|(
operator|!
name|include_merged_revisions
operator|)
operator|&&
operator|(
operator|(
operator|!
name|paths
operator|->
name|nelts
operator|)
operator|||
operator|(
operator|(
name|paths
operator|->
name|nelts
operator|==
literal|1
operator|)
operator|&&
operator|(
name|svn_path_is_empty
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
operator|||
operator|(
name|strcmp
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|apr_uint64_t
name|send_count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* If we are provided an authz callback function, use it to          verify that the user has read access to the root path in the          first of our revisions.           ### FIXME:  Strictly speaking, we should be checking this          ### access in every revision along the line.  But currently,          ### there are no known authz implementations which concern          ### themselves with per-revision access.  */
if|if
condition|(
name|authz_read_func
condition|)
block|{
name|svn_boolean_t
name|readable
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|rev_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|rev_root
argument_list|,
name|fs
argument_list|,
name|descending_order
condition|?
name|end
else|:
name|start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|authz_read_func
argument_list|(
operator|&
name|readable
argument_list|,
name|rev_root
argument_list|,
literal|""
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_AUTHZ_UNREADABLE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|send_count
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|limit
operator|>
literal|0
operator|&&
name|send_count
operator|>
name|limit
condition|)
name|send_count
operator|=
name|limit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|send_count
condition|;
operator|++
name|i
control|)
block|{
name|svn_revnum_t
name|rev
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|descending_order
condition|)
name|rev
operator|=
name|end
operator|-
name|i
expr_stmt|;
else|else
name|rev
operator|=
name|start
operator|+
name|i
expr_stmt|;
name|SVN_ERR
argument_list|(
name|send_log
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|discover_changed_paths
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|revprops
argument_list|,
name|FALSE
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If we are including merged revisions, then create mergeinfo that      represents all of PATHS' history between START and END.  We will use      this later to squelch duplicate log revisions that might exist in      both natural history and merged-in history.  See      http://subversion.tigris.org/issues/show_bug.cgi?id=3650#desc5 */
if|if
condition|(
name|include_merged_revisions
condition|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_paths_history_as_mergeinfo
argument_list|(
operator|&
name|paths_history_mergeinfo
argument_list|,
name|repos
argument_list|,
name|paths
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
return|return
name|do_logs
argument_list|(
name|repos
operator|->
name|fs
argument_list|,
name|paths
argument_list|,
name|paths_history_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|limit
argument_list|,
name|discover_changed_paths
argument_list|,
name|strict_node_history
argument_list|,
name|include_merged_revisions
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|revprops
argument_list|,
name|descending_order
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|authz_read_func
argument_list|,
name|authz_read_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

end_unit

