begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * wc_db_wcroot.c :  supporting datastructures for the administrative database  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_define
define|#
directive|define
name|SVN_WC__I_AM_WC_DB
end_define

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"wc_db_private.h"
end_include

begin_include
include|#
directive|include
file|"wc-queries.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* ### Same values as wc_db.c */
end_comment

begin_define
define|#
directive|define
name|SDB_FILE
value|"wc.db"
end_define

begin_define
define|#
directive|define
name|UNKNOWN_WC_ID
value|((apr_int64_t) -1)
end_define

begin_define
define|#
directive|define
name|FORMAT_FROM_SDB
value|(-1)
end_define

begin_escape
end_escape

begin_comment
comment|/* Get the format version from a wc-1 directory. If it is not a working copy    directory, then it sets VERSION to zero and returns no error.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_old_version
parameter_list|(
name|int
modifier|*
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_file_path
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* Try reading the format number from the entries file.  */
name|format_file_path
operator|=
name|svn_wc__adm_child
argument_list|(
name|abspath
argument_list|,
name|SVN_WC__ADM_ENTRIES
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Since trying to open a non-existent file is quite expensive, try a      quick stat call first. In wc-ng w/cs, this will be an early exit. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|format_file_path
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
operator|*
name|version
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|err
operator|=
name|svn_io_read_version_file
argument_list|(
name|version
argument_list|,
name|format_file_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
operator|&&
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|&&
operator|!
name|APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_MISSING
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"'%s' does not exist"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* This must be a really old working copy!  Fall back to reading the      format file.       Note that the format file might not exist in newer working copies      (format 7 and higher), but in that case, the entries file should      have contained the format number. */
name|format_file_path
operator|=
name|svn_wc__adm_child
argument_list|(
name|abspath
argument_list|,
name|SVN_WC__ADM_FORMAT
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_read_version_file
argument_list|(
name|version
argument_list|,
name|format_file_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Whatever error may have occurred... we can just ignore. This is not      a working copy directory. Signal the caller.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|version
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A helper function to parse_local_abspath() which returns the on-disk KIND    of LOCAL_ABSPATH, using DB and SCRATCH_POOL as needed.     This function may do strange things, but at long as it comes up with the    Right Answer, we should be happy. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_path_kind
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|special
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
comment|/* This implements a *really* simple LRU cache, where "simple" is defined      as "only one element".  In other words, we remember the most recently      queried path, and nothing else.  This gives>80% cache hits. */
if|if
condition|(
name|db
operator|->
name|parse_cache
operator|.
name|abspath
operator|&&
name|strcmp
argument_list|(
name|db
operator|->
name|parse_cache
operator|.
name|abspath
operator|->
name|data
argument_list|,
name|local_abspath
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Cache hit! */
operator|*
name|kind
operator|=
name|db
operator|->
name|parse_cache
operator|.
name|kind
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|db
operator|->
name|parse_cache
operator|.
name|abspath
condition|)
block|{
name|db
operator|->
name|parse_cache
operator|.
name|abspath
operator|=
name|svn_stringbuf_create
argument_list|(
name|local_abspath
argument_list|,
name|db
operator|->
name|state_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_stringbuf_set
argument_list|(
name|db
operator|->
name|parse_cache
operator|.
name|abspath
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|node_kind
argument_list|,
operator|&
name|special
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|parse_cache
operator|.
name|kind
operator|=
operator|(
name|special
condition|?
name|svn_node_symlink
else|:
name|node_kind
operator|)
expr_stmt|;
operator|*
name|kind
operator|=
name|db
operator|->
name|parse_cache
operator|.
name|kind
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return an error if the work queue in SDB is non-empty. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_no_work
parameter_list|(
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|sdb
argument_list|,
name|STMT_LOOK_FOR_WORK
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_row
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CLEANUP_REQUIRED
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* nothing to add.  */
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_function
specifier|static
name|apr_status_t
name|close_wcroot
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
init|=
name|data
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|wcroot
operator|->
name|sdb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_sqlite__close
argument_list|(
name|wcroot
operator|->
name|sdb
argument_list|)
expr_stmt|;
name|wcroot
operator|->
name|sdb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|apr_status_t
name|result
init|=
name|err
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_open
parameter_list|(
name|svn_wc__db_t
modifier|*
modifier|*
name|db
parameter_list|,
name|svn_config_t
modifier|*
name|config
parameter_list|,
name|svn_boolean_t
name|open_without_upgrade
parameter_list|,
name|svn_boolean_t
name|enforce_empty_wq
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|db
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|db
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|config
operator|=
name|config
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|verify_format
operator|=
operator|!
name|open_without_upgrade
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|enforce_empty_wq
operator|=
name|enforce_empty_wq
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|dir_data
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
operator|(
operator|*
name|db
operator|)
operator|->
name|state_pool
operator|=
name|result_pool
expr_stmt|;
comment|/* Don't need to initialize (*db)->parse_cache, due to the calloc above */
if|if
condition|(
name|config
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|sqlite_exclusive
init|=
name|FALSE
decl_stmt|;
name|err
operator|=
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|sqlite_exclusive
argument_list|,
name|SVN_CONFIG_SECTION_WORKING_COPY
argument_list|,
name|SVN_CONFIG_OPTION_SQLITE_EXCLUSIVE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|db
operator|)
operator|->
name|exclusive
operator|=
name|sqlite_exclusive
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_close
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|db
operator|->
name|state_pool
decl_stmt|;
name|apr_hash_t
modifier|*
name|roots
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Collect all the unique WCROOT structures, and empty out DIR_DATA.  */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|db
operator|->
name|dir_data
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|wcroot
operator|->
name|sdb
condition|)
name|svn_hash_sets
argument_list|(
name|roots
argument_list|,
name|wcroot
operator|->
name|abspath
argument_list|,
name|wcroot
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Run the cleanup for each WCROOT.  */
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__db_close_many_wcroots
argument_list|(
name|roots
argument_list|,
name|db
operator|->
name|state_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_pdh_create_wcroot
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|wcroot_abspath
parameter_list|,
name|svn_sqlite__db_t
modifier|*
name|sdb
parameter_list|,
name|apr_int64_t
name|wc_id
parameter_list|,
name|int
name|format
parameter_list|,
name|svn_boolean_t
name|verify_format
parameter_list|,
name|svn_boolean_t
name|enforce_empty_wq
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|sdb
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__read_schema_version
argument_list|(
operator|&
name|format
argument_list|,
name|sdb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we construct a wcroot, then we better have a format.  */
name|SVN_ERR_ASSERT
argument_list|(
name|format
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|/* If this working copy is PRE-1.0, then simply bail out.  */
if|if
condition|(
name|format
operator|<
literal|4
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Working copy format of '%s' is too old (%d); "
literal|"please check out your working copy again"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|format
argument_list|)
return|;
block|}
comment|/* If this working copy is from a future version, then bail out.  */
if|if
condition|(
name|format
operator|>
name|SVN_WC__VERSION
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"This client is too old to work with the working copy at\n"
literal|"'%s' (format %d).\n"
literal|"You need to get a newer Subversion client. For more details, see\n"
literal|"  http://subversion.apache.org/faq.html#working-copy-format-change\n"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|format
argument_list|)
return|;
block|}
comment|/* Verify that no work items exists. If they do, then our integrity is      suspect and, thus, we cannot use this database.  */
if|if
condition|(
name|format
operator|>=
name|SVN_WC__HAS_WORK_QUEUE
operator|&&
operator|(
name|enforce_empty_wq
operator|||
operator|(
name|format
operator|<
name|SVN_WC__VERSION
operator|&&
name|verify_format
operator|)
operator|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|verify_no_work
argument_list|(
name|sdb
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Special message for attempts to upgrade a 1.7-dev wc with              outstanding workqueue items. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_CLEANUP_REQUIRED
operator|&&
name|format
operator|<
name|SVN_WC__VERSION
operator|&&
name|verify_format
condition|)
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Cleanup with an older 1.7 "
literal|"client before upgrading with "
literal|"this client"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* Auto-upgrade the SDB if possible.  */
if|if
condition|(
name|format
operator|<
name|SVN_WC__VERSION
operator|&&
name|verify_format
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_UPGRADE_REQUIRED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The working copy at '%s'\nis too old "
literal|"(format %d) to work with client version "
literal|"'%s' (expects format %d). You need to "
literal|"upgrade the working copy first.\n"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|format
argument_list|,
name|SVN_VERSION
argument_list|,
name|SVN_WC__VERSION
argument_list|)
return|;
block|}
operator|*
name|wcroot
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|wcroot
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|wcroot
operator|)
operator|->
name|abspath
operator|=
name|wcroot_abspath
expr_stmt|;
operator|(
operator|*
name|wcroot
operator|)
operator|->
name|sdb
operator|=
name|sdb
expr_stmt|;
operator|(
operator|*
name|wcroot
operator|)
operator|->
name|wc_id
operator|=
name|wc_id
expr_stmt|;
operator|(
operator|*
name|wcroot
operator|)
operator|->
name|format
operator|=
name|format
expr_stmt|;
comment|/* 8 concurrent locks is probably more than a typical wc_ng based svn client      uses. */
operator|(
operator|*
name|wcroot
operator|)
operator|->
name|owned_locks
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc__db_wclock_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|wcroot
operator|)
operator|->
name|access_cache
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* SDB will be NULL for pre-NG working copies. We only need to run a      cleanup when the SDB is present.  */
if|if
condition|(
name|sdb
operator|!=
name|NULL
condition|)
name|apr_pool_cleanup_register
argument_list|(
name|result_pool
argument_list|,
operator|*
name|wcroot
argument_list|,
name|close_wcroot
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_close_many_wcroots
parameter_list|(
name|apr_hash_t
modifier|*
name|roots
parameter_list|,
name|apr_pool_t
modifier|*
name|state_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|roots
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_status_t
name|result
decl_stmt|;
name|result
operator|=
name|apr_pool_cleanup_run
argument_list|(
name|state_pool
argument_list|,
name|wcroot
argument_list|,
name|close_wcroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* POOL may be NULL if the lifetime of LOCAL_ABSPATH is sufficient.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|compute_relpath
parameter_list|(
specifier|const
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_dirent_is_child
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|relpath
operator|==
name|NULL
condition|)
return|return
literal|""
return|;
return|return
name|relpath
return|;
block|}
end_function

begin_comment
comment|/* Return in *LINK_TARGET_ABSPATH the absolute path the symlink at  * LOCAL_ABSPATH is pointing to. Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_link_target
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|link_target_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|link_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|canon_link_target
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_link
argument_list|(
operator|&
name|link_target
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_target
operator|->
name|len
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_SYMLINK
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The symlink at '%s' points nowhere"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|canon_link_target
operator|=
name|svn_dirent_canonicalize
argument_list|(
name|link_target
operator|->
name|data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Treat relative symlinks as relative to LOCAL_ABSPATH's parent. */
if|if
condition|(
operator|!
name|svn_dirent_is_absolute
argument_list|(
name|canon_link_target
argument_list|)
condition|)
name|canon_link_target
operator|=
name|svn_dirent_join
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|,
name|canon_link_target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Collapse any .. in the symlink part of the path. */
if|if
condition|(
name|svn_path_is_backpath_present
argument_list|(
name|canon_link_target
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
name|link_target_abspath
argument_list|,
name|canon_link_target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|link_target_abspath
operator|=
name|canon_link_target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_wcroot_parse_local_abspath
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|local_relpath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_dir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_abspath
init|=
name|local_abspath
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|build_relpath
decl_stmt|;
name|svn_wc__db_wcroot_t
modifier|*
name|probe_wcroot
decl_stmt|;
name|svn_wc__db_wcroot_t
modifier|*
name|found_wcroot
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan_abspath
decl_stmt|;
name|svn_sqlite__db_t
modifier|*
name|sdb
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|moved_upwards
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|always_check
init|=
name|FALSE
decl_stmt|;
name|int
name|wc_format
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|adm_relpath
decl_stmt|;
comment|/* Non-NULL if WCROOT is found through a symlink: */
specifier|const
name|char
modifier|*
name|symlink_wcroot_abspath
init|=
name|NULL
decl_stmt|;
comment|/* ### we need more logic for finding the database (if it is located      ### outside of the wcroot) and then managing all of that within DB.      ### for now: play quick& dirty. */
name|probe_wcroot
operator|=
name|svn_hash_gets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe_wcroot
operator|!=
name|NULL
condition|)
block|{
operator|*
name|wcroot
operator|=
name|probe_wcroot
expr_stmt|;
comment|/* We got lucky. Just return the thing BEFORE performing any I/O.  */
comment|/* ### validate SMODE against how we opened wcroot->sdb? and against          ### DB->mode? (will we record per-dir mode?)  */
comment|/* ### for most callers, we could pass NULL for result_pool.  */
operator|*
name|local_relpath
operator|=
name|compute_relpath
argument_list|(
name|probe_wcroot
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* ### at some point in the future, we may need to find a way to get      ### rid of this stat() call. it is going to happen for EVERY call      ### into wc_db which references a file. calls for directories could      ### get an early-exit in the hash lookup just above.  */
name|SVN_ERR
argument_list|(
name|get_path_kind
argument_list|(
operator|&
name|kind
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
comment|/* If the node specified by the path is NOT present, then it cannot          possibly be a directory containing ".svn/wc.db".           If it is a file, then it cannot contain ".svn/wc.db".           For both of these cases, strip the basename off of the path and          move up one level. Keep record of what we strip, though, since          we'll need it later to construct local_relpath.  */
name|svn_dirent_split
argument_list|(
operator|&
name|local_dir_abspath
argument_list|,
operator|&
name|build_relpath
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Is this directory in our hash?  */
name|probe_wcroot
operator|=
name|svn_hash_gets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|local_dir_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe_wcroot
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|dir_relpath
decl_stmt|;
operator|*
name|wcroot
operator|=
name|probe_wcroot
expr_stmt|;
comment|/* Stashed directory's local_relpath + basename. */
name|dir_relpath
operator|=
name|compute_relpath
argument_list|(
name|probe_wcroot
argument_list|,
name|local_dir_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|local_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|dir_relpath
argument_list|,
name|build_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If the requested path is not on the disk, then we don't know how          many ancestors need to be scanned until we start hitting content          on the disk. Set ALWAYS_CHECK to keep looking for .svn/entries          rather than bailing out after the first check.  */
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
name|always_check
operator|=
name|TRUE
expr_stmt|;
comment|/* Start the scanning at LOCAL_DIR_ABSPATH.  */
name|local_abspath
operator|=
name|local_dir_abspath
expr_stmt|;
block|}
else|else
block|{
comment|/* Start the local_relpath empty. If *this* directory contains the          wc.db, then relpath will be the empty string.  */
name|build_relpath
operator|=
literal|""
expr_stmt|;
comment|/* Remember the dir containing LOCAL_ABSPATH (they're the same).  */
name|local_dir_abspath
operator|=
name|local_abspath
expr_stmt|;
block|}
comment|/* LOCAL_ABSPATH refers to a directory at this point. At this point,      we've determined that an associated WCROOT is NOT in the DB's hash      table for this directory. Let's find an existing one in the ancestors,      or create one when we find the actual wcroot.  */
comment|/* Assume that LOCAL_ABSPATH is a directory, and look for the SQLite      database in the right place. If we find it... great! If not, then      peel off some components, and try again. */
name|adm_relpath
operator|=
name|svn_wc_get_adm_dir
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_node_kind_t
name|adm_subdir_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|adm_subdir
init|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|adm_relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|adm_subdir
argument_list|,
operator|&
name|adm_subdir_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adm_subdir_kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* We always open the database in read/write mode.  If the database              isn't writable in the filesystem, SQLite will internally open              it as read-only, and we'll get an error if we try to do a write              operation.               We could decide what to do on a per-operation basis, but since              we're caching database handles, it make sense to be as permissive              as the filesystem allows. */
name|err
operator|=
name|svn_wc__db_util_open_db
argument_list|(
operator|&
name|sdb
argument_list|,
name|local_abspath
argument_list|,
name|SDB_FILE
argument_list|,
name|svn_sqlite__mode_readwrite
argument_list|,
name|db
operator|->
name|exclusive
argument_list|,
name|NULL
argument_list|,
name|db
operator|->
name|state_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SVN_DEBUG
comment|/* Install self-verification trigger statements. */
name|err
operator|=
name|svn_sqlite__exec_statements
argument_list|(
name|sdb
argument_list|,
name|STMT_VERIFICATION_TRIGGERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_SQLITE_ERROR
condition|)
block|{
comment|/* Verification triggers can fail to install on old 1.7-dev                    * formats which didn't have a NODES table yet. Ignore sqlite                    * errors so such working copies can be upgraded. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_SQLITE_ERROR
operator|&&
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* If we have not moved upwards, then check for a wc-1 working copy.              Since wc-1 has a .svn in every directory, and we didn't find one              in the original directory, then we aren't looking at a wc-1.               If the original path is not present, then we have to check on every              iteration. The content may be the immediate parent, or possibly              five ancetors higher. We don't test for directory presence (just              for the presence of subdirs/files), so we don't know when we can              stop checking ... so just check always.  */
if|if
condition|(
operator|!
name|moved_upwards
operator|||
name|always_check
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_old_version
argument_list|(
operator|&
name|wc_format
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_format
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* We couldn't open the SDB within the specified directory, so          move up one more directory. */
if|if
condition|(
name|svn_dirent_is_root
argument_list|(
name|local_abspath
argument_list|,
name|strlen
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Hit the root without finding a wcroot. */
comment|/* The wcroot could be a symlink to a directory.            * (Issue #2557, #3987). If so, try again, this time scanning            * for a db within the directory the symlink points to,            * rather than within the symlink's parent directory. */
if|if
condition|(
name|kind
operator|==
name|svn_node_symlink
condition|)
block|{
name|svn_node_kind_t
name|resolved_kind
decl_stmt|;
name|local_abspath
operator|=
name|original_abspath
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_resolved_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|resolved_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolved_kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* Is this directory recorded in our hash?  */
name|found_wcroot
operator|=
name|svn_hash_gets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_wcroot
condition|)
break|break;
name|symlink_wcroot_abspath
operator|=
name|local_abspath
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_link_target
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|try_symlink_as_dir
label|:
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|moved_upwards
operator|=
name|FALSE
expr_stmt|;
name|local_dir_abspath
operator|=
name|local_abspath
expr_stmt|;
name|build_relpath
operator|=
literal|""
expr_stmt|;
continue|continue;
block|}
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|original_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|local_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|moved_upwards
operator|=
name|TRUE
expr_stmt|;
name|symlink_wcroot_abspath
operator|=
name|NULL
expr_stmt|;
comment|/* Is the parent directory recorded in our hash?  */
name|found_wcroot
operator|=
name|svn_hash_gets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_wcroot
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|found_wcroot
operator|!=
name|NULL
condition|)
block|{
comment|/* We found a hash table entry for an ancestor, so we stopped scanning          since all subdirectories use the same WCROOT.  */
operator|*
name|wcroot
operator|=
name|found_wcroot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc_format
operator|==
literal|0
condition|)
block|{
comment|/* We finally found the database. Construct a wcroot_t for it.  */
name|apr_int64_t
name|wc_id
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc__db_util_fetch_wc_id
argument_list|(
operator|&
name|wc_id
argument_list|,
name|sdb
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_CORRUPT
condition|)
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Missing a row in WCROOT for '%s'."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|original_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* WCROOT.local_abspath may be NULL when the database is stored          inside the wcroot, but we know the abspath is this directory          (ie. where we found it).  */
name|err
operator|=
name|svn_wc__db_pdh_create_wcroot
argument_list|(
name|wcroot
argument_list|,
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|state_pool
argument_list|,
name|symlink_wcroot_abspath
condition|?
name|symlink_wcroot_abspath
else|:
name|local_abspath
argument_list|)
argument_list|,
name|sdb
argument_list|,
name|wc_id
argument_list|,
name|FORMAT_FROM_SDB
argument_list|,
name|db
operator|->
name|verify_format
argument_list|,
name|db
operator|->
name|enforce_empty_wq
argument_list|,
name|db
operator|->
name|state_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_UNSUPPORTED_FORMAT
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_UPGRADE_REQUIRED
operator|)
operator|&&
name|kind
operator|==
name|svn_node_symlink
condition|)
block|{
comment|/* We found an unsupported WC after traversing upwards from a            * symlink. Fall through to code below to check if the symlink            * points at a supported WC. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|wcroot
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
comment|/* Close handle if we are not going to use it to support              upgrading with exclusive wc locking. */
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_sqlite__close
argument_list|(
name|sdb
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* We found something that looks like a wc-1 working copy directory.          However, if the format version is 12 and the .svn/entries file          is only 3 bytes long, then it's a breadcrumb in a wc-ng working          copy that's missing an .svn/wc.db, or its .svn/wc.db is corrupt. */
if|if
condition|(
name|wc_format
operator|==
name|SVN_WC__WC_NG_VERSION
comment|/* 12 */
condition|)
block|{
name|apr_finfo_t
name|info
decl_stmt|;
comment|/* Check attributes of .svn/entries */
specifier|const
name|char
modifier|*
name|admin_abspath
init|=
name|svn_wc__adm_child
argument_list|(
name|local_abspath
argument_list|,
name|SVN_WC__ADM_ENTRIES
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_stat
argument_list|(
operator|&
name|info
argument_list|,
name|admin_abspath
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* If the former does not succeed, something is seriously wrong. */
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"The working copy at '%s' is corrupt."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
literal|3
operator|==
name|info
operator|.
name|size
condition|)
block|{
comment|/* Check existence of .svn/wc.db */
name|admin_abspath
operator|=
name|svn_wc__adm_child
argument_list|(
name|local_abspath
argument_list|,
name|SDB_FILE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_stat
argument_list|(
operator|&
name|info
argument_list|,
name|admin_abspath
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The working copy database at '%s' is missing."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
comment|/* We should never have reached this point in the code                    if .svn/wc.db exists; therefore it's best to assume                    it's corrupt. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"The working copy database at '%s' is corrupt."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_pdh_create_wcroot
argument_list|(
name|wcroot
argument_list|,
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|state_pool
argument_list|,
name|symlink_wcroot_abspath
condition|?
name|symlink_wcroot_abspath
else|:
name|local_abspath
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|UNKNOWN_WC_ID
argument_list|,
name|wc_format
argument_list|,
name|db
operator|->
name|verify_format
argument_list|,
name|db
operator|->
name|enforce_empty_wq
argument_list|,
name|db
operator|->
name|state_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|wcroot
condition|)
block|{
specifier|const
name|char
modifier|*
name|dir_relpath
decl_stmt|;
if|if
condition|(
name|symlink_wcroot_abspath
condition|)
block|{
comment|/* The WCROOT was found through a symlink pointing at the root of            * the WC. Cache the WCROOT under the symlink's path. */
name|local_dir_abspath
operator|=
name|symlink_wcroot_abspath
expr_stmt|;
block|}
comment|/* The subdirectory's relpath is easily computed relative to the          wcroot that we just found.  */
name|dir_relpath
operator|=
name|compute_relpath
argument_list|(
operator|*
name|wcroot
argument_list|,
name|local_dir_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* And the result local_relpath may include a filename.  */
operator|*
name|local_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|dir_relpath
argument_list|,
name|build_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_symlink
condition|)
block|{
name|svn_boolean_t
name|retry_if_dir
init|=
name|FALSE
decl_stmt|;
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Check if the symlink is versioned or obstructs a versioned node        * in this DB -- in that case, use this wcroot. Else, if the symlink        * points to a directory, try to find a wcroot in that directory        * instead. */
if|if
condition|(
operator|*
name|wcroot
condition|)
block|{
name|err
operator|=
name|svn_wc__db_read_info_internal
argument_list|(
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|*
name|wcroot
argument_list|,
operator|*
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|&&
operator|!
name|SVN_WC__ERR_IS_NOT_CURRENT_WC
argument_list|(
name|err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|retry_if_dir
operator|=
name|TRUE
expr_stmt|;
comment|/* The symlink is unversioned. */
block|}
else|else
block|{
comment|/* The symlink is versioned, or obstructs a versioned node.                * Ignore non-conflicted not-present/excluded nodes.                * This allows the symlink to redirect the wcroot query to a                * directory, regardless of 'invisible' nodes in this WC. */
name|retry_if_dir
operator|=
operator|(
operator|(
name|status
operator|==
name|svn_wc__db_status_not_present
operator|||
name|status
operator|==
name|svn_wc__db_status_excluded
operator|||
name|status
operator|==
name|svn_wc__db_status_server_excluded
operator|)
operator|&&
operator|!
name|conflicted
operator|)
expr_stmt|;
block|}
block|}
else|else
name|retry_if_dir
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|retry_if_dir
condition|)
block|{
name|svn_node_kind_t
name|resolved_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_resolved_path
argument_list|(
name|original_abspath
argument_list|,
operator|&
name|resolved_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolved_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|symlink_wcroot_abspath
operator|=
name|original_abspath
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_link_target
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|original_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This handle was opened in this function but is not going                  to be used further so close it. */
if|if
condition|(
name|sdb
condition|)
name|SVN_ERR
argument_list|(
name|svn_sqlite__close
argument_list|(
name|sdb
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|try_symlink_as_dir
goto|;
block|}
block|}
block|}
comment|/* We've found the appropriate WCROOT for the requested path. Stash      it into that path's directory.  */
name|svn_hash_sets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|state_pool
argument_list|,
name|local_dir_abspath
argument_list|)
argument_list|,
operator|*
name|wcroot
argument_list|)
expr_stmt|;
comment|/* Did we traverse up to parent directories?  */
if|if
condition|(
operator|!
name|moved_upwards
condition|)
block|{
comment|/* We did NOT move to a parent of the original requested directory.          We've constructed and filled in a WCROOT for the request, so we          are done.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The WCROOT that we just found/built was for the LOCAL_ABSPATH originally      passed into this function. We stepped *at least* one directory above that.      We should now associate the WROOT for each parent directory that does      not (yet) have one.  */
name|scan_abspath
operator|=
name|local_dir_abspath
expr_stmt|;
do|do
block|{
specifier|const
name|char
modifier|*
name|parent_dir
init|=
name|svn_dirent_dirname
argument_list|(
name|scan_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_wc__db_wcroot_t
modifier|*
name|parent_wcroot
decl_stmt|;
name|parent_wcroot
operator|=
name|svn_hash_gets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|parent_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_wcroot
operator|==
name|NULL
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|apr_pstrdup
argument_list|(
name|db
operator|->
name|state_pool
argument_list|,
name|parent_dir
argument_list|)
argument_list|,
operator|*
name|wcroot
argument_list|)
expr_stmt|;
block|}
comment|/* Move up a directory, stopping when we reach the directory where          we found/built the WCROOT.  */
name|scan_abspath
operator|=
name|parent_dir
expr_stmt|;
block|}
do|while
condition|(
name|strcmp
argument_list|(
name|scan_abspath
argument_list|,
name|local_abspath
argument_list|)
operator|!=
literal|0
condition|)
do|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_drop_root
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|root_wcroot
init|=
name|svn_hash_gets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|local_abspath
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_status_t
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|root_wcroot
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|root_wcroot
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a working copy root"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|db
operator|->
name|dir_data
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|wcroot
operator|==
name|root_wcroot
condition|)
name|svn_hash_sets
argument_list|(
name|db
operator|->
name|dir_data
argument_list|,
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|apr_pool_cleanup_run
argument_list|(
name|db
operator|->
name|state_pool
argument_list|,
name|root_wcroot
argument_list|,
name|close_wcroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

