begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * merge.c:  merging changes into a working file  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"adm_files.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Contains some information on the merge target before merge, and some    information needed for the diff processing. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|merge_target_t
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
comment|/* The DB used to access target */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* The absolute path to target */
specifier|const
name|char
modifier|*
name|wri_abspath
decl_stmt|;
comment|/* The working copy of target */
name|apr_hash_t
modifier|*
name|old_actual_props
decl_stmt|;
comment|/* The set of actual properties                                                before merging */
specifier|const
name|apr_array_header_t
modifier|*
name|prop_diff
decl_stmt|;
comment|/* The property changes */
specifier|const
name|char
modifier|*
name|diff3_cmd
decl_stmt|;
comment|/* The diff3 command and options */
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
decl_stmt|;
block|}
name|merge_target_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Return a pointer to the svn_prop_t structure from PROP_DIFF    belonging to PROP_NAME, if any.  NULL otherwise.*/
end_comment

begin_function
specifier|static
specifier|const
name|svn_prop_t
modifier|*
name|get_prop
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|prop_diff
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|)
block|{
if|if
condition|(
name|prop_diff
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_diff
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|elt
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|prop_diff
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|elt
operator|->
name|name
argument_list|,
name|prop_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|elt
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Detranslate a working copy file MERGE_TARGET to achieve the effect of:     1. Detranslate    2. Install new props    3. Retranslate    4. Detranslate     in one pass, to get a file which can be compared with the left and right    files which are in repository normal form.     Property changes make this a little complex though. Changes in     - svn:mime-type    - svn:eol-style    - svn:keywords    - svn:special     may change the way a file is translated.     Effect for svn:mime-type:       If svn:mime-type is considered 'binary', we ignore svn:eol-style (but      still translate keywords).       I) both old and new mime-types are texty         -> just do the translation dance (as lined out below)            ### actually we do a shortcut with just one translation:            detranslate with the old keywords and ... eol-style            (the new re+detranslation is a no-op w.r.t. keywords [1])       II) the old one is texty, the new one is binary         -> detranslate with the old eol-style and keywords            (the new re+detranslation is a no-op [1])       III) the old one is binary, the new one texty         -> detranslate with the old keywords and new eol-style            (the old detranslation is a no-op w.r.t. eol, and             the new re+detranslation is a no-op w.r.t. keywords [1])       IV) the old and new ones are binary         -> detranslate with the old keywords            (the new re+detranslation is a no-op [1])     Effect for svn:eol-style       I) On add or change of svn:eol-style, use the new value       II) otherwise: use the old value (absent means 'no translation')     Effect for svn:keywords       Always use the old settings (re+detranslation are no-op [1]).       [1] Translation of keywords from repository normal form to WC form and          back is normally a no-op, but is not a no-op if text contains a kw          that is only enabled by the new props and is present in non-          contracted form (such as "$Rev: 1234 $").  If we want to catch this          case we should detranslate with both the old& the new keywords          together.     Effect for svn:special       Always use the old settings (re+detranslation are no-op).    Sets *DETRANSLATED_ABSPATH to the path to the detranslated file,   this may be the same as SOURCE_ABSPATH if FORCE_COPY is FALSE and no   translation is required.    If FORCE_COPY is FALSE and *DETRANSLATED_ABSPATH is a file distinct   from SOURCE_ABSPATH then the file will be deleted on RESULT_POOL   cleanup.    If FORCE_COPY is TRUE then *DETRANSLATED_ABSPATH will always be a   new file distinct from SOURCE_ABSPATH and it will be the callers   responsibility to delete the file.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|detranslate_wc_file
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|detranslated_abspath
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|mt
parameter_list|,
name|svn_boolean_t
name|force_copy
parameter_list|,
specifier|const
name|char
modifier|*
name|source_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|old_is_binary
decl_stmt|,
name|new_is_binary
decl_stmt|;
name|svn_subst_eol_style_t
name|style
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
name|apr_hash_t
modifier|*
name|keywords
decl_stmt|;
name|svn_boolean_t
name|special
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|old_mime_value
init|=
name|svn_prop_get_value
argument_list|(
name|mt
operator|->
name|old_actual_props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
decl_stmt|;
specifier|const
name|svn_prop_t
modifier|*
name|prop
init|=
name|get_prop
argument_list|(
name|mt
operator|->
name|prop_diff
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_mime_value
init|=
name|prop
condition|?
operator|(
name|prop
operator|->
name|value
condition|?
name|prop
operator|->
name|value
operator|->
name|data
else|:
name|NULL
operator|)
else|:
name|old_mime_value
decl_stmt|;
name|old_is_binary
operator|=
name|old_mime_value
operator|&&
name|svn_mime_type_is_binary
argument_list|(
name|old_mime_value
argument_list|)
expr_stmt|;
name|new_is_binary
operator|=
name|new_mime_value
operator|&&
name|svn_mime_type_is_binary
argument_list|(
name|new_mime_value
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
comment|/* See what translations we want to do */
if|if
condition|(
name|old_is_binary
operator|&&
name|new_is_binary
condition|)
block|{
comment|/* Case IV. Old and new props 'binary': detranslate keywords only */
name|SVN_ERR
argument_list|(
name|svn_wc__get_translate_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|keywords
argument_list|,
name|NULL
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|mt
operator|->
name|old_actual_props
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Why override 'special'? Elsewhere it has precedence. */
name|special
operator|=
name|FALSE
expr_stmt|;
name|eol
operator|=
name|NULL
expr_stmt|;
name|style
operator|=
name|svn_subst_eol_style_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|old_is_binary
operator|&&
name|new_is_binary
condition|)
block|{
comment|/* Case II. Old props indicate texty, new props indicate binary:          detranslate keywords and old eol-style */
name|SVN_ERR
argument_list|(
name|svn_wc__get_translate_info
argument_list|(
operator|&
name|style
argument_list|,
operator|&
name|eol
argument_list|,
operator|&
name|keywords
argument_list|,
operator|&
name|special
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|mt
operator|->
name|old_actual_props
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Case I& III. New props indicate texty, regardless of old props */
comment|/* In case the file used to be special, detranslate specially */
name|SVN_ERR
argument_list|(
name|svn_wc__get_translate_info
argument_list|(
operator|&
name|style
argument_list|,
operator|&
name|eol
argument_list|,
operator|&
name|keywords
argument_list|,
operator|&
name|special
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|mt
operator|->
name|old_actual_props
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|special
condition|)
block|{
name|keywords
operator|=
name|NULL
expr_stmt|;
name|eol
operator|=
name|NULL
expr_stmt|;
name|style
operator|=
name|svn_subst_eol_style_none
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
comment|/* In case a new eol style was set, use that for detranslation */
if|if
condition|(
operator|(
name|prop
operator|=
name|get_prop
argument_list|(
name|mt
operator|->
name|prop_diff
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
operator|)
operator|&&
name|prop
operator|->
name|value
condition|)
block|{
comment|/* Value added or changed */
name|svn_subst_eol_style_from_value
argument_list|(
operator|&
name|style
argument_list|,
operator|&
name|eol
argument_list|,
name|prop
operator|->
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|old_is_binary
condition|)
block|{
comment|/* Already fetched */
block|}
else|else
block|{
name|eol
operator|=
name|NULL
expr_stmt|;
name|style
operator|=
name|svn_subst_eol_style_none
expr_stmt|;
block|}
block|}
block|}
comment|/* Now, detranslate with the settings we created above */
if|if
condition|(
name|force_copy
operator|||
name|keywords
operator|||
name|eol
operator|||
name|special
condition|)
block|{
specifier|const
name|char
modifier|*
name|temp_dir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|detranslated
decl_stmt|;
comment|/* Force a copy into the temporary wc area to avoid having          temporary files created below to appear in the actual wc. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|temp_dir_abspath
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### svn_subst_copy_and_translate4() also creates a tempfile          ### internally.  Anyway to piggyback on that? */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|detranslated
argument_list|,
name|temp_dir_abspath
argument_list|,
operator|(
name|force_copy
condition|?
name|svn_io_file_del_none
else|:
name|svn_io_file_del_on_pool_cleanup
operator|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Always 'repair' EOLs here, so that we can apply a diff that          changes from inconsistent newlines and no 'svn:eol-style' to          consistent newlines and 'svn:eol-style' set.  */
if|if
condition|(
name|style
operator|==
name|svn_subst_eol_style_native
condition|)
name|eol
operator|=
name|SVN_SUBST_NATIVE_EOL_STR
expr_stmt|;
elseif|else
if|if
condition|(
name|style
operator|!=
name|svn_subst_eol_style_fixed
operator|&&
name|style
operator|!=
name|svn_subst_eol_style_none
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_UNKNOWN_EOL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_subst_copy_and_translate4
argument_list|(
name|source_abspath
argument_list|,
name|detranslated
argument_list|,
name|eol
argument_list|,
name|TRUE
comment|/* repair */
argument_list|,
name|keywords
argument_list|,
name|FALSE
comment|/* contract keywords */
argument_list|,
name|special
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
name|detranslated_abspath
argument_list|,
name|detranslated
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|detranslated_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|source_abspath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Updates (by copying and translating) the eol style in    OLD_TARGET_ABSPATH returning the filename containing the    correct eol style in NEW_TARGET_ABSPATH, if an eol style    change is contained in PROP_DIFF. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|maybe_update_target_eols
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|new_target_abspath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|prop_diff
parameter_list|,
specifier|const
name|char
modifier|*
name|old_target_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|prop
init|=
name|get_prop
argument_list|(
name|prop_diff
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|value
condition|)
block|{
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_new
decl_stmt|;
name|svn_subst_eol_style_from_value
argument_list|(
name|NULL
argument_list|,
operator|&
name|eol
argument_list|,
name|prop
operator|->
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|tmp_new
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Always 'repair' EOLs here, so that we can apply a diff that          changes from inconsistent newlines and no 'svn:eol-style' to          consistent newlines and 'svn:eol-style' set.  */
name|SVN_ERR
argument_list|(
name|svn_subst_copy_and_translate4
argument_list|(
name|old_target_abspath
argument_list|,
name|tmp_new
argument_list|,
name|eol
argument_list|,
name|TRUE
comment|/* repair */
argument_list|,
name|NULL
comment|/* keywords */
argument_list|,
name|FALSE
comment|/* expand */
argument_list|,
name|FALSE
comment|/* special */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_target_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|tmp_new
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|new_target_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|old_target_abspath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *TARGET_MARKER, *LEFT_MARKER and *RIGHT_MARKER to strings suitable    for delimiting the alternative texts in a text conflict.  Include in each    marker a string that may be given by TARGET_LABEL, LEFT_LABEL and    RIGHT_LABEL respectively or a default value where any of those are NULL.     Allocate the results in POOL or statically. */
end_comment

begin_function
specifier|static
name|void
name|init_conflict_markers
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|target_marker
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|left_marker
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|right_marker
parameter_list|,
specifier|const
name|char
modifier|*
name|target_label
parameter_list|,
specifier|const
name|char
modifier|*
name|left_label
parameter_list|,
specifier|const
name|char
modifier|*
name|right_label
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Labels fall back to sensible defaults if not specified. */
if|if
condition|(
name|target_label
condition|)
operator|*
name|target_marker
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"<<<<<<< %s"
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
else|else
operator|*
name|target_marker
operator|=
literal|"<<<<<<< .working"
expr_stmt|;
if|if
condition|(
name|left_label
condition|)
operator|*
name|left_marker
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"||||||| %s"
argument_list|,
name|left_label
argument_list|)
expr_stmt|;
else|else
operator|*
name|left_marker
operator|=
literal|"||||||| .old"
expr_stmt|;
if|if
condition|(
name|right_label
condition|)
operator|*
name|right_marker
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|">>>>>>> %s"
argument_list|,
name|right_label
argument_list|)
expr_stmt|;
else|else
operator|*
name|right_marker
operator|=
literal|">>>>>>> .new"
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a 3-way merge of the files at paths LEFT, DETRANSLATED_TARGET,  * and RIGHT, using diff options provided in MERGE_OPTIONS.  Store the merge  * result in the file RESULT_F.  * If there are conflicts, set *CONTAINS_CONFLICTS to true, and use  * TARGET_LABEL, LEFT_LABEL, and RIGHT_LABEL as labels for conflict  * markers.  Else, set *CONTAINS_CONFLICTS to false.  * Do all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_text_merge
parameter_list|(
name|svn_boolean_t
modifier|*
name|contains_conflicts
parameter_list|,
name|apr_file_t
modifier|*
name|result_f
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
specifier|const
name|char
modifier|*
name|detranslated_target
parameter_list|,
specifier|const
name|char
modifier|*
name|left
parameter_list|,
specifier|const
name|char
modifier|*
name|right
parameter_list|,
specifier|const
name|char
modifier|*
name|target_label
parameter_list|,
specifier|const
name|char
modifier|*
name|left_label
parameter_list|,
specifier|const
name|char
modifier|*
name|right_label
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_stream_t
modifier|*
name|ostream
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_marker
decl_stmt|;
specifier|const
name|char
modifier|*
name|left_marker
decl_stmt|;
specifier|const
name|char
modifier|*
name|right_marker
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|diff3_options
decl_stmt|;
name|diff3_options
operator|=
name|svn_diff_file_options_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_options
condition|)
name|SVN_ERR
argument_list|(
name|svn_diff_file_options_parse
argument_list|(
name|diff3_options
argument_list|,
name|merge_options
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|init_conflict_markers
argument_list|(
operator|&
name|target_marker
argument_list|,
operator|&
name|left_marker
argument_list|,
operator|&
name|right_marker
argument_list|,
name|target_label
argument_list|,
name|left_label
argument_list|,
name|right_label
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff3_2
argument_list|(
operator|&
name|diff
argument_list|,
name|left
argument_list|,
name|detranslated_target
argument_list|,
name|right
argument_list|,
name|diff3_options
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ostream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|result_f
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_output_merge2
argument_list|(
name|ostream
argument_list|,
name|diff
argument_list|,
name|left
argument_list|,
name|detranslated_target
argument_list|,
name|right
argument_list|,
name|left_marker
argument_list|,
name|target_marker
argument_list|,
name|right_marker
argument_list|,
literal|"======="
argument_list|,
comment|/* separator */
name|svn_diff_conflict_display_modified_latest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|ostream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contains_conflicts
operator|=
name|svn_diff_contains_conflicts
argument_list|(
name|diff
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Same as do_text_merge() above, but use the external diff3  * command DIFF3_CMD to perform the merge.  Pass MERGE_OPTIONS  * to the diff3 command.  Do all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_text_merge_external
parameter_list|(
name|svn_boolean_t
modifier|*
name|contains_conflicts
parameter_list|,
name|apr_file_t
modifier|*
name|result_f
parameter_list|,
specifier|const
name|char
modifier|*
name|diff3_cmd
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
specifier|const
name|char
modifier|*
name|detranslated_target
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target_label
parameter_list|,
specifier|const
name|char
modifier|*
name|left_label
parameter_list|,
specifier|const
name|char
modifier|*
name|right_label
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|exit_code
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_run_diff3_3
argument_list|(
operator|&
name|exit_code
argument_list|,
literal|"."
argument_list|,
name|detranslated_target
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
name|target_label
argument_list|,
name|left_label
argument_list|,
name|right_label
argument_list|,
name|result_f
argument_list|,
name|diff3_cmd
argument_list|,
name|merge_options
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contains_conflicts
operator|=
name|exit_code
operator|==
literal|1
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Preserve the three pre-merge files.     Create three empty files, with unique names that each include the    basename of TARGET_ABSPATH and one of LEFT_LABEL, RIGHT_LABEL and    TARGET_LABEL, in the directory that contains TARGET_ABSPATH.  Typical    names are "foo.c.r37" or "foo.c.2.mine".  Set *LEFT_COPY, *RIGHT_COPY and    *TARGET_COPY to their absolute paths.     Set *WORK_ITEMS to a list of new work items that will write copies of    LEFT_ABSPATH, RIGHT_ABSPATH and TARGET_ABSPATH into the three files,    translated to working-copy form.     The translation to working-copy form will be done according to the    versioned properties of TARGET_ABSPATH that are current when the work    queue items are executed.     If target_abspath is not versioned use detranslated_target_abspath    as the target file.        ### NOT IMPLEMENTED -- 'detranslated_target_abspath' is not used. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|preserve_pre_merge_files
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|left_copy
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|right_copy
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|target_copy
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|mt
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|left_label
parameter_list|,
specifier|const
name|char
modifier|*
name|right_label
parameter_list|,
specifier|const
name|char
modifier|*
name|target_label
parameter_list|,
specifier|const
name|char
modifier|*
name|detranslated_target_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp_left
decl_stmt|,
modifier|*
name|tmp_right
decl_stmt|,
modifier|*
name|detranslated_target_copy
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|,
modifier|*
name|target_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|,
modifier|*
name|temp_dir_abspath
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|,
modifier|*
name|last_items
init|=
name|NULL
decl_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|dir_abspath
argument_list|,
operator|&
name|target_name
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|temp_dir_abspath
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|wri_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create three empty files in DIR_ABSPATH, naming them with unique names      that each include TARGET_NAME and one of {LEFT,RIGHT,TARGET}_LABEL,      and set *{LEFT,RIGHT,TARGET}_COPY to those names. */
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
name|left_copy
argument_list|,
name|dir_abspath
argument_list|,
name|target_name
argument_list|,
name|left_label
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
name|right_copy
argument_list|,
name|dir_abspath
argument_list|,
name|target_name
argument_list|,
name|right_label
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
name|target_copy
argument_list|,
name|dir_abspath
argument_list|,
name|target_name
argument_list|,
name|target_label
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We preserve all the files with keywords expanded and line      endings in local (working) form. */
comment|/* The workingqueue requires its paths to be in the subtree      relative to the wcroot path they are executed in.       Make our LEFT and RIGHT files 'local' if they aren't... */
if|if
condition|(
operator|!
name|svn_dirent_is_ancestor
argument_list|(
name|wcroot_abspath
argument_list|,
name|left_abspath
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|tmp_left
argument_list|,
name|temp_dir_abspath
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|left_abspath
argument_list|,
name|tmp_left
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And create a wq item to remove the file later */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|wcroot_abspath
argument_list|,
name|tmp_left
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|last_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|last_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp_left
operator|=
name|left_abspath
expr_stmt|;
if|if
condition|(
operator|!
name|svn_dirent_is_ancestor
argument_list|(
name|wcroot_abspath
argument_list|,
name|right_abspath
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|tmp_right
argument_list|,
name|temp_dir_abspath
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|right_abspath
argument_list|,
name|tmp_right
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And create a wq item to remove the file later */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|wcroot_abspath
argument_list|,
name|tmp_right
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|last_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|last_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp_right
operator|=
name|right_abspath
expr_stmt|;
comment|/* NOTE: Callers must ensure that the svn:eol-style and      svn:keywords property values are correct in the currently      installed props.  With 'svn merge', it's no big deal.  But      when 'svn up' calls this routine, it needs to make sure that      this routine is using the newest property values that may      have been received *during* the update.  Since this routine      will be run from within a log-command, merge_file()      needs to make sure that a previous log-command to 'install      latest props' has already executed first.  Ben and I just      checked, and that is indeed the order in which the log items      are written, so everything should be fine.  Really.  */
comment|/* Create LEFT and RIGHT backup files, in expanded form.      We use TARGET_ABSPATH's current properties to do the translation. */
comment|/* Derive the basenames of the 3 backup files. */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_copy_translated
argument_list|(
operator|&
name|work_item
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|tmp_left
argument_list|,
operator|*
name|left_copy
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_copy_translated
argument_list|(
operator|&
name|work_item
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|tmp_right
argument_list|,
operator|*
name|right_copy
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Back up TARGET_ABSPATH through detranslation/retranslation:      the new translation properties may not match the current ones */
name|SVN_ERR
argument_list|(
name|detranslate_wc_file
argument_list|(
operator|&
name|detranslated_target_copy
argument_list|,
name|mt
argument_list|,
name|TRUE
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_copy_translated
argument_list|(
operator|&
name|work_item
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|detranslated_target_copy
argument_list|,
operator|*
name|target_copy
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* And maybe delete some tempfiles */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|wcroot_abspath
argument_list|,
name|detranslated_target_copy
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|last_items
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Attempt a trivial merge of LEFT_ABSPATH and RIGHT_ABSPATH to  * the target file at TARGET_ABSPATH.  *  * These are the inherently trivial cases:  *  *   left == right == target         =>  no-op  *   left != right, left == target   =>  target := right  *  * This case is also treated as trivial:  *  *   left != right, right == target  =>  no-op  *  *   ### Strictly, this case is a conflict, and the no-op outcome is only  *       one of the possible resolutions.  *  *       TODO: Raise a conflict at this level and implement the 'no-op'  *       resolution of that conflict at a higher level, in preparation for  *       being able to support stricter conflict detection.  *  * This case is inherently trivial but not currently handled here:  *  *   left == right != target         =>  no-op  *  * The files at LEFT_ABSPATH and RIGHT_ABSPATH are in repository normal  * form.  The file at DETRANSLATED_TARGET_ABSPATH is a copy of the target,  * 'detranslated' to repository normal form, or may be the target file  * itself if no translation is necessary.  *  * When this function updates the target file, it translates to working copy  * form.  *  * On success, set *MERGE_OUTCOME to SVN_WC_MERGE_MERGED in case the  * target was changed, or to SVN_WC_MERGE_UNCHANGED if the target was not  * changed. Install work queue items allocated in RESULT_POOL in *WORK_ITEMS.  * On failure, set *MERGE_OUTCOME to SVN_WC_MERGE_NO_MERGE.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_file_trivial
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|enum
name|svn_wc_merge_outcome_t
modifier|*
name|merge_outcome
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|detranslated_target_abspath
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|svn_boolean_t
name|same_left_right
decl_stmt|;
name|svn_boolean_t
name|same_right_target
decl_stmt|;
name|svn_boolean_t
name|same_left_target
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|is_special
decl_stmt|;
comment|/* If the target is not a normal file, do not attempt a trivial merge. */
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|target_abspath
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|is_special
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
operator|||
name|is_special
condition|)
block|{
operator|*
name|merge_outcome
operator|=
name|svn_wc_merge_no_merge
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Check the files */
name|SVN_ERR
argument_list|(
name|svn_io_files_contents_three_same_p
argument_list|(
operator|&
name|same_left_right
argument_list|,
operator|&
name|same_right_target
argument_list|,
operator|&
name|same_left_target
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
name|detranslated_target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the LEFT side of the merge is equal to WORKING, then we can    * copy RIGHT directly. */
if|if
condition|(
name|same_left_target
condition|)
block|{
comment|/* If the left side equals the right side, there is no change to merge        * so we leave the target unchanged. */
if|if
condition|(
name|same_left_right
condition|)
block|{
operator|*
name|merge_outcome
operator|=
name|svn_wc_merge_unchanged
expr_stmt|;
block|}
else|else
block|{
operator|*
name|merge_outcome
operator|=
name|svn_wc_merge_merged
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|svn_boolean_t
name|delete_src
init|=
name|FALSE
decl_stmt|;
comment|/* The right_abspath might be outside our working copy. In that                  case we should copy the file to a safe location before                  installing to avoid breaking the workqueue.                   This matches the behavior in preserve_pre_merge_files */
name|SVN_ERR
argument_list|(
name|svn_wc__db_get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|db
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_dirent_is_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|right_abspath
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|svn_stream_t
modifier|*
name|tmp_src
decl_stmt|;
name|svn_stream_t
modifier|*
name|tmp_dst
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|tmp_src
argument_list|,
name|right_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__open_writable_base
argument_list|(
operator|&
name|tmp_dst
argument_list|,
operator|&
name|right_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|tmp_src
argument_list|,
name|tmp_dst
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|delete_src
operator|=
name|TRUE
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|target_abspath
argument_list|,
name|right_abspath
argument_list|,
name|FALSE
comment|/* use_commit_times */
argument_list|,
name|FALSE
comment|/* record_fileinfo */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_src
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|wcroot_abspath
argument_list|,
name|right_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* If the locally existing, changed file equals the incoming 'right'        * file, there is no conflict.  For binary files, we historically        * conflicted them needlessly, while merge_text_file figured it out        * eventually and returned svn_wc_merge_unchanged for them, which        * is what we do here. */
if|if
condition|(
name|same_right_target
condition|)
block|{
operator|*
name|merge_outcome
operator|=
name|svn_wc_merge_unchanged
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
operator|*
name|merge_outcome
operator|=
name|svn_wc_merge_no_merge
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handle a non-trivial merge of 'text' files.  (Assume that a trivial  * merge was not possible.)  *  * Set *WORK_ITEMS, *CONFLICT_SKEL and *MERGE_OUTCOME according to the  * result -- to install the merged file, or to indicate a conflict.  *  * On successful merge, leave the result in a temporary file and set  * *WORK_ITEMS to hold work items that will translate and install that  * file into its proper form and place (unless DRY_RUN) and delete the  * temporary file (in any case).  Set *MERGE_OUTCOME to 'merged' or  * 'unchanged'.  *  * If a conflict occurs, set *MERGE_OUTCOME to 'conflicted', and (unless  * DRY_RUN) set *WORK_ITEMS and *CONFLICT_SKEL to record the conflict  * and copies of the pre-merge files.  See preserve_pre_merge_files()  * for details.  *  * On entry, all of the output pointers must be non-null and *CONFLICT_SKEL  * must either point to an existing conflict skel or be NULL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_text_file
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_skel_t
modifier|*
modifier|*
name|conflict_skel
parameter_list|,
name|enum
name|svn_wc_merge_outcome_t
modifier|*
name|merge_outcome
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|mt
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|left_label
parameter_list|,
specifier|const
name|char
modifier|*
name|right_label
parameter_list|,
specifier|const
name|char
modifier|*
name|target_label
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
specifier|const
name|char
modifier|*
name|detranslated_target_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|scratch_pool
decl_stmt|;
comment|/* ### temporary rename  */
name|svn_boolean_t
name|contains_conflicts
decl_stmt|;
name|apr_file_t
modifier|*
name|result_f
decl_stmt|;
specifier|const
name|char
modifier|*
name|result_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_dir
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
name|base_name
operator|=
name|svn_dirent_basename
argument_list|(
name|mt
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Open a second temporary file for writing; this is where diff3      will write the merged results.  We want to use a tempfile      with a name that reflects the original, in case this      ultimately winds up in a conflict resolution editor.  */
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|temp_dir
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|wri_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
operator|&
name|result_f
argument_list|,
operator|&
name|result_target
argument_list|,
name|temp_dir
argument_list|,
name|base_name
argument_list|,
literal|".tmp"
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run the external or internal merge, as requested. */
if|if
condition|(
name|mt
operator|->
name|diff3_cmd
condition|)
name|SVN_ERR
argument_list|(
name|do_text_merge_external
argument_list|(
operator|&
name|contains_conflicts
argument_list|,
name|result_f
argument_list|,
name|mt
operator|->
name|diff3_cmd
argument_list|,
name|mt
operator|->
name|merge_options
argument_list|,
name|detranslated_target_abspath
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
name|target_label
argument_list|,
name|left_label
argument_list|,
name|right_label
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Use internal merge. */
name|SVN_ERR
argument_list|(
name|do_text_merge
argument_list|(
operator|&
name|contains_conflicts
argument_list|,
name|result_f
argument_list|,
name|mt
operator|->
name|merge_options
argument_list|,
name|detranslated_target_abspath
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
name|target_label
argument_list|,
name|left_label
argument_list|,
name|right_label
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|result_f
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the MERGE_OUTCOME, and record any conflict. */
if|if
condition|(
name|contains_conflicts
operator|&&
operator|!
name|dry_run
condition|)
block|{
operator|*
name|merge_outcome
operator|=
name|svn_wc_merge_conflict
expr_stmt|;
if|if
condition|(
operator|*
name|merge_outcome
operator|==
name|svn_wc_merge_conflict
condition|)
block|{
specifier|const
name|char
modifier|*
name|left_copy
decl_stmt|,
modifier|*
name|right_copy
decl_stmt|,
modifier|*
name|target_copy
decl_stmt|;
comment|/* Preserve the three conflict files */
name|SVN_ERR
argument_list|(
name|preserve_pre_merge_files
argument_list|(
operator|&
name|work_item
argument_list|,
operator|&
name|left_copy
argument_list|,
operator|&
name|right_copy
argument_list|,
operator|&
name|target_copy
argument_list|,
name|mt
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
name|left_label
argument_list|,
name|right_label
argument_list|,
name|target_label
argument_list|,
name|detranslated_target_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Track the conflict marker files in the metadata. */
if|if
condition|(
operator|!
operator|*
name|conflict_skel
condition|)
operator|*
name|conflict_skel
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_text_conflict
argument_list|(
operator|*
name|conflict_skel
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|target_copy
argument_list|,
name|left_copy
argument_list|,
name|right_copy
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|merge_outcome
operator|==
name|svn_wc_merge_merged
condition|)
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|contains_conflicts
operator|&&
name|dry_run
condition|)
operator|*
name|merge_outcome
operator|=
name|svn_wc_merge_conflict
expr_stmt|;
else|else
block|{
name|svn_boolean_t
name|same
decl_stmt|,
name|special
decl_stmt|;
comment|/* If 'special', then use the detranslated form of the          target file.  This is so we don't try to follow symlinks,          but the same treatment is probably also appropriate for          whatever special file types we may invent in the future. */
name|SVN_ERR
argument_list|(
name|svn_wc__get_translate_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|special
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|mt
operator|->
name|old_actual_props
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_files_contents_same_p
argument_list|(
operator|&
name|same
argument_list|,
name|result_target
argument_list|,
operator|(
name|special
condition|?
name|detranslated_target_abspath
else|:
name|mt
operator|->
name|local_abspath
operator|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|merge_outcome
operator|=
name|same
condition|?
name|svn_wc_merge_unchanged
else|:
name|svn_wc_merge_merged
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|merge_outcome
operator|!=
name|svn_wc_merge_unchanged
operator|&&
operator|!
name|dry_run
condition|)
block|{
comment|/* replace TARGET_ABSPATH with the new merged file, expanding. */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|result_target
argument_list|,
name|FALSE
comment|/* use_commit_times */
argument_list|,
name|FALSE
comment|/* record_fileinfo */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* Remove the tempfile after use */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|result_target
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handle a non-trivial merge of 'binary' files: don't actually merge, just  * flag a conflict.  (Assume that a trivial merge was not possible.)  *  * Copy* the files at LEFT_ABSPATH and RIGHT_ABSPATH into the same directory  * as the target file, giving them unique names that start with the target  * file's name and end with LEFT_LABEL and RIGHT_LABEL respectively.  * If the merge target has been 'detranslated' to repository normal form,  * move the detranslated file similarly to a unique name ending with  * TARGET_LABEL.  *  * ### * Why do we copy the left and right temp files when we could (maybe  *     not always?) move them?  *  * On entry, all of the output pointers must be non-null and *CONFLICT_SKEL  * must either point to an existing conflict skel or be NULL.  *  * Set *WORK_ITEMS, *CONFLICT_SKEL and *MERGE_OUTCOME to indicate the  * conflict.  *  * ### Why do we not use preserve_pre_merge_files() in here?  The  *     behaviour would be slightly different, more consistent: the  *     preserved 'left' and 'right' files would be translated to working  *     copy form, which may make a difference when a binary file  *     contains keyword expansions or when some versions of the file are  *     not 'binary' even though we're merging in 'binary files' mode.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_binary_file
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_skel_t
modifier|*
modifier|*
name|conflict_skel
parameter_list|,
name|enum
name|svn_wc_merge_outcome_t
modifier|*
name|merge_outcome
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|mt
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|left_label
parameter_list|,
specifier|const
name|char
modifier|*
name|right_label
parameter_list|,
specifier|const
name|char
modifier|*
name|target_label
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
specifier|const
name|char
modifier|*
name|detranslated_target_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|scratch_pool
decl_stmt|;
comment|/* ### temporary rename  */
comment|/* ### when making the binary-file backups, should we be honoring      keywords and eol stuff?   */
specifier|const
name|char
modifier|*
name|left_copy
decl_stmt|,
modifier|*
name|right_copy
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_dirpath
decl_stmt|,
modifier|*
name|merge_filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_wrk
decl_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|merge_dirpath
argument_list|,
operator|&
name|merge_filename
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
block|{
operator|*
name|merge_outcome
operator|=
name|svn_wc_merge_conflict
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* reserve names for backups of left and right fulltexts */
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
operator|&
name|left_copy
argument_list|,
name|merge_dirpath
argument_list|,
name|merge_filename
argument_list|,
name|left_label
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
operator|&
name|right_copy
argument_list|,
name|merge_dirpath
argument_list|,
name|merge_filename
argument_list|,
name|right_label
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create the backup files */
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|left_abspath
argument_list|,
name|left_copy
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|right_abspath
argument_list|,
name|right_copy
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Was the merge target detranslated? */
if|if
condition|(
name|strcmp
argument_list|(
name|mt
operator|->
name|local_abspath
argument_list|,
name|detranslated_target_abspath
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Create a .mine file too */
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
operator|&
name|conflict_wrk
argument_list|,
name|merge_dirpath
argument_list|,
name|merge_filename
argument_list|,
name|target_label
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_move
argument_list|(
name|work_items
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|detranslated_target_abspath
argument_list|,
name|conflict_wrk
argument_list|,
name|pool
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conflict_wrk
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Mark target_abspath's entry as "Conflicted", and start tracking      the backup files in the entry as well. */
if|if
condition|(
operator|!
operator|*
name|conflict_skel
condition|)
operator|*
name|conflict_skel
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_text_conflict
argument_list|(
operator|*
name|conflict_skel
argument_list|,
name|mt
operator|->
name|db
argument_list|,
name|mt
operator|->
name|local_abspath
argument_list|,
name|conflict_wrk
argument_list|,
name|left_copy
argument_list|,
name|right_copy
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|merge_outcome
operator|=
name|svn_wc_merge_conflict
expr_stmt|;
comment|/* a conflict happened */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__internal_merge
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_skel_t
modifier|*
modifier|*
name|conflict_skel
parameter_list|,
name|enum
name|svn_wc_merge_outcome_t
modifier|*
name|merge_outcome
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|left_label
parameter_list|,
specifier|const
name|char
modifier|*
name|right_label
parameter_list|,
specifier|const
name|char
modifier|*
name|target_label
parameter_list|,
name|apr_hash_t
modifier|*
name|old_actual_props
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
specifier|const
name|char
modifier|*
name|diff3_cmd
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|prop_diff
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|detranslated_target_abspath
decl_stmt|;
name|svn_boolean_t
name|is_binary
init|=
name|FALSE
decl_stmt|;
specifier|const
name|svn_prop_t
modifier|*
name|mimeprop
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|merge_target_t
name|mt
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|left_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|right_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|target_abspath
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
comment|/* Fill the merge target baton */
name|mt
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|mt
operator|.
name|local_abspath
operator|=
name|target_abspath
expr_stmt|;
name|mt
operator|.
name|wri_abspath
operator|=
name|wri_abspath
expr_stmt|;
name|mt
operator|.
name|old_actual_props
operator|=
name|old_actual_props
expr_stmt|;
name|mt
operator|.
name|prop_diff
operator|=
name|prop_diff
expr_stmt|;
name|mt
operator|.
name|diff3_cmd
operator|=
name|diff3_cmd
expr_stmt|;
name|mt
operator|.
name|merge_options
operator|=
name|merge_options
expr_stmt|;
comment|/* Decide if the merge target is a text or binary file. */
if|if
condition|(
operator|(
name|mimeprop
operator|=
name|get_prop
argument_list|(
name|prop_diff
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
operator|)
operator|&&
name|mimeprop
operator|->
name|value
condition|)
name|is_binary
operator|=
name|svn_mime_type_is_binary
argument_list|(
name|mimeprop
operator|->
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|svn_prop_get_value
argument_list|(
name|mt
operator|.
name|old_actual_props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
decl_stmt|;
name|is_binary
operator|=
name|value
operator|&&
name|svn_mime_type_is_binary
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|detranslate_wc_file
argument_list|(
operator|&
name|detranslated_target_abspath
argument_list|,
operator|&
name|mt
argument_list|,
operator|(
operator|!
name|is_binary
operator|)
operator|&&
name|diff3_cmd
operator|!=
name|NULL
argument_list|,
name|target_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We cannot depend on the left file to contain the same eols as the      right file. If the merge target has mods, this will mark the entire      file as conflicted, so we need to compensate. */
name|SVN_ERR
argument_list|(
name|maybe_update_target_eols
argument_list|(
operator|&
name|left_abspath
argument_list|,
name|prop_diff
argument_list|,
name|left_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|merge_file_trivial
argument_list|(
name|work_items
argument_list|,
name|merge_outcome
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
name|target_abspath
argument_list|,
name|detranslated_target_abspath
argument_list|,
name|dry_run
argument_list|,
name|db
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|merge_outcome
operator|==
name|svn_wc_merge_no_merge
condition|)
block|{
comment|/* We have a non-trivial merge.  If we classify it as a merge of        * 'binary' files we'll just raise a conflict, otherwise we'll do        * the actual merge of 'text' file contents. */
if|if
condition|(
name|is_binary
condition|)
block|{
comment|/* Raise a text conflict */
name|SVN_ERR
argument_list|(
name|merge_binary_file
argument_list|(
name|work_items
argument_list|,
name|conflict_skel
argument_list|,
name|merge_outcome
argument_list|,
operator|&
name|mt
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
name|left_label
argument_list|,
name|right_label
argument_list|,
name|target_label
argument_list|,
name|dry_run
argument_list|,
name|detranslated_target_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|merge_text_file
argument_list|(
name|work_items
argument_list|,
name|conflict_skel
argument_list|,
name|merge_outcome
argument_list|,
operator|&
name|mt
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
name|left_label
argument_list|,
name|right_label
argument_list|,
name|target_label
argument_list|,
name|dry_run
argument_list|,
name|detranslated_target_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Merging is complete.  Regardless of text or binariness, we might      need to tweak the executable bit on the new working file, and      possibly make it read-only. */
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_sync_file_flags
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|target_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_merge5
parameter_list|(
name|enum
name|svn_wc_merge_outcome_t
modifier|*
name|merge_content_outcome
parameter_list|,
name|enum
name|svn_wc_notify_state_t
modifier|*
name|merge_props_outcome
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|left_label
parameter_list|,
specifier|const
name|char
modifier|*
name|right_label
parameter_list|,
specifier|const
name|char
modifier|*
name|target_label
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
specifier|const
name|char
modifier|*
name|diff3_cmd
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|apr_hash_t
modifier|*
name|original_props
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|prop_diff
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dir_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_items
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_skel
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|pristine_props
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_actual_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_actual_props
init|=
name|NULL
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|left_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|right_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|target_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Before we do any work, make sure we hold a write lock.  */
if|if
condition|(
operator|!
name|dry_run
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__write_check
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sanity check:  the merge target must be a file under revision control */
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|had_props
decl_stmt|;
name|svn_boolean_t
name|props_mod
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
operator|&
name|had_props
argument_list|,
operator|&
name|props_mod
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
operator|||
operator|(
name|status
operator|!=
name|svn_wc__db_status_normal
operator|&&
name|status
operator|!=
name|svn_wc__db_status_added
operator|)
condition|)
block|{
operator|*
name|merge_content_outcome
operator|=
name|svn_wc_merge_no_merge
expr_stmt|;
if|if
condition|(
name|merge_props_outcome
condition|)
operator|*
name|merge_props_outcome
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|conflicted
condition|)
block|{
name|svn_boolean_t
name|text_conflicted
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__internal_conflicted_p
argument_list|(
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't install two prop conflicts on a single node, so            avoid even checking that we have to merge it */
if|if
condition|(
name|text_conflicted
operator|||
name|prop_conflicted
operator|||
name|tree_conflicted
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't merge into conflicted node '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* else: Conflict was resolved by removing markers */
block|}
if|if
condition|(
name|merge_props_outcome
operator|&&
name|had_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|pristine_props
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|merge_props_outcome
condition|)
name|pristine_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|props_mod
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|old_actual_props
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pristine_props
condition|)
name|old_actual_props
operator|=
name|pristine_props
expr_stmt|;
else|else
name|old_actual_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the properties, if requested.  We merge the properties first    * because the properties can affect the text (EOL style, keywords). */
if|if
condition|(
name|merge_props_outcome
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* The PROPCHANGES may not have non-"normal" properties in it. If entry          or wc props were allowed, then the following code would install them          into the BASE and/or WORKING properties(!).  */
for|for
control|(
name|i
operator|=
name|prop_diff
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|change
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|prop_diff
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|svn_wc_is_normal_prop
argument_list|(
name|change
operator|->
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROP_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The property '%s' may not be merged "
literal|"into '%s'."
argument_list|)
argument_list|,
name|change
operator|->
name|name
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__merge_props
argument_list|(
operator|&
name|conflict_skel
argument_list|,
name|merge_props_outcome
argument_list|,
operator|&
name|new_actual_props
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|original_props
argument_list|,
name|pristine_props
argument_list|,
name|old_actual_props
argument_list|,
name|prop_diff
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the text. */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_merge
argument_list|(
operator|&
name|work_items
argument_list|,
operator|&
name|conflict_skel
argument_list|,
name|merge_content_outcome
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
name|target_abspath
argument_list|,
name|target_abspath
argument_list|,
name|left_label
argument_list|,
name|right_label
argument_list|,
name|target_label
argument_list|,
name|old_actual_props
argument_list|,
name|dry_run
argument_list|,
name|diff3_cmd
argument_list|,
name|merge_options
argument_list|,
name|prop_diff
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this isn't a dry run, then update the DB, run the work, and    * call the conflict resolver callback.  */
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
if|if
condition|(
name|conflict_skel
condition|)
block|{
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_merge
argument_list|(
name|conflict_skel
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_create_markers
argument_list|(
operator|&
name|work_item
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_actual_props
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_set_props
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|new_actual_props
argument_list|,
name|svn_wc__has_magic_property
argument_list|(
name|prop_diff
argument_list|)
argument_list|,
name|conflict_skel
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|conflict_skel
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_conflict
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|work_items
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_add
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_items
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_skel
operator|&&
name|conflict_func
condition|)
block|{
name|svn_boolean_t
name|text_conflicted
decl_stmt|,
name|prop_conflicted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_invoke_resolver
argument_list|(
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|merge_options
argument_list|,
name|conflict_func
argument_list|,
name|conflict_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset *MERGE_CONTENT_OUTCOME etc. if a conflict was resolved. */
name|SVN_ERR
argument_list|(
name|svn_wc__internal_conflicted_p
argument_list|(
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|merge_props_outcome
operator|==
name|svn_wc_notify_state_conflicted
operator|&&
operator|!
name|prop_conflicted
condition|)
operator|*
name|merge_props_outcome
operator|=
name|svn_wc_notify_state_merged
expr_stmt|;
if|if
condition|(
operator|*
name|merge_content_outcome
operator|==
name|svn_wc_merge_conflict
operator|&&
operator|!
name|text_conflicted
condition|)
operator|*
name|merge_content_outcome
operator|=
name|svn_wc_merge_merged
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

