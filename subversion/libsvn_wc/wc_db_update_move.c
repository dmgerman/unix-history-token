begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * wc_db_update_move.c :  updating moves during tree-conflict resolution  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* This file implements an editor and an edit driver which are used  * to resolve an "incoming edit, local move-away" tree conflict resulting  * from an update (or switch).  *  * Our goal is to be able to resolve this conflict such that the end  * result is just the same as if the user had run the update *before*  * the local move.  *  * When an update (or switch) produces incoming changes for a locally  * moved-away subtree, it updates the base nodes of the moved-away tree  * and flags a tree-conflict on the moved-away root node.  * This editor transfers these changes from the moved-away part of the  * working copy to the corresponding moved-here part of the working copy.  *  * Both the driver and receiver components of the editor are implemented  * in this file.  *  * The driver sees two NODES trees: the move source tree and the move  * destination tree.  When the move is initially made these trees are  * equivalent, the destination is a copy of the source.  The source is  * a single-op-depth, single-revision, deleted layer [1] and the  * destination has an equivalent single-op-depth, single-revision  * layer. The destination may have additional higher op-depths  * representing adds, deletes, moves within the move destination. [2]  *  * After the initial move an update has modified the NODES in the move  * source and may have introduced a tree-conflict since the source and  * destination trees are no longer equivalent.  The source is a  * different revision and may have text, property and tree changes  * compared to the destination.  The driver will compare the two NODES  * trees and drive an editor to change the destination tree so that it  * once again matches the source tree.  Changes made to the  * destination NODES tree to achieve this match will be merged into  * the working files/directories.  *  * The whole drive occurs as one single wc.db transaction.  At the end  * of the transaction the destination NODES table should have a layer  * that is equivalent to the source NODES layer, there should be  * workqueue items to make any required changes to working  * files/directories in the move destination, and there should be  * tree-conflicts in the move destination where it was not possible to  * update the working files/directories.  *  * [1] The move source tree is single-revision because we currently do  *     not allow a mixed-rev move, and therefore it is single op-depth  *     regardless whether it is a base layer or a nested move.  *  * [2] The source tree also may have additional higher op-depths,  *     representing a replacement, but this editor only reads from the  *     single-op-depth layer of it, and makes no changes of any kind  *     within the source tree.  */
end_comment

begin_define
define|#
directive|define
name|SVN_WC__I_AM_WC_DB
end_define

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sqlite.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"props.h"
end_include

begin_include
include|#
directive|include
file|"wc_db_private.h"
end_include

begin_include
include|#
directive|include
file|"wc-queries.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"token-map.h"
end_include

begin_comment
comment|/* Helper functions */
end_comment

begin_comment
comment|/* Return the absolute path, in local path style, of LOCAL_RELPATH    in WCROOT.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_for_error_message
parameter_list|(
specifier|const
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|local_relpath
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
return|return
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ensure that there is a working copy lock for LOCAL_RELPATH in WCROOT */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_write_lock
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|locked
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock_internal
argument_list|(
operator|&
name|locked
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_LOCKED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No write-lock in '%s'"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* In our merge conflicts we record the move_op_src path, which is essentially    the depth at which what was moved is marked deleted. The problem is that    this depth is not guaranteed to be stable, because somebody might just    remove another ancestor, or revert one.     To work around this problem we locate the layer below this path, and use    that to pinpoint whatever is moved.     For a path SRC_RELPATH that was deleted by an operation rooted at    DELETE_OP_DEPTH find the op-depth at which the node was originally added.    */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_src_op_depth
parameter_list|(
name|int
modifier|*
name|src_op_depth
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
name|int
name|delete_op_depth
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_HIGHEST_WORKING_NODE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|src_relpath
argument_list|,
name|delete_op_depth
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_row
condition|)
operator|*
name|src_op_depth
operator|=
name|svn_sqlite__column_int
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_row
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not deleted"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Receiver code.  *  * The receiver is an editor that, when driven with a certain change, will  * merge the edits into the working/actual state of the move destination  * at MOVE_ROOT_DST_RELPATH (in struct tc_editor_baton), perhaps raising  * conflicts if necessary.  *  * The receiver should not need to refer directly to the move source, as  * the driver should provide all relevant information about the change to  * be made at the move destination.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|update_move_baton_t
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
decl_stmt|;
name|int
name|src_op_depth
decl_stmt|;
name|int
name|dst_op_depth
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|old_version
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|new_version
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
name|update_move_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Per node flags for tree conflict collection */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|node_move_baton_t
block|{
name|svn_boolean_t
name|skip
decl_stmt|;
name|svn_boolean_t
name|shadowed
decl_stmt|;
name|svn_boolean_t
name|edited
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_relpath
decl_stmt|;
name|update_move_baton_t
modifier|*
name|umb
decl_stmt|;
name|struct
name|node_move_baton_t
modifier|*
name|pb
decl_stmt|;
block|}
name|node_move_baton_t
typedef|;
end_typedef

begin_comment
comment|/*  * Notifications are delayed until the entire update-move transaction  * completes. These functions provide the necessary support by storing  * notification information in a temporary db table (the "update_move_list")  * and spooling notifications out of that table after the transaction.  */
end_comment

begin_comment
comment|/* Add an entry to the notification list, and at the same time install    a conflict and/or work items. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_move_list_add
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_wc_notify_action_t
name|action
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_wc_notify_state_t
name|content_state
parameter_list|,
name|svn_wc_notify_state_t
name|prop_state
parameter_list|,
name|svn_skel_t
modifier|*
name|conflict
parameter_list|,
name|svn_skel_t
modifier|*
name|work_item
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
if|if
condition|(
name|conflict
condition|)
block|{
name|svn_boolean_t
name|tree_conflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tree_conflict
argument_list|,
name|db
argument_list|,
name|wcroot
operator|->
name|abspath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_conflict
condition|)
block|{
name|action
operator|=
name|svn_wc_notify_tree_conflict
expr_stmt|;
name|content_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_INSERT_UPDATE_MOVE_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"sdtdd"
argument_list|,
name|local_relpath
argument_list|,
name|action
argument_list|,
name|kind_map_none
argument_list|,
name|kind
argument_list|,
name|content_state
argument_list|,
name|prop_state
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_mark_conflict_internal
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_item
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_add_internal
argument_list|(
name|wcroot
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Send all notifications stored in the notification list, and then  * remove the temporary database table. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_update_move_list_notify
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
name|svn_revnum_t
name|old_revision
parameter_list|,
name|svn_revnum_t
name|new_revision
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
if|if
condition|(
name|notify_func
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_UPDATE_MOVE_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
name|svn_wc_notify_action_t
name|action
decl_stmt|;
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|local_relpath
operator|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|action
operator|=
name|svn_sqlite__column_int
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|svn_dirent_join
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|local_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|action
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_sqlite__column_token
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|,
name|kind_map_none
argument_list|)
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|svn_sqlite__column_int
argument_list|(
name|stmt
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|notify
operator|->
name|prop_state
operator|=
name|svn_sqlite__column_int
argument_list|(
name|stmt
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|notify
operator|->
name|old_revision
operator|=
name|old_revision
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
name|new_revision
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_FINALIZE_UPDATE_MOVE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step_done
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a tree-conflict for recording on LOCAL_RELPATH if such    a tree-conflict does not already exist. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_tree_conflict
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|conflict_p
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_op_root_relpath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|old_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|new_version
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
name|svn_node_kind_t
name|old_kind
parameter_list|,
name|svn_node_kind_t
name|new_kind
parameter_list|,
specifier|const
name|char
modifier|*
name|old_repos_relpath
parameter_list|,
name|svn_wc_conflict_reason_t
name|reason
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
specifier|const
name|char
modifier|*
name|move_src_op_root_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|conflict_old_version
decl_stmt|,
modifier|*
name|conflict_new_version
decl_stmt|;
specifier|const
name|char
modifier|*
name|move_src_op_root_abspath
init|=
name|move_src_op_root_relpath
condition|?
name|svn_dirent_join
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|move_src_op_root_relpath
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_repos_relpath_part
init|=
name|old_repos_relpath
condition|?
name|svn_relpath_skip_ancestor
argument_list|(
name|old_version
operator|->
name|path_in_repos
argument_list|,
name|old_repos_relpath
argument_list|)
else|:
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_repos_relpath
init|=
name|old_repos_relpath_part
condition|?
name|svn_relpath_join
argument_list|(
name|new_version
operator|->
name|path_in_repos
argument_list|,
name|old_repos_relpath_part
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|new_repos_relpath
condition|)
block|{
specifier|const
name|char
modifier|*
name|child_relpath
init|=
name|svn_relpath_skip_ancestor
argument_list|(
name|dst_op_root_relpath
argument_list|,
name|local_relpath
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child_relpath
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|new_repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|new_version
operator|->
name|path_in_repos
argument_list|,
name|child_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_wc__db_read_conflict_internal
argument_list|(
operator|&
name|conflict
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
elseif|else
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|conflict
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|conflict
condition|)
block|{
name|svn_wc_operation_t
name|conflict_operation
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|conflict_operation
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|wcroot
operator|->
name|abspath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_operation
operator|!=
name|svn_wc_operation_update
operator|&&
name|conflict_operation
operator|!=
name|svn_wc_operation_switch
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' already in conflict"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|tree_conflicted
condition|)
block|{
name|svn_wc_conflict_reason_t
name|existing_reason
decl_stmt|;
name|svn_wc_conflict_action_t
name|existing_action
decl_stmt|;
specifier|const
name|char
modifier|*
name|existing_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|existing_reason
argument_list|,
operator|&
name|existing_action
argument_list|,
operator|&
name|existing_abspath
argument_list|,
name|db
argument_list|,
name|wcroot
operator|->
name|abspath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|!=
name|existing_reason
operator|||
name|action
operator|!=
name|existing_action
operator|||
operator|(
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|&&
name|strcmp
argument_list|(
name|move_src_op_root_relpath
argument_list|,
name|svn_dirent_skip_ancestor
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|existing_abspath
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' already in conflict"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* Already a suitable tree-conflict. */
operator|*
name|conflict_p
operator|=
name|conflict
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
name|conflict
operator|=
name|svn_wc__conflict_skel_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_add_tree_conflict
argument_list|(
name|conflict
argument_list|,
name|db
argument_list|,
name|svn_dirent_join
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|reason
argument_list|,
name|action
argument_list|,
name|move_src_op_root_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|conflict_old_version
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|old_version
operator|->
name|repos_url
argument_list|,
name|old_version
operator|->
name|repos_uuid
argument_list|,
name|old_repos_relpath
argument_list|,
name|old_version
operator|->
name|peg_rev
argument_list|,
name|old_kind
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|conflict_new_version
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|new_version
operator|->
name|repos_url
argument_list|,
name|new_version
operator|->
name|repos_uuid
argument_list|,
name|new_repos_relpath
argument_list|,
name|new_version
operator|->
name|peg_rev
argument_list|,
name|new_kind
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_update
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_update
argument_list|(
name|conflict
argument_list|,
name|conflict_old_version
argument_list|,
name|conflict_new_version
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|operation
operator|==
name|svn_wc_operation_switch
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_switch
argument_list|(
name|conflict
argument_list|,
name|conflict_old_version
argument_list|,
name|conflict_new_version
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|conflict_p
operator|=
name|conflict
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_node_tree_conflict
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|conflict_p
parameter_list|,
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_local_relpath
parameter_list|,
name|svn_node_kind_t
name|old_kind
parameter_list|,
name|svn_node_kind_t
name|new_kind
parameter_list|,
name|svn_wc_conflict_reason_t
name|reason
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
specifier|const
name|char
modifier|*
name|move_src_op_root_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_move_baton_t
modifier|*
name|umb
init|=
name|nmb
operator|->
name|umb
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_root_relpath
init|=
name|svn_relpath_prefix
argument_list|(
name|nmb
operator|->
name|dst_relpath
argument_list|,
name|nmb
operator|->
name|umb
operator|->
name|dst_op_depth
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|dst_repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|nmb
operator|->
name|umb
operator|->
name|old_version
operator|->
name|path_in_repos
argument_list|,
name|svn_relpath_skip_ancestor
argument_list|(
name|dst_root_relpath
argument_list|,
name|nmb
operator|->
name|dst_relpath
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|create_tree_conflict
argument_list|(
name|conflict_p
argument_list|,
name|umb
operator|->
name|wcroot
argument_list|,
name|dst_local_relpath
argument_list|,
name|svn_relpath_prefix
argument_list|(
name|dst_local_relpath
argument_list|,
name|umb
operator|->
name|dst_op_depth
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|umb
operator|->
name|db
argument_list|,
name|umb
operator|->
name|old_version
argument_list|,
name|umb
operator|->
name|new_version
argument_list|,
name|umb
operator|->
name|operation
argument_list|,
name|old_kind
argument_list|,
name|new_kind
argument_list|,
name|dst_repos_relpath
argument_list|,
name|reason
argument_list|,
name|action
argument_list|,
name|move_src_op_root_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks if a specific local path is shadowed as seen from the move root.    Helper for update_moved_away_node() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_node_shadowed
parameter_list|(
name|svn_boolean_t
modifier|*
name|shadowed
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|int
name|move_root_dst_op_depth
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_WORKING_NODE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"is"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_row
condition|)
block|{
name|int
name|op_depth
init|=
name|svn_sqlite__column_int
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|shadowed
operator|=
operator|(
name|op_depth
operator|>
name|move_root_dst_op_depth
operator|)
expr_stmt|;
block|}
else|else
operator|*
name|shadowed
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set a tree conflict for the shadowed node LOCAL_RELPATH, which is    the ROOT OF THE OBSTRUCTION if such a tree-conflict does not    already exist.  KIND is the kind of the incoming LOCAL_RELPATH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_tc_on_op_root
parameter_list|(
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
name|svn_node_kind_t
name|old_kind
parameter_list|,
name|svn_node_kind_t
name|new_kind
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_move_baton_t
modifier|*
name|b
init|=
name|nmb
operator|->
name|umb
decl_stmt|;
specifier|const
name|char
modifier|*
name|move_dst_relpath
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|nmb
operator|->
name|shadowed
operator|&&
operator|!
name|nmb
operator|->
name|pb
operator|->
name|shadowed
argument_list|)
expr_stmt|;
name|nmb
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|old_kind
operator|==
name|svn_node_none
condition|)
name|move_dst_relpath
operator|=
name|NULL
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_moved_to_internal
argument_list|(
name|NULL
argument_list|,
operator|&
name|move_dst_relpath
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|wcroot
argument_list|,
name|nmb
operator|->
name|dst_relpath
argument_list|,
name|b
operator|->
name|dst_op_depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_node_tree_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|nmb
argument_list|,
name|nmb
operator|->
name|dst_relpath
argument_list|,
name|old_kind
argument_list|,
name|new_kind
argument_list|,
operator|(
name|move_dst_relpath
condition|?
name|svn_wc_conflict_reason_moved_away
else|:
name|svn_wc_conflict_reason_deleted
operator|)
argument_list|,
name|action
argument_list|,
name|move_dst_relpath
condition|?
name|nmb
operator|->
name|dst_relpath
else|:
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|update_move_list_add
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|nmb
operator|->
name|dst_relpath
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|new_kind
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|conflict
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_node_edited
parameter_list|(
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|nmb
operator|->
name|edited
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|nmb
operator|->
name|pb
condition|)
block|{
name|SVN_ERR
argument_list|(
name|mark_node_edited
argument_list|(
name|nmb
operator|->
name|pb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmb
operator|->
name|pb
operator|->
name|skip
condition|)
name|nmb
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
block|}
name|nmb
operator|->
name|edited
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|nmb
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|nmb
operator|->
name|shadowed
operator|&&
operator|!
operator|(
name|nmb
operator|->
name|pb
operator|&&
name|nmb
operator|->
name|pb
operator|->
name|shadowed
operator|)
condition|)
block|{
name|svn_node_kind_t
name|dst_kind
decl_stmt|,
name|src_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_depth_get_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|dst_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|nmb
operator|->
name|umb
operator|->
name|wcroot
argument_list|,
name|nmb
operator|->
name|dst_relpath
argument_list|,
name|nmb
operator|->
name|umb
operator|->
name|dst_op_depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_depth_get_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|src_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|nmb
operator|->
name|umb
operator|->
name|wcroot
argument_list|,
name|nmb
operator|->
name|src_relpath
argument_list|,
name|nmb
operator|->
name|umb
operator|->
name|src_op_depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_tc_on_op_root
argument_list|(
name|nmb
argument_list|,
name|dst_kind
argument_list|,
name|src_kind
argument_list|,
name|svn_wc_conflict_action_edit
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_parent_edited
parameter_list|(
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|nmb
operator|&&
name|nmb
operator|->
name|pb
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_node_edited
argument_list|(
name|nmb
operator|->
name|pb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmb
operator|->
name|pb
operator|->
name|skip
condition|)
name|nmb
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tc_editor_add_directory
parameter_list|(
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_node_kind_t
name|old_kind
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_move_baton_t
modifier|*
name|b
init|=
name|nmb
operator|->
name|umb
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
init|=
name|NULL
decl_stmt|;
name|svn_wc_conflict_reason_t
name|reason
init|=
name|svn_wc_conflict_reason_unversioned
decl_stmt|;
name|SVN_ERR
argument_list|(
name|mark_parent_edited
argument_list|(
name|nmb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmb
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|nmb
operator|->
name|shadowed
condition|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info_internal
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|wc_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|wcroot
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_deleted
condition|)
name|reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|!=
name|svn_wc__db_status_added
condition|)
name|wc_kind
operator|=
name|svn_node_none
expr_stmt|;
elseif|else
if|if
condition|(
name|old_kind
operator|==
name|svn_node_none
condition|)
name|reason
operator|=
name|svn_wc_conflict_reason_added
expr_stmt|;
else|else
name|reason
operator|=
name|svn_wc_conflict_reason_replaced
expr_stmt|;
block|}
else|else
name|wc_kind
operator|=
name|svn_node_none
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* Check for unversioned tree-conflict */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|wc_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nmb
operator|->
name|shadowed
operator|&&
name|wc_kind
operator|==
name|old_kind
condition|)
name|wc_kind
operator|=
name|svn_node_none
expr_stmt|;
comment|/* Node will be gone once we install */
if|if
condition|(
name|wc_kind
operator|!=
name|svn_node_none
operator|&&
operator|(
name|nmb
operator|->
name|shadowed
operator|||
name|wc_kind
operator|!=
name|old_kind
operator|)
condition|)
comment|/* replace */
block|{
name|SVN_ERR
argument_list|(
name|create_node_tree_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|nmb
argument_list|,
name|relpath
argument_list|,
name|old_kind
argument_list|,
name|svn_node_dir
argument_list|,
name|reason
argument_list|,
operator|(
name|old_kind
operator|==
name|svn_node_none
operator|)
condition|?
name|svn_wc_conflict_action_add
else|:
name|svn_wc_conflict_action_replace
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|nmb
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_dir_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|update_move_list_add
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|relpath
argument_list|,
name|b
operator|->
name|db
argument_list|,
operator|(
name|old_kind
operator|==
name|svn_node_none
operator|)
condition|?
name|svn_wc_notify_update_add
else|:
name|svn_wc_notify_update_replace
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|conflict
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tc_editor_add_file
parameter_list|(
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_node_kind_t
name|old_kind
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_move_baton_t
modifier|*
name|b
init|=
name|nmb
operator|->
name|umb
decl_stmt|;
name|svn_wc_conflict_reason_t
name|reason
init|=
name|svn_wc_conflict_reason_unversioned
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|mark_parent_edited
argument_list|(
name|nmb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmb
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|nmb
operator|->
name|shadowed
condition|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info_internal
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|wc_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|wcroot
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|svn_wc__db_status_deleted
condition|)
name|reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|!=
name|svn_wc__db_status_added
condition|)
name|wc_kind
operator|=
name|svn_node_none
expr_stmt|;
elseif|else
if|if
condition|(
name|old_kind
operator|==
name|svn_node_none
condition|)
name|reason
operator|=
name|svn_wc_conflict_reason_added
expr_stmt|;
else|else
name|reason
operator|=
name|svn_wc_conflict_reason_replaced
expr_stmt|;
block|}
else|else
name|wc_kind
operator|=
name|svn_node_none
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* Check for unversioned tree-conflict */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|wc_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wc_kind
operator|!=
name|svn_node_none
operator|&&
operator|(
name|nmb
operator|->
name|shadowed
operator|||
name|wc_kind
operator|!=
name|old_kind
operator|)
condition|)
comment|/* replace */
block|{
name|SVN_ERR
argument_list|(
name|create_node_tree_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|nmb
argument_list|,
name|relpath
argument_list|,
name|old_kind
argument_list|,
name|svn_node_file
argument_list|,
name|reason
argument_list|,
operator|(
name|old_kind
operator|==
name|svn_node_none
operator|)
condition|?
name|svn_wc_conflict_action_add
else|:
name|svn_wc_conflict_action_replace
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|nmb
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Update working file. */
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|svn_dirent_join
argument_list|(
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|FALSE
comment|/*FIXME: use_commit_times?*/
argument_list|,
name|TRUE
comment|/* record_file_info */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|update_move_list_add
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|relpath
argument_list|,
name|b
operator|->
name|db
argument_list|,
operator|(
name|old_kind
operator|==
name|svn_node_none
operator|)
condition|?
name|svn_wc_notify_update_add
else|:
name|svn_wc_notify_update_replace
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|conflict
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* All the info we need about one version of a working node. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|working_node_version_t
block|{
name|svn_wc_conflict_version_t
modifier|*
name|location_and_kind
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
comment|/* for files only */
block|}
name|working_node_version_t
typedef|;
end_typedef

begin_comment
comment|/* Return *WORK_ITEMS to create a conflict on LOCAL_ABSPATH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_conflict_markers
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
specifier|const
name|working_node_version_t
modifier|*
name|old_version
parameter_list|,
specifier|const
name|working_node_version_t
modifier|*
name|new_version
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_boolean_t
name|set_operation
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_conflict_version_t
modifier|*
name|original_version
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|conflicted_version
decl_stmt|;
specifier|const
name|char
modifier|*
name|part
decl_stmt|;
name|original_version
operator|=
name|svn_wc_conflict_version_dup
argument_list|(
name|old_version
operator|->
name|location_and_kind
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|original_version
operator|->
name|node_kind
operator|=
name|kind
expr_stmt|;
name|conflicted_version
operator|=
name|svn_wc_conflict_version_dup
argument_list|(
name|new_version
operator|->
name|location_and_kind
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|conflicted_version
operator|->
name|node_kind
operator|=
name|kind
expr_stmt|;
name|part
operator|=
name|svn_relpath_skip_ancestor
argument_list|(
name|original_version
operator|->
name|path_in_repos
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
name|conflicted_version
operator|->
name|path_in_repos
operator|=
name|svn_relpath_join
argument_list|(
name|conflicted_version
operator|->
name|path_in_repos
argument_list|,
name|part
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|original_version
operator|->
name|path_in_repos
operator|=
name|repos_relpath
expr_stmt|;
if|if
condition|(
name|set_operation
condition|)
block|{
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_update
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_update
argument_list|(
name|conflict_skel
argument_list|,
name|original_version
argument_list|,
name|conflicted_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_set_op_switch
argument_list|(
name|conflict_skel
argument_list|,
name|original_version
argument_list|,
name|conflicted_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* According to this func's doc string, it is "Currently only used for    * property conflicts as text conflict markers are just in-wc files." */
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_create_markers
argument_list|(
name|work_items
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_working_props
parameter_list|(
name|svn_wc_notify_state_t
modifier|*
name|prop_state
parameter_list|,
name|svn_skel_t
modifier|*
modifier|*
name|conflict_skel
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|propchanges
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|actual_props
parameter_list|,
name|update_move_baton_t
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
specifier|const
name|struct
name|working_node_version_t
modifier|*
name|old_version
parameter_list|,
specifier|const
name|struct
name|working_node_version_t
modifier|*
name|new_version
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|new_actual_props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|new_propchanges
decl_stmt|;
comment|/*    * Run a 3-way prop merge to update the props, using the pre-update    * props as the merge base, the post-update props as the    * merge-left version, and the current props of the    * moved-here working file as the merge-right version.    */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props_internal
argument_list|(
name|actual_props
argument_list|,
name|b
operator|->
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
name|propchanges
argument_list|,
name|new_version
operator|->
name|props
argument_list|,
name|old_version
operator|->
name|props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__merge_props
argument_list|(
name|conflict_skel
argument_list|,
name|prop_state
argument_list|,
operator|&
name|new_actual_props
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|svn_dirent_join
argument_list|(
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|old_version
operator|->
name|props
argument_list|,
name|old_version
operator|->
name|props
argument_list|,
operator|*
name|actual_props
argument_list|,
operator|*
name|propchanges
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setting properties in ACTUAL_NODE with svn_wc__db_op_set_props_internal      relies on NODES row being updated via a different route .       This extra property diff makes sure we clear the actual row when      the final result is unchanged properties. */
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|new_propchanges
argument_list|,
name|new_actual_props
argument_list|,
name|new_version
operator|->
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_propchanges
operator|->
name|nelts
condition|)
name|new_actual_props
operator|=
name|NULL
expr_stmt|;
comment|/* Install the new actual props. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_set_props_internal
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|new_actual_props
argument_list|,
name|svn_wc__has_magic_property
argument_list|(
operator|*
name|propchanges
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tc_editor_alter_directory
parameter_list|(
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
name|apr_hash_t
modifier|*
name|old_props
parameter_list|,
name|apr_hash_t
modifier|*
name|new_props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_move_baton_t
modifier|*
name|b
init|=
name|nmb
operator|->
name|umb
decl_stmt|;
name|working_node_version_t
name|old_version
decl_stmt|,
name|new_version
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_skel
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|dst_relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_wc_notify_state_t
name|prop_state
decl_stmt|;
name|apr_hash_t
modifier|*
name|actual_props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
name|svn_boolean_t
name|obstructed
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|mark_node_edited
argument_list|(
name|nmb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmb
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|wc_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_kind
operator|!=
name|svn_node_none
operator|&&
name|wc_kind
operator|!=
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|create_node_tree_conflict
argument_list|(
operator|&
name|conflict_skel
argument_list|,
name|nmb
argument_list|,
name|dst_relpath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_conflict_reason_obstructed
argument_list|,
name|svn_wc_conflict_action_edit
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|obstructed
operator|=
name|TRUE
expr_stmt|;
block|}
name|old_version
operator|.
name|location_and_kind
operator|=
name|b
operator|->
name|old_version
expr_stmt|;
name|new_version
operator|.
name|location_and_kind
operator|=
name|b
operator|->
name|new_version
expr_stmt|;
name|old_version
operator|.
name|checksum
operator|=
name|NULL
expr_stmt|;
comment|/* not a file */
name|old_version
operator|.
name|props
operator|=
name|old_props
expr_stmt|;
name|new_version
operator|.
name|checksum
operator|=
name|NULL
expr_stmt|;
comment|/* not a file */
name|new_version
operator|.
name|props
operator|=
name|new_props
expr_stmt|;
name|SVN_ERR
argument_list|(
name|update_working_props
argument_list|(
operator|&
name|prop_state
argument_list|,
operator|&
name|conflict_skel
argument_list|,
operator|&
name|propchanges
argument_list|,
operator|&
name|actual_props
argument_list|,
name|b
argument_list|,
name|dst_relpath
argument_list|,
operator|&
name|old_version
argument_list|,
operator|&
name|new_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_state
operator|==
name|svn_wc_notify_state_conflicted
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_dst_repos_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_depth_get_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|move_dst_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|wcroot
argument_list|,
name|dst_relpath
argument_list|,
name|b
operator|->
name|dst_op_depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_conflict_markers
argument_list|(
operator|&
name|work_items
argument_list|,
name|local_abspath
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|move_dst_repos_relpath
argument_list|,
name|conflict_skel
argument_list|,
name|b
operator|->
name|operation
argument_list|,
operator|&
name|old_version
argument_list|,
operator|&
name|new_version
argument_list|,
name|svn_node_dir
argument_list|,
operator|!
name|obstructed
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|update_move_list_add
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|dst_relpath
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|svn_wc_notify_update_update
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|prop_state
argument_list|,
name|conflict_skel
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Edit the file found at the move destination, which is initially at  * the old state.  Merge the changes into the "working"/"actual" file.  *  * Merge the difference between OLD_VERSION and NEW_VERSION into  * the working file at LOCAL_RELPATH.  *  * The term 'old' refers to the pre-update state, which is the state of  * (some layer of) LOCAL_RELPATH while this function runs; and 'new'  * refers to the post-update state, as found at the (base layer of) the  * move source path while this function runs.  *  * LOCAL_RELPATH is a file in the working copy at WCROOT in DB, and  * REPOS_RELPATH is the repository path it would be committed to.  *  * Use NOTIFY_FUNC and NOTIFY_BATON for notifications.  * Set *WORK_ITEMS to any required work items, allocated in RESULT_POOL.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tc_editor_alter_file
parameter_list|(
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|old_checksum
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|new_checksum
parameter_list|,
name|apr_hash_t
modifier|*
name|old_props
parameter_list|,
name|apr_hash_t
modifier|*
name|new_props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_move_baton_t
modifier|*
name|b
init|=
name|nmb
operator|->
name|umb
decl_stmt|;
name|working_node_version_t
name|old_version
decl_stmt|,
name|new_version
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|dst_relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_pristine_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_pristine_abspath
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_skel
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|actual_props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|;
name|enum
name|svn_wc_merge_outcome_t
name|merge_outcome
decl_stmt|;
name|svn_wc_notify_state_t
name|prop_state
decl_stmt|,
name|content_state
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|,
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
name|svn_boolean_t
name|obstructed
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|mark_node_edited
argument_list|(
name|nmb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmb
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|wc_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_kind
operator|!=
name|svn_node_none
operator|&&
name|wc_kind
operator|!=
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|create_node_tree_conflict
argument_list|(
operator|&
name|conflict_skel
argument_list|,
name|nmb
argument_list|,
name|dst_relpath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_conflict_reason_obstructed
argument_list|,
name|svn_wc_conflict_action_edit
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|obstructed
operator|=
name|TRUE
expr_stmt|;
block|}
name|old_version
operator|.
name|location_and_kind
operator|=
name|b
operator|->
name|old_version
expr_stmt|;
name|new_version
operator|.
name|location_and_kind
operator|=
name|b
operator|->
name|new_version
expr_stmt|;
name|old_version
operator|.
name|checksum
operator|=
name|old_checksum
expr_stmt|;
name|old_version
operator|.
name|props
operator|=
name|old_props
expr_stmt|;
name|new_version
operator|.
name|checksum
operator|=
name|new_checksum
expr_stmt|;
name|new_version
operator|.
name|props
operator|=
name|new_props
expr_stmt|;
comment|/* ### TODO: Only do this when there is no higher WORKING layer */
name|SVN_ERR
argument_list|(
name|update_working_props
argument_list|(
operator|&
name|prop_state
argument_list|,
operator|&
name|conflict_skel
argument_list|,
operator|&
name|propchanges
argument_list|,
operator|&
name|actual_props
argument_list|,
name|b
argument_list|,
name|dst_relpath
argument_list|,
operator|&
name|old_version
argument_list|,
operator|&
name|new_version
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obstructed
operator|&&
operator|!
name|svn_checksum_match
argument_list|(
name|new_version
operator|.
name|checksum
argument_list|,
name|old_version
operator|.
name|checksum
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|is_locally_modified
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__internal_file_modified_p
argument_list|(
operator|&
name|is_locally_modified
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* exact_comparison */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_locally_modified
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|FALSE
comment|/* FIXME: use_commit_times? */
argument_list|,
name|TRUE
comment|/* record_file_info */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|content_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
block|}
else|else
block|{
comment|/*            * Run a 3-way merge to update the file, using the pre-update            * pristine text as the merge base, the post-update pristine            * text as the merge-left version, and the current content of the            * moved-here working file as the merge-right version.            */
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_path
argument_list|(
operator|&
name|old_pristine_abspath
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|old_version
operator|.
name|checksum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_pristine_get_path
argument_list|(
operator|&
name|new_pristine_abspath
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|new_version
operator|.
name|checksum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__internal_merge
argument_list|(
operator|&
name|work_item
argument_list|,
operator|&
name|conflict_skel
argument_list|,
operator|&
name|merge_outcome
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|old_pristine_abspath
argument_list|,
name|new_pristine_abspath
argument_list|,
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* diff labels */
name|actual_props
argument_list|,
name|FALSE
argument_list|,
comment|/* dry-run */
name|NULL
argument_list|,
comment|/* diff3-cmd */
name|NULL
argument_list|,
comment|/* merge options */
name|propchanges
argument_list|,
name|b
operator|->
name|cancel_func
argument_list|,
name|b
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_outcome
operator|==
name|svn_wc_merge_conflict
condition|)
name|content_state
operator|=
name|svn_wc_notify_state_conflicted
expr_stmt|;
else|else
name|content_state
operator|=
name|svn_wc_notify_state_merged
expr_stmt|;
block|}
block|}
else|else
name|content_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
comment|/* If there are any conflicts to be stored, convert them into work items    * too. */
if|if
condition|(
name|conflict_skel
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_dst_repos_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_depth_get_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|move_dst_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|wcroot
argument_list|,
name|dst_relpath
argument_list|,
name|b
operator|->
name|dst_op_depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_conflict_markers
argument_list|(
operator|&
name|work_item
argument_list|,
name|local_abspath
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|move_dst_repos_relpath
argument_list|,
name|conflict_skel
argument_list|,
name|b
operator|->
name|operation
argument_list|,
operator|&
name|old_version
argument_list|,
operator|&
name|new_version
argument_list|,
name|svn_node_file
argument_list|,
operator|!
name|obstructed
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|update_move_list_add
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|dst_relpath
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|svn_wc_notify_update_update
argument_list|,
name|svn_node_file
argument_list|,
name|content_state
argument_list|,
name|prop_state
argument_list|,
name|conflict_skel
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tc_editor_delete
parameter_list|(
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_node_kind_t
name|old_kind
parameter_list|,
name|svn_node_kind_t
name|new_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_move_baton_t
modifier|*
name|b
init|=
name|nmb
operator|->
name|umb
decl_stmt|;
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_boolean_t
name|is_modified
decl_stmt|,
name|is_all_deletes
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|mark_parent_edited
argument_list|(
name|nmb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmb
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Check before retracting delete to catch delete-delete      conflicts. This catches conflicts on the node itself; deleted      children are caught as local modifications below.*/
if|if
condition|(
name|nmb
operator|->
name|shadowed
condition|)
block|{
name|SVN_ERR
argument_list|(
name|mark_tc_on_op_root
argument_list|(
name|nmb
argument_list|,
name|old_kind
argument_list|,
name|new_kind
argument_list|,
name|svn_wc_conflict_action_delete
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_has_local_mods
argument_list|(
operator|&
name|is_modified
argument_list|,
operator|&
name|is_all_deletes
argument_list|,
name|nmb
operator|->
name|umb
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_modified
condition|)
block|{
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
comment|/* No conflict means no NODES rows at the relpath op-depth          so it's easy to convert the modified tree into a copy.           Note the following assumptions for relpath:             * it is not shadowed             * it is not the/an op-root. (or we can't make us a copy)        */
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_make_copy_internal
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|relpath
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|reason
operator|=
name|svn_wc_conflict_reason_edited
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_node_tree_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|nmb
argument_list|,
name|relpath
argument_list|,
name|old_kind
argument_list|,
name|new_kind
argument_list|,
name|reason
argument_list|,
operator|(
name|new_kind
operator|==
name|svn_node_none
operator|)
condition|?
name|svn_wc_conflict_action_delete
else|:
name|svn_wc_conflict_action_replace
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|nmb
operator|->
name|skip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|del_abspath
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
comment|/* Get all descendants of the node in reverse order (so children are          handled before their parents, but not strictly depth first) */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|b
operator|->
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_DESCENDANTS_OP_DEPTH_RV
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|b
operator|->
name|wcroot
operator|->
name|wc_id
argument_list|,
name|relpath
argument_list|,
name|b
operator|->
name|dst_op_depth
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|svn_node_kind_t
name|del_kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|del_kind
operator|=
name|svn_sqlite__column_token
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|kind_map
argument_list|)
expr_stmt|;
name|del_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|del_kind
operator|==
name|svn_node_dir
condition|)
name|err
operator|=
name|svn_wc__wq_build_dir_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|del_abspath
argument_list|,
name|FALSE
comment|/* recursive */
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|del_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_wc__db_wq_add_internal
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|work_item
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_dir_remove
argument_list|(
operator|&
name|work_items
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* recursive */
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_items
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|b
operator|->
name|wcroot
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* Only notify if add_file/add_dir is not going to notify */
if|if
condition|(
name|conflict
operator|||
operator|(
name|new_kind
operator|==
name|svn_node_none
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|update_move_list_add
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|relpath
argument_list|,
name|b
operator|->
name|db
argument_list|,
name|svn_wc_notify_update_delete
argument_list|,
name|new_kind
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|conflict
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|work_items
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_add_internal
argument_list|(
name|b
operator|->
name|wcroot
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Driver code.  *  * The scenario is that a subtree has been locally moved, and then the base  * layer on the source side of the move has received an update to a new  * state.  The destination subtree has not yet been updated, and still  * matches the pre-update state of the source subtree.  *  * The edit driver drives the receiver with the difference between the  * pre-update state (as found now at the move-destination) and the  * post-update state (found now at the move-source).  *  * We currently assume that both the pre-update and post-update states are  * single-revision.  */
end_comment

begin_comment
comment|/* Return *PROPS, *CHECKSUM, *CHILDREN and *KIND for LOCAL_RELPATH at    OP_DEPTH provided the row exists.  Return *KIND of svn_node_none if    the row does not exist, or only describes a delete of a lower op-depth.    *CHILDREN is a sorted array of basenames of type 'const char *', rather    than a hash, to allow the driver to process children in a defined order. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_info
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|children
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|int
name|op_depth
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_node_kind_t
name|db_kind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc__db_depth_get_info
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|db_kind
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|checksum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|op_depth
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If there is no node at this depth, or only a node that describes a delete      of a lower layer we report this node as not existing. */
if|if
condition|(
operator|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|)
operator|||
operator|(
operator|!
name|err
operator|&&
name|status
operator|!=
name|svn_wc__db_status_added
operator|&&
name|status
operator|!=
name|svn_wc__db_status_normal
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
condition|)
operator|*
name|kind
operator|=
name|svn_node_none
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
operator|*
name|checksum
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|props
condition|)
operator|*
name|props
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|children
condition|)
operator|*
name|children
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
condition|)
operator|*
name|kind
operator|=
name|db_kind
expr_stmt|;
if|if
condition|(
name|children
operator|&&
name|db_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
operator|*
name|children
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_OP_DEPTH_CHILDREN_EXISTS
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|op_depth
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
specifier|const
name|char
modifier|*
name|child_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|children
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_relpath_basename
argument_list|(
name|child_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|children
condition|)
operator|*
name|children
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if SRC_PROPS and DST_PROPS contain the same properties,    FALSE otherwise. SRC_PROPS and DST_PROPS are standard property    hashes. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|props_match
parameter_list|(
name|svn_boolean_t
modifier|*
name|match
parameter_list|,
name|apr_hash_t
modifier|*
name|src_props
parameter_list|,
name|apr_hash_t
modifier|*
name|dst_props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|src_props
operator|&&
operator|!
name|dst_props
condition|)
operator|*
name|match
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|src_props
operator|||
operator|!
name|dst_props
condition|)
operator|*
name|match
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|apr_array_header_t
modifier|*
name|propdiffs
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|propdiffs
argument_list|,
name|src_props
argument_list|,
name|dst_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|match
operator|=
name|propdiffs
operator|->
name|nelts
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ### Drive TC_EDITOR so as to ...  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_moved_away_node
parameter_list|(
name|node_move_baton_t
modifier|*
name|nmb
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_move_baton_t
modifier|*
name|b
init|=
name|nmb
operator|->
name|umb
decl_stmt|;
name|svn_node_kind_t
name|src_kind
decl_stmt|,
name|dst_kind
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|src_checksum
decl_stmt|,
modifier|*
name|dst_checksum
decl_stmt|;
name|apr_hash_t
modifier|*
name|src_props
decl_stmt|,
modifier|*
name|dst_props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|src_children
decl_stmt|,
modifier|*
name|dst_children
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|b
operator|->
name|cancel_func
argument_list|(
name|b
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_info
argument_list|(
operator|&
name|src_props
argument_list|,
operator|&
name|src_checksum
argument_list|,
operator|&
name|src_children
argument_list|,
operator|&
name|src_kind
argument_list|,
name|src_relpath
argument_list|,
name|b
operator|->
name|src_op_depth
argument_list|,
name|wcroot
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_info
argument_list|(
operator|&
name|dst_props
argument_list|,
operator|&
name|dst_checksum
argument_list|,
operator|&
name|dst_children
argument_list|,
operator|&
name|dst_kind
argument_list|,
name|dst_relpath
argument_list|,
name|b
operator|->
name|dst_op_depth
argument_list|,
name|wcroot
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_kind
operator|==
name|svn_node_none
operator|||
operator|(
name|dst_kind
operator|!=
name|svn_node_none
operator|&&
name|src_kind
operator|!=
name|dst_kind
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|tc_editor_delete
argument_list|(
name|nmb
argument_list|,
name|dst_relpath
argument_list|,
name|dst_kind
argument_list|,
name|src_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmb
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|src_kind
operator|!=
name|svn_node_none
operator|&&
name|src_kind
operator|!=
name|dst_kind
condition|)
block|{
if|if
condition|(
name|src_kind
operator|==
name|svn_node_file
operator|||
name|src_kind
operator|==
name|svn_node_symlink
condition|)
block|{
name|SVN_ERR
argument_list|(
name|tc_editor_add_file
argument_list|(
name|nmb
argument_list|,
name|dst_relpath
argument_list|,
name|dst_kind
argument_list|,
name|src_checksum
argument_list|,
name|src_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|tc_editor_add_directory
argument_list|(
name|nmb
argument_list|,
name|dst_relpath
argument_list|,
name|dst_kind
argument_list|,
name|src_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|src_kind
operator|!=
name|svn_node_none
condition|)
block|{
name|svn_boolean_t
name|props_equal
decl_stmt|;
name|SVN_ERR
argument_list|(
name|props_match
argument_list|(
operator|&
name|props_equal
argument_list|,
name|src_props
argument_list|,
name|dst_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_kind
operator|==
name|svn_node_file
operator|||
name|src_kind
operator|==
name|svn_node_symlink
condition|)
block|{
if|if
condition|(
operator|!
name|props_equal
operator|||
operator|!
name|svn_checksum_match
argument_list|(
name|src_checksum
argument_list|,
name|dst_checksum
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|tc_editor_alter_file
argument_list|(
name|nmb
argument_list|,
name|dst_relpath
argument_list|,
name|dst_checksum
argument_list|,
name|src_checksum
argument_list|,
name|dst_props
argument_list|,
name|src_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
operator|!
name|props_equal
condition|)
name|SVN_ERR
argument_list|(
name|tc_editor_alter_directory
argument_list|(
name|nmb
argument_list|,
name|dst_relpath
argument_list|,
name|dst_props
argument_list|,
name|src_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nmb
operator|->
name|skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|src_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|src_children
operator|->
name|nelts
operator|||
name|j
operator|<
name|dst_children
operator|->
name|nelts
condition|)
block|{
specifier|const
name|char
modifier|*
name|child_name
decl_stmt|;
name|svn_boolean_t
name|src_only
init|=
name|FALSE
decl_stmt|,
name|dst_only
init|=
name|FALSE
decl_stmt|;
name|node_move_baton_t
name|cnmb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|cnmb
operator|.
name|pb
operator|=
name|nmb
expr_stmt|;
name|cnmb
operator|.
name|umb
operator|=
name|nmb
operator|->
name|umb
expr_stmt|;
name|cnmb
operator|.
name|shadowed
operator|=
name|nmb
operator|->
name|shadowed
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|src_children
operator|->
name|nelts
condition|)
block|{
name|dst_only
operator|=
name|TRUE
expr_stmt|;
name|child_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|dst_children
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|>=
name|dst_children
operator|->
name|nelts
condition|)
block|{
name|src_only
operator|=
name|TRUE
expr_stmt|;
name|child_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|src_children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|src_name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|src_children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|dst_children
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
name|strcmp
argument_list|(
name|src_name
argument_list|,
name|dst_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|dst_only
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|src_only
operator|=
name|TRUE
expr_stmt|;
name|child_name
operator|=
name|dst_only
condition|?
name|dst_name
else|:
name|src_name
expr_stmt|;
block|}
name|cnmb
operator|.
name|src_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|src_relpath
argument_list|,
name|child_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|cnmb
operator|.
name|dst_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|dst_relpath
argument_list|,
name|child_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cnmb
operator|.
name|shadowed
condition|)
name|SVN_ERR
argument_list|(
name|check_node_shadowed
argument_list|(
operator|&
name|cnmb
operator|.
name|shadowed
argument_list|,
name|wcroot
argument_list|,
name|cnmb
operator|.
name|dst_relpath
argument_list|,
name|b
operator|->
name|dst_op_depth
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|update_moved_away_node
argument_list|(
operator|&
name|cnmb
argument_list|,
name|wcroot
argument_list|,
name|cnmb
operator|.
name|src_relpath
argument_list|,
name|cnmb
operator|.
name|dst_relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst_only
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|src_only
condition|)
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|nmb
operator|->
name|skip
condition|)
comment|/* Does parent now want a skip? */
break|break;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|suitable_for_move
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_BASE_NODE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"is"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_row
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
name|revision
operator|=
name|svn_sqlite__column_revnum
argument_list|(
name|stmt
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|repos_relpath
operator|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_REPOS_PATH_REVISION
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"is"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
name|svn_revnum_t
name|node_revision
init|=
name|svn_sqlite__column_revnum
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|relpath
operator|=
name|svn_relpath_skip_ancestor
argument_list|(
name|local_relpath
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
name|relpath
operator|=
name|svn_relpath_join
argument_list|(
name|repos_relpath
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|revision
operator|!=
name|node_revision
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Cannot apply update because move source "
literal|"%s' is a mixed-revision working copy"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|relpath
argument_list|,
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Cannot apply update because move source "
literal|"'%s' is a switched subtree"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The body of svn_wc__db_update_moved_away_conflict_victim(), which see.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_moved_away_conflict_victim
parameter_list|(
name|svn_revnum_t
modifier|*
name|old_rev
parameter_list|,
name|svn_revnum_t
modifier|*
name|new_rev
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|delete_relpath
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
name|svn_wc_conflict_reason_t
name|reason
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|update_move_baton_t
name|umb
init|=
block|{
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_relpath
decl_stmt|,
modifier|*
name|dst_relpath
decl_stmt|;
name|svn_wc_conflict_version_t
name|old_version
decl_stmt|;
name|svn_wc_conflict_version_t
name|new_version
decl_stmt|;
name|apr_int64_t
name|repos_id
decl_stmt|;
name|node_move_baton_t
name|nmb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_relpath_skip_ancestor
argument_list|(
name|delete_relpath
argument_list|,
name|local_relpath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Construct editor baton. */
name|SVN_ERR
argument_list|(
name|find_src_op_depth
argument_list|(
operator|&
name|umb
operator|.
name|src_op_depth
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|relpath_depth
argument_list|(
name|delete_relpath
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_scan_moved_to_internal
argument_list|(
operator|&
name|src_relpath
argument_list|,
operator|&
name|dst_relpath
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|umb
operator|.
name|src_op_depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_relpath
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' has not been moved away"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|umb
operator|.
name|dst_op_depth
operator|=
name|relpath_depth
argument_list|(
name|dst_relpath
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_write_lock
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_write_lock
argument_list|(
name|wcroot
argument_list|,
name|dst_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_depth_get_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|new_version
operator|.
name|node_kind
argument_list|,
operator|&
name|new_version
operator|.
name|peg_rev
argument_list|,
operator|&
name|new_version
operator|.
name|path_in_repos
argument_list|,
operator|&
name|repos_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|umb
operator|.
name|src_op_depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|new_version
operator|.
name|repos_url
argument_list|,
operator|&
name|new_version
operator|.
name|repos_uuid
argument_list|,
name|wcroot
argument_list|,
name|repos_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_depth_get_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|old_version
operator|.
name|node_kind
argument_list|,
operator|&
name|old_version
operator|.
name|peg_rev
argument_list|,
operator|&
name|old_version
operator|.
name|path_in_repos
argument_list|,
operator|&
name|repos_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|dst_relpath
argument_list|,
name|umb
operator|.
name|dst_op_depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|old_version
operator|.
name|repos_url
argument_list|,
operator|&
name|old_version
operator|.
name|repos_uuid
argument_list|,
name|wcroot
argument_list|,
name|repos_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|old_rev
operator|=
name|old_version
operator|.
name|peg_rev
expr_stmt|;
operator|*
name|new_rev
operator|=
name|new_version
operator|.
name|peg_rev
expr_stmt|;
name|umb
operator|.
name|operation
operator|=
name|operation
expr_stmt|;
name|umb
operator|.
name|old_version
operator|=
operator|&
name|old_version
expr_stmt|;
name|umb
operator|.
name|new_version
operator|=
operator|&
name|new_version
expr_stmt|;
name|umb
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|umb
operator|.
name|wcroot
operator|=
name|wcroot
expr_stmt|;
name|umb
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|umb
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
if|if
condition|(
name|umb
operator|.
name|src_op_depth
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|suitable_for_move
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new, and empty, list for notification information. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_CREATE_UPDATE_MOVE_LIST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Drive the editor... */
name|nmb
operator|.
name|umb
operator|=
operator|&
name|umb
expr_stmt|;
name|nmb
operator|.
name|src_relpath
operator|=
name|src_relpath
expr_stmt|;
name|nmb
operator|.
name|dst_relpath
operator|=
name|dst_relpath
expr_stmt|;
comment|/* nmb.shadowed = FALSE; */
comment|/* nmb.edited = FALSE; */
comment|/* nmb.skip_children = FALSE; */
comment|/* We walk the move source (i.e. the post-update tree), comparing each node     * with the equivalent node at the move destination and applying the update     * to nodes at the move destination. */
name|SVN_ERR
argument_list|(
name|update_moved_away_node
argument_list|(
operator|&
name|nmb
argument_list|,
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|dst_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_copy_layer_internal
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|umb
operator|.
name|src_op_depth
argument_list|,
name|dst_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_update_moved_away_conflict_victim
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|delete_op_abspath
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
name|svn_wc_conflict_reason_t
name|reason
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
decl_stmt|;
name|svn_revnum_t
name|old_rev
decl_stmt|,
name|new_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|delete_relpath
decl_stmt|;
comment|/* ### Check for mixed-rev src or dst? */
name|SVN_ERR
argument_list|(
name|svn_wc__db_wcroot_parse_local_abspath
argument_list|(
operator|&
name|wcroot
argument_list|,
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY_USABLE_WCROOT
argument_list|(
name|wcroot
argument_list|)
expr_stmt|;
name|delete_relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|delete_op_abspath
argument_list|)
expr_stmt|;
name|SVN_WC__DB_WITH_TXN
argument_list|(
name|update_moved_away_conflict_victim
argument_list|(
operator|&
name|old_rev
argument_list|,
operator|&
name|new_rev
argument_list|,
name|db
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|delete_relpath
argument_list|,
name|operation
argument_list|,
name|action
argument_list|,
name|reason
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|wcroot
argument_list|)
expr_stmt|;
comment|/* Send all queued up notifications. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_update_move_list_notify
argument_list|(
name|wcroot
argument_list|,
name|old_rev
argument_list|,
name|new_rev
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|svn_dirent_join
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_wc_notify_update_completed
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
name|new_rev
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *CAN_BUMP to TRUE if DEPTH is sufficient to cover the entire    tree  LOCAL_RELPATH at OP_DEPTH, to FALSE otherwise. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|depth_sufficient_to_bump
parameter_list|(
name|svn_boolean_t
modifier|*
name|can_bump
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|int
name|op_depth
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
name|svn_depth_infinity
case|:
operator|*
name|can_bump
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_depth_empty
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_OP_DEPTH_CHILDREN
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|op_depth
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_depth_files
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_HAS_NON_FILE_CHILDREN
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|op_depth
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_depth_immediates
case|:
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_HAS_GRANDCHILDREN
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|op_depth
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|can_bump
operator|=
operator|!
name|have_row
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Mark a move-edit conflict on MOVE_SRC_ROOT_RELPATH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_mark_tree_conflict
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|move_src_root_relpath
parameter_list|,
name|int
name|src_op_depth
parameter_list|,
specifier|const
name|char
modifier|*
name|move_src_op_root_relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|move_dst_op_root_relpath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_int64_t
name|repos_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_repos_relpath
decl_stmt|;
name|svn_revnum_t
name|old_rev
decl_stmt|;
name|svn_revnum_t
name|new_rev
decl_stmt|;
name|svn_node_kind_t
name|old_kind
decl_stmt|;
name|svn_node_kind_t
name|new_kind
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|old_version
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|new_version
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
comment|/* Verify precondition: We are allowed to set a tree conflict here. */
name|SVN_ERR
argument_list|(
name|verify_write_lock
argument_list|(
name|wcroot
argument_list|,
name|move_src_root_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read new (post-update) information from the new move source BASE node. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_depth_get_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|new_kind
argument_list|,
operator|&
name|new_rev
argument_list|,
operator|&
name|new_repos_relpath
argument_list|,
operator|&
name|repos_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|move_src_op_root_relpath
argument_list|,
name|src_op_depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_fetch_repos_info
argument_list|(
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|wcroot
argument_list|,
name|repos_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read old (pre-update) information from the move destination node.       This potentially touches nodes that aren't locked by us, but that is not      a problem because we have a SQLite write lock here, and all sqlite      operations that affect move stability use a sqlite lock as well.      (And affecting the move itself requires a write lock on the node that       we do own the lock for: the move source)   */
name|SVN_ERR
argument_list|(
name|svn_wc__db_depth_get_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|old_kind
argument_list|,
operator|&
name|old_rev
argument_list|,
operator|&
name|old_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|move_dst_op_root_relpath
argument_list|,
name|relpath_depth
argument_list|(
name|move_dst_op_root_relpath
argument_list|)
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|move_src_root_relpath
argument_list|,
name|move_src_op_root_relpath
argument_list|)
condition|)
block|{
comment|/* We have information for the op-root, but need it for the node that          we are putting the tree conflict on. Luckily we know that we have          a clean BASE */
specifier|const
name|char
modifier|*
name|rpath
init|=
name|svn_relpath_skip_ancestor
argument_list|(
name|move_src_op_root_relpath
argument_list|,
name|move_src_root_relpath
argument_list|)
decl_stmt|;
name|old_repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|old_repos_relpath
argument_list|,
name|rpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|new_repos_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|new_repos_relpath
argument_list|,
name|rpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|old_version
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|old_repos_relpath
argument_list|,
name|old_rev
argument_list|,
name|old_kind
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|new_version
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|new_repos_relpath
argument_list|,
name|new_rev
argument_list|,
name|new_kind
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_tree_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|wcroot
argument_list|,
name|move_src_root_relpath
argument_list|,
name|move_dst_op_root_relpath
argument_list|,
name|db
argument_list|,
name|old_version
argument_list|,
name|new_version
argument_list|,
name|svn_wc_operation_update
argument_list|,
name|old_kind
argument_list|,
name|new_kind
argument_list|,
name|old_repos_relpath
argument_list|,
name|svn_wc_conflict_reason_moved_away
argument_list|,
name|svn_wc_conflict_action_edit
argument_list|,
name|move_src_op_root_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|update_move_list_add
argument_list|(
name|wcroot
argument_list|,
name|move_src_root_relpath
argument_list|,
name|db
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|new_kind
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|conflict
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Checks if SRC_RELPATH is within BUMP_DEPTH from BUMP_ROOT. Sets  * *SKIP to TRUE if the node should be skipped, otherwise to FALSE.  * Sets *SRC_DEPTH to the remaining depth at SRC_RELPATH.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_bump_layer
parameter_list|(
name|svn_boolean_t
modifier|*
name|skip
parameter_list|,
name|svn_depth_t
modifier|*
name|src_depth
parameter_list|,
specifier|const
name|char
modifier|*
name|bump_root
parameter_list|,
name|svn_depth_t
name|bump_depth
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
name|svn_node_kind_t
name|src_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
operator|*
name|skip
operator|=
name|FALSE
expr_stmt|;
operator|*
name|src_depth
operator|=
name|bump_depth
expr_stmt|;
name|relpath
operator|=
name|svn_relpath_skip_ancestor
argument_list|(
name|bump_root
argument_list|,
name|src_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relpath
condition|)
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bump_depth
operator|==
name|svn_depth_infinity
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|relpath
operator|&&
operator|*
name|relpath
operator|==
literal|'\0'
condition|)
return|return
name|SVN_NO_ERROR
return|;
switch|switch
condition|(
name|bump_depth
condition|)
block|{
case|case
name|svn_depth_empty
case|:
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_depth_files
case|:
if|if
condition|(
name|src_kind
operator|!=
name|svn_node_file
condition|)
block|{
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Fallthrough */
case|case
name|svn_depth_immediates
case|:
if|if
condition|(
operator|!
name|relpath
operator|||
name|relpath_depth
argument_list|(
name|relpath
argument_list|)
operator|>
literal|1
condition|)
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
operator|*
name|src_depth
operator|=
name|svn_depth_empty
expr_stmt|;
break|break;
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The guts of bump_moved_away: Determines if a move can be bumped to match  * the move origin and if so performs this bump.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_moved_layer
parameter_list|(
name|svn_boolean_t
modifier|*
name|recurse
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|int
name|op_depth
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
name|int
name|src_del_depth
parameter_list|,
name|svn_depth_t
name|src_depth
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|svn_boolean_t
name|can_bump
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_root_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|verify_write_lock
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|recurse
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_HAS_LAYER_BETWEEN
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isdd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|op_depth
argument_list|,
name|src_del_depth
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_row
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|op_depth
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|depth_sufficient_to_bump
argument_list|(
operator|&
name|can_bump
argument_list|,
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|op_depth
argument_list|,
name|src_depth
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Having chosen to bump an entire BASE tree move we        always have sufficient depth to bump subtree moves. */
name|can_bump
operator|=
name|TRUE
expr_stmt|;
comment|/* Are we allowed to bump */
if|if
condition|(
name|can_bump
condition|)
block|{
name|svn_boolean_t
name|locked
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock_internal
argument_list|(
operator|&
name|locked
argument_list|,
name|wcroot
argument_list|,
name|dst_relpath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|can_bump
operator|=
name|FALSE
expr_stmt|;
block|}
name|src_root_relpath
operator|=
name|svn_relpath_prefix
argument_list|(
name|src_relpath
argument_list|,
name|src_del_depth
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_bump
condition|)
block|{
name|SVN_ERR
argument_list|(
name|bump_mark_tree_conflict
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|op_depth
argument_list|,
name|src_root_relpath
argument_list|,
name|dst_relpath
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict_internal
argument_list|(
operator|&
name|conflict
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|src_root_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### TODO: check this is the right sort of tree-conflict? */
if|if
condition|(
operator|!
name|conflict
condition|)
block|{
comment|/* ### TODO: verify moved_here? */
name|SVN_ERR
argument_list|(
name|verify_write_lock
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_copy_layer_internal
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|op_depth
argument_list|,
name|dst_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|recurse
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Internal storage for bump_moved_away() */
end_comment

begin_struct
struct|struct
name|bump_pair_t
block|{
specifier|const
name|char
modifier|*
name|src_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_relpath
decl_stmt|;
name|int
name|src_del_op_depth
decl_stmt|;
name|svn_node_kind_t
name|src_kind
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bump moves of LOCAL_RELPATH and all its descendants that were    originally below LOCAL_RELPATH at op-depth OP_DEPTH.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bump_moved_away
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|int
name|op_depth
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|pairs
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|32
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bump_pair_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Build an array, as we can't execute the same Sqlite query recursively */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_MOVED_PAIR3
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|op_depth
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
name|struct
name|bump_pair_t
modifier|*
name|bp
init|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|)
decl_stmt|;
name|bp
operator|->
name|src_relpath
operator|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|bp
operator|->
name|dst_relpath
operator|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|bp
operator|->
name|src_del_op_depth
operator|=
name|svn_sqlite__column_int
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bp
operator|->
name|src_kind
operator|=
name|svn_sqlite__column_token
argument_list|(
name|stmt
argument_list|,
literal|3
argument_list|,
name|kind_map
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|pairs
argument_list|,
expr|struct
name|bump_pair_t
operator|*
argument_list|)
operator|=
name|bp
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pairs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bump_pair_t
modifier|*
name|bp
init|=
name|APR_ARRAY_IDX
argument_list|(
name|pairs
argument_list|,
name|i
argument_list|,
expr|struct
name|bump_pair_t
operator|*
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|skip
decl_stmt|;
name|svn_depth_t
name|src_wc_depth
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_bump_layer
argument_list|(
operator|&
name|skip
argument_list|,
operator|&
name|src_wc_depth
argument_list|,
name|local_relpath
argument_list|,
name|depth
argument_list|,
name|bp
operator|->
name|src_relpath
argument_list|,
name|bp
operator|->
name|src_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|svn_boolean_t
name|recurse
decl_stmt|;
name|SVN_ERR
argument_list|(
name|bump_moved_layer
argument_list|(
operator|&
name|recurse
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|op_depth
argument_list|,
name|bp
operator|->
name|src_relpath
argument_list|,
name|bp
operator|->
name|src_del_op_depth
argument_list|,
name|src_wc_depth
argument_list|,
name|bp
operator|->
name|dst_relpath
argument_list|,
name|db
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recurse
condition|)
name|SVN_ERR
argument_list|(
name|bump_moved_away
argument_list|(
name|wcroot
argument_list|,
name|bp
operator|->
name|dst_relpath
argument_list|,
name|relpath_depth
argument_list|(
name|bp
operator|->
name|dst_relpath
argument_list|)
argument_list|,
name|depth
argument_list|,
name|db
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_bump_moved_away
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_CREATE_UPDATE_MOVE_LIST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_dst_op_root_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|move_src_root_relpath
decl_stmt|,
modifier|*
name|delete_relpath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Is the root of the update moved away? (Impossible for the wcroot) */
name|err
operator|=
name|svn_wc__db_scan_moved_to_internal
argument_list|(
operator|&
name|move_src_root_relpath
argument_list|,
operator|&
name|move_dst_op_root_relpath
argument_list|,
operator|&
name|delete_relpath
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
literal|0
comment|/* BASE */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|move_src_root_relpath
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|move_src_root_relpath
argument_list|,
name|local_relpath
argument_list|)
condition|)
block|{
comment|/* An ancestor of the path that was updated is moved away.                   If we have a lock on that ancestor, we can mark a tree                  conflict on it, if we don't we ignore this case. A future                  update of the ancestor will handle this. */
name|svn_boolean_t
name|locked
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wclock_owns_lock_internal
argument_list|(
operator|&
name|locked
argument_list|,
name|wcroot
argument_list|,
name|move_src_root_relpath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
block|{
name|SVN_ERR
argument_list|(
name|bump_mark_tree_conflict
argument_list|(
name|wcroot
argument_list|,
name|move_src_root_relpath
argument_list|,
literal|0
argument_list|,
name|delete_relpath
argument_list|,
name|move_dst_op_root_relpath
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
name|SVN_ERR
argument_list|(
name|bump_moved_away
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
literal|0
argument_list|,
name|depth
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *OPERATION, *LOCAL_CHANGE, *INCOMING_CHANGE, *OLD_VERSION, *NEW_VERSION  * to reflect the tree conflict on the victim SRC_ABSPATH in DB.  *  * If SRC_ABSPATH is not a tree-conflict victim, return an error.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_conflict_details
parameter_list|(
name|int
modifier|*
name|src_op_depth
parameter_list|,
name|svn_wc_operation_t
modifier|*
name|operation
parameter_list|,
name|svn_wc_conflict_action_t
modifier|*
name|action
parameter_list|,
name|svn_wc_conflict_version_t
modifier|*
modifier|*
name|left_version
parameter_list|,
name|svn_wc_conflict_version_t
modifier|*
modifier|*
name|right_version
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|locations
decl_stmt|;
name|svn_boolean_t
name|text_conflicted
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
specifier|const
name|char
modifier|*
name|move_src_op_root_abspath
decl_stmt|;
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|conflict_skel
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not in conflict"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
name|operation
argument_list|,
operator|&
name|locations
argument_list|,
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_conflicted
operator|||
name|prop_conflicted
operator|||
operator|!
name|tree_conflicted
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid tree-conflict victim"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
name|action
argument_list|,
operator|&
name|move_src_op_root_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is already a moved away tree-conflict"
argument_list|)
argument_list|,
name|path_for_error_message
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|left_version
condition|)
block|{
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|0
condition|)
operator|*
name|left_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|0
argument_list|,
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
else|else
operator|*
name|left_version
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|right_version
condition|)
block|{
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|1
condition|)
operator|*
name|right_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|1
argument_list|,
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
else|else
operator|*
name|right_version
operator|=
name|NULL
expr_stmt|;
block|}
block|{
name|int
name|del_depth
init|=
name|relpath_depth
argument_list|(
name|local_relpath
argument_list|)
decl_stmt|;
if|if
condition|(
name|move_src_op_root_abspath
condition|)
name|del_depth
operator|=
name|relpath_depth
argument_list|(
name|svn_dirent_skip_ancestor
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|move_src_op_root_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_src_op_depth
argument_list|(
name|src_op_depth
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|del_depth
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_op_raise_moved_away_internal
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|int
name|src_op_depth
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|old_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|new_version
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_CREATE_UPDATE_MOVE_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_MOVED_DESCENDANTS_SRC
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|src_op_depth
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|delete_op_depth
init|=
name|svn_sqlite__column_int
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|src_kind
init|=
name|svn_sqlite__column_token
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|,
name|kind_map
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_repos_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|src_repos_relpath
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|create_tree_conflict
argument_list|(
operator|&
name|conflict
argument_list|,
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|dst_relpath
argument_list|,
name|db
argument_list|,
name|old_version
argument_list|,
name|new_version
argument_list|,
name|operation
argument_list|,
name|src_kind
comment|/* ### old kind */
argument_list|,
name|src_kind
comment|/* ### new kind */
argument_list|,
name|src_repos_relpath
argument_list|,
name|svn_wc_conflict_reason_moved_away
argument_list|,
name|action
argument_list|,
name|svn_relpath_prefix
argument_list|(
name|src_relpath
argument_list|,
name|delete_op_depth
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|update_move_list_add
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|db
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|src_kind
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|conflict
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_op_raise_moved_away
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
name|svn_wc_conflict_action_t
name|action
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|left_version
decl_stmt|,
modifier|*
name|right_version
decl_stmt|;
name|int
name|move_src_op_depth
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wcroot_parse_local_abspath
argument_list|(
operator|&
name|wcroot
argument_list|,
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY_USABLE_WCROOT
argument_list|(
name|wcroot
argument_list|)
expr_stmt|;
name|SVN_WC__DB_WITH_TXN4
argument_list|(
name|svn_wc__db_read_conflict_internal
argument_list|(
operator|&
name|conflict
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|fetch_conflict_details
argument_list|(
operator|&
name|move_src_op_depth
argument_list|,
operator|&
name|operation
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|left_version
argument_list|,
operator|&
name|right_version
argument_list|,
name|wcroot
argument_list|,
name|db
argument_list|,
name|local_relpath
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_wc__db_op_mark_resolved_internal
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|db
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_wc__db_op_raise_moved_away_internal
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|move_src_op_depth
argument_list|,
name|db
argument_list|,
name|operation
argument_list|,
name|action
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|wcroot
argument_list|)
expr_stmt|;
comment|/* These version numbers are valid for update/switch notifications       only! */
name|SVN_ERR
argument_list|(
name|svn_wc__db_update_move_list_notify
argument_list|(
name|wcroot
argument_list|,
operator|(
name|left_version
condition|?
name|left_version
operator|->
name|peg_rev
else|:
name|SVN_INVALID_REVNUM
operator|)
argument_list|,
operator|(
name|right_version
condition|?
name|right_version
operator|->
name|peg_rev
else|:
name|SVN_INVALID_REVNUM
operator|)
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|break_moved_away
parameter_list|(
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|int
name|parent_src_op_depth
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__exec_statements
argument_list|(
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_CREATE_UPDATE_MOVE_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_MOVED_DESCENDANTS_SRC
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
name|parent_src_op_depth
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
name|int
name|src_op_depth
init|=
name|svn_sqlite__column_int
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|src_kind
init|=
name|svn_sqlite__column_token
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|,
name|kind_map
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|verify_write_lock
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|verify_write_lock
argument_list|(
name|wcroot
argument_list|,
name|dst_relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|svn_wc__db_op_break_move_internal
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|src_op_depth
argument_list|,
name|dst_relpath
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|update_move_list_add
argument_list|(
name|wcroot
argument_list|,
name|src_relpath
argument_list|,
name|db
argument_list|,
name|svn_wc_notify_move_broken
argument_list|,
name|src_kind
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__db_op_break_moved_away
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|del_op_root_abspath
parameter_list|,
name|svn_boolean_t
name|mark_tc_resolved
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|del_relpath
decl_stmt|;
name|int
name|src_op_depth
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wcroot_parse_local_abspath
argument_list|(
operator|&
name|wcroot
argument_list|,
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY_USABLE_WCROOT
argument_list|(
name|wcroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|del_op_root_abspath
condition|)
name|del_relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|del_op_root_abspath
argument_list|)
expr_stmt|;
else|else
name|del_relpath
operator|=
name|NULL
expr_stmt|;
name|SVN_WC__DB_WITH_TXN4
argument_list|(
name|find_src_op_depth
argument_list|(
operator|&
name|src_op_depth
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|del_relpath
condition|?
name|relpath_depth
argument_list|(
name|del_relpath
argument_list|)
else|:
name|relpath_depth
argument_list|(
name|local_relpath
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|break_moved_away
argument_list|(
name|wcroot
argument_list|,
name|db
argument_list|,
name|local_relpath
argument_list|,
name|src_op_depth
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|mark_tc_resolved
condition|?
name|svn_wc__db_op_mark_resolved_internal
argument_list|(
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|db
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|SVN_NO_ERROR
argument_list|,
name|SVN_NO_ERROR
argument_list|,
name|wcroot
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_update_move_list_notify
argument_list|(
name|wcroot
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|required_lock_for_resolve
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|required_relpath
parameter_list|,
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
parameter_list|,
specifier|const
name|char
modifier|*
name|local_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_sqlite__stmt_t
modifier|*
name|stmt
decl_stmt|;
name|svn_boolean_t
name|have_row
decl_stmt|;
operator|*
name|required_relpath
operator|=
name|local_relpath
expr_stmt|;
comment|/* This simply looks for all moves out of the LOCAL_RELPATH tree. We      could attempt to limit it to only those moves that are going to      be resolved but that would require second guessing the resolver.      This simple algorithm is sufficient although it may give a      strictly larger/deeper lock than necessary. */
name|SVN_ERR
argument_list|(
name|svn_sqlite__get_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|wcroot
operator|->
name|sdb
argument_list|,
name|STMT_SELECT_MOVED_OUTSIDE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__bindf
argument_list|(
name|stmt
argument_list|,
literal|"isd"
argument_list|,
name|wcroot
operator|->
name|wc_id
argument_list|,
name|local_relpath
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|have_row
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_dst_relpath
init|=
name|svn_sqlite__column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
operator|*
name|required_relpath
operator|=
name|svn_relpath_get_longest_ancestor
argument_list|(
operator|*
name|required_relpath
argument_list|,
name|move_dst_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_sqlite__step
argument_list|(
operator|&
name|have_row
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_sqlite__reset
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|required_relpath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
operator|*
name|required_relpath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__required_lock_for_resolve
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|required_abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc__db_wcroot_t
modifier|*
name|wcroot
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|required_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_wcroot_parse_local_abspath
argument_list|(
operator|&
name|wcroot
argument_list|,
operator|&
name|local_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY_USABLE_WCROOT
argument_list|(
name|wcroot
argument_list|)
expr_stmt|;
name|SVN_WC__DB_WITH_TXN
argument_list|(
name|required_lock_for_resolve
argument_list|(
operator|&
name|required_relpath
argument_list|,
name|wcroot
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|wcroot
argument_list|)
expr_stmt|;
operator|*
name|required_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|wcroot
operator|->
name|abspath
argument_list|,
name|required_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

