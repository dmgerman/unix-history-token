begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * conflicts.c: routines for managing conflict data.  *            NOTE: this code doesn't know where the conflict is  *            actually stored.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"wc.h"
end_include

begin_include
include|#
directive|include
file|"wc_db.h"
end_include

begin_include
include|#
directive|include
file|"conflicts.h"
end_include

begin_include
include|#
directive|include
file|"workqueue.h"
end_include

begin_include
include|#
directive|include
file|"props.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* --------------------------------------------------------------------  * Conflict skel management  */
end_comment

begin_function
name|svn_skel_t
modifier|*
name|svn_wc__conflict_skel_create
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|conflict_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
comment|/* Add empty CONFLICTS list */
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|conflict_skel
argument_list|)
expr_stmt|;
comment|/* Add empty WHY list */
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|conflict_skel
argument_list|)
expr_stmt|;
return|return
name|conflict_skel
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_is_complete
parameter_list|(
name|svn_boolean_t
modifier|*
name|complete
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|)
block|{
operator|*
name|complete
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|svn_skel__list_length
argument_list|(
name|conflict_skel
argument_list|)
operator|<
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Not a conflict skel"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|svn_skel__list_length
argument_list|(
name|conflict_skel
operator|->
name|children
argument_list|)
operator|<
literal|2
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* WHY is not set */
if|if
condition|(
name|svn_skel__list_length
argument_list|(
name|conflict_skel
operator|->
name|children
operator|->
name|next
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* No conflict set */
operator|*
name|complete
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Serialize a svn_wc_conflict_version_t before the existing data in skel */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict__prepend_location
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|location
parameter_list|,
name|svn_boolean_t
name|allow_NULL
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|loc
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|location
operator|||
name|allow_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|location
condition|)
block|{
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* ("subversion" repos_root_url repos_uuid repos_relpath rev kind) */
name|loc
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|svn_node_kind_to_word
argument_list|(
name|location
operator|->
name|node_kind
argument_list|)
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_int
argument_list|(
name|location
operator|->
name|peg_rev
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|location
operator|->
name|path_in_repos
argument_list|)
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|location
operator|->
name|repos_uuid
condition|)
comment|/* Can theoretically be NULL */
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend_str
argument_list|(
name|location
operator|->
name|repos_uuid
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|location
operator|->
name|repos_url
argument_list|)
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_SRC_SUBVERSION
argument_list|,
name|loc
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|loc
argument_list|,
name|skel
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Deserialize a svn_wc_conflict_version_t from the skel.    Set *LOCATION to NULL when the data is not a svn_wc_conflict_version_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict__read_location
parameter_list|(
name|svn_wc_conflict_version_t
modifier|*
modifier|*
name|location
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|apr_int64_t
name|v
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
comment|/* note that 'none' is a legitimate value */
specifier|const
name|char
modifier|*
name|kind_str
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|c
init|=
name|skel
operator|->
name|children
decl_stmt|;
if|if
condition|(
operator|!
name|svn_skel__matches_atom
argument_list|(
name|c
argument_list|,
name|SVN_WC__CONFLICT_SRC_SUBVERSION
argument_list|)
condition|)
block|{
operator|*
name|location
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|repos_root_url
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|is_atom
condition|)
name|repos_uuid
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
name|repos_uuid
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|repos_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_skel__parse_int
argument_list|(
operator|&
name|v
argument_list|,
name|c
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|revision
operator|=
operator|(
name|svn_revnum_t
operator|)
name|v
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|kind_str
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
expr_stmt|;
name|node_kind
operator|=
name|svn_node_kind_from_word
argument_list|(
name|kind_str
argument_list|)
expr_stmt|;
operator|*
name|location
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|repos_relpath
argument_list|,
name|revision
argument_list|,
name|node_kind
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get the operation part of CONFLICT_SKELL or NULL if no operation is set    at this time */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict__get_operation
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|why
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
operator|*
name|why
operator|=
name|conflict_skel
operator|->
name|children
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|why
operator|)
operator|->
name|children
condition|)
operator|*
name|why
operator|=
name|NULL
expr_stmt|;
comment|/* Operation is not set yet */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_set_op_update
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|why
decl_stmt|;
name|svn_skel_t
modifier|*
name|origins
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|why
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|why
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No operation set */
name|why
operator|=
name|conflict_skel
operator|->
name|children
expr_stmt|;
name|origins
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|target
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|original
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|origins
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_OP_UPDATE
argument_list|,
name|why
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_set_op_switch
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|original
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|why
decl_stmt|;
name|svn_skel_t
modifier|*
name|origins
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|why
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|why
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No operation set */
name|why
operator|=
name|conflict_skel
operator|->
name|children
expr_stmt|;
name|origins
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|target
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|original
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|origins
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_OP_SWITCH
argument_list|,
name|why
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_set_op_merge
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|why
decl_stmt|;
name|svn_skel_t
modifier|*
name|origins
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|why
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|why
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* No operation set */
name|why
operator|=
name|conflict_skel
operator|->
name|children
expr_stmt|;
name|origins
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|right
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__prepend_location
argument_list|(
name|origins
argument_list|,
name|left
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|origins
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_OP_MERGE
argument_list|,
name|why
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Gets the conflict data of the specified type CONFLICT_TYPE from    CONFLICT_SKEL, or NULL if no such conflict is recorded */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict__get_conflict
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|conflict
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|char
modifier|*
name|conflict_type
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|&&
name|conflict_skel
operator|->
name|children
operator|&&
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|&&
operator|!
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|children
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|c
operator|->
name|children
argument_list|,
name|conflict_type
argument_list|)
condition|)
block|{
operator|*
name|conflict
operator|=
name|c
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
operator|*
name|conflict
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_add_text_conflict
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|mine_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|their_old_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|their_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|text_conflict
decl_stmt|;
name|svn_skel_t
modifier|*
name|markers
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|text_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|text_conflict
argument_list|)
expr_stmt|;
comment|/* ### Use proper error? */
comment|/* Current skel format      ("text"       (OLD MINE OLD-THEIRS THEIRS)) */
name|text_conflict
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|markers
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|their_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|their_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|their_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|their_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|their_relpath
argument_list|,
name|markers
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|markers
argument_list|)
expr_stmt|;
if|if
condition|(
name|mine_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|mine_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|mine_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|mine_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|mine_relpath
argument_list|,
name|markers
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|markers
argument_list|)
expr_stmt|;
if|if
condition|(
name|their_old_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|original_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|original_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|their_old_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|original_relpath
argument_list|,
name|markers
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
argument_list|,
name|markers
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|markers
argument_list|,
name|text_conflict
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|,
name|text_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* And add it to the conflict skel */
name|svn_skel__prepend
argument_list|(
name|text_conflict
argument_list|,
name|conflict_skel
operator|->
name|children
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_add_prop_conflict
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|marker_abspath
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|mine_props
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|their_old_props
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|their_props
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|conflicted_prop_names
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|prop_conflict
decl_stmt|;
name|svn_skel_t
modifier|*
name|props
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflict_names
decl_stmt|;
name|svn_skel_t
modifier|*
name|markers
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|prop_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|prop_conflict
argument_list|)
expr_stmt|;
comment|/* ### Use proper error? */
comment|/* This function currently implements:      ("prop"       ("marker_relpath")       prop-conflicted_prop_names       old-props       mine-props       their-props)      NULL lists are recorded as "" */
comment|/* ### Seems that this may not match what we read out.  Read-out of    * 'theirs-old' comes as NULL. */
name|prop_conflict
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|their_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|their_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|props
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend_str
argument_list|(
literal|""
argument_list|,
name|prop_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* No their_props */
if|if
condition|(
name|mine_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|mine_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|props
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend_str
argument_list|(
literal|""
argument_list|,
name|prop_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* No mine_props */
if|if
condition|(
name|their_old_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|their_old_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|props
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
block|}
else|else
name|svn_skel__prepend_str
argument_list|(
literal|""
argument_list|,
name|prop_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* No old_props */
name|conflict_names
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
operator|(
name|apr_hash_t
operator|*
operator|)
name|conflicted_prop_names
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_skel__prepend_str
argument_list|(
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|,
name|conflict_names
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|svn_skel__prepend
argument_list|(
name|conflict_names
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
name|markers
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|marker_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|marker_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|marker_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|marker_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|marker_relpath
argument_list|,
name|markers
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
comment|/*else // ### set via svn_wc__conflict_create_markers     svn_skel__prepend(svn_skel__make_empty_list(result_pool), markers);*/
name|svn_skel__prepend
argument_list|(
name|markers
argument_list|,
name|prop_conflict
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|,
name|prop_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* And add it to the conflict skel */
name|svn_skel__prepend
argument_list|(
name|prop_conflict
argument_list|,
name|conflict_skel
operator|->
name|children
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A map for svn_wc_conflict_reason_t values. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|local_change_map
index|[]
init|=
block|{
block|{
literal|"edited"
block|,
name|svn_wc_conflict_reason_edited
block|}
block|,
block|{
literal|"obstructed"
block|,
name|svn_wc_conflict_reason_obstructed
block|}
block|,
block|{
literal|"deleted"
block|,
name|svn_wc_conflict_reason_deleted
block|}
block|,
block|{
literal|"missing"
block|,
name|svn_wc_conflict_reason_missing
block|}
block|,
block|{
literal|"unversioned"
block|,
name|svn_wc_conflict_reason_unversioned
block|}
block|,
block|{
literal|"added"
block|,
name|svn_wc_conflict_reason_added
block|}
block|,
block|{
literal|"replaced"
block|,
name|svn_wc_conflict_reason_replaced
block|}
block|,
block|{
literal|"moved-away"
block|,
name|svn_wc_conflict_reason_moved_away
block|}
block|,
block|{
literal|"moved-here"
block|,
name|svn_wc_conflict_reason_moved_here
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|incoming_change_map
index|[]
init|=
block|{
block|{
literal|"edited"
block|,
name|svn_wc_conflict_action_edit
block|}
block|,
block|{
literal|"added"
block|,
name|svn_wc_conflict_action_add
block|}
block|,
block|{
literal|"deleted"
block|,
name|svn_wc_conflict_action_delete
block|}
block|,
block|{
literal|"replaced"
block|,
name|svn_wc_conflict_action_replace
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_add_tree_conflict
parameter_list|(
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_wc_conflict_reason_t
name|local_change
parameter_list|,
name|svn_wc_conflict_action_t
name|incoming_change
parameter_list|,
specifier|const
name|char
modifier|*
name|move_src_op_root_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|tree_conflict
decl_stmt|;
name|svn_skel_t
modifier|*
name|markers
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|tree_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|tree_conflict
argument_list|)
expr_stmt|;
comment|/* ### Use proper error? */
name|SVN_ERR_ASSERT
argument_list|(
name|local_change
operator|==
name|svn_wc_conflict_reason_moved_away
operator|||
operator|!
name|move_src_op_root_abspath
argument_list|)
expr_stmt|;
comment|/* ### Use proper error? */
name|tree_conflict
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_change
operator|==
name|svn_wc_conflict_reason_moved_away
operator|&&
name|move_src_op_root_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_src_op_root_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|move_src_op_root_relpath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|move_src_op_root_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|move_src_op_root_relpath
argument_list|,
name|tree_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|svn_skel__prepend_str
argument_list|(
name|svn_token__to_word
argument_list|(
name|incoming_change_map
argument_list|,
name|incoming_change
argument_list|)
argument_list|,
name|tree_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|svn_token__to_word
argument_list|(
name|local_change_map
argument_list|,
name|local_change
argument_list|)
argument_list|,
name|tree_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Tree conflicts have no marker files */
name|markers
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|markers
argument_list|,
name|tree_conflict
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|,
name|tree_conflict
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* And add it to the conflict skel */
name|svn_skel__prepend
argument_list|(
name|tree_conflict
argument_list|,
name|conflict_skel
operator|->
name|children
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_skel_resolve
parameter_list|(
name|svn_boolean_t
modifier|*
name|completely_resolved
parameter_list|,
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_boolean_t
name|resolve_text
parameter_list|,
specifier|const
name|char
modifier|*
name|resolve_prop
parameter_list|,
name|svn_boolean_t
name|resolve_tree
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|op
decl_stmt|;
name|svn_skel_t
modifier|*
modifier|*
name|pconflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|op
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Not a completed conflict skel"
argument_list|)
argument_list|)
return|;
comment|/* We are going to drop items from a linked list. Instead of keeping      a pointer to the item we want to drop we store a pointer to the      pointer of what we may drop, to allow setting it to the next item. */
name|pconflict
operator|=
operator|&
operator|(
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|children
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|pconflict
condition|)
block|{
name|svn_skel_t
modifier|*
name|c
init|=
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|children
decl_stmt|;
if|if
condition|(
name|resolve_text
operator|&&
name|svn_skel__matches_atom
argument_list|(
name|c
argument_list|,
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|)
condition|)
block|{
comment|/* Remove the text conflict from the linked list */
operator|*
name|pconflict
operator|=
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|resolve_prop
operator|&&
name|svn_skel__matches_atom
argument_list|(
name|c
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
condition|)
block|{
name|svn_skel_t
modifier|*
modifier|*
name|ppropnames
init|=
operator|&
operator|(
name|c
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|)
decl_stmt|;
if|if
condition|(
name|resolve_prop
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|ppropnames
operator|=
name|NULL
expr_stmt|;
comment|/* remove all conflicted property names */
else|else
while|while
condition|(
operator|*
name|ppropnames
condition|)
block|{
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
operator|*
name|ppropnames
argument_list|,
name|resolve_prop
argument_list|)
condition|)
block|{
operator|*
name|ppropnames
operator|=
operator|(
operator|*
name|ppropnames
operator|)
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|ppropnames
operator|=
operator|&
operator|(
operator|(
operator|*
name|ppropnames
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
comment|/* If no conflicted property names left */
if|if
condition|(
operator|!
name|c
operator|->
name|next
operator|->
name|next
operator|->
name|children
condition|)
block|{
comment|/* Remove the propery conflict skel from the linked list */
operator|*
name|pconflict
operator|=
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|resolve_tree
operator|&&
name|svn_skel__matches_atom
argument_list|(
name|c
argument_list|,
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|)
condition|)
block|{
comment|/* Remove the tree conflict from the linked list */
operator|*
name|pconflict
operator|=
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
name|pconflict
operator|=
operator|&
operator|(
operator|(
operator|*
name|pconflict
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|completely_resolved
condition|)
block|{
comment|/* Nice, we can just call the complete function */
name|svn_boolean_t
name|complete_conflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_skel_is_complete
argument_list|(
operator|&
name|complete_conflict
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|completely_resolved
operator|=
operator|!
name|complete_conflict
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A map for svn_wc_operation_t values. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|operation_map
index|[]
init|=
block|{
block|{
literal|""
block|,
name|svn_wc_operation_none
block|}
block|,
block|{
name|SVN_WC__CONFLICT_OP_UPDATE
block|,
name|svn_wc_operation_update
block|}
block|,
block|{
name|SVN_WC__CONFLICT_OP_SWITCH
block|,
name|svn_wc_operation_switch
block|}
block|,
block|{
name|SVN_WC__CONFLICT_OP_MERGE
block|,
name|svn_wc_operation_merge
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_info
parameter_list|(
name|svn_wc_operation_t
modifier|*
name|operation
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
modifier|*
name|locations
parameter_list|,
name|svn_boolean_t
modifier|*
name|text_conflicted
parameter_list|,
name|svn_boolean_t
modifier|*
name|prop_conflicted
parameter_list|,
name|svn_boolean_t
modifier|*
name|tree_conflicted
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|op
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_operation
argument_list|(
operator|&
name|op
argument_list|,
name|conflict_skel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Not a completed conflict skel"
argument_list|)
argument_list|)
return|;
name|c
operator|=
name|op
operator|->
name|children
expr_stmt|;
if|if
condition|(
name|operation
condition|)
block|{
name|int
name|value
init|=
name|svn_token__from_mem
argument_list|(
name|operation_map
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|SVN_TOKEN_UNKNOWN
condition|)
operator|*
name|operation
operator|=
name|value
expr_stmt|;
else|else
operator|*
name|operation
operator|=
name|svn_wc_operation_none
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|c
operator|->
name|children
condition|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|loc_skel
decl_stmt|;
name|svn_wc_conflict_version_t
modifier|*
name|loc
decl_stmt|;
name|apr_array_header_t
modifier|*
name|locs
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|loc
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|loc_skel
operator|=
name|c
operator|->
name|children
init|;
name|loc_skel
condition|;
name|loc_skel
operator|=
name|loc_skel
operator|->
name|next
control|)
block|{
name|SVN_ERR
argument_list|(
name|conflict__read_location
argument_list|(
operator|&
name|loc
argument_list|,
name|loc_skel
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|locs
argument_list|,
name|svn_wc_conflict_version_t
operator|*
argument_list|)
operator|=
name|loc
expr_stmt|;
block|}
operator|*
name|locations
operator|=
name|locs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locations
condition|)
operator|*
name|locations
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|text_conflicted
condition|)
block|{
name|svn_skel_t
modifier|*
name|c_skel
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|c_skel
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|text_conflicted
operator|=
operator|(
name|c_skel
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|prop_conflicted
condition|)
block|{
name|svn_skel_t
modifier|*
name|c_skel
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|c_skel
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|prop_conflicted
operator|=
operator|(
name|c_skel
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tree_conflicted
condition|)
block|{
name|svn_skel_t
modifier|*
name|c_skel
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|c_skel
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tree_conflicted
operator|=
operator|(
name|c_skel
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_text_conflict
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|mine_abspath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|their_old_abspath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|their_abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|text_conflict
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|m
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|text_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TEXT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_conflict
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_MISSING
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict not set"
argument_list|)
argument_list|)
return|;
name|m
operator|=
name|text_conflict
operator|->
name|children
operator|->
name|next
operator|->
name|children
expr_stmt|;
if|if
condition|(
name|their_old_abspath
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|is_atom
condition|)
block|{
specifier|const
name|char
modifier|*
name|original_relpath
decl_stmt|;
name|original_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|m
operator|->
name|data
argument_list|,
name|m
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|their_old_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|original_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|their_old_abspath
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|mine_abspath
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|is_atom
condition|)
block|{
specifier|const
name|char
modifier|*
name|mine_relpath
decl_stmt|;
name|mine_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|m
operator|->
name|data
argument_list|,
name|m
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|mine_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|mine_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|mine_abspath
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|their_abspath
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|is_atom
condition|)
block|{
specifier|const
name|char
modifier|*
name|their_relpath
decl_stmt|;
name|their_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|m
operator|->
name|data
argument_list|,
name|m
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|their_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|their_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|their_abspath
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_prop_conflict
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|marker_abspath
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|mine_props
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|their_old_props
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|their_props
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|conflicted_prop_names
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|prop_conflict
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|prop_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_conflict
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_MISSING
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict not set"
argument_list|)
argument_list|)
return|;
name|c
operator|=
name|prop_conflict
operator|->
name|children
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Skip "prop" */
comment|/* Get marker file */
if|if
condition|(
name|marker_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|marker_relpath
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|children
operator|&&
name|c
operator|->
name|children
operator|->
name|is_atom
condition|)
block|{
name|marker_relpath
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|c
operator|->
name|children
operator|->
name|data
argument_list|,
name|c
operator|->
name|children
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|marker_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|marker_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|marker_abspath
operator|=
name|NULL
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Get conflicted properties */
if|if
condition|(
name|conflicted_prop_names
condition|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|name
decl_stmt|;
operator|*
name|conflicted_prop_names
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|name
operator|=
name|c
operator|->
name|children
init|;
name|name
condition|;
name|name
operator|=
name|name
operator|->
name|next
control|)
block|{
name|svn_hash_sets
argument_list|(
operator|*
name|conflicted_prop_names
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|name
operator|->
name|data
argument_list|,
name|name
operator|->
name|len
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Get original properties */
if|if
condition|(
name|their_old_props
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|is_atom
condition|)
operator|*
name|their_old_props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
name|their_old_props
argument_list|,
name|c
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Get mine properties */
if|if
condition|(
name|mine_props
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|is_atom
condition|)
operator|*
name|mine_props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
name|mine_props
argument_list|,
name|c
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Get their properties */
if|if
condition|(
name|their_props
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|is_atom
condition|)
operator|*
name|their_props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
name|their_props
argument_list|,
name|c
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_tree_conflict
parameter_list|(
name|svn_wc_conflict_reason_t
modifier|*
name|local_change
parameter_list|,
name|svn_wc_conflict_action_t
modifier|*
name|incoming_change
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|move_src_op_root_abspath
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|tree_conflict
decl_stmt|;
specifier|const
name|svn_skel_t
modifier|*
name|c
decl_stmt|;
name|svn_boolean_t
name|is_moved_away
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|tree_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_TREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_conflict
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_MISSING
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict not set"
argument_list|)
argument_list|)
return|;
name|c
operator|=
name|tree_conflict
operator|->
name|children
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Skip "tree" */
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* Skip markers */
block|{
name|int
name|value
init|=
name|svn_token__from_mem
argument_list|(
name|local_change_map
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|local_change
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|SVN_TOKEN_UNKNOWN
condition|)
operator|*
name|local_change
operator|=
name|value
expr_stmt|;
else|else
operator|*
name|local_change
operator|=
name|svn_wc_conflict_reason_edited
expr_stmt|;
block|}
name|is_moved_away
operator|=
operator|(
name|value
operator|==
name|svn_wc_conflict_reason_moved_away
operator|)
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|incoming_change
condition|)
block|{
name|int
name|value
init|=
name|svn_token__from_mem
argument_list|(
name|incoming_change_map
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|SVN_TOKEN_UNKNOWN
condition|)
operator|*
name|incoming_change
operator|=
name|value
expr_stmt|;
else|else
operator|*
name|incoming_change
operator|=
name|svn_wc_conflict_action_edit
expr_stmt|;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|move_src_op_root_abspath
condition|)
block|{
comment|/* Only set for update and switch tree conflicts */
if|if
condition|(
name|c
operator|&&
name|is_moved_away
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_src_op_root_relpath
init|=
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|c
operator|->
name|data
argument_list|,
name|c
operator|->
name|len
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
name|move_src_op_root_abspath
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|move_src_op_root_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|move_src_op_root_abspath
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_read_markers
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
modifier|*
name|markers
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|conflict
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|conflict_skel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk the conflicts */
for|for
control|(
name|conflict
operator|=
name|conflict_skel
operator|->
name|children
operator|->
name|next
operator|->
name|children
init|;
name|conflict
condition|;
name|conflict
operator|=
name|conflict
operator|->
name|next
control|)
block|{
specifier|const
name|svn_skel_t
modifier|*
name|marker
decl_stmt|;
comment|/* Get the list of markers stored per conflict */
for|for
control|(
name|marker
operator|=
name|conflict
operator|->
name|children
operator|->
name|next
operator|->
name|children
init|;
name|marker
condition|;
name|marker
operator|=
name|marker
operator|->
name|next
control|)
block|{
comment|/* Skip placeholders */
if|if
condition|(
operator|!
name|marker
operator|->
name|is_atom
condition|)
continue|continue;
if|if
condition|(
operator|!
name|list
condition|)
name|list
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_from_relpath
argument_list|(
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|list
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|marker
operator|->
name|data
argument_list|,
name|marker
operator|->
name|len
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|markers
operator|=
name|list
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* Helper for svn_wc__conflict_create_markers */
end_comment

begin_function
specifier|static
name|svn_skel_t
modifier|*
name|prop_conflict_skel_new
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|operation
init|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|result
init|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_skel__prepend
argument_list|(
name|operation
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Helper for prop_conflict_skel_add */
end_comment

begin_function
specifier|static
name|void
name|prepend_prop_value
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|value_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|void
modifier|*
name|dup
init|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|value
operator|->
name|len
argument_list|)
decl_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|dup
argument_list|,
name|value
operator|->
name|len
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|value_skel
argument_list|)
expr_stmt|;
block|}
name|svn_skel__prepend
argument_list|(
name|value_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for svn_wc__conflict_create_markers */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prop_conflict_skel_add
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original_value
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|mine_value
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|incoming_value
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|incoming_base_value
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|prop_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
comment|/* ### check that OPERATION has been filled in.  */
comment|/* See notes/wc-ng/conflict-storage  */
name|prepend_prop_value
argument_list|(
name|incoming_base_value
argument_list|,
name|prop_skel
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|prepend_prop_value
argument_list|(
name|incoming_value
argument_list|,
name|prop_skel
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|prepend_prop_value
argument_list|(
name|mine_value
argument_list|,
name|prop_skel
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|prepend_prop_value
argument_list|(
name|original_value
argument_list|,
name|prop_skel
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|prop_name
argument_list|)
argument_list|,
name|prop_skel
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|,
name|prop_skel
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Now we append PROP_SKEL to the end of the provided conflict SKEL.  */
name|svn_skel__append
argument_list|(
name|skel
argument_list|,
name|prop_skel
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_create_markers
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_conflicted
condition|)
block|{
specifier|const
name|char
modifier|*
name|marker_abspath
init|=
name|NULL
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|marker_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|marker_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|marker_relpath
decl_stmt|;
comment|/* Ok, currently we have to do a few things for property conflicts:          - Create a marker file          - Create a WQ item that sets the marker name          - Create a WQ item that fills the marker with the expected data           This can be simplified once we really store conflict_skel in wc.db */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|marker_dir
operator|=
name|local_abspath
expr_stmt|;
name|marker_name
operator|=
name|SVN_WC__THIS_DIR_PREJ
expr_stmt|;
block|}
else|else
name|svn_dirent_split
argument_list|(
operator|&
name|marker_dir
argument_list|,
operator|&
name|marker_name
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
operator|&
name|marker_abspath
argument_list|,
name|marker_dir
argument_list|,
name|marker_name
argument_list|,
name|SVN_WC__PROP_REJ_EXT
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_to_relpath
argument_list|(
operator|&
name|marker_relpath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|marker_abspath
argument_list|,
name|result_pool
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And store the marker in the skel */
block|{
name|svn_skel_t
modifier|*
name|prop_conflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict__get_conflict
argument_list|(
operator|&
name|prop_conflict
argument_list|,
name|conflict_skel
argument_list|,
name|SVN_WC__CONFLICT_KIND_PROP
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend_str
argument_list|(
name|marker_relpath
argument_list|,
name|prop_conflict
operator|->
name|children
operator|->
name|next
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Store the data in the WQ item in the same format used as 1.7.          Once we store the data in DB it is easier to just read it back          from the workqueue */
block|{
name|svn_skel_t
modifier|*
name|prop_data
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|mine_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_original_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
name|NULL
argument_list|,
operator|&
name|mine_props
argument_list|,
operator|&
name|their_original_props
argument_list|,
operator|&
name|their_props
argument_list|,
operator|&
name|conflicted_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_merge
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|old_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old_props
operator|=
name|their_original_props
expr_stmt|;
name|prop_data
operator|=
name|prop_conflict_skel_new
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|conflicted_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|prop_conflict_skel_add
argument_list|(
name|prop_data
argument_list|,
name|propname
argument_list|,
name|old_props
condition|?
name|svn_hash_gets
argument_list|(
name|old_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|mine_props
condition|?
name|svn_hash_gets
argument_list|(
name|mine_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|their_props
condition|?
name|svn_hash_gets
argument_list|(
name|their_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|their_original_props
condition|?
name|svn_hash_gets
argument_list|(
name|their_original_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_prej_install
argument_list|(
name|work_items
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|prop_data
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function for the three apply_* functions below, used when  * merging properties together.  *  * Given property PROPNAME on LOCAL_ABSPATH, and four possible property  * values, generate four tmpfiles and pass them to CONFLICT_FUNC callback.  * This gives the client an opportunity to interactively resolve the  * property conflict.  *  * BASE_VAL/WORKING_VAL represent the current state of the working  * copy, and INCOMING_OLD_VAL/INCOMING_NEW_VAL represents the incoming  * propchange.  Any of these values might be NULL, indicating either  * non-existence or intent-to-delete.  *  * If the callback isn't available, or if it responds with  * 'choose_postpone', then set *CONFLICT_REMAINS to TRUE and return.  *  * If the callback responds with a choice of 'base', 'theirs', 'mine',  * or 'merged', then install the proper value into ACTUAL_PROPS and  * set *CONFLICT_REMAINS to FALSE.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|generate_propconflict
parameter_list|(
name|svn_boolean_t
modifier|*
name|conflict_remains
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|base_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|working_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|incoming_old_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|incoming_new_val
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_conflict_result_t
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|svn_wc_conflict_description2_t
modifier|*
name|cdesc
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirpath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|new_value
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_kind
argument_list|(
operator|&
name|kind
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* allow_missing */
argument_list|,
name|FALSE
comment|/* show_deleted */
argument_list|,
name|FALSE
comment|/* show_hidden */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' was not found."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|cdesc
operator|=
name|svn_wc_conflict_description_create_prop2
argument_list|(
name|local_abspath
argument_list|,
operator|(
name|kind
operator|==
name|svn_node_dir
operator|)
condition|?
name|svn_node_dir
else|:
name|svn_node_file
argument_list|,
name|propname
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|cdesc
operator|->
name|src_left_version
operator|=
name|left_version
expr_stmt|;
name|cdesc
operator|->
name|src_right_version
operator|=
name|right_version
expr_stmt|;
comment|/* Create a tmpfile for each of the string_t's we've got.  */
if|if
condition|(
name|working_val
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|file_name
argument_list|,
name|dirpath
argument_list|,
name|working_val
operator|->
name|data
argument_list|,
name|working_val
operator|->
name|len
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|my_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|file_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|incoming_new_val
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|file_name
argument_list|,
name|dirpath
argument_list|,
name|incoming_new_val
operator|->
name|data
argument_list|,
name|incoming_new_val
operator|->
name|len
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|their_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|file_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|base_val
operator|&&
operator|!
name|incoming_old_val
condition|)
block|{
comment|/* If base and old are both NULL, then that's fine, we just let          base_file stay NULL as-is.  Both agents are attempting to add a          new property.  */
block|}
elseif|else
if|if
condition|(
operator|(
name|base_val
operator|&&
operator|!
name|incoming_old_val
operator|)
operator|||
operator|(
operator|!
name|base_val
operator|&&
name|incoming_old_val
operator|)
condition|)
block|{
comment|/* If only one of base and old are defined, then we've got a          situation where one agent is attempting to add the property          for the first time, and the other agent is changing a          property it thinks already exists.  In this case, we return          whichever older-value happens to be defined, so that the          conflict-callback can still attempt a 3-way merge. */
specifier|const
name|svn_string_t
modifier|*
name|conflict_base_val
init|=
name|base_val
condition|?
name|base_val
else|:
name|incoming_old_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|file_name
argument_list|,
name|dirpath
argument_list|,
name|conflict_base_val
operator|->
name|data
argument_list|,
name|conflict_base_val
operator|->
name|len
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|base_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|file_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* base and old are both non-NULL */
block|{
specifier|const
name|svn_string_t
modifier|*
name|conflict_base_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
if|if
condition|(
operator|!
name|svn_string_compare
argument_list|(
name|base_val
argument_list|,
name|incoming_old_val
argument_list|)
condition|)
block|{
comment|/* What happens if 'base' and 'old' don't match up?  In an              ideal situation, they would.  But if they don't, this is              a classic example of a patch 'hunk' failing to apply due              to a lack of context.  For example: imagine that the user              is busy changing the property from a value of "cat" to              "dog", but the incoming propchange wants to change the              same property value from "red" to "green".  Total context              mismatch.               HOWEVER: we can still pass one of the two base values as              'base_file' to the callback anyway.  It's still useful to              present the working and new values to the user to              compare. */
if|if
condition|(
name|working_val
operator|&&
name|svn_string_compare
argument_list|(
name|base_val
argument_list|,
name|working_val
argument_list|)
condition|)
name|conflict_base_val
operator|=
name|incoming_old_val
expr_stmt|;
else|else
name|conflict_base_val
operator|=
name|base_val
expr_stmt|;
block|}
else|else
block|{
name|conflict_base_val
operator|=
name|base_val
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|file_name
argument_list|,
name|dirpath
argument_list|,
name|conflict_base_val
operator|->
name|data
argument_list|,
name|conflict_base_val
operator|->
name|len
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|base_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|file_name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|working_val
operator|&&
name|incoming_new_val
condition|)
block|{
name|svn_stream_t
modifier|*
name|mergestream
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|options
init|=
name|svn_diff_file_options_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|mergestream
argument_list|,
operator|&
name|cdesc
operator|->
name|merged_file
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_mem_string_diff3
argument_list|(
operator|&
name|diff
argument_list|,
name|conflict_base_val
argument_list|,
name|working_val
argument_list|,
name|incoming_new_val
argument_list|,
name|options
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_mem_string_output_merge2
argument_list|(
name|mergestream
argument_list|,
name|diff
argument_list|,
name|conflict_base_val
argument_list|,
name|working_val
argument_list|,
name|incoming_new_val
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_diff_conflict_display_modified_latest
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|mergestream
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|incoming_old_val
operator|&&
name|incoming_new_val
condition|)
name|cdesc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_add
expr_stmt|;
elseif|else
if|if
condition|(
name|incoming_old_val
operator|&&
operator|!
name|incoming_new_val
condition|)
name|cdesc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_delete
expr_stmt|;
else|else
name|cdesc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_edit
expr_stmt|;
if|if
condition|(
name|base_val
operator|&&
operator|!
name|working_val
condition|)
name|cdesc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|base_val
operator|&&
name|working_val
condition|)
name|cdesc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_obstructed
expr_stmt|;
else|else
name|cdesc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_edited
expr_stmt|;
comment|/* Invoke the interactive conflict callback. */
block|{
name|SVN_ERR
argument_list|(
name|conflict_func
argument_list|(
operator|&
name|result
argument_list|,
name|cdesc
argument_list|,
name|conflict_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict callback violated API:"
literal|" returned no results"
argument_list|)
argument_list|)
return|;
block|}
switch|switch
condition|(
name|result
operator|->
name|choice
condition|)
block|{
default|default:
case|case
name|svn_wc_conflict_choose_postpone
case|:
block|{
operator|*
name|conflict_remains
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_mine_full
case|:
block|{
comment|/* No need to change actual_props; it already contains working_val */
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
name|new_value
operator|=
name|working_val
expr_stmt|;
break|break;
block|}
comment|/* I think _mine_full and _theirs_full are appropriate for prop          behavior as well as the text behavior.  There should even be          analogous behaviors for _mine and _theirs when those are          ready, namely: fold in all non-conflicting prop changes, and          then choose _mine side or _theirs side for conflicting ones. */
case|case
name|svn_wc_conflict_choose_theirs_full
case|:
block|{
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
name|new_value
operator|=
name|incoming_new_val
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_base
case|:
block|{
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
name|new_value
operator|=
name|base_val
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_merged
case|:
block|{
name|svn_stringbuf_t
modifier|*
name|merged_stringbuf
decl_stmt|;
if|if
condition|(
operator|!
name|cdesc
operator|->
name|merged_file
operator|&&
operator|!
name|result
operator|->
name|merged_file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict callback violated API:"
literal|" returned no merged file"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|merged_stringbuf
argument_list|,
name|result
operator|->
name|merged_file
condition|?
name|result
operator|->
name|merged_file
else|:
name|cdesc
operator|->
name|merged_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_value
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|merged_stringbuf
argument_list|)
expr_stmt|;
operator|*
name|conflict_remains
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|conflict_remains
condition|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* For now, just set the property values. This should really do some of the          more advanced things from svn_wc_prop_set() */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_set_props
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|props
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Resolve the text conflict on DB/LOCAL_ABSPATH in the manner specified  * by CHOICE.  *  * Set *WORK_ITEMS to new work items that will make the on-disk changes  * needed to complete the resolution (but not to mark it as resolved).  * Set *IS_RESOLVED to true if the conflicts are resolved; otherwise  * (which is only if CHOICE is 'postpone') to false.  *  * LEFT_ABSPATH, RIGHT_ABSPATH, and DETRANSLATED_TARGET are the  * input files to the 3-way merge that will be performed if CHOICE is  * 'theirs-conflict' or 'mine-conflict'.  LEFT_ABSPATH is also the file  * that will be used if CHOICE is 'base', and RIGHT_ABSPATH if CHOICE is  * 'theirs-full'.  MERGED_ABSPATH will be used if CHOICE is 'merged'.  *  * DETRANSLATED_TARGET is the detranslated version of 'mine' (see  * detranslate_wc_file() above).  MERGE_OPTIONS are passed to the  * diff3 implementation in case a 3-way merge has to be carried out.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|eval_text_conflict_func_result
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_resolved
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc_conflict_choice_t
name|choice
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|detranslated_target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|install_from_abspath
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|remove_source
init|=
name|FALSE
decl_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|choice
condition|)
block|{
comment|/* If the callback wants to use one of the fulltexts          to resolve the conflict, so be it.*/
case|case
name|svn_wc_conflict_choose_base
case|:
block|{
name|install_from_abspath
operator|=
name|left_abspath
expr_stmt|;
operator|*
name|is_resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_theirs_full
case|:
block|{
name|install_from_abspath
operator|=
name|right_abspath
expr_stmt|;
operator|*
name|is_resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_mine_full
case|:
block|{
name|install_from_abspath
operator|=
name|detranslated_target
expr_stmt|;
operator|*
name|is_resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_theirs_conflict
case|:
case|case
name|svn_wc_conflict_choose_mine_conflict
case|:
block|{
specifier|const
name|char
modifier|*
name|chosen_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_dir
decl_stmt|;
name|svn_stream_t
modifier|*
name|chosen_stream
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_diff_conflict_display_style_t
name|style
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|diff3_options
decl_stmt|;
name|diff3_options
operator|=
name|svn_diff_file_options_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_options
condition|)
name|SVN_ERR
argument_list|(
name|svn_diff_file_options_parse
argument_list|(
name|diff3_options
argument_list|,
name|merge_options
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|style
operator|=
name|choice
operator|==
name|svn_wc_conflict_choose_theirs_conflict
condition|?
name|svn_diff_conflict_display_latest
else|:
name|svn_diff_conflict_display_modified
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|temp_dir
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|chosen_stream
argument_list|,
operator|&
name|chosen_abspath
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff3_2
argument_list|(
operator|&
name|diff
argument_list|,
name|left_abspath
argument_list|,
name|detranslated_target
argument_list|,
name|right_abspath
argument_list|,
name|diff3_options
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_output_merge2
argument_list|(
name|chosen_stream
argument_list|,
name|diff
argument_list|,
name|left_abspath
argument_list|,
name|detranslated_target
argument_list|,
name|right_abspath
argument_list|,
comment|/* markers ignored */
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|style
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|chosen_stream
argument_list|)
argument_list|)
expr_stmt|;
name|install_from_abspath
operator|=
name|chosen_abspath
expr_stmt|;
name|remove_source
operator|=
name|TRUE
expr_stmt|;
operator|*
name|is_resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* For the case of 3-way file merging, we don't            really distinguish between these return values;            if the callback claims to have "generally            resolved" the situation, we still interpret            that as "OK, we'll assume the merged version is            good to use". */
case|case
name|svn_wc_conflict_choose_merged
case|:
block|{
name|install_from_abspath
operator|=
name|merged_abspath
expr_stmt|;
operator|*
name|is_resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
case|case
name|svn_wc_conflict_choose_postpone
case|:
default|default:
block|{
comment|/* Assume conflict remains. */
operator|*
name|is_resolved
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|install_from_abspath
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|{
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_install
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|install_from_abspath
argument_list|,
name|FALSE
comment|/* use_commit_times */
argument_list|,
name|FALSE
comment|/* record_fileinfo */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_sync_file_flags
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_source
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|install_from_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a new file in the same directory as LOCAL_ABSPATH, with the    same basename as LOCAL_ABSPATH, with a ".edited" extension, and set    *WORK_ITEM to a new work item that will copy and translate from the file    SOURCE_ABSPATH to that new file.  It will be translated from repository-    normal form to working-copy form according to the versioned properties    of LOCAL_ABSPATH that are current when the work item is executed.     DB should have a write lock for the directory containing SOURCE.     Allocate *WORK_ITEM in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|save_merge_result
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_item
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|source_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|edited_copy_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|dir_abspath
argument_list|,
operator|&
name|filename
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* ### Should use preserved-conflict-file-exts. */
comment|/* Create the .edited file within this file's DIR_ABSPATH  */
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
operator|&
name|edited_copy_abspath
argument_list|,
name|dir_abspath
argument_list|,
name|filename
argument_list|,
literal|".edited"
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_copy_translated
argument_list|(
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|source_abspath
argument_list|,
name|edited_copy_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Call the conflict resolver callback for a text conflict, and resolve  * the conflict if it tells us to do so.  *  * Assume that there is a text conflict on the path DB/LOCAL_ABSPATH.  *  * Call CONFLICT_FUNC with CONFLICT_BATON to find out whether and how  * it wants to resolve the conflict.  Pass it a conflict description  * containing OPERATION, LEFT/RIGHT_ABSPATH, LEFT/RIGHT_VERSION,  * RESULT_TARGET and DETRANSLATED_TARGET.  *  * If the callback returns a resolution other than 'postpone', then  * perform that requested resolution and prepare to mark the conflict  * as resolved.  *  * Return *WORK_ITEMS that will do the on-disk work required to complete  * the resolution (but not to mark the conflict as resolved), and set  * *WAS_RESOLVED to true, if it was resolved.  Set *WORK_ITEMS to NULL  * and *WAS_RESOLVED to FALSE otherwise.  *  * RESULT_TARGET is the path to the merged file produced by the internal  * or external 3-way merge, which may contain conflict markers, in  * repository normal form.  DETRANSLATED_TARGET is the 'mine' version of  * the file, also in RNF.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_text_conflict
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_boolean_t
modifier|*
name|was_resolved
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
specifier|const
name|char
modifier|*
name|left_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|right_abspath
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
specifier|const
name|char
modifier|*
name|result_target
parameter_list|,
specifier|const
name|char
modifier|*
name|detranslated_target
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_conflict_result_t
modifier|*
name|result
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|svn_wc_conflict_description2_t
modifier|*
name|cdesc
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
operator|*
name|was_resolved
operator|=
name|FALSE
expr_stmt|;
comment|/* Give the conflict resolution callback a chance to clean      up the conflicts before we mark the file 'conflicted' */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cdesc
operator|=
name|svn_wc_conflict_description_create_text2
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|is_binary
operator|=
name|FALSE
expr_stmt|;
name|cdesc
operator|->
name|mime_type
operator|=
name|svn_prop_get_value
argument_list|(
name|props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
expr_stmt|;
name|cdesc
operator|->
name|base_abspath
operator|=
name|left_abspath
expr_stmt|;
name|cdesc
operator|->
name|their_abspath
operator|=
name|right_abspath
expr_stmt|;
name|cdesc
operator|->
name|my_abspath
operator|=
name|detranslated_target
expr_stmt|;
name|cdesc
operator|->
name|merged_file
operator|=
name|result_target
expr_stmt|;
name|cdesc
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|cdesc
operator|->
name|src_left_version
operator|=
name|left_version
expr_stmt|;
name|cdesc
operator|->
name|src_right_version
operator|=
name|right_version
expr_stmt|;
name|SVN_ERR
argument_list|(
name|conflict_func
argument_list|(
operator|&
name|result
argument_list|,
name|cdesc
argument_list|,
name|conflict_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict callback violated API:"
literal|" returned no results"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|result
operator|->
name|save_merged
condition|)
block|{
name|SVN_ERR
argument_list|(
name|save_merge_result
argument_list|(
name|work_items
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
comment|/* Look for callback's own                                     merged-file first: */
name|result
operator|->
name|merged_file
condition|?
name|result
operator|->
name|merged_file
else|:
name|result_target
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|->
name|choice
operator|!=
name|svn_wc_conflict_choose_postpone
condition|)
block|{
name|SVN_ERR
argument_list|(
name|eval_text_conflict_func_result
argument_list|(
operator|&
name|work_item
argument_list|,
name|was_resolved
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|result
operator|->
name|choice
argument_list|,
name|merge_options
argument_list|,
name|left_abspath
argument_list|,
name|right_abspath
argument_list|,
comment|/* ### Sure this is an abspath? */
name|result
operator|->
name|merged_file
condition|?
name|result
operator|->
name|merged_file
else|:
name|result_target
argument_list|,
name|detranslated_target
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
operator|*
name|work_items
argument_list|,
name|work_item
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|was_resolved
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_tree_conflict_desc
parameter_list|(
name|svn_wc_conflict_description2_t
modifier|*
modifier|*
name|desc
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
name|svn_wc_conflict_reason_t
name|local_change
parameter_list|,
name|svn_wc_conflict_action_t
name|incoming_change
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|tc_kind
decl_stmt|;
if|if
condition|(
name|left_version
condition|)
name|tc_kind
operator|=
name|left_version
operator|->
name|node_kind
expr_stmt|;
elseif|else
if|if
condition|(
name|right_version
condition|)
name|tc_kind
operator|=
name|right_version
operator|->
name|node_kind
expr_stmt|;
else|else
name|tc_kind
operator|=
name|svn_node_file
expr_stmt|;
comment|/* Avoid assertion */
operator|*
name|desc
operator|=
name|svn_wc_conflict_description_create_tree2
argument_list|(
name|local_abspath
argument_list|,
name|tc_kind
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|reason
operator|=
name|local_change
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
operator|->
name|action
operator|=
name|incoming_change
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__conflict_invoke_resolver
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|resolver_func
parameter_list|,
name|void
modifier|*
name|resolver_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|text_conflicted
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|locations
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
operator|&
name|locations
argument_list|,
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|0
condition|)
name|left_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|0
argument_list|,
specifier|const
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|1
condition|)
name|right_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|1
argument_list|,
specifier|const
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Quick and dirty compatibility wrapper. My guess would be that most resolvers      would want to look at all properties at the same time.       ### svn currently only invokes this from the merge code to collect the list of      ### conflicted paths. Eventually this code will be the base for 'svn resolve'      ### and at that time the test coverage will improve      */
if|if
condition|(
name|prop_conflicted
condition|)
block|{
name|apr_hash_t
modifier|*
name|old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|mine_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_their_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|mark_resolved
init|=
name|TRUE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
name|NULL
argument_list|,
operator|&
name|mine_props
argument_list|,
operator|&
name|old_their_props
argument_list|,
operator|&
name|their_props
argument_list|,
operator|&
name|conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_merge
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|old_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old_props
operator|=
name|old_their_props
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|conflicted
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|conflict_remains
init|=
name|TRUE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|generate_propconflict
argument_list|(
operator|&
name|conflict_remains
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|propname
argument_list|,
name|old_props
condition|?
name|svn_hash_gets
argument_list|(
name|old_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|mine_props
condition|?
name|svn_hash_gets
argument_list|(
name|mine_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|old_their_props
condition|?
name|svn_hash_gets
argument_list|(
name|old_their_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|their_props
condition|?
name|svn_hash_gets
argument_list|(
name|their_props
argument_list|,
name|propname
argument_list|)
else|:
name|NULL
argument_list|,
name|resolver_func
argument_list|,
name|resolver_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_remains
condition|)
name|mark_resolved
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|mark_resolved
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__mark_resolved_prop_conflicts
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|text_conflicted
condition|)
block|{
specifier|const
name|char
modifier|*
name|mine_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|their_original_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|their_abspath
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_items
decl_stmt|;
name|svn_boolean_t
name|was_resolved
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_text_conflict
argument_list|(
operator|&
name|mine_abspath
argument_list|,
operator|&
name|their_original_abspath
argument_list|,
operator|&
name|their_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|resolve_text_conflict
argument_list|(
operator|&
name|work_items
argument_list|,
operator|&
name|was_resolved
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|merge_options
argument_list|,
name|operation
argument_list|,
name|their_original_abspath
argument_list|,
name|their_abspath
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|local_abspath
argument_list|,
name|mine_abspath
argument_list|,
name|resolver_func
argument_list|,
name|resolver_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_resolved
condition|)
block|{
if|if
condition|(
name|work_items
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_wq_add
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__mark_resolved_text_conflict
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tree_conflicted
condition|)
block|{
name|svn_wc_conflict_reason_t
name|local_change
decl_stmt|;
name|svn_wc_conflict_action_t
name|incoming_change
decl_stmt|;
name|svn_wc_conflict_result_t
modifier|*
name|result
decl_stmt|;
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|local_change
argument_list|,
operator|&
name|incoming_change
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|setup_tree_conflict_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|local_change
argument_list|,
name|incoming_change
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the resolver func about this conflict. */
name|SVN_ERR
argument_list|(
name|resolver_func
argument_list|(
operator|&
name|result
argument_list|,
name|desc
argument_list|,
name|resolver_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore the result. We cannot apply it here since this code runs        * during an update or merge operation. Tree conflicts are always        * postponed and resolved after the operation has completed. */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read all property conflicts contained in CONFLICT_SKEL into  * individual conflict descriptions, and append those descriptions  * to the CONFLICTS array.  *  * If NOT create_tempfiles, always create a legacy property conflict  * descriptor.  *  * Use NODE_KIND, OPERATION and shallow copies of LEFT_VERSION and  * RIGHT_VERSION, rather than reading them from CONFLICT_SKEL.  *  * Allocate results in RESULT_POOL. SCRATCH_POOL is used for temporary  * allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_prop_conflicts
parameter_list|(
name|apr_array_header_t
modifier|*
name|conflicts
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_skel_t
modifier|*
name|conflict_skel
parameter_list|,
name|svn_boolean_t
name|create_tempfiles
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
name|svn_wc_operation_t
name|operation
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prop_reject_file
decl_stmt|;
name|apr_hash_t
modifier|*
name|my_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted_props
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
operator|&
name|prop_reject_file
argument_list|,
operator|&
name|my_props
argument_list|,
operator|&
name|their_old_props
argument_list|,
operator|&
name|their_props
argument_list|,
operator|&
name|conflicted_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|create_tempfiles
operator|)
operator|||
name|apr_hash_count
argument_list|(
name|conflicted_props
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Legacy prop conflict with only a .reject file. */
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|svn_wc_conflict_description_create_prop2
argument_list|(
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
literal|""
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* ### This should be changed. The prej file should be stored        * ### separately from the other files. We need to rev the        * ### conflict description struct for this. */
name|desc
operator|->
name|their_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|prop_reject_file
argument_list|)
expr_stmt|;
name|desc
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|desc
operator|->
name|src_left_version
operator|=
name|left_version
expr_stmt|;
name|desc
operator|->
name|src_right_version
operator|=
name|right_version
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|conflicts
argument_list|,
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
operator|=
name|desc
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|conflicted_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|old_value
decl_stmt|;
name|svn_string_t
modifier|*
name|my_value
decl_stmt|;
name|svn_string_t
modifier|*
name|their_value
decl_stmt|;
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|desc
operator|=
name|svn_wc_conflict_description_create_prop2
argument_list|(
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
name|propname
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|desc
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|desc
operator|->
name|src_left_version
operator|=
name|left_version
expr_stmt|;
name|desc
operator|->
name|src_right_version
operator|=
name|right_version
expr_stmt|;
name|desc
operator|->
name|property_name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|my_value
operator|=
name|svn_hash_gets
argument_list|(
name|my_props
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|their_value
operator|=
name|svn_hash_gets
argument_list|(
name|their_props
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|old_value
operator|=
name|svn_hash_gets
argument_list|(
name|their_old_props
argument_list|,
name|propname
argument_list|)
expr_stmt|;
comment|/* Compute the incoming side of the conflict ('action'). */
if|if
condition|(
name|their_value
operator|==
name|NULL
condition|)
name|desc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_delete
expr_stmt|;
elseif|else
if|if
condition|(
name|old_value
operator|==
name|NULL
condition|)
name|desc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_add
expr_stmt|;
else|else
name|desc
operator|->
name|action
operator|=
name|svn_wc_conflict_action_edit
expr_stmt|;
comment|/* Compute the local side of the conflict ('reason'). */
if|if
condition|(
name|my_value
operator|==
name|NULL
condition|)
name|desc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
elseif|else
if|if
condition|(
name|old_value
operator|==
name|NULL
condition|)
name|desc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_added
expr_stmt|;
else|else
name|desc
operator|->
name|reason
operator|=
name|svn_wc_conflict_reason_edited
expr_stmt|;
comment|/* ### This should be changed. The prej file should be stored        * ### separately from the other files. We need to rev the        * ### conflict description struct for this. */
name|desc
operator|->
name|their_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|prop_reject_file
argument_list|)
expr_stmt|;
comment|/* ### This should be changed. The conflict description for        * ### props should contain these values as svn_string_t,        * ### rather than in temporary files. We need to rev the        * ### conflict description struct for this. */
if|if
condition|(
name|my_value
condition|)
block|{
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|desc
operator|->
name|my_abspath
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|my_value
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|s
argument_list|,
name|my_value
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|their_value
condition|)
block|{
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* ### Currently, their_abspath is used for the prop reject file.            * ### Put their value into merged instead...            * ### We need to rev the conflict description struct to fix this. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|desc
operator|->
name|merged_file
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|their_value
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|s
argument_list|,
name|their_value
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_value
condition|)
block|{
name|svn_stream_t
modifier|*
name|s
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|desc
operator|->
name|base_abspath
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|old_value
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|s
argument_list|,
name|old_value
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|conflicts
argument_list|,
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
operator|=
name|desc
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__read_conflicts
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
modifier|*
name|conflicts
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|create_tempfiles
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|conflict_skel
decl_stmt|;
name|apr_array_header_t
modifier|*
name|cflcts
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
name|svn_boolean_t
name|text_conflicted
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|locations
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left_version
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right_version
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflict_skel
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflict_skel
condition|)
block|{
comment|/* Some callers expect not NULL */
operator|*
name|conflicts
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
operator|&
name|locations
argument_list|,
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cflcts
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|0
condition|)
name|left_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|0
argument_list|,
specifier|const
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|locations
operator|&&
name|locations
operator|->
name|nelts
operator|>
literal|1
condition|)
name|right_version
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|locations
argument_list|,
literal|1
argument_list|,
specifier|const
name|svn_wc_conflict_version_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_conflicted
condition|)
block|{
name|svn_node_kind_t
name|node_kind
init|=
name|left_version
condition|?
name|left_version
operator|->
name|node_kind
else|:
name|svn_node_unknown
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_prop_conflicts
argument_list|(
name|cflcts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|create_tempfiles
argument_list|,
name|node_kind
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|text_conflicted
condition|)
block|{
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|svn_wc_conflict_description_create_text2
argument_list|(
name|local_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|desc
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|desc
operator|->
name|src_left_version
operator|=
name|left_version
expr_stmt|;
name|desc
operator|->
name|src_right_version
operator|=
name|right_version
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_text_conflict
argument_list|(
operator|&
name|desc
operator|->
name|my_abspath
argument_list|,
operator|&
name|desc
operator|->
name|base_abspath
argument_list|,
operator|&
name|desc
operator|->
name|their_abspath
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|merged_file
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|cflcts
argument_list|,
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
operator|=
name|desc
expr_stmt|;
block|}
if|if
condition|(
name|tree_conflicted
condition|)
block|{
name|svn_wc_conflict_reason_t
name|local_change
decl_stmt|;
name|svn_wc_conflict_action_t
name|incoming_change
decl_stmt|;
name|svn_wc_conflict_description2_t
modifier|*
name|desc
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|local_change
argument_list|,
operator|&
name|incoming_change
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_skel
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|setup_tree_conflict_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|operation
argument_list|,
name|left_version
argument_list|,
name|right_version
argument_list|,
name|local_change
argument_list|,
name|incoming_change
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|cflcts
argument_list|,
specifier|const
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
operator|=
name|desc
expr_stmt|;
block|}
operator|*
name|conflicts
operator|=
name|cflcts
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Resolving a conflict automatically ***/
end_comment

begin_comment
comment|/* Prepare to delete an artifact file at ARTIFACT_FILE_ABSPATH in the  * working copy at DB/WRI_ABSPATH.  *  * Set *WORK_ITEMS to a new work item that, when run, will delete the  * artifact file; or to NULL if there is no file to delete.  *  * Set *FILE_FOUND to TRUE if the artifact file is found on disk and its  * node kind is 'file'; otherwise do not change *FILE_FOUND.  FILE_FOUND  * may be NULL if not required.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_artifact_file_if_exists
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|work_items
parameter_list|,
name|svn_boolean_t
modifier|*
name|file_found
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|artifact_file_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|work_items
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|artifact_file_abspath
condition|)
block|{
name|svn_node_kind_t
name|node_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|artifact_file_abspath
argument_list|,
operator|&
name|node_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_remove
argument_list|(
name|work_items
argument_list|,
name|db
argument_list|,
name|wri_abspath
argument_list|,
name|artifact_file_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_found
condition|)
operator|*
name|file_found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve the text conflict found in DB/LOCAL_ABSPATH according  * to CONFLICT_CHOICE.  *  * It is not an error if there is no text conflict. If a text conflict  * existed and was resolved, set *DID_RESOLVE to TRUE, else set it to FALSE.  *  * Note: When there are no conflict markers to remove there is no existing  * text conflict; just a database containing old information, which we should  * remove to avoid checking all the time. Resolving a text conflict by  * removing all the marker files is a fully supported scenario since  * Subversion 1.0.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_text_conflict_on_node
parameter_list|(
name|svn_boolean_t
modifier|*
name|did_resolve
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_file
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|conflict_old
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_new
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict_working
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|auto_resolve_src
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflicts
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
name|svn_boolean_t
name|text_conflicted
decl_stmt|;
operator|*
name|did_resolve
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflicts
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
name|NULL
argument_list|,
operator|&
name|text_conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text_conflicted
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_text_conflict
argument_list|(
operator|&
name|conflict_working
argument_list|,
operator|&
name|conflict_old
argument_list|,
operator|&
name|conflict_new
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle automatic conflict resolution before the temporary files are    * deleted, if necessary. */
switch|switch
condition|(
name|conflict_choice
condition|)
block|{
case|case
name|svn_wc_conflict_choose_base
case|:
name|auto_resolve_src
operator|=
name|conflict_old
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_mine_full
case|:
name|auto_resolve_src
operator|=
name|conflict_working
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_theirs_full
case|:
name|auto_resolve_src
operator|=
name|conflict_new
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_merged
case|:
name|auto_resolve_src
operator|=
name|merged_file
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_theirs_conflict
case|:
case|case
name|svn_wc_conflict_choose_mine_conflict
case|:
block|{
if|if
condition|(
name|conflict_old
operator|&&
name|conflict_working
operator|&&
name|conflict_new
condition|)
block|{
specifier|const
name|char
modifier|*
name|temp_dir
decl_stmt|;
name|svn_stream_t
modifier|*
name|tmp_stream
init|=
name|NULL
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_diff_conflict_display_style_t
name|style
init|=
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_theirs_conflict
condition|?
name|svn_diff_conflict_display_latest
else|:
name|svn_diff_conflict_display_modified
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_temp_wcroot_tempdir
argument_list|(
operator|&
name|temp_dir
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|tmp_stream
argument_list|,
operator|&
name|auto_resolve_src
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff3_2
argument_list|(
operator|&
name|diff
argument_list|,
name|conflict_old
argument_list|,
name|conflict_working
argument_list|,
name|conflict_new
argument_list|,
name|svn_diff_file_options_create
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_output_merge2
argument_list|(
name|tmp_stream
argument_list|,
name|diff
argument_list|,
name|conflict_old
argument_list|,
name|conflict_working
argument_list|,
name|conflict_new
argument_list|,
comment|/* markers ignored */
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|style
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|tmp_stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|auto_resolve_src
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
default|default:
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid 'conflict_result' argument"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|auto_resolve_src
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_file_copy_translated
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|auto_resolve_src
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_build_sync_file_flags
argument_list|(
operator|&
name|work_item
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Legacy behavior: Only report text conflicts as resolved when at least      one conflict marker file exists.       If not the UI shows the conflict as already resolved      (and in this case we just remove the in-db conflict) */
name|SVN_ERR
argument_list|(
name|remove_artifact_file_if_exists
argument_list|(
operator|&
name|work_item
argument_list|,
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_old
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remove_artifact_file_if_exists
argument_list|(
operator|&
name|work_item
argument_list|,
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_new
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remove_artifact_file_if_exists
argument_list|(
operator|&
name|work_item
argument_list|,
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflict_working
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve the property conflicts found in DB/LOCAL_ABSPATH according  * to CONFLICT_CHOICE.  *  * It is not an error if there is no prop conflict. If a prop conflict  * existed and was resolved, set *DID_RESOLVE to TRUE, else set it to FALSE.  *  * Note: When there are no conflict markers on-disk to remove there is  * no existing text conflict (unless we are still in the process of  * creating the text conflict and we didn't register a marker file yet).  * In this case the database contains old information, which we should  * remove to avoid checking the next time. Resolving a property conflict  * by just removing the marker file is a fully supported scenario since  * Subversion 1.0.  *  * ### TODO [JAF] The '*_full' and '*_conflict' choices should differ.  *     In my opinion, 'mine_full'/'theirs_full' should select  *     the entire set of properties from 'mine' or 'theirs' respectively,  *     while 'mine_conflict'/'theirs_conflict' should select just the  *     properties that are in conflict.  Or, '_full' should select the  *     entire property whereas '_conflict' should do a text merge within  *     each property, selecting hunks.  Or all three kinds of behaviour  *     should be available (full set of props, full value of conflicting  *     props, or conflicting text hunks).  * ### BH: If we make *_full select the full set of properties, we should  *     check if we shouldn't make it also select the full text for files.  *  * ### TODO [JAF] All this complexity should not be down here in libsvn_wc  *     but in a layer above.  *  * ### TODO [JAF] Options for 'base' should be like options for 'mine' and  *     for 'theirs' -- choose full set of props, full value of conflicting  *     props, or conflicting text hunks.  *  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_prop_conflict_on_node
parameter_list|(
name|svn_boolean_t
modifier|*
name|did_resolve
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|conflicted_propname
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_file
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prop_reject_file
decl_stmt|;
name|apr_hash_t
modifier|*
name|mine_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|their_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|resolve_from
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|work_items
init|=
name|NULL
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflicts
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
name|svn_boolean_t
name|prop_conflicted
decl_stmt|;
operator|*
name|did_resolve
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflicts
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_conflicted
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_prop_conflict
argument_list|(
operator|&
name|prop_reject_file
argument_list|,
operator|&
name|mine_props
argument_list|,
operator|&
name|their_old_props
argument_list|,
operator|&
name|their_props
argument_list|,
operator|&
name|conflicted_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_merge
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_pristine_props
argument_list|(
operator|&
name|old_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old_props
operator|=
name|their_old_props
expr_stmt|;
comment|/* We currently handle *_conflict as *_full as this argument is currently      always applied for all conflicts on a node at the same time. Giving      an error would break some tests that assumed that this would just      resolve property conflicts to working.       An alternative way to handle these conflicts would be to just copy all      property state from mine/theirs on the _full option instead of just the      conflicted properties. In some ways this feels like a sensible option as      that would take both properties and text from mine/theirs, but when not      both properties and text are conflicted we would fail in doing so.    */
switch|switch
condition|(
name|conflict_choice
condition|)
block|{
case|case
name|svn_wc_conflict_choose_base
case|:
name|resolve_from
operator|=
name|their_old_props
condition|?
name|their_old_props
else|:
name|old_props
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_mine_full
case|:
case|case
name|svn_wc_conflict_choose_mine_conflict
case|:
name|resolve_from
operator|=
name|mine_props
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_theirs_full
case|:
case|case
name|svn_wc_conflict_choose_theirs_conflict
case|:
name|resolve_from
operator|=
name|their_props
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_choose_merged
case|:
if|if
condition|(
name|merged_file
operator|&&
name|conflicted_propname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|apr_hash_t
modifier|*
name|actual_props
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_string_t
modifier|*
name|merged_propval
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|actual_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|resolve_from
operator|=
name|actual_props
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|merged_file
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_string_from_stream
argument_list|(
operator|&
name|merged_propval
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|resolve_from
argument_list|,
name|conflicted_propname
argument_list|,
name|merged_propval
argument_list|)
expr_stmt|;
block|}
else|else
name|resolve_from
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid 'conflict_result' argument"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|conflicted_props
operator|&&
name|apr_hash_count
argument_list|(
name|conflicted_props
argument_list|)
operator|&&
name|resolve_from
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|actual_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_props
argument_list|(
operator|&
name|actual_props
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|conflicted_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|new_value
init|=
name|NULL
decl_stmt|;
name|new_value
operator|=
name|svn_hash_gets
argument_list|(
name|resolve_from
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|actual_props
argument_list|,
name|propname
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_set_props
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|actual_props
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Legacy behavior: Only report property conflicts as resolved when the      property reject file exists       If not the UI shows the conflict as already resolved      (and in this case we just remove the in-db conflict) */
block|{
name|svn_skel_t
modifier|*
name|work_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|remove_artifact_file_if_exists
argument_list|(
operator|&
name|work_item
argument_list|,
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|prop_reject_file
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|work_items
operator|=
name|svn_wc__wq_merge
argument_list|(
name|work_items
argument_list|,
name|work_item
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|work_items
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve the tree conflict found in DB/LOCAL_ABSPATH according to  * CONFLICT_CHOICE.  *  * It is not an error if there is no tree conflict. If a tree conflict  * existed and was resolved, set *DID_RESOLVE to TRUE, else set it to FALSE.  *  * It is not an error if there is no tree conflict.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_tree_conflict_on_node
parameter_list|(
name|svn_boolean_t
modifier|*
name|did_resolve
parameter_list|,
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_conflict_reason_t
name|reason
decl_stmt|;
name|svn_wc_conflict_action_t
name|action
decl_stmt|;
name|svn_skel_t
modifier|*
name|conflicts
decl_stmt|;
name|svn_wc_operation_t
name|operation
decl_stmt|;
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
operator|*
name|did_resolve
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_conflict
argument_list|(
operator|&
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conflicts
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_info
argument_list|(
operator|&
name|operation
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_conflicted
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc__conflict_read_tree_conflict
argument_list|(
operator|&
name|reason
argument_list|,
operator|&
name|action
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|conflicts
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|svn_wc_operation_update
operator|||
name|operation
operator|==
name|svn_wc_operation_switch
condition|)
block|{
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
operator|||
name|reason
operator|==
name|svn_wc_conflict_reason_replaced
condition|)
block|{
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_merged
condition|)
block|{
comment|/* Break moves for any children moved out of this directory,                * and leave this directory deleted. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_resolve_break_moved_away_children
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_mine_conflict
condition|)
block|{
comment|/* Raised moved-away conflicts on any children moved out of                * this directory, and leave this directory deleted.                * The newly conflicted moved-away children will be updated                * if they are resolved with 'mine_conflict' as well. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_resolve_delete_raise_moved_away
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Tree conflict can only be resolved to "
literal|"'working' or 'mine-conflict' state; "
literal|"'%s' not resolved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
operator|&&
name|action
operator|==
name|svn_wc_conflict_action_edit
condition|)
block|{
comment|/* After updates, we can resolve local moved-away            * vs. any incoming change, either by updating the            * moved-away node (mine-conflict) or by breaking the            * move (theirs-conflict). */
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_mine_conflict
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__db_update_moved_away_conflict_victim
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conflict_choice
operator|==
name|svn_wc_conflict_choose_merged
condition|)
block|{
comment|/* We must break the move if the user accepts the current                * working copy state instead of updating the move.                * Else the move would be left in an invalid state. */
comment|/* ### This breaks the move but leaves the conflict                  ### involving the move until                  ### svn_wc__db_op_mark_resolved. */
name|SVN_ERR
argument_list|(
name|svn_wc__db_resolve_break_moved_away
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|did_resolve
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Tree conflict can only be resolved to "
literal|"'working' or 'mine-conflict' state; "
literal|"'%s' not resolved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|did_resolve
operator|&&
name|conflict_choice
operator|!=
name|svn_wc_conflict_choose_merged
condition|)
block|{
comment|/* For other tree conflicts, there is no way to pick        * theirs-full or mine-full, etc. Throw an error if the        * user expects us to be smarter than we really are. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Tree conflict can only be "
literal|"resolved to 'working' state; "
literal|"'%s' not resolved"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__db_op_mark_resolved
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__wq_run
argument_list|(
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__mark_resolved_text_conflict
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|ignored_result
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|resolve_text_conflict_on_node
argument_list|(
operator|&
name|ignored_result
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|svn_wc_conflict_choose_merged
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__mark_resolved_prop_conflicts
parameter_list|(
name|svn_wc__db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|ignored_result
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|resolve_prop_conflict_on_node
argument_list|(
operator|&
name|ignored_result
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
literal|""
argument_list|,
name|svn_wc_conflict_choose_merged
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton for conflict_status_walker */
end_comment

begin_struct
struct|struct
name|conflict_status_walker_baton
block|{
name|svn_wc__db_t
modifier|*
name|db
decl_stmt|;
name|svn_boolean_t
name|resolve_text
decl_stmt|;
specifier|const
name|char
modifier|*
name|resolve_prop
decl_stmt|;
name|svn_boolean_t
name|resolve_tree
decl_stmt|;
name|svn_wc_conflict_choice_t
name|conflict_choice
decl_stmt|;
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
decl_stmt|;
name|void
modifier|*
name|conflict_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
name|svn_wc_notify_func2_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_wc_status4_t to walk all conflicts to resolve.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict_status_walker
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|conflict_status_walker_baton
modifier|*
name|cswb
init|=
name|baton
decl_stmt|;
name|svn_wc__db_t
modifier|*
name|db
init|=
name|cswb
operator|->
name|db
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|conflicts
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|resolved
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|status
operator|->
name|conflicted
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__read_conflicts
argument_list|(
operator|&
name|conflicts
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|conflicts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|cd
decl_stmt|;
name|svn_boolean_t
name|did_resolve
decl_stmt|;
name|svn_wc_conflict_choice_t
name|my_choice
init|=
name|cswb
operator|->
name|conflict_choice
decl_stmt|;
specifier|const
name|char
modifier|*
name|merged_file
init|=
name|NULL
decl_stmt|;
name|cd
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|conflicts
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_choice
operator|==
name|svn_wc_conflict_choose_unspecified
condition|)
block|{
name|svn_wc_conflict_result_t
modifier|*
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|cswb
operator|->
name|conflict_func
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No conflict-callback and no "
literal|"pre-defined conflict-choice provided"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|cswb
operator|->
name|conflict_func
argument_list|(
operator|&
name|result
argument_list|,
name|cd
argument_list|,
name|cswb
operator|->
name|conflict_baton
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|my_choice
operator|=
name|result
operator|->
name|choice
expr_stmt|;
name|merged_file
operator|=
name|result
operator|->
name|merged_file
expr_stmt|;
comment|/* ### Bug: ignores result->save_merged */
block|}
if|if
condition|(
name|my_choice
operator|==
name|svn_wc_conflict_choose_postpone
condition|)
continue|continue;
switch|switch
condition|(
name|cd
operator|->
name|kind
condition|)
block|{
case|case
name|svn_wc_conflict_kind_tree
case|:
if|if
condition|(
operator|!
name|cswb
operator|->
name|resolve_tree
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|resolve_tree_conflict_on_node
argument_list|(
operator|&
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|my_choice
argument_list|,
name|cswb
operator|->
name|notify_func
argument_list|,
name|cswb
operator|->
name|notify_baton
argument_list|,
name|cswb
operator|->
name|cancel_func
argument_list|,
name|cswb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_kind_text
case|:
if|if
condition|(
operator|!
name|cswb
operator|->
name|resolve_text
condition|)
break|break;
name|SVN_ERR
argument_list|(
name|resolve_text_conflict_on_node
argument_list|(
operator|&
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|my_choice
argument_list|,
name|merged_file
argument_list|,
name|cswb
operator|->
name|cancel_func
argument_list|,
name|cswb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_resolve
condition|)
name|resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_kind_property
case|:
if|if
condition|(
operator|!
name|cswb
operator|->
name|resolve_prop
condition|)
break|break;
if|if
condition|(
operator|*
name|cswb
operator|->
name|resolve_prop
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|cswb
operator|->
name|resolve_prop
argument_list|,
name|cd
operator|->
name|property_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
comment|/* This is not the property we want to resolve. */
block|}
name|SVN_ERR
argument_list|(
name|resolve_prop_conflict_on_node
argument_list|(
operator|&
name|did_resolve
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|cd
operator|->
name|property_name
argument_list|,
name|my_choice
argument_list|,
name|merged_file
argument_list|,
name|cswb
operator|->
name|cancel_func
argument_list|,
name|cswb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_resolve
condition|)
name|resolved
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
comment|/* We can't resolve other conflict types */
break|break;
block|}
block|}
comment|/* Notify */
if|if
condition|(
name|cswb
operator|->
name|notify_func
operator|&&
name|resolved
condition|)
name|cswb
operator|->
name|notify_func
argument_list|(
name|cswb
operator|->
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_resolved
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc__resolve_conflicts
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|resolve_text
parameter_list|,
specifier|const
name|char
modifier|*
name|resolve_prop
parameter_list|,
name|svn_boolean_t
name|resolve_tree
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
name|svn_wc_conflict_resolver_func2_t
name|conflict_func
parameter_list|,
name|void
modifier|*
name|conflict_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|conflicted
decl_stmt|;
name|struct
name|conflict_status_walker_baton
name|cswb
decl_stmt|;
comment|/* ### the underlying code does NOT support resolving individual      ### properties. bail out if the caller tries it.  */
if|if
condition|(
name|resolve_prop
operator|!=
name|NULL
operator|&&
operator|*
name|resolve_prop
operator|!=
literal|'\0'
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|U_
argument_list|(
literal|"Resolving a single property is not (yet) "
literal|"supported."
argument_list|)
argument_list|)
return|;
comment|/* ### Just a versioned check? */
comment|/* Conflicted is set to allow invoking on actual only nodes */
name|SVN_ERR
argument_list|(
name|svn_wc__db_read_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|conflicted
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
operator|->
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When the implementation still used the entry walker, depth      unknown was translated to infinity. */
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
name|depth
operator|=
name|svn_depth_empty
expr_stmt|;
elseif|else
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|cswb
operator|.
name|db
operator|=
name|wc_ctx
operator|->
name|db
expr_stmt|;
name|cswb
operator|.
name|resolve_text
operator|=
name|resolve_text
expr_stmt|;
name|cswb
operator|.
name|resolve_prop
operator|=
name|resolve_prop
expr_stmt|;
name|cswb
operator|.
name|resolve_tree
operator|=
name|resolve_tree
expr_stmt|;
name|cswb
operator|.
name|conflict_choice
operator|=
name|conflict_choice
expr_stmt|;
name|cswb
operator|.
name|conflict_func
operator|=
name|conflict_func
expr_stmt|;
name|cswb
operator|.
name|conflict_baton
operator|=
name|conflict_baton
expr_stmt|;
name|cswb
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|cswb
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|cswb
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|cswb
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_conflict_resolver_starting
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_walk_status
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|FALSE
comment|/* get_all */
argument_list|,
name|FALSE
comment|/* no_ignore */
argument_list|,
name|TRUE
comment|/* ignore_text_mods */
argument_list|,
name|NULL
comment|/* ignore_patterns */
argument_list|,
name|conflict_status_walker
argument_list|,
operator|&
name|cswb
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_conflict_resolver_done
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_wc_resolved_conflict5
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|resolve_text
parameter_list|,
specifier|const
name|char
modifier|*
name|resolve_prop
parameter_list|,
name|svn_boolean_t
name|resolve_tree
parameter_list|,
name|svn_wc_conflict_choice_t
name|conflict_choice
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__resolve_conflicts
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|resolve_text
argument_list|,
name|resolve_prop
argument_list|,
name|resolve_tree
argument_list|,
name|conflict_choice
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Constructor for the result-structure returned by conflict callbacks. */
end_comment

begin_function
name|svn_wc_conflict_result_t
modifier|*
name|svn_wc_create_conflict_result
parameter_list|(
name|svn_wc_conflict_choice_t
name|choice
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_conflict_result_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|choice
operator|=
name|choice
expr_stmt|;
name|result
operator|->
name|merged_file
operator|=
name|merged_file
expr_stmt|;
name|result
operator|->
name|save_merged
operator|=
name|FALSE
expr_stmt|;
comment|/* If we add more fields to svn_wc_conflict_result_t, add them here. */
return|return
name|result
return|;
block|}
end_function

end_unit

