begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * @copyright  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  * @endcopyright  *  * @file svn_utf_private.h  * @brief UTF validation and normalization routines  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_UTF_PRIVATE_H
end_ifndef

begin_define
define|#
directive|define
name|SVN_UTF_PRIVATE_H
end_define

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_string_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
comment|/* Return TRUE if the string SRC of length LEN is a valid UTF-8 encoding  * according to the rules laid down by the Unicode 4.0 standard, FALSE  * otherwise.  This function is faster than svn_utf__last_valid().  */
name|svn_boolean_t
name|svn_utf__is_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
function_decl|;
comment|/* As for svn_utf__is_valid but SRC is NULL terminated. */
name|svn_boolean_t
name|svn_utf__cstring_is_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|)
function_decl|;
comment|/* Return a pointer to the first character after the last valid UTF-8  * potentially multi-byte character in the string SRC of length LEN.  * Validity of bytes from SRC to SRC+LEN-1, inclusively, is checked.  * If SRC is a valid UTF-8, the return value will point to the byte SRC+LEN,  * otherwise it will point to the start of the first invalid character.  * In either case all the characters between SRC and the return pointer - 1,  * inclusively, are valid UTF-8.  *  * See also svn_utf__is_valid().  */
specifier|const
name|char
modifier|*
name|svn_utf__last_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
function_decl|;
comment|/* As for svn_utf__last_valid but uses a different implementation without    lookup tables.  It avoids the table memory use (about 400 bytes) but the    function is longer (about 200 bytes extra) and likely to be slower when    the string is valid.  If the string is invalid this function may be    faster since it returns immediately rather than continuing to the end of    the string.  The main reason this function exists is to test the table    driven implementation.  */
specifier|const
name|char
modifier|*
name|svn_utf__last_valid2
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
function_decl|;
comment|/* Copy LENGTH bytes of SRC, converting characters as follows:     - Pass characters from the ASCII subset to the result     - Strip all combining marks from the string     - Represent other valid Unicode chars as {U+XXXX}     - Replace invalid Unicode chars with {U?XXXX}     - Represent chars that are not valid UTF-8 as ?\XX     - Replace codes outside the Unicode range with a sequence of ?\XX     - Represent the null byte as \0    Allocate the result in POOL. */
specifier|const
name|char
modifier|*
name|svn_utf__fuzzy_escape
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_size_t
name|length
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|svn_utf__cstring_from_utf8_fuzzy
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|convert_from_utf8
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
comment|/* On Windows: Convert the UTF-8 string SRC to UTF-16.    If PREFIX is not NULL, prepend it to the converted result.    The result, if not empty, will be allocated in RESULT_POOL. */
name|svn_error_t
modifier|*
name|svn_utf__win32_utf8_to_utf16
parameter_list|(
specifier|const
name|WCHAR
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|WCHAR
modifier|*
name|prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
comment|/* On Windows: Convert the UTF-16 string SRC to UTF-8.    If PREFIX is not NULL, prepend it to the converted result.    The result, if not empty, will be allocated in RESULT_POOL. */
name|svn_error_t
modifier|*
name|svn_utf__win32_utf16_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|WCHAR
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* WIN32*/
comment|/* A constant used for many length parameters in the utf8proc wrappers  * to indicate that the length of a string is unknonw. */
define|#
directive|define
name|SVN_UTF__UNKNOWN_LENGTH
value|((apr_size_t) -1)
comment|/* Compare two UTF-8 strings, ignoring normalization, using buffers  * BUF1 and BUF2 for temporary storage. If either of LEN1 or LEN2 is  * SVN_UTF__UNKNOWN_LENGTH, assume the associated string is  * null-terminated; otherwise, consider the string only up to the  * given length.  *  * Return compare value in *RESULT.  */
name|svn_error_t
modifier|*
name|svn_utf__normcmp
parameter_list|(
name|int
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
name|apr_size_t
name|len1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|,
name|apr_size_t
name|len2
parameter_list|,
name|svn_membuf_t
modifier|*
name|buf1
parameter_list|,
name|svn_membuf_t
modifier|*
name|buf2
parameter_list|)
function_decl|;
comment|/* Normalize the UTF-8 string STR to form C, using BUF for temporary  * storage. If LEN is SVN_UTF__UNKNOWN_LENGTH, assume STR is  * null-terminated; otherwise, consider the string only up to the  * given length.  *  * Return the normalized string in *RESULT, which shares storage with  * BUF and is valid only until the next time BUF is modified.  *  * A returned error may indicate that STRING contains invalid UTF-8 or  * invalid Unicode codepoints.  */
name|svn_error_t
modifier|*
name|svn_utf__normalize
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_membuf_t
modifier|*
name|buf
parameter_list|)
function_decl|;
comment|/* Check if STRING is a valid, NFC-normalized UTF-8 string.  Note that  * a FALSE return value may indicate that STRING is not valid UTF-8 at  * all.  *  * Use SCRATCH_POOL for temporary allocations.  */
name|svn_boolean_t
name|svn_utf__is_normalized
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Encode an UCS-4 string to UTF-8, placing the result into BUFFER.  * While utf8proc does have a similar function, it does more checking  * and processing than we want here; this function does not attempt  * any normalizations but just encodes the individual code points.  * The encoded string will always be NUL-terminated.  *  * Return the length of the result (excluding the NUL terminator) in  * *result_length.  *  * A returned error indicates that a codepoint is invalid.  */
name|svn_error_t
modifier|*
name|svn_utf__encode_ucs4_string
parameter_list|(
name|svn_membuf_t
modifier|*
name|buffer
parameter_list|,
specifier|const
name|apr_int32_t
modifier|*
name|ucs4str
parameter_list|,
name|apr_size_t
name|length
parameter_list|,
name|apr_size_t
modifier|*
name|result_length
parameter_list|)
function_decl|;
comment|/* Pattern matching similar to the the SQLite LIKE and GLOB  * operators. PATTERN, KEY and ESCAPE must all point to UTF-8  * strings. Furthermore, ESCAPE, if provided, must be a character from  * the ASCII subset.  *  * If any of PATTERN_LEN, STRING_LEN or ESCAPE_LEN are  * SVN_UTF__UNKNOWN_LENGTH, assume the associated string is  * null-terminated; otherwise, consider the string only up to the  * given length.  *  * Use buffers PATTERN_BUF, STRING_BUF and TEMP_BUF for temporary storage.  *  * If SQL_LIKE is true, interpret PATTERN as a pattern used by the SQL  * LIKE operator and notice ESCAPE. Otherwise it's a Unix fileglob  * pattern, and ESCAPE must be NULL.  *  * Set *MATCH to the result of the comparison. */
name|svn_error_t
modifier|*
name|svn_utf__glob
parameter_list|(
name|svn_boolean_t
modifier|*
name|match
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|apr_size_t
name|pattern_len
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_size_t
name|string_len
parameter_list|,
specifier|const
name|char
modifier|*
name|escape
parameter_list|,
name|apr_size_t
name|escape_len
parameter_list|,
name|svn_boolean_t
name|sql_like
parameter_list|,
name|svn_membuf_t
modifier|*
name|pattern_buf
parameter_list|,
name|svn_membuf_t
modifier|*
name|string_buf
parameter_list|,
name|svn_membuf_t
modifier|*
name|temp_buf
parameter_list|)
function_decl|;
comment|/* Return the compiled version of the wrapped utf8proc library. */
specifier|const
name|char
modifier|*
name|svn_utf__utf8proc_compiled_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Return the runtime version of the wrapped utf8proc library. */
specifier|const
name|char
modifier|*
name|svn_utf__utf8proc_runtime_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Convert an UTF-16 (or UCS-2) string to UTF-8, returning the pointer  * in RESULT. If BIG_ENDIAN is set, then UTF16STR is big-endian;  * otherwise, it's little-endian.  *  * If UTF16LEN is SVN_UTF__UNKNOWN_LENGTH, then UTF16STR must be  * terminated with a zero; otherwise, it is the number of 16-bit codes  * to convert, and the source string may contain NUL values.  *  * Allocate RESULT in RESULT_POOL and use SCRATCH_POOL for  * intermediate allocation.  *  * This function combines UTF-16 surrogate pairs into single code  * points, but will leave single lead or trail surrogates unchanged.  */
name|svn_error_t
modifier|*
name|svn_utf__utf16_to_utf8
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|apr_uint16_t
modifier|*
name|utf16str
parameter_list|,
name|apr_size_t
name|utf16len
parameter_list|,
name|svn_boolean_t
name|big_endian
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* Convert an UTF-32 string to UTF-8, returning the pointer in  * RESULT. If BIG_ENDIAN is set, then UTF32STR is big-endian;  * otherwise, it's little-endian.  *  * If UTF32LEN is SVN_UTF__UNKNOWN_LENGTH, then UTF32STR must be  * terminated with a zero; otherwise, it is the number of 32-bit codes  * to convert, and the source string may contain NUL values.  *  * Allocate RESULT in RESULT_POOL and use SCRATCH_POOL for  * intermediate allocation.  */
name|svn_error_t
modifier|*
name|svn_utf__utf32_to_utf8
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|apr_int32_t
modifier|*
name|utf32str
parameter_list|,
name|apr_size_t
name|utf32len
parameter_list|,
name|svn_boolean_t
name|big_endian
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __cplusplus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_UTF_PRIVATE_H */
end_comment

end_unit

