begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * serf.c :  entry point for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dav_protocol.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Implements svn_ra__vtable_t.get_version(). */
end_comment

begin_function
specifier|static
specifier|const
name|svn_version_t
modifier|*
name|ra_serf_version
parameter_list|(
name|void
parameter_list|)
block|{
name|SVN_VERSION_BODY
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RA_SERF_DESCRIPTION
define|\
value|N_("Module for accessing a repository via WebDAV protocol using serf.")
end_define

begin_comment
comment|/* Implements svn_ra__vtable_t.get_description(). */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ra_serf_get_description
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|_
argument_list|(
name|RA_SERF_DESCRIPTION
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.get_schemes(). */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|ra_serf_get_schemes
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|serf_ssl
index|[]
init|=
block|{
literal|"http"
block|,
literal|"https"
block|,
name|NULL
block|}
decl_stmt|;
if|#
directive|if
literal|0
comment|/* ### Temporary: to shut up a warning. */
block|static const char *serf_no_ssl[] = { "http", NULL };
endif|#
directive|endif
comment|/* TODO: Runtime detection. */
return|return
name|serf_ssl
return|;
block|}
end_function

begin_comment
comment|/* Load the setting http-auth-types from the global or server specific    section, parse its value and set the types of authentication we should    accept from the server. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|load_http_auth_types
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_config_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|server_group
parameter_list|,
name|int
modifier|*
name|authn_types
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|http_auth_types
init|=
name|NULL
decl_stmt|;
operator|*
name|authn_types
operator|=
name|SERF_AUTHN_NONE
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|http_auth_types
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_AUTH_TYPES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_group
condition|)
block|{
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|http_auth_types
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_AUTH_TYPES
argument_list|,
name|http_auth_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|http_auth_types
condition|)
block|{
name|char
modifier|*
name|token
decl_stmt|;
name|char
modifier|*
name|auth_types_list
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|strlen
argument_list|(
name|http_auth_types
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|apr_collapse_spaces
argument_list|(
name|auth_types_list
argument_list|,
name|http_auth_types
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|";"
argument_list|,
operator|&
name|auth_types_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
literal|"basic"
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|authn_types
operator||=
name|SERF_AUTHN_BASIC
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
literal|"digest"
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|authn_types
operator||=
name|SERF_AUTHN_DIGEST
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
literal|"ntlm"
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|authn_types
operator||=
name|SERF_AUTHN_NTLM
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
literal|"negotiate"
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|authn_types
operator||=
name|SERF_AUTHN_NEGOTIATE
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid config: unknown %s "
literal|"'%s'"
argument_list|)
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_AUTH_TYPES
argument_list|,
name|token
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* Nothing specified by the user, so accept all types. */
operator|*
name|authn_types
operator|=
name|SERF_AUTHN_ALL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Default HTTP timeout (in seconds); overridden by the 'http-timeout'    runtime configuration variable. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_HTTP_TIMEOUT
value|600
end_define

begin_comment
comment|/* Private symbol for the 1.9-public SVN_CONFIG_OPTION_HTTP_CHUNKED_REQUESTS */
end_comment

begin_define
define|#
directive|define
name|OPTION_HTTP_CHUNKED_REQUESTS
value|"http-chunked-requests"
end_define

begin_function
specifier|static
name|svn_error_t
modifier|*
name|load_config
parameter_list|(
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|config_hash
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|config_client
decl_stmt|;
specifier|const
name|char
modifier|*
name|server_group
decl_stmt|;
specifier|const
name|char
modifier|*
name|proxy_host
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|port_str
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|timeout_str
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|exceptions
decl_stmt|;
name|apr_port_t
name|proxy_port
decl_stmt|;
name|svn_tristate_t
name|chunked_requests
decl_stmt|;
if|if
condition|(
name|config_hash
condition|)
block|{
name|config
operator|=
name|svn_hash_gets
argument_list|(
name|config_hash
argument_list|,
name|SVN_CONFIG_CATEGORY_SERVERS
argument_list|)
expr_stmt|;
name|config_client
operator|=
name|svn_hash_gets
argument_list|(
name|config_hash
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|config
operator|=
name|NULL
expr_stmt|;
name|config_client
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|using_compression
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_COMPRESSION
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|timeout_str
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_TIMEOUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
condition|)
block|{
if|if
condition|(
name|config_client
condition|)
block|{
name|svn_auth_set_parameter
argument_list|(
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_CONFIG_CATEGORY_CONFIG
argument_list|,
name|config_client
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config
condition|)
block|{
name|svn_auth_set_parameter
argument_list|(
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_CONFIG_CATEGORY_SERVERS
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Use the default proxy-specific settings if and only if      "http-proxy-exceptions" is not set to exclude this host. */
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|exceptions
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_EXCEPTIONS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_cstring_match_glob_list
argument_list|(
name|session
operator|->
name|session_url
operator|.
name|hostname
argument_list|,
name|svn_cstring_split
argument_list|(
name|exceptions
argument_list|,
literal|","
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
condition|)
block|{
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|proxy_host
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_HOST
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|port_str
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_PORT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|proxy_username
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_USERNAME
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|proxy_password
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_PASSWORD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Load the global ssl settings, if set. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|trust_default_ca
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_SSL_TRUST_DEFAULT_CA
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|ssl_authorities
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_SSL_AUTHORITY_FILES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If set, read the flag that tells us to do bulk updates or not. Defaults      to skelta updates. */
name|SVN_ERR
argument_list|(
name|svn_config_get_tristate
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|bulk_updates
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_BULK_UPDATES
argument_list|,
literal|"auto"
argument_list|,
name|svn_tristate_unknown
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load the maximum number of parallel session connections. */
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|max_connections
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS
argument_list|,
name|SVN_CONFIG_DEFAULT_OPTION_HTTP_MAX_CONNECTIONS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Should we use chunked transfer encoding. */
name|SVN_ERR
argument_list|(
name|svn_config_get_tristate
argument_list|(
name|config
argument_list|,
operator|&
name|chunked_requests
argument_list|,
name|SVN_CONFIG_SECTION_GLOBAL
argument_list|,
name|OPTION_HTTP_CHUNKED_REQUESTS
argument_list|,
literal|"auto"
argument_list|,
name|svn_tristate_unknown
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
condition|)
name|server_group
operator|=
name|svn_config_find_group
argument_list|(
name|config
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|hostname
argument_list|,
name|SVN_CONFIG_SECTION_GROUPS
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|server_group
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|server_group
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|using_compression
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_COMPRESSION
argument_list|,
name|session
operator|->
name|using_compression
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|timeout_str
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_TIMEOUT
argument_list|,
name|timeout_str
argument_list|)
expr_stmt|;
name|svn_auth_set_parameter
argument_list|(
name|session
operator|->
name|wc_callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_SERVER_GROUP
argument_list|,
name|server_group
argument_list|)
expr_stmt|;
comment|/* Load the group proxy server settings, overriding global          settings.  We intentionally ignore 'http-proxy-exceptions'          here because, well, if this site was an exception, why is          there a per-server proxy configuration for it?  */
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|proxy_host
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_HOST
argument_list|,
name|proxy_host
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|port_str
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_PORT
argument_list|,
name|port_str
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|proxy_username
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_USERNAME
argument_list|,
name|session
operator|->
name|proxy_username
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|proxy_password
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_PROXY_PASSWORD
argument_list|,
name|session
operator|->
name|proxy_password
argument_list|)
expr_stmt|;
comment|/* Load the group ssl settings. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|trust_default_ca
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_SSL_TRUST_DEFAULT_CA
argument_list|,
name|session
operator|->
name|trust_default_ca
argument_list|)
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|ssl_authorities
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_SSL_AUTHORITY_FILES
argument_list|,
name|session
operator|->
name|ssl_authorities
argument_list|)
expr_stmt|;
comment|/* Load the group bulk updates flag. */
name|SVN_ERR
argument_list|(
name|svn_config_get_tristate
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|bulk_updates
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_BULK_UPDATES
argument_list|,
literal|"auto"
argument_list|,
name|session
operator|->
name|bulk_updates
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load the maximum number of parallel session connections,          overriding global values. */
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|session
operator|->
name|max_connections
argument_list|,
name|server_group
argument_list|,
name|SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS
argument_list|,
name|session
operator|->
name|max_connections
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Should we use chunked transfer encoding. */
name|SVN_ERR
argument_list|(
name|svn_config_get_tristate
argument_list|(
name|config
argument_list|,
operator|&
name|chunked_requests
argument_list|,
name|server_group
argument_list|,
name|OPTION_HTTP_CHUNKED_REQUESTS
argument_list|,
literal|"auto"
argument_list|,
name|chunked_requests
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Don't allow the http-max-connections value to be larger than our      compiled-in limit, or to be too small to operate.  Broken      functionality and angry administrators are equally undesirable. */
if|if
condition|(
name|session
operator|->
name|max_connections
operator|>
name|SVN_RA_SERF__MAX_CONNECTIONS_LIMIT
condition|)
name|session
operator|->
name|max_connections
operator|=
name|SVN_RA_SERF__MAX_CONNECTIONS_LIMIT
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|max_connections
operator|<
literal|2
condition|)
name|session
operator|->
name|max_connections
operator|=
literal|2
expr_stmt|;
comment|/* Parse the connection timeout value, if any. */
name|session
operator|->
name|timeout
operator|=
name|apr_time_from_sec
argument_list|(
name|DEFAULT_HTTP_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout_str
condition|)
block|{
name|char
modifier|*
name|endstr
decl_stmt|;
specifier|const
name|long
name|int
name|timeout
init|=
name|strtol
argument_list|(
name|timeout_str
argument_list|,
operator|&
name|endstr
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|endstr
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid config: illegal character in "
literal|"timeout value"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid config: negative timeout value"
argument_list|)
argument_list|)
return|;
name|session
operator|->
name|timeout
operator|=
name|apr_time_from_sec
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|session
operator|->
name|timeout
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert the proxy port value, if any. */
if|if
condition|(
name|port_str
condition|)
block|{
name|char
modifier|*
name|endstr
decl_stmt|;
specifier|const
name|long
name|int
name|port
init|=
name|strtol
argument_list|(
name|port_str
argument_list|,
operator|&
name|endstr
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|endstr
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid URL: illegal character in proxy "
literal|"port number"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid URL: negative proxy port number"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|port
operator|>
literal|65535
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid URL: proxy port number greater "
literal|"than maximum TCP port number 65535"
argument_list|)
argument_list|)
return|;
name|proxy_port
operator|=
operator|(
name|apr_port_t
operator|)
name|port
expr_stmt|;
block|}
else|else
block|{
name|proxy_port
operator|=
literal|80
expr_stmt|;
block|}
if|if
condition|(
name|proxy_host
condition|)
block|{
name|apr_sockaddr_t
modifier|*
name|proxy_addr
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|apr_sockaddr_info_get
argument_list|(
operator|&
name|proxy_addr
argument_list|,
name|proxy_host
argument_list|,
name|APR_UNSPEC
argument_list|,
name|proxy_port
argument_list|,
literal|0
argument_list|,
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Could not resolve proxy server '%s'"
argument_list|)
argument_list|,
name|proxy_host
argument_list|)
return|;
block|}
name|session
operator|->
name|using_proxy
operator|=
name|TRUE
expr_stmt|;
name|serf_config_proxy
argument_list|(
name|session
operator|->
name|context
argument_list|,
name|proxy_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|session
operator|->
name|using_proxy
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Setup detect_chunking and using_chunked_requests based on    * the chunked_requests tristate */
if|if
condition|(
name|chunked_requests
operator|==
name|svn_tristate_unknown
condition|)
block|{
name|session
operator|->
name|detect_chunking
operator|=
name|TRUE
expr_stmt|;
name|session
operator|->
name|using_chunked_requests
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunked_requests
operator|==
name|svn_tristate_true
condition|)
block|{
name|session
operator|->
name|detect_chunking
operator|=
name|FALSE
expr_stmt|;
name|session
operator|->
name|using_chunked_requests
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
comment|/* chunked_requests == svn_tristate_false */
block|{
name|session
operator|->
name|detect_chunking
operator|=
name|FALSE
expr_stmt|;
name|session
operator|->
name|using_chunked_requests
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Setup authentication. */
name|SVN_ERR
argument_list|(
name|load_http_auth_types
argument_list|(
name|pool
argument_list|,
name|config
argument_list|,
name|server_group
argument_list|,
operator|&
name|session
operator|->
name|authn_types
argument_list|)
argument_list|)
expr_stmt|;
name|serf_config_authn_types
argument_list|(
name|session
operator|->
name|context
argument_list|,
name|session
operator|->
name|authn_types
argument_list|)
expr_stmt|;
name|serf_config_credentials_callback
argument_list|(
name|session
operator|->
name|context
argument_list|,
name|svn_ra_serf__credentials_callback
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DEFAULT_HTTP_TIMEOUT
end_undef

begin_function
specifier|static
name|void
name|svn_ra_serf__progress
parameter_list|(
name|void
modifier|*
name|progress_baton
parameter_list|,
name|apr_off_t
name|read
parameter_list|,
name|apr_off_t
name|written
parameter_list|)
block|{
specifier|const
name|svn_ra_serf__session_t
modifier|*
name|serf_sess
init|=
name|progress_baton
decl_stmt|;
if|if
condition|(
name|serf_sess
operator|->
name|progress_func
condition|)
block|{
name|serf_sess
operator|->
name|progress_func
argument_list|(
name|read
operator|+
name|written
argument_list|,
operator|-
literal|1
argument_list|,
name|serf_sess
operator|->
name|progress_baton
argument_list|,
name|serf_sess
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.open_session(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__open
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|corrected_url
parameter_list|,
specifier|const
name|char
modifier|*
name|session_URL
parameter_list|,
specifier|const
name|svn_ra_callbacks2_t
modifier|*
name|callbacks
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|serf_sess
decl_stmt|;
name|apr_uri_t
name|url
decl_stmt|;
specifier|const
name|char
modifier|*
name|client_string
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|corrected_url
condition|)
operator|*
name|corrected_url
operator|=
name|NULL
expr_stmt|;
name|serf_sess
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|serf_sess
argument_list|)
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|wc_callbacks
operator|=
name|callbacks
expr_stmt|;
name|serf_sess
operator|->
name|wc_callback_baton
operator|=
name|callback_baton
expr_stmt|;
name|serf_sess
operator|->
name|progress_func
operator|=
name|callbacks
operator|->
name|progress_func
expr_stmt|;
name|serf_sess
operator|->
name|progress_baton
operator|=
name|callbacks
operator|->
name|progress_baton
expr_stmt|;
name|serf_sess
operator|->
name|cancel_func
operator|=
name|callbacks
operator|->
name|cancel_func
expr_stmt|;
name|serf_sess
operator|->
name|cancel_baton
operator|=
name|callback_baton
expr_stmt|;
comment|/* todo: reuse serf context across sessions */
name|serf_sess
operator|->
name|context
operator|=
name|serf_context_create
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_create
argument_list|(
operator|&
name|serf_sess
operator|->
name|blncache
argument_list|,
name|serf_sess
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|,
name|session_URL
argument_list|,
operator|&
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Illegal URL '%s'"
argument_list|)
argument_list|,
name|session_URL
argument_list|)
return|;
block|}
comment|/* Depending the version of apr-util in use, for root paths url.path      will be NULL or "", where serf requires "/". */
if|if
condition|(
name|url
operator|.
name|path
operator|==
name|NULL
operator|||
name|url
operator|.
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|url
operator|.
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|url
operator|.
name|port
condition|)
block|{
name|url
operator|.
name|port
operator|=
name|apr_uri_port_of_scheme
argument_list|(
name|url
operator|.
name|scheme
argument_list|)
expr_stmt|;
block|}
name|serf_sess
operator|->
name|session_url
operator|=
name|url
expr_stmt|;
name|serf_sess
operator|->
name|session_url_str
operator|=
name|apr_pstrdup
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|,
name|session_URL
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|using_ssl
operator|=
operator|(
name|svn_cstring_casecmp
argument_list|(
name|url
operator|.
name|scheme
argument_list|,
literal|"https"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|serf_sess
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_unknown
expr_stmt|;
name|serf_sess
operator|->
name|capabilities
operator|=
name|apr_hash_make
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* We have to assume that the server only supports HTTP/1.0. Once it's clear      HTTP/1.1 is supported, we can upgrade. */
name|serf_sess
operator|->
name|http10
operator|=
name|TRUE
expr_stmt|;
comment|/* If we switch to HTTP/1.1, then we will use chunked requests. We may disable      this, if we find an intervening proxy does not support chunked requests.  */
name|serf_sess
operator|->
name|using_chunked_requests
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|load_config
argument_list|(
name|serf_sess
argument_list|,
name|config
argument_list|,
name|serf_sess
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|=
name|apr_pcalloc
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|bkt_alloc
operator|=
name|serf_bucket_allocator_create
argument_list|(
name|serf_sess
operator|->
name|pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|session
operator|=
name|serf_sess
expr_stmt|;
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|last_status_code
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* create the user agent string */
if|if
condition|(
name|callbacks
operator|->
name|get_client_string
condition|)
name|SVN_ERR
argument_list|(
name|callbacks
operator|->
name|get_client_string
argument_list|(
name|callback_baton
argument_list|,
operator|&
name|client_string
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_string
condition|)
name|serf_sess
operator|->
name|useragent
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|USER_AGENT
argument_list|,
literal|" "
argument_list|,
name|client_string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|serf_sess
operator|->
name|useragent
operator|=
name|USER_AGENT
expr_stmt|;
comment|/* go ahead and tell serf about the connection. */
name|status
operator|=
name|serf_connection_create2
argument_list|(
operator|&
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
operator|->
name|conn
argument_list|,
name|serf_sess
operator|->
name|context
argument_list|,
name|url
argument_list|,
name|svn_ra_serf__conn_setup
argument_list|,
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|svn_ra_serf__conn_closed
argument_list|,
name|serf_sess
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|serf_sess
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_ra_serf__wrap_err
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Set the progress callback. */
name|serf_context_set_progress_cb
argument_list|(
name|serf_sess
operator|->
name|context
argument_list|,
name|svn_ra_serf__progress
argument_list|,
name|serf_sess
argument_list|)
expr_stmt|;
name|serf_sess
operator|->
name|num_conns
operator|=
literal|1
expr_stmt|;
name|session
operator|->
name|priv
operator|=
name|serf_sess
expr_stmt|;
name|err
operator|=
name|svn_ra_serf__exchange_capabilities
argument_list|(
name|serf_sess
argument_list|,
name|corrected_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* serf should produce a usable error code instead of APR_EGENERAL */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|APR_EGENERAL
condition|)
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_REQUEST_FAILED
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Connection to '%s' failed"
argument_list|)
argument_list|,
name|session_URL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We have set up a useful connection (that doesn't indication a redirect).      If we've been told there is possibly a worrisome proxy in our path to the      server AND we switched to HTTP/1.1 (chunked requests), then probe for      problems in any proxy.  */
if|if
condition|(
operator|(
name|corrected_url
operator|==
name|NULL
operator|||
operator|*
name|corrected_url
operator|==
name|NULL
operator|)
operator|&&
name|serf_sess
operator|->
name|detect_chunking
operator|&&
operator|!
name|serf_sess
operator|->
name|http10
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_serf__probe_proxy
argument_list|(
name|serf_sess
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.reparent(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__reparent
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_uri_t
name|new_url
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* If it's the URL we already have, wave our hands and do nothing. */
if|if
condition|(
name|strcmp
argument_list|(
name|session
operator|->
name|session_url_str
argument_list|,
name|url
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|session
operator|->
name|repos_root_str
condition|)
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|session
operator|->
name|repos_root_str
argument_list|,
name|url
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"URL '%s' is not a child of the session's repository root "
literal|"URL '%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|session
operator|->
name|repos_root_str
argument_list|)
return|;
block|}
name|status
operator|=
name|apr_uri_parse
argument_list|(
name|pool
argument_list|,
name|url
argument_list|,
operator|&
name|new_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Illegal repository URL '%s'"
argument_list|)
argument_list|,
name|url
argument_list|)
return|;
block|}
comment|/* Depending the version of apr-util in use, for root paths url.path      will be NULL or "", where serf requires "/". */
comment|/* ### Maybe we should use a string buffer for these strings so we      ### don't allocate memory in the session on every reparent? */
if|if
condition|(
name|new_url
operator|.
name|path
operator|==
name|NULL
operator|||
name|new_url
operator|.
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|session
operator|->
name|session_url
operator|.
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|session
operator|->
name|pool
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|session
operator|->
name|session_url
operator|.
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|session
operator|->
name|pool
argument_list|,
name|new_url
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
name|session
operator|->
name|session_url_str
operator|=
name|apr_pstrdup
argument_list|(
name|session
operator|->
name|pool
argument_list|,
name|url
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.get_session_url(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__get_session_url
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
operator|*
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|session
operator|->
name|session_url_str
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.get_latest_revnum(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__get_latest_revnum
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
modifier|*
name|latest_revnum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__get_youngest_revnum
argument_list|(
name|latest_revnum
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.rev_proplist(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__rev_proplist
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|ret_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|char
modifier|*
name|propfind_path
decl_stmt|;
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
block|{
name|propfind_path
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s/%ld"
argument_list|,
name|session
operator|->
name|rev_stub
argument_list|,
name|rev
argument_list|)
expr_stmt|;
comment|/* svn_ra_serf__retrieve_props() wants to added the revision as          a Label to the PROPFIND, which isn't really necessary when          querying a rev-stub URI.  *Shrug*  Probably okay to leave the          Label, but whatever. */
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the VCC as the propfind target path. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|propfind_path
argument_list|,
name|session
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### fix: fetch hash of *just* the PATH@REV props. no nested hash.  */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__retrieve_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
argument_list|,
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|propfind_path
argument_list|,
name|rev
argument_list|,
literal|"0"
argument_list|,
name|all_props
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__select_revprops
argument_list|(
name|ret_props
argument_list|,
name|propfind_path
argument_list|,
name|rev
argument_list|,
name|props
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.rev_prop(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_string_t
modifier|*
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__rev_proplist
argument_list|(
name|session
argument_list|,
name|rev
argument_list|,
operator|&
name|props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_path_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|session_relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|desired_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|url
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
comment|/* If we have a relative path, append it. */
if|if
condition|(
name|session_relpath
condition|)
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|url
argument_list|,
name|session_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If we were given a specific revision, get a URL that refers to that      specific revision (rather than floating with HEAD).  */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|url
argument_list|,
name|NULL
comment|/* latest_revnum */
argument_list|,
name|session
argument_list|,
name|NULL
comment|/* conn */
argument_list|,
name|url
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* URL is stable, so we use SVN_INVALID_REVNUM since it is now irrelevant.      Or we started with SVN_INVALID_REVNUM and URL may be floating.  */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_node_props
argument_list|(
name|props
argument_list|,
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|url
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|desired_props
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.check_path(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__check_path
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|fetch_path_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
argument_list|,
name|rel_path
argument_list|,
name|revision
argument_list|,
name|check_path_props
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|kind
operator|=
name|svn_node_none
expr_stmt|;
block|}
else|else
block|{
comment|/* Any other error, raise to caller. */
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_resource_type
argument_list|(
name|kind
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|dirent_walker_baton_t
block|{
comment|/* Update the fields in this entry.  */
name|svn_dirent_t
modifier|*
name|entry
decl_stmt|;
name|svn_tristate_t
modifier|*
name|supports_deadprop_count
decl_stmt|;
comment|/* If allocations are necessary, then use this pool.  */
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dirent_walker
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|dirent_walker_baton_t
modifier|*
name|dwb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_CUSTOM
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwb
operator|->
name|entry
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_SVN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwb
operator|->
name|entry
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_DAV
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"deadprop-count"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|val
operator|->
name|data
condition|)
block|{
name|apr_int64_t
name|deadprop_count
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|deadprop_count
argument_list|,
name|val
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|dwb
operator|->
name|entry
operator|->
name|has_props
operator|=
name|deadprop_count
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|dwb
operator|->
name|supports_deadprop_count
condition|)
operator|*
name|dwb
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dwb
operator|->
name|supports_deadprop_count
condition|)
operator|*
name|dwb
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_DAV__VERSION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwb
operator|->
name|entry
operator|->
name|created_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|val
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"creator-displayname"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwb
operator|->
name|entry
operator|->
name|last_author
operator|=
name|val
operator|->
name|data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_DAV__CREATIONDATE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|dwb
operator|->
name|entry
operator|->
name|time
argument_list|,
name|val
operator|->
name|data
argument_list|,
name|dwb
operator|->
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"getcontentlength"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 'getcontentlength' property is empty for directories. */
if|if
condition|(
name|val
operator|->
name|len
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|dwb
operator|->
name|entry
operator|->
name|size
argument_list|,
name|val
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"resourcetype"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|val
operator|->
name|data
argument_list|,
literal|"collection"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwb
operator|->
name|entry
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
else|else
block|{
name|dwb
operator|->
name|entry
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|path_dirent_visitor_t
block|{
name|apr_hash_t
modifier|*
name|full_paths
decl_stmt|;
name|apr_hash_t
modifier|*
name|base_paths
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig_path
decl_stmt|;
name|svn_tristate_t
name|supports_deadprop_count
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|path_dirent_walker
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_ssize_t
name|path_len
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
name|apr_ssize_t
name|ns_len
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_ssize_t
name|name_len
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|path_dirent_visitor_t
modifier|*
name|dirents
init|=
name|baton
decl_stmt|;
name|struct
name|dirent_walker_baton_t
name|dwb
decl_stmt|;
name|svn_dirent_t
modifier|*
name|entry
decl_stmt|;
comment|/* Skip our original path. */
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
name|dirents
operator|->
name|orig_path
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
name|entry
operator|=
name|apr_hash_get
argument_list|(
name|dirents
operator|->
name|full_paths
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
name|entry
operator|=
name|svn_dirent_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|dirents
operator|->
name|full_paths
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|base_name
operator|=
name|svn_path_uri_decode
argument_list|(
name|svn_urlpath__basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|dirents
operator|->
name|base_paths
argument_list|,
name|base_name
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|dwb
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
name|dwb
operator|.
name|supports_deadprop_count
operator|=
operator|&
name|dirents
operator|->
name|supports_deadprop_count
expr_stmt|;
name|dwb
operator|.
name|result_pool
operator|=
name|dirents
operator|->
name|result_pool
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|dirent_walker
argument_list|(
operator|&
name|dwb
argument_list|,
name|ns
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|get_dirent_props
parameter_list|(
name|apr_uint32_t
name|dirent_fields
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__dav_props_t
modifier|*
name|prop
decl_stmt|;
name|apr_array_header_t
modifier|*
name|props
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|7
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_ra_serf__dav_props_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|session
operator|->
name|supports_deadprop_count
operator|!=
name|svn_tristate_false
operator|||
operator|!
operator|(
name|dirent_fields
operator|&
name|SVN_DIRENT_HAS_PROPS
operator|)
condition|)
block|{
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_KIND
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|namespace
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"resourcetype"
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_SIZE
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|namespace
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"getcontentlength"
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_HAS_PROPS
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|namespace
operator|=
name|SVN_DAV_PROP_NS_DAV
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"deadprop-count"
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_CREATED_REV
condition|)
block|{
name|svn_ra_serf__dav_props_t
modifier|*
name|p
init|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
decl_stmt|;
name|p
operator|->
name|namespace
operator|=
literal|"DAV:"
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|SVN_DAV__VERSION_NAME
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_TIME
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|namespace
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|SVN_DAV__CREATIONDATE
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_LAST_AUTHOR
condition|)
block|{
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|namespace
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"creator-displayname"
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We found an old subversion server that can't handle          the deadprop-count property in the way we expect.           The neon behavior is to retrieve all properties in this case */
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|namespace
operator|=
literal|"DAV:"
expr_stmt|;
name|prop
operator|->
name|name
operator|=
literal|"allprop"
expr_stmt|;
block|}
name|prop
operator|=
name|apr_array_push
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|prop
operator|->
name|namespace
operator|=
name|NULL
expr_stmt|;
name|prop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|svn_ra_serf__dav_props_t
operator|*
operator|)
name|props
operator|->
name|elts
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.stat(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__stat
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_dirent_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|struct
name|dirent_walker_baton_t
name|dwb
decl_stmt|;
name|svn_tristate_t
name|deadprop_count
init|=
name|svn_tristate_unknown
decl_stmt|;
name|err
operator|=
name|fetch_path_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
argument_list|,
name|rel_path
argument_list|,
name|revision
argument_list|,
name|get_dirent_props
argument_list|(
name|SVN_DIRENT_ALL
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|dirent
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|dwb
operator|.
name|entry
operator|=
name|svn_dirent_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|dwb
operator|.
name|supports_deadprop_count
operator|=
operator|&
name|deadprop_count
expr_stmt|;
name|dwb
operator|.
name|result_pool
operator|=
name|pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_node_props
argument_list|(
name|props
argument_list|,
name|dirent_walker
argument_list|,
operator|&
name|dwb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deadprop_count
operator|==
name|svn_tristate_false
operator|&&
name|session
operator|->
name|supports_deadprop_count
operator|==
name|svn_tristate_unknown
operator|&&
operator|!
name|dwb
operator|.
name|entry
operator|->
name|has_props
condition|)
block|{
comment|/* We have to requery as the server didn't give us the right          information */
name|session
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_false
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fetch_path_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
argument_list|,
name|rel_path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|get_dirent_props
argument_list|(
name|SVN_DIRENT_ALL
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_node_props
argument_list|(
name|props
argument_list|,
name|dirent_walker
argument_list|,
operator|&
name|dwb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deadprop_count
operator|!=
name|svn_tristate_unknown
condition|)
name|session
operator|->
name|supports_deadprop_count
operator|=
name|deadprop_count
expr_stmt|;
operator|*
name|dirent
operator|=
name|dwb
operator|.
name|entry
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Reads the 'resourcetype' property from the list PROPS and checks if the  * resource at PATH@REVISION really is a directory. Returns  * SVN_ERR_FS_NOT_DIRECTORY if not.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resource_is_directory
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_resource_type
argument_list|(
operator|&
name|kind
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get entries of non-directory"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra__vtable_t.get_dir(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__get_dir
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|dirents
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|ret_props
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_uint32_t
name|dirent_fields
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
comment|/* If we have a relative path, URI encode and append it. */
if|if
condition|(
name|rel_path
condition|)
block|{
name|path
operator|=
name|svn_path_url_add_component2
argument_list|(
name|path
argument_list|,
name|rel_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If the user specified a peg revision other than HEAD, we have to fetch      the baseline collection url for that revision. If not, we can use the      public url. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
operator|||
name|fetched_rev
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_stable_url
argument_list|(
operator|&
name|path
argument_list|,
name|fetched_rev
argument_list|,
name|session
argument_list|,
name|NULL
comment|/* conn */
argument_list|,
name|path
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* REVISION is always SVN_INVALID_REVNUM  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're asked for children, fetch them now. */
if|if
condition|(
name|dirents
condition|)
block|{
name|struct
name|path_dirent_visitor_t
name|dirent_walk
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|char
modifier|*
name|rtype
decl_stmt|;
comment|/* Always request node kind to check that path is really a        * directory.        */
name|dirent_fields
operator||=
name|SVN_DIRENT_KIND
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__retrieve_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
argument_list|,
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|"1"
argument_list|,
name|get_dirent_props
argument_list|(
name|dirent_fields
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if the path is really a directory. */
name|rtype
operator|=
name|svn_ra_serf__get_prop
argument_list|(
name|props
argument_list|,
name|path
argument_list|,
literal|"DAV:"
argument_list|,
literal|"resourcetype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"collection"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get entries of non-directory"
argument_list|)
argument_list|)
return|;
comment|/* We're going to create two hashes to help the walker along.        * We're going to return the 2nd one back to the caller as it        * will have the basenames it expects.        */
name|dirent_walk
operator|.
name|full_paths
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|dirent_walk
operator|.
name|base_paths
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|dirent_walk
operator|.
name|orig_path
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dirent_walk
operator|.
name|supports_deadprop_count
operator|=
name|svn_tristate_unknown
expr_stmt|;
name|dirent_walk
operator|.
name|result_pool
operator|=
name|pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_all_paths
argument_list|(
name|props
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|path_dirent_walker
argument_list|,
operator|&
name|dirent_walk
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_walk
operator|.
name|supports_deadprop_count
operator|==
name|svn_tristate_false
operator|&&
name|session
operator|->
name|supports_deadprop_count
operator|==
name|svn_tristate_unknown
operator|&&
name|dirent_fields
operator|&
name|SVN_DIRENT_HAS_PROPS
condition|)
block|{
comment|/* We have to requery as the server didn't give us the right              information */
name|session
operator|->
name|supports_deadprop_count
operator|=
name|svn_tristate_false
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__retrieve_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
argument_list|,
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|"1"
argument_list|,
name|get_dirent_props
argument_list|(
name|dirent_fields
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_hash_clear
argument_list|(
name|dirent_walk
operator|.
name|full_paths
argument_list|)
expr_stmt|;
name|apr_hash_clear
argument_list|(
name|dirent_walk
operator|.
name|base_paths
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_all_paths
argument_list|(
name|props
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|path_dirent_walker
argument_list|,
operator|&
name|dirent_walk
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|dirents
operator|=
name|dirent_walk
operator|.
name|base_paths
expr_stmt|;
if|if
condition|(
name|dirent_walk
operator|.
name|supports_deadprop_count
operator|!=
name|svn_tristate_unknown
condition|)
name|session
operator|->
name|supports_deadprop_count
operator|=
name|dirent_walk
operator|.
name|supports_deadprop_count
expr_stmt|;
block|}
comment|/* If we're asked for the directory properties, fetch them too. */
if|if
condition|(
name|ret_props
condition|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_node_props
argument_list|(
operator|&
name|props
argument_list|,
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|all_props
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if the path is really a directory. */
name|SVN_ERR
argument_list|(
name|resource_is_directory
argument_list|(
name|props
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### flatten_props() does not copy PROPVALUE, but fetch_node_props()          ### put them into POOL, so we're okay.  */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__flatten_props
argument_list|(
name|ret_props
argument_list|,
name|props
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_repos_root
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|repos_root_str
condition|)
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|url
operator|=
name|session
operator|->
name|repos_root_str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* TODO: to fetch the uuid from the repository, we need:    1. a path that exists in HEAD    2. a path that's readable     get_uuid handles the case where a path doesn't exist in HEAD and also the    case where the root of the repository is not readable.    However, it does not handle the case where we're fetching path not existing    in HEAD of a repository with unreadable root directory.     Implements svn_ra__vtable_t.get_uuid().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_serf__get_uuid
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|uuid
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|uuid
condition|)
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
comment|/* We should never get here if we have HTTP v2 support, because          any server with that support should be transmitting the          UUID in the initial OPTIONS response.  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're not interested in vcc_url and relative_url, but this call also          stores the repository's uuid in the session. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|uuid
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_RESPONSE_HEADER_BADNESS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The UUID property was not found on the "
literal|"resource or any of its parents"
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|*
name|uuid
operator|=
name|session
operator|->
name|uuid
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra__vtable_t
name|serf_vtable
init|=
block|{
name|ra_serf_version
block|,
name|ra_serf_get_description
block|,
name|ra_serf_get_schemes
block|,
name|svn_ra_serf__open
block|,
name|svn_ra_serf__reparent
block|,
name|svn_ra_serf__get_session_url
block|,
name|svn_ra_serf__get_latest_revnum
block|,
name|svn_ra_serf__get_dated_revision
block|,
name|svn_ra_serf__change_rev_prop
block|,
name|svn_ra_serf__rev_proplist
block|,
name|svn_ra_serf__rev_prop
block|,
name|svn_ra_serf__get_commit_editor
block|,
name|svn_ra_serf__get_file
block|,
name|svn_ra_serf__get_dir
block|,
name|svn_ra_serf__get_mergeinfo
block|,
name|svn_ra_serf__do_update
block|,
name|svn_ra_serf__do_switch
block|,
name|svn_ra_serf__do_status
block|,
name|svn_ra_serf__do_diff
block|,
name|svn_ra_serf__get_log
block|,
name|svn_ra_serf__check_path
block|,
name|svn_ra_serf__stat
block|,
name|svn_ra_serf__get_uuid
block|,
name|svn_ra_serf__get_repos_root
block|,
name|svn_ra_serf__get_locations
block|,
name|svn_ra_serf__get_location_segments
block|,
name|svn_ra_serf__get_file_revs
block|,
name|svn_ra_serf__lock
block|,
name|svn_ra_serf__unlock
block|,
name|svn_ra_serf__get_lock
block|,
name|svn_ra_serf__get_locks
block|,
name|svn_ra_serf__replay
block|,
name|svn_ra_serf__has_capability
block|,
name|svn_ra_serf__replay_range
block|,
name|svn_ra_serf__get_deleted_rev
block|,
name|svn_ra_serf__register_editor_shim_callbacks
block|,
name|svn_ra_serf__get_inherited_props
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__init
parameter_list|(
specifier|const
name|svn_version_t
modifier|*
name|loader_version
parameter_list|,
specifier|const
name|svn_ra__vtable_t
modifier|*
modifier|*
name|vtable
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|int
name|serf_major
decl_stmt|;
name|int
name|serf_minor
decl_stmt|;
name|int
name|serf_patch
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ver_check_list
argument_list|(
name|ra_serf_version
argument_list|()
argument_list|,
name|checklist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Simplified version check to make sure we can safely use the      VTABLE parameter. The RA loader does a more exhaustive check. */
if|if
condition|(
name|loader_version
operator|->
name|major
operator|!=
name|SVN_VER_MAJOR
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_VERSION_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported RA loader version (%d) for ra_serf"
argument_list|)
argument_list|,
name|loader_version
operator|->
name|major
argument_list|)
return|;
block|}
comment|/* Make sure that we have loaded a compatible library: the MAJOR must      match, and the minor must be at *least* what we compiled against.      The patch level is simply ignored.  */
name|serf_lib_version
argument_list|(
operator|&
name|serf_major
argument_list|,
operator|&
name|serf_minor
argument_list|,
operator|&
name|serf_patch
argument_list|)
expr_stmt|;
if|if
condition|(
name|serf_major
operator|!=
name|SERF_MAJOR_VERSION
operator|||
name|serf_minor
operator|<
name|SERF_MINOR_VERSION
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
comment|/* ### should return a unique error  */
name|SVN_ERR_VERSION_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"ra_serf was compiled for serf %d.%d.%d but loaded "
literal|"an incompatible %d.%d.%d library"
argument_list|)
argument_list|,
name|SERF_MAJOR_VERSION
argument_list|,
name|SERF_MINOR_VERSION
argument_list|,
name|SERF_PATCH_VERSION
argument_list|,
name|serf_major
argument_list|,
name|serf_minor
argument_list|,
name|serf_patch
argument_list|)
return|;
block|}
operator|*
name|vtable
operator|=
operator|&
name|serf_vtable
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compatibility wrapper for pre-1.2 subversions.  Needed? */
end_comment

begin_define
define|#
directive|define
name|NAME
value|"ra_serf"
end_define

begin_define
define|#
directive|define
name|DESCRIPTION
value|RA_SERF_DESCRIPTION
end_define

begin_define
define|#
directive|define
name|VTBL
value|serf_vtable
end_define

begin_define
define|#
directive|define
name|INITFUNC
value|svn_ra_serf__init
end_define

begin_define
define|#
directive|define
name|COMPAT_INITFUNC
value|svn_ra_serf_init
end_define

begin_include
include|#
directive|include
file|"../libsvn_ra/wrapper_template.h"
end_include

end_unit

