begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * property.c : property routines for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dav_protocol.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Our current parsing state we're in for the PROPFIND response. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|prop_state_e
block|{
name|INITIAL
init|=
literal|0
block|,
name|MULTISTATUS
block|,
name|RESPONSE
block|,
name|HREF
block|,
name|PROPSTAT
block|,
name|STATUS
block|,
name|PROP
block|,
name|PROPVAL
block|,
name|COLLECTION
block|,
name|HREF_VALUE
block|}
name|prop_state_e
typedef|;
end_typedef

begin_comment
comment|/*  * This structure represents a pending PROPFIND response.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|propfind_context_t
block|{
comment|/* pool to issue allocations from */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
comment|/* associated serf session */
name|svn_ra_serf__session_t
modifier|*
name|sess
decl_stmt|;
name|svn_ra_serf__connection_t
modifier|*
name|conn
decl_stmt|;
comment|/* the requested path */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* the requested version (number and string form) */
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
comment|/* the request depth */
specifier|const
name|char
modifier|*
name|depth
decl_stmt|;
comment|/* the list of requested properties */
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|find_props
decl_stmt|;
comment|/* hash table that will be updated with the properties    *    * This can be shared between multiple propfind_context_t    * structures    */
name|apr_hash_t
modifier|*
name|ret_props
decl_stmt|;
comment|/* hash table containing all the properties associated with the    * "current"<propstat> tag.  These will get copied into RET_PROPS    * if the status code similarly associated indicates that they are    * "good"; otherwise, they'll get discarded.    */
name|apr_hash_t
modifier|*
name|ps_props
decl_stmt|;
comment|/* If not-NULL, add us to this list when we're done. */
name|svn_ra_serf__list_t
modifier|*
modifier|*
name|done_list
decl_stmt|;
name|svn_ra_serf__list_t
name|done_item
decl_stmt|;
block|}
name|propfind_context_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|D_
value|"DAV:"
end_define

begin_define
define|#
directive|define
name|S_
value|SVN_XML_NAMESPACE
end_define

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_serf__xml_transition_t
name|propfind_ttable
index|[]
init|=
block|{
block|{
name|INITIAL
block|,
name|D_
block|,
literal|"multistatus"
block|,
name|MULTISTATUS
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|MULTISTATUS
block|,
name|D_
block|,
literal|"response"
block|,
name|RESPONSE
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|RESPONSE
block|,
name|D_
block|,
literal|"href"
block|,
name|HREF
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|RESPONSE
block|,
name|D_
block|,
literal|"propstat"
block|,
name|PROPSTAT
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROPSTAT
block|,
name|D_
block|,
literal|"status"
block|,
name|STATUS
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROPSTAT
block|,
name|D_
block|,
literal|"prop"
block|,
name|PROP
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|FALSE
block|}
block|,
block|{
name|PROP
block|,
literal|"*"
block|,
literal|"*"
block|,
name|PROPVAL
block|,
name|TRUE
block|,
block|{
literal|"?V:encoding"
block|,
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROPVAL
block|,
name|D_
block|,
literal|"collection"
block|,
name|COLLECTION
block|,
name|FALSE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
name|PROPVAL
block|,
name|D_
block|,
literal|"href"
block|,
name|HREF_VALUE
block|,
name|TRUE
block|,
block|{
name|NULL
block|}
block|,
name|TRUE
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the HTTP status code contained in STATUS_LINE, or 0 if    there's a problem parsing it. */
end_comment

begin_function
specifier|static
name|int
name|parse_status_code
parameter_list|(
specifier|const
name|char
modifier|*
name|status_line
parameter_list|)
block|{
comment|/* STATUS_LINE should be of form: "HTTP/1.1 200 OK" */
if|if
condition|(
name|status_line
index|[
literal|0
index|]
operator|==
literal|'H'
operator|&&
name|status_line
index|[
literal|1
index|]
operator|==
literal|'T'
operator|&&
name|status_line
index|[
literal|2
index|]
operator|==
literal|'T'
operator|&&
name|status_line
index|[
literal|3
index|]
operator|==
literal|'P'
operator|&&
name|status_line
index|[
literal|4
index|]
operator|==
literal|'/'
operator|&&
operator|(
name|status_line
index|[
literal|5
index|]
operator|>=
literal|'0'
operator|&&
name|status_line
index|[
literal|5
index|]
operator|<=
literal|'9'
operator|)
operator|&&
name|status_line
index|[
literal|6
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|status_line
index|[
literal|7
index|]
operator|>=
literal|'0'
operator|&&
name|status_line
index|[
literal|7
index|]
operator|<=
literal|'9'
operator|)
operator|&&
name|status_line
index|[
literal|8
index|]
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|reason
decl_stmt|;
return|return
name|apr_strtoi64
argument_list|(
name|status_line
operator|+
literal|8
argument_list|,
operator|&
name|reason
argument_list|,
literal|10
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__path_rev_walker_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_into_ret_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_ssize_t
name|path_len
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
name|apr_ssize_t
name|ns_len
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_ssize_t
name|name_len
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|svn_ra_serf__set_ver_prop
argument_list|(
name|ctx
operator|->
name|ret_props
argument_list|,
name|path
argument_list|,
name|ctx
operator|->
name|rev
argument_list|,
name|ns
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_opened_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|propfind_opened
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|entered_state
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|tag
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|entered_state
operator|==
name|PROPVAL
condition|)
block|{
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPVAL
argument_list|,
literal|"ns"
argument_list|,
name|tag
operator|->
name|namespace
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPVAL
argument_list|,
literal|"name"
argument_list|,
name|tag
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entered_state
operator|==
name|PROPSTAT
condition|)
block|{
name|ctx
operator|->
name|ps_props
operator|=
name|apr_hash_make
argument_list|(
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__xml_closed_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|propfind_closed
parameter_list|(
name|svn_ra_serf__xml_estate_t
modifier|*
name|xes
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|int
name|leaving_state
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|cdata
parameter_list|,
name|apr_hash_t
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|leaving_state
operator|==
name|MULTISTATUS
condition|)
block|{
comment|/* We've gathered all the data from the reponse. Add this item          onto the "done list". External callers will then know this          request has been completed (tho stray response bytes may still          arrive).  */
if|if
condition|(
name|ctx
operator|->
name|done_list
condition|)
block|{
name|ctx
operator|->
name|done_item
operator|.
name|data
operator|=
name|ctx
operator|->
name|handler
expr_stmt|;
name|ctx
operator|->
name|done_item
operator|.
name|next
operator|=
operator|*
name|ctx
operator|->
name|done_list
expr_stmt|;
operator|*
name|ctx
operator|->
name|done_list
operator|=
operator|&
name|ctx
operator|->
name|done_item
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|HREF
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|val_str
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ctx
operator|->
name|depth
argument_list|,
literal|"1"
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|cdata
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|path
operator|=
name|ctx
operator|->
name|path
expr_stmt|;
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|RESPONSE
argument_list|,
literal|"path"
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Copy the value into the right pool, then save the HREF.  */
name|val_str
operator|=
name|svn_string_dup
argument_list|(
name|cdata
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_ra_serf__set_ver_prop
argument_list|(
name|ctx
operator|->
name|ret_props
argument_list|,
name|path
argument_list|,
name|ctx
operator|->
name|rev
argument_list|,
name|D_
argument_list|,
literal|"href"
argument_list|,
name|val_str
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|COLLECTION
condition|)
block|{
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPVAL
argument_list|,
literal|"altvalue"
argument_list|,
literal|"collection"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|HREF_VALUE
condition|)
block|{
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPVAL
argument_list|,
literal|"altvalue"
argument_list|,
name|cdata
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|STATUS
condition|)
block|{
comment|/* Parse the status field, and remember if this is a property          that we wish to ignore.  (Typically, if it's not a 200, the          status will be 404 to indicate that a property we          specifically requested from the server doesn't exist.)  */
name|int
name|status
init|=
name|parse_status_code
argument_list|(
name|cdata
operator|->
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|200
condition|)
name|svn_ra_serf__xml_note
argument_list|(
name|xes
argument_list|,
name|PROPSTAT
argument_list|,
literal|"ignore-prop"
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leaving_state
operator|==
name|PROPVAL
condition|)
block|{
specifier|const
name|char
modifier|*
name|encoding
init|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"V:encoding"
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|val_str
decl_stmt|;
name|apr_hash_t
modifier|*
name|gathered
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|ns
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|altvalue
decl_stmt|;
if|if
condition|(
name|encoding
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"base64"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Got unrecognized encoding '%s'"
argument_list|)
argument_list|,
name|encoding
argument_list|)
return|;
comment|/* Decode into the right pool.  */
name|val_str
operator|=
name|svn_base64_decode_string
argument_list|(
name|cdata
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy into the right pool.  */
name|val_str
operator|=
name|svn_string_dup
argument_list|(
name|cdata
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* The current path sits on the RESPONSE state. Gather up all the          state from this PROPVAL to the (grandparent) RESPONSE state,          and grab the path from there.           Now, it would be nice if we could, at this point, know that          the status code for this property indicated a problem -- then          we could simply bail out here and ignore the property.          Sadly, though, we might get the status code *after* we get          the property value.  So we'll carry on with our processing          here, setting the property and value as expected.  Once we          know for sure the status code associate with the property,          we'll decide its fate.  */
name|gathered
operator|=
name|svn_ra_serf__xml_gather_since
argument_list|(
name|xes
argument_list|,
name|RESPONSE
argument_list|)
expr_stmt|;
comment|/* These will be dup'd into CTX->POOL, as necessary.  */
name|path
operator|=
name|svn_hash_gets
argument_list|(
name|gathered
argument_list|,
literal|"path"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
name|ctx
operator|->
name|path
expr_stmt|;
name|ns
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"ns"
argument_list|)
expr_stmt|;
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|pool
argument_list|,
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|altvalue
operator|=
name|svn_hash_gets
argument_list|(
name|attrs
argument_list|,
literal|"altvalue"
argument_list|)
expr_stmt|;
if|if
condition|(
name|altvalue
operator|!=
name|NULL
condition|)
name|val_str
operator|=
name|svn_string_create
argument_list|(
name|altvalue
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_ra_serf__set_ver_prop
argument_list|(
name|ctx
operator|->
name|ps_props
argument_list|,
name|path
argument_list|,
name|ctx
operator|->
name|rev
argument_list|,
name|ns
argument_list|,
name|name
argument_list|,
name|val_str
argument_list|,
name|ctx
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_hash_t
modifier|*
name|gathered
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|leaving_state
operator|==
name|PROPSTAT
argument_list|)
expr_stmt|;
name|gathered
operator|=
name|svn_ra_serf__xml_gather_since
argument_list|(
name|xes
argument_list|,
name|PROPSTAT
argument_list|)
expr_stmt|;
comment|/* If we've squirreled away a note that says we want to ignore          these properties, we'll do so.  Otherwise, we need to copy          them from the temporary hash into the ctx->ret_props hash. */
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|gathered
argument_list|,
literal|"ignore-prop"
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__walk_all_paths
argument_list|(
name|ctx
operator|->
name|ps_props
argument_list|,
name|ctx
operator|->
name|rev
argument_list|,
name|copy_into_ret_props
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|ps_props
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|svn_string_t
modifier|*
name|svn_ra_serf__get_ver_prop_string
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|ver_props
decl_stmt|,
modifier|*
name|path_props
decl_stmt|,
modifier|*
name|ns_props
decl_stmt|;
name|void
modifier|*
name|val
init|=
name|NULL
decl_stmt|;
name|ver_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
operator|&
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver_props
condition|)
block|{
name|path_props
operator|=
name|svn_hash_gets
argument_list|(
name|ver_props
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_props
condition|)
block|{
name|ns_props
operator|=
name|svn_hash_gets
argument_list|(
name|path_props
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_props
condition|)
block|{
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|ns_props
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_ra_serf__get_ver_prop
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|svn_ra_serf__get_ver_prop_string
argument_list|(
name|props
argument_list|,
name|path
argument_list|,
name|rev
argument_list|,
name|ns
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
return|return
name|val
operator|->
name|data
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|svn_string_t
modifier|*
name|svn_ra_serf__get_prop_string
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|svn_ra_serf__get_ver_prop_string
argument_list|(
name|props
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|ns
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_ra_serf__get_prop
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|svn_ra_serf__get_ver_prop
argument_list|(
name|props
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|ns
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|svn_ra_serf__set_ver_prop
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|ver_props
decl_stmt|,
modifier|*
name|path_props
decl_stmt|,
modifier|*
name|ns_props
decl_stmt|;
name|ver_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
operator|&
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ver_props
condition|)
block|{
name|ver_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|props
argument_list|,
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
operator|&
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|,
name|ver_props
argument_list|)
expr_stmt|;
block|}
name|path_props
operator|=
name|svn_hash_gets
argument_list|(
name|ver_props
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path_props
condition|)
block|{
name|path_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|ver_props
argument_list|,
name|path
argument_list|,
name|path_props
argument_list|)
expr_stmt|;
comment|/* todo: we know that we'll fail the next check, but fall through        * for now for simplicity's sake.        */
block|}
name|ns_props
operator|=
name|svn_hash_gets
argument_list|(
name|path_props
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_props
condition|)
block|{
name|ns_props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|ns
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|path_props
argument_list|,
name|ns
argument_list|,
name|ns_props
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|ns_props
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_ra_serf__set_prop
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__set_ver_prop
argument_list|(
name|props
argument_list|,
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|ns
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|setup_propfind_headers
parameter_list|(
name|serf_bucket_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|ctx
init|=
name|setup_baton
decl_stmt|;
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Depth"
argument_list|,
name|ctx
operator|->
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|label
condition|)
block|{
name|serf_bucket_headers_setn
argument_list|(
name|headers
argument_list|,
literal|"Label"
argument_list|,
name|ctx
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PROPFIND_HEADER
value|"<?xml version=\"1.0\" encoding=\"utf-8\"?><propfind xmlns=\"DAV:\">"
end_define

begin_define
define|#
directive|define
name|PROPFIND_TRAILER
value|"</propfind>"
end_define

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_propfind_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|bkt
parameter_list|,
name|void
modifier|*
name|setup_baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|ctx
init|=
name|setup_baton
decl_stmt|;
name|serf_bucket_t
modifier|*
name|body_bkt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|prop
decl_stmt|;
name|svn_boolean_t
name|requested_allprop
init|=
name|FALSE
decl_stmt|;
name|body_bkt
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|prop
operator|=
name|ctx
operator|->
name|find_props
expr_stmt|;
while|while
condition|(
name|prop
operator|&&
name|prop
operator|->
name|namespace
condition|)
block|{
comment|/* special case the allprop case. */
if|if
condition|(
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
literal|"allprop"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|requested_allprop
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*<*propname* xmlns="*propns*" /> */
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"<"
argument_list|,
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|" xmlns=\""
argument_list|,
sizeof|sizeof
argument_list|(
literal|" xmlns=\""
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING
argument_list|(
name|prop
operator|->
name|namespace
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"\"/>"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"\"/>"
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|prop
operator|++
expr_stmt|;
block|}
comment|/* If we're not doing an allprop, add<prop> tags. */
if|if
condition|(
operator|!
name|requested_allprop
condition|)
block|{
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"<prop>"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"<prop>"
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_prepend
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
name|PROPFIND_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
name|PROPFIND_HEADER
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_prepend
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|requested_allprop
condition|)
block|{
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
literal|"</prop>"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"</prop>"
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|SERF_BUCKET_SIMPLE_STRING_LEN
argument_list|(
name|PROPFIND_TRAILER
argument_list|,
sizeof|sizeof
argument_list|(
name|PROPFIND_TRAILER
argument_list|)
operator|-
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|serf_bucket_aggregate_append
argument_list|(
name|body_bkt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|bkt
operator|=
name|body_bkt
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__deliver_props
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
modifier|*
name|propfind_handler
parameter_list|,
name|apr_hash_t
modifier|*
name|ret_props
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|depth
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|find_props
parameter_list|,
name|svn_ra_serf__list_t
modifier|*
modifier|*
name|done_list
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|propfind_context_t
modifier|*
name|new_prop_ctx
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_ra_serf__xml_context_t
modifier|*
name|xmlctx
decl_stmt|;
name|new_prop_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_prop_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|new_prop_ctx
operator|->
name|pool
operator|=
name|apr_hash_pool_get
argument_list|(
name|ret_props
argument_list|)
expr_stmt|;
name|new_prop_ctx
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|new_prop_ctx
operator|->
name|find_props
operator|=
name|find_props
expr_stmt|;
name|new_prop_ctx
operator|->
name|ret_props
operator|=
name|ret_props
expr_stmt|;
name|new_prop_ctx
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|new_prop_ctx
operator|->
name|sess
operator|=
name|sess
expr_stmt|;
name|new_prop_ctx
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|new_prop_ctx
operator|->
name|rev
operator|=
name|rev
expr_stmt|;
name|new_prop_ctx
operator|->
name|done_list
operator|=
name|done_list
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
block|{
name|new_prop_ctx
operator|->
name|label
operator|=
name|apr_ltoa
argument_list|(
name|pool
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_prop_ctx
operator|->
name|label
operator|=
name|NULL
expr_stmt|;
block|}
name|xmlctx
operator|=
name|svn_ra_serf__xml_context_create
argument_list|(
name|propfind_ttable
argument_list|,
name|propfind_opened
argument_list|,
name|propfind_closed
argument_list|,
name|NULL
argument_list|,
name|new_prop_ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|=
name|svn_ra_serf__create_expat_handler
argument_list|(
name|xmlctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"PROPFIND"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_propfind_body
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/xml"
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|new_prop_ctx
expr_stmt|;
name|handler
operator|->
name|header_delegate
operator|=
name|setup_propfind_headers
expr_stmt|;
name|handler
operator|->
name|header_delegate_baton
operator|=
name|new_prop_ctx
expr_stmt|;
name|handler
operator|->
name|session
operator|=
name|new_prop_ctx
operator|->
name|sess
expr_stmt|;
name|handler
operator|->
name|conn
operator|=
name|new_prop_ctx
operator|->
name|conn
expr_stmt|;
name|new_prop_ctx
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
operator|*
name|propfind_handler
operator|=
name|handler
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * This helper function will block until the PROP_CTX indicates that is done  * or another error is returned.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__wait_for_props
parameter_list|(
name|svn_ra_serf__handler_t
modifier|*
name|handler
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|err
operator|=
name|svn_ra_serf__context_run_one
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err2
operator|=
name|svn_ra_serf__error_on_status
argument_list|(
name|handler
operator|->
name|sline
argument_list|,
name|handler
operator|->
name|path
argument_list|,
name|handler
operator|->
name|location
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err2
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is a blocking version of deliver_props.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__retrieve_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|results
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|sess
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|depth
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
operator|*
name|results
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__deliver_props
argument_list|(
operator|&
name|handler
argument_list|,
operator|*
name|results
argument_list|,
name|sess
argument_list|,
name|conn
argument_list|,
name|url
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|,
name|props
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__wait_for_props
argument_list|(
name|handler
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__fetch_node_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|results
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|svn_ra_serf__dav_props_t
modifier|*
name|which_props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|multiprops
decl_stmt|;
name|apr_hash_t
modifier|*
name|ver_props
decl_stmt|;
comment|/* Note: a couple extra hash tables and whatnot get into RESULT_POOL.      Not a big deal at this point. Theoretically, we could fetch all      props into SCRATCH_POOL, then copy just the REVISION/URL props      into RESULT_POOL. Too much work for too little gain...  */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__retrieve_props
argument_list|(
operator|&
name|multiprops
argument_list|,
name|conn
operator|->
name|session
argument_list|,
name|conn
argument_list|,
name|url
argument_list|,
name|revision
argument_list|,
literal|"0"
argument_list|,
name|which_props
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ver_props
operator|=
name|apr_hash_get
argument_list|(
name|multiprops
argument_list|,
operator|&
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver_props
operator|!=
name|NULL
condition|)
block|{
operator|*
name|results
operator|=
name|svn_hash_gets
argument_list|(
name|ver_props
argument_list|,
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|results
operator|!=
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_PROPS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include "
literal|"the requested properties"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__walk_node_props
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_ra_serf__walker_visitor_t
name|walker
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|ns_hi
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|ns_hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|props
argument_list|)
init|;
name|ns_hi
condition|;
name|ns_hi
operator|=
name|apr_hash_next
argument_list|(
name|ns_hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|ns_val
decl_stmt|;
specifier|const
name|void
modifier|*
name|ns_name
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|name_hi
decl_stmt|;
comment|/* NOTE: We do not clear ITERPOOL in this loop. Generally, there are            very few namespaces, so this loop will not have many iterations.            Instead, ITERPOOL is used for the inner loop.  */
name|apr_hash_this
argument_list|(
name|ns_hi
argument_list|,
operator|&
name|ns_name
argument_list|,
name|NULL
argument_list|,
operator|&
name|ns_val
argument_list|)
expr_stmt|;
for|for
control|(
name|name_hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|ns_val
argument_list|)
init|;
name|name_hi
condition|;
name|name_hi
operator|=
name|apr_hash_next
argument_list|(
name|name_hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|prop_val
decl_stmt|;
specifier|const
name|void
modifier|*
name|prop_name
decl_stmt|;
comment|/* See note above, regarding clearing of this pool.  */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|name_hi
argument_list|,
operator|&
name|prop_name
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_val
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|walker
argument_list|(
name|baton
argument_list|,
name|ns_name
argument_list|,
name|prop_name
argument_list|,
name|prop_val
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__walk_all_props
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_ra_serf__walker_visitor_t
name|walker
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|ver_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|path_props
decl_stmt|;
name|ver_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
operator|&
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ver_props
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|path_props
operator|=
name|svn_hash_gets
argument_list|(
name|ver_props
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path_props
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__walk_node_props
argument_list|(
name|path_props
argument_list|,
name|walker
argument_list|,
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__walk_all_paths
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_ra_serf__path_rev_walker_t
name|walker
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|path_hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|ver_props
decl_stmt|;
name|ver_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
operator|&
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ver_props
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
for|for
control|(
name|path_hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|ver_props
argument_list|)
init|;
name|path_hi
condition|;
name|path_hi
operator|=
name|apr_hash_next
argument_list|(
name|path_hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|path_props
decl_stmt|;
specifier|const
name|void
modifier|*
name|path_name
decl_stmt|;
name|apr_ssize_t
name|path_len
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|ns_hi
decl_stmt|;
name|apr_hash_this
argument_list|(
name|path_hi
argument_list|,
operator|&
name|path_name
argument_list|,
operator|&
name|path_len
argument_list|,
operator|&
name|path_props
argument_list|)
expr_stmt|;
for|for
control|(
name|ns_hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_props
argument_list|)
init|;
name|ns_hi
condition|;
name|ns_hi
operator|=
name|apr_hash_next
argument_list|(
name|ns_hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|ns_val
decl_stmt|;
specifier|const
name|void
modifier|*
name|ns_name
decl_stmt|;
name|apr_ssize_t
name|ns_len
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|name_hi
decl_stmt|;
name|apr_hash_this
argument_list|(
name|ns_hi
argument_list|,
operator|&
name|ns_name
argument_list|,
operator|&
name|ns_len
argument_list|,
operator|&
name|ns_val
argument_list|)
expr_stmt|;
for|for
control|(
name|name_hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|ns_val
argument_list|)
init|;
name|name_hi
condition|;
name|name_hi
operator|=
name|apr_hash_next
argument_list|(
name|name_hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|prop_val
decl_stmt|;
specifier|const
name|void
modifier|*
name|prop_name
decl_stmt|;
name|apr_ssize_t
name|prop_len
decl_stmt|;
name|apr_hash_this
argument_list|(
name|name_hi
argument_list|,
operator|&
name|prop_name
argument_list|,
operator|&
name|prop_len
argument_list|,
operator|&
name|prop_val
argument_list|)
expr_stmt|;
comment|/* use a subpool? */
name|SVN_ERR
argument_list|(
name|walker
argument_list|(
name|baton
argument_list|,
name|path_name
argument_list|,
name|path_len
argument_list|,
name|ns_name
argument_list|,
name|ns_len
argument_list|,
name|prop_name
argument_list|,
name|prop_len
argument_list|,
name|prop_val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_ra_serf__svnname_from_wirename
parameter_list|(
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ns
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_CUSTOM
argument_list|)
operator|==
literal|0
condition|)
return|return
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_SVN
argument_list|)
operator|==
literal|0
condition|)
return|return
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_PROP_PREFIX
argument_list|)
operator|==
literal|0
condition|)
return|return
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_DAV__VERSION_NAME
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_COMMITTED_REV
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_DAV__CREATIONDATE
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_COMMITTED_DATE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"creator-displayname"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_LAST_AUTHOR
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"repository-uuid"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_UUID
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"lock-token"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_PROP_ENTRY_LOCK_TOKEN
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"checked-in"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_RA_SERF__WC_CHECKED_IN_URL
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
literal|"DAV:"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_DAV
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Here DAV: properties not yet converted to svn: properties should be          ignored. */
return|return
name|NULL
return|;
block|}
comment|/* An unknown namespace, must be a custom property. */
return|return
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|ns
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_ra_serf__walker_visitor_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_flat_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|props
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
comment|/* ### is VAL in the proper pool?  */
name|prop_name
operator|=
name|svn_ra_serf__svnname_from_wirename
argument_list|(
name|ns
argument_list|,
name|name
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
operator|!=
name|NULL
condition|)
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|prop_name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__flatten_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|flat_props
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|flat_props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__walk_node_props
argument_list|(
name|props
argument_list|,
name|set_flat_props
argument_list|,
operator|*
name|flat_props
comment|/* baton */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|select_revprops
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|ns
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|revprops
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|revprops
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
comment|/* ### copy NAME into the RESULT_POOL?  */
comment|/* ### copy VAL into the RESULT_POOL?  */
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_CUSTOM
argument_list|)
operator|==
literal|0
condition|)
name|prop_name
operator|=
name|name
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_DAV_PROP_NS_SVN
argument_list|)
operator|==
literal|0
condition|)
name|prop_name
operator|=
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
name|SVN_PROP_PREFIX
argument_list|)
operator|==
literal|0
condition|)
name|prop_name
operator|=
name|apr_pstrcat
argument_list|(
name|result_pool
argument_list|,
name|SVN_PROP_PREFIX
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ns
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
name|prop_name
operator|=
name|name
expr_stmt|;
else|else
block|{
comment|/* do nothing for now? */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|svn_hash_sets
argument_list|(
name|revprops
argument_list|,
name|prop_name
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__select_revprops
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|revprops
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|all_revprops
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|revprops
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__walk_all_props
argument_list|(
name|all_revprops
argument_list|,
name|name
argument_list|,
name|rev
argument_list|,
name|select_revprops
argument_list|,
operator|*
name|revprops
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Contact the server (using CONN) to calculate baseline  * information for BASELINE_URL at REVISION (which may be  * SVN_INVALID_REVNUM to query the HEAD revision).  *  * If ACTUAL_REVISION is non-NULL, set *ACTUAL_REVISION to revision  * retrieved from the server as part of this process (which should  * match REVISION when REVISION is valid).  Set *BASECOLL_URL_P to the  * baseline collection URL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|retrieve_baseline_info
parameter_list|(
name|svn_revnum_t
modifier|*
name|actual_revision
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|basecoll_url_p
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|baseline_url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_hash_t
modifier|*
name|dav_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|basecoll_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_node_props
argument_list|(
operator|&
name|props
argument_list|,
name|conn
argument_list|,
name|baseline_url
argument_list|,
name|revision
argument_list|,
name|baseline_props
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|dav_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
literal|"DAV:"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If DAV_PROPS is NULL, then svn_prop_get_value() will return NULL.  */
name|basecoll_url
operator|=
name|svn_prop_get_value
argument_list|(
name|dav_props
argument_list|,
literal|"baseline-collection"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basecoll_url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_PROPS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include "
literal|"the requested baseline-collection value"
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|basecoll_url_p
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|basecoll_url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_revision
condition|)
block|{
specifier|const
name|char
modifier|*
name|version_name
decl_stmt|;
name|version_name
operator|=
name|svn_prop_get_value
argument_list|(
name|dav_props
argument_list|,
name|SVN_DAV__VERSION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|version_name
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_PROPS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include "
literal|"the requested version-name value"
argument_list|)
argument_list|)
return|;
operator|*
name|actual_revision
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|version_name
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For HTTPv1 servers, do a PROPFIND dance on the VCC to fetch the youngest    revnum. If BASECOLL_URL is non-NULL, then the corresponding baseline    collection URL is also returned.     Do the work over CONN.     *BASECOLL_URL (if requested) will be allocated in RESULT_POOL. All    temporary allocations will be made in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|v1_get_youngest_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|basecoll_url
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|vcc_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|baseline_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|bc_url
decl_stmt|;
comment|/* Fetching DAV:checked-in from the VCC (with no Label: to specify a      revision) will return the latest Baseline resource's URL.  */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_dav_prop
argument_list|(
operator|&
name|baseline_url
argument_list|,
name|conn
argument_list|,
name|vcc_url
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
literal|"checked-in"
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|baseline_url
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The OPTIONS response did not include "
literal|"the requested checked-in value"
argument_list|)
argument_list|)
return|;
block|}
name|baseline_url
operator|=
name|svn_urlpath__canonicalize
argument_list|(
name|baseline_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* From the Baseline resource, we can fetch the DAV:baseline-collection      and DAV:version-name properties. The latter is the revision number,      which is formally the name used in Label: headers.  */
comment|/* First check baseline information cache. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_get_baseline_info
argument_list|(
operator|&
name|bc_url
argument_list|,
name|youngest
argument_list|,
name|conn
operator|->
name|session
operator|->
name|blncache
argument_list|,
name|baseline_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bc_url
condition|)
block|{
name|SVN_ERR
argument_list|(
name|retrieve_baseline_info
argument_list|(
name|youngest
argument_list|,
operator|&
name|bc_url
argument_list|,
name|conn
argument_list|,
name|baseline_url
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_set
argument_list|(
name|conn
operator|->
name|session
operator|->
name|blncache
argument_list|,
name|baseline_url
argument_list|,
operator|*
name|youngest
argument_list|,
name|bc_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basecoll_url
operator|!=
name|NULL
condition|)
operator|*
name|basecoll_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|bc_url
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_youngest_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_serf__v2_get_youngest_revnum
argument_list|(
name|youngest
argument_list|,
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|v1_get_youngest_revnum
argument_list|(
name|youngest
argument_list|,
name|NULL
argument_list|,
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|vcc_url
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *BC_URL to the baseline collection url for REVISION. If REVISION    is SVN_INVALID_REVNUM, then the youngest revnum ("HEAD") is used.     *REVNUM_USED will be set to the revision used.     Uses the specified CONN, which is part of SESSION.     All allocations (results and temporary) are performed in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_baseline_info
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|bc_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|revnum_used
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* If we detected HTTP v2 support on the server, we can construct      the baseline collection URL ourselves, and fetch the latest      revision (if needed) with an OPTIONS request.  */
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
operator|*
name|revnum_used
operator|=
name|revision
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__v2_get_youngest_revnum
argument_list|(
name|revnum_used
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|revnum_used
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The OPTIONS response did not include "
literal|"the youngest revision"
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|bc_url
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s/%ld"
argument_list|,
name|session
operator|->
name|rev_root_stub
argument_list|,
operator|*
name|revnum_used
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we fall back to the old VCC_URL PROPFIND hunt.  */
else|else
block|{
specifier|const
name|char
modifier|*
name|vcc_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__discover_vcc
argument_list|(
operator|&
name|vcc_url
argument_list|,
name|session
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
comment|/* First check baseline information cache. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_get_bc_url
argument_list|(
name|bc_url
argument_list|,
name|session
operator|->
name|blncache
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bc_url
condition|)
block|{
name|SVN_ERR
argument_list|(
name|retrieve_baseline_info
argument_list|(
name|NULL
argument_list|,
name|bc_url
argument_list|,
name|conn
argument_list|,
name|vcc_url
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__blncache_set
argument_list|(
name|session
operator|->
name|blncache
argument_list|,
name|NULL
argument_list|,
name|revision
argument_list|,
operator|*
name|bc_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|revnum_used
operator|=
name|revision
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|v1_get_youngest_revnum
argument_list|(
name|revnum_used
argument_list|,
name|bc_url
argument_list|,
name|conn
argument_list|,
name|vcc_url
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_stable_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|stable_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|latest_revnum
parameter_list|,
name|svn_ra_serf__session_t
modifier|*
name|session
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|basecoll_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_revnum_t
name|revnum_used
decl_stmt|;
comment|/* No URL? No sweat. We'll use the session URL.  */
if|if
condition|(
operator|!
name|url
condition|)
name|url
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
comment|/* If the caller didn't provide a specific connection for us to use,      we'll use the default connection.  */
if|if
condition|(
operator|!
name|conn
condition|)
name|conn
operator|=
name|session
operator|->
name|conns
index|[
literal|0
index|]
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_baseline_info
argument_list|(
operator|&
name|basecoll_url
argument_list|,
operator|&
name|revnum_used
argument_list|,
name|session
argument_list|,
name|conn
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_relative_path
argument_list|(
operator|&
name|repos_relpath
argument_list|,
name|url
argument_list|,
name|session
argument_list|,
name|conn
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stable_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|basecoll_url
argument_list|,
name|repos_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|latest_revnum
condition|)
operator|*
name|latest_revnum
operator|=
name|revnum_used
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__get_resource_type
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|dav_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|res_type
decl_stmt|;
name|dav_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
literal|"DAV:"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|res_type
operator|=
name|svn_prop_get_value
argument_list|(
name|dav_props
argument_list|,
literal|"resourcetype"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res_type
condition|)
block|{
comment|/* How did this happen? */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_PROPS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include the "
literal|"requested resourcetype value"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|res_type
argument_list|,
literal|"collection"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
else|else
block|{
operator|*
name|kind
operator|=
name|svn_node_file
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__fetch_dav_prop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|svn_ra_serf__connection_t
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_hash_t
modifier|*
name|dav_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__fetch_node_props
argument_list|(
operator|&
name|props
argument_list|,
name|conn
argument_list|,
name|url
argument_list|,
name|revision
argument_list|,
name|checked_in_props
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|dav_props
operator|=
name|apr_hash_get
argument_list|(
name|props
argument_list|,
literal|"DAV:"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|dav_props
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_PROPS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The PROPFIND response did not include "
literal|"the requested 'DAV:' properties"
argument_list|)
argument_list|)
return|;
comment|/* We wouldn't get here if the resource was not found (404), so the      property should be present.       Note: it is okay to call apr_pstrdup() with NULL.  */
operator|*
name|value
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|svn_prop_get_value
argument_list|(
name|dav_props
argument_list|,
name|propname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

