begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * replay.c :  entry point for replay RA functions for ra_serf  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|<serf.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_dav.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"ra_serf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * This enum represents the current state of our XML parsing.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|replay_state_e
block|{
name|NONE
init|=
literal|0
block|,
name|REPORT
block|,
name|OPEN_DIR
block|,
name|ADD_DIR
block|,
name|OPEN_FILE
block|,
name|ADD_FILE
block|,
name|DELETE_ENTRY
block|,
name|APPLY_TEXTDELTA
block|,
name|CHANGE_PROP
block|}
name|replay_state_e
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|replay_info_t
name|replay_info_t
typedef|;
end_typedef

begin_struct
struct|struct
name|replay_info_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|replay_info_t
modifier|*
name|parent
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|change_prop_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|prop_info_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|change_prop_t
name|change
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|svn_boolean_t
name|del_prop
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|prop_value
decl_stmt|;
name|replay_info_t
modifier|*
name|parent
decl_stmt|;
block|}
name|prop_info_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|replay_context_t
block|{
name|apr_pool_t
modifier|*
name|src_rev_pool
decl_stmt|;
name|apr_pool_t
modifier|*
name|dst_rev_pool
decl_stmt|;
comment|/*file_pool is cleared after completion of each file. */
name|apr_pool_t
modifier|*
name|file_pool
decl_stmt|;
comment|/* Are we done fetching this file? */
name|svn_boolean_t
name|done
decl_stmt|;
name|svn_ra_serf__list_t
modifier|*
modifier|*
name|done_list
decl_stmt|;
name|svn_ra_serf__list_t
name|done_item
decl_stmt|;
comment|/* callback to get an editor */
name|svn_ra_replay_revstart_callback_t
name|revstart_func
decl_stmt|;
name|svn_ra_replay_revfinish_callback_t
name|revfinish_func
decl_stmt|;
name|void
modifier|*
name|replay_baton
decl_stmt|;
comment|/* replay receiver function and baton */
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|editor_baton
decl_stmt|;
comment|/* Path and revision used to filter replayed changes.  If      INCLUDE_PATH is non-NULL, REVISION is unnecessary and will not be      included in the replay REPORT.  (Because the REPORT is being      aimed an HTTP v2 revision resource.)  */
specifier|const
name|char
modifier|*
name|include_path
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* Information needed to create the replay report body */
name|svn_revnum_t
name|low_water_mark
decl_stmt|;
name|svn_boolean_t
name|send_deltas
decl_stmt|;
comment|/* Target and revision to fetch revision properties on */
specifier|const
name|char
modifier|*
name|revprop_target
decl_stmt|;
name|svn_revnum_t
name|revprop_rev
decl_stmt|;
comment|/* Revision properties for this revision. */
name|apr_hash_t
modifier|*
name|revs_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* Keep a reference to the XML parser ctx to report any errors. */
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser_ctx
decl_stmt|;
comment|/* Handlers for the PROPFIND and REPORT for the current revision. */
name|svn_ra_serf__handler_t
modifier|*
name|propfind_handler
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|report_handler
decl_stmt|;
block|}
name|replay_context_t
typedef|;
end_typedef

begin_escape
end_escape

begin_function
specifier|static
name|void
modifier|*
name|push_state
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|replay_context_t
modifier|*
name|replay_ctx
parameter_list|,
name|replay_state_e
name|state
parameter_list|)
block|{
name|svn_ra_serf__xml_push_state
argument_list|(
name|parser
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|||
name|state
operator|==
name|OPEN_FILE
operator|||
name|state
operator|==
name|ADD_FILE
condition|)
block|{
name|replay_info_t
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|apr_palloc
argument_list|(
name|replay_ctx
operator|->
name|dst_rev_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|pool
operator|=
name|replay_ctx
operator|->
name|dst_rev_pool
expr_stmt|;
name|info
operator|->
name|parent
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
name|info
operator|->
name|baton
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
name|parser
operator|->
name|state
operator|->
name|private
operator|=
name|info
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|CHANGE_PROP
condition|)
block|{
name|prop_info_t
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|apr_pcalloc
argument_list|(
name|replay_ctx
operator|->
name|dst_rev_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|pool
operator|=
name|replay_ctx
operator|->
name|dst_rev_pool
expr_stmt|;
name|info
operator|->
name|parent
operator|=
name|parser
operator|->
name|state
operator|->
name|private
expr_stmt|;
name|info
operator|->
name|prop_value
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|parser
operator|->
name|state
operator|->
name|private
operator|=
name|info
expr_stmt|;
block|}
return|return
name|parser
operator|->
name|state
operator|->
name|private
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|start_replay
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attrs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|replay_context_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
name|replay_state_e
name|state
decl_stmt|;
name|state
operator|=
name|parser
operator|->
name|state
operator|->
name|current_state
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NONE
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"editor-report"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|REPORT
argument_list|)
expr_stmt|;
comment|/* Before we can continue, we need the revision properties. */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|ctx
operator|->
name|propfind_handler
operator|||
name|ctx
operator|->
name|propfind_handler
operator|->
name|done
argument_list|)
expr_stmt|;
comment|/* Create a pool for the commit editor. */
name|ctx
operator|->
name|dst_rev_pool
operator|=
name|svn_pool_create
argument_list|(
name|ctx
operator|->
name|src_rev_pool
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|file_pool
operator|=
name|svn_pool_create
argument_list|(
name|ctx
operator|->
name|dst_rev_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__select_revprops
argument_list|(
operator|&
name|ctx
operator|->
name|props
argument_list|,
name|ctx
operator|->
name|revprop_target
argument_list|,
name|ctx
operator|->
name|revprop_rev
argument_list|,
name|ctx
operator|->
name|revs_props
argument_list|,
name|ctx
operator|->
name|dst_rev_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|revstart_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|revstart_func
argument_list|(
name|ctx
operator|->
name|revision
argument_list|,
name|ctx
operator|->
name|replay_baton
argument_list|,
operator|&
name|ctx
operator|->
name|editor
argument_list|,
operator|&
name|ctx
operator|->
name|editor_baton
argument_list|,
name|ctx
operator|->
name|props
argument_list|,
name|ctx
operator|->
name|dst_rev_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|REPORT
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"target-revision"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|rev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision attr in target-revision element"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|set_target_revision
argument_list|(
name|ctx
operator|->
name|editor_baton
argument_list|,
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|REPORT
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-root"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|replay_info_t
modifier|*
name|info
decl_stmt|;
name|rev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision attr in open-root element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|OPEN_DIR
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|open_root
argument_list|(
name|ctx
operator|->
name|editor_baton
argument_list|,
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
argument_list|,
name|ctx
operator|->
name|dst_rev_pool
argument_list|,
operator|&
name|info
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"delete-entry"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
name|replay_info_t
modifier|*
name|info
decl_stmt|;
name|file_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in delete-entry element"
argument_list|)
argument_list|)
return|;
block|}
name|rev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision attr in delete-entry element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|DELETE_ENTRY
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|delete_entry
argument_list|(
name|file_name
argument_list|,
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
argument_list|,
name|info
operator|->
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-directory"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|rev
decl_stmt|,
modifier|*
name|dir_name
decl_stmt|;
name|replay_info_t
modifier|*
name|info
decl_stmt|;
name|dir_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in open-directory element"
argument_list|)
argument_list|)
return|;
block|}
name|rev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision attr in open-directory element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|OPEN_DIR
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|open_directory
argument_list|(
name|dir_name
argument_list|,
name|info
operator|->
name|parent
operator|->
name|baton
argument_list|,
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
argument_list|,
name|ctx
operator|->
name|dst_rev_pool
argument_list|,
operator|&
name|info
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"add-directory"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|dir_name
decl_stmt|,
modifier|*
name|copyfrom
decl_stmt|,
modifier|*
name|copyrev
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|replay_info_t
modifier|*
name|info
decl_stmt|;
name|dir_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in add-directory element"
argument_list|)
argument_list|)
return|;
block|}
name|copyfrom
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"copyfrom-path"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|copyrev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"copyfrom-rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyrev
condition|)
name|rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|copyrev
argument_list|)
expr_stmt|;
else|else
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|ADD_DIR
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|add_directory
argument_list|(
name|dir_name
argument_list|,
name|info
operator|->
name|parent
operator|->
name|baton
argument_list|,
name|copyfrom
argument_list|,
name|rev
argument_list|,
name|ctx
operator|->
name|dst_rev_pool
argument_list|,
operator|&
name|info
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"close-directory"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|replay_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|close_directory
argument_list|(
name|info
operator|->
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
name|replay_info_t
modifier|*
name|info
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|ctx
operator|->
name|file_pool
argument_list|)
expr_stmt|;
name|file_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in open-file element"
argument_list|)
argument_list|)
return|;
block|}
name|rev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision attr in open-file element"
argument_list|)
argument_list|)
return|;
block|}
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|OPEN_FILE
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|open_file
argument_list|(
name|file_name
argument_list|,
name|info
operator|->
name|parent
operator|->
name|baton
argument_list|,
name|SVN_STR_TO_REV
argument_list|(
name|rev
argument_list|)
argument_list|,
name|ctx
operator|->
name|file_pool
argument_list|,
operator|&
name|info
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"add-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|,
modifier|*
name|copyfrom
decl_stmt|,
modifier|*
name|copyrev
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|replay_info_t
modifier|*
name|info
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|ctx
operator|->
name|file_pool
argument_list|)
expr_stmt|;
name|file_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in add-file element"
argument_list|)
argument_list|)
return|;
block|}
name|copyfrom
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"copyfrom-path"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|copyrev
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"copyfrom-rev"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|ADD_FILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyrev
condition|)
name|rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|copyrev
argument_list|)
expr_stmt|;
else|else
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|add_file
argument_list|(
name|file_name
argument_list|,
name|info
operator|->
name|parent
operator|->
name|baton
argument_list|,
name|copyfrom
argument_list|,
name|rev
argument_list|,
name|ctx
operator|->
name|file_pool
argument_list|,
operator|&
name|info
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_FILE
operator|||
name|state
operator|==
name|ADD_FILE
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"apply-textdelta"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|checksum
decl_stmt|;
name|replay_info_t
modifier|*
name|info
decl_stmt|;
name|svn_txdelta_window_handler_t
name|textdelta
decl_stmt|;
name|void
modifier|*
name|textdelta_baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|delta_stream
decl_stmt|;
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|APPLY_TEXTDELTA
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"checksum"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
name|checksum
operator|=
name|apr_pstrdup
argument_list|(
name|info
operator|->
name|pool
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|info
operator|->
name|baton
argument_list|,
name|checksum
argument_list|,
name|ctx
operator|->
name|file_pool
argument_list|,
operator|&
name|textdelta
argument_list|,
operator|&
name|textdelta_baton
argument_list|)
argument_list|)
expr_stmt|;
name|delta_stream
operator|=
name|svn_txdelta_parse_svndiff
argument_list|(
name|textdelta
argument_list|,
name|textdelta_baton
argument_list|,
name|TRUE
argument_list|,
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
name|info
operator|->
name|stream
operator|=
name|svn_base64_decode
argument_list|(
name|delta_stream
argument_list|,
name|info
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_FILE
operator|||
name|state
operator|==
name|ADD_FILE
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"close-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|replay_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
specifier|const
name|char
modifier|*
name|checksum
decl_stmt|;
name|checksum
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"checksum"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|editor
operator|->
name|close_file
argument_list|(
name|info
operator|->
name|baton
argument_list|,
name|checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|state
operator|==
name|OPEN_FILE
operator|||
name|state
operator|==
name|ADD_FILE
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"change-file-prop"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|state
operator|==
name|OPEN_DIR
operator|||
name|state
operator|==
name|ADD_DIR
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"change-dir-prop"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_info_t
modifier|*
name|info
decl_stmt|;
name|prop_name
operator|=
name|svn_xml_get_attr_value
argument_list|(
literal|"name"
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_name
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_DAV_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing name attr in %s element"
argument_list|)
argument_list|,
name|name
operator|.
name|name
argument_list|)
return|;
block|}
name|info
operator|=
name|push_state
argument_list|(
name|parser
argument_list|,
name|ctx
argument_list|,
name|CHANGE_PROP
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_xml_get_attr_value
argument_list|(
literal|"del"
argument_list|,
name|attrs
argument_list|)
condition|)
name|info
operator|->
name|del_prop
operator|=
name|TRUE
expr_stmt|;
else|else
name|info
operator|->
name|del_prop
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|OPEN_FILE
operator|||
name|state
operator|==
name|ADD_FILE
condition|)
block|{
name|info
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|file_pool
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
name|info
operator|->
name|change
operator|=
name|ctx
operator|->
name|editor
operator|->
name|change_file_prop
expr_stmt|;
block|}
else|else
block|{
name|info
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|ctx
operator|->
name|dst_rev_pool
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
name|info
operator|->
name|change
operator|=
name|ctx
operator|->
name|editor
operator|->
name|change_dir_prop
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|end_replay
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
name|svn_ra_serf__dav_props_t
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|replay_context_t
modifier|*
name|ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
name|replay_state_e
name|state
decl_stmt|;
name|state
operator|=
name|parser
operator|->
name|state
operator|->
name|current_state
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|REPORT
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"editor-report"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|revfinish_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|revfinish_func
argument_list|(
name|ctx
operator|->
name|revision
argument_list|,
name|ctx
operator|->
name|replay_baton
argument_list|,
name|ctx
operator|->
name|editor
argument_list|,
name|ctx
operator|->
name|editor_baton
argument_list|,
name|ctx
operator|->
name|props
argument_list|,
name|ctx
operator|->
name|dst_rev_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|ctx
operator|->
name|dst_rev_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|OPEN_DIR
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-directory"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't do anything. */
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|ADD_DIR
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"add-directory"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't do anything. */
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|OPEN_FILE
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"open-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't do anything. */
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|ADD_FILE
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"add-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't do anything. */
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|OPEN_FILE
operator|||
name|state
operator|==
name|ADD_FILE
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"close-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't do anything. */
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|APPLY_TEXTDELTA
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"apply-textdelta"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|replay_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|info
operator|->
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|CHANGE_PROP
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"change-file-prop"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"change-dir-prop"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|prop_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|prop_val
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|del_prop
condition|)
block|{
name|prop_val
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|svn_string_t
modifier|*
name|morph
decl_stmt|;
name|morph
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|info
operator|->
name|prop_value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_DEBUG
name|info
operator|->
name|prop_value
operator|=
name|NULL
expr_stmt|;
comment|/* morph killed the stringbuf.  */
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|.
name|name
argument_list|,
literal|"change-file-prop"
argument_list|)
operator|==
literal|0
condition|)
name|prop_val
operator|=
name|svn_base64_decode_string
argument_list|(
name|morph
argument_list|,
name|ctx
operator|->
name|file_pool
argument_list|)
expr_stmt|;
else|else
name|prop_val
operator|=
name|svn_base64_decode_string
argument_list|(
name|morph
argument_list|,
name|ctx
operator|->
name|dst_rev_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|info
operator|->
name|change
argument_list|(
name|info
operator|->
name|parent
operator|->
name|baton
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|prop_val
argument_list|,
name|info
operator|->
name|parent
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_serf__xml_pop_state
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cdata_replay
parameter_list|(
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|replay_context_t
modifier|*
name|replay_ctx
init|=
name|parser
operator|->
name|user_data
decl_stmt|;
name|replay_state_e
name|state
decl_stmt|;
name|UNUSED_CTX
argument_list|(
name|replay_ctx
argument_list|)
expr_stmt|;
name|state
operator|=
name|parser
operator|->
name|state
operator|->
name|current_state
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|APPLY_TEXTDELTA
condition|)
block|{
name|replay_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
name|apr_size_t
name|written
decl_stmt|;
name|written
operator|=
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|data
argument_list|,
operator|&
name|written
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|!=
name|len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_STREAM_UNEXPECTED_EOF
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error writing stream: unexpected EOF"
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|CHANGE_PROP
condition|)
block|{
name|prop_info_t
modifier|*
name|info
init|=
name|parser
operator|->
name|state
operator|->
name|private
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|info
operator|->
name|prop_value
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_replay_body
parameter_list|(
name|serf_bucket_t
modifier|*
modifier|*
name|bkt
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|serf_bucket_alloc_t
modifier|*
name|alloc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|replay_context_t
modifier|*
name|ctx
init|=
name|baton
decl_stmt|;
name|serf_bucket_t
modifier|*
name|body_bkt
decl_stmt|;
name|body_bkt
operator|=
name|serf_bucket_aggregate_create
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_open_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"S:replay-report"
argument_list|,
literal|"xmlns:S"
argument_list|,
name|SVN_XML_NAMESPACE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we have a non-NULL include path, we add it to the body and      omit the revision; otherwise, the reverse. */
if|if
condition|(
name|ctx
operator|->
name|include_path
condition|)
block|{
name|svn_ra_serf__add_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
literal|"S:include-path"
argument_list|,
name|ctx
operator|->
name|include_path
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_ra_serf__add_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
literal|"S:revision"
argument_list|,
name|apr_ltoa
argument_list|(
name|ctx
operator|->
name|src_rev_pool
argument_list|,
name|ctx
operator|->
name|revision
argument_list|)
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
name|svn_ra_serf__add_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
literal|"S:low-water-mark"
argument_list|,
name|apr_ltoa
argument_list|(
name|ctx
operator|->
name|src_rev_pool
argument_list|,
name|ctx
operator|->
name|low_water_mark
argument_list|)
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
literal|"S:send-deltas"
argument_list|,
name|apr_ltoa
argument_list|(
name|ctx
operator|->
name|src_rev_pool
argument_list|,
name|ctx
operator|->
name|send_deltas
argument_list|)
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|svn_ra_serf__add_close_tag_buckets
argument_list|(
name|body_bkt
argument_list|,
name|alloc
argument_list|,
literal|"S:replay-report"
argument_list|)
expr_stmt|;
operator|*
name|bkt
operator|=
name|body_bkt
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__replay
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|replay_context_t
modifier|*
name|replay_ctx
decl_stmt|;
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser_ctx
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|report_target
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__report_resource
argument_list|(
operator|&
name|report_target
argument_list|,
name|session
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|replay_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|replay_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|replay_ctx
operator|->
name|src_rev_pool
operator|=
name|pool
expr_stmt|;
name|replay_ctx
operator|->
name|editor
operator|=
name|editor
expr_stmt|;
name|replay_ctx
operator|->
name|editor_baton
operator|=
name|edit_baton
expr_stmt|;
name|replay_ctx
operator|->
name|done
operator|=
name|FALSE
expr_stmt|;
name|replay_ctx
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|replay_ctx
operator|->
name|low_water_mark
operator|=
name|low_water_mark
expr_stmt|;
name|replay_ctx
operator|->
name|send_deltas
operator|=
name|send_deltas
expr_stmt|;
name|replay_ctx
operator|->
name|revs_props
operator|=
name|apr_hash_make
argument_list|(
name|replay_ctx
operator|->
name|src_rev_pool
argument_list|)
expr_stmt|;
name|handler
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|->
name|handler_pool
operator|=
name|pool
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"REPORT"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_replay_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|replay_ctx
expr_stmt|;
name|handler
operator|->
name|body_type
operator|=
literal|"text/xml"
expr_stmt|;
name|handler
operator|->
name|conn
operator|=
name|session
operator|->
name|conns
index|[
literal|0
index|]
expr_stmt|;
name|handler
operator|->
name|session
operator|=
name|session
expr_stmt|;
name|parser_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|parser_ctx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|parser_ctx
operator|->
name|user_data
operator|=
name|replay_ctx
expr_stmt|;
name|parser_ctx
operator|->
name|start
operator|=
name|start_replay
expr_stmt|;
name|parser_ctx
operator|->
name|end
operator|=
name|end_replay
expr_stmt|;
name|parser_ctx
operator|->
name|cdata
operator|=
name|cdata_replay
expr_stmt|;
name|parser_ctx
operator|->
name|done
operator|=
operator|&
name|replay_ctx
operator|->
name|done
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__handle_xml_parser
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|parser_ctx
expr_stmt|;
comment|/* This is only needed to handle errors during XML parsing. */
name|replay_ctx
operator|->
name|parser_ctx
operator|=
name|parser_ctx
expr_stmt|;
name|replay_ctx
operator|->
name|report_handler
operator|=
name|handler
expr_stmt|;
comment|/* unused */
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_serf__context_run_wait
argument_list|(
operator|&
name|replay_ctx
operator|->
name|done
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|svn_ra_serf__error_on_status
argument_list|(
name|handler
operator|->
name|sline
operator|.
name|code
argument_list|,
name|handler
operator|->
name|path
argument_list|,
name|handler
operator|->
name|location
argument_list|)
argument_list|,
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The maximum number of outstanding requests at any time. When this  * number is reached, ra_serf will stop sending requests until  * responses on the previous requests are received and handled.  *  * Some observations about serf which lead us to the current value.  * ----------------------------------------------------------------  *  * We aim to keep serf's outgoing queue filled with enough requests so  * the network bandwidth and server capacity is used  * optimally. Originally we used 5 as the max. number of outstanding  * requests, but this turned out to be too low.  *  * Serf doesn't exit out of the svn_ra_serf__context_run_wait loop as long as  * it has data to send or receive. With small responses (revs of a few  * kB), serf doesn't come out of this loop at all. So with  * MAX_OUTSTANDING_REQUESTS set to a low number, there's a big chance  * that serf handles those requests completely in its internal loop,  * and only then gives us a chance to create new requests. This  * results in hiccups, slowing down the whole process.  *  * With a larger MAX_OUTSTANDING_REQUESTS, like 100 or more, there's  * more chance that serf can come out of its internal loop so we can  * replenish the outgoing request queue.  There's no real disadvantage  * of using a large number here, besides the memory used to store the  * message, parser and handler objects (approx. 250 bytes).  *  * In my test setup peak performance was reached at max. 30-35  * requests. So I added a small margin and chose 50.  */
end_comment

begin_define
define|#
directive|define
name|MAX_OUTSTANDING_REQUESTS
value|50
end_define

begin_function
name|svn_error_t
modifier|*
name|svn_ra_serf__replay_range
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
name|svn_ra_replay_revstart_callback_t
name|revstart_func
parameter_list|,
name|svn_ra_replay_revfinish_callback_t
name|revfinish_func
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_serf__session_t
modifier|*
name|session
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_revnum_t
name|rev
init|=
name|start_revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|report_target
decl_stmt|;
name|int
name|active_reports
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|include_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__report_resource
argument_list|(
operator|&
name|report_target
argument_list|,
name|session
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prior to 1.8, mod_dav_svn expect to get replay REPORT requests      aimed at the session URL.  But that's incorrect -- these reports      aren't about specific resources -- they are above revisions.  The      path-based filtering offered by this API is just that: a filter      applied to the full set of changes made in the revision.  As      such, the correct target for these REPORT requests is the "me      resource" (or, pre-http-v2, the default VCC).       Our server should have told us if it supported this protocol      correction.  If so, we aimed our report at the correct resource      and include the filtering path as metadata within the report      body.  Otherwise, we fall back to the pre-1.8 behavior and just      wish for the best.       See issue #4287:      http://subversion.tigris.org/issues/show_bug.cgi?id=4287   */
if|if
condition|(
name|session
operator|->
name|supports_rev_rsrc_replay
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_serf__get_relative_path
argument_list|(
operator|&
name|include_path
argument_list|,
name|session
operator|->
name|session_url
operator|.
name|path
argument_list|,
name|session
argument_list|,
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|include_path
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|active_reports
operator|||
name|rev
operator|<=
name|end_revision
condition|)
block|{
name|svn_ra_serf__list_t
modifier|*
name|done_list
decl_stmt|;
name|svn_ra_serf__list_t
modifier|*
name|done_reports
init|=
name|NULL
decl_stmt|;
name|replay_context_t
modifier|*
name|replay_ctx
decl_stmt|;
if|if
condition|(
name|session
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|session
operator|->
name|cancel_func
argument_list|(
name|session
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send pending requests, if any. Limit the number of outstanding          requests to MAX_OUTSTANDING_REQUESTS. */
if|if
condition|(
name|rev
operator|<=
name|end_revision
operator|&&
name|active_reports
operator|<
name|MAX_OUTSTANDING_REQUESTS
condition|)
block|{
name|svn_ra_serf__handler_t
modifier|*
name|handler
decl_stmt|;
name|svn_ra_serf__xml_parser_t
modifier|*
name|parser_ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|ctx_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|replay_target
decl_stmt|;
name|replay_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|ctx_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|replay_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|replay_ctx
operator|->
name|src_rev_pool
operator|=
name|ctx_pool
expr_stmt|;
name|replay_ctx
operator|->
name|revstart_func
operator|=
name|revstart_func
expr_stmt|;
name|replay_ctx
operator|->
name|revfinish_func
operator|=
name|revfinish_func
expr_stmt|;
name|replay_ctx
operator|->
name|replay_baton
operator|=
name|replay_baton
expr_stmt|;
name|replay_ctx
operator|->
name|done
operator|=
name|FALSE
expr_stmt|;
name|replay_ctx
operator|->
name|include_path
operator|=
name|include_path
expr_stmt|;
name|replay_ctx
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|replay_ctx
operator|->
name|low_water_mark
operator|=
name|low_water_mark
expr_stmt|;
name|replay_ctx
operator|->
name|send_deltas
operator|=
name|send_deltas
expr_stmt|;
name|replay_ctx
operator|->
name|done_item
operator|.
name|data
operator|=
name|replay_ctx
expr_stmt|;
comment|/* Request all properties of a certain revision. */
name|replay_ctx
operator|->
name|revs_props
operator|=
name|apr_hash_make
argument_list|(
name|replay_ctx
operator|->
name|src_rev_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_RA_SERF__HAVE_HTTPV2_SUPPORT
argument_list|(
name|session
argument_list|)
condition|)
block|{
name|replay_ctx
operator|->
name|revprop_target
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s/%ld"
argument_list|,
name|session
operator|->
name|rev_stub
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|replay_ctx
operator|->
name|revprop_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
name|replay_ctx
operator|->
name|revprop_target
operator|=
name|report_target
expr_stmt|;
name|replay_ctx
operator|->
name|revprop_rev
operator|=
name|rev
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_serf__deliver_props
argument_list|(
operator|&
name|replay_ctx
operator|->
name|propfind_handler
argument_list|,
name|replay_ctx
operator|->
name|revs_props
argument_list|,
name|session
argument_list|,
name|session
operator|->
name|conns
index|[
literal|0
index|]
argument_list|,
name|replay_ctx
operator|->
name|revprop_target
argument_list|,
name|replay_ctx
operator|->
name|revprop_rev
argument_list|,
literal|"0"
argument_list|,
name|all_props
argument_list|,
name|NULL
argument_list|,
name|replay_ctx
operator|->
name|src_rev_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Spin up the serf request for the PROPFIND.  */
name|svn_ra_serf__request_create
argument_list|(
name|replay_ctx
operator|->
name|propfind_handler
argument_list|)
expr_stmt|;
comment|/* Send the replay REPORT request. */
if|if
condition|(
name|session
operator|->
name|supports_rev_rsrc_replay
condition|)
block|{
name|replay_target
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s/%ld"
argument_list|,
name|session
operator|->
name|rev_stub
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|replay_target
operator|=
name|session
operator|->
name|session_url
operator|.
name|path
expr_stmt|;
block|}
name|handler
operator|=
name|apr_pcalloc
argument_list|(
name|replay_ctx
operator|->
name|src_rev_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|)
expr_stmt|;
name|handler
operator|->
name|handler_pool
operator|=
name|replay_ctx
operator|->
name|src_rev_pool
expr_stmt|;
name|handler
operator|->
name|method
operator|=
literal|"REPORT"
expr_stmt|;
name|handler
operator|->
name|path
operator|=
name|replay_target
expr_stmt|;
name|handler
operator|->
name|body_delegate
operator|=
name|create_replay_body
expr_stmt|;
name|handler
operator|->
name|body_delegate_baton
operator|=
name|replay_ctx
expr_stmt|;
name|handler
operator|->
name|conn
operator|=
name|session
operator|->
name|conns
index|[
literal|0
index|]
expr_stmt|;
name|handler
operator|->
name|session
operator|=
name|session
expr_stmt|;
name|parser_ctx
operator|=
name|apr_pcalloc
argument_list|(
name|replay_ctx
operator|->
name|src_rev_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser_ctx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the XML parser context.              Because we have not one but a list of requests, the 'done' property              on the replay_ctx is not of much use. Instead, use 'done_list'.              On each handled response (succesfully or not), the parser will add              done_item to done_list, so by keeping track of the state of              done_list we know how many requests have been handled completely.           */
name|parser_ctx
operator|->
name|pool
operator|=
name|replay_ctx
operator|->
name|src_rev_pool
expr_stmt|;
name|parser_ctx
operator|->
name|user_data
operator|=
name|replay_ctx
expr_stmt|;
name|parser_ctx
operator|->
name|start
operator|=
name|start_replay
expr_stmt|;
name|parser_ctx
operator|->
name|end
operator|=
name|end_replay
expr_stmt|;
name|parser_ctx
operator|->
name|cdata
operator|=
name|cdata_replay
expr_stmt|;
name|parser_ctx
operator|->
name|done
operator|=
operator|&
name|replay_ctx
operator|->
name|done
expr_stmt|;
name|parser_ctx
operator|->
name|done_list
operator|=
operator|&
name|done_reports
expr_stmt|;
name|parser_ctx
operator|->
name|done_item
operator|=
operator|&
name|replay_ctx
operator|->
name|done_item
expr_stmt|;
name|handler
operator|->
name|response_handler
operator|=
name|svn_ra_serf__handle_xml_parser
expr_stmt|;
name|handler
operator|->
name|response_baton
operator|=
name|parser_ctx
expr_stmt|;
name|replay_ctx
operator|->
name|report_handler
operator|=
name|handler
expr_stmt|;
comment|/* This is only needed to handle errors during XML parsing. */
name|replay_ctx
operator|->
name|parser_ctx
operator|=
name|parser_ctx
expr_stmt|;
name|svn_ra_serf__request_create
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|rev
operator|++
expr_stmt|;
name|active_reports
operator|++
expr_stmt|;
block|}
comment|/* Run the serf loop. */
name|SVN_ERR
argument_list|(
name|svn_ra_serf__context_run_wait
argument_list|(
operator|&
name|replay_ctx
operator|->
name|done
argument_list|,
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Substract the number of completely handled responses from our          total nr. of open requests', so we'll know when to stop this loop.          Since the message is completely handled, we can destroy its pool. */
name|done_list
operator|=
name|done_reports
expr_stmt|;
while|while
condition|(
name|done_list
condition|)
block|{
name|replay_context_t
modifier|*
name|ctx
init|=
operator|(
name|replay_context_t
operator|*
operator|)
name|done_list
operator|->
name|data
decl_stmt|;
name|svn_ra_serf__handler_t
modifier|*
name|done_handler
init|=
name|ctx
operator|->
name|report_handler
decl_stmt|;
name|done_list
operator|=
name|done_list
operator|->
name|next
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_serf__error_on_status
argument_list|(
name|done_handler
operator|->
name|sline
operator|.
name|code
argument_list|,
name|done_handler
operator|->
name|path
argument_list|,
name|done_handler
operator|->
name|location
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|ctx
operator|->
name|src_rev_pool
argument_list|)
expr_stmt|;
name|active_reports
operator|--
expr_stmt|;
block|}
name|done_reports
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MAX_OUTSTANDING_REQUESTS
end_undef

end_unit

