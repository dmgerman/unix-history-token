begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * depth_filter_editor.c -- provide a svn_delta_editor_t which wraps  *                          another editor and provides depth-based filtering  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Batons, and the Toys That Create Them ***/
end_comment

begin_struct
struct|struct
name|edit_baton
block|{
comment|/* The editor/baton we're wrapping. */
specifier|const
name|svn_delta_editor_t
modifier|*
name|wrapped_editor
decl_stmt|;
name|void
modifier|*
name|wrapped_edit_baton
decl_stmt|;
comment|/* The depth to which we are limiting the drive of the wrapped      editor/baton. */
name|svn_depth_t
name|requested_depth
decl_stmt|;
comment|/* Does the wrapped editor/baton have an explicit target (in the      anchor/target sense of the word)? */
name|svn_boolean_t
name|has_target
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|node_baton
block|{
comment|/* TRUE iff this node was filtered out -- that is, not allowed to      pass through to the wrapped editor -- by virtue of not appearing      at a depth in the tree that was "inside" the requested depth.  Of      course, any children of this node will be deeper still, and so      will also be filtered out for the same reason. */
name|svn_boolean_t
name|filtered
decl_stmt|;
comment|/* Pointer to the edit_baton. */
name|void
modifier|*
name|edit_baton
decl_stmt|;
comment|/* The real node baton we're wrapping.  May be a directory or file      baton; we don't care. */
name|void
modifier|*
name|wrapped_baton
decl_stmt|;
comment|/* The calculated depth (in terms of counted, stacked, integral      deepnesses) of this node.  If the node is a directory, this value      is 1 greater than the value of the same on its parent directory;      if a file, it is equal to its parent directory's depth value. */
name|int
name|dir_depth
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate and return a new node_baton structure, populated via the    the input to this helper function. */
end_comment

begin_function
specifier|static
name|struct
name|node_baton
modifier|*
name|make_node_baton
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_boolean_t
name|filtered
parameter_list|,
name|int
name|dir_depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|b
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|b
operator|->
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|b
operator|->
name|wrapped_baton
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|filtered
operator|=
name|filtered
expr_stmt|;
name|b
operator|->
name|dir_depth
operator|=
name|dir_depth
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff changes to immediate children of the directory    identified by PB, when those children are of node kind KIND, are    allowed by the requested depth which this editor is trying to    preserve.  EB is the edit baton.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|okay_to_edit
parameter_list|(
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
name|struct
name|node_baton
modifier|*
name|pb
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|)
block|{
name|int
name|effective_depth
decl_stmt|;
comment|/* If we've already filter out the parent directory, we necessarily      are filtering out its children, too.  */
if|if
condition|(
name|pb
operator|->
name|filtered
condition|)
return|return
name|FALSE
return|;
comment|/* Calculate the effective depth of the parent directory.       NOTE:  "Depth" in this sense is not the same as the Subversion      magic depth keywords.  Here, we're talking about a literal,      integral, stacked depth of directories.       The root of the edit is generally depth=1, subdirectories thereof      depth=2, and so on.  But if we have an edit target -- which means      that the real target of the edit operation isn't the root      directory, but is instead some immediate child thereof -- we have      to adjust our calculated effected depth such that the target      itself is depth=1 (as are its siblings, which we trust aren't      present in the edit at all), immediate subdirectories thereof are      depth=2, and so on.   */
name|effective_depth
operator|=
name|pb
operator|->
name|dir_depth
operator|-
operator|(
name|eb
operator|->
name|has_target
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|eb
operator|->
name|requested_depth
condition|)
block|{
case|case
name|svn_depth_empty
case|:
return|return
operator|(
name|effective_depth
operator|<=
literal|0
operator|)
return|;
case|case
name|svn_depth_files
case|:
return|return
operator|(
operator|(
name|effective_depth
operator|<=
literal|0
operator|)
operator|||
operator|(
name|kind
operator|==
name|svn_node_file
operator|&&
name|effective_depth
operator|==
literal|1
operator|)
operator|)
return|;
case|case
name|svn_depth_immediates
case|:
return|return
operator|(
name|effective_depth
operator|<=
literal|1
operator|)
return|;
case|case
name|svn_depth_unknown
case|:
case|case
name|svn_depth_exclude
case|:
case|case
name|svn_depth_infinity
case|:
comment|/* Shouldn't reach; see svn_delta_depth_filter_editor() */
default|default:
name|SVN_ERR_MALFUNCTION_NO_RETURN
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Editor Functions ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_target_revision
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
comment|/* Nothing depth-y to filter here. */
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|set_target_revision
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|target_revision
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|node_baton
modifier|*
name|b
decl_stmt|;
comment|/* The root node always gets through cleanly. */
name|b
operator|=
name|make_node_baton
argument_list|(
name|edit_baton
argument_list|,
name|FALSE
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_root
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_baton
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
comment|/* ### FIXME: We don't know the type of the entry, which ordinarily      doesn't matter, but is a key (*the* key, in fact) distinction      between depth "files" and depths "immediates".  If the server is      telling us to delete a subdirectory and our requested depth was      "immediates", that's fine; if our requested depth was "files",      though, this deletion shouldn't survive filtering.  For now,      we'll claim to our helper function that the to-be-deleted thing      is a file because that's the conservative route to take. */
if|if
condition|(
name|okay_to_edit
argument_list|(
name|eb
argument_list|,
name|pb
argument_list|,
name|svn_node_file
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|delete_entry
argument_list|(
name|path
argument_list|,
name|base_revision
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|node_baton
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
comment|/* Check for sufficient depth. */
if|if
condition|(
name|okay_to_edit
argument_list|(
name|eb
argument_list|,
name|pb
argument_list|,
name|svn_node_dir
argument_list|)
condition|)
block|{
name|b
operator|=
name|make_node_baton
argument_list|(
name|eb
argument_list|,
name|FALSE
argument_list|,
name|pb
operator|->
name|dir_depth
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|add_directory
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|make_node_baton
argument_list|(
name|eb
argument_list|,
name|TRUE
argument_list|,
name|pb
operator|->
name|dir_depth
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|child_baton
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|node_baton
modifier|*
name|b
decl_stmt|;
comment|/* Check for sufficient depth. */
if|if
condition|(
name|okay_to_edit
argument_list|(
name|eb
argument_list|,
name|pb
argument_list|,
name|svn_node_dir
argument_list|)
condition|)
block|{
name|b
operator|=
name|make_node_baton
argument_list|(
name|eb
argument_list|,
name|FALSE
argument_list|,
name|pb
operator|->
name|dir_depth
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_directory
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|make_node_baton
argument_list|(
name|eb
argument_list|,
name|TRUE
argument_list|,
name|pb
operator|->
name|dir_depth
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|child_baton
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|node_baton
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
comment|/* Check for sufficient depth. */
if|if
condition|(
name|okay_to_edit
argument_list|(
name|eb
argument_list|,
name|pb
argument_list|,
name|svn_node_file
argument_list|)
condition|)
block|{
name|b
operator|=
name|make_node_baton
argument_list|(
name|eb
argument_list|,
name|FALSE
argument_list|,
name|pb
operator|->
name|dir_depth
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|add_file
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|copyfrom_path
argument_list|,
name|copyfrom_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|make_node_baton
argument_list|(
name|eb
argument_list|,
name|TRUE
argument_list|,
name|pb
operator|->
name|dir_depth
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|child_baton
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|node_baton
modifier|*
name|b
decl_stmt|;
comment|/* Check for sufficient depth. */
if|if
condition|(
name|okay_to_edit
argument_list|(
name|eb
argument_list|,
name|pb
argument_list|,
name|svn_node_file
argument_list|)
condition|)
block|{
name|b
operator|=
name|make_node_baton
argument_list|(
name|eb
argument_list|,
name|FALSE
argument_list|,
name|pb
operator|->
name|dir_depth
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|open_file
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|,
operator|&
name|b
operator|->
name|wrapped_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|make_node_baton
argument_list|(
name|eb
argument_list|,
name|TRUE
argument_list|,
name|pb
operator|->
name|dir_depth
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|child_baton
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
comment|/* For filtered files, we just consume the textdelta. */
if|if
condition|(
name|fb
operator|->
name|filtered
condition|)
block|{
operator|*
name|handler
operator|=
name|svn_delta_noop_window_handler
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|apply_textdelta
argument_list|(
name|fb
operator|->
name|wrapped_baton
argument_list|,
name|base_checksum
argument_list|,
name|pool
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
comment|/* Don't close filtered files. */
if|if
condition|(
operator|!
name|fb
operator|->
name|filtered
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_file
argument_list|(
name|fb
operator|->
name|wrapped_baton
argument_list|,
name|text_checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
comment|/* Don't report absent items in filtered directories. */
if|if
condition|(
operator|!
name|pb
operator|->
name|filtered
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|absent_file
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
comment|/* Don't close filtered directories. */
if|if
condition|(
operator|!
name|db
operator|->
name|filtered
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_directory
argument_list|(
name|db
operator|->
name|wrapped_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|absent_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
comment|/* Don't report absent items in filtered directories. */
if|if
condition|(
operator|!
name|pb
operator|->
name|filtered
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|absent_directory
argument_list|(
name|path
argument_list|,
name|pb
operator|->
name|wrapped_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
comment|/* No propchanges on filtered files. */
if|if
condition|(
operator|!
name|fb
operator|->
name|filtered
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|change_file_prop
argument_list|(
name|fb
operator|->
name|wrapped_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
comment|/* No propchanges on filtered nodes. */
if|if
condition|(
operator|!
name|db
operator|->
name|filtered
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|wrapped_editor
operator|->
name|change_dir_prop
argument_list|(
name|db
operator|->
name|wrapped_baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
return|return
name|eb
operator|->
name|wrapped_editor
operator|->
name|close_edit
argument_list|(
name|eb
operator|->
name|wrapped_edit_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_delta_depth_filter_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|wrapped_editor
parameter_list|,
name|void
modifier|*
name|wrapped_edit_baton
parameter_list|,
name|svn_depth_t
name|requested_depth
parameter_list|,
name|svn_boolean_t
name|has_target
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_delta_editor_t
modifier|*
name|depth_filter_editor
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
decl_stmt|;
comment|/* Easy out: if the caller wants infinite depth, there's nothing to      filter, so just return the editor we were supposed to wrap.  And      if they've asked for an unknown depth, we can't possibly know      what that means, so why bother?  */
if|if
condition|(
operator|(
name|requested_depth
operator|==
name|svn_depth_unknown
operator|)
operator|||
operator|(
name|requested_depth
operator|==
name|svn_depth_infinity
operator|)
condition|)
block|{
operator|*
name|editor
operator|=
name|wrapped_editor
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|wrapped_edit_baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|depth_filter_editor
operator|=
name|svn_delta_default_editor
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|depth_filter_editor
operator|->
name|set_target_revision
operator|=
name|set_target_revision
expr_stmt|;
name|depth_filter_editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|depth_filter_editor
operator|->
name|delete_entry
operator|=
name|delete_entry
expr_stmt|;
name|depth_filter_editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|depth_filter_editor
operator|->
name|open_directory
operator|=
name|open_directory
expr_stmt|;
name|depth_filter_editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|depth_filter_editor
operator|->
name|close_directory
operator|=
name|close_directory
expr_stmt|;
name|depth_filter_editor
operator|->
name|absent_directory
operator|=
name|absent_directory
expr_stmt|;
name|depth_filter_editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|depth_filter_editor
operator|->
name|open_file
operator|=
name|open_file
expr_stmt|;
name|depth_filter_editor
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|depth_filter_editor
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|depth_filter_editor
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|depth_filter_editor
operator|->
name|absent_file
operator|=
name|absent_file
expr_stmt|;
name|depth_filter_editor
operator|->
name|close_edit
operator|=
name|close_edit
expr_stmt|;
name|eb
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|wrapped_editor
operator|=
name|wrapped_editor
expr_stmt|;
name|eb
operator|->
name|wrapped_edit_baton
operator|=
name|wrapped_edit_baton
expr_stmt|;
name|eb
operator|->
name|has_target
operator|=
name|has_target
expr_stmt|;
name|eb
operator|->
name|requested_depth
operator|=
name|requested_depth
expr_stmt|;
operator|*
name|editor
operator|=
name|depth_filter_editor
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|eb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

