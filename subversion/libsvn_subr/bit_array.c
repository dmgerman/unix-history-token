begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * bit_array.c :  implement a simple packed bit array  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_comment
comment|/* We allocate our data buffer in blocks of this size (in bytes).  * For performance reasons, this shall be a power of two.  * It should also not exceed 80kB (to prevent APR pool fragmentation) and  * not be too small (to keep the number of OS-side memory allocations low -  * avoiding hitting system-specific limits).  */
end_comment

begin_define
define|#
directive|define
name|BLOCK_SIZE
value|0x10000
end_define

begin_comment
comment|/* Number of bits in each block.  */
end_comment

begin_define
define|#
directive|define
name|BLOCK_SIZE_BITS
value|(8 * BLOCK_SIZE)
end_define

begin_comment
comment|/* Initial array size (covers INITIAL_BLOCK_COUNT * BLOCK_SIZE_BITS bits).  * For performance reasons, this shall be a power of two.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_BLOCK_COUNT
value|16
end_define

begin_comment
comment|/* We store the bits in a lazily allocated two-dimensional array.  * For every BLOCK_SIZE_BITS range of indexes, there is one entry in the  * BLOCKS array.  If index / BLOCK_SIZE_BITS exceeds BLOCK_COUNT-1, the  * blocks are implicitly empty.  Only if a bit will be set to 1, will the  * BLOCKS array be auto-expanded.  *  * As long as no bit got set in a particular block, the respective entry in  * BLOCKS entry will be NULL, implying that all block contents is 0.  */
end_comment

begin_struct
struct|struct
name|svn_bit_array__t
block|{
comment|/* Data buffer of BLOCK_COUNT blocks, BLOCK_SIZE_BITS each.  Never NULL.    * Every block may be NULL, though. */
name|unsigned
name|char
modifier|*
modifier|*
name|blocks
decl_stmt|;
comment|/* Number of bytes allocated to DATA.  Never shrinks. */
name|apr_size_t
name|block_count
decl_stmt|;
comment|/* Reallocate DATA form this POOL when growing. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Given that MAX shall be an actual bit index in a packed bit array,  * return the number of blocks entries to allocate for the data buffer. */
end_comment

begin_function
specifier|static
name|apr_size_t
name|select_data_size
parameter_list|(
name|apr_size_t
name|max
parameter_list|)
block|{
comment|/* We allocate a power of two of bytes but at least 16 blocks. */
name|apr_size_t
name|size
init|=
name|INITIAL_BLOCK_COUNT
decl_stmt|;
comment|/* Caution:    * MAX / BLOCK_SIZE_BITS == SIZE still means that MAX is out of bounds.    * OTOH, 2 * (MAX/BLOCK_SIZE_BITS) is always within the value range of    * APR_SIZE_T. */
while|while
condition|(
name|size
operator|<=
name|max
operator|/
name|BLOCK_SIZE_BITS
condition|)
name|size
operator|*=
literal|2
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
name|svn_bit_array__t
modifier|*
name|svn_bit_array__create
parameter_list|(
name|apr_size_t
name|max
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_bit_array__t
modifier|*
name|array
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|array
operator|->
name|block_count
operator|=
name|select_data_size
argument_list|(
name|max
argument_list|)
expr_stmt|;
name|array
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|array
operator|->
name|blocks
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|array
operator|->
name|block_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|array
operator|->
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
end_function

begin_function
name|void
name|svn_bit_array__set
parameter_list|(
name|svn_bit_array__t
modifier|*
name|array
parameter_list|,
name|apr_size_t
name|idx
parameter_list|,
name|svn_boolean_t
name|value
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|block
decl_stmt|;
comment|/* Index within ARRAY->BLOCKS for the block containing bit IDX. */
name|apr_size_t
name|block_idx
init|=
name|idx
operator|/
name|BLOCK_SIZE_BITS
decl_stmt|;
comment|/* Within that block, index of the byte containing IDX. */
name|apr_size_t
name|byte_idx
init|=
operator|(
name|idx
operator|%
name|BLOCK_SIZE_BITS
operator|)
operator|/
literal|8
decl_stmt|;
comment|/* Within that byte, index of the bit corresponding to IDX. */
name|apr_size_t
name|bit_idx
init|=
operator|(
name|idx
operator|%
name|BLOCK_SIZE_BITS
operator|)
operator|%
literal|8
decl_stmt|;
comment|/* If IDX is outside the allocated range, we _may_ have to grow it.    *    * Be sure to use division instead of multiplication as we need to cover    * the full value range of APR_SIZE_T for the bit indexes.    */
if|if
condition|(
name|block_idx
operator|>=
name|array
operator|->
name|block_count
condition|)
block|{
name|apr_size_t
name|new_count
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|new_blocks
decl_stmt|;
comment|/* Unallocated indexes are implicitly 0, so no actual allocation        * required in that case.        */
if|if
condition|(
operator|!
name|value
condition|)
return|return;
comment|/* Grow block list to cover IDX.        * Clear the new entries to guarantee our array[idx]==0 default.        */
name|new_count
operator|=
name|select_data_size
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|new_blocks
operator|=
name|apr_pcalloc
argument_list|(
name|array
operator|->
name|pool
argument_list|,
name|new_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|new_blocks
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_blocks
argument_list|,
name|array
operator|->
name|blocks
argument_list|,
name|array
operator|->
name|block_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|new_blocks
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|->
name|blocks
operator|=
name|new_blocks
expr_stmt|;
name|array
operator|->
name|block_count
operator|=
name|new_count
expr_stmt|;
block|}
comment|/* IDX is covered by ARRAY->BLOCKS now. */
comment|/* Get the block that contains IDX.  Auto-allocate it if missing. */
name|block
operator|=
name|array
operator|->
name|blocks
index|[
name|block_idx
index|]
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
block|{
comment|/* Unallocated indexes are implicitly 0, so no actual allocation        * required in that case.        */
if|if
condition|(
operator|!
name|value
condition|)
return|return;
comment|/* Allocate the previously missing block and clear it for our        * array[idx] == 0 default. */
name|block
operator|=
name|apr_pcalloc
argument_list|(
name|array
operator|->
name|pool
argument_list|,
name|BLOCK_SIZE
argument_list|)
expr_stmt|;
name|array
operator|->
name|blocks
index|[
name|block_idx
index|]
operator|=
name|block
expr_stmt|;
block|}
comment|/* Set / reset one bit.  Be sure to use unsigned shifts. */
if|if
condition|(
name|value
condition|)
name|block
index|[
name|byte_idx
index|]
operator||=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|1u
operator|<<
name|bit_idx
argument_list|)
expr_stmt|;
else|else
name|block
index|[
name|byte_idx
index|]
operator|&=
operator|~
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|1u
operator|<<
name|bit_idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_bit_array__get
parameter_list|(
name|svn_bit_array__t
modifier|*
name|array
parameter_list|,
name|apr_size_t
name|idx
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|block
decl_stmt|;
comment|/* Index within ARRAY->BLOCKS for the block containing bit IDX. */
name|apr_size_t
name|block_idx
init|=
name|idx
operator|/
name|BLOCK_SIZE_BITS
decl_stmt|;
comment|/* Within that block, index of the byte containing IDX. */
name|apr_size_t
name|byte_idx
init|=
operator|(
name|idx
operator|%
name|BLOCK_SIZE_BITS
operator|)
operator|/
literal|8
decl_stmt|;
comment|/* Within that byte, index of the bit corresponding to IDX. */
name|apr_size_t
name|bit_idx
init|=
operator|(
name|idx
operator|%
name|BLOCK_SIZE_BITS
operator|)
operator|%
literal|8
decl_stmt|;
comment|/* Indexes outside the allocated range are implicitly 0. */
if|if
condition|(
name|block_idx
operator|>=
name|array
operator|->
name|block_count
condition|)
return|return
literal|0
return|;
comment|/* Same if the respective block has not been allocated. */
name|block
operator|=
name|array
operator|->
name|blocks
index|[
name|block_idx
index|]
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Extract one bit (get the byte, shift bit to LSB, extract it). */
return|return
operator|(
name|block
index|[
name|byte_idx
index|]
operator|>>
name|bit_idx
operator|)
operator|&
literal|1
return|;
block|}
end_function

end_unit

