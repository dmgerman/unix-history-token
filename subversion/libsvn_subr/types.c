begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svn_types.c :  Implementation for Subversion's data types.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_function
name|svn_error_t
modifier|*
name|svn_revnum_parse
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|svn_revnum_t
name|result
init|=
operator|(
name|svn_revnum_t
operator|)
name|svn__strtoul
argument_list|(
name|str
argument_list|,
operator|&
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|endptr
condition|)
operator|*
name|endptr
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|end
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REVNUM_PARSE_FAILURE
argument_list|,
name|NULL
argument_list|,
operator|*
name|str
operator|==
literal|'-'
condition|?
name|_
argument_list|(
literal|"Negative revision number found parsing '%s'"
argument_list|)
else|:
name|_
argument_list|(
literal|"Invalid revision number found parsing '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
return|;
comment|/* a revision number with more than 9 digits is suspicious.      Have a closer look at those. */
if|if
condition|(
name|str
operator|+
literal|10
operator|<=
name|end
condition|)
block|{
comment|/* we support 32 bit revision numbers only. check for overflows */
if|if
condition|(
name|str
operator|+
literal|10
operator|<
name|end
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REVNUM_PARSE_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision number longer than 10 digits '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
return|;
comment|/* we support 32 bit revision numbers only. check for overflows */
if|if
condition|(
operator|*
name|str
operator|>
literal|'2'
operator|||
operator|(
name|apr_uint32_t
operator|)
name|result
operator|>
name|APR_INT32_MAX
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_REVNUM_PARSE_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision number too large '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
return|;
block|}
if|if
condition|(
name|endptr
condition|)
operator|*
name|endptr
operator|=
name|end
expr_stmt|;
operator|*
name|rev
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_uuid_generate
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uuid_t
name|uuid
decl_stmt|;
name|char
modifier|*
name|uuid_str
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|APR_UUID_FORMATTED_LENGTH
operator|+
literal|1
argument_list|)
decl_stmt|;
name|apr_uuid_get
argument_list|(
operator|&
name|uuid
argument_list|)
expr_stmt|;
name|apr_uuid_format
argument_list|(
name|uuid_str
argument_list|,
operator|&
name|uuid
argument_list|)
expr_stmt|;
return|return
name|uuid_str
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_depth_to_word
parameter_list|(
name|svn_depth_t
name|depth
parameter_list|)
block|{
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
name|svn_depth_exclude
case|:
return|return
literal|"exclude"
return|;
case|case
name|svn_depth_unknown
case|:
return|return
literal|"unknown"
return|;
case|case
name|svn_depth_empty
case|:
return|return
literal|"empty"
return|;
case|case
name|svn_depth_files
case|:
return|return
literal|"files"
return|;
case|case
name|svn_depth_immediates
case|:
return|return
literal|"immediates"
return|;
case|case
name|svn_depth_infinity
case|:
return|return
literal|"infinity"
return|;
default|default:
return|return
literal|"INVALID-DEPTH"
return|;
block|}
block|}
end_function

begin_function
name|svn_depth_t
name|svn_depth_from_word
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"exclude"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_depth_exclude
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"unknown"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_depth_unknown
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"empty"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_depth_empty
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"files"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_depth_files
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"immediates"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_depth_immediates
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"infinity"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_depth_infinity
return|;
comment|/* There's no special value for invalid depth, and no convincing      reason to make one yet, so just fall back to unknown depth.      If you ever change that convention, check callers to make sure      they're not depending on it (e.g., option parsing in main() ).   */
return|return
name|svn_depth_unknown
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_node_kind_to_word
parameter_list|(
name|svn_node_kind_t
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|svn_node_none
case|:
return|return
literal|"none"
return|;
case|case
name|svn_node_file
case|:
return|return
literal|"file"
return|;
case|case
name|svn_node_dir
case|:
return|return
literal|"dir"
return|;
case|case
name|svn_node_symlink
case|:
return|return
literal|"symlink"
return|;
case|case
name|svn_node_unknown
case|:
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_function

begin_function
name|svn_node_kind_t
name|svn_node_kind_from_word
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
if|if
condition|(
name|word
operator|==
name|NULL
condition|)
return|return
name|svn_node_unknown
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_node_none
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_node_file
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"dir"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_node_dir
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"symlink"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_node_symlink
return|;
else|else
comment|/* This also handles word == "unknown" */
return|return
name|svn_node_unknown
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_tristate__to_word
parameter_list|(
name|svn_tristate_t
name|tristate
parameter_list|)
block|{
switch|switch
condition|(
name|tristate
condition|)
block|{
case|case
name|svn_tristate_false
case|:
return|return
literal|"false"
return|;
case|case
name|svn_tristate_true
case|:
return|return
literal|"true"
return|;
case|case
name|svn_tristate_unknown
case|:
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|svn_tristate_t
name|svn_tristate__from_word
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
if|if
condition|(
name|word
operator|==
name|NULL
condition|)
return|return
name|svn_tristate_unknown
return|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"true"
argument_list|)
operator|||
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"yes"
argument_list|)
operator|||
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"on"
argument_list|)
operator|||
literal|0
operator|==
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"1"
argument_list|)
condition|)
return|return
name|svn_tristate_true
return|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"false"
argument_list|)
operator|||
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"no"
argument_list|)
operator|||
literal|0
operator|==
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"off"
argument_list|)
operator|||
literal|0
operator|==
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"0"
argument_list|)
condition|)
return|return
name|svn_tristate_false
return|;
return|return
name|svn_tristate_unknown
return|;
block|}
end_function

begin_function
name|svn_commit_info_t
modifier|*
name|svn_create_commit_info
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_commit_info_t
modifier|*
name|commit_info
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|commit_info
argument_list|)
argument_list|)
decl_stmt|;
name|commit_info
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* All other fields were initialized to NULL above. */
return|return
name|commit_info
return|;
block|}
end_function

begin_function
name|svn_commit_info_t
modifier|*
name|svn_commit_info_dup
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|src_commit_info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_commit_info_t
modifier|*
name|dst_commit_info
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst_commit_info
argument_list|)
argument_list|)
decl_stmt|;
name|dst_commit_info
operator|->
name|date
operator|=
name|src_commit_info
operator|->
name|date
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|src_commit_info
operator|->
name|date
argument_list|)
else|:
name|NULL
expr_stmt|;
name|dst_commit_info
operator|->
name|author
operator|=
name|src_commit_info
operator|->
name|author
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|src_commit_info
operator|->
name|author
argument_list|)
else|:
name|NULL
expr_stmt|;
name|dst_commit_info
operator|->
name|revision
operator|=
name|src_commit_info
operator|->
name|revision
expr_stmt|;
name|dst_commit_info
operator|->
name|post_commit_err
operator|=
name|src_commit_info
operator|->
name|post_commit_err
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|src_commit_info
operator|->
name|post_commit_err
argument_list|)
else|:
name|NULL
expr_stmt|;
name|dst_commit_info
operator|->
name|repos_root
operator|=
name|src_commit_info
operator|->
name|repos_root
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|src_commit_info
operator|->
name|repos_root
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|dst_commit_info
return|;
block|}
end_function

begin_function
name|svn_log_changed_path2_t
modifier|*
name|svn_log_changed_path2_create
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_log_changed_path2_t
modifier|*
name|new_changed_path
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_changed_path
argument_list|)
argument_list|)
decl_stmt|;
name|new_changed_path
operator|->
name|text_modified
operator|=
name|svn_tristate_unknown
expr_stmt|;
name|new_changed_path
operator|->
name|props_modified
operator|=
name|svn_tristate_unknown
expr_stmt|;
return|return
name|new_changed_path
return|;
block|}
end_function

begin_function
name|svn_log_changed_path2_t
modifier|*
name|svn_log_changed_path2_dup
parameter_list|(
specifier|const
name|svn_log_changed_path2_t
modifier|*
name|changed_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_log_changed_path2_t
modifier|*
name|new_changed_path
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_changed_path
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|new_changed_path
operator|=
operator|*
name|changed_path
expr_stmt|;
if|if
condition|(
name|new_changed_path
operator|->
name|copyfrom_path
condition|)
name|new_changed_path
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|new_changed_path
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
return|return
name|new_changed_path
return|;
block|}
end_function

begin_function
name|svn_dirent_t
modifier|*
name|svn_dirent_create
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_dirent_t
modifier|*
name|new_dirent
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_dirent
argument_list|)
argument_list|)
decl_stmt|;
name|new_dirent
operator|->
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|new_dirent
operator|->
name|size
operator|=
name|SVN_INVALID_FILESIZE
expr_stmt|;
name|new_dirent
operator|->
name|created_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|new_dirent
operator|->
name|time
operator|=
literal|0
expr_stmt|;
name|new_dirent
operator|->
name|last_author
operator|=
name|NULL
expr_stmt|;
return|return
name|new_dirent
return|;
block|}
end_function

begin_function
name|svn_dirent_t
modifier|*
name|svn_dirent_dup
parameter_list|(
specifier|const
name|svn_dirent_t
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_dirent_t
modifier|*
name|new_dirent
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_dirent
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|new_dirent
operator|=
operator|*
name|dirent
expr_stmt|;
name|new_dirent
operator|->
name|last_author
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|dirent
operator|->
name|last_author
argument_list|)
expr_stmt|;
return|return
name|new_dirent
return|;
block|}
end_function

begin_function
name|svn_log_entry_t
modifier|*
name|svn_log_entry_create
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_log_entry_t
modifier|*
name|log_entry
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|log_entry
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|log_entry
return|;
block|}
end_function

begin_function
name|svn_log_entry_t
modifier|*
name|svn_log_entry_dup
parameter_list|(
specifier|const
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_log_entry_t
modifier|*
name|new_entry
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|log_entry
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revprops
condition|)
name|new_entry
operator|->
name|revprops
operator|=
name|svn_prop_hash_dup
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|changed_paths2
condition|)
block|{
name|new_entry
operator|->
name|changed_paths2
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|change
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|change
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|new_entry
operator|->
name|changed_paths2
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|key
argument_list|)
argument_list|,
name|svn_log_changed_path2_dup
argument_list|(
name|change
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We can't copy changed_paths by itself without using deprecated code,      but we don't have to, as this function was new after the introduction      of the changed_paths2 field. */
name|new_entry
operator|->
name|changed_paths
operator|=
name|new_entry
operator|->
name|changed_paths2
expr_stmt|;
return|return
name|new_entry
return|;
block|}
end_function

begin_function
name|svn_location_segment_t
modifier|*
name|svn_location_segment_dup
parameter_list|(
specifier|const
name|svn_location_segment_t
modifier|*
name|segment
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_location_segment_t
modifier|*
name|new_segment
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_segment
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|new_segment
operator|=
operator|*
name|segment
expr_stmt|;
if|if
condition|(
name|segment
operator|->
name|path
condition|)
name|new_segment
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|segment
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|new_segment
return|;
block|}
end_function

end_unit

