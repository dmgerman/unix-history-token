begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * quoprint.c:  quoted-printable encoding and decoding functions  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_comment
comment|/* for APR_INLINE */
end_comment

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_quoprint.h"
end_include

begin_comment
comment|/* Caveats:          (1) This code is for the encoding and decoding of binary data             only.  Thus, CRLF sequences are encoded as =0D=0A, and we             don't have to worry about tabs and spaces coming before             hard newlines, since there aren't any.          (2) The decoder does no error reporting, and instead throws             away invalid sequences.  It also discards CRLF sequences,             since those can only appear in the encoding of text data.          (3) The decoder does not strip whitespace at the end of a             line, so it is not actually compliant with RFC 2045.             (Such whitespace should never occur, even in the encoding             of text data, but RFC 2045 requires a decoder to detect             that a transport agent has added trailing whitespace).          (4) The encoder is tailored to make output embeddable in XML,             which means it quotes<>'"& as well as the characters             required by RFC 2045.  */
end_comment

begin_define
define|#
directive|define
name|QUOPRINT_LINELEN
value|76
end_define

begin_define
define|#
directive|define
name|VALID_LITERAL
parameter_list|(
name|c
parameter_list|)
value|((c) == '\t' || ((c)>= ' '&& (c)<= '~' \&& (c) != '='))
end_define

begin_define
define|#
directive|define
name|ENCODE_AS_LITERAL
parameter_list|(
name|c
parameter_list|)
value|(VALID_LITERAL(c)&& (c) != '\t'&& (c) != '<' \&& (c) != '>'&& (c) != '\''&& (c) != '"' \&& (c) != '&')
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hextab
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Binary input --> quoted-printable-encoded output */
end_comment

begin_struct
struct|struct
name|encode_baton
block|{
name|svn_stream_t
modifier|*
name|output
decl_stmt|;
name|int
name|linelen
decl_stmt|;
comment|/* Bytes output so far on this line */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Quoted-printable-encode a byte string which may or may not be the    totality of the data being encoded.  *LINELEN carries the length of    the current output line; initialize it to 0.  Output will be    appended to STR.  */
end_comment

begin_function
specifier|static
name|void
name|encode_bytes
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|int
modifier|*
name|linelen
parameter_list|)
block|{
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Keep encoding three-byte groups until we run out.  */
for|for
control|(
name|p
operator|=
name|data
init|;
name|p
operator|<
name|data
operator|+
name|len
condition|;
name|p
operator|++
control|)
block|{
comment|/* Encode this character.  */
if|if
condition|(
name|ENCODE_AS_LITERAL
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linelen
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'='
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|hextab
index|[
operator|(
operator|*
name|p
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|hextab
index|[
operator|*
name|p
operator|&
literal|0xf
index|]
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
operator|*
name|linelen
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* Make sure our output lines don't exceed QUOPRINT_LINELEN.  */
if|if
condition|(
operator|*
name|linelen
operator|+
literal|3
operator|>
name|QUOPRINT_LINELEN
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|str
argument_list|,
literal|"=\n"
argument_list|)
expr_stmt|;
operator|*
name|linelen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write handler for svn_quoprint_encode.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|encode_data
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|encode_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|encoded
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|subpool
argument_list|)
decl_stmt|;
name|apr_size_t
name|enclen
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* Encode this block of data and write it out.  */
name|encode_bytes
argument_list|(
name|encoded
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|,
operator|&
name|eb
operator|->
name|linelen
argument_list|)
expr_stmt|;
name|enclen
operator|=
name|encoded
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|enclen
operator|!=
literal|0
condition|)
name|err
operator|=
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
name|encoded
operator|->
name|data
argument_list|,
operator|&
name|enclen
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Close handler for svn_quoprint_encode().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|finish_encoding_data
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|encode_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* Terminate the current output line if it's not empty.  */
if|if
condition|(
name|eb
operator|->
name|linelen
operator|>
literal|0
condition|)
block|{
name|len
operator|=
literal|2
expr_stmt|;
name|err
operator|=
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
literal|"=\n"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Pass on the close request and clean up the baton.  */
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
name|err
operator|=
name|svn_stream_close
argument_list|(
name|eb
operator|->
name|output
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_quoprint_encode
parameter_list|(
name|svn_stream_t
modifier|*
name|output
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|struct
name|encode_baton
modifier|*
name|eb
init|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|eb
operator|->
name|output
operator|=
name|output
expr_stmt|;
name|eb
operator|->
name|linelen
operator|=
literal|0
expr_stmt|;
name|eb
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|eb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|encode_data
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|finish_encoding_data
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_quoprint_encode_string
parameter_list|(
specifier|const
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|encoded
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|linelen
init|=
literal|0
decl_stmt|;
name|encode_bytes
argument_list|(
name|encoded
argument_list|,
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|,
operator|&
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|linelen
operator|>
literal|0
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|encoded
argument_list|,
literal|"=\n"
argument_list|)
expr_stmt|;
return|return
name|encoded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Quoted-printable-encoded input --> binary output */
end_comment

begin_struct
struct|struct
name|decode_baton
block|{
name|svn_stream_t
modifier|*
name|output
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
comment|/* Bytes waiting to be decoded */
name|int
name|buflen
decl_stmt|;
comment|/* Number of bytes waiting */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Decode a byte string which may or may not be the total amount of    data being decoded.  INBUF and *INBUFLEN carry the leftover bytes    from call to call.  Have room for four bytes in INBUF and    initialize *INBUFLEN to 0 and *DONE to FALSE.  Output will be    appended to STR.  */
end_comment

begin_function
specifier|static
name|void
name|decode_bytes
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|char
modifier|*
name|inbuf
parameter_list|,
name|int
modifier|*
name|inbuflen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|find1
decl_stmt|,
modifier|*
name|find2
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|p
operator|=
name|data
init|;
name|p
operator|<=
name|data
operator|+
name|len
condition|;
name|p
operator|++
control|)
block|{
comment|/* Append this byte to the buffer and see what we have.  */
name|inbuf
index|[
operator|(
operator|*
name|inbuflen
operator|)
operator|++
index|]
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|inbuf
operator|!=
literal|'='
condition|)
block|{
comment|/* Literal character; append it if it's valid as such.  */
if|if
condition|(
name|VALID_LITERAL
argument_list|(
operator|*
name|inbuf
argument_list|)
condition|)
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
operator|*
name|inbuf
argument_list|)
expr_stmt|;
operator|*
name|inbuflen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|inbuf
operator|==
literal|'='
operator|&&
operator|*
name|inbuflen
operator|==
literal|2
operator|&&
name|inbuf
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* Soft newline; ignore.  */
operator|*
name|inbuflen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|inbuf
operator|==
literal|'='
operator|&&
operator|*
name|inbuflen
operator|==
literal|3
condition|)
block|{
comment|/* Encoded character; decode it and append.  */
name|find1
operator|=
name|strchr
argument_list|(
name|hextab
argument_list|,
name|inbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|find2
operator|=
name|strchr
argument_list|(
name|hextab
argument_list|,
name|inbuf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|find1
operator|!=
name|NULL
operator|&&
name|find2
operator|!=
name|NULL
condition|)
block|{
name|c
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|find1
operator|-
name|hextab
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|find2
operator|-
name|hextab
operator|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|inbuflen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write handler for svn_quoprint_decode.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|decode_data
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|decode_baton
modifier|*
name|db
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|decoded
decl_stmt|;
name|apr_size_t
name|declen
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* Decode this block of data.  */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|decoded
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|decode_bytes
argument_list|(
name|decoded
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|,
name|db
operator|->
name|buf
argument_list|,
operator|&
name|db
operator|->
name|buflen
argument_list|)
expr_stmt|;
comment|/* Write the output, clean up, go home.  */
name|declen
operator|=
name|decoded
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|declen
operator|!=
literal|0
condition|)
name|err
operator|=
name|svn_stream_write
argument_list|(
name|db
operator|->
name|output
argument_list|,
name|decoded
operator|->
name|data
argument_list|,
operator|&
name|declen
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Close handler for svn_quoprint_decode().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|finish_decoding_data
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|decode_baton
modifier|*
name|db
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Pass on the close request and clean up the baton.  */
name|err
operator|=
name|svn_stream_close
argument_list|(
name|db
operator|->
name|output
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_quoprint_decode
parameter_list|(
name|svn_stream_t
modifier|*
name|output
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|struct
name|decode_baton
modifier|*
name|db
init|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|db
operator|->
name|output
operator|=
name|output
expr_stmt|;
name|db
operator|->
name|buflen
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|db
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|decode_data
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|finish_decoding_data
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_quoprint_decode_string
parameter_list|(
specifier|const
name|svn_stringbuf_t
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|decoded
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|char
name|ingroup
index|[
literal|4
index|]
decl_stmt|;
name|int
name|ingrouplen
init|=
literal|0
decl_stmt|;
name|decode_bytes
argument_list|(
name|decoded
argument_list|,
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|,
name|ingroup
argument_list|,
operator|&
name|ingrouplen
argument_list|)
expr_stmt|;
return|return
name|decoded
return|;
block|}
end_function

end_unit

