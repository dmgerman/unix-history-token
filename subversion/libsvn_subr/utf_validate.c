begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * utf_validate.c:  Validate a UTF-8 string  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* Validate a UTF-8 string according to the rules in  *  *    Table 3-6. Well-Formed UTF-8 Bytes Sequences  *  * in  *  *    The Unicode Standard, Version 4.0  *  * which is available at  *  *    http://www.unicode.org/  *  * UTF-8 was originally defined in RFC-2279, Unicode's "well-formed UTF-8"  * is a subset of that enconding.  The Unicode enconding prohibits things  * like non-shortest encodings (some characters can be represented by more  * than one multi-byte encoding) and the encodings for the surrogate code  * points.  RFC-3629 superceeds RFC-2279 and adopts the same well-formed  * rules as Unicode.  This is the ABNF in RFC-3629 that describes  * well-formed UTF-8 rules:  *  *   UTF8-octets = *( UTF8-char )  *   UTF8-char   = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4  *   UTF8-1      = %x00-7F  *   UTF8-2      = %xC2-DF UTF8-tail  *   UTF8-3      = %xE0 %xA0-BF UTF8-tail /  *                 %xE1-EC 2( UTF8-tail ) /  *                 %xED %x80-9F UTF8-tail /  *                 %xEE-EF 2( UTF8-tail )  *   UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) /  *                 %xF1-F3 3( UTF8-tail ) /  *                 %xF4 %x80-8F 2( UTF8-tail )  *   UTF8-tail   = %x80-BF  *  */
end_comment

begin_include
include|#
directive|include
file|"private/svn_utf_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_eol_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_comment
comment|/* Lookup table to categorise each octet in the string. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|octet_category
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x00-0x7f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 0x80-0x8f */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* 0x90-0x9f */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* 0xa0-0xbf */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
comment|/* 0xc0-0xc1 */
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
comment|/* 0xc2-0xdf */
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
comment|/* 0xe0 */
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
comment|/* 0xe1-0xec */
literal|8
block|,
comment|/* 0xed */
literal|9
block|,
literal|9
block|,
comment|/* 0xee-0xef */
literal|10
block|,
comment|/* 0xf0 */
literal|11
block|,
literal|11
block|,
literal|11
block|,
comment|/* 0xf1-0xf3 */
literal|12
block|,
comment|/* 0xf4 */
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
comment|/* 0xf5-0xff */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Machine states */
end_comment

begin_define
define|#
directive|define
name|FSM_START
value|0
end_define

begin_define
define|#
directive|define
name|FSM_80BF
value|1
end_define

begin_define
define|#
directive|define
name|FSM_A0BF
value|2
end_define

begin_define
define|#
directive|define
name|FSM_80BF80BF
value|3
end_define

begin_define
define|#
directive|define
name|FSM_809F
value|4
end_define

begin_define
define|#
directive|define
name|FSM_90BF
value|5
end_define

begin_define
define|#
directive|define
name|FSM_80BF80BF80BF
value|6
end_define

begin_define
define|#
directive|define
name|FSM_808F
value|7
end_define

begin_define
define|#
directive|define
name|FSM_ERROR
value|8
end_define

begin_comment
comment|/* In the FSM it appears that categories 0xc0-0xc1 and 0xf5-0xff make the    same transitions, as do categories 0xe1-0xec and 0xee-0xef.  I wonder if    there is any great benefit in combining categories?  It would reduce the    memory footprint of the transition table by 16 bytes, but might it be    harder to understand?  */
end_comment

begin_comment
comment|/* Machine transition table */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|machine
index|[
literal|9
index|]
index|[
literal|14
index|]
init|=
block|{
comment|/* FSM_START */
block|{
name|FSM_START
block|,
comment|/* 0x00-0x7f */
name|FSM_ERROR
block|,
comment|/* 0x80-0x8f */
name|FSM_ERROR
block|,
comment|/* 0x90-0x9f */
name|FSM_ERROR
block|,
comment|/* 0xa0-0xbf */
name|FSM_ERROR
block|,
comment|/* 0xc0-0xc1 */
name|FSM_80BF
block|,
comment|/* 0xc2-0xdf */
name|FSM_A0BF
block|,
comment|/* 0xe0 */
name|FSM_80BF80BF
block|,
comment|/* 0xe1-0xec */
name|FSM_809F
block|,
comment|/* 0xed */
name|FSM_80BF80BF
block|,
comment|/* 0xee-0xef */
name|FSM_90BF
block|,
comment|/* 0xf0 */
name|FSM_80BF80BF80BF
block|,
comment|/* 0xf1-0xf3 */
name|FSM_808F
block|,
comment|/* 0xf4 */
name|FSM_ERROR
block|}
block|,
comment|/* 0xf5-0xff */
comment|/* FSM_80BF */
block|{
name|FSM_ERROR
block|,
comment|/* 0x00-0x7f */
name|FSM_START
block|,
comment|/* 0x80-0x8f */
name|FSM_START
block|,
comment|/* 0x90-0x9f */
name|FSM_START
block|,
comment|/* 0xa0-0xbf */
name|FSM_ERROR
block|,
comment|/* 0xc0-0xc1 */
name|FSM_ERROR
block|,
comment|/* 0xc2-0xdf */
name|FSM_ERROR
block|,
comment|/* 0xe0 */
name|FSM_ERROR
block|,
comment|/* 0xe1-0xec */
name|FSM_ERROR
block|,
comment|/* 0xed */
name|FSM_ERROR
block|,
comment|/* 0xee-0xef */
name|FSM_ERROR
block|,
comment|/* 0xf0 */
name|FSM_ERROR
block|,
comment|/* 0xf1-0xf3 */
name|FSM_ERROR
block|,
comment|/* 0xf4 */
name|FSM_ERROR
block|}
block|,
comment|/* 0xf5-0xff */
comment|/* FSM_A0BF */
block|{
name|FSM_ERROR
block|,
comment|/* 0x00-0x7f */
name|FSM_ERROR
block|,
comment|/* 0x80-0x8f */
name|FSM_ERROR
block|,
comment|/* 0x90-0x9f */
name|FSM_80BF
block|,
comment|/* 0xa0-0xbf */
name|FSM_ERROR
block|,
comment|/* 0xc0-0xc1 */
name|FSM_ERROR
block|,
comment|/* 0xc2-0xdf */
name|FSM_ERROR
block|,
comment|/* 0xe0 */
name|FSM_ERROR
block|,
comment|/* 0xe1-0xec */
name|FSM_ERROR
block|,
comment|/* 0xed */
name|FSM_ERROR
block|,
comment|/* 0xee-0xef */
name|FSM_ERROR
block|,
comment|/* 0xf0 */
name|FSM_ERROR
block|,
comment|/* 0xf1-0xf3 */
name|FSM_ERROR
block|,
comment|/* 0xf4 */
name|FSM_ERROR
block|}
block|,
comment|/* 0xf5-0xff */
comment|/* FSM_80BF80BF */
block|{
name|FSM_ERROR
block|,
comment|/* 0x00-0x7f */
name|FSM_80BF
block|,
comment|/* 0x80-0x8f */
name|FSM_80BF
block|,
comment|/* 0x90-0x9f */
name|FSM_80BF
block|,
comment|/* 0xa0-0xbf */
name|FSM_ERROR
block|,
comment|/* 0xc0-0xc1 */
name|FSM_ERROR
block|,
comment|/* 0xc2-0xdf */
name|FSM_ERROR
block|,
comment|/* 0xe0 */
name|FSM_ERROR
block|,
comment|/* 0xe1-0xec */
name|FSM_ERROR
block|,
comment|/* 0xed */
name|FSM_ERROR
block|,
comment|/* 0xee-0xef */
name|FSM_ERROR
block|,
comment|/* 0xf0 */
name|FSM_ERROR
block|,
comment|/* 0xf1-0xf3 */
name|FSM_ERROR
block|,
comment|/* 0xf4 */
name|FSM_ERROR
block|}
block|,
comment|/* 0xf5-0xff */
comment|/* FSM_809F */
block|{
name|FSM_ERROR
block|,
comment|/* 0x00-0x7f */
name|FSM_80BF
block|,
comment|/* 0x80-0x8f */
name|FSM_80BF
block|,
comment|/* 0x90-0x9f */
name|FSM_ERROR
block|,
comment|/* 0xa0-0xbf */
name|FSM_ERROR
block|,
comment|/* 0xc0-0xc1 */
name|FSM_ERROR
block|,
comment|/* 0xc2-0xdf */
name|FSM_ERROR
block|,
comment|/* 0xe0 */
name|FSM_ERROR
block|,
comment|/* 0xe1-0xec */
name|FSM_ERROR
block|,
comment|/* 0xed */
name|FSM_ERROR
block|,
comment|/* 0xee-0xef */
name|FSM_ERROR
block|,
comment|/* 0xf0 */
name|FSM_ERROR
block|,
comment|/* 0xf1-0xf3 */
name|FSM_ERROR
block|,
comment|/* 0xf4 */
name|FSM_ERROR
block|}
block|,
comment|/* 0xf5-0xff */
comment|/* FSM_90BF */
block|{
name|FSM_ERROR
block|,
comment|/* 0x00-0x7f */
name|FSM_ERROR
block|,
comment|/* 0x80-0x8f */
name|FSM_80BF80BF
block|,
comment|/* 0x90-0x9f */
name|FSM_80BF80BF
block|,
comment|/* 0xa0-0xbf */
name|FSM_ERROR
block|,
comment|/* 0xc0-0xc1 */
name|FSM_ERROR
block|,
comment|/* 0xc2-0xdf */
name|FSM_ERROR
block|,
comment|/* 0xe0 */
name|FSM_ERROR
block|,
comment|/* 0xe1-0xec */
name|FSM_ERROR
block|,
comment|/* 0xed */
name|FSM_ERROR
block|,
comment|/* 0xee-0xef */
name|FSM_ERROR
block|,
comment|/* 0xf0 */
name|FSM_ERROR
block|,
comment|/* 0xf1-0xf3 */
name|FSM_ERROR
block|,
comment|/* 0xf4 */
name|FSM_ERROR
block|}
block|,
comment|/* 0xf5-0xff */
comment|/* FSM_80BF80BF80BF */
block|{
name|FSM_ERROR
block|,
comment|/* 0x00-0x7f */
name|FSM_80BF80BF
block|,
comment|/* 0x80-0x8f */
name|FSM_80BF80BF
block|,
comment|/* 0x90-0x9f */
name|FSM_80BF80BF
block|,
comment|/* 0xa0-0xbf */
name|FSM_ERROR
block|,
comment|/* 0xc0-0xc1 */
name|FSM_ERROR
block|,
comment|/* 0xc2-0xdf */
name|FSM_ERROR
block|,
comment|/* 0xe0 */
name|FSM_ERROR
block|,
comment|/* 0xe1-0xec */
name|FSM_ERROR
block|,
comment|/* 0xed */
name|FSM_ERROR
block|,
comment|/* 0xee-0xef */
name|FSM_ERROR
block|,
comment|/* 0xf0 */
name|FSM_ERROR
block|,
comment|/* 0xf1-0xf3 */
name|FSM_ERROR
block|,
comment|/* 0xf4 */
name|FSM_ERROR
block|}
block|,
comment|/* 0xf5-0xff */
comment|/* FSM_808F */
block|{
name|FSM_ERROR
block|,
comment|/* 0x00-0x7f */
name|FSM_80BF80BF
block|,
comment|/* 0x80-0x8f */
name|FSM_ERROR
block|,
comment|/* 0x90-0x9f */
name|FSM_ERROR
block|,
comment|/* 0xa0-0xbf */
name|FSM_ERROR
block|,
comment|/* 0xc0-0xc1 */
name|FSM_ERROR
block|,
comment|/* 0xc2-0xdf */
name|FSM_ERROR
block|,
comment|/* 0xe0 */
name|FSM_ERROR
block|,
comment|/* 0xe1-0xec */
name|FSM_ERROR
block|,
comment|/* 0xed */
name|FSM_ERROR
block|,
comment|/* 0xee-0xef */
name|FSM_ERROR
block|,
comment|/* 0xf0 */
name|FSM_ERROR
block|,
comment|/* 0xf1-0xf3 */
name|FSM_ERROR
block|,
comment|/* 0xf4 */
name|FSM_ERROR
block|}
block|,
comment|/* 0xf5-0xff */
comment|/* FSM_ERROR */
block|{
name|FSM_ERROR
block|,
comment|/* 0x00-0x7f */
name|FSM_ERROR
block|,
comment|/* 0x80-0x8f */
name|FSM_ERROR
block|,
comment|/* 0x90-0x9f */
name|FSM_ERROR
block|,
comment|/* 0xa0-0xbf */
name|FSM_ERROR
block|,
comment|/* 0xc0-0xc1 */
name|FSM_ERROR
block|,
comment|/* 0xc2-0xdf */
name|FSM_ERROR
block|,
comment|/* 0xe0 */
name|FSM_ERROR
block|,
comment|/* 0xe1-0xec */
name|FSM_ERROR
block|,
comment|/* 0xed */
name|FSM_ERROR
block|,
comment|/* 0xee-0xef */
name|FSM_ERROR
block|,
comment|/* 0xf0 */
name|FSM_ERROR
block|,
comment|/* 0xf1-0xf3 */
name|FSM_ERROR
block|,
comment|/* 0xf4 */
name|FSM_ERROR
block|}
block|,
comment|/* 0xf5-0xff */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan MAX_LEN bytes in *DATA for chars that are not in the octet  * category 0 (FSM_START).  Return the position of the first such char  * or DATA + MAX_LEN if all were cat 0.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|first_non_fsm_start_char
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|max_len
parameter_list|)
block|{
if|#
directive|if
operator|!
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* On some systems, we need to make sure that buf is properly aligned    * for chunky data access.    */
if|if
condition|(
operator|(
name|apr_uintptr_t
operator|)
name|data
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|apr_size_t
name|len
init|=
operator|(
operator|~
operator|(
name|apr_uintptr_t
operator|)
name|data
operator|)
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
name|len
operator|=
name|max_len
expr_stmt|;
name|max_len
operator|-=
name|len
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|++
name|data
operator|,
operator|--
name|len
control|)
if|if
condition|(
operator|*
name|data
operator|<
literal|0
operator|||
operator|*
name|data
operator|>=
literal|0x80
condition|)
return|return
name|data
return|;
block|}
endif|#
directive|endif
comment|/* Scan the input one machine word at a time. */
for|for
control|(
init|;
name|max_len
operator|>
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
condition|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
operator|,
name|max_len
operator|-=
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
control|)
if|if
condition|(
operator|*
operator|(
specifier|const
name|apr_uintptr_t
operator|*
operator|)
name|data
operator|&
name|SVN__BIT_7_SET
condition|)
break|break;
comment|/* The remaining odd bytes will be examined the naive way: */
for|for
control|(
init|;
name|max_len
operator|>
literal|0
condition|;
operator|++
name|data
operator|,
operator|--
name|max_len
control|)
if|if
condition|(
operator|*
name|data
operator|<
literal|0
operator|||
operator|*
name|data
operator|>=
literal|0x80
condition|)
break|break;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/* Scan the C string in *DATA for chars that are not in the octet  * category 0 (FSM_START).  Return the position of either the such  * char or of the terminating NUL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|first_non_fsm_start_char_cstring
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
comment|/* We need to make sure that BUF is properly aligned for chunky data    * access because we don't know the string's length. Unaligned chunk    * read access beyond the NUL terminator could therefore result in a    * segfault.    */
for|for
control|(
init|;
operator|(
name|apr_uintptr_t
operator|)
name|data
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
operator|-
literal|1
operator|)
condition|;
operator|++
name|data
control|)
if|if
condition|(
operator|*
name|data
operator|<=
literal|0
operator|||
operator|*
name|data
operator|>=
literal|0x80
condition|)
return|return
name|data
return|;
comment|/* Scan the input one machine word at a time. */
ifndef|#
directive|ifndef
name|SVN_UTF_NO_UNINITIALISED_ACCESS
comment|/* This may read allocated but initialised bytes beyond the      terminating null.  Any such bytes are always readable and this      code operates correctly whatever the uninitialised values happen      to be.  However memory checking tools such as valgrind and GCC      4.8's address santitizer will object so this bit of code can be      disabled at compile time. */
for|for
control|(
init|;
condition|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|apr_uintptr_t
argument_list|)
control|)
block|{
comment|/* Check for non-ASCII chars: */
name|apr_uintptr_t
name|chunk
init|=
operator|*
operator|(
specifier|const
name|apr_uintptr_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|chunk
operator|&
name|SVN__BIT_7_SET
condition|)
break|break;
comment|/* This is the well-known strlen test: */
name|chunk
operator||=
operator|(
name|chunk
operator|&
name|SVN__LOWER_7BITS_SET
operator|)
operator|+
name|SVN__LOWER_7BITS_SET
expr_stmt|;
if|if
condition|(
operator|(
name|chunk
operator|&
name|SVN__BIT_7_SET
operator|)
operator|!=
name|SVN__BIT_7_SET
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* The remaining odd bytes will be examined the naive way: */
for|for
control|(
init|;
condition|;
operator|++
name|data
control|)
if|if
condition|(
operator|*
name|data
operator|<=
literal|0
operator|||
operator|*
name|data
operator|>=
literal|0x80
condition|)
break|break;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_utf__last_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
name|first_non_fsm_start_char
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
name|int
name|state
init|=
name|FSM_START
decl_stmt|;
name|data
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|data
operator|<
name|end
condition|)
block|{
name|unsigned
name|char
name|octet
init|=
operator|*
name|data
operator|++
decl_stmt|;
name|int
name|category
init|=
name|octet_category
index|[
name|octet
index|]
decl_stmt|;
name|state
operator|=
name|machine
index|[
name|state
index|]
index|[
name|category
index|]
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|FSM_START
condition|)
name|start
operator|=
name|data
expr_stmt|;
block|}
return|return
name|start
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_utf__cstring_is_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|state
init|=
name|FSM_START
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|FALSE
return|;
name|data
operator|=
name|first_non_fsm_start_char_cstring
argument_list|(
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|data
condition|)
block|{
name|unsigned
name|char
name|octet
init|=
operator|*
name|data
operator|++
decl_stmt|;
name|int
name|category
init|=
name|octet_category
index|[
name|octet
index|]
decl_stmt|;
name|state
operator|=
name|machine
index|[
name|state
index|]
index|[
name|category
index|]
expr_stmt|;
block|}
return|return
name|state
operator|==
name|FSM_START
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_utf__is_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
name|int
name|state
init|=
name|FSM_START
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|FALSE
return|;
name|data
operator|=
name|first_non_fsm_start_char
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|data
operator|<
name|end
condition|)
block|{
name|unsigned
name|char
name|octet
init|=
operator|*
name|data
operator|++
decl_stmt|;
name|int
name|category
init|=
name|octet_category
index|[
name|octet
index|]
decl_stmt|;
name|state
operator|=
name|machine
index|[
name|state
index|]
index|[
name|category
index|]
expr_stmt|;
block|}
return|return
name|state
operator|==
name|FSM_START
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_utf__last_valid2
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
name|first_non_fsm_start_char
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
name|int
name|state
init|=
name|FSM_START
decl_stmt|;
name|data
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|data
operator|<
name|end
condition|)
block|{
name|unsigned
name|char
name|octet
init|=
operator|*
name|data
operator|++
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|FSM_START
case|:
if|if
condition|(
name|octet
operator|<=
literal|0x7F
condition|)
break|break;
elseif|else
if|if
condition|(
name|octet
operator|<=
literal|0xC1
condition|)
name|state
operator|=
name|FSM_ERROR
expr_stmt|;
elseif|else
if|if
condition|(
name|octet
operator|<=
literal|0xDF
condition|)
name|state
operator|=
name|FSM_80BF
expr_stmt|;
elseif|else
if|if
condition|(
name|octet
operator|==
literal|0xE0
condition|)
name|state
operator|=
name|FSM_A0BF
expr_stmt|;
elseif|else
if|if
condition|(
name|octet
operator|<=
literal|0xEC
condition|)
name|state
operator|=
name|FSM_80BF80BF
expr_stmt|;
elseif|else
if|if
condition|(
name|octet
operator|==
literal|0xED
condition|)
name|state
operator|=
name|FSM_809F
expr_stmt|;
elseif|else
if|if
condition|(
name|octet
operator|<=
literal|0xEF
condition|)
name|state
operator|=
name|FSM_80BF80BF
expr_stmt|;
elseif|else
if|if
condition|(
name|octet
operator|==
literal|0xF0
condition|)
name|state
operator|=
name|FSM_90BF
expr_stmt|;
elseif|else
if|if
condition|(
name|octet
operator|<=
literal|0xF3
condition|)
name|state
operator|=
name|FSM_80BF80BF80BF
expr_stmt|;
elseif|else
if|if
condition|(
name|octet
operator|<=
literal|0xF4
condition|)
name|state
operator|=
name|FSM_808F
expr_stmt|;
else|else
name|state
operator|=
name|FSM_ERROR
expr_stmt|;
break|break;
case|case
name|FSM_80BF
case|:
if|if
condition|(
name|octet
operator|>=
literal|0x80
operator|&&
name|octet
operator|<=
literal|0xBF
condition|)
name|state
operator|=
name|FSM_START
expr_stmt|;
else|else
name|state
operator|=
name|FSM_ERROR
expr_stmt|;
break|break;
case|case
name|FSM_A0BF
case|:
if|if
condition|(
name|octet
operator|>=
literal|0xA0
operator|&&
name|octet
operator|<=
literal|0xBF
condition|)
name|state
operator|=
name|FSM_80BF
expr_stmt|;
else|else
name|state
operator|=
name|FSM_ERROR
expr_stmt|;
break|break;
case|case
name|FSM_80BF80BF
case|:
if|if
condition|(
name|octet
operator|>=
literal|0x80
operator|&&
name|octet
operator|<=
literal|0xBF
condition|)
name|state
operator|=
name|FSM_80BF
expr_stmt|;
else|else
name|state
operator|=
name|FSM_ERROR
expr_stmt|;
break|break;
case|case
name|FSM_809F
case|:
if|if
condition|(
name|octet
operator|>=
literal|0x80
operator|&&
name|octet
operator|<=
literal|0x9F
condition|)
name|state
operator|=
name|FSM_80BF
expr_stmt|;
else|else
name|state
operator|=
name|FSM_ERROR
expr_stmt|;
break|break;
case|case
name|FSM_90BF
case|:
if|if
condition|(
name|octet
operator|>=
literal|0x90
operator|&&
name|octet
operator|<=
literal|0xBF
condition|)
name|state
operator|=
name|FSM_80BF80BF
expr_stmt|;
else|else
name|state
operator|=
name|FSM_ERROR
expr_stmt|;
break|break;
case|case
name|FSM_80BF80BF80BF
case|:
if|if
condition|(
name|octet
operator|>=
literal|0x80
operator|&&
name|octet
operator|<=
literal|0xBF
condition|)
name|state
operator|=
name|FSM_80BF80BF
expr_stmt|;
else|else
name|state
operator|=
name|FSM_ERROR
expr_stmt|;
break|break;
case|case
name|FSM_808F
case|:
if|if
condition|(
name|octet
operator|>=
literal|0x80
operator|&&
name|octet
operator|<=
literal|0x8F
condition|)
name|state
operator|=
name|FSM_80BF80BF
expr_stmt|;
else|else
name|state
operator|=
name|FSM_ERROR
expr_stmt|;
break|break;
default|default:
case|case
name|FSM_ERROR
case|:
return|return
name|start
return|;
block|}
if|if
condition|(
name|state
operator|==
name|FSM_START
condition|)
name|start
operator|=
name|data
expr_stmt|;
block|}
return|return
name|start
return|;
block|}
end_function

end_unit

