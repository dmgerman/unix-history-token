begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svn_temp_serializer.c: implement the tempoary structure serialization API  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_comment
comment|/* This is a very efficient serialization and especially efficient  * deserialization framework. The idea is just to concatenate all sub-  * structures and strings into a single buffer while preserving proper  * member alignment. Pointers will be replaced by the respective data  * offsets in the buffer when that target that it pointed to gets  * serialized, i.e. appended to the data buffer written so far.  *  * Hence, deserialization can be simply done by copying the buffer and  * adjusting the pointers. No fine-grained allocation and copying is  * necessary.  */
end_comment

begin_comment
comment|/* An element in the structure stack. It contains a pointer to the source  * structure so that the relative offset of sub-structure or string  * references can be determined properly. It also contains the corresponding  * position within the serialized data. Thus, pointers can be serialized  * as offsets within the target buffer.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|source_stack_t
block|{
comment|/* the source structure passed in to *_init or *_push */
specifier|const
name|void
modifier|*
name|source_struct
decl_stmt|;
comment|/* offset within the target buffer to where the structure got copied */
name|apr_size_t
name|target_offset
decl_stmt|;
comment|/* parent stack entry. Will be NULL for the root entry.    * Items in the svn_temp_serializer__context_t recycler will use this    * to link to the next unused item. */
name|struct
name|source_stack_t
modifier|*
name|upper
decl_stmt|;
block|}
name|source_stack_t
typedef|;
end_typedef

begin_comment
comment|/* Serialization context info. It basically consists of the buffer holding  * the serialized result and the stack of source structure information.  */
end_comment

begin_struct
struct|struct
name|svn_temp_serializer__context_t
block|{
comment|/* allocations are made from this pool */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* the buffer holding all serialized data */
name|svn_stringbuf_t
modifier|*
name|buffer
decl_stmt|;
comment|/* the stack of structures being serialized. If NULL, the serialization    * process has been finished. However, it is not necessarily NULL when    * the application end serialization. */
name|source_stack_t
modifier|*
name|source
decl_stmt|;
comment|/* unused stack elements will be put here for later reuse. */
name|source_stack_t
modifier|*
name|recycler
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make sure the serialized data len is a multiple of the default alignment,  * i.e. structures may be appended without violating member alignment  * guarantees.  */
end_comment

begin_function
specifier|static
name|void
name|align_buffer_end
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|)
block|{
name|apr_size_t
name|current_len
init|=
name|context
operator|->
name|buffer
operator|->
name|len
decl_stmt|;
name|apr_size_t
name|aligned_len
init|=
name|APR_ALIGN_DEFAULT
argument_list|(
name|current_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|aligned_len
operator|+
literal|1
operator|>
name|context
operator|->
name|buffer
operator|->
name|blocksize
condition|)
name|svn_stringbuf_ensure
argument_list|(
name|context
operator|->
name|buffer
argument_list|,
name|aligned_len
argument_list|)
expr_stmt|;
name|context
operator|->
name|buffer
operator|->
name|len
operator|=
name|aligned_len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin the serialization process for the SOURCE_STRUCT and all objects  * referenced from it. STRUCT_SIZE must match the result of sizeof() of  * the actual structure. You may suggest a larger initial buffer size  * in SUGGESTED_BUFFER_SIZE to minimize the number of internal buffer  * re-allocations during the serialization process. All allocations will  * be made from POOL.  */
end_comment

begin_function
name|svn_temp_serializer__context_t
modifier|*
name|svn_temp_serializer__init
parameter_list|(
specifier|const
name|void
modifier|*
name|source_struct
parameter_list|,
name|apr_size_t
name|struct_size
parameter_list|,
name|apr_size_t
name|suggested_buffer_size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* select a meaningful initial memory buffer capacity */
name|apr_size_t
name|init_size
init|=
name|suggested_buffer_size
operator|<
name|struct_size
condition|?
name|struct_size
else|:
name|suggested_buffer_size
decl_stmt|;
comment|/* create the serialization context and initialize it */
name|svn_temp_serializer__context_t
modifier|*
name|context
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
argument_list|)
argument_list|)
decl_stmt|;
name|context
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|context
operator|->
name|buffer
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|init_size
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|context
operator|->
name|recycler
operator|=
name|NULL
expr_stmt|;
comment|/* If a source struct has been given, make it the root struct. */
if|if
condition|(
name|source_struct
condition|)
block|{
name|context
operator|->
name|source
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
operator|->
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|source
operator|->
name|source_struct
operator|=
name|source_struct
expr_stmt|;
name|context
operator|->
name|source
operator|->
name|target_offset
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|source
operator|->
name|upper
operator|=
name|NULL
expr_stmt|;
comment|/* serialize, i.e. append, the content of the first structure */
name|svn_stringbuf_appendbytes
argument_list|(
name|context
operator|->
name|buffer
argument_list|,
name|source_struct
argument_list|,
name|struct_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The root struct will be set with the first push() op, or not at all        * (in case of a plain string). */
name|context
operator|->
name|source
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* done */
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* Continue the serialization process of the SOURCE_STRUCT that has already  * been serialized to BUFFER but contains references to new objects yet to  * serialize. The current size of the serialized data is given in  * CURRENTLY_USED. If the allocated data buffer is actually larger, you may  * specifiy that in CURRENTLY_ALLOCATED to prevent unnecessary allocations.  * Otherwise, set it to 0. All allocations will be made from POOl.  */
end_comment

begin_function
name|svn_temp_serializer__context_t
modifier|*
name|svn_temp_serializer__init_append
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|void
modifier|*
name|source_struct
parameter_list|,
name|apr_size_t
name|currently_used
parameter_list|,
name|apr_size_t
name|currently_allocated
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* determine the current memory buffer capacity */
name|apr_size_t
name|init_size
init|=
name|currently_allocated
operator|<
name|currently_used
condition|?
name|currently_used
else|:
name|currently_allocated
decl_stmt|;
comment|/* create the serialization context and initialize it */
name|svn_temp_serializer__context_t
modifier|*
name|context
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
argument_list|)
argument_list|)
decl_stmt|;
name|context
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* use BUFFER as serialization target */
name|context
operator|->
name|buffer
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|context
operator|->
name|buffer
operator|->
name|data
operator|=
name|buffer
expr_stmt|;
name|context
operator|->
name|buffer
operator|->
name|len
operator|=
name|currently_used
expr_stmt|;
name|context
operator|->
name|buffer
operator|->
name|blocksize
operator|=
name|init_size
expr_stmt|;
comment|/* SOURCE_STRUCT is our serialization root */
name|context
operator|->
name|source
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
operator|->
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|source
operator|->
name|source_struct
operator|=
name|source_struct
expr_stmt|;
name|context
operator|->
name|source
operator|->
name|target_offset
operator|=
operator|(
name|char
operator|*
operator|)
name|source_struct
operator|-
operator|(
name|char
operator|*
operator|)
name|buffer
expr_stmt|;
name|context
operator|->
name|source
operator|->
name|upper
operator|=
name|NULL
expr_stmt|;
comment|/* initialize the RECYCLER */
name|context
operator|->
name|recycler
operator|=
name|NULL
expr_stmt|;
comment|/* done */
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* Utility function replacing the serialized pointer corresponding to  * *SOURCE_POINTER with the offset that it will be put when being append  * right after this function call.  */
end_comment

begin_function
specifier|static
name|void
name|store_current_end_pointer
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|source_pointer
parameter_list|)
block|{
name|apr_size_t
name|ptr_offset
decl_stmt|;
name|apr_size_t
modifier|*
name|target_ptr
decl_stmt|;
comment|/* if *source_pointer is the root struct, there will be no parent structure    * to relate it to */
if|if
condition|(
name|context
operator|->
name|source
operator|==
name|NULL
condition|)
return|return;
comment|/* position of the serialized pointer relative to the begin of the buffer */
name|ptr_offset
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|source_pointer
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|context
operator|->
name|source
operator|->
name|source_struct
operator|+
name|context
operator|->
name|source
operator|->
name|target_offset
expr_stmt|;
comment|/* the offset must be within the serialized data. Otherwise, you forgot    * to serialize the respective sub-struct. */
name|assert
argument_list|(
name|context
operator|->
name|buffer
operator|->
name|len
operator|>
name|ptr_offset
argument_list|)
expr_stmt|;
comment|/* use the serialized pointer as a storage for the offset */
name|target_ptr
operator|=
operator|(
name|apr_size_t
operator|*
operator|)
operator|(
name|context
operator|->
name|buffer
operator|->
name|data
operator|+
name|ptr_offset
operator|)
expr_stmt|;
comment|/* store the current buffer length because that's where we will append    * the serialized data of the sub-struct or string */
operator|*
name|target_ptr
operator|=
operator|*
name|source_pointer
operator|==
name|NULL
condition|?
literal|0
else|:
name|context
operator|->
name|buffer
operator|->
name|len
operator|-
name|context
operator|->
name|source
operator|->
name|target_offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin serialization of a referenced sub-structure within the  * serialization CONTEXT. SOURCE_STRUCT must be a reference to the pointer  * in the original parent structure so that the correspondence in the  * serialized structure can be established. STRUCT_SIZE must match the  * result of sizeof() of the actual structure.  */
end_comment

begin_function
name|void
name|svn_temp_serializer__push
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|source_struct
parameter_list|,
name|apr_size_t
name|struct_size
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|source
init|=
operator|*
name|source_struct
decl_stmt|;
name|source_stack_t
modifier|*
name|new
decl_stmt|;
comment|/* recycle an old entry or create a new one for the structure stack */
if|if
condition|(
name|context
operator|->
name|recycler
condition|)
block|{
name|new
operator|=
name|context
operator|->
name|recycler
expr_stmt|;
name|context
operator|->
name|recycler
operator|=
name|new
operator|->
name|upper
expr_stmt|;
block|}
else|else
name|new
operator|=
name|apr_palloc
argument_list|(
name|context
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the serialized structure must be properly aligned */
if|if
condition|(
name|source
condition|)
name|align_buffer_end
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* Store the offset at which the struct data that will the appended.    * Write 0 for NULL pointers. */
name|store_current_end_pointer
argument_list|(
name|context
argument_list|,
name|source_struct
argument_list|)
expr_stmt|;
comment|/* store source and target information */
name|new
operator|->
name|source_struct
operator|=
name|source
expr_stmt|;
name|new
operator|->
name|target_offset
operator|=
name|context
operator|->
name|buffer
operator|->
name|len
expr_stmt|;
comment|/* put the new entry onto the stack*/
name|new
operator|->
name|upper
operator|=
name|context
operator|->
name|source
expr_stmt|;
name|context
operator|->
name|source
operator|=
name|new
expr_stmt|;
comment|/* finally, actually append the new struct    * (so we can now manipulate pointers within it) */
if|if
condition|(
operator|*
name|source_struct
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|context
operator|->
name|buffer
argument_list|,
name|source
argument_list|,
name|struct_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the lastest structure from the stack.  */
end_comment

begin_function
name|void
name|svn_temp_serializer__pop
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|)
block|{
name|source_stack_t
modifier|*
name|old
init|=
name|context
operator|->
name|source
decl_stmt|;
comment|/* we may pop the original struct but not further */
name|assert
argument_list|(
name|context
operator|->
name|source
argument_list|)
expr_stmt|;
comment|/* one level up the structure stack */
name|context
operator|->
name|source
operator|=
name|context
operator|->
name|source
operator|->
name|upper
expr_stmt|;
comment|/* put the old stack element into the recycler for later reuse */
name|old
operator|->
name|upper
operator|=
name|context
operator|->
name|recycler
expr_stmt|;
name|context
operator|->
name|recycler
operator|=
name|old
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_temp_serializer__add_leaf
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|source_struct
parameter_list|,
name|apr_size_t
name|struct_size
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|source
init|=
operator|*
name|source_struct
decl_stmt|;
comment|/* the serialized structure must be properly aligned */
if|if
condition|(
name|source
condition|)
name|align_buffer_end
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* Store the offset at which the struct data that will the appended.    * Write 0 for NULL pointers. */
name|store_current_end_pointer
argument_list|(
name|context
argument_list|,
name|source_struct
argument_list|)
expr_stmt|;
comment|/* finally, actually append the struct contents */
if|if
condition|(
operator|*
name|source_struct
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|context
operator|->
name|buffer
argument_list|,
name|source
argument_list|,
name|struct_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Serialize a string referenced from the current structure within the  * serialization CONTEXT. S must be a reference to the char* pointer in  * the original structure so that the correspondence in the serialized  * structure can be established.  */
end_comment

begin_function
name|void
name|svn_temp_serializer__add_string
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
operator|*
name|s
decl_stmt|;
comment|/* Store the offset at which the string data that will the appended.    * Write 0 for NULL pointers. Strings don't need special alignment. */
name|store_current_end_pointer
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
comment|/* append the string data */
if|if
condition|(
name|string
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|context
operator|->
name|buffer
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the serialized representation of the pointer PTR inside the current  * structure within the serialization CONTEXT to NULL. This is particularly  * useful if the pointer is not NULL in the source structure.  */
end_comment

begin_function
name|void
name|svn_temp_serializer__set_null
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|ptr
parameter_list|)
block|{
name|apr_size_t
name|offset
decl_stmt|;
comment|/* there must be a parent structure */
name|assert
argument_list|(
name|context
operator|->
name|source
argument_list|)
expr_stmt|;
comment|/* position of the serialized pointer relative to the begin of the buffer */
name|offset
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|ptr
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|context
operator|->
name|source
operator|->
name|source_struct
operator|+
name|context
operator|->
name|source
operator|->
name|target_offset
expr_stmt|;
comment|/* the offset must be within the serialized data. Otherwise, you forgot    * to serialize the respective sub-struct. */
name|assert
argument_list|(
name|context
operator|->
name|buffer
operator|->
name|len
operator|>
name|offset
argument_list|)
expr_stmt|;
comment|/* use the serialized pointer as a storage for the offset */
operator|*
operator|(
name|apr_size_t
operator|*
operator|)
operator|(
name|context
operator|->
name|buffer
operator|->
name|data
operator|+
name|offset
operator|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes currently used in the serialization buffer  * of the given serialization CONTEXT.*/
end_comment

begin_function
name|apr_size_t
name|svn_temp_serializer__get_length
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|buffer
operator|->
name|len
return|;
block|}
end_function

begin_comment
comment|/* Return the data buffer that receives the serialized data from  * the given serialization CONTEXT.  */
end_comment

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_temp_serializer__get
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Replace the deserialized pointer value at PTR inside BUFFER with a  * proper pointer value.  */
end_comment

begin_function
name|void
name|svn_temp_deserializer__resolve
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|void
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
comment|/* All pointers are stored as offsets to the buffer start    * (of the respective serialized sub-struct). */
name|apr_size_t
name|ptr_offset
init|=
operator|*
operator|(
name|apr_size_t
operator|*
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr_offset
condition|)
block|{
comment|/* Reconstruct the original pointer value */
specifier|const
name|char
modifier|*
name|target
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buffer
operator|+
name|ptr_offset
decl_stmt|;
comment|/* All sub-structs are written _after_ their respective parent.        * Thus, all offsets are> 0. If the following assertion is not met,        * the data is either corrupt or you tried to resolve the pointer        * more than once. */
name|assert
argument_list|(
name|target
operator|>
operator|(
specifier|const
name|char
operator|*
operator|)
name|buffer
argument_list|)
expr_stmt|;
comment|/* replace the PTR_OFFSET in *ptr with the pointer to TARGET */
operator|(
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|ptr
operator|)
operator|=
name|target
expr_stmt|;
block|}
else|else
block|{
comment|/* NULL pointers are stored as 0 which might have a different        * binary representation. */
operator|*
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|void
modifier|*
name|svn_temp_deserializer__ptr
parameter_list|(
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
name|apr_size_t
operator|)
operator|*
name|ptr
operator|==
literal|0
condition|?
name|NULL
else|:
operator|(
specifier|const
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|apr_size_t
operator|)
operator|*
name|ptr
return|;
block|}
end_function

end_unit

