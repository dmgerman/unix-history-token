begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * cache-memcache.c: memcached caching for Subversion  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_base64.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cache.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_MEMCACHE
end_ifdef

begin_include
include|#
directive|include
file|<apr_memcache.h>
end_include

begin_comment
comment|/* A note on thread safety:     The apr_memcache_t object does its own mutex handling, and nothing    else in memcache_t is ever modified, so this implementation should    be fully thread-safe. */
end_comment

begin_comment
comment|/* The (internal) cache object. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|memcache_t
block|{
comment|/* The memcached server set we're using. */
name|apr_memcache_t
modifier|*
name|memcache
decl_stmt|;
comment|/* A prefix used to differentiate our data from any other data in    * the memcached (URI-encoded). */
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* The size of the key: either a fixed number of bytes or    * APR_HASH_KEY_STRING. */
name|apr_ssize_t
name|klen
decl_stmt|;
comment|/* Used to marshal values in and out of the cache. */
name|svn_cache__serialize_func_t
name|serialize_func
decl_stmt|;
name|svn_cache__deserialize_func_t
name|deserialize_func
decl_stmt|;
block|}
name|memcache_t
typedef|;
end_typedef

begin_comment
comment|/* The wrapper around apr_memcache_t. */
end_comment

begin_struct
struct|struct
name|svn_memcache_t
block|{
name|apr_memcache_t
modifier|*
name|c
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The memcached protocol says the maximum key length is 250.  Let's    just say 249, to be safe. */
end_comment

begin_define
define|#
directive|define
name|MAX_MEMCACHED_KEY_LEN
value|249
end_define

begin_define
define|#
directive|define
name|MEMCACHED_KEY_UNHASHED_LEN
value|(MAX_MEMCACHED_KEY_LEN - \                                     2 * APR_MD5_DIGESTSIZE)
end_define

begin_comment
comment|/* Set *MC_KEY to a memcache key for the given key KEY for CACHE, allocated    in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|build_key
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|mc_key
parameter_list|,
name|memcache_t
modifier|*
name|cache
parameter_list|,
specifier|const
name|void
modifier|*
name|raw_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|encoded_suffix
decl_stmt|;
specifier|const
name|char
modifier|*
name|long_key
decl_stmt|;
name|apr_size_t
name|long_key_len
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|klen
operator|==
name|APR_HASH_KEY_STRING
condition|)
name|encoded_suffix
operator|=
name|svn_path_uri_encode
argument_list|(
name|raw_key
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|svn_string_t
modifier|*
name|raw
init|=
name|svn_string_ncreate
argument_list|(
name|raw_key
argument_list|,
name|cache
operator|->
name|klen
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|encoded
init|=
name|svn_base64_encode_string2
argument_list|(
name|raw
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|encoded_suffix
operator|=
name|encoded
operator|->
name|data
expr_stmt|;
block|}
name|long_key
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"SVN:"
argument_list|,
name|cache
operator|->
name|prefix
argument_list|,
literal|":"
argument_list|,
name|encoded_suffix
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|long_key_len
operator|=
name|strlen
argument_list|(
name|long_key
argument_list|)
expr_stmt|;
comment|/* We don't want to have a key that's too big.  If it was going to      be too big, we MD5 the entire string, then replace the last bit      with the checksum.  Note that APR_MD5_DIGESTSIZE is for the pure      binary digest; we have to double that when we convert to hex.       Every key we use will either be at most      MEMCACHED_KEY_UNHASHED_LEN bytes long, or be exactly      MAX_MEMCACHED_KEY_LEN bytes long. */
if|if
condition|(
name|long_key_len
operator|>
name|MEMCACHED_KEY_UNHASHED_LEN
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|long_key
argument_list|,
name|long_key_len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|long_key
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|long_key
argument_list|,
name|MEMCACHED_KEY_UNHASHED_LEN
argument_list|)
argument_list|,
name|svn_checksum_to_cstring_display
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|mc_key
operator|=
name|long_key
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Core functionality of our getter functions: fetch DATA from the memcached  * given by CACHE_VOID and identified by KEY. Indicate success in FOUND and  * use a tempoary sub-pool of POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|memcache_internal_get
parameter_list|(
name|char
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|size
parameter_list|,
name|svn_boolean_t
modifier|*
name|found
parameter_list|,
name|void
modifier|*
name|cache_void
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|memcache_t
modifier|*
name|cache
init|=
name|cache_void
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|mc_key
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
operator|*
name|found
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build_key
argument_list|(
operator|&
name|mc_key
argument_list|,
name|cache
argument_list|,
name|key
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_memcache_getp
argument_list|(
name|cache
operator|->
name|memcache
argument_list|,
name|pool
argument_list|,
name|mc_key
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|NULL
comment|/* ignore flags */
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|==
name|APR_NOTFOUND
condition|)
block|{
operator|*
name|found
operator|=
name|FALSE
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
operator|||
operator|!
operator|*
name|data
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Unknown memcached error while reading"
argument_list|)
argument_list|)
return|;
operator|*
name|found
operator|=
name|TRUE
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|memcache_get
parameter_list|(
name|void
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|found
parameter_list|,
name|void
modifier|*
name|cache_void
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|memcache_t
modifier|*
name|cache
init|=
name|cache_void
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|data_len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|memcache_internal_get
argument_list|(
operator|&
name|data
argument_list|,
operator|&
name|data_len
argument_list|,
name|found
argument_list|,
name|cache_void
argument_list|,
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we found it, de-serialize it. */
if|if
condition|(
operator|*
name|found
condition|)
block|{
if|if
condition|(
name|cache
operator|->
name|deserialize_func
condition|)
block|{
name|SVN_ERR
argument_list|(
call|(
name|cache
operator|->
name|deserialize_func
call|)
argument_list|(
name|value_p
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_stringbuf_t
modifier|*
name|value
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|value
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|value
operator|->
name|blocksize
operator|=
name|data_len
expr_stmt|;
name|value
operator|->
name|len
operator|=
name|data_len
operator|-
literal|1
expr_stmt|;
comment|/* account for trailing NUL */
operator|*
name|value_p
operator|=
name|value
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Core functionality of our setter functions: store LENGH bytes of DATA  * to be identified by KEY in the memcached given by CACHE_VOID. Use POOL  * for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|memcache_internal_set
parameter_list|(
name|void
modifier|*
name|cache_void
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|memcache_t
modifier|*
name|cache
init|=
name|cache_void
decl_stmt|;
specifier|const
name|char
modifier|*
name|mc_key
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|build_key
argument_list|(
operator|&
name|mc_key
argument_list|,
name|cache
argument_list|,
name|key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_memcache_set
argument_list|(
name|cache
operator|->
name|memcache
argument_list|,
name|mc_key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ### Maybe write failures should be ignored (but logged)? */
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Unknown memcached error while writing"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|memcache_set
parameter_list|(
name|void
modifier|*
name|cache_void
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|memcache_t
modifier|*
name|cache
init|=
name|cache_void
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|data_len
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|cache
operator|->
name|serialize_func
condition|)
block|{
name|SVN_ERR
argument_list|(
call|(
name|cache
operator|->
name|serialize_func
call|)
argument_list|(
operator|&
name|data
argument_list|,
operator|&
name|data_len
argument_list|,
name|value
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_stringbuf_t
modifier|*
name|value_str
init|=
name|value
decl_stmt|;
name|data
operator|=
name|value_str
operator|->
name|data
expr_stmt|;
name|data_len
operator|=
name|value_str
operator|->
name|len
operator|+
literal|1
expr_stmt|;
comment|/* copy trailing NUL */
block|}
name|err
operator|=
name|memcache_internal_set
argument_list|(
name|cache_void
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|memcache_get_partial
parameter_list|(
name|void
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|found
parameter_list|,
name|void
modifier|*
name|cache_void
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|svn_cache__partial_getter_func_t
name|func
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
name|SVN_ERR
argument_list|(
name|memcache_internal_get
argument_list|(
operator|&
name|data
argument_list|,
operator|&
name|size
argument_list|,
name|found
argument_list|,
name|cache_void
argument_list|,
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we found it, de-serialize it. */
return|return
operator|*
name|found
condition|?
name|func
argument_list|(
name|value_p
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|baton
argument_list|,
name|result_pool
argument_list|)
else|:
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|memcache_set_partial
parameter_list|(
name|void
modifier|*
name|cache_void
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|svn_cache__partial_setter_func_t
name|func
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
name|svn_boolean_t
name|found
init|=
name|FALSE
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|memcache_internal_get
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|data
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|found
argument_list|,
name|cache_void
argument_list|,
name|key
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we found it, modify it and write it back to cache */
if|if
condition|(
name|found
condition|)
block|{
name|SVN_ERR
argument_list|(
name|func
argument_list|(
operator|&
name|data
argument_list|,
operator|&
name|size
argument_list|,
name|baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|memcache_internal_set
argument_list|(
name|cache_void
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|memcache_iter
parameter_list|(
name|svn_boolean_t
modifier|*
name|completed
parameter_list|,
name|void
modifier|*
name|cache_void
parameter_list|,
name|svn_iter_apr_hash_cb_t
name|user_cb
parameter_list|,
name|void
modifier|*
name|user_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't iterate a memcached cache"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|memcache_is_cachable
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
operator|(
name|void
operator|)
name|unused
expr_stmt|;
comment|/* silence gcc warning. */
comment|/* The memcached cutoff seems to be a bit (header length?) under a megabyte.    * We round down a little to be safe.    */
return|return
name|size
operator|<
literal|1000000
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|memcache_get_info
parameter_list|(
name|void
modifier|*
name|cache_void
parameter_list|,
name|svn_cache__info_t
modifier|*
name|info
parameter_list|,
name|svn_boolean_t
name|reset
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|memcache_t
modifier|*
name|cache
init|=
name|cache_void
decl_stmt|;
name|info
operator|->
name|id
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|cache
operator|->
name|prefix
argument_list|)
expr_stmt|;
comment|/* we don't have any memory allocation info */
name|info
operator|->
name|used_size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|total_size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|used_entries
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|total_entries
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|svn_cache__vtable_t
name|memcache_vtable
init|=
block|{
name|memcache_get
block|,
name|memcache_set
block|,
name|memcache_iter
block|,
name|memcache_is_cachable
block|,
name|memcache_get_partial
block|,
name|memcache_set_partial
block|,
name|memcache_get_info
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_cache__create_memcache
parameter_list|(
name|svn_cache__t
modifier|*
modifier|*
name|cache_p
parameter_list|,
name|svn_memcache_t
modifier|*
name|memcache
parameter_list|,
name|svn_cache__serialize_func_t
name|serialize_func
parameter_list|,
name|svn_cache__deserialize_func_t
name|deserialize_func
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cache__t
modifier|*
name|wrapper
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wrapper
argument_list|)
argument_list|)
decl_stmt|;
name|memcache_t
modifier|*
name|cache
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cache
argument_list|)
argument_list|)
decl_stmt|;
name|cache
operator|->
name|serialize_func
operator|=
name|serialize_func
expr_stmt|;
name|cache
operator|->
name|deserialize_func
operator|=
name|deserialize_func
expr_stmt|;
name|cache
operator|->
name|klen
operator|=
name|klen
expr_stmt|;
name|cache
operator|->
name|prefix
operator|=
name|svn_path_uri_encode
argument_list|(
name|prefix
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|cache
operator|->
name|memcache
operator|=
name|memcache
operator|->
name|c
expr_stmt|;
name|wrapper
operator|->
name|vtable
operator|=
operator|&
name|memcache_vtable
expr_stmt|;
name|wrapper
operator|->
name|cache_internal
operator|=
name|cache
expr_stmt|;
name|wrapper
operator|->
name|error_handler
operator|=
literal|0
expr_stmt|;
name|wrapper
operator|->
name|error_baton
operator|=
literal|0
expr_stmt|;
operator|*
name|cache_p
operator|=
name|wrapper
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Creating apr_memcache_t from svn_config_t. ***/
end_comment

begin_comment
comment|/* Baton for add_memcache_server. */
end_comment

begin_struct
struct|struct
name|ams_baton
block|{
name|apr_memcache_t
modifier|*
name|memcache
decl_stmt|;
name|apr_pool_t
modifier|*
name|memcache_pool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_config_enumerator2_t. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|add_memcache_server
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|ams_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|scope
decl_stmt|;
name|apr_port_t
name|port
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_memcache_server_t
modifier|*
name|server
decl_stmt|;
name|apr_err
operator|=
name|apr_parse_addr_port
argument_list|(
operator|&
name|host
argument_list|,
operator|&
name|scope
argument_list|,
operator|&
name|port
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error parsing memcache server '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|scope
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_SERVER_SPECIFICATION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Scope not allowed in memcache server "
literal|"'%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|host
operator|||
operator|!
name|port
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_SERVER_SPECIFICATION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Must specify host and port for memcache "
literal|"server '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Note: the four numbers here are only relevant when an      apr_memcache_t is being shared by multiple threads. */
name|apr_err
operator|=
name|apr_memcache_server_create
argument_list|(
name|b
operator|->
name|memcache_pool
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
comment|/* min connections */
literal|5
argument_list|,
comment|/* soft max connections */
literal|10
argument_list|,
comment|/* hard max connections */
comment|/*  time to live (in microseconds) */
name|apr_time_from_sec
argument_list|(
literal|50
argument_list|)
argument_list|,
operator|&
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Unknown error creating memcache server"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|apr_err
operator|=
name|apr_memcache_add_server
argument_list|(
name|b
operator|->
name|memcache
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|b
operator|->
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Unknown error adding server to memcache"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! SVN_HAVE_MEMCACHE */
end_comment

begin_comment
comment|/* Stubs for no apr memcache library. */
end_comment

begin_struct
struct|struct
name|svn_memcache_t
block|{
name|void
modifier|*
name|unused
decl_stmt|;
comment|/* Let's not have a size-zero struct. */
block|}
struct|;
end_struct

begin_function
name|svn_error_t
modifier|*
name|svn_cache__create_memcache
parameter_list|(
name|svn_cache__t
modifier|*
modifier|*
name|cache_p
parameter_list|,
name|svn_memcache_t
modifier|*
name|memcache
parameter_list|,
name|svn_cache__serialize_func_t
name|serialize_func
parameter_list|,
name|svn_cache__deserialize_func_t
name|deserialize_func
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_NO_APR_MEMCACHE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_HAVE_MEMCACHE */
end_comment

begin_comment
comment|/* Implements svn_config_enumerator2_t.  Just used for the    entry-counting return value of svn_config_enumerate2. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|nop_enumerator
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cache__make_memcache_from_config
parameter_list|(
name|svn_memcache_t
modifier|*
modifier|*
name|memcache_p
parameter_list|,
name|svn_config_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|server_count
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|server_count
operator|=
name|svn_config_enumerate2
argument_list|(
name|config
argument_list|,
name|SVN_CACHE_CONFIG_CATEGORY_MEMCACHED_SERVERS
argument_list|,
name|nop_enumerator
argument_list|,
name|NULL
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_count
operator|==
literal|0
condition|)
block|{
operator|*
name|memcache_p
operator|=
name|NULL
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|server_count
operator|>
name|APR_INT16_MAX
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_TOO_MANY_MEMCACHED_SERVERS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
ifdef|#
directive|ifdef
name|SVN_HAVE_MEMCACHE
block|{
name|struct
name|ams_baton
name|b
decl_stmt|;
name|svn_memcache_t
modifier|*
name|memcache
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|memcache
argument_list|)
argument_list|)
decl_stmt|;
name|apr_status_t
name|apr_err
init|=
name|apr_memcache_create
argument_list|(
name|pool
argument_list|,
operator|(
name|apr_uint16_t
operator|)
name|server_count
argument_list|,
literal|0
argument_list|,
comment|/* flags */
operator|&
operator|(
name|memcache
operator|->
name|c
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Unknown error creating apr_memcache_t"
argument_list|)
argument_list|)
return|;
name|b
operator|.
name|memcache
operator|=
name|memcache
operator|->
name|c
expr_stmt|;
name|b
operator|.
name|memcache_pool
operator|=
name|pool
expr_stmt|;
name|b
operator|.
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|svn_config_enumerate2
argument_list|(
name|config
argument_list|,
name|SVN_CACHE_CONFIG_CATEGORY_MEMCACHED_SERVERS
argument_list|,
name|add_memcache_server
argument_list|,
operator|&
name|b
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|err
condition|)
return|return
name|b
operator|.
name|err
return|;
operator|*
name|memcache_p
operator|=
name|memcache
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|#
directive|else
comment|/* ! SVN_HAVE_MEMCACHE */
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_NO_APR_MEMCACHE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* SVN_HAVE_MEMCACHE */
block|}
end_function

end_unit

