begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * io.c:   shared file reading, writing, and probing code.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|APR_STATUS_IS_EPERM
end_ifndef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EPERM
end_ifdef

begin_define
define|#
directive|define
name|APR_STATUS_IS_EPERM
parameter_list|(
name|s
parameter_list|)
value|((s) == EPERM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|APR_STATUS_IS_EPERM
parameter_list|(
name|s
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_portable.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_include
include|#
directive|include
file|<arch/win32/apr_arch_file_io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_define
define|#
directive|define
name|SVN_SLEEP_ENV_VAR
value|"SVN_I_LOVE_CORRUPTED_WORKING_COPIES_SO_DISABLE_SLEEP_FOR_TIMESTAMPS"
end_define

begin_escape
end_escape

begin_comment
comment|/*   Windows is 'aided' by a number of types of applications that   follow other applications around and open up files they have   changed for various reasons (the most intrusive are virus   scanners).  So, if one of these other apps has glommed onto   our file we may get an 'access denied' error.    This retry loop does not completely solve the problem (who   knows how long the other app is going to hold onto it for), but   goes a long way towards minimizing it.  It is not an infinite   loop because there might really be an error.    Another reason for retrying delete operations on Windows   is that they are asynchronous -- the file or directory is not   actually deleted until the last handle to it is closed.  The   retry loop cannot completely solve this problem either, but can   help mitigate it. */
end_comment

begin_define
define|#
directive|define
name|RETRY_MAX_ATTEMPTS
value|100
end_define

begin_define
define|#
directive|define
name|RETRY_INITIAL_SLEEP
value|1000
end_define

begin_define
define|#
directive|define
name|RETRY_MAX_SLEEP
value|128000
end_define

begin_define
define|#
directive|define
name|RETRY_LOOP
parameter_list|(
name|err
parameter_list|,
name|expr
parameter_list|,
name|retry_test
parameter_list|,
name|sleep_test
parameter_list|)
define|\
value|do                                                                       \     {                                                                      \       apr_status_t os_err = APR_TO_OS_ERROR(err);                          \       int sleep_count = RETRY_INITIAL_SLEEP;                               \       int retries;                                                         \       for (retries = 0;                                                    \            retries< RETRY_MAX_ATTEMPTS&& (retry_test);                   \            os_err = APR_TO_OS_ERROR(err))                                  \         {                                                                  \           if (sleep_test)                                                  \             {                                                              \               ++retries;                                                   \               apr_sleep(sleep_count);                                      \               if (sleep_count< RETRY_MAX_SLEEP)                           \                 sleep_count *= 2;                                          \             }                                                              \           (err) = (expr);                                                  \         }                                                                  \     }                                                                      \   while (0)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EDEADLK
argument_list|)
operator|&&
name|APR_HAS_THREADS
end_if

begin_define
define|#
directive|define
name|FILE_LOCK_RETRY_LOOP
parameter_list|(
name|err
parameter_list|,
name|expr
parameter_list|)
define|\
value|RETRY_LOOP(err,                                                          \              expr,                                                         \              (APR_STATUS_IS_EINTR(err) || os_err == EDEADLK),              \              (!APR_STATUS_IS_EINTR(err)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FILE_LOCK_RETRY_LOOP
parameter_list|(
name|err
parameter_list|,
name|expr
parameter_list|)
define|\
value|RETRY_LOOP(err,                                                          \              expr,                                                         \              (APR_STATUS_IS_EINTR(err)),                                   \              0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32_RETRY_LOOP
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SVN_NO_WIN32_RETRY_LOOP
argument_list|)
end_if

begin_define
define|#
directive|define
name|WIN32_RETRY_LOOP
parameter_list|(
name|err
parameter_list|,
name|expr
parameter_list|)
define|\
value|RETRY_LOOP(err, expr, (os_err == ERROR_ACCESS_DENIED                     \                          || os_err == ERROR_SHARING_VIOLATION              \                          || os_err == ERROR_DIR_NOT_EMPTY),                \              1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WIN32_RETRY_LOOP
parameter_list|(
name|err
parameter_list|,
name|expr
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declaration */
end_comment

begin_function_decl
specifier|static
name|apr_status_t
name|dir_is_empty
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|APR_INLINE
name|svn_error_t
modifier|*
name|do_io_file_wrapper_cleanup
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_status_t
name|status
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_no_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Local wrapper of svn_path_cstring_to_utf8() that does no copying on  * operating systems where APR always uses utf-8 as native path format */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cstring_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path_utf8
parameter_list|,
specifier|const
name|char
modifier|*
name|path_apr
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|DARWIN
argument_list|)
operator|*
name|path_utf8
operator|=
name|path_apr
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
else|#
directive|else
return|return
name|svn_path_cstring_to_utf8
argument_list|(
name|path_utf8
argument_list|,
name|path_apr
argument_list|,
name|pool
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Local wrapper of svn_path_cstring_from_utf8() that does no copying on  * operating systems where APR always uses utf-8 as native path format */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cstring_from_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path_apr
parameter_list|,
specifier|const
name|char
modifier|*
name|path_utf8
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|DARWIN
argument_list|)
operator|*
name|path_apr
operator|=
name|path_utf8
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
else|#
directive|else
return|return
name|svn_path_cstring_from_utf8
argument_list|(
name|path_apr
argument_list|,
name|path_utf8
argument_list|,
name|pool
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Helper function that allows to convert an APR-level PATH to something  * that we can pass the svn_error_wrap_apr. Since we use it in context  * of error reporting, having *some* path info may be more useful than  * having none.  Therefore, we use a best effort approach here.  *  * This is different from svn_io_file_name_get in that it uses a different  * signature style and will never fail.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|try_utf8_from_internal_style
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_utf8
decl_stmt|;
comment|/* Special case. */
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
literal|"(NULL)"
return|;
comment|/* (try to) convert PATH to UTF-8. If that fails, continue with the plain    * PATH because it is the best we have. It may actually be UTF-8 already.    */
name|error
operator|=
name|cstring_to_utf8
argument_list|(
operator|&
name|path_utf8
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* fallback to best representation we have */
name|svn_error_clear
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|path_utf8
operator|=
name|path
expr_stmt|;
block|}
comment|/* Toggle (back-)slashes etc. as necessary.    */
return|return
name|svn_dirent_local_style
argument_list|(
name|path_utf8
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *NAME_P to the UTF-8 representation of directory entry NAME.  * NAME is in the internal encoding used by APR; PARENT is in  * UTF-8 and in internal (not local) style.  *  * Use PARENT only for generating an error string if the conversion  * fails because NAME could not be represented in UTF-8.  In that  * case, return a two-level error in which the outer error's message  * mentions PARENT, but the inner error's message does not mention  * NAME (except possibly in hex) since NAME may not be printable.  * Such a compound error at least allows the user to go looking in the  * right directory for the problem.  *  * If there is any other error, just return that error directly.  *  * If there is any error, the effect on *NAME_P is undefined.  *  * *NAME_P and NAME may refer to the same storage.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|entry_name_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|name_p
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|parent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|DARWIN
argument_list|)
operator|*
name|name_p
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
else|#
directive|else
name|svn_error_t
modifier|*
name|err
init|=
name|svn_path_cstring_to_utf8
argument_list|(
name|name_p
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|APR_EINVAL
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Error converting entry "
literal|"in directory '%s' to UTF-8"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|err
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|map_apr_finfo_to_node_kind
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_special
parameter_list|,
name|apr_finfo_t
modifier|*
name|finfo
parameter_list|)
block|{
operator|*
name|is_special
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|filetype
operator|==
name|APR_REG
condition|)
operator|*
name|kind
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
name|finfo
operator|->
name|filetype
operator|==
name|APR_DIR
condition|)
operator|*
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
elseif|else
if|if
condition|(
name|finfo
operator|->
name|filetype
operator|==
name|APR_LNK
condition|)
block|{
operator|*
name|is_special
operator|=
name|TRUE
expr_stmt|;
operator|*
name|kind
operator|=
name|svn_node_file
expr_stmt|;
block|}
else|else
operator|*
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for svn_io_check_path() and svn_io_check_resolved_path();    essentially the same semantics as those two, with the obvious    interpretation for RESOLVE_SYMLINKS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|io_check_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|resolve_symlinks
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_special_p
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_int32_t
name|flags
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|svn_boolean_t
name|is_special
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
comment|/* Not using svn_io_stat() here because we want to check the      apr_err return explicitly. */
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|resolve_symlinks
condition|?
name|APR_FINFO_MIN
else|:
operator|(
name|APR_FINFO_MIN
operator||
name|APR_FINFO_LINK
operator|)
expr_stmt|;
name|apr_err
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path_apr
argument_list|,
name|flags
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|apr_err
argument_list|)
condition|)
operator|*
name|kind
operator|=
name|svn_node_none
expr_stmt|;
elseif|else
if|if
condition|(
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|apr_err
argument_list|)
condition|)
operator|*
name|kind
operator|=
name|svn_node_none
expr_stmt|;
elseif|else
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't check path '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
else|else
name|map_apr_finfo_to_node_kind
argument_list|(
name|kind
argument_list|,
operator|&
name|is_special
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
operator|*
name|is_special_p
operator|=
name|is_special
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Wrapper for apr_file_open(), taking an APR-encoded filename. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|file_open
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|fname_apr
parameter_list|,
name|apr_int32_t
name|flag
parameter_list|,
name|apr_fileperms_t
name|perm
parameter_list|,
name|svn_boolean_t
name|retry_on_failure
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|apr_file_open
argument_list|(
name|f
argument_list|,
name|fname_apr
argument_list|,
name|flag
argument_list|,
name|perm
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|retry_on_failure
condition|)
block|{
name|WIN32_RETRY_LOOP
argument_list|(
name|status
argument_list|,
name|apr_file_open
argument_list|(
name|f
argument_list|,
name|fname_apr
argument_list|,
name|flag
argument_list|,
name|perm
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_check_resolved_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|ignored
decl_stmt|;
return|return
name|io_check_path
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
operator|&
name|ignored
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_check_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|ignored
decl_stmt|;
return|return
name|io_check_path
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
operator|&
name|ignored
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_check_special_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_special
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|io_check_path
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|is_special
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|temp_file_cleanup_s
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The (APR-encoded) full path of the file to be removed, or NULL if    * nothing to do. */
specifier|const
name|char
modifier|*
name|fname_apr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|apr_status_t
name|temp_file_plain_cleanup_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|temp_file_cleanup_s
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_status_t
name|apr_err
init|=
name|APR_SUCCESS
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|fname_apr
condition|)
block|{
name|apr_err
operator|=
name|apr_file_remove
argument_list|(
name|b
operator|->
name|fname_apr
argument_list|,
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
name|WIN32_RETRY_LOOP
argument_list|(
name|apr_err
argument_list|,
name|apr_file_remove
argument_list|(
name|b
operator|->
name|fname_apr
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|apr_err
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|temp_file_child_cleanup_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|temp_file_cleanup_s
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_pool_cleanup_kill
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|b
argument_list|,
name|temp_file_plain_cleanup_handler
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_open_uniquely_named
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|unique_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dirpath
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|svn_io_file_del_t
name|delete_when
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|temp_file_cleanup_s
modifier|*
name|baton
init|=
name|NULL
decl_stmt|;
comment|/* At the beginning, we don't know whether unique_path will need      UTF8 conversion */
name|svn_boolean_t
name|needs_utf8_conversion
init|=
name|TRUE
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|file
operator|||
name|unique_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirpath
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_temp_dir
argument_list|(
operator|&
name|dirpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
literal|"tempfile"
expr_stmt|;
if|if
condition|(
name|suffix
operator|==
name|NULL
condition|)
name|suffix
operator|=
literal|".tmp"
expr_stmt|;
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|dirpath
argument_list|,
name|filename
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_when
operator|==
name|svn_io_file_del_on_pool_cleanup
condition|)
block|{
name|baton
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|baton
operator|->
name|fname_apr
operator|=
name|NULL
expr_stmt|;
comment|/* Because cleanups are run LIFO, we need to make sure to register          our cleanup before the apr_file_close cleanup:           On Windows, you can't remove an open file.       */
name|apr_pool_cleanup_register
argument_list|(
name|result_pool
argument_list|,
name|baton
argument_list|,
name|temp_file_plain_cleanup_handler
argument_list|,
name|temp_file_child_cleanup_handler
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|99999
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|unique_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|unique_name_apr
decl_stmt|;
name|apr_file_t
modifier|*
name|try_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_int32_t
name|flag
init|=
operator|(
name|APR_READ
operator||
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_EXCL
operator||
name|APR_BUFFERED
operator||
name|APR_BINARY
operator|)
decl_stmt|;
if|if
condition|(
name|delete_when
operator|==
name|svn_io_file_del_on_close
condition|)
name|flag
operator||=
name|APR_DELONCLOSE
expr_stmt|;
comment|/* Special case the first attempt -- if we can avoid having a          generated numeric portion at all, that's best.  So first we          try with just the suffix; then future tries add a number          before the suffix.  (A do-while loop could avoid the repeated          conditional, but it's not worth the clarity loss.)           If the first attempt fails, the first number will be "2".          This is good, since "1" would misleadingly imply that          the second attempt was actually the first... and if someone's          got conflicts on their conflicts, we probably don't want to          add to their confusion :-). */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|unique_name
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%s%s"
argument_list|,
name|path
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
else|else
name|unique_name
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%s.%u%s"
argument_list|,
name|path
argument_list|,
name|i
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|/* Hmmm.  Ideally, we would append to a native-encoding buf          before starting iteration, then convert back to UTF-8 for          return. But I suppose that would make the appending code          sensitive to i18n in a way it shouldn't be... Oh well. */
if|if
condition|(
name|needs_utf8_conversion
condition|)
block|{
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|unique_name_apr
argument_list|,
name|unique_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
comment|/* The variable parts of unique_name will not require UTF8                  conversion. Therefore, if UTF8 conversion had no effect                  on it in the first iteration, it won't require conversion                  in any future iteration. */
name|needs_utf8_conversion
operator|=
name|strcmp
argument_list|(
name|unique_name_apr
argument_list|,
name|unique_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|unique_name_apr
operator|=
name|unique_name
expr_stmt|;
name|apr_err
operator|=
name|file_open
argument_list|(
operator|&
name|try_file
argument_list|,
name|unique_name_apr
argument_list|,
name|flag
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EEXIST
argument_list|(
name|apr_err
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|apr_err
condition|)
block|{
comment|/* On Win32, CreateFile fails with an "Access Denied" error              code, rather than "File Already Exists", if the colliding              name belongs to a directory. */
if|if
condition|(
name|APR_STATUS_IS_EACCES
argument_list|(
name|apr_err
argument_list|)
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_status_t
name|apr_err_2
init|=
name|apr_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|unique_name_apr
argument_list|,
name|APR_FINFO_TYPE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|apr_err_2
operator|&&
name|finfo
operator|.
name|filetype
operator|==
name|APR_DIR
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|WIN32
name|apr_err_2
operator|=
name|APR_TO_OS_ERROR
argument_list|(
name|apr_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err_2
operator|==
name|ERROR_ACCESS_DENIED
operator|||
name|apr_err_2
operator|==
name|ERROR_SHARING_VIOLATION
condition|)
block|{
comment|/* The file is in use by another process or is hidden;                      create a new name, but don't do this 99999 times in                      case the folder is not writable */
name|i
operator|+=
literal|797
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* Else fall through and return the original error. */
block|}
if|if
condition|(
name|file
condition|)
operator|*
name|file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unique_path
condition|)
operator|*
name|unique_path
operator|=
name|NULL
expr_stmt|;
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't open '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|unique_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|delete_when
operator|==
name|svn_io_file_del_on_pool_cleanup
condition|)
name|baton
operator|->
name|fname_apr
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|unique_name_apr
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
operator|*
name|file
operator|=
name|try_file
expr_stmt|;
else|else
name|apr_file_close
argument_list|(
name|try_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|unique_path
condition|)
operator|*
name|unique_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|unique_name
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
name|file
condition|)
operator|*
name|file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unique_path
condition|)
operator|*
name|unique_path
operator|=
name|NULL
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to make name for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_create_unique_link
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|unique_name_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|unique_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|unique_name_apr
decl_stmt|;
specifier|const
name|char
modifier|*
name|dest_apr
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|dest_apr
argument_list|,
name|dest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|99999
condition|;
name|i
operator|++
control|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
comment|/* Special case the first attempt -- if we can avoid having a          generated numeric portion at all, that's best.  So first we          try with just the suffix; then future tries add a number          before the suffix.  (A do-while loop could avoid the repeated          conditional, but it's not worth the clarity loss.)           If the first attempt fails, the first number will be "2".          This is good, since "1" would misleadingly imply that          the second attempt was actually the first... and if someone's          got conflicts on their conflicts, we probably don't want to          add to their confusion :-). */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|unique_name
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s%s"
argument_list|,
name|path
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
else|else
name|unique_name
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s.%u%s"
argument_list|,
name|path
argument_list|,
name|i
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|/* Hmmm.  Ideally, we would append to a native-encoding buf          before starting iteration, then convert back to UTF-8 for          return. But I suppose that would make the appending code          sensitive to i18n in a way it shouldn't be... Oh well. */
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|unique_name_apr
argument_list|,
name|unique_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|symlink
argument_list|(
name|dest_apr
argument_list|,
name|unique_name_apr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|APR_STATUS_IS_EINTR
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|)
condition|)
do|;
name|apr_err
operator|=
name|apr_get_os_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|APR_STATUS_IS_EEXIST
argument_list|(
name|apr_err
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|apr_err
condition|)
block|{
comment|/* On Win32, CreateFile fails with an "Access Denied" error              code, rather than "File Already Exists", if the colliding              name belongs to a directory. */
if|if
condition|(
name|APR_STATUS_IS_EACCES
argument_list|(
name|apr_err
argument_list|)
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_status_t
name|apr_err_2
init|=
name|apr_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|unique_name_apr
argument_list|,
name|APR_FINFO_TYPE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|apr_err_2
operator|&&
operator|(
name|finfo
operator|.
name|filetype
operator|==
name|APR_DIR
operator|)
condition|)
continue|continue;
comment|/* Else ignore apr_err_2; better to fall through and                  return the original error. */
block|}
operator|*
name|unique_name_p
operator|=
name|NULL
expr_stmt|;
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't create symbolic link '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|unique_name
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
operator|*
name|unique_name_p
operator|=
name|unique_name
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
operator|*
name|unique_name_p
operator|=
name|NULL
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to make name for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Symbolic links are not supported on this "
literal|"platform"
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_read_link
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_READLINK
name|svn_string_t
name|dest_apr
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|char
name|buf
index|[
literal|1025
index|]
decl_stmt|;
name|ssize_t
name|rv
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|readlink
argument_list|(
name|path_apr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|APR_STATUS_IS_EINTR
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|)
condition|)
do|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Can't read contents of link"
argument_list|)
argument_list|)
return|;
name|buf
index|[
name|rv
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dest_apr
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|dest_apr
operator|.
name|len
operator|=
name|rv
expr_stmt|;
comment|/* ### Cast needed, one of these interfaces is wrong */
return|return
name|svn_utf_string_to_utf8
argument_list|(
operator|(
specifier|const
name|svn_string_t
operator|*
operator|*
operator|)
name|dest
argument_list|,
operator|&
name|dest_apr
argument_list|,
name|pool
argument_list|)
return|;
else|#
directive|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Symbolic links are not supported on this "
literal|"platform"
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_copy_link
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_READLINK
name|svn_string_t
modifier|*
name|link_dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_tmp
decl_stmt|;
comment|/* Notice what the link is pointing at... */
name|SVN_ERR
argument_list|(
name|svn_io_read_link
argument_list|(
operator|&
name|link_dest
argument_list|,
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a tmp-link pointing at the same thing. */
name|SVN_ERR
argument_list|(
name|svn_io_create_unique_link
argument_list|(
operator|&
name|dst_tmp
argument_list|,
name|dst
argument_list|,
name|link_dest
operator|->
name|data
argument_list|,
literal|".tmp"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the tmp-link to link. */
return|return
name|svn_io_file_rename
argument_list|(
name|dst_tmp
argument_list|,
name|dst
argument_list|,
name|pool
argument_list|)
return|;
else|#
directive|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Symbolic links are not supported on this "
literal|"platform"
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Temporary directory name cache for svn_io_temp_dir() */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|svn_atomic_t
name|temp_dir_init_state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|temp_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper function to initialize temp dir. Passed to svn_atomic__init_once */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_temp_dir
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Global pool for the temp path */
name|apr_pool_t
modifier|*
name|global_pool
init|=
name|svn_pool_create
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
name|apr_status_t
name|apr_err
init|=
name|apr_temp_dir_get
argument_list|(
operator|&
name|dir
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't find a temporary directory"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|cstring_to_utf8
argument_list|(
operator|&
name|dir
argument_list|,
name|dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|=
name|svn_dirent_internal_style
argument_list|(
name|dir
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|temp_dir
argument_list|,
name|dir
argument_list|,
name|global_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_temp_dir
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_atomic__init_once
argument_list|(
operator|&
name|temp_dir_init_state
argument_list|,
name|init_temp_dir
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dir
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|temp_dir
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Creating, copying and appending files. ***/
end_comment

begin_comment
comment|/* Transfer the contents of FROM_FILE to TO_FILE, using POOL for temporary  * allocations.  *  * NOTE: We don't use apr_copy_file() for this, since it takes filenames  * as parameters.  Since we want to copy to a temporary file  * and rename for atomicity (see below), this would require an extra  * close/open pair, which can be expensive, especially on  * remote file systems.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|copy_contents
parameter_list|(
name|apr_file_t
modifier|*
name|from_file
parameter_list|,
name|apr_file_t
modifier|*
name|to_file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Copy bytes till the cows come home. */
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|buf
index|[
name|SVN__STREAM_CHUNK_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|bytes_this_time
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|apr_status_t
name|read_err
decl_stmt|;
name|apr_status_t
name|write_err
decl_stmt|;
comment|/* Read 'em. */
name|read_err
operator|=
name|apr_file_read
argument_list|(
name|from_file
argument_list|,
name|buf
argument_list|,
operator|&
name|bytes_this_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_err
operator|&&
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|read_err
argument_list|)
condition|)
block|{
return|return
name|read_err
return|;
block|}
comment|/* Write 'em. */
name|write_err
operator|=
name|apr_file_write_full
argument_list|(
name|to_file
argument_list|,
name|buf
argument_list|,
name|bytes_this_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_err
condition|)
block|{
return|return
name|write_err
return|;
block|}
if|if
condition|(
name|read_err
operator|&&
name|APR_STATUS_IS_EOF
argument_list|(
name|read_err
argument_list|)
condition|)
block|{
comment|/* Return the results of this close: an error, or success. */
return|return
name|APR_SUCCESS
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_copy_file
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|svn_boolean_t
name|copy_perms
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|from_file
decl_stmt|,
modifier|*
name|to_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_tmp
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* ### NOTE: sometimes src == dst. In this case, because we copy to a      ###   temporary file, and then rename over the top of the destination,      ###   the net result is resetting the permissions on src/dst.      ###      ### Note: specifically, this can happen during a switch when the desired      ###   permissions for a file change from one branch to another. See      ###   switch_tests 17.      ###      ### ... yes, we should avoid copying to the same file, and we should      ###     make the "reset perms" explicit. The switch *happens* to work      ###     because of this copy-to-temp-then-rename implementation. If it      ###     weren't for that, the switch would break.   */
ifdef|#
directive|ifdef
name|CHECK_FOR_SAME_FILE
if|if
condition|(
name|strcmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|from_file
argument_list|,
name|src
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For atomicity, we copy to a tmp file and then rename the tmp      file over the real destination. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|to_file
argument_list|,
operator|&
name|dst_tmp
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|copy_contents
argument_list|(
name|from_file
argument_list|,
name|to_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't copy '%s' to '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_tmp
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|from_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|to_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_remove_file2
argument_list|(
name|dst_tmp
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* If copying perms, set the perms on dst_tmp now, so they will be      atomically inherited in the upcoming rename.  But note that we      had to wait until now to set perms, because if they say      read-only, then we'd have failed filling dst_tmp's contents. */
if|if
condition|(
name|copy_perms
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|src
argument_list|,
name|dst_tmp
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_rename
argument_list|(
name|dst_tmp
argument_list|,
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
end_if

begin_comment
comment|/* Wrapper for apr_file_perms_set(), taking a UTF8-encoded filename. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_perms_set
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|apr_fileperms_t
name|perms
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname_apr
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|fname_apr
argument_list|,
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_file_perms_set
argument_list|(
name|fname_apr
argument_list|,
name|perms
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't set permissions on '%s'"
argument_list|)
argument_list|,
name|fname
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set permissions PERMS on the FILE. This is a cheaper variant of the  * file_perms_set wrapper() function because no locale-dependent string  * conversion is required. POOL will be used for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_perms_set2
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_fileperms_t
name|perms
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname_apr
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|apr_file_name_get
argument_list|(
operator|&
name|fname_apr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't get file name"
argument_list|)
argument_list|)
return|;
name|status
operator|=
name|apr_file_perms_set
argument_list|(
name|fname_apr
argument_list|,
name|perms
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't set permissions on '%s'"
argument_list|)
argument_list|,
name|try_utf8_from_internal_style
argument_list|(
name|fname_apr
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !WIN32&& !__OS2__ */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_io_copy_perms
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* ### On Windows or OS/2, apr_file_perms_set always returns APR_ENOTIMPL,          and the path passed to apr_file_perms_set must be encoded          in the platform-specific path encoding; not necessary UTF-8.          We need a platform-specific implementation to get the          permissions right. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|is_special
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* If DST is a symlink, don't bother copying permissions. */
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|dst
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|is_special
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_special
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|src
argument_list|,
name|APR_FINFO_PROT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|file_perms_set
argument_list|(
name|dst
argument_list|,
name|finfo
operator|.
name|protection
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* We shouldn't be able to get APR_INCOMPLETE or APR_ENOTIMPL            here under normal circumstances, because the perms themselves            came from a call to apr_file_info_get(), and we already know            this is the non-Win32 case.  But if it does happen, it's not            an error. */
if|if
condition|(
name|APR_STATUS_IS_INCOMPLETE
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|APR_STATUS_IS_ENOTIMPL
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|message
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Can't set permissions on '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|message
argument_list|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* !WIN32&& !__OS2__ */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_append_file
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_apr
decl_stmt|,
modifier|*
name|dst_apr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|src_apr
argument_list|,
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|dst_apr
argument_list|,
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_file_append
argument_list|(
name|src_apr
argument_list|,
name|dst_apr
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't append '%s' to '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_copy_dir_recursively
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_parent
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_basename
parameter_list|,
name|svn_boolean_t
name|copy_perms
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_path
decl_stmt|;
name|apr_dir_t
modifier|*
name|this_dir
decl_stmt|;
name|apr_finfo_t
name|this_entry
decl_stmt|;
name|apr_int32_t
name|flags
init|=
name|APR_FINFO_TYPE
operator||
name|APR_FINFO_NAME
decl_stmt|;
comment|/* Make a subpool for recursion */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* The 'dst_path' is simply dst_parent/dst_basename */
name|dst_path
operator|=
name|svn_dirent_join
argument_list|(
name|dst_parent
argument_list|,
name|dst_basename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Sanity checks:  SRC and DST_PARENT are directories, and      DST_BASENAME doesn't already exist in DST_PARENT. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src
argument_list|,
operator|&
name|kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Source '%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_parent
argument_list|,
operator|&
name|kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination '%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_parent
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_path
argument_list|,
operator|&
name|kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination '%s' already exists"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* Create the new directory. */
comment|/* ### TODO: copy permissions (needs apr_file_attrs_get()) */
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|dst_path
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop over the dirents in SRC.  ('.' and '..' are auto-excluded) */
name|SVN_ERR
argument_list|(
name|svn_io_dir_open
argument_list|(
operator|&
name|this_dir
argument_list|,
name|src
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|status
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|this_entry
argument_list|,
name|flags
argument_list|,
name|this_dir
argument_list|)
init|;
name|status
operator|==
name|APR_SUCCESS
condition|;
name|status
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|this_entry
argument_list|,
name|flags
argument_list|,
name|this_dir
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|this_entry
operator|.
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|src_target
decl_stmt|,
modifier|*
name|entryname_utf8
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|entry_name_to_utf8
argument_list|(
operator|&
name|entryname_utf8
argument_list|,
name|this_entry
operator|.
name|name
argument_list|,
name|src
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|src_target
operator|=
name|svn_dirent_join
argument_list|(
name|src
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_entry
operator|.
name|filetype
operator|==
name|APR_REG
condition|)
comment|/* regular file */
block|{
specifier|const
name|char
modifier|*
name|dst_target
init|=
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|src_target
argument_list|,
name|dst_target
argument_list|,
name|copy_perms
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_entry
operator|.
name|filetype
operator|==
name|APR_LNK
condition|)
comment|/* symlink */
block|{
specifier|const
name|char
modifier|*
name|dst_target
init|=
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_link
argument_list|(
name|src_target
argument_list|,
name|dst_target
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_entry
operator|.
name|filetype
operator|==
name|APR_DIR
condition|)
comment|/* recurse */
block|{
comment|/* Prevent infinite recursion by filtering off our                  newly created destination path. */
if|if
condition|(
name|strcmp
argument_list|(
name|src
argument_list|,
name|dst_parent
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|entryname_utf8
argument_list|,
name|dst_basename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|svn_io_copy_dir_recursively
argument_list|(
name|src_target
argument_list|,
name|dst_path
argument_list|,
name|entryname_utf8
argument_list|,
name|copy_perms
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### support other APR node types someday?? */
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|status
argument_list|)
operator|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't read directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|status
operator|=
name|apr_dir_close
argument_list|(
name|this_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Error closing directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* Free any memory used by recursion */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_make_dir_recursively
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
if|if
condition|(
name|svn_path_is_empty
argument_list|(
name|path
argument_list|)
condition|)
comment|/* Empty path (current dir) is assumed to always exist,        so we do nothing, per docs. */
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_dir_make_recursive
argument_list|(
name|path_apr
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|WIN32_RETRY_LOOP
argument_list|(
name|apr_err
argument_list|,
name|apr_dir_make_recursive
argument_list|(
name|path_apr
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't make directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_create
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|f
decl_stmt|;
name|apr_size_t
name|written
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|f
argument_list|,
name|file
argument_list|,
operator|(
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_EXCL
operator|)
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|&&
operator|*
name|contents
condition|)
name|err
operator|=
name|svn_io_file_write_full
argument_list|(
name|f
argument_list|,
name|contents
argument_list|,
name|strlen
argument_list|(
name|contents
argument_list|)
argument_list|,
operator|&
name|written
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|f
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_file_copy
parameter_list|(
specifier|const
name|char
modifier|*
name|src_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dest_path
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|file_dest_path
init|=
name|svn_dirent_join
argument_list|(
name|dest_path
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_src_path
init|=
name|svn_dirent_join
argument_list|(
name|src_path
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_io_copy_file
argument_list|(
name|file_src_path
argument_list|,
name|file_dest_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Modtime checking. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_affected_time
parameter_list|(
name|apr_time_t
modifier|*
name|apr_time
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_MIN
operator||
name|APR_FINFO_LINK
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|apr_time
operator|=
name|finfo
operator|.
name|mtime
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_set_file_affected_time
parameter_list|(
name|apr_time_t
name|apr_time
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|native_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|native_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_file_mtime_set
argument_list|(
name|native_path
argument_list|,
name|apr_time
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't set access time of '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_io_sleep_for_timestamps
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_time_t
name|now
decl_stmt|,
name|then
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|sleep_env_var
decl_stmt|;
name|sleep_env_var
operator|=
name|getenv
argument_list|(
name|SVN_SLEEP_ENV_VAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleep_env_var
operator|&&
name|apr_strnatcasecmp
argument_list|(
name|sleep_env_var
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Allow skipping for testing */
name|now
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
comment|/* Calculate 0.02 seconds after the next second wallclock tick. */
name|then
operator|=
name|apr_time_make
argument_list|(
name|apr_time_sec
argument_list|(
name|now
argument_list|)
operator|+
literal|1
argument_list|,
name|APR_USEC_PER_SEC
operator|/
literal|50
argument_list|)
expr_stmt|;
comment|/* Worst case is waiting one second, so we can use that time to determine      if we can sleep shorter than that */
if|if
condition|(
name|path
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|err
operator|=
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_MTIME
operator||
name|APR_FINFO_LINK
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Fall back on original behavior */
block|}
elseif|else
if|if
condition|(
name|finfo
operator|.
name|mtime
operator|%
name|APR_USEC_PER_SEC
condition|)
block|{
comment|/* Very simplistic but safe approach:               If the filesystem has< sec mtime we can be reasonably sure               that the filesystem has some sub-second resolution.  On Windows               it is likely to be sub-millisecond; on Linux systems it depends               on the filesystem, ext4 is typically 1ms, 4ms or 10ms resolution.               ## Perhaps find a better algorithm here. This will fail once                 in every 1000 cases on a millisecond precision filesystem                 if the mtime happens to be an exact second.                  But better to fail once in every thousand cases than every                 time, like we did before.               Note for further research on algorithm:                FAT32 has< 1 sec precision on ctime, but 2 sec on mtime.                 Linux/ext4 with CONFIG_HZ=250 has high resolution                apr_time_now and although the filesystem timestamps                have similar high precision they are only updated with                a coarser 4ms resolution. */
comment|/* 10 milliseconds after now. */
ifndef|#
directive|ifndef
name|SVN_HI_RES_SLEEP_MS
define|#
directive|define
name|SVN_HI_RES_SLEEP_MS
value|10
endif|#
directive|endif
name|then
operator|=
name|now
operator|+
name|apr_time_from_msec
argument_list|(
name|SVN_HI_RES_SLEEP_MS
argument_list|)
expr_stmt|;
block|}
comment|/* Remove time taken to do stat() from sleep. */
name|now
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|now
operator|>=
name|then
condition|)
return|return;
comment|/* Passing negative values may suspend indefinitely (Windows) */
comment|/* (t< 1000 will be round to 0 in apr) */
if|if
condition|(
name|then
operator|-
name|now
operator|<
literal|1000
condition|)
name|apr_sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
name|apr_sleep
argument_list|(
name|then
operator|-
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_filesizes_different_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|different_p
parameter_list|,
specifier|const
name|char
modifier|*
name|file1
parameter_list|,
specifier|const
name|char
modifier|*
name|file2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_finfo_t
name|finfo1
decl_stmt|;
name|apr_finfo_t
name|finfo2
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|file1_apr
decl_stmt|,
modifier|*
name|file2_apr
decl_stmt|;
comment|/* Not using svn_io_stat() because don't want to generate      svn_error_t objects for non-error conditions. */
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|file1_apr
argument_list|,
name|file1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|file2_apr
argument_list|,
name|file2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stat both files */
name|status
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo1
argument_list|,
name|file1_apr
argument_list|,
name|APR_FINFO_MIN
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* If we got an error stat'ing a file, it could be because the          file was removed... or who knows.  Whatever the case, we          don't know if the filesizes are definitely different, so          assume that they're not. */
operator|*
name|different_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|status
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo2
argument_list|,
name|file2_apr
argument_list|,
name|APR_FINFO_MIN
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* See previous comment. */
operator|*
name|different_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Examine file sizes */
if|if
condition|(
name|finfo1
operator|.
name|size
operator|==
name|finfo2
operator|.
name|size
condition|)
operator|*
name|different_p
operator|=
name|FALSE
expr_stmt|;
else|else
operator|*
name|different_p
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_filesizes_three_different_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|different_p12
parameter_list|,
name|svn_boolean_t
modifier|*
name|different_p23
parameter_list|,
name|svn_boolean_t
modifier|*
name|different_p13
parameter_list|,
specifier|const
name|char
modifier|*
name|file1
parameter_list|,
specifier|const
name|char
modifier|*
name|file2
parameter_list|,
specifier|const
name|char
modifier|*
name|file3
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_finfo_t
name|finfo1
decl_stmt|,
name|finfo2
decl_stmt|,
name|finfo3
decl_stmt|;
name|apr_status_t
name|status1
decl_stmt|,
name|status2
decl_stmt|,
name|status3
decl_stmt|;
specifier|const
name|char
modifier|*
name|file1_apr
decl_stmt|,
modifier|*
name|file2_apr
decl_stmt|,
modifier|*
name|file3_apr
decl_stmt|;
comment|/* Not using svn_io_stat() because don't want to generate      svn_error_t objects for non-error conditions. */
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|file1_apr
argument_list|,
name|file1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|file2_apr
argument_list|,
name|file2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|file3_apr
argument_list|,
name|file3
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stat all three files */
name|status1
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo1
argument_list|,
name|file1_apr
argument_list|,
name|APR_FINFO_MIN
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|status2
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo2
argument_list|,
name|file2_apr
argument_list|,
name|APR_FINFO_MIN
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|status3
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo3
argument_list|,
name|file3_apr
argument_list|,
name|APR_FINFO_MIN
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If we got an error stat'ing a file, it could be because the      file was removed... or who knows.  Whatever the case, we      don't know if the filesizes are definitely different, so      assume that they're not. */
operator|*
name|different_p12
operator|=
operator|!
name|status1
operator|&&
operator|!
name|status2
operator|&&
name|finfo1
operator|.
name|size
operator|!=
name|finfo2
operator|.
name|size
expr_stmt|;
operator|*
name|different_p23
operator|=
operator|!
name|status2
operator|&&
operator|!
name|status3
operator|&&
name|finfo2
operator|.
name|size
operator|!=
name|finfo3
operator|.
name|size
expr_stmt|;
operator|*
name|different_p13
operator|=
operator|!
name|status1
operator|&&
operator|!
name|status3
operator|&&
name|finfo1
operator|.
name|size
operator|!=
name|finfo3
operator|.
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_checksum2
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|checksum_stream
decl_stmt|;
name|apr_file_t
modifier|*
name|f
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|f
argument_list|,
name|file
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|file_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|f
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|checksum_stream
operator|=
name|svn_stream_checksummed2
argument_list|(
name|file_stream
argument_list|,
name|checksum
argument_list|,
name|NULL
argument_list|,
name|kind
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Because the checksummed stream will force the reading (and      checksumming) of all the file's bytes, we can just close the stream      and let its magic work. */
return|return
name|svn_stream_close
argument_list|(
name|checksum_stream
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_checksum
parameter_list|(
name|unsigned
name|char
name|digest
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_checksum2
argument_list|(
operator|&
name|checksum
argument_list|,
name|file
argument_list|,
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|digest
argument_list|,
name|checksum
operator|->
name|digest
argument_list|,
name|APR_MD5_DIGESTSIZE
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Permissions and modes. ***/
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
end_if

begin_comment
comment|/* Given the file specified by PATH, attempt to create an    identical version of it owned by the current user.  This is done by    moving it to a temporary location, copying the file back to its old    path, then deleting the temporarily moved version.  All temporary    allocations are done in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reown_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|unique_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|unique_name
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|path
argument_list|,
name|unique_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|unique_name
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|unique_name
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine what the PERMS for a new file should be by looking at the    permissions of a temporary file that we create.    Unfortunately, umask() as defined in POSIX provides no thread-safe way    to get at the current value of the umask, so what we're doing here is    the only way we have to determine which combination of write bits    (User/Group/World) should be set by default.    Make temporary allocations in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_default_file_perms
parameter_list|(
name|apr_fileperms_t
modifier|*
name|perms
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* the default permissions as read from the temp folder */
specifier|static
name|apr_fileperms_t
name|default_perms
init|=
literal|0
decl_stmt|;
comment|/* Technically, this "racy": Multiple threads may use enter here and      try to figure out the default permission concurrently. That's fine      since they will end up with the same results. Even more technical,      apr_fileperms_t is an atomic type on 32+ bit machines.    */
if|if
condition|(
name|default_perms
operator|==
literal|0
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_file_t
modifier|*
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname_base
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|apr_uint32_t
name|randomish
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Get the perms for a newly created file to find out what bits         should be set.          Explictly delete the file because we want this file to be as         short-lived as possible since its presence means other         processes may have to try multiple names.          Using svn_io_open_uniquely_named() here because other tempfile         creation functions tweak the permission bits of files they create.       */
name|randomish
operator|=
operator|(
operator|(
name|apr_uint32_t
operator|)
operator|(
name|apr_uintptr_t
operator|)
name|scratch_pool
operator|+
operator|(
name|apr_uint32_t
operator|)
name|apr_time_now
argument_list|()
operator|)
expr_stmt|;
name|fname_base
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"svn-%08x"
argument_list|,
name|randomish
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
operator|&
name|fd
argument_list|,
operator|&
name|fname
argument_list|,
name|NULL
argument_list|,
name|fname_base
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_file_info_get
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_PROT
argument_list|,
name|fd
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|fd
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_remove_file2
argument_list|(
name|fname
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|perms
operator|=
name|finfo
operator|.
name|protection
expr_stmt|;
name|default_perms
operator|=
name|finfo
operator|.
name|protection
expr_stmt|;
block|}
else|else
operator|*
name|perms
operator|=
name|default_perms
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* OR together permission bits of the file FD and the default permissions    of a file as determined by get_default_file_perms(). Do temporary    allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_default_file_perms
parameter_list|(
name|apr_file_t
modifier|*
name|fd
parameter_list|,
name|apr_fileperms_t
modifier|*
name|perms
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_fileperms_t
name|default_perms
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_default_file_perms
argument_list|(
operator|&
name|default_perms
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_info_get
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_PROT
argument_list|,
name|fd
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Glom the perms together. */
operator|*
name|perms
operator|=
name|default_perms
operator||
name|finfo
operator|.
name|protection
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is a helper function for the svn_io_set_file_read* functions    that attempts to honor the users umask when dealing with    permission changes.  It is a no-op when invoked on a symlink. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|io_set_file_perms
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|change_readwrite
parameter_list|,
name|svn_boolean_t
name|enable_write
parameter_list|,
name|svn_boolean_t
name|change_executable
parameter_list|,
name|svn_boolean_t
name|executable
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_fileperms_t
name|perms_to_set
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to change only a minimal amount of the perms first      by getting the current perms and adding bits      only on where read perms are granted.  If this fails      fall through to just setting file attributes. */
name|status
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path_apr
argument_list|,
name|APR_FINFO_PROT
operator||
name|APR_FINFO_LINK
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|ignore_enoent
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
elseif|else
if|if
condition|(
name|status
operator|!=
name|APR_ENOTIMPL
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't change perms of file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|finfo
operator|.
name|filetype
operator|==
name|APR_LNK
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|perms_to_set
operator|=
name|finfo
operator|.
name|protection
expr_stmt|;
if|if
condition|(
name|change_readwrite
condition|)
block|{
if|if
condition|(
name|enable_write
condition|)
comment|/* Make read-write. */
block|{
comment|/* Tweak the owner bits only. The group/other bits aren't safe to            * touch because we may end up setting them in undesired ways. */
name|perms_to_set
operator||=
operator|(
name|APR_UREAD
operator||
name|APR_UWRITE
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|finfo
operator|.
name|protection
operator|&
name|APR_UREAD
condition|)
name|perms_to_set
operator|&=
operator|~
name|APR_UWRITE
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|protection
operator|&
name|APR_GREAD
condition|)
name|perms_to_set
operator|&=
operator|~
name|APR_GWRITE
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|protection
operator|&
name|APR_WREAD
condition|)
name|perms_to_set
operator|&=
operator|~
name|APR_WWRITE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|change_executable
condition|)
block|{
if|if
condition|(
name|executable
condition|)
block|{
if|if
condition|(
name|finfo
operator|.
name|protection
operator|&
name|APR_UREAD
condition|)
name|perms_to_set
operator||=
name|APR_UEXECUTE
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|protection
operator|&
name|APR_GREAD
condition|)
name|perms_to_set
operator||=
name|APR_GEXECUTE
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|protection
operator|&
name|APR_WREAD
condition|)
name|perms_to_set
operator||=
name|APR_WEXECUTE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|finfo
operator|.
name|protection
operator|&
name|APR_UREAD
condition|)
name|perms_to_set
operator|&=
operator|~
name|APR_UEXECUTE
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|protection
operator|&
name|APR_GREAD
condition|)
name|perms_to_set
operator|&=
operator|~
name|APR_GEXECUTE
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|protection
operator|&
name|APR_WREAD
condition|)
name|perms_to_set
operator|&=
operator|~
name|APR_WEXECUTE
expr_stmt|;
block|}
block|}
comment|/* If we aren't changing anything then just return, this saves      some system calls and helps with shared working copies */
if|if
condition|(
name|perms_to_set
operator|==
name|finfo
operator|.
name|protection
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|status
operator|=
name|apr_file_perms_set
argument_list|(
name|path_apr
argument_list|,
name|perms_to_set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|APR_STATUS_IS_EPERM
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* We don't have permissions to change the          permissions!  Try a move, copy, and delete          workaround to see if we can get the file owned by          us.  If these succeed, try the permissions set          again.           Note that we only attempt this in the          stat-available path.  This assumes that the          move-copy workaround will only be helpful on          platforms that implement apr_stat. */
name|SVN_ERR
argument_list|(
name|reown_file
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_file_perms_set
argument_list|(
name|path_apr
argument_list|,
name|perms_to_set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|status
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|ignore_enoent
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
elseif|else
if|if
condition|(
name|status
operator|==
name|APR_ENOTIMPL
condition|)
block|{
comment|/* At least try to set the attributes. */
name|apr_fileattrs_t
name|attrs
init|=
literal|0
decl_stmt|;
name|apr_fileattrs_t
name|attrs_values
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|change_readwrite
condition|)
block|{
name|attrs
operator|=
name|APR_FILE_ATTR_READONLY
expr_stmt|;
if|if
condition|(
operator|!
name|enable_write
condition|)
name|attrs_values
operator|=
name|APR_FILE_ATTR_READONLY
expr_stmt|;
block|}
if|if
condition|(
name|change_executable
condition|)
block|{
name|attrs
operator|=
name|APR_FILE_ATTR_EXECUTABLE
expr_stmt|;
if|if
condition|(
name|executable
condition|)
name|attrs_values
operator|=
name|APR_FILE_ATTR_EXECUTABLE
expr_stmt|;
block|}
name|status
operator|=
name|apr_file_attrs_set
argument_list|(
name|path_apr
argument_list|,
name|attrs
argument_list|,
name|attrs_values
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't change perms of file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !WIN32&& !__OS2__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_if
if|#
directive|if
name|APR_HAS_UNICODE_FS
end_if

begin_comment
comment|/* copy of the apr function utf8_to_unicode_path since apr doesn't export this one */
end_comment

begin_function
specifier|static
name|apr_status_t
name|io_utf8_to_unicode_path
parameter_list|(
name|apr_wchar_t
modifier|*
name|retstr
parameter_list|,
name|apr_size_t
name|retlen
parameter_list|,
specifier|const
name|char
modifier|*
name|srcstr
parameter_list|)
block|{
comment|/* TODO: The computations could preconvert the string to determine      * the true size of the retstr, but that's a memory over speed      * tradeoff that isn't appropriate this early in development.      *      * Allocate the maximum string length based on leading 4      * characters of \\?\ (allowing nearly unlimited path lengths)      * plus the trailing null, then transform /'s into \\'s since      * the \\?\ form doesn't allow '/' path separators.      *      * Note that the \\?\ form only works for local drive paths, and      * \\?\UNC\ is needed UNC paths.      */
name|apr_size_t
name|srcremains
init|=
name|strlen
argument_list|(
name|srcstr
argument_list|)
operator|+
literal|1
decl_stmt|;
name|apr_wchar_t
modifier|*
name|t
init|=
name|retstr
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
comment|/* This is correct, we don't twist the filename if it will      * definitely be shorter than 248 characters.  It merits some      * performance testing to see if this has any effect, but there      * seem to be applications that get confused by the resulting      * Unicode \\?\ style file names, especially if they use argv[0]      * or call the Win32 API functions such as GetModuleName, etc.      * Not every application is prepared to handle such names.      *      * Note also this is shorter than MAX_PATH, as directory paths      * are actually limited to 248 characters.      *      * Note that a utf-8 name can never result in more wide chars      * than the original number of utf-8 narrow chars.      */
if|if
condition|(
name|srcremains
operator|>
literal|248
condition|)
block|{
if|if
condition|(
name|srcstr
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
operator|(
name|srcstr
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|srcstr
index|[
literal|2
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|wcscpy
argument_list|(
name|retstr
argument_list|,
literal|L"\\\\?\\"
argument_list|)
expr_stmt|;
name|retlen
operator|-=
literal|4
expr_stmt|;
name|t
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|srcstr
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|srcstr
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|srcstr
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|srcstr
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|srcstr
index|[
literal|2
index|]
operator|!=
literal|'?'
operator|)
condition|)
block|{
comment|/* Skip the slashes */
name|srcstr
operator|+=
literal|2
expr_stmt|;
name|srcremains
operator|-=
literal|2
expr_stmt|;
name|wcscpy
argument_list|(
name|retstr
argument_list|,
literal|L"\\\\?\\UNC\\"
argument_list|)
expr_stmt|;
name|retlen
operator|-=
literal|8
expr_stmt|;
name|t
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rv
operator|=
name|apr_conv_utf8_to_ucs2
argument_list|(
name|srcstr
argument_list|,
operator|&
name|srcremains
argument_list|,
name|t
argument_list|,
operator|&
name|retlen
argument_list|)
condition|)
block|{
return|return
operator|(
name|rv
operator|==
name|APR_INCOMPLETE
operator|)
condition|?
name|APR_EINVAL
else|:
name|rv
return|;
block|}
if|if
condition|(
name|srcremains
condition|)
block|{
return|return
name|APR_ENAMETOOLONG
return|;
block|}
for|for
control|(
init|;
operator|*
name|t
condition|;
operator|++
name|t
control|)
if|if
condition|(
operator|*
name|t
operator|==
literal|L'
expr|/'
condition|)
operator|*
name|t
operator|=
literal|L'
expr|\\'
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|apr_status_t
name|io_win_file_attrs_set
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|DWORD
name|attributes
parameter_list|,
name|DWORD
name|attr_mask
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* this is an implementation of apr_file_attrs_set() but one        that uses the proper Windows attributes instead of the apr        attributes. This way, we can apply any Windows file and        folder attributes even if apr doesn't implement them */
name|DWORD
name|flags
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
if|#
directive|if
name|APR_HAS_UNICODE_FS
name|apr_wchar_t
name|wfname
index|[
name|APR_PATH_MAX
index|]
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|APR_HAS_UNICODE_FS
name|IF_WIN_OS_IS_UNICODE
block|{
if|if
condition|(
name|rv
operator|=
name|io_utf8_to_unicode_path
argument_list|(
name|wfname
argument_list|,
sizeof|sizeof
argument_list|(
name|wfname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|wfname
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|fname
argument_list|)
condition|)
return|return
name|rv
return|;
name|flags
operator|=
name|GetFileAttributesW
argument_list|(
name|wfname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|APR_HAS_ANSI_FS
name|ELSE_WIN_OS_IS_ANSI
block|{
name|flags
operator|=
name|GetFileAttributesA
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|flags
operator|==
literal|0xFFFFFFFF
condition|)
return|return
name|apr_get_os_error
argument_list|()
return|;
name|flags
operator|&=
operator|~
name|attr_mask
expr_stmt|;
name|flags
operator||=
operator|(
name|attributes
operator|&
name|attr_mask
operator|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_UNICODE_FS
name|IF_WIN_OS_IS_UNICODE
block|{
name|rv
operator|=
name|SetFileAttributesW
argument_list|(
name|wfname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|APR_HAS_ANSI_FS
name|ELSE_WIN_OS_IS_ANSI
block|{
name|rv
operator|=
name|SetFileAttributesA
argument_list|(
name|fname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
return|return
name|apr_get_os_error
argument_list|()
return|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|svn_error_t
modifier|*
name|svn_io_set_file_read_write_carefully
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|enable_write
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|enable_write
condition|)
return|return
name|svn_io_set_file_read_write
argument_list|(
name|path
argument_list|,
name|ignore_enoent
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|svn_io_set_file_read_only
argument_list|(
name|path
argument_list|,
name|ignore_enoent
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_set_file_read_only
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* On Windows and OS/2, just set the file attributes -- on unix call      our internal function which attempts to honor the umask. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
return|return
name|io_set_file_perms
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ignore_enoent
argument_list|,
name|pool
argument_list|)
return|;
else|#
directive|else
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_file_attrs_set
argument_list|(
name|path_apr
argument_list|,
name|APR_FILE_ATTR_READONLY
argument_list|,
name|APR_FILE_ATTR_READONLY
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
name|status
operator|!=
name|APR_ENOTIMPL
condition|)
if|if
condition|(
operator|!
name|ignore_enoent
operator|||
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't set file '%s' read-only"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_set_file_read_write
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* On Windows and OS/2, just set the file attributes -- on unix call      our internal function which attempts to honor the umask. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
return|return
name|io_set_file_perms
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ignore_enoent
argument_list|,
name|pool
argument_list|)
return|;
else|#
directive|else
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_file_attrs_set
argument_list|(
name|path_apr
argument_list|,
literal|0
argument_list|,
name|APR_FILE_ATTR_READONLY
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
name|status
operator|!=
name|APR_ENOTIMPL
condition|)
if|if
condition|(
operator|!
name|ignore_enoent
operator|||
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't set file '%s' read-write"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_set_file_executable
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|executable
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* On Windows and OS/2, just exit -- on unix call our internal function   which attempts to honor the umask. */
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
operator|)
return|return
name|io_set_file_perms
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|executable
argument_list|,
name|ignore_enoent
argument_list|,
name|pool
argument_list|)
return|;
else|#
directive|else
return|return
name|SVN_NO_ERROR
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io__is_finfo_read_only
parameter_list|(
name|svn_boolean_t
modifier|*
name|read_only
parameter_list|,
name|apr_finfo_t
modifier|*
name|file_info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|APR_HAS_USER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_uid_t
name|uid
decl_stmt|;
name|apr_gid_t
name|gid
decl_stmt|;
operator|*
name|read_only
operator|=
name|FALSE
expr_stmt|;
name|apr_err
operator|=
name|apr_uid_current
argument_list|(
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error getting UID of process"
argument_list|)
argument_list|)
return|;
comment|/* Check write bit for current user. */
if|if
condition|(
name|apr_uid_compare
argument_list|(
name|uid
argument_list|,
name|file_info
operator|->
name|user
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
operator|*
name|read_only
operator|=
operator|!
operator|(
name|file_info
operator|->
name|protection
operator|&
name|APR_UWRITE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|apr_gid_compare
argument_list|(
name|gid
argument_list|,
name|file_info
operator|->
name|group
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
operator|*
name|read_only
operator|=
operator|!
operator|(
name|file_info
operator|->
name|protection
operator|&
name|APR_GWRITE
operator|)
expr_stmt|;
else|else
operator|*
name|read_only
operator|=
operator|!
operator|(
name|file_info
operator|->
name|protection
operator|&
name|APR_WWRITE
operator|)
expr_stmt|;
else|#
directive|else
comment|/* WIN32 || __OS2__ || !APR_HAS_USER */
operator|*
name|read_only
operator|=
operator|(
name|file_info
operator|->
name|protection
operator|&
name|APR_FREADONLY
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io__is_finfo_executable
parameter_list|(
name|svn_boolean_t
modifier|*
name|executable
parameter_list|,
name|apr_finfo_t
modifier|*
name|file_info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|APR_HAS_USER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_uid_t
name|uid
decl_stmt|;
name|apr_gid_t
name|gid
decl_stmt|;
operator|*
name|executable
operator|=
name|FALSE
expr_stmt|;
name|apr_err
operator|=
name|apr_uid_current
argument_list|(
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error getting UID of process"
argument_list|)
argument_list|)
return|;
comment|/* Check executable bit for current user. */
if|if
condition|(
name|apr_uid_compare
argument_list|(
name|uid
argument_list|,
name|file_info
operator|->
name|user
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
operator|*
name|executable
operator|=
operator|(
name|file_info
operator|->
name|protection
operator|&
name|APR_UEXECUTE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|apr_gid_compare
argument_list|(
name|gid
argument_list|,
name|file_info
operator|->
name|group
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
operator|*
name|executable
operator|=
operator|(
name|file_info
operator|->
name|protection
operator|&
name|APR_GEXECUTE
operator|)
expr_stmt|;
else|else
operator|*
name|executable
operator|=
operator|(
name|file_info
operator|->
name|protection
operator|&
name|APR_WEXECUTE
operator|)
expr_stmt|;
else|#
directive|else
comment|/* WIN32 || __OS2__ || !APR_HAS_USER */
operator|*
name|executable
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_is_file_executable
parameter_list|(
name|svn_boolean_t
modifier|*
name|executable
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|APR_HAS_USER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
name|apr_finfo_t
name|file_info
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|file_info
argument_list|,
name|path
argument_list|,
name|APR_FINFO_PROT
operator||
name|APR_FINFO_OWNER
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io__is_finfo_executable
argument_list|(
name|executable
argument_list|,
operator|&
name|file_info
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* WIN32 || __OS2__ || !APR_HAS_USER */
operator|*
name|executable
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** File locking. ***/
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
end_if

begin_comment
comment|/* Clear all outstanding locks on ARG, an open apr_file_t *. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|file_clear_locks
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_file_t
modifier|*
name|f
init|=
name|arg
decl_stmt|;
comment|/* Remove locks. */
name|apr_err
operator|=
name|apr_file_unlock
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|apr_err
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|svn_error_t
modifier|*
name|svn_io_lock_open_file
parameter_list|(
name|apr_file_t
modifier|*
name|lockfile_handle
parameter_list|,
name|svn_boolean_t
name|exclusive
parameter_list|,
name|svn_boolean_t
name|nonblocking
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|locktype
init|=
name|APR_FLOCK_SHARED
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|exclusive
condition|)
name|locktype
operator|=
name|APR_FLOCK_EXCLUSIVE
expr_stmt|;
if|if
condition|(
name|nonblocking
condition|)
name|locktype
operator||=
name|APR_FLOCK_NONBLOCK
expr_stmt|;
comment|/* We need this only in case of an error but this is cheap to get -    * so we do it here for clarity. */
name|apr_err
operator|=
name|apr_file_name_get
argument_list|(
operator|&
name|fname
argument_list|,
name|lockfile_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get file name"
argument_list|)
argument_list|)
return|;
comment|/* Get lock on the filehandle. */
name|apr_err
operator|=
name|apr_file_lock
argument_list|(
name|lockfile_handle
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
comment|/* In deployments with two or more multithreaded servers running on      the same system serving two or more fsfs repositories it is      possible for a deadlock to occur when getting a write lock on      db/txn-current-lock:       Process 1                         Process 2      ---------                         ---------      thread 1: get lock in repos A                                        thread 1: get lock in repos B                                        thread 2: block getting lock in repos A      thread 2: try to get lock in B *** deadlock ***       Retry for a while for the deadlock to clear. */
name|FILE_LOCK_RETRY_LOOP
argument_list|(
name|apr_err
argument_list|,
name|apr_file_lock
argument_list|(
name|lockfile_handle
argument_list|,
name|locktype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
switch|switch
condition|(
name|locktype
operator|&
name|APR_FLOCK_TYPEMASK
condition|)
block|{
case|case
name|APR_FLOCK_SHARED
case|:
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get shared lock on file '%s'"
argument_list|)
argument_list|,
name|try_utf8_from_internal_style
argument_list|(
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
case|case
name|APR_FLOCK_EXCLUSIVE
case|:
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get exclusive lock on file '%s'"
argument_list|)
argument_list|,
name|try_utf8_from_internal_style
argument_list|(
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* On Windows and OS/2 file locks are automatically released when    the file handle closes */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|lockfile_handle
argument_list|,
name|file_clear_locks
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_unlock_open_file
parameter_list|(
name|apr_file_t
modifier|*
name|lockfile_handle
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
comment|/* We need this only in case of an error but this is cheap to get -    * so we do it here for clarity. */
name|apr_err
operator|=
name|apr_file_name_get
argument_list|(
operator|&
name|fname
argument_list|,
name|lockfile_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get file name"
argument_list|)
argument_list|)
return|;
comment|/* The actual unlock attempt. */
name|apr_err
operator|=
name|apr_file_unlock
argument_list|(
name|lockfile_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't unlock file '%s'"
argument_list|)
argument_list|,
name|try_utf8_from_internal_style
argument_list|(
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* On Windows and OS/2 file locks are automatically released when    the file handle closes */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
name|apr_pool_cleanup_kill
argument_list|(
name|pool
argument_list|,
name|lockfile_handle
argument_list|,
name|file_clear_locks
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_lock2
parameter_list|(
specifier|const
name|char
modifier|*
name|lock_file
parameter_list|,
name|svn_boolean_t
name|exclusive
parameter_list|,
name|svn_boolean_t
name|nonblocking
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|locktype
init|=
name|APR_FLOCK_SHARED
decl_stmt|;
name|apr_file_t
modifier|*
name|lockfile_handle
decl_stmt|;
name|apr_int32_t
name|flags
decl_stmt|;
if|if
condition|(
name|exclusive
condition|)
name|locktype
operator|=
name|APR_FLOCK_EXCLUSIVE
expr_stmt|;
name|flags
operator|=
name|APR_READ
expr_stmt|;
if|if
condition|(
name|locktype
operator|==
name|APR_FLOCK_EXCLUSIVE
condition|)
name|flags
operator||=
name|APR_WRITE
expr_stmt|;
comment|/* locktype is never read after this block, so we don't need to bother      setting it.  If that were to ever change, uncomment the following      block.   if (nonblocking)     locktype |= APR_FLOCK_NONBLOCK;   */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|lockfile_handle
argument_list|,
name|lock_file
argument_list|,
name|flags
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get lock on the filehandle. */
return|return
name|svn_io_lock_open_file
argument_list|(
name|lockfile_handle
argument_list|,
name|exclusive
argument_list|,
name|nonblocking
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Data consistency/coherency operations. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_flush_to_disk
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_os_file_t
name|filehand
decl_stmt|;
comment|/* First make sure that any user-space buffered data is flushed. */
name|SVN_ERR
argument_list|(
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_flush
argument_list|(
name|file
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't flush file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't flush stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_os_file_get
argument_list|(
operator|&
name|filehand
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Call the operating system specific function to actually force the      data to disk. */
block|{
ifdef|#
directive|ifdef
name|WIN32
if|if
condition|(
operator|!
name|FlushFileBuffers
argument_list|(
name|filehand
argument_list|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Can't flush file to disk"
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|int
name|rv
decl_stmt|;
do|do
block|{
name|rv
operator|=
name|fsync
argument_list|(
name|filehand
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|APR_STATUS_IS_EINTR
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|)
condition|)
do|;
comment|/* If the file is in a memory filesystem, fsync() may return          EINVAL.  Presumably the user knows the risks, and we can just          ignore the error. */
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|APR_STATUS_IS_EINVAL
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_get_os_error
argument_list|()
argument_list|,
name|_
argument_list|(
literal|"Can't flush file to disk"
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* TODO write test for these two functions, then refactor. */
end_comment

begin_comment
comment|/* Set RESULT to an svn_stringbuf_t containing the contents of FILE.    FILENAME is the FILE's on-disk APR-safe name, or NULL if that name    isn't known.  If CHECK_SIZE is TRUE, the function will attempt to    first stat() the file to determine it's size before sucking its    contents into the stringbuf.  (Doing so can prevent unnecessary    memory usage, an unwanted side effect of the stringbuf growth and    reallocation mechanism.)  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stringbuf_from_aprfile
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_boolean_t
name|check_size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|res_initial_len
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
comment|/* If our caller wants us to check the size of the file for      efficient memory handling, we'll try to do so. */
if|if
condition|(
name|check_size
condition|)
block|{
name|apr_status_t
name|status
decl_stmt|;
comment|/* If our caller didn't tell us the file's name, we'll ask APR          if it knows the name.  No problem if we can't figure it out.  */
if|if
condition|(
operator|!
name|filename
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename_apr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|=
name|apr_file_name_get
argument_list|(
operator|&
name|filename_apr
argument_list|,
name|file
argument_list|)
operator|)
condition|)
name|filename
operator|=
name|filename_apr
expr_stmt|;
block|}
comment|/* If we now know the filename, try to stat().  If we succeed,          we know how to allocate our stringbuf.  */
if|if
condition|(
name|filename
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|filename
argument_list|,
name|APR_FINFO_MIN
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
name|res_initial_len
operator|=
operator|(
name|apr_size_t
operator|)
name|finfo
operator|.
name|size
expr_stmt|;
block|}
block|}
comment|/* XXX: We should check the incoming data for being of type binary. */
name|res
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|res_initial_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* apr_file_read will not return data and eof in the same call. So this loop    * is safe from missing read data.  */
name|len
operator|=
name|SVN__STREAM_CHUNK_SIZE
expr_stmt|;
name|err
operator|=
name|svn_io_file_read
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|err
condition|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|SVN__STREAM_CHUNK_SIZE
expr_stmt|;
name|err
operator|=
name|svn_io_file_read
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Having read all the data we *expect* EOF */
if|if
condition|(
name|err
operator|&&
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|err
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|res
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stringbuf_from_file2
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|filename
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
if|if
condition|(
operator|(
name|apr_err
operator|=
name|apr_file_open_stdin
argument_list|(
operator|&
name|f
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't open stdin"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|stringbuf_from_aprfile
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|,
name|f
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|f
argument_list|,
name|filename
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stringbuf_from_aprfile
argument_list|(
name|result
argument_list|,
name|filename
argument_list|,
name|f
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_io_file_close
argument_list|(
name|f
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stringbuf_from_file
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|filename
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading from stdin is disallowed"
argument_list|)
argument_list|)
return|;
return|return
name|svn_stringbuf_from_file2
argument_list|(
name|result
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_stringbuf_from_aprfile
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|result
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|stringbuf_from_aprfile
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|,
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Deletion. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_io_remove_file2
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_file_remove
argument_list|(
name|path_apr
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apr_err
operator|||
operator|(
name|ignore_enoent
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|apr_err
argument_list|)
operator|)
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
ifdef|#
directive|ifdef
name|WIN32
comment|/* If the target is read only NTFS reports EACCESS and FAT/FAT32      reports EEXIST */
if|if
condition|(
name|APR_STATUS_IS_EACCES
argument_list|(
name|apr_err
argument_list|)
operator|||
name|APR_STATUS_IS_EEXIST
argument_list|(
name|apr_err
argument_list|)
condition|)
block|{
comment|/* Set the destination file writable because Windows will not          allow us to delete when path is read-only */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_write
argument_list|(
name|path
argument_list|,
name|ignore_enoent
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_file_remove
argument_list|(
name|path_apr
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apr_err
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
block|{
name|apr_status_t
name|os_err
init|=
name|APR_TO_OS_ERROR
argument_list|(
name|apr_err
argument_list|)
decl_stmt|;
comment|/* Check to make sure we aren't trying to delete a directory */
if|if
condition|(
name|os_err
operator|==
name|ERROR_ACCESS_DENIED
operator|||
name|os_err
operator|==
name|ERROR_SHARING_VIOLATION
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
if|if
condition|(
operator|!
name|apr_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path_apr
argument_list|,
name|APR_FINFO_TYPE
argument_list|,
name|scratch_pool
argument_list|)
operator|&&
name|finfo
operator|.
name|filetype
operator|==
name|APR_REG
condition|)
block|{
name|WIN32_RETRY_LOOP
argument_list|(
name|apr_err
argument_list|,
name|apr_file_remove
argument_list|(
name|path_apr
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Just return the delete error */
block|}
endif|#
directive|endif
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't remove file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_remove_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_io_remove_dir2
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  Mac OS X has a bug where if you're reading the contents of a  directory via readdir in a loop, and you remove one of the entries in  the directory and the directory has 338 or more files in it you will  skip over some of the entries in the directory.  Needless to say,  this causes problems if you are using this kind of loop inside a  function that is recursively deleting a directory, because when you  get around to removing the directory it will still have something in  it. A similar problem has been observed in other BSDs. This bug has  since been fixed. See http://www.vnode.ch/fixing_seekdir for details.   The workaround is to delete the files only _after_ the initial  directory scan.  A previous workaround involving rewinddir is  problematic on Win32 and some NFS clients, notably NetBSD.   See http://subversion.tigris.org/issues/show_bug.cgi?id=1896 and  http://subversion.tigris.org/issues/show_bug.cgi?id=3501. */
end_comment

begin_comment
comment|/* Neither windows nor unix allows us to delete a non-empty    directory.     This is a function to perform the equivalent of 'rm -rf'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_io_remove_dir2
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Check for pending cancellation request.      If we need to bail out, do so early. */
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|cancel_func
call|)
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* if the directory doesn't exist, our mission is accomplished */
if|if
condition|(
name|ignore_enoent
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fullpath
decl_stmt|;
name|fullpath
operator|=
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* Don't check for cancellation, the callee will immediately do so */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|fullpath
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|cancel_func
call|)
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_remove_file2
argument_list|(
name|fullpath
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Can't remove '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fullpath
argument_list|,
name|subpool
argument_list|)
argument_list|)
return|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|svn_io_dir_remove_nonrecursive
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_get_dir_filenames
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|dirents
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_io_get_dirents3
argument_list|(
name|dirents
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_io_dirent2_t
modifier|*
name|svn_io_dirent2_create
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_io_dirent2_t
modifier|*
name|dirent
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dirent
argument_list|)
argument_list|)
decl_stmt|;
comment|/*dirent->kind = svn_node_none;   dirent->special = FALSE;*/
name|dirent
operator|->
name|filesize
operator|=
name|SVN_INVALID_FILESIZE
expr_stmt|;
comment|/*dirent->mtime = 0;*/
return|return
name|dirent
return|;
block|}
end_function

begin_function
name|svn_io_dirent2_t
modifier|*
name|svn_io_dirent2_dup
parameter_list|(
specifier|const
name|svn_io_dirent2_t
modifier|*
name|item
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
return|return
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|item
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_get_dirents3
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|dirents
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|only_check_type
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_dir_t
modifier|*
name|this_dir
decl_stmt|;
name|apr_finfo_t
name|this_entry
decl_stmt|;
name|apr_int32_t
name|flags
init|=
name|APR_FINFO_TYPE
operator||
name|APR_FINFO_NAME
decl_stmt|;
if|if
condition|(
operator|!
name|only_check_type
condition|)
name|flags
operator||=
name|APR_FINFO_SIZE
operator||
name|APR_FINFO_MTIME
expr_stmt|;
operator|*
name|dirents
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_dir_open
argument_list|(
operator|&
name|this_dir
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|status
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|this_entry
argument_list|,
name|flags
argument_list|,
name|this_dir
argument_list|)
init|;
name|status
operator|==
name|APR_SUCCESS
condition|;
name|status
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|this_entry
argument_list|,
name|flags
argument_list|,
name|this_dir
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|this_entry
operator|.
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|svn_io_dirent2_t
modifier|*
name|dirent
init|=
name|svn_io_dirent2_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|entry_name_to_utf8
argument_list|(
operator|&
name|name
argument_list|,
name|this_entry
operator|.
name|name
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|map_apr_finfo_to_node_kind
argument_list|(
operator|&
operator|(
name|dirent
operator|->
name|kind
operator|)
argument_list|,
operator|&
operator|(
name|dirent
operator|->
name|special
operator|)
argument_list|,
operator|&
name|this_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|only_check_type
condition|)
block|{
name|dirent
operator|->
name|filesize
operator|=
name|this_entry
operator|.
name|size
expr_stmt|;
name|dirent
operator|->
name|mtime
operator|=
name|this_entry
operator|.
name|mtime
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
operator|*
name|dirents
argument_list|,
name|name
argument_list|,
name|dirent
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|status
argument_list|)
operator|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't read directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|status
operator|=
name|apr_dir_close
argument_list|(
name|this_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Error closing directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_stat_dirent2
parameter_list|(
specifier|const
name|svn_io_dirent2_t
modifier|*
modifier|*
name|dirent_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|verify_truename
parameter_list|,
name|svn_boolean_t
name|ignore_enoent
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|svn_io_dirent2_t
modifier|*
name|dirent
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_int32_t
name|wanted
init|=
name|APR_FINFO_TYPE
operator||
name|APR_FINFO_LINK
operator||
name|APR_FINFO_SIZE
operator||
name|APR_FINFO_MTIME
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__OS2__
argument_list|)
if|if
condition|(
name|verify_truename
condition|)
name|wanted
operator||=
name|APR_FINFO_NAME
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|wanted
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|ignore_enoent
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|dirent
operator|=
name|svn_io_dirent2_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_none
argument_list|)
expr_stmt|;
operator|*
name|dirent_p
operator|=
name|dirent
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__OS2__
argument_list|)
operator|||
name|defined
argument_list|(
name|DARWIN
argument_list|)
if|if
condition|(
name|verify_truename
condition|)
block|{
specifier|const
name|char
modifier|*
name|requested_name
init|=
name|svn_dirent_basename
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|requested_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* No parent directory. No need to stat/verify */
block|}
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__OS2__
argument_list|)
elseif|else
if|if
condition|(
name|finfo
operator|.
name|name
condition|)
block|{
specifier|const
name|char
modifier|*
name|name_on_disk
decl_stmt|;
name|SVN_ERR
argument_list|(
name|entry_name_to_utf8
argument_list|(
operator|&
name|name_on_disk
argument_list|,
name|finfo
operator|.
name|name
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name_on_disk
argument_list|,
name|requested_name
argument_list|)
comment|/* != 0 */
condition|)
block|{
if|if
condition|(
name|ignore_enoent
condition|)
block|{
operator|*
name|dirent_p
operator|=
name|svn_io_dirent2_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|APR_ENOENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' not found, case obstructed by '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|name_on_disk
argument_list|)
return|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|DARWIN
argument_list|)
comment|/* Currently apr doesn't set finfo.name on DARWIN, returning                    APR_INCOMPLETE.          ### Can we optimize this in another way? */
else|else
block|{
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|err
operator|=
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
comment|/* only_check_type */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|ignore_enoent
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|dirent_p
operator|=
name|svn_io_dirent2_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|dirents
argument_list|,
name|requested_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ignore_enoent
condition|)
block|{
operator|*
name|dirent_p
operator|=
name|svn_io_dirent2_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|APR_ENOENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' not found"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
name|dirent
operator|=
name|svn_io_dirent2_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|map_apr_finfo_to_node_kind
argument_list|(
operator|&
operator|(
name|dirent
operator|->
name|kind
operator|)
argument_list|,
operator|&
operator|(
name|dirent
operator|->
name|special
operator|)
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
name|dirent
operator|->
name|filesize
operator|=
name|finfo
operator|.
name|size
expr_stmt|;
name|dirent
operator|->
name|mtime
operator|=
name|finfo
operator|.
name|mtime
expr_stmt|;
operator|*
name|dirent_p
operator|=
name|dirent
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Pool userdata key for the error file passed to svn_io_start_cmd(). */
end_comment

begin_define
define|#
directive|define
name|ERRFILE_KEY
value|"svn-io-start-cmd-errfile"
end_define

begin_comment
comment|/* Handle an error from the child process (before command execution) by    printing DESC and the error string corresponding to STATUS to stderr. */
end_comment

begin_function
specifier|static
name|void
name|handle_child_process_error
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_status_t
name|status
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|256
index|]
decl_stmt|;
name|apr_file_t
modifier|*
name|errfile
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
comment|/* We can't do anything if we get an error here, so just return. */
if|if
condition|(
name|apr_pool_userdata_get
argument_list|(
operator|&
name|p
argument_list|,
name|ERRFILE_KEY
argument_list|,
name|pool
argument_list|)
condition|)
return|return;
name|errfile
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|errfile
condition|)
comment|/* What we get from APR is in native encoding. */
name|apr_file_printf
argument_list|(
name|errfile
argument_list|,
literal|"%s: %s"
argument_list|,
name|desc
argument_list|,
name|apr_strerror
argument_list|(
name|status
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_start_cmd3
parameter_list|(
name|apr_proc_t
modifier|*
name|cmd_proc
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|args
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
name|svn_boolean_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|infile_pipe
parameter_list|,
name|apr_file_t
modifier|*
name|infile
parameter_list|,
name|svn_boolean_t
name|outfile_pipe
parameter_list|,
name|apr_file_t
modifier|*
name|outfile
parameter_list|,
name|svn_boolean_t
name|errfile_pipe
parameter_list|,
name|apr_file_t
modifier|*
name|errfile
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_procattr_t
modifier|*
name|cmdproc_attr
decl_stmt|;
name|int
name|num_args
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|args_native
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd_apr
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|infile
operator|!=
name|NULL
operator|)
operator|&&
name|infile_pipe
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|outfile
operator|!=
name|NULL
operator|)
operator|&&
name|outfile_pipe
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|errfile
operator|!=
name|NULL
operator|)
operator|&&
name|errfile_pipe
operator|)
argument_list|)
expr_stmt|;
comment|/* Create the process attributes. */
name|apr_err
operator|=
name|apr_procattr_create
argument_list|(
operator|&
name|cmdproc_attr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't create process '%s' attributes"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
comment|/* Make sure we invoke cmd directly, not through a shell. */
name|apr_err
operator|=
name|apr_procattr_cmdtype_set
argument_list|(
name|cmdproc_attr
argument_list|,
name|inherit
condition|?
name|APR_PROGRAM_PATH
else|:
name|APR_PROGRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't set process '%s' cmdtype"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
comment|/* Set the process's working directory. */
if|if
condition|(
name|path
condition|)
block|{
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_procattr_dir_set
argument_list|(
name|cmdproc_attr
argument_list|,
name|path_apr
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't set process '%s' directory"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
block|}
comment|/* Use requested inputs and outputs.       ### Unfortunately each of these apr functions creates a pipe and then      overwrites the pipe file descriptor with the descriptor we pass      in. The pipes can then never be closed. This is an APR bug. */
if|if
condition|(
name|infile
condition|)
block|{
name|apr_err
operator|=
name|apr_procattr_child_in_set
argument_list|(
name|cmdproc_attr
argument_list|,
name|infile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't set process '%s' child input"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
block|}
if|if
condition|(
name|outfile
condition|)
block|{
name|apr_err
operator|=
name|apr_procattr_child_out_set
argument_list|(
name|cmdproc_attr
argument_list|,
name|outfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't set process '%s' child outfile"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
block|}
if|if
condition|(
name|errfile
condition|)
block|{
name|apr_err
operator|=
name|apr_procattr_child_err_set
argument_list|(
name|cmdproc_attr
argument_list|,
name|errfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't set process '%s' child errfile"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
block|}
comment|/* Forward request for pipes to APR. */
if|if
condition|(
name|infile_pipe
operator|||
name|outfile_pipe
operator|||
name|errfile_pipe
condition|)
block|{
name|apr_err
operator|=
name|apr_procattr_io_set
argument_list|(
name|cmdproc_attr
argument_list|,
name|infile_pipe
condition|?
name|APR_FULL_BLOCK
else|:
name|APR_NO_PIPE
argument_list|,
name|outfile_pipe
condition|?
name|APR_FULL_BLOCK
else|:
name|APR_NO_PIPE
argument_list|,
name|errfile_pipe
condition|?
name|APR_FULL_BLOCK
else|:
name|APR_NO_PIPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't set process '%s' stdio pipes"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
block|}
comment|/* Have the child print any problems executing its program to errfile. */
name|apr_err
operator|=
name|apr_pool_userdata_set
argument_list|(
name|errfile
argument_list|,
name|ERRFILE_KEY
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't set process '%s' child errfile for "
literal|"error handler"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
name|apr_err
operator|=
name|apr_procattr_child_errfn_set
argument_list|(
name|cmdproc_attr
argument_list|,
name|handle_child_process_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't set process '%s' error handler"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
comment|/* Convert cmd and args from UTF-8 */
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|cmd_apr
argument_list|,
name|cmd
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|num_args
operator|=
literal|0
init|;
name|args
index|[
name|num_args
index|]
condition|;
name|num_args
operator|++
control|)
empty_stmt|;
name|args_native
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
operator|(
name|num_args
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|args_native
index|[
name|num_args
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|num_args
operator|--
condition|)
block|{
comment|/* ### Well, it turns out that on APR on Windows expects all              program args to be in UTF-8. Callers of svn_io_run_cmd              should be aware of that. */
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|args_native
index|[
name|num_args
index|]
argument_list|,
name|args
index|[
name|num_args
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Start the cmd command. */
name|apr_err
operator|=
name|apr_proc_create
argument_list|(
name|cmd_proc
argument_list|,
name|cmd_apr
argument_list|,
name|args_native
argument_list|,
name|inherit
condition|?
name|NULL
else|:
name|env
argument_list|,
name|cmdproc_attr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't start process '%s'"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ERRFILE_KEY
end_undef

begin_function
name|svn_error_t
modifier|*
name|svn_io_wait_for_cmd
parameter_list|(
name|apr_proc_t
modifier|*
name|cmd_proc
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|int
modifier|*
name|exitcode
parameter_list|,
name|apr_exit_why_e
modifier|*
name|exitwhy
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_exit_why_e
name|exitwhy_val
decl_stmt|;
name|int
name|exitcode_val
decl_stmt|;
comment|/* The Win32 apr_proc_wait doesn't set this... */
name|exitwhy_val
operator|=
name|APR_PROC_EXIT
expr_stmt|;
comment|/* Wait for the cmd command to finish. */
name|apr_err
operator|=
name|apr_proc_wait
argument_list|(
name|cmd_proc
argument_list|,
operator|&
name|exitcode_val
argument_list|,
operator|&
name|exitwhy_val
argument_list|,
name|APR_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|APR_STATUS_IS_CHILD_DONE
argument_list|(
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error waiting for process '%s'"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
if|if
condition|(
name|exitwhy
condition|)
operator|*
name|exitwhy
operator|=
name|exitwhy_val
expr_stmt|;
elseif|else
if|if
condition|(
name|APR_PROC_CHECK_SIGNALED
argument_list|(
name|exitwhy_val
argument_list|)
operator|&&
name|APR_PROC_CHECK_CORE_DUMP
argument_list|(
name|exitwhy_val
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Process '%s' failed (signal %d, core dumped)"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|exitcode_val
argument_list|)
return|;
elseif|else
if|if
condition|(
name|APR_PROC_CHECK_SIGNALED
argument_list|(
name|exitwhy_val
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Process '%s' failed (signal %d)"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|exitcode_val
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|APR_PROC_CHECK_EXIT
argument_list|(
name|exitwhy_val
argument_list|)
condition|)
comment|/* Don't really know what happened here. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Process '%s' failed (exitwhy %d, exitcode %d)"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|exitwhy_val
argument_list|,
name|exitcode_val
argument_list|)
return|;
if|if
condition|(
name|exitcode
condition|)
operator|*
name|exitcode
operator|=
name|exitcode_val
expr_stmt|;
elseif|else
if|if
condition|(
name|exitcode_val
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Process '%s' returned error exitcode %d"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|exitcode_val
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_run_cmd
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|exitcode
parameter_list|,
name|apr_exit_why_e
modifier|*
name|exitwhy
parameter_list|,
name|svn_boolean_t
name|inherit
parameter_list|,
name|apr_file_t
modifier|*
name|infile
parameter_list|,
name|apr_file_t
modifier|*
name|outfile
parameter_list|,
name|apr_file_t
modifier|*
name|errfile
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_proc_t
name|cmd_proc
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_start_cmd3
argument_list|(
operator|&
name|cmd_proc
argument_list|,
name|path
argument_list|,
name|cmd
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|,
name|inherit
argument_list|,
name|FALSE
argument_list|,
name|infile
argument_list|,
name|FALSE
argument_list|,
name|outfile
argument_list|,
name|FALSE
argument_list|,
name|errfile
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_io_wait_for_cmd
argument_list|(
operator|&
name|cmd_proc
argument_list|,
name|cmd
argument_list|,
name|exitcode
argument_list|,
name|exitwhy
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_run_diff2
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|user_args
parameter_list|,
name|int
name|num_user_args
parameter_list|,
specifier|const
name|char
modifier|*
name|label1
parameter_list|,
specifier|const
name|char
modifier|*
name|label2
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|,
name|int
modifier|*
name|pexitcode
parameter_list|,
name|apr_file_t
modifier|*
name|outfile
parameter_list|,
name|apr_file_t
modifier|*
name|errfile
parameter_list|,
specifier|const
name|char
modifier|*
name|diff_cmd
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|exitcode
decl_stmt|;
name|int
name|nargs
init|=
literal|4
decl_stmt|;
comment|/* the diff command itself, two paths, plus a trailing NULL */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|pexitcode
operator|==
name|NULL
condition|)
name|pexitcode
operator|=
operator|&
name|exitcode
expr_stmt|;
if|if
condition|(
name|user_args
operator|!=
name|NULL
condition|)
name|nargs
operator|+=
name|num_user_args
expr_stmt|;
else|else
name|nargs
operator|+=
literal|1
expr_stmt|;
comment|/* -u */
if|if
condition|(
name|label1
operator|!=
name|NULL
condition|)
name|nargs
operator|+=
literal|2
expr_stmt|;
comment|/* the -L and the label itself */
if|if
condition|(
name|label2
operator|!=
name|NULL
condition|)
name|nargs
operator|+=
literal|2
expr_stmt|;
comment|/* the -L and the label itself */
name|args
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|diff_cmd
expr_stmt|;
if|if
condition|(
name|user_args
operator|!=
name|NULL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_user_args
condition|;
operator|++
name|j
control|)
name|args
index|[
name|i
operator|++
index|]
operator|=
name|user_args
index|[
name|j
index|]
expr_stmt|;
block|}
else|else
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-u"
expr_stmt|;
comment|/* assume -u if the user didn't give us any args */
if|if
condition|(
name|label1
operator|!=
name|NULL
condition|)
block|{
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-L"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|label1
expr_stmt|;
block|}
if|if
condition|(
name|label2
operator|!=
name|NULL
condition|)
block|{
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-L"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|label2
expr_stmt|;
block|}
name|args
index|[
name|i
operator|++
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|from
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|to
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|i
operator|==
name|nargs
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_run_cmd
argument_list|(
name|dir
argument_list|,
name|diff_cmd
argument_list|,
name|args
argument_list|,
name|pexitcode
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|outfile
argument_list|,
name|errfile
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The man page for (GNU) diff describes the return value as:         "An exit status of 0 means no differences were found, 1 means         some differences were found, and 2 means trouble."       A return value of 2 typically occurs when diff cannot read its input      or write to its output, but in any case we probably ought to return an      error for anything other than 0 or 1 as the output is likely to be      corrupt.    */
if|if
condition|(
operator|*
name|pexitcode
operator|!=
literal|0
operator|&&
operator|*
name|pexitcode
operator|!=
literal|1
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' returned %d"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|diff_cmd
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|*
name|pexitcode
argument_list|)
return|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_run_diff3_3
parameter_list|(
name|int
modifier|*
name|exitcode
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|mine
parameter_list|,
specifier|const
name|char
modifier|*
name|older
parameter_list|,
specifier|const
name|char
modifier|*
name|yours
parameter_list|,
specifier|const
name|char
modifier|*
name|mine_label
parameter_list|,
specifier|const
name|char
modifier|*
name|older_label
parameter_list|,
specifier|const
name|char
modifier|*
name|yours_label
parameter_list|,
name|apr_file_t
modifier|*
name|merged
parameter_list|,
specifier|const
name|char
modifier|*
name|diff3_cmd
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|user_args
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|args
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
literal|13
operator|+
operator|(
name|user_args
condition|?
name|user_args
operator|->
name|nelts
else|:
literal|1
operator|)
operator|)
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|int
name|nargs
init|=
literal|12
decl_stmt|;
endif|#
directive|endif
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Labels fall back to sensible defaults if not specified. */
if|if
condition|(
name|mine_label
operator|==
name|NULL
condition|)
name|mine_label
operator|=
literal|".working"
expr_stmt|;
if|if
condition|(
name|older_label
operator|==
name|NULL
condition|)
name|older_label
operator|=
literal|".old"
expr_stmt|;
if|if
condition|(
name|yours_label
operator|==
name|NULL
condition|)
name|yours_label
operator|=
literal|".new"
expr_stmt|;
comment|/* Set up diff3 command line. */
name|args
index|[
name|i
operator|++
index|]
operator|=
name|diff3_cmd
expr_stmt|;
if|if
condition|(
name|user_args
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|user_args
operator|->
name|nelts
condition|;
operator|++
name|j
control|)
name|args
index|[
name|i
operator|++
index|]
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|user_args
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|nargs
operator|+=
name|user_args
operator|->
name|nelts
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-E"
expr_stmt|;
comment|/* We tried "-A" here, but that caused                                        overlapping identical changes to                                        conflict.  See issue #682. */
ifndef|#
directive|ifndef
name|NDEBUG
operator|++
name|nargs
expr_stmt|;
endif|#
directive|endif
block|}
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-m"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-L"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|mine_label
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-L"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|older_label
expr_stmt|;
comment|/* note:  this label is ignored if                                    using 2-part markers, which is the                                    case with "-E". */
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-L"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|yours_label
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_DIFF3_HAS_DIFF_PROGRAM_ARG
block|{
name|svn_boolean_t
name|has_arg
decl_stmt|;
comment|/* ### FIXME: we really shouldn't be reading the config here;        instead, the necessary bits should be passed in by the caller.        But should we add another parameter to this function, when the        whole external diff3 thing might eventually go away?  */
name|apr_hash_t
modifier|*
name|config
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_config
argument_list|(
operator|&
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|has_arg
argument_list|,
name|SVN_CONFIG_SECTION_HELPERS
argument_list|,
name|SVN_CONFIG_OPTION_DIFF3_HAS_PROGRAM_ARG
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_arg
condition|)
block|{
specifier|const
name|char
modifier|*
name|diff_cmd
decl_stmt|,
modifier|*
name|diff_utf8
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|diff_cmd
argument_list|,
name|SVN_CONFIG_SECTION_HELPERS
argument_list|,
name|SVN_CONFIG_OPTION_DIFF_CMD
argument_list|,
name|SVN_CLIENT_DIFF
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_to_utf8
argument_list|(
operator|&
name|diff_utf8
argument_list|,
name|diff_cmd
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"--diff-program="
argument_list|,
name|diff_utf8
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
operator|++
name|nargs
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
name|args
index|[
name|i
operator|++
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|mine
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|older
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|svn_dirent_local_style
argument_list|(
name|yours
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
name|SVN_ERR_ASSERT
argument_list|(
name|i
operator|==
name|nargs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Run diff3, output the merged text into the scratch file. */
name|SVN_ERR
argument_list|(
name|svn_io_run_cmd
argument_list|(
name|dir
argument_list|,
name|diff3_cmd
argument_list|,
name|args
argument_list|,
name|exitcode
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
comment|/* keep environment */
name|NULL
argument_list|,
name|merged
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* According to the diff3 docs, a '0' means the merge was clean, and      '1' means conflict markers were found.  Anything else is real      error. */
if|if
condition|(
operator|(
operator|*
name|exitcode
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|exitcode
operator|!=
literal|1
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error running '%s':  exitcode was %d, "
literal|"args were:"
literal|"\nin directory '%s', basenames:\n%s\n%s\n%s"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|diff3_cmd
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|*
name|exitcode
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dir
argument_list|,
name|pool
argument_list|)
argument_list|,
comment|/* Don't call svn_path_local_style() on                                 the basenames.  We don't want them to                                 be absolute, and we don't need the                                 separator conversion. */
name|mine
argument_list|,
name|older
argument_list|,
name|yours
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize a string for hashing.  Modifies KEY in place. */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|char
modifier|*
name|fileext_tolower
parameter_list|(
name|char
modifier|*
name|key
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|key
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
operator|++
name|p
control|)
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|apr_tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_parse_mimetypes_file
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|type_map
parameter_list|,
specifier|const
name|char
modifier|*
name|mimetypes_file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_hash_t
modifier|*
name|types
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|eof
init|=
name|FALSE
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|types_file
decl_stmt|;
name|svn_stream_t
modifier|*
name|mimetypes_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|types_file
argument_list|,
name|mimetypes_file
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|mimetypes_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|types_file
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|apr_array_header_t
modifier|*
name|tokens
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Read a line. */
if|if
condition|(
operator|(
name|err
operator|=
name|svn_stream_readline
argument_list|(
name|mimetypes_stream
argument_list|,
operator|&
name|buf
argument_list|,
name|APR_EOL_STR
argument_list|,
operator|&
name|eof
argument_list|,
name|subpool
argument_list|)
operator|)
condition|)
break|break;
comment|/* Only pay attention to non-empty, non-comment lines. */
if|if
condition|(
name|buf
operator|->
name|len
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* Tokenize (into our return pool). */
name|tokens
operator|=
name|svn_cstring_split
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|" \t"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokens
operator|->
name|nelts
operator|<
literal|2
condition|)
continue|continue;
comment|/* The first token in a multi-token line is the media type.              Subsequent tokens are filename extensions associated with              that media type. */
name|type
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|tokens
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|tokens
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* We can safely address 'ext' as a non-const string because                * we know svn_cstring_split() allocated it in 'pool' for us. */
name|char
modifier|*
name|ext
init|=
name|APR_ARRAY_IDX
argument_list|(
name|tokens
argument_list|,
name|i
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|fileext_tolower
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|types
argument_list|,
name|ext
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eof
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* If there was an error above, close the file (ignoring any error      from *that*) and return the originally error. */
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_stream_close
argument_list|(
name|mimetypes_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* Close the stream (which closes the underlying file, too). */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|mimetypes_stream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|type_map
operator|=
name|types
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_detect_mimetype2
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|mimetype
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|apr_hash_t
modifier|*
name|mimetype_map
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|generic_binary
init|=
literal|"application/octet-stream"
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_file_t
modifier|*
name|fh
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|unsigned
name|char
name|block
index|[
literal|1024
index|]
decl_stmt|;
name|apr_size_t
name|amt_read
init|=
sizeof|sizeof
argument_list|(
name|block
argument_list|)
decl_stmt|;
comment|/* Default return value is NULL. */
operator|*
name|mimetype
operator|=
name|NULL
expr_stmt|;
comment|/* If there is a mimetype_map provided, we'll first try to look up      our file's extension in the map.  Failing that, we'll run the      heuristic. */
if|if
condition|(
name|mimetype_map
condition|)
block|{
specifier|const
name|char
modifier|*
name|type_from_map
decl_stmt|;
name|char
modifier|*
name|path_ext
decl_stmt|;
comment|/* Can point to physical const memory but only when                          svn_path_splitext sets it to "". */
name|svn_path_splitext
argument_list|(
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|path_ext
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fileext_tolower
argument_list|(
name|path_ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type_from_map
operator|=
name|svn_hash_gets
argument_list|(
name|mimetype_map
argument_list|,
name|path_ext
argument_list|)
operator|)
condition|)
block|{
operator|*
name|mimetype
operator|=
name|type_from_map
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* See if this file even exists, and make sure it really is a file. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|file
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_FILENAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't detect MIME type of non-file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|fh
argument_list|,
name|file
argument_list|,
name|APR_READ
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read a block of data from FILE. */
name|err
operator|=
name|svn_io_file_read
argument_list|(
name|fh
argument_list|,
name|block
argument_list|,
operator|&
name|amt_read
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|err
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Now close the file.  No use keeping it open any more.  */
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|fh
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_io_is_binary_data
argument_list|(
name|block
argument_list|,
name|amt_read
argument_list|)
condition|)
operator|*
name|mimetype
operator|=
name|generic_binary
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_io_is_binary_data
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|buf
init|=
name|data
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|0xEF
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|0xBB
operator|&&
name|buf
index|[
literal|2
index|]
operator|==
literal|0xBF
condition|)
block|{
comment|/* This is an empty UTF-8 file which only contains the UTF-8 BOM.        * Treat it as plain text. */
return|return
name|FALSE
return|;
block|}
comment|/* Right now, this function is going to be really stupid.  It's      going to examine the block of data, and make sure that 15%      of the bytes are such that their value is in the ranges 0x07-0x0D      or 0x20-0x7F, and that none of those bytes is 0x00.  If those      criteria are not met, we're calling it binary.       NOTE:  Originally, I intended to target 85% of the bytes being in      the specified ranges, but I flubbed the condition.  At any rate,      folks aren't complaining, so I'm not sure that it's worth      adjusting this retroactively now.  --cmpilato  */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|i
decl_stmt|;
name|apr_size_t
name|binary_count
init|=
literal|0
decl_stmt|;
comment|/* Run through the data we've read, counting the 'binary-ish'          bytes.  HINT: If we see a 0x00 byte, we'll set our count to its          max and stop reading the file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|binary_count
operator|=
name|len
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|buf
index|[
name|i
index|]
operator|<
literal|0x07
operator|)
operator|||
operator|(
operator|(
name|buf
index|[
name|i
index|]
operator|>
literal|0x0D
operator|)
operator|&&
operator|(
name|buf
index|[
name|i
index|]
operator|<
literal|0x20
operator|)
operator|)
operator|||
operator|(
name|buf
index|[
name|i
index|]
operator|>
literal|0x7F
operator|)
condition|)
block|{
name|binary_count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
operator|(
name|binary_count
operator|*
literal|1000
operator|)
operator|/
name|len
operator|)
operator|>
literal|850
operator|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_detect_mimetype
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|mimetype
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_io_detect_mimetype2
argument_list|(
name|mimetype
argument_list|,
name|file
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_open
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|new_file
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|apr_int32_t
name|flag
parameter_list|,
name|apr_fileperms_t
name|perm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname_apr
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|fname_apr
argument_list|,
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|file_open
argument_list|(
name|new_file
argument_list|,
name|fname_apr
argument_list|,
name|flag
operator||
name|APR_BINARY
argument_list|,
name|perm
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't open file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
name|svn_error_t
modifier|*
name|do_io_file_wrapper_cleanup
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_status_t
name|status
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_no_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|err
operator|=
name|svn_io_file_name_get
argument_list|(
operator|&
name|name
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* ### Issue #3014: Return a specific error for broken pipes,    * ### with a single element in the error chain. */
if|if
condition|(
name|SVN__APR_STATUS_IS_EPIPE
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_PIPE_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|name
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
name|msg
argument_list|)
argument_list|,
name|try_utf8_from_internal_style
argument_list|(
name|name
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
else|else
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
name|msg_no_name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_close
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_close
argument_list|(
name|file
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't close file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't close stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_getc
parameter_list|(
name|char
modifier|*
name|ch
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_getc
argument_list|(
name|ch
argument_list|,
name|file
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't read file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't read stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_putc
parameter_list|(
name|char
name|ch
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_putc
argument_list|(
name|ch
argument_list|,
name|file
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't write file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't write stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_info_get
parameter_list|(
name|apr_finfo_t
modifier|*
name|finfo
parameter_list|,
name|apr_int32_t
name|wanted
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Quoting APR: On NT this request is incredibly expensive, but accurate. */
name|wanted
operator|&=
operator|~
name|SVN__APR_FINFO_MASK_OUT
expr_stmt|;
return|return
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_info_get
argument_list|(
name|finfo
argument_list|,
name|wanted
argument_list|,
name|file
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't get attribute information from file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't get attribute information from stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_read
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|nbytes
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_read
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't read file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't read stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_read_full2
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|nbytes
parameter_list|,
name|apr_size_t
modifier|*
name|bytes_read
parameter_list|,
name|svn_boolean_t
modifier|*
name|hit_eof
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|apr_file_read_full
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|,
name|bytes_read
argument_list|)
decl_stmt|;
if|if
condition|(
name|hit_eof
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
block|{
operator|*
name|hit_eof
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
operator|*
name|hit_eof
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|status
argument_list|,
name|N_
argument_list|(
literal|"Can't read file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't read stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_seek
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_seek_where_t
name|where
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_seek
argument_list|(
name|file
argument_list|,
name|where
argument_list|,
name|offset
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't set position pointer in file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't set position pointer in stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_write
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|nbytes
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_write
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't write to file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't write to stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_write_full
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|nbytes
parameter_list|,
name|apr_size_t
modifier|*
name|bytes_written
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* We cannot simply call apr_file_write_full on Win32 as it may fail      for larger values of NBYTES. In that case, we have to emulate the      "_full" part here. Thus, always call apr_file_write directly on      Win32 as this minimizes overhead for small data buffers. */
ifdef|#
directive|ifdef
name|WIN32
define|#
directive|define
name|MAXBUFSIZE
value|30*1024
name|apr_size_t
name|bw
init|=
name|nbytes
decl_stmt|;
name|apr_size_t
name|to_write
init|=
name|nbytes
decl_stmt|;
comment|/* try a simple "write everything at once" first */
name|apr_status_t
name|rv
init|=
name|apr_file_write
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|bw
argument_list|)
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|bw
expr_stmt|;
name|to_write
operator|-=
name|bw
expr_stmt|;
comment|/* if the OS cannot handle that, use smaller chunks */
if|if
condition|(
name|rv
operator|==
name|APR_FROM_OS_ERROR
argument_list|(
name|ERROR_NOT_ENOUGH_MEMORY
argument_list|)
operator|&&
name|nbytes
operator|>
name|MAXBUFSIZE
condition|)
block|{
do|do
block|{
name|bw
operator|=
name|to_write
operator|>
name|MAXBUFSIZE
condition|?
name|MAXBUFSIZE
else|:
name|to_write
expr_stmt|;
name|rv
operator|=
name|apr_file_write
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|bw
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|bw
expr_stmt|;
name|to_write
operator|-=
name|bw
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
name|APR_SUCCESS
operator|&&
name|to_write
operator|>
literal|0
condition|)
do|;
block|}
comment|/* bytes_written may actually be NULL */
if|if
condition|(
name|bytes_written
condition|)
operator|*
name|bytes_written
operator|=
name|nbytes
operator|-
name|to_write
expr_stmt|;
undef|#
directive|undef
name|MAXBUFSIZE
else|#
directive|else
name|apr_status_t
name|rv
init|=
name|apr_file_write_full
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|,
name|bytes_written
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
name|svn_error_trace
argument_list|(
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|rv
argument_list|,
name|N_
argument_list|(
literal|"Can't write to file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't write to stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_write_unique
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|tmp_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dirpath
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|nbytes
parameter_list|,
name|svn_io_file_del_t
name|delete_when
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|new_file
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|new_file
argument_list|,
name|tmp_path
argument_list|,
name|dirpath
argument_list|,
name|delete_when
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_file_write_full
argument_list|(
name|new_file
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_io_file_flush_to_disk
argument_list|(
name|new_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|new_file
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_trunc
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* This is a work-around. APR would flush the write buffer      _after_ truncating the file causing now invalid buffered      data to be written behind OFFSET. */
name|SVN_ERR
argument_list|(
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_flush
argument_list|(
name|file
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't flush file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't flush stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|do_io_file_wrapper_cleanup
argument_list|(
name|file
argument_list|,
name|apr_file_trunc
argument_list|(
name|file
argument_list|,
name|offset
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't truncate file '%s'"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Can't truncate stream"
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_read_length_line
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|limit
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* variables */
name|apr_size_t
name|total_read
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|eof
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_size_t
name|buf_size
init|=
operator|*
name|limit
decl_stmt|;
while|while
condition|(
name|buf_size
operator|>
literal|0
condition|)
block|{
comment|/* read a fair chunk of data at once. But don't get too ambitious        * as that would result in too much waste. Also make sure we can        * put a NUL after the last byte read.        */
name|apr_size_t
name|to_read
init|=
name|buf_size
operator|<
literal|129
condition|?
name|buf_size
operator|-
literal|1
else|:
literal|128
decl_stmt|;
name|apr_size_t
name|bytes_read
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|eol
decl_stmt|;
if|if
condition|(
name|to_read
operator|==
literal|0
condition|)
break|break;
comment|/* read data block (or just a part of it) */
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|to_read
argument_list|,
operator|&
name|bytes_read
argument_list|,
operator|&
name|eof
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* look or a newline char */
name|buf
index|[
name|bytes_read
index|]
operator|=
literal|0
expr_stmt|;
name|eol
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol
condition|)
block|{
name|apr_off_t
name|offset
init|=
operator|(
name|eol
operator|+
literal|1
operator|-
name|buf
operator|)
operator|-
operator|(
name|apr_off_t
operator|)
name|bytes_read
decl_stmt|;
operator|*
name|eol
operator|=
literal|0
expr_stmt|;
operator|*
name|limit
operator|=
name|total_read
operator|+
operator|(
name|eol
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* correct the file pointer:            * appear as though we just had read the newline char            */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|eof
condition|)
block|{
comment|/* no EOL found but we hit the end of the file.            * Generate a nice EOF error object and return it.            */
name|char
name|dummy
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_getc
argument_list|(
operator|&
name|dummy
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* next data chunk */
name|buf_size
operator|-=
name|bytes_read
expr_stmt|;
name|buf
operator|+=
name|bytes_read
expr_stmt|;
name|total_read
operator|+=
name|bytes_read
expr_stmt|;
block|}
comment|/* buffer limit has been exceeded without finding the EOL */
name|err
operator|=
name|svn_io_file_name_get
argument_list|(
operator|&
name|name
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_MALFORMED_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't read length line in file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|name
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_MALFORMED_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't read length line in stream"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_stat
parameter_list|(
name|apr_finfo_t
modifier|*
name|finfo
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|apr_int32_t
name|wanted
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname_apr
decl_stmt|;
comment|/* APR doesn't like "" directories */
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|fname
operator|=
literal|"."
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|fname_apr
argument_list|,
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Quoting APR: On NT this request is incredibly expensive, but accurate. */
name|wanted
operator|&=
operator|~
name|SVN__APR_FINFO_MASK_OUT
expr_stmt|;
name|status
operator|=
name|apr_stat
argument_list|(
name|finfo
argument_list|,
name|fname_apr
argument_list|,
name|wanted
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't stat '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
init|=
name|APR_SUCCESS
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_path_apr
decl_stmt|,
modifier|*
name|to_path_apr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|from_path_apr
argument_list|,
name|from_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|to_path_apr
argument_list|,
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_file_rename
argument_list|(
name|from_path_apr
argument_list|,
name|to_path_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__OS2__
argument_list|)
comment|/* If the target file is read only NTFS reports EACCESS and      FAT/FAT32 reports EEXIST */
if|if
condition|(
name|APR_STATUS_IS_EACCES
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_EEXIST
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* Set the destination file writable because Windows will not          allow us to rename when to_path is read-only, but will          allow renaming when from_path is read only. */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_write
argument_list|(
name|to_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_file_rename
argument_list|(
name|from_path_apr
argument_list|,
name|to_path_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|WIN32_RETRY_LOOP
argument_list|(
name|status
argument_list|,
name|apr_file_rename
argument_list|(
name|from_path_apr
argument_list|,
name|to_path_apr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WIN32 || __OS2__ */
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't move '%s' to '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|from_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_move
parameter_list|(
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_file_rename
argument_list|(
name|from_path
argument_list|,
name|to_path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EXDEV
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp_to_path
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|tmp_to_path
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_copy_file
argument_list|(
name|from_path
argument_list|,
name|tmp_to_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|failed_tmp
goto|;
name|err
operator|=
name|svn_io_file_rename
argument_list|(
name|tmp_to_path
argument_list|,
name|to_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|failed_tmp
goto|;
name|err
operator|=
name|svn_io_remove_file2
argument_list|(
name|from_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|to_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
name|failed_tmp
label|:
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|tmp_to_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Common implementation of svn_io_dir_make and svn_io_dir_make_hidden.    HIDDEN determines if the hidden attribute    should be set on the newly created directory. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dir_make
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_fileperms_t
name|perm
parameter_list|,
name|svn_boolean_t
name|hidden
parameter_list|,
name|svn_boolean_t
name|sgid
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* APR doesn't like "" directories */
if|if
condition|(
name|path_apr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|path_apr
operator|=
literal|"."
expr_stmt|;
if|#
directive|if
operator|(
name|APR_OS_DEFAULT
operator|&
name|APR_WSTICKY
operator|)
comment|/* The APR shipped with httpd 2.0.50 contains a bug where      APR_OS_DEFAULT encompasses the setuid, setgid, and sticky bits.      There is a special case for file creation, but not directory      creation, so directories wind up getting created with the sticky      bit set.  (There is no such thing as a setuid directory, and the      setgid bit is apparently ignored at mkdir() time.)  If we detect      this problem, work around it by unsetting those bits if we are      passed APR_OS_DEFAULT. */
if|if
condition|(
name|perm
operator|==
name|APR_OS_DEFAULT
condition|)
name|perm
operator|&=
operator|~
operator|(
name|APR_USETID
operator||
name|APR_GSETID
operator||
name|APR_WSTICKY
operator|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|apr_dir_make
argument_list|(
name|path_apr
argument_list|,
name|perm
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|WIN32_RETRY_LOOP
argument_list|(
name|status
argument_list|,
name|apr_dir_make
argument_list|(
name|path_apr
argument_list|,
name|perm
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't create directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
ifdef|#
directive|ifdef
name|APR_FILE_ATTR_HIDDEN
if|if
condition|(
name|hidden
condition|)
block|{
ifndef|#
directive|ifndef
name|WIN32
name|status
operator|=
name|apr_file_attrs_set
argument_list|(
name|path_apr
argument_list|,
name|APR_FILE_ATTR_HIDDEN
argument_list|,
name|APR_FILE_ATTR_HIDDEN
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* on Windows, use our wrapper so we can also set the        FILE_ATTRIBUTE_NOT_CONTENT_INDEXED attribute */
name|status
operator|=
name|io_win_file_attrs_set
argument_list|(
name|path_apr
argument_list|,
name|FILE_ATTRIBUTE_HIDDEN
operator||
name|FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
argument_list|,
name|FILE_ATTRIBUTE_HIDDEN
operator||
name|FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't hide directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* Windows does not implement sgid. Skip here because retrieving    the file permissions via APR_FINFO_PROT | APR_FINFO_OWNER is documented    to be 'incredibly expensive'. */
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|sgid
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
comment|/* Per our contract, don't do error-checking.  Some filesystems        * don't support the sgid bit, and that's okay. */
name|status
operator|=
name|apr_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path_apr
argument_list|,
name|APR_FINFO_PROT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
name|apr_file_perms_set
argument_list|(
name|path_apr
argument_list|,
name|finfo
operator|.
name|protection
operator||
name|APR_GSETID
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_make
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_fileperms_t
name|perm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|dir_make
argument_list|(
name|path
argument_list|,
name|perm
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_make_hidden
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_fileperms_t
name|perm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|dir_make
argument_list|(
name|path
argument_list|,
name|perm
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_make_sgid
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_fileperms_t
name|perm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|dir_make
argument_list|(
name|path
argument_list|,
name|perm
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_open
parameter_list|(
name|apr_dir_t
modifier|*
modifier|*
name|new_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirname_apr
decl_stmt|;
comment|/* APR doesn't like "" directories */
if|if
condition|(
name|dirname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|dirname
operator|=
literal|"."
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|dirname_apr
argument_list|,
name|dirname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_dir_open
argument_list|(
name|new_dir
argument_list|,
name|dirname_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't open directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dirname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_remove_nonrecursive
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirname_apr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|dirname_apr
argument_list|,
name|dirname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_dir_remove
argument_list|(
name|dirname_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
block|{
name|svn_boolean_t
name|retry
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|APR_TO_OS_ERROR
argument_list|(
name|status
argument_list|)
operator|==
name|ERROR_DIR_NOT_EMPTY
condition|)
block|{
name|apr_status_t
name|empty_status
init|=
name|dir_is_empty
argument_list|(
name|dirname_apr
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|APR_STATUS_IS_ENOTEMPTY
argument_list|(
name|empty_status
argument_list|)
condition|)
name|retry
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|retry
condition|)
block|{
name|WIN32_RETRY_LOOP
argument_list|(
name|status
argument_list|,
name|apr_dir_remove
argument_list|(
name|dirname_apr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't remove directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dirname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_read
parameter_list|(
name|apr_finfo_t
modifier|*
name|finfo
parameter_list|,
name|apr_int32_t
name|wanted
parameter_list|,
name|apr_dir_t
modifier|*
name|thedir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|apr_dir_read
argument_list|(
name|finfo
argument_list|,
name|wanted
argument_list|,
name|thedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't read directory"
argument_list|)
argument_list|)
return|;
comment|/* It would be nice to use entry_name_to_utf8() below, but can we      get the dir's path out of an apr_dir_t?  I don't see a reliable      way to do it. */
if|if
condition|(
name|finfo
operator|->
name|fname
condition|)
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
operator|&
name|finfo
operator|->
name|fname
argument_list|,
name|finfo
operator|->
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|name
condition|)
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
operator|&
name|finfo
operator|->
name|name
argument_list|,
name|finfo
operator|->
name|name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_close
parameter_list|(
name|apr_dir_t
modifier|*
name|thedir
parameter_list|)
block|{
name|apr_status_t
name|apr_err
init|=
name|apr_dir_close
argument_list|(
name|thedir
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error closing directory"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_walk2
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|apr_int32_t
name|wanted
parameter_list|,
name|svn_io_walk_func_t
name|walk_func
parameter_list|,
name|void
modifier|*
name|walk_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_dir_t
modifier|*
name|handle
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirname_apr
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|wanted
operator||=
name|APR_FINFO_TYPE
operator||
name|APR_FINFO_NAME
expr_stmt|;
comment|/* Quoting APR: On NT this request is incredibly expensive, but accurate. */
name|wanted
operator|&=
operator|~
name|SVN__APR_FINFO_MASK_OUT
expr_stmt|;
comment|/* The documentation for apr_dir_read used to state that "." and ".."      will be returned as the first two files, but it doesn't      work that way in practice, in particular ext3 on Linux-2.6 doesn't      follow the rules.  For details see      http://subversion.tigris.org/servlets/ReadMsg?list=dev&msgNo=56666       If APR ever does implement "dot-first" then it would be possible to      remove the svn_io_stat and walk_func calls and use the walk_func      inside the loop.       Note: apr_stat doesn't handle FINFO_NAME but svn_io_dir_walk is      documented to provide it, so we have to do a bit extra. */
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|dirname
argument_list|,
name|wanted
operator|&
operator|~
name|APR_FINFO_NAME
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|finfo
operator|.
name|name
argument_list|,
name|svn_dirent_basename
argument_list|(
name|dirname
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|valid
operator||=
name|APR_FINFO_NAME
expr_stmt|;
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|walk_func
call|)
argument_list|(
name|walk_baton
argument_list|,
name|dirname
argument_list|,
operator|&
name|finfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|dirname_apr
argument_list|,
name|dirname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* APR doesn't like "" directories */
if|if
condition|(
name|dirname_apr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|dirname_apr
operator|=
literal|"."
expr_stmt|;
name|apr_err
operator|=
name|apr_dir_open
argument_list|(
operator|&
name|handle
argument_list|,
name|dirname_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't open directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dirname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* iteration subpool */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|name_utf8
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|finfo
argument_list|,
name|wanted
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|apr_err
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|apr_err
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't read directory entry in '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dirname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|finfo
operator|.
name|filetype
operator|==
name|APR_DIR
condition|)
block|{
if|if
condition|(
name|finfo
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|finfo
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|finfo
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|finfo
operator|.
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
comment|/* skip "." and ".." */
continue|continue;
comment|/* some other directory. recurse. it will be passed to the              callback inside the recursion. */
name|SVN_ERR
argument_list|(
name|entry_name_to_utf8
argument_list|(
operator|&
name|name_utf8
argument_list|,
name|finfo
operator|.
name|name
argument_list|,
name|dirname
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_dirent_join
argument_list|(
name|dirname
argument_list|,
name|name_utf8
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_dir_walk2
argument_list|(
name|full_path
argument_list|,
name|wanted
argument_list|,
name|walk_func
argument_list|,
name|walk_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|finfo
operator|.
name|filetype
operator|==
name|APR_REG
operator|||
name|finfo
operator|.
name|filetype
operator|==
name|APR_LNK
condition|)
block|{
comment|/* some other directory. pass it to the callback. */
name|SVN_ERR
argument_list|(
name|entry_name_to_utf8
argument_list|(
operator|&
name|name_utf8
argument_list|,
name|finfo
operator|.
name|name
argument_list|,
name|dirname
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_dirent_join
argument_list|(
name|dirname
argument_list|,
name|name_utf8
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|walk_func
call|)
argument_list|(
name|walk_baton
argument_list|,
name|full_path
argument_list|,
operator|&
name|finfo
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* else:          Some other type of file; skip it for now.  We've reserved the          right to expand our coverage here in the future, though,          without revving this API.       */
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_dir_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error closing directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dirname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/**  * Determine if a directory is empty or not.  * @param Return APR_SUCCESS if the dir is empty, else APR_ENOTEMPTY if not.  * @param path The directory.  * @param pool Used for temporary allocation.  * @remark If path is not a directory, or some other error occurs,  * then return the appropriate apr status code.  *  * (This function is written in APR style, in anticipation of  * perhaps someday being moved to APR as 'apr_dir_is_empty'.)  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|dir_is_empty
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_dir_t
modifier|*
name|dir_handle
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_status_t
name|retval
init|=
name|APR_SUCCESS
decl_stmt|;
comment|/* APR doesn't like "" directories */
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|dir
operator|=
literal|"."
expr_stmt|;
name|apr_err
operator|=
name|apr_dir_open
argument_list|(
operator|&
name|dir_handle
argument_list|,
name|dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|apr_err
return|;
for|for
control|(
name|apr_err
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_NAME
argument_list|,
name|dir_handle
argument_list|)
init|;
name|apr_err
operator|==
name|APR_SUCCESS
condition|;
name|apr_err
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_NAME
argument_list|,
name|dir_handle
argument_list|)
control|)
block|{
comment|/* Ignore entries for this dir and its parent, robustly.          (APR promises that they'll come first, so technically          this guard could be moved outside the loop.  But Ryan Bloom          says he doesn't believe it, and I believe him. */
if|if
condition|(
operator|!
operator|(
name|finfo
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|finfo
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|finfo
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|finfo
operator|.
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
block|{
name|retval
operator|=
name|APR_ENOTEMPTY
expr_stmt|;
break|break;
block|}
block|}
comment|/* Make sure we broke out of the loop for the right reason. */
if|if
condition|(
name|apr_err
operator|&&
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|apr_err
argument_list|)
condition|)
return|return
name|apr_err
return|;
name|apr_err
operator|=
name|apr_dir_close
argument_list|(
name|dir_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|apr_err
return|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_dir_empty
parameter_list|(
name|svn_boolean_t
modifier|*
name|is_empty_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_apr
decl_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|path_apr
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|dir_is_empty
argument_list|(
name|path_apr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
operator|*
name|is_empty_p
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|APR_STATUS_IS_ENOTEMPTY
argument_list|(
name|status
argument_list|)
condition|)
operator|*
name|is_empty_p
operator|=
name|FALSE
expr_stmt|;
else|else
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't check directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Version/format files ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_io_write_version_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|version
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_contents
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%d\n"
argument_list|,
name|version
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|version
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|path_tmp
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|format_contents
argument_list|,
name|strlen
argument_list|(
name|format_contents
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__OS2__
argument_list|)
comment|/* make the destination writable, but only on Windows, because      Windows does not let us replace read-only files. */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_write
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WIN32 || __OS2__ */
comment|/* rename the temp file as the real destination */
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|path_tmp
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And finally remove the perms to make it read only */
return|return
name|svn_io_set_file_read_only
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_read_version_file
parameter_list|(
name|int
modifier|*
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|format_file
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Read a chunk of data from PATH */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|format_file
argument_list|,
name|path
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_file_read
argument_list|(
name|format_file
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Close the file. */
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|format_file
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there was no data in PATH, return an error. */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_STREAM_UNEXPECTED_EOF
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* Check that the first line contains only digits. */
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|buf
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|svn_ctype_isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"First line of '%s' contains non-digit"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Convert to integer. */
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
name|version
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Do a byte-for-byte comparison of FILE1 and FILE2. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|contents_identical_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|identical_p
parameter_list|,
specifier|const
name|char
modifier|*
name|file1
parameter_list|,
specifier|const
name|char
modifier|*
name|file2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_size_t
name|bytes_read1
decl_stmt|,
name|bytes_read2
decl_stmt|;
name|char
modifier|*
name|buf1
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|file1_h
decl_stmt|;
name|apr_file_t
modifier|*
name|file2_h
decl_stmt|;
name|svn_boolean_t
name|eof1
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|eof2
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file1_h
argument_list|,
name|file1
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|file2_h
argument_list|,
name|file2
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|file1_h
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
return|;
operator|*
name|identical_p
operator|=
name|TRUE
expr_stmt|;
comment|/* assume TRUE, until disproved below */
while|while
condition|(
operator|!
name|err
operator|&&
operator|!
name|eof1
operator|&&
operator|!
name|eof2
condition|)
block|{
name|err
operator|=
name|svn_io_file_read_full2
argument_list|(
name|file1_h
argument_list|,
name|buf1
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|,
operator|&
name|bytes_read1
argument_list|,
operator|&
name|eof1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|err
operator|=
name|svn_io_file_read_full2
argument_list|(
name|file2_h
argument_list|,
name|buf2
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|,
operator|&
name|bytes_read2
argument_list|,
operator|&
name|eof2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
operator|(
name|bytes_read1
operator|!=
name|bytes_read2
operator|)
operator|||
name|memcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
name|bytes_read1
argument_list|)
condition|)
block|{
operator|*
name|identical_p
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Special case: one file being a prefix of the other and the shorter    * file's size is a multiple of SVN__STREAM_CHUNK_SIZE. */
if|if
condition|(
operator|!
name|err
operator|&&
operator|(
name|eof1
operator|!=
name|eof2
operator|)
condition|)
operator|*
name|identical_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_error_compose_create
argument_list|(
name|svn_io_file_close
argument_list|(
name|file1_h
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_close
argument_list|(
name|file2_h
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do a byte-for-byte comparison of FILE1, FILE2 and FILE3. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|contents_three_identical_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|identical_p12
parameter_list|,
name|svn_boolean_t
modifier|*
name|identical_p23
parameter_list|,
name|svn_boolean_t
modifier|*
name|identical_p13
parameter_list|,
specifier|const
name|char
modifier|*
name|file1
parameter_list|,
specifier|const
name|char
modifier|*
name|file2
parameter_list|,
specifier|const
name|char
modifier|*
name|file3
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_size_t
name|bytes_read1
decl_stmt|,
name|bytes_read2
decl_stmt|,
name|bytes_read3
decl_stmt|;
name|char
modifier|*
name|buf1
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf3
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|file1_h
decl_stmt|;
name|apr_file_t
modifier|*
name|file2_h
decl_stmt|;
name|apr_file_t
modifier|*
name|file3_h
decl_stmt|;
name|svn_boolean_t
name|eof1
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|eof2
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|eof3
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|read_1
decl_stmt|,
name|read_2
decl_stmt|,
name|read_3
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file1_h
argument_list|,
name|file1
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|file2_h
argument_list|,
name|file2
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|file1_h
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
return|;
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|file3_h
argument_list|,
name|file3
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_error_compose_create
argument_list|(
name|svn_io_file_close
argument_list|(
name|file1_h
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_io_file_close
argument_list|(
name|file2_h
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* assume TRUE, until disproved below */
operator|*
name|identical_p12
operator|=
operator|*
name|identical_p23
operator|=
operator|*
name|identical_p13
operator|=
name|TRUE
expr_stmt|;
comment|/* We need to read as long as no error occurs, and as long as one of the    * flags could still change due to a read operation */
while|while
condition|(
operator|!
name|err
operator|&&
operator|(
operator|(
operator|*
name|identical_p12
operator|&&
operator|!
name|eof1
operator|&&
operator|!
name|eof2
operator|)
operator|||
operator|(
operator|*
name|identical_p23
operator|&&
operator|!
name|eof2
operator|&&
operator|!
name|eof3
operator|)
operator|||
operator|(
operator|*
name|identical_p13
operator|&&
operator|!
name|eof1
operator|&&
operator|!
name|eof3
operator|)
operator|)
condition|)
block|{
name|read_1
operator|=
name|read_2
operator|=
name|read_3
operator|=
name|FALSE
expr_stmt|;
comment|/* As long as a file is not at the end yet, and it is still        * potentially identical to another file, we read the next chunk.*/
if|if
condition|(
operator|!
name|eof1
operator|&&
operator|(
operator|*
name|identical_p12
operator|||
operator|*
name|identical_p13
operator|)
condition|)
block|{
name|err
operator|=
name|svn_io_file_read_full2
argument_list|(
name|file1_h
argument_list|,
name|buf1
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|,
operator|&
name|bytes_read1
argument_list|,
operator|&
name|eof1
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|read_1
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eof2
operator|&&
operator|(
operator|*
name|identical_p12
operator|||
operator|*
name|identical_p23
operator|)
condition|)
block|{
name|err
operator|=
name|svn_io_file_read_full2
argument_list|(
name|file2_h
argument_list|,
name|buf2
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|,
operator|&
name|bytes_read2
argument_list|,
operator|&
name|eof2
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|read_2
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eof3
operator|&&
operator|(
operator|*
name|identical_p13
operator|||
operator|*
name|identical_p23
operator|)
condition|)
block|{
name|err
operator|=
name|svn_io_file_read_full2
argument_list|(
name|file3_h
argument_list|,
name|buf3
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|,
operator|&
name|bytes_read3
argument_list|,
operator|&
name|eof3
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|read_3
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If the files are still marked identical, and at least one of them        * is not at the end of file, we check whether they differ, and set        * their flag to false then. */
if|if
condition|(
operator|*
name|identical_p12
operator|&&
operator|(
name|read_1
operator|||
name|read_2
operator|)
operator|&&
operator|(
operator|(
name|eof1
operator|!=
name|eof2
operator|)
operator|||
operator|(
name|bytes_read1
operator|!=
name|bytes_read2
operator|)
operator|||
name|memcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
name|bytes_read1
argument_list|)
operator|)
condition|)
block|{
operator|*
name|identical_p12
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|identical_p23
operator|&&
operator|(
name|read_2
operator|||
name|read_3
operator|)
operator|&&
operator|(
operator|(
name|eof2
operator|!=
name|eof3
operator|)
operator|||
operator|(
name|bytes_read2
operator|!=
name|bytes_read3
operator|)
operator|||
name|memcmp
argument_list|(
name|buf2
argument_list|,
name|buf3
argument_list|,
name|bytes_read2
argument_list|)
operator|)
condition|)
block|{
operator|*
name|identical_p23
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|identical_p13
operator|&&
operator|(
name|read_1
operator|||
name|read_3
operator|)
operator|&&
operator|(
operator|(
name|eof1
operator|!=
name|eof3
operator|)
operator|||
operator|(
name|bytes_read1
operator|!=
name|bytes_read3
operator|)
operator|||
name|memcmp
argument_list|(
name|buf1
argument_list|,
name|buf3
argument_list|,
name|bytes_read3
argument_list|)
operator|)
condition|)
block|{
operator|*
name|identical_p13
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_error_compose_create
argument_list|(
name|svn_io_file_close
argument_list|(
name|file1_h
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_error_compose_create
argument_list|(
name|svn_io_file_close
argument_list|(
name|file2_h
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_io_file_close
argument_list|(
name|file3_h
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_files_contents_same_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|same
parameter_list|,
specifier|const
name|char
modifier|*
name|file1
parameter_list|,
specifier|const
name|char
modifier|*
name|file2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|q
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_filesizes_different_p
argument_list|(
operator|&
name|q
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
operator|*
name|same
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|contents_identical_p
argument_list|(
operator|&
name|q
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|same
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|same
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_files_contents_three_same_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|same12
parameter_list|,
name|svn_boolean_t
modifier|*
name|same23
parameter_list|,
name|svn_boolean_t
modifier|*
name|same13
parameter_list|,
specifier|const
name|char
modifier|*
name|file1
parameter_list|,
specifier|const
name|char
modifier|*
name|file2
parameter_list|,
specifier|const
name|char
modifier|*
name|file3
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|diff_size12
decl_stmt|,
name|diff_size23
decl_stmt|,
name|diff_size13
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_filesizes_three_different_p
argument_list|(
operator|&
name|diff_size12
argument_list|,
operator|&
name|diff_size23
argument_list|,
operator|&
name|diff_size13
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|,
name|file3
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_size12
operator|&&
name|diff_size23
operator|&&
name|diff_size13
condition|)
block|{
operator|*
name|same12
operator|=
operator|*
name|same23
operator|=
operator|*
name|same13
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff_size12
operator|&&
name|diff_size23
condition|)
block|{
operator|*
name|same12
operator|=
operator|*
name|same23
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|contents_identical_p
argument_list|(
name|same13
argument_list|,
name|file1
argument_list|,
name|file3
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff_size23
operator|&&
name|diff_size13
condition|)
block|{
operator|*
name|same23
operator|=
operator|*
name|same13
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|contents_identical_p
argument_list|(
name|same12
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff_size12
operator|&&
name|diff_size13
condition|)
block|{
operator|*
name|same12
operator|=
operator|*
name|same13
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|contents_identical_p
argument_list|(
name|same23
argument_list|,
name|file2
argument_list|,
name|file3
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|diff_size12
operator|&&
operator|!
name|diff_size23
operator|&&
operator|!
name|diff_size13
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|contents_three_identical_p
argument_list|(
name|same12
argument_list|,
name|same23
argument_list|,
name|same13
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|,
name|file3
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/* Counter value of file_mktemp request (used in a threadsafe way), to make    sure that a single process normally never generates the same tempname    twice */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|apr_uint32_t
name|tempname_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Creates a new temporary file in DIRECTORY with apr flags FLAGS.    Set *NEW_FILE to the file handle and *NEW_FILE_NAME to its name.    Perform temporary allocations in SCRATCH_POOL and the result in    RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|temp_file_create
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|new_file
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|new_file_name
parameter_list|,
specifier|const
name|char
modifier|*
name|directory
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|WIN32
specifier|const
name|char
modifier|*
name|templ
init|=
name|svn_dirent_join
argument_list|(
name|directory
argument_list|,
literal|"svn-XXXXXX"
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|templ_apr
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|templ_apr
argument_list|,
name|templ
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### svn_path_cstring_from_utf8() guarantees to make a copy of the          data available in POOL and we need a non-const pointer here,          as apr changes the template to return the new filename. */
name|status
operator|=
name|apr_file_mktemp
argument_list|(
name|new_file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|templ_apr
argument_list|,
name|flags
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't create temporary file from "
literal|"template '%s'"
argument_list|)
argument_list|,
name|templ
argument_list|)
return|;
comment|/* Translate the returned path back to utf-8 before returning it */
return|return
name|svn_error_trace
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
name|new_file_name
argument_list|,
name|templ_apr
argument_list|,
name|result_pool
argument_list|)
argument_list|)
return|;
else|#
directive|else
comment|/* The Windows implementation of apr_file_mktemp doesn't handle access      denied errors correctly. Therefore we implement our own temp file      creation function here. */
comment|/* ### Most of this is borrowed from the svn_io_open_uniquely_named(),      ### the function we used before. But we try to guess a more unique      ### name before trying if it exists. */
comment|/* Offset by some time value and a unique request nr to make the number      +- unique for both this process and on the computer */
name|int
name|baseNr
init|=
operator|(
name|GetTickCount
argument_list|()
operator|<<
literal|11
operator|)
operator|+
literal|7
operator|*
name|svn_atomic_inc
argument_list|(
operator|&
name|tempname_counter
argument_list|)
operator|+
name|GetCurrentProcessId
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* ### Maybe use an iterpool? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|99999
condition|;
name|i
operator|++
control|)
block|{
name|apr_uint32_t
name|unique_nr
decl_stmt|;
specifier|const
name|char
modifier|*
name|unique_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|unique_name_apr
decl_stmt|;
name|apr_file_t
modifier|*
name|try_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
comment|/* Generate a number that should be unique for this application and          usually for the entire computer to reduce the number of cycles          through this loop. (A bit of calculation is much cheaper then          disk io) */
name|unique_nr
operator|=
name|baseNr
operator|+
literal|3
operator|*
name|i
expr_stmt|;
name|unique_name
operator|=
name|svn_dirent_join
argument_list|(
name|directory
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"svn-%X"
argument_list|,
name|unique_nr
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|unique_name_apr
argument_list|,
name|unique_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|file_open
argument_list|(
operator|&
name|try_file
argument_list|,
name|unique_name_apr
argument_list|,
name|flags
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EEXIST
argument_list|(
name|apr_err
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|apr_err
condition|)
block|{
comment|/* On Win32, CreateFile fails with an "Access Denied" error              code, rather than "File Already Exists", if the colliding              name belongs to a directory. */
if|if
condition|(
name|APR_STATUS_IS_EACCES
argument_list|(
name|apr_err
argument_list|)
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|apr_status_t
name|apr_err_2
init|=
name|apr_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|unique_name_apr
argument_list|,
name|APR_FINFO_TYPE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|apr_err_2
operator|&&
name|finfo
operator|.
name|filetype
operator|==
name|APR_DIR
condition|)
continue|continue;
name|apr_err_2
operator|=
name|APR_TO_OS_ERROR
argument_list|(
name|apr_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err_2
operator|==
name|ERROR_ACCESS_DENIED
operator|||
name|apr_err_2
operator|==
name|ERROR_SHARING_VIOLATION
condition|)
block|{
comment|/* The file is in use by another process or is hidden;                      create a new name, but don't do this 99999 times in                      case the folder is not writable */
name|i
operator|+=
literal|797
expr_stmt|;
continue|continue;
block|}
comment|/* Else fall through and return the original error. */
block|}
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't open '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|unique_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Move file to the right pool */
name|apr_err
operator|=
name|apr_file_setaside
argument_list|(
name|new_file
argument_list|,
name|try_file
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't set aside '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|unique_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
operator|*
name|new_file_name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|unique_name
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to make name in '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|directory
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Wrapper for apr_file_name_get(), passing out a UTF8-encoded filename. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_name_get
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname_apr
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|status
operator|=
name|apr_file_name_get
argument_list|(
operator|&
name|fname_apr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't get file name"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|fname_apr
condition|)
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
name|filename
argument_list|,
name|fname_apr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_open_unique_file3
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|unique_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dirpath
parameter_list|,
name|svn_io_file_del_t
name|delete_when
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|tempfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|tempname
decl_stmt|;
name|struct
name|temp_file_cleanup_s
modifier|*
name|baton
init|=
name|NULL
decl_stmt|;
name|apr_int32_t
name|flags
init|=
operator|(
name|APR_READ
operator||
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_EXCL
operator||
name|APR_BUFFERED
operator||
name|APR_BINARY
operator|)
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
name|apr_fileperms_t
name|perms
decl_stmt|;
name|svn_boolean_t
name|using_system_temp_dir
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|SVN_ERR_ASSERT
argument_list|(
name|file
operator|||
name|unique_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
operator|*
name|file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unique_path
condition|)
operator|*
name|unique_path
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dirpath
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
name|using_system_temp_dir
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|svn_io_temp_dir
argument_list|(
operator|&
name|dirpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|delete_when
condition|)
block|{
case|case
name|svn_io_file_del_on_pool_cleanup
case|:
name|baton
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|baton
operator|->
name|fname_apr
operator|=
name|NULL
expr_stmt|;
comment|/* Because cleanups are run LIFO, we need to make sure to register            our cleanup before the apr_file_close cleanup:             On Windows, you can't remove an open file.         */
name|apr_pool_cleanup_register
argument_list|(
name|result_pool
argument_list|,
name|baton
argument_list|,
name|temp_file_plain_cleanup_handler
argument_list|,
name|temp_file_child_cleanup_handler
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_io_file_del_on_close
case|:
name|flags
operator||=
name|APR_DELONCLOSE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|SVN_ERR
argument_list|(
name|temp_file_create
argument_list|(
operator|&
name|tempfile
argument_list|,
operator|&
name|tempname
argument_list|,
name|dirpath
argument_list|,
name|flags
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
comment|/* apr_file_mktemp() creates files with mode 0600.    * This is appropriate if we're using a system temp dir since we don't    * want to leak sensitive data into temp files other users can read.    * If we're not using a system temp dir we're probably using the    * .svn/tmp area and it's likely that the tempfile will end up being    * copied or renamed into the working copy.    * This would cause working files having mode 0600 while users might    * expect to see 0644 or 0664. So we tweak perms of the tempfile in this    * case, but only if the umask allows it. */
if|if
condition|(
operator|!
name|using_system_temp_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|merge_default_file_perms
argument_list|(
name|tempfile
argument_list|,
operator|&
name|perms
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|file_perms_set2
argument_list|(
name|tempfile
argument_list|,
name|perms
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|file
condition|)
operator|*
name|file
operator|=
name|tempfile
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|tempfile
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unique_path
condition|)
operator|*
name|unique_path
operator|=
name|tempname
expr_stmt|;
comment|/* Was allocated in result_pool */
if|if
condition|(
name|baton
condition|)
name|SVN_ERR
argument_list|(
name|cstring_from_utf8
argument_list|(
operator|&
name|baton
operator|->
name|fname_apr
argument_list|,
name|tempname
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_io_file_readline
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|stringbuf
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_size_t
name|max_len
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|apr_size_t
name|numbytes
decl_stmt|;
name|char
name|c
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_boolean_t
name|found_eof
decl_stmt|;
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|80
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Read bytes into STR up to and including, but not storing,    * the next EOL sequence. */
name|eol_str
operator|=
name|NULL
expr_stmt|;
name|numbytes
operator|=
literal|1
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|found_eof
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|found_eof
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|max_len
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|numbytes
argument_list|,
operator|&
name|found_eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|numbytes
operator|!=
literal|1
operator|||
name|len
operator|>
name|max_len
condition|)
block|{
name|found_eof
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|eol_str
operator|=
literal|"\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
name|eol_str
operator|=
literal|"\r"
expr_stmt|;
if|if
condition|(
operator|!
name|found_eof
operator|&&
name|len
operator|<
name|max_len
condition|)
block|{
name|apr_off_t
name|pos
decl_stmt|;
comment|/* Check for "\r\n" by peeking at the next byte. */
name|pos
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|numbytes
argument_list|,
operator|&
name|found_eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbytes
operator|==
literal|1
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
name|eol_str
operator|=
literal|"\r\n"
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Pretend we never peeked. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|found_eof
operator|=
name|FALSE
expr_stmt|;
name|numbytes
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_str
condition|)
break|break;
block|}
if|if
condition|(
name|eol
condition|)
operator|*
name|eol
operator|=
name|eol_str
expr_stmt|;
if|if
condition|(
name|eof
condition|)
operator|*
name|eof
operator|=
name|found_eof
expr_stmt|;
operator|*
name|stringbuf
operator|=
name|str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

