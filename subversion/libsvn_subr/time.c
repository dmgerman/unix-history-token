begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * time.c:  time/date utilities  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_time.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Our timestamp strings look like this:  *  *    "2002-05-07Thh:mm:ss.uuuuuuZ"  *  * The format is conformant with ISO-8601 and the date format required  * by RFC2518 for creationdate. It is a direct conversion between  * apr_time_t and a string, so converting to string and back retains  * the exact value.  */
end_comment

begin_define
define|#
directive|define
name|TIMESTAMP_FORMAT
value|"%04d-%02d-%02dT%02d:%02d:%02d.%06dZ"
end_define

begin_comment
comment|/* Our old timestamp strings looked like this:  *  *    "Tue 3 Oct 2000 HH:MM:SS.UUU (day 277, dst 1, gmt_off -18000)"  *  * The idea is that they are conventionally human-readable for the  * first part, and then in parentheses comes everything else required  * to completely fill in an apr_time_exp_t: tm_yday, tm_isdst,  * and tm_gmtoff.  *  * This format is still recognized on input, for backward  * compatibility, but no longer generated.  */
end_comment

begin_define
define|#
directive|define
name|OLD_TIMESTAMP_FORMAT
define|\
value|"%3s %d %3s %d %02d:%02d:%02d.%06d (day %03d, dst %d, gmt_off %06d)"
end_define

begin_comment
comment|/* Our human representation of dates looks like this:  *  *    "2002-06-23 11:13:02 +0300 (Sun, 23 Jun 2002)"  *  * This format is used whenever time is shown to the user. It consists  * of a machine parseable, almost ISO-8601, part in the beginning -  * and a human explanatory part at the end. The machine parseable part  * is generated strictly by APR and our code, with a apr_snprintf. The  * human explanatory part is generated by apr_strftime, which means  * that its generation can be affected by locale, it can fail and it  * doesn't need to be constant in size. In other words, perfect to be  * converted to a configuration option later on.  */
end_comment

begin_comment
comment|/* Maximum length for the date string. */
end_comment

begin_define
define|#
directive|define
name|SVN_TIME__MAX_LENGTH
value|80
end_define

begin_comment
comment|/* Machine parseable part, generated by apr_snprintf. */
end_comment

begin_define
define|#
directive|define
name|HUMAN_TIMESTAMP_FORMAT
value|"%.4d-%.2d-%.2d %.2d:%.2d:%.2d %+.2d%.2d"
end_define

begin_comment
comment|/* Human explanatory part, generated by apr_strftime as "Sat, 01 Jan 2000" */
end_comment

begin_define
define|#
directive|define
name|human_timestamp_format_suffix
value|_(" (%a, %d %b %Y)")
end_define

begin_function
specifier|const
name|char
modifier|*
name|svn_time_to_cstring
parameter_list|(
name|apr_time_t
name|when
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_time_exp_t
name|exploded_time
decl_stmt|;
comment|/* We toss apr_status_t return value here -- for one thing, caller      should pass in good information.  But also, where APR's own code      calls these functions it tosses the return values, and      furthermore their current implementations can only return success      anyway. */
comment|/* We get the date in GMT now -- and expect the tm_gmtoff and      tm_isdst to be not set. We also ignore the weekday and yearday,      since those are not needed. */
name|apr_time_exp_gmt
argument_list|(
operator|&
name|exploded_time
argument_list|,
name|when
argument_list|)
expr_stmt|;
comment|/* It would be nice to use apr_strftime(), but APR doesn't give a      way to convert back, so we wouldn't be able to share the format      string between the writer and reader. */
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|TIMESTAMP_FORMAT
argument_list|,
name|exploded_time
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|exploded_time
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|exploded_time
operator|.
name|tm_mday
argument_list|,
name|exploded_time
operator|.
name|tm_hour
argument_list|,
name|exploded_time
operator|.
name|tm_min
argument_list|,
name|exploded_time
operator|.
name|tm_sec
argument_list|,
name|exploded_time
operator|.
name|tm_usec
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_int32_t
name|find_matching_string
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
specifier|const
name|char
name|strings
index|[]
index|[
literal|4
index|]
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strings
index|[
name|i
index|]
operator|&&
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|strings
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|apr_int32_t
operator|)
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_time_from_cstring
parameter_list|(
name|apr_time_t
modifier|*
name|when
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_time_exp_t
name|exploded_time
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|char
name|wday
index|[
literal|4
index|]
decl_stmt|,
name|month
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
comment|/* Open-code parsing of the new timestamp format, as this      is a hot path for reading the entries file.  This format looks      like:  "2001-08-31T04:24:14.966996Z"  */
name|exploded_time
operator|.
name|tm_year
operator|=
operator|(
name|apr_int32_t
operator|)
name|strtol
argument_list|(
name|data
argument_list|,
operator|&
name|c
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|++
operator|!=
literal|'-'
condition|)
goto|goto
name|fail
goto|;
name|exploded_time
operator|.
name|tm_mon
operator|=
operator|(
name|apr_int32_t
operator|)
name|strtol
argument_list|(
name|c
argument_list|,
operator|&
name|c
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|++
operator|!=
literal|'-'
condition|)
goto|goto
name|fail
goto|;
name|exploded_time
operator|.
name|tm_mday
operator|=
operator|(
name|apr_int32_t
operator|)
name|strtol
argument_list|(
name|c
argument_list|,
operator|&
name|c
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|++
operator|!=
literal|'T'
condition|)
goto|goto
name|fail
goto|;
name|exploded_time
operator|.
name|tm_hour
operator|=
operator|(
name|apr_int32_t
operator|)
name|strtol
argument_list|(
name|c
argument_list|,
operator|&
name|c
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|++
operator|!=
literal|':'
condition|)
goto|goto
name|fail
goto|;
name|exploded_time
operator|.
name|tm_min
operator|=
operator|(
name|apr_int32_t
operator|)
name|strtol
argument_list|(
name|c
argument_list|,
operator|&
name|c
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|++
operator|!=
literal|':'
condition|)
goto|goto
name|fail
goto|;
name|exploded_time
operator|.
name|tm_sec
operator|=
operator|(
name|apr_int32_t
operator|)
name|strtol
argument_list|(
name|c
argument_list|,
operator|&
name|c
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|++
operator|!=
literal|'.'
condition|)
goto|goto
name|fail
goto|;
name|exploded_time
operator|.
name|tm_usec
operator|=
operator|(
name|apr_int32_t
operator|)
name|strtol
argument_list|(
name|c
argument_list|,
operator|&
name|c
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|++
operator|!=
literal|'Z'
condition|)
goto|goto
name|fail
goto|;
name|exploded_time
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|exploded_time
operator|.
name|tm_mon
operator|-=
literal|1
expr_stmt|;
name|exploded_time
operator|.
name|tm_wday
operator|=
literal|0
expr_stmt|;
name|exploded_time
operator|.
name|tm_yday
operator|=
literal|0
expr_stmt|;
name|exploded_time
operator|.
name|tm_isdst
operator|=
literal|0
expr_stmt|;
name|exploded_time
operator|.
name|tm_gmtoff
operator|=
literal|0
expr_stmt|;
name|apr_err
operator|=
name|apr_time_exp_gmt_get
argument_list|(
name|when
argument_list|,
operator|&
name|exploded_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|==
name|APR_SUCCESS
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_DATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|fail
label|:
comment|/* Try the compatibility option.  This does not need to be fast,      as this format is no longer generated and the client will convert      an old-format entries file the first time it reads it.  */
if|if
condition|(
name|sscanf
argument_list|(
name|data
argument_list|,
name|OLD_TIMESTAMP_FORMAT
argument_list|,
name|wday
argument_list|,
operator|&
name|exploded_time
operator|.
name|tm_mday
argument_list|,
name|month
argument_list|,
operator|&
name|exploded_time
operator|.
name|tm_year
argument_list|,
operator|&
name|exploded_time
operator|.
name|tm_hour
argument_list|,
operator|&
name|exploded_time
operator|.
name|tm_min
argument_list|,
operator|&
name|exploded_time
operator|.
name|tm_sec
argument_list|,
operator|&
name|exploded_time
operator|.
name|tm_usec
argument_list|,
operator|&
name|exploded_time
operator|.
name|tm_yday
argument_list|,
operator|&
name|exploded_time
operator|.
name|tm_isdst
argument_list|,
operator|&
name|exploded_time
operator|.
name|tm_gmtoff
argument_list|)
operator|==
literal|11
condition|)
block|{
name|exploded_time
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|exploded_time
operator|.
name|tm_yday
operator|-=
literal|1
expr_stmt|;
comment|/* Using hard coded limits for the arrays - they are going away          soon in any case. */
name|exploded_time
operator|.
name|tm_wday
operator|=
name|find_matching_string
argument_list|(
name|wday
argument_list|,
literal|7
argument_list|,
name|apr_day_snames
argument_list|)
expr_stmt|;
name|exploded_time
operator|.
name|tm_mon
operator|=
name|find_matching_string
argument_list|(
name|month
argument_list|,
literal|12
argument_list|,
name|apr_month_snames
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_time_exp_gmt_get
argument_list|(
name|when
argument_list|,
operator|&
name|exploded_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_DATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Timestamp is something we do not recognize. */
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_BAD_DATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_time_to_human_cstring
parameter_list|(
name|apr_time_t
name|when
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_time_exp_t
name|exploded_time
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|,
name|retlen
decl_stmt|;
name|apr_status_t
name|ret
decl_stmt|;
name|char
modifier|*
name|datestr
decl_stmt|,
modifier|*
name|curptr
decl_stmt|,
name|human_datestr
index|[
name|SVN_TIME__MAX_LENGTH
index|]
decl_stmt|;
comment|/* Get the time into parts */
name|ret
operator|=
name|apr_time_exp_lt
argument_list|(
operator|&
name|exploded_time
argument_list|,
name|when
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|NULL
return|;
comment|/* Make room for datestring */
name|datestr
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|SVN_TIME__MAX_LENGTH
argument_list|)
expr_stmt|;
comment|/* Put in machine parseable part */
name|len
operator|=
name|apr_snprintf
argument_list|(
name|datestr
argument_list|,
name|SVN_TIME__MAX_LENGTH
argument_list|,
name|HUMAN_TIMESTAMP_FORMAT
argument_list|,
name|exploded_time
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|exploded_time
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|exploded_time
operator|.
name|tm_mday
argument_list|,
name|exploded_time
operator|.
name|tm_hour
argument_list|,
name|exploded_time
operator|.
name|tm_min
argument_list|,
name|exploded_time
operator|.
name|tm_sec
argument_list|,
name|exploded_time
operator|.
name|tm_gmtoff
operator|/
operator|(
literal|60
operator|*
literal|60
operator|)
argument_list|,
operator|(
name|abs
argument_list|(
name|exploded_time
operator|.
name|tm_gmtoff
argument_list|)
operator|/
literal|60
operator|)
operator|%
literal|60
argument_list|)
expr_stmt|;
comment|/* If we overfilled the buffer, just return what we got. */
if|if
condition|(
name|len
operator|>=
name|SVN_TIME__MAX_LENGTH
condition|)
return|return
name|datestr
return|;
comment|/* Calculate offset to the end of the machine parseable part. */
name|curptr
operator|=
name|datestr
operator|+
name|len
expr_stmt|;
comment|/* Put in human explanatory part */
name|ret
operator|=
name|apr_strftime
argument_list|(
name|human_datestr
argument_list|,
operator|&
name|retlen
argument_list|,
name|SVN_TIME__MAX_LENGTH
operator|-
name|len
argument_list|,
name|human_timestamp_format_suffix
argument_list|,
operator|&
name|exploded_time
argument_list|)
expr_stmt|;
comment|/* If there was an error, ensure that the string is zero-terminated. */
if|if
condition|(
name|ret
operator|||
name|retlen
operator|==
literal|0
condition|)
operator|*
name|curptr
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|utf8_string
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_string
argument_list|,
name|human_datestr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|*
name|curptr
operator|=
literal|'\0'
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
name|apr_cpystrn
argument_list|(
name|curptr
argument_list|,
name|utf8_string
argument_list|,
name|SVN_TIME__MAX_LENGTH
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|datestr
return|;
block|}
end_function

begin_function
name|void
name|svn_sleep_for_timestamps
parameter_list|(
name|void
parameter_list|)
block|{
name|svn_io_sleep_for_timestamps
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

