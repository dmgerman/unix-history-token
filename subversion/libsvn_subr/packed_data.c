begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* packed_data.c : implement the packed binary stream data structure  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_delta_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_packed_data.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Private int stream data referenced by svn_packed__int_stream_t.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|packed_int_private_t
block|{
comment|/* First sub-stream, if any.  NULL otherwise. */
name|svn_packed__int_stream_t
modifier|*
name|first_substream
decl_stmt|;
comment|/* Last sub-stream, if any.  NULL otherwise. */
name|svn_packed__int_stream_t
modifier|*
name|last_substream
decl_stmt|;
comment|/* Current sub-stream to read from / write to, if any.  NULL otherwise.      This will be initialized to FIRST_SUBSTREAM and then advanced in a      round-robin scheme after each number being read. */
name|svn_packed__int_stream_t
modifier|*
name|current_substream
decl_stmt|;
comment|/* Number of sub-streams. */
name|apr_size_t
name|substream_count
decl_stmt|;
comment|/* Next (sibling) integer stream.  If this is the last one, points to      the first in the list (i.e. this forms a ring list).  Never NULL. */
name|svn_packed__int_stream_t
modifier|*
name|next
decl_stmt|;
comment|/* 7b/8b encoded integer values (previously diff'ed and sign-handled,      if indicated by the flags below).  The contents are disjoint from      the unparsed number buffer.  May be NULL while not written to. */
name|svn_stringbuf_t
modifier|*
name|packed
decl_stmt|;
comment|/* Initialized to 0.  Latest value written to / read from PACKED.      Undefined if DIFF is FALSE. */
name|apr_uint64_t
name|last_value
decl_stmt|;
comment|/* Deltify data before storing it in PACKED. */
name|svn_boolean_t
name|diff
decl_stmt|;
comment|/* Numbers are likely to contain negative values with small absolutes.      If TRUE, store the signed bit in LSB before encoding. */
name|svn_boolean_t
name|is_signed
decl_stmt|;
comment|/* Number of integers in this stream. */
name|apr_size_t
name|item_count
decl_stmt|;
comment|/* TRUE for the last stream in a list of siblings. */
name|svn_boolean_t
name|is_last
decl_stmt|;
comment|/* Pool to use for allocations. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|packed_int_private_t
typedef|;
end_typedef

begin_comment
comment|/* A byte sequence stream.  Please note that NEXT is defined different  * from the NEXT member in integer streams.  */
end_comment

begin_struct
struct|struct
name|svn_packed__byte_stream_t
block|{
comment|/* First sub-stream, if any.  NULL otherwise. */
name|svn_packed__byte_stream_t
modifier|*
name|first_substream
decl_stmt|;
comment|/* Last sub-stream, if any.  NULL otherwise. */
name|svn_packed__byte_stream_t
modifier|*
name|last_substream
decl_stmt|;
comment|/* Next (sibling) byte sequence stream, if any.  NULL otherwise. */
name|svn_packed__byte_stream_t
modifier|*
name|next
decl_stmt|;
comment|/* Stream to store the sequence lengths. */
name|svn_packed__int_stream_t
modifier|*
name|lengths_stream
decl_stmt|;
comment|/* It's index (relative to its parent). */
name|apr_size_t
name|lengths_stream_index
decl_stmt|;
comment|/* Concatenated byte sequences. */
name|svn_stringbuf_t
modifier|*
name|packed
decl_stmt|;
comment|/* Pool to use for allocations. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The serialization root object.  It references the top-level streams.  */
end_comment

begin_struct
struct|struct
name|svn_packed__data_root_t
block|{
comment|/* First top-level integer stream, if any.  NULL otherwise. */
name|svn_packed__int_stream_t
modifier|*
name|first_int_stream
decl_stmt|;
comment|/* Last top-level integer stream, if any.  NULL otherwise. */
name|svn_packed__int_stream_t
modifier|*
name|last_int_stream
decl_stmt|;
comment|/* Number of top-level integer streams. */
name|apr_size_t
name|int_stream_count
decl_stmt|;
comment|/* First top-level byte sequence stream, if any.  NULL otherwise. */
name|svn_packed__byte_stream_t
modifier|*
name|first_byte_stream
decl_stmt|;
comment|/* Last top-level byte sequence stream, if any.  NULL otherwise. */
name|svn_packed__byte_stream_t
modifier|*
name|last_byte_stream
decl_stmt|;
comment|/* Number of top-level byte sequence streams. */
name|apr_size_t
name|byte_stream_count
decl_stmt|;
comment|/* Pool to use for allocations. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Write access. */
end_comment

begin_function
name|svn_packed__data_root_t
modifier|*
name|svn_packed__data_create_root
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_packed__data_root_t
modifier|*
name|root
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|root
argument_list|)
argument_list|)
decl_stmt|;
name|root
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|root
return|;
block|}
end_function

begin_function
name|svn_packed__int_stream_t
modifier|*
name|svn_packed__create_int_stream
parameter_list|(
name|svn_packed__data_root_t
modifier|*
name|root
parameter_list|,
name|svn_boolean_t
name|diff
parameter_list|,
name|svn_boolean_t
name|signed_ints
parameter_list|)
block|{
comment|/* allocate and initialize the stream node */
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|apr_pcalloc
argument_list|(
name|root
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|private_data
argument_list|)
argument_list|)
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|stream
init|=
name|apr_palloc
argument_list|(
name|root
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|)
decl_stmt|;
name|private_data
operator|->
name|diff
operator|=
name|diff
expr_stmt|;
name|private_data
operator|->
name|is_signed
operator|=
name|signed_ints
expr_stmt|;
name|private_data
operator|->
name|is_last
operator|=
name|TRUE
expr_stmt|;
name|private_data
operator|->
name|pool
operator|=
name|root
operator|->
name|pool
expr_stmt|;
name|stream
operator|->
name|buffer_used
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|private_data
operator|=
name|private_data
expr_stmt|;
comment|/* maintain the ring list */
if|if
condition|(
name|root
operator|->
name|last_int_stream
condition|)
block|{
name|packed_int_private_t
modifier|*
name|previous_private_data
init|=
name|root
operator|->
name|last_int_stream
operator|->
name|private_data
decl_stmt|;
name|previous_private_data
operator|->
name|next
operator|=
name|stream
expr_stmt|;
name|previous_private_data
operator|->
name|is_last
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|root
operator|->
name|first_int_stream
operator|=
name|stream
expr_stmt|;
block|}
name|root
operator|->
name|last_int_stream
operator|=
name|stream
expr_stmt|;
name|root
operator|->
name|int_stream_count
operator|++
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|svn_packed__int_stream_t
modifier|*
name|svn_packed__create_int_substream
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|parent
parameter_list|,
name|svn_boolean_t
name|diff
parameter_list|,
name|svn_boolean_t
name|signed_ints
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|parent_private
init|=
name|parent
operator|->
name|private_data
decl_stmt|;
comment|/* allocate and initialize the stream node */
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|apr_pcalloc
argument_list|(
name|parent_private
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|private_data
argument_list|)
argument_list|)
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|stream
init|=
name|apr_palloc
argument_list|(
name|parent_private
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|)
decl_stmt|;
name|private_data
operator|->
name|diff
operator|=
name|diff
expr_stmt|;
name|private_data
operator|->
name|is_signed
operator|=
name|signed_ints
expr_stmt|;
name|private_data
operator|->
name|is_last
operator|=
name|TRUE
expr_stmt|;
name|private_data
operator|->
name|pool
operator|=
name|parent_private
operator|->
name|pool
expr_stmt|;
name|stream
operator|->
name|buffer_used
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|private_data
operator|=
name|private_data
expr_stmt|;
comment|/* maintain the ring list */
if|if
condition|(
name|parent_private
operator|->
name|last_substream
condition|)
block|{
name|packed_int_private_t
modifier|*
name|previous_private_data
init|=
name|parent_private
operator|->
name|last_substream
operator|->
name|private_data
decl_stmt|;
name|previous_private_data
operator|->
name|next
operator|=
name|stream
expr_stmt|;
name|previous_private_data
operator|->
name|is_last
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|parent_private
operator|->
name|first_substream
operator|=
name|stream
expr_stmt|;
name|parent_private
operator|->
name|current_substream
operator|=
name|stream
expr_stmt|;
block|}
name|parent_private
operator|->
name|last_substream
operator|=
name|stream
expr_stmt|;
name|parent_private
operator|->
name|substream_count
operator|++
expr_stmt|;
name|private_data
operator|->
name|next
operator|=
name|parent_private
operator|->
name|first_substream
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_comment
comment|/* Returns a new top-level byte sequence stream for ROOT but does not  * initialize the LENGTH_STREAM member.  */
end_comment

begin_function
specifier|static
name|svn_packed__byte_stream_t
modifier|*
name|create_bytes_stream_body
parameter_list|(
name|svn_packed__data_root_t
modifier|*
name|root
parameter_list|)
block|{
name|svn_packed__byte_stream_t
modifier|*
name|stream
init|=
name|apr_pcalloc
argument_list|(
name|root
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|)
decl_stmt|;
name|stream
operator|->
name|packed
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|root
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|last_byte_stream
condition|)
name|root
operator|->
name|last_byte_stream
operator|->
name|next
operator|=
name|stream
expr_stmt|;
else|else
name|root
operator|->
name|first_byte_stream
operator|=
name|stream
expr_stmt|;
name|root
operator|->
name|last_byte_stream
operator|=
name|stream
expr_stmt|;
name|root
operator|->
name|byte_stream_count
operator|++
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|svn_packed__byte_stream_t
modifier|*
name|svn_packed__create_bytes_stream
parameter_list|(
name|svn_packed__data_root_t
modifier|*
name|root
parameter_list|)
block|{
name|svn_packed__byte_stream_t
modifier|*
name|stream
init|=
name|create_bytes_stream_body
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|stream
operator|->
name|lengths_stream_index
operator|=
name|root
operator|->
name|int_stream_count
expr_stmt|;
name|stream
operator|->
name|lengths_stream
operator|=
name|svn_packed__create_int_stream
argument_list|(
name|root
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_comment
comment|/* Write the 7b/8b representation of VALUE into BUFFER.  BUFFER must  * provide at least 10 bytes space.  * Returns the first position behind the written data.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|write_packed_uint_body
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_uint64_t
name|value
parameter_list|)
block|{
while|while
condition|(
name|value
operator|>=
literal|0x80
condition|)
block|{
operator|*
operator|(
name|buffer
operator|++
operator|)
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|%
literal|0x80
operator|)
operator|+
literal|0x80
argument_list|)
expr_stmt|;
name|value
operator|/=
literal|0x80
expr_stmt|;
block|}
operator|*
operator|(
name|buffer
operator|++
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|value
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Return remapped VALUE.  *  * Due to sign conversion and diff underflow, values close to UINT64_MAX  * are almost as frequent as those close to 0.  Remap them such that the  * MSB is stored in the LSB and the remainder stores the absolute distance  * to 0.  *  * This minimizes the absolute value to store in many scenarios.  * Hence, the variable-length representation on disk is shorter, too.  */
end_comment

begin_function
specifier|static
name|apr_uint64_t
name|remap_uint
parameter_list|(
name|apr_uint64_t
name|value
parameter_list|)
block|{
return|return
name|value
operator|&
name|APR_UINT64_C
argument_list|(
literal|0x8000000000000000
argument_list|)
condition|?
name|APR_UINT64_MAX
operator|-
operator|(
literal|2
operator|*
name|value
operator|)
else|:
literal|2
operator|*
name|value
return|;
block|}
end_function

begin_comment
comment|/* Invert remap_uint. */
end_comment

begin_function
specifier|static
name|apr_uint64_t
name|unmap_uint
parameter_list|(
name|apr_uint64_t
name|value
parameter_list|)
block|{
return|return
name|value
operator|&
literal|1
condition|?
operator|(
name|APR_UINT64_MAX
operator|-
name|value
operator|/
literal|2
operator|)
else|:
name|value
operator|/
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Empty the unprocessed integer buffer in STREAM by either pushing the  * data to the sub-streams or writing to the packed data (in case there  * are no sub-streams).  */
end_comment

begin_function
specifier|static
name|void
name|svn_packed__data_flush_buffer
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
comment|/* if we have sub-streams, push the data down to them */
if|if
condition|(
name|private_data
operator|->
name|current_substream
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stream
operator|->
name|buffer_used
condition|;
operator|++
name|i
control|)
block|{
name|packed_int_private_t
modifier|*
name|current_private_data
init|=
name|private_data
operator|->
name|current_substream
operator|->
name|private_data
decl_stmt|;
name|svn_packed__add_uint
argument_list|(
name|private_data
operator|->
name|current_substream
argument_list|,
name|stream
operator|->
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|private_data
operator|->
name|current_substream
operator|=
name|current_private_data
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* pack the numbers into our local PACKED buffer */
comment|/* temporary buffer, max 10 bytes required per 7b/8b encoded number */
name|unsigned
name|char
name|local_buffer
index|[
literal|10
operator|*
name|SVN__PACKED_DATA_BUFFER_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
name|local_buffer
decl_stmt|;
comment|/* if configured, deltify numbers before packing them.          Since delta may be negative, always use the 'signed' encoding. */
if|if
condition|(
name|private_data
operator|->
name|diff
condition|)
block|{
name|apr_uint64_t
name|last_value
init|=
name|private_data
operator|->
name|last_value
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stream
operator|->
name|buffer_used
condition|;
operator|++
name|i
control|)
block|{
name|apr_uint64_t
name|temp
init|=
name|stream
operator|->
name|buffer
index|[
name|i
index|]
decl_stmt|;
name|stream
operator|->
name|buffer
index|[
name|i
index|]
operator|=
name|remap_uint
argument_list|(
name|temp
operator|-
name|last_value
argument_list|)
expr_stmt|;
name|last_value
operator|=
name|temp
expr_stmt|;
block|}
name|private_data
operator|->
name|last_value
operator|=
name|last_value
expr_stmt|;
block|}
comment|/* if configured and not already done by the deltification above,          transform to 'signed' encoding.  Store the sign in the LSB and          the absolute value (-1 for negative values) in the remaining          63 bits. */
if|if
condition|(
operator|!
name|private_data
operator|->
name|diff
operator|&&
name|private_data
operator|->
name|is_signed
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stream
operator|->
name|buffer_used
condition|;
operator|++
name|i
control|)
name|stream
operator|->
name|buffer
index|[
name|i
index|]
operator|=
name|remap_uint
argument_list|(
name|stream
operator|->
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* auto-create packed data buffer.  Give it some reasonable initial          size - just enough for a few tens of values. */
if|if
condition|(
name|private_data
operator|->
name|packed
operator|==
name|NULL
condition|)
name|private_data
operator|->
name|packed
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|256
argument_list|,
name|private_data
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* encode numbers into our temp buffer. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stream
operator|->
name|buffer_used
condition|;
operator|++
name|i
control|)
name|p
operator|=
name|write_packed_uint_body
argument_list|(
name|p
argument_list|,
name|stream
operator|->
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* append them to the final packed data */
name|svn_stringbuf_appendbytes
argument_list|(
name|private_data
operator|->
name|packed
argument_list|,
operator|(
name|char
operator|*
operator|)
name|local_buffer
argument_list|,
name|p
operator|-
name|local_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* maintain counters */
name|private_data
operator|->
name|item_count
operator|+=
name|stream
operator|->
name|buffer_used
expr_stmt|;
name|stream
operator|->
name|buffer_used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_packed__add_uint
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_uint64_t
name|value
parameter_list|)
block|{
name|stream
operator|->
name|buffer
index|[
name|stream
operator|->
name|buffer_used
index|]
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|++
name|stream
operator|->
name|buffer_used
operator|==
name|SVN__PACKED_DATA_BUFFER_SIZE
condition|)
name|svn_packed__data_flush_buffer
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_packed__add_int
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_int64_t
name|value
parameter_list|)
block|{
name|svn_packed__add_uint
argument_list|(
name|stream
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_packed__add_bytes
parameter_list|(
name|svn_packed__byte_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|svn_packed__add_uint
argument_list|(
name|stream
operator|->
name|lengths_stream
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|stream
operator|->
name|packed
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append the 7b/8b encoded representation of VALUE to PACKED.  */
end_comment

begin_function
specifier|static
name|void
name|write_packed_uint
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|packed
parameter_list|,
name|apr_uint64_t
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|<
literal|0x80
condition|)
block|{
name|svn_stringbuf_appendbyte
argument_list|(
name|packed
argument_list|,
operator|(
name|char
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
name|write_packed_uint_body
argument_list|(
name|buffer
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|packed
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|p
operator|-
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Recursively write the structure (config parameters, sub-streams, data  * sizes) of the STREAM and all its siblings to the TREE_STRUCT buffer.  */
end_comment

begin_function
specifier|static
name|void
name|write_int_stream_structure
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|tree_struct
parameter_list|,
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
while|while
condition|(
name|stream
condition|)
block|{
comment|/* store config parameters and number of sub-streams in 1 number */
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
name|write_packed_uint
argument_list|(
name|tree_struct
argument_list|,
operator|(
name|private_data
operator|->
name|substream_count
operator|<<
literal|2
operator|)
operator|+
operator|(
name|private_data
operator|->
name|diff
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|private_data
operator|->
name|is_signed
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* store item count and length their of packed representation */
name|svn_packed__data_flush_buffer
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|write_packed_uint
argument_list|(
name|tree_struct
argument_list|,
name|private_data
operator|->
name|item_count
argument_list|)
expr_stmt|;
name|write_packed_uint
argument_list|(
name|tree_struct
argument_list|,
name|private_data
operator|->
name|packed
condition|?
name|private_data
operator|->
name|packed
operator|->
name|len
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* append all sub-stream structures */
name|write_int_stream_structure
argument_list|(
name|tree_struct
argument_list|,
name|private_data
operator|->
name|first_substream
argument_list|)
expr_stmt|;
comment|/* continue with next sibling */
name|stream
operator|=
name|private_data
operator|->
name|is_last
condition|?
name|NULL
else|:
name|private_data
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Recursively write the structure (sub-streams, data sizes) of the STREAM  * and all its siblings to the TREE_STRUCT buffer.  */
end_comment

begin_function
specifier|static
name|void
name|write_byte_stream_structure
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|tree_struct
parameter_list|,
name|svn_packed__byte_stream_t
modifier|*
name|stream
parameter_list|)
block|{
comment|/* for this and all siblings */
for|for
control|(
init|;
name|stream
condition|;
name|stream
operator|=
name|stream
operator|->
name|next
control|)
block|{
comment|/* this stream's structure and size */
name|write_packed_uint
argument_list|(
name|tree_struct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_packed_uint
argument_list|(
name|tree_struct
argument_list|,
name|stream
operator|->
name|lengths_stream_index
argument_list|)
expr_stmt|;
name|write_packed_uint
argument_list|(
name|tree_struct
argument_list|,
name|stream
operator|->
name|packed
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* followed by all its sub-streams */
name|write_byte_stream_structure
argument_list|(
name|tree_struct
argument_list|,
name|stream
operator|->
name|first_substream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the 7b/8b encoded representation of VALUE to STREAM.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_stream_uint
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_uint64_t
name|value
parameter_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|apr_size_t
name|count
init|=
name|write_packed_uint_body
argument_list|(
name|buffer
argument_list|,
name|value
argument_list|)
operator|-
name|buffer
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
operator|&
name|count
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the total size of all packed data in STREAM, its siblings and  * all sub-streams.  To get an accurate value, flush all buffers prior to  * calling this function.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|packed_int_stream_length
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
name|apr_size_t
name|result
init|=
name|private_data
operator|->
name|packed
condition|?
name|private_data
operator|->
name|packed
operator|->
name|len
else|:
literal|0
decl_stmt|;
name|stream
operator|=
name|private_data
operator|->
name|first_substream
expr_stmt|;
while|while
condition|(
name|stream
condition|)
block|{
name|private_data
operator|=
name|stream
operator|->
name|private_data
expr_stmt|;
name|result
operator|+=
name|packed_int_stream_length
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|=
name|private_data
operator|->
name|is_last
condition|?
name|NULL
else|:
name|private_data
operator|->
name|next
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the total size of all byte sequences data in STREAM, its siblings  * and all sub-streams.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|packed_byte_stream_length
parameter_list|(
name|svn_packed__byte_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|apr_size_t
name|result
init|=
name|stream
operator|->
name|packed
operator|->
name|len
decl_stmt|;
for|for
control|(
name|stream
operator|=
name|stream
operator|->
name|first_substream
init|;
name|stream
condition|;
name|stream
operator|=
name|stream
operator|->
name|next
control|)
name|result
operator|+=
name|packed_byte_stream_length
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Append all packed data in STREAM, its siblings and all sub-streams to  * COMBINED.  */
end_comment

begin_function
specifier|static
name|void
name|append_int_stream
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|combined
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
if|if
condition|(
name|private_data
operator|->
name|packed
condition|)
name|svn_stringbuf_appendstr
argument_list|(
name|combined
argument_list|,
name|private_data
operator|->
name|packed
argument_list|)
expr_stmt|;
name|stream
operator|=
name|private_data
operator|->
name|first_substream
expr_stmt|;
while|while
condition|(
name|stream
condition|)
block|{
name|private_data
operator|=
name|stream
operator|->
name|private_data
expr_stmt|;
name|append_int_stream
argument_list|(
name|stream
argument_list|,
name|combined
argument_list|)
expr_stmt|;
name|stream
operator|=
name|private_data
operator|->
name|is_last
condition|?
name|NULL
else|:
name|private_data
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append all byte sequences in STREAM, its siblings and all sub-streams  * to COMBINED.  */
end_comment

begin_function
specifier|static
name|void
name|append_byte_stream
parameter_list|(
name|svn_packed__byte_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|combined
parameter_list|)
block|{
name|svn_stringbuf_appendstr
argument_list|(
name|combined
argument_list|,
name|stream
operator|->
name|packed
argument_list|)
expr_stmt|;
for|for
control|(
name|stream
operator|=
name|stream
operator|->
name|first_substream
init|;
name|stream
condition|;
name|stream
operator|=
name|stream
operator|->
name|next
control|)
name|append_byte_stream
argument_list|(
name|stream
argument_list|,
name|combined
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take the binary data in UNCOMPRESSED, zip it into COMPRESSED and write  * it to STREAM.  COMPRESSED simply acts as a re-usable memory buffer.  * Clear all buffers (COMPRESSED, UNCOMPRESSED) at the end of the function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_stream_data
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|uncompressed
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|compressed
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn__compress
argument_list|(
name|uncompressed
argument_list|,
name|compressed
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_stream_uint
argument_list|(
name|stream
argument_list|,
name|compressed
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|compressed
operator|->
name|data
argument_list|,
operator|&
name|compressed
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|uncompressed
argument_list|)
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_packed__data_write
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_packed__data_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_packed__int_stream_t
modifier|*
name|int_stream
decl_stmt|;
name|svn_packed__byte_stream_t
modifier|*
name|byte_stream
decl_stmt|;
comment|/* re-usable data buffers */
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|1024
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|1024
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* write tree structure */
name|svn_stringbuf_t
modifier|*
name|tree_struct
init|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|127
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|write_packed_uint
argument_list|(
name|tree_struct
argument_list|,
name|root
operator|->
name|int_stream_count
argument_list|)
expr_stmt|;
name|write_int_stream_structure
argument_list|(
name|tree_struct
argument_list|,
name|root
operator|->
name|first_int_stream
argument_list|)
expr_stmt|;
name|write_packed_uint
argument_list|(
name|tree_struct
argument_list|,
name|root
operator|->
name|byte_stream_count
argument_list|)
expr_stmt|;
name|write_byte_stream_structure
argument_list|(
name|tree_struct
argument_list|,
name|root
operator|->
name|first_byte_stream
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_stream_uint
argument_list|(
name|stream
argument_list|,
name|tree_struct
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|tree_struct
operator|->
name|data
argument_list|,
operator|&
name|tree_struct
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flatten sub-streams, zip them and write them to disk */
for|for
control|(
name|int_stream
operator|=
name|root
operator|->
name|first_int_stream
init|;
name|int_stream
condition|;
name|int_stream
operator|=
operator|(
operator|(
name|packed_int_private_t
operator|*
operator|)
name|int_stream
operator|->
name|private_data
operator|)
operator|->
name|next
control|)
block|{
name|apr_size_t
name|len
init|=
name|packed_int_stream_length
argument_list|(
name|int_stream
argument_list|)
decl_stmt|;
name|svn_stringbuf_ensure
argument_list|(
name|uncompressed
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|append_int_stream
argument_list|(
name|int_stream
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_stream_data
argument_list|(
name|stream
argument_list|,
name|uncompressed
argument_list|,
name|compressed
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|byte_stream
operator|=
name|root
operator|->
name|first_byte_stream
init|;
name|byte_stream
condition|;
name|byte_stream
operator|=
name|byte_stream
operator|->
name|next
control|)
block|{
name|apr_size_t
name|len
init|=
name|packed_byte_stream_length
argument_list|(
name|byte_stream
argument_list|)
decl_stmt|;
name|svn_stringbuf_ensure
argument_list|(
name|uncompressed
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|append_byte_stream
argument_list|(
name|byte_stream
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_stream_data
argument_list|(
name|stream
argument_list|,
name|uncompressed
argument_list|,
name|compressed
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read access. */
end_comment

begin_function
name|svn_packed__int_stream_t
modifier|*
name|svn_packed__first_int_stream
parameter_list|(
name|svn_packed__data_root_t
modifier|*
name|root
parameter_list|)
block|{
return|return
name|root
operator|->
name|first_int_stream
return|;
block|}
end_function

begin_function
name|svn_packed__byte_stream_t
modifier|*
name|svn_packed__first_byte_stream
parameter_list|(
name|svn_packed__data_root_t
modifier|*
name|root
parameter_list|)
block|{
return|return
name|root
operator|->
name|first_byte_stream
return|;
block|}
end_function

begin_function
name|svn_packed__int_stream_t
modifier|*
name|svn_packed__next_int_stream
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
return|return
name|private_data
operator|->
name|is_last
condition|?
name|NULL
else|:
name|private_data
operator|->
name|next
return|;
block|}
end_function

begin_function
name|svn_packed__byte_stream_t
modifier|*
name|svn_packed__next_byte_stream
parameter_list|(
name|svn_packed__byte_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|stream
operator|->
name|next
return|;
block|}
end_function

begin_function
name|svn_packed__int_stream_t
modifier|*
name|svn_packed__first_int_substream
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
return|return
name|private_data
operator|->
name|first_substream
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_packed__int_count
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
return|return
name|private_data
operator|->
name|item_count
operator|+
name|stream
operator|->
name|buffer_used
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_packed__byte_count
parameter_list|(
name|svn_packed__byte_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|stream
operator|->
name|packed
operator|->
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read one 7b/8b encoded value from *P and return it in *RESULT.  Returns  * the first position after the parsed data.  *  * Overflows will be detected in the sense that it will end parsing the  * input but the result is undefined.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|read_packed_uint_body
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|apr_uint64_t
modifier|*
name|result
parameter_list|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|0x80
condition|)
block|{
operator|*
name|result
operator|=
operator|*
name|p
expr_stmt|;
block|}
else|else
block|{
name|apr_uint64_t
name|shift
init|=
literal|0
decl_stmt|;
name|apr_uint64_t
name|value
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|0x80
condition|)
block|{
name|value
operator|+=
call|(
name|apr_uint64_t
call|)
argument_list|(
operator|*
name|p
operator|&
literal|0x7f
argument_list|)
operator|<<
name|shift
expr_stmt|;
operator|++
name|p
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|64
condition|)
block|{
comment|/* a definite overflow.  Note, that numbers of 65 .. 70                  bits will not be detected as an overflow as they don't                  threaten to exceed the input buffer. */
operator|*
name|result
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
operator|*
name|result
operator|=
name|value
operator|+
operator|(
operator|(
name|apr_uint64_t
operator|)
operator|*
name|p
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
return|return
operator|++
name|p
return|;
block|}
end_function

begin_comment
comment|/* Read one 7b/8b encoded value from STREAM and return it in *RESULT.  *  * Overflows will be detected in the sense that it will end parsing the  * input but the result is undefined.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_stream_uint
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_uint64_t
modifier|*
name|result
parameter_list|)
block|{
name|apr_uint64_t
name|shift
init|=
literal|0
decl_stmt|;
name|apr_uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
do|do
block|{
name|apr_size_t
name|len
init|=
literal|1
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CORRUPT_PACKED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of stream"
argument_list|)
argument_list|)
return|;
name|value
operator|+=
call|(
name|apr_uint64_t
call|)
argument_list|(
name|c
operator|&
literal|0x7f
argument_list|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|64
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CORRUPT_PACKED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Integer representation too long"
argument_list|)
argument_list|)
return|;
block|}
do|while
condition|(
name|c
operator|>=
literal|0x80
condition|)
do|;
operator|*
name|result
operator|=
name|value
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Extract and return the next integer from PACKED and make PACKED point  * to the next integer.  */
end_comment

begin_function
specifier|static
name|apr_uint64_t
name|read_packed_uint
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|packed
parameter_list|)
block|{
name|apr_uint64_t
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|packed
operator|->
name|data
decl_stmt|;
name|apr_size_t
name|read
init|=
name|read_packed_uint_body
argument_list|(
name|p
argument_list|,
operator|&
name|result
argument_list|)
operator|-
name|p
decl_stmt|;
if|if
condition|(
name|read
operator|>
name|packed
operator|->
name|len
condition|)
name|read
operator|=
name|packed
operator|->
name|len
expr_stmt|;
name|packed
operator|->
name|data
operator|+=
name|read
expr_stmt|;
name|packed
operator|->
name|blocksize
operator|-=
name|read
expr_stmt|;
name|packed
operator|->
name|len
operator|-=
name|read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Ensure that STREAM contains at least one item in its buffer.  */
end_comment

begin_function
specifier|static
name|void
name|svn_packed__data_fill_buffer
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|apr_size_t
name|end
init|=
name|MIN
argument_list|(
name|SVN__PACKED_DATA_BUFFER_SIZE
argument_list|,
name|private_data
operator|->
name|item_count
argument_list|)
decl_stmt|;
comment|/* in case, some user calls us explicitly without a good reason ... */
if|if
condition|(
name|stream
operator|->
name|buffer_used
condition|)
return|return;
comment|/* can we get data from the sub-streams or do we have to decode it from      our local packed container? */
if|if
condition|(
name|private_data
operator|->
name|current_substream
condition|)
for|for
control|(
name|i
operator|=
name|end
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|packed_int_private_t
modifier|*
name|current_private_data
init|=
name|private_data
operator|->
name|current_substream
operator|->
name|private_data
decl_stmt|;
name|stream
operator|->
name|buffer
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|svn_packed__get_uint
argument_list|(
name|private_data
operator|->
name|current_substream
argument_list|)
expr_stmt|;
name|private_data
operator|->
name|current_substream
operator|=
name|current_private_data
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* use this local buffer only if the packed data is shorter than this.          The goal is that read_packed_uint_body doesn't need check for          overflows. */
name|unsigned
name|char
name|local_buffer
index|[
literal|10
operator|*
name|SVN__PACKED_DATA_BUFFER_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|apr_size_t
name|packed_read
decl_stmt|;
if|if
condition|(
name|private_data
operator|->
name|packed
operator|->
name|len
operator|<
sizeof|sizeof
argument_list|(
name|local_buffer
argument_list|)
condition|)
block|{
name|apr_size_t
name|trail
init|=
sizeof|sizeof
argument_list|(
name|local_buffer
argument_list|)
operator|-
name|private_data
operator|->
name|packed
operator|->
name|len
decl_stmt|;
name|memcpy
argument_list|(
name|local_buffer
argument_list|,
name|private_data
operator|->
name|packed
operator|->
name|data
argument_list|,
name|private_data
operator|->
name|packed
operator|->
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|local_buffer
operator|+
name|private_data
operator|->
name|packed
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|MIN
argument_list|(
name|trail
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|local_buffer
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|private_data
operator|->
name|packed
operator|->
name|data
expr_stmt|;
comment|/* unpack numbers */
name|start
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
name|end
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|p
operator|=
name|read_packed_uint_body
argument_list|(
name|p
argument_list|,
operator|&
name|stream
operator|->
name|buffer
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* adjust remaining packed data buffer */
name|packed_read
operator|=
name|p
operator|-
name|start
expr_stmt|;
name|private_data
operator|->
name|packed
operator|->
name|data
operator|+=
name|packed_read
expr_stmt|;
name|private_data
operator|->
name|packed
operator|->
name|len
operator|-=
name|packed_read
expr_stmt|;
name|private_data
operator|->
name|packed
operator|->
name|blocksize
operator|-=
name|packed_read
expr_stmt|;
comment|/* undeltify numbers, if configured */
if|if
condition|(
name|private_data
operator|->
name|diff
condition|)
block|{
name|apr_uint64_t
name|last_value
init|=
name|private_data
operator|->
name|last_value
decl_stmt|;
for|for
control|(
name|i
operator|=
name|end
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|last_value
operator|+=
name|unmap_uint
argument_list|(
name|stream
operator|->
name|buffer
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|stream
operator|->
name|buffer
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|last_value
expr_stmt|;
block|}
name|private_data
operator|->
name|last_value
operator|=
name|last_value
expr_stmt|;
block|}
comment|/* handle signed values, if configured and not handled already */
if|if
condition|(
operator|!
name|private_data
operator|->
name|diff
operator|&&
name|private_data
operator|->
name|is_signed
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
name|stream
operator|->
name|buffer
index|[
name|i
index|]
operator|=
name|unmap_uint
argument_list|(
name|stream
operator|->
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|buffer_used
operator|=
name|end
expr_stmt|;
name|private_data
operator|->
name|item_count
operator|-=
name|end
expr_stmt|;
block|}
end_function

begin_function
name|apr_uint64_t
name|svn_packed__get_uint
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|buffer_used
operator|==
literal|0
condition|)
name|svn_packed__data_fill_buffer
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|stream
operator|->
name|buffer_used
condition|?
name|stream
operator|->
name|buffer
index|[
operator|--
name|stream
operator|->
name|buffer_used
index|]
else|:
literal|0
return|;
block|}
end_function

begin_function
name|apr_int64_t
name|svn_packed__get_int
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
operator|(
name|apr_int64_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_packed__get_bytes
parameter_list|(
name|svn_packed__byte_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
init|=
name|stream
operator|->
name|packed
operator|->
name|data
decl_stmt|;
name|apr_size_t
name|count
init|=
operator|(
name|apr_size_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|stream
operator|->
name|lengths_stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
name|stream
operator|->
name|packed
operator|->
name|len
condition|)
name|count
operator|=
name|stream
operator|->
name|packed
operator|->
name|len
expr_stmt|;
comment|/* advance packed buffer */
name|stream
operator|->
name|packed
operator|->
name|data
operator|+=
name|count
expr_stmt|;
name|stream
operator|->
name|packed
operator|->
name|len
operator|-=
name|count
expr_stmt|;
name|stream
operator|->
name|packed
operator|->
name|blocksize
operator|-=
name|count
expr_stmt|;
operator|*
name|len
operator|=
name|count
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Read the integer stream structure and recreate it in STREAM, including  * sub-streams, from TREE_STRUCT.  */
end_comment

begin_function
specifier|static
name|void
name|read_int_stream_structure
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|tree_struct
parameter_list|,
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
name|apr_uint64_t
name|value
init|=
name|read_packed_uint
argument_list|(
name|tree_struct
argument_list|)
decl_stmt|;
name|apr_size_t
name|substream_count
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
comment|/* extract local parameters */
name|private_data
operator|->
name|diff
operator|=
operator|(
name|value
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|private_data
operator|->
name|is_signed
operator|=
operator|(
name|value
operator|&
literal|2
operator|)
operator|!=
literal|0
expr_stmt|;
name|substream_count
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|value
operator|>>
literal|2
argument_list|)
expr_stmt|;
comment|/* read item count& packed size; allocate packed data buffer */
name|private_data
operator|->
name|item_count
operator|=
operator|(
name|apr_size_t
operator|)
name|read_packed_uint
argument_list|(
name|tree_struct
argument_list|)
expr_stmt|;
name|value
operator|=
name|read_packed_uint
argument_list|(
name|tree_struct
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|private_data
operator|->
name|packed
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
operator|(
name|apr_size_t
operator|)
name|value
argument_list|,
name|private_data
operator|->
name|pool
argument_list|)
expr_stmt|;
name|private_data
operator|->
name|packed
operator|->
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|value
expr_stmt|;
block|}
comment|/* add sub-streams and read their config, too */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|substream_count
condition|;
operator|++
name|i
control|)
name|read_int_stream_structure
argument_list|(
name|tree_struct
argument_list|,
name|svn_packed__create_int_substream
argument_list|(
name|stream
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the integer stream structure and recreate it in STREAM, including  * sub-streams, from TREE_STRUCT.  FIRST_INT_STREAM is the integer stream  * that would correspond to lengths_stream_index 0.  */
end_comment

begin_function
specifier|static
name|void
name|read_byte_stream_structure
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|tree_struct
parameter_list|,
name|svn_packed__byte_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_packed__int_stream_t
modifier|*
name|first_int_stream
parameter_list|)
block|{
name|apr_size_t
name|lengths_stream_index
decl_stmt|;
name|apr_size_t
name|packed_size
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
comment|/* read parameters from the TREE_STRUCT buffer */
operator|(
name|void
operator|)
operator|(
name|apr_size_t
operator|)
name|read_packed_uint
argument_list|(
name|tree_struct
argument_list|)
expr_stmt|;
comment|/* discard first uint */
name|lengths_stream_index
operator|=
operator|(
name|apr_size_t
operator|)
name|read_packed_uint
argument_list|(
name|tree_struct
argument_list|)
expr_stmt|;
name|packed_size
operator|=
operator|(
name|apr_size_t
operator|)
name|read_packed_uint
argument_list|(
name|tree_struct
argument_list|)
expr_stmt|;
comment|/* allocate byte sequence buffer size */
name|svn_stringbuf_ensure
argument_list|(
name|stream
operator|->
name|packed
argument_list|,
name|packed_size
argument_list|)
expr_stmt|;
name|stream
operator|->
name|packed
operator|->
name|len
operator|=
name|packed_size
expr_stmt|;
comment|/* navigate to the (already existing) lengths_stream */
name|stream
operator|->
name|lengths_stream_index
operator|=
name|lengths_stream_index
expr_stmt|;
name|stream
operator|->
name|lengths_stream
operator|=
name|first_int_stream
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lengths_stream_index
condition|;
operator|++
name|i
control|)
block|{
name|packed_int_private_t
modifier|*
name|length_private
init|=
name|stream
operator|->
name|lengths_stream
operator|->
name|private_data
decl_stmt|;
name|stream
operator|->
name|lengths_stream
operator|=
name|length_private
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read a compressed block from STREAM and uncompress it into UNCOMPRESSED.  * UNCOMPRESSED_LEN is the expected size of the stream.  COMPRESSED is a  * re-used buffer for temporary data.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_stream_data
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_size_t
name|uncompressed_len
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|uncompressed
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|compressed
parameter_list|)
block|{
name|apr_uint64_t
name|len
decl_stmt|;
name|apr_size_t
name|compressed_len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_stream_uint
argument_list|(
name|stream
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|compressed_len
operator|=
operator|(
name|apr_size_t
operator|)
name|len
expr_stmt|;
name|svn_stringbuf_ensure
argument_list|(
name|compressed
argument_list|,
name|compressed_len
argument_list|)
expr_stmt|;
name|compressed
operator|->
name|len
operator|=
name|compressed_len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
name|compressed
operator|->
name|data
argument_list|,
operator|&
name|compressed
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|compressed
operator|->
name|data
index|[
name|compressed_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn__decompress
argument_list|(
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|uncompressed_len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the packed contents from COMBINED, starting at *OFFSET and store  * it in STREAM.  Update *OFFSET to point to the next stream's data and  * continue with the sub-streams.  */
end_comment

begin_function
specifier|static
name|void
name|unflatten_int_stream
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|combined
parameter_list|,
name|apr_size_t
modifier|*
name|offset
parameter_list|)
block|{
name|packed_int_private_t
modifier|*
name|private_data
init|=
name|stream
operator|->
name|private_data
decl_stmt|;
if|if
condition|(
name|private_data
operator|->
name|packed
condition|)
block|{
name|memcpy
argument_list|(
name|private_data
operator|->
name|packed
operator|->
name|data
argument_list|,
name|combined
operator|->
name|data
operator|+
operator|*
name|offset
argument_list|,
name|private_data
operator|->
name|packed
operator|->
name|len
argument_list|)
expr_stmt|;
name|private_data
operator|->
name|packed
operator|->
name|data
index|[
name|private_data
operator|->
name|packed
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|offset
operator|+=
name|private_data
operator|->
name|packed
operator|->
name|len
expr_stmt|;
block|}
name|stream
operator|=
name|private_data
operator|->
name|first_substream
expr_stmt|;
while|while
condition|(
name|stream
condition|)
block|{
name|private_data
operator|=
name|stream
operator|->
name|private_data
expr_stmt|;
name|unflatten_int_stream
argument_list|(
name|stream
argument_list|,
name|combined
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|stream
operator|=
name|private_data
operator|->
name|is_last
condition|?
name|NULL
else|:
name|private_data
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read the packed contents from COMBINED, starting at *OFFSET and store  * it in STREAM.  Update *OFFSET to point to the next stream's data and  * continue with the sub-streams.  */
end_comment

begin_function
specifier|static
name|void
name|unflatten_byte_stream
parameter_list|(
name|svn_packed__byte_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|combined
parameter_list|,
name|apr_size_t
modifier|*
name|offset
parameter_list|)
block|{
name|memcpy
argument_list|(
name|stream
operator|->
name|packed
operator|->
name|data
argument_list|,
name|combined
operator|->
name|data
operator|+
operator|*
name|offset
argument_list|,
name|stream
operator|->
name|packed
operator|->
name|len
argument_list|)
expr_stmt|;
name|stream
operator|->
name|packed
operator|->
name|data
index|[
name|stream
operator|->
name|packed
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|offset
operator|+=
name|stream
operator|->
name|packed
operator|->
name|len
expr_stmt|;
for|for
control|(
name|stream
operator|=
name|stream
operator|->
name|first_substream
init|;
name|stream
condition|;
name|stream
operator|=
name|stream
operator|->
name|next
control|)
name|unflatten_byte_stream
argument_list|(
name|stream
argument_list|,
name|combined
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_packed__data_read
parameter_list|(
name|svn_packed__data_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_uint64_t
name|i
decl_stmt|;
name|apr_uint64_t
name|count
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|int_stream
decl_stmt|;
name|svn_packed__byte_stream_t
modifier|*
name|byte_stream
decl_stmt|;
name|svn_packed__data_root_t
modifier|*
name|root
init|=
name|svn_packed__data_create_root
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|1024
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|1024
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* read tree structure */
name|apr_uint64_t
name|tree_struct_size
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|tree_struct
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_stream_uint
argument_list|(
name|stream
argument_list|,
operator|&
name|tree_struct_size
argument_list|)
argument_list|)
expr_stmt|;
name|tree_struct
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
operator|(
name|apr_size_t
operator|)
name|tree_struct_size
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|tree_struct
operator|->
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|tree_struct_size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
name|tree_struct
operator|->
name|data
argument_list|,
operator|&
name|tree_struct
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|tree_struct
operator|->
name|data
index|[
name|tree_struct
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* reconstruct tree structure */
name|count
operator|=
name|read_packed_uint
argument_list|(
name|tree_struct
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|read_int_stream_structure
argument_list|(
name|tree_struct
argument_list|,
name|svn_packed__create_int_stream
argument_list|(
name|root
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|read_packed_uint
argument_list|(
name|tree_struct
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|read_byte_stream_structure
argument_list|(
name|tree_struct
argument_list|,
name|create_bytes_stream_body
argument_list|(
name|root
argument_list|)
argument_list|,
name|root
operator|->
name|first_int_stream
argument_list|)
expr_stmt|;
comment|/* read sub-stream data from disk, unzip it and buffer it */
for|for
control|(
name|int_stream
operator|=
name|root
operator|->
name|first_int_stream
init|;
name|int_stream
condition|;
name|int_stream
operator|=
operator|(
operator|(
name|packed_int_private_t
operator|*
operator|)
name|int_stream
operator|->
name|private_data
operator|)
operator|->
name|next
control|)
block|{
name|apr_size_t
name|offset
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_stream_data
argument_list|(
name|stream
argument_list|,
name|packed_int_stream_length
argument_list|(
name|int_stream
argument_list|)
argument_list|,
name|uncompressed
argument_list|,
name|compressed
argument_list|)
argument_list|)
expr_stmt|;
name|unflatten_int_stream
argument_list|(
name|int_stream
argument_list|,
name|uncompressed
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|byte_stream
operator|=
name|root
operator|->
name|first_byte_stream
init|;
name|byte_stream
condition|;
name|byte_stream
operator|=
name|byte_stream
operator|->
name|next
control|)
block|{
name|apr_size_t
name|offset
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_stream_data
argument_list|(
name|stream
argument_list|,
name|packed_byte_stream_length
argument_list|(
name|byte_stream
argument_list|)
argument_list|,
name|uncompressed
argument_list|,
name|compressed
argument_list|)
argument_list|)
expr_stmt|;
name|unflatten_byte_stream
argument_list|(
name|byte_stream
argument_list|,
name|uncompressed
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
block|}
operator|*
name|root_p
operator|=
name|root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

