begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * opt.c :  option and argument parsing for Subversion command lines  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_opt_private.h"
end_include

begin_include
include|#
directive|include
file|"opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_function
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|svn_opt_get_canonical_subcommand2
parameter_list|(
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd_name
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cmd_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|table
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|table
operator|+
name|i
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
name|SVN_OPT_MAX_ALIASES
operator|)
operator|&&
name|table
index|[
name|i
index|]
operator|.
name|aliases
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|aliases
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|table
operator|+
name|i
return|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* If we get here, there was no matching subcommand name or alias. */
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|apr_getopt_option_t
modifier|*
name|svn_opt_get_option_from_code2
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|apr_getopt_option_t
modifier|*
name|option_table
parameter_list|,
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|command
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|option_table
index|[
name|i
index|]
operator|.
name|optch
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|option_table
index|[
name|i
index|]
operator|.
name|optch
operator|==
name|code
condition|)
block|{
if|if
condition|(
name|command
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|j
operator|<
name|SVN_OPT_MAX_OPTIONS
operator|)
operator|&&
name|command
operator|->
name|desc_overrides
index|[
name|j
index|]
operator|.
name|optch
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|command
operator|->
name|desc_overrides
index|[
name|j
index|]
operator|.
name|optch
operator|==
name|code
condition|)
block|{
name|apr_getopt_option_t
modifier|*
name|tmpopt
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmpopt
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|tmpopt
operator|=
name|option_table
index|[
name|i
index|]
expr_stmt|;
name|tmpopt
operator|->
name|description
operator|=
name|command
operator|->
name|desc_overrides
index|[
name|j
index|]
operator|.
name|desc
expr_stmt|;
return|return
name|tmpopt
return|;
block|}
block|}
return|return
operator|&
operator|(
name|option_table
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|apr_getopt_option_t
modifier|*
name|svn_opt_get_option_from_code
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|apr_getopt_option_t
modifier|*
name|option_table
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|option_table
index|[
name|i
index|]
operator|.
name|optch
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|option_table
index|[
name|i
index|]
operator|.
name|optch
operator|==
name|code
condition|)
return|return
operator|&
operator|(
name|option_table
index|[
name|i
index|]
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Like svn_opt_get_option_from_code2(), but also, if CODE appears a second  * time in OPTION_TABLE with a different name, then set *LONG_ALIAS to that  * second name, else set it to NULL. */
end_comment

begin_function
specifier|static
specifier|const
name|apr_getopt_option_t
modifier|*
name|get_option_from_code
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|long_alias
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|apr_getopt_option_t
modifier|*
name|option_table
parameter_list|,
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|command
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|apr_getopt_option_t
modifier|*
name|i
decl_stmt|;
specifier|const
name|apr_getopt_option_t
modifier|*
name|opt
init|=
name|svn_opt_get_option_from_code2
argument_list|(
name|code
argument_list|,
name|option_table
argument_list|,
name|command
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* Find a long alias in the table, if there is one. */
operator|*
name|long_alias
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|option_table
init|;
name|i
operator|->
name|optch
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|->
name|optch
operator|==
name|code
operator|&&
name|i
operator|->
name|name
operator|!=
name|opt
operator|->
name|name
condition|)
block|{
operator|*
name|long_alias
operator|=
name|i
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
return|return
name|opt
return|;
block|}
end_function

begin_comment
comment|/* Print an option OPT nicely into a STRING allocated in POOL.  * If OPT has a single-character short form, then print OPT->name (if not  * NULL) as an alias, else print LONG_ALIAS (if not NULL) as an alias.  * If DOC is set, include the generic documentation string of OPT,  * localized to the current locale if a translation is available.  */
end_comment

begin_function
specifier|static
name|void
name|format_option
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|string
parameter_list|,
specifier|const
name|apr_getopt_option_t
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|long_alias
parameter_list|,
name|svn_boolean_t
name|doc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|opts
decl_stmt|;
if|if
condition|(
name|opt
operator|==
name|NULL
condition|)
block|{
operator|*
name|string
operator|=
literal|"?"
expr_stmt|;
return|return;
block|}
comment|/* We have a valid option which may or may not have a "short      name" (a single-character alias for the long option). */
if|if
condition|(
name|opt
operator|->
name|optch
operator|<=
literal|255
condition|)
name|opts
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"-%c [--%s]"
argument_list|,
name|opt
operator|->
name|optch
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|long_alias
condition|)
name|opts
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"--%s [--%s]"
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|long_alias
argument_list|)
expr_stmt|;
else|else
name|opts
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"--%s"
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|has_arg
condition|)
name|opts
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|opts
argument_list|,
name|_
argument_list|(
literal|" ARG"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
condition|)
name|opts
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%-24s : %s"
argument_list|,
name|opts
argument_list|,
name|_
argument_list|(
name|opt
operator|->
name|description
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|string
operator|=
name|opts
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_opt_format_option
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|string
parameter_list|,
specifier|const
name|apr_getopt_option_t
modifier|*
name|opt
parameter_list|,
name|svn_boolean_t
name|doc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|format_option
argument_list|(
name|string
argument_list|,
name|opt
argument_list|,
name|NULL
argument_list|,
name|doc
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_opt_subcommand_takes_option3
parameter_list|(
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|command
parameter_list|,
name|int
name|option_code
parameter_list|,
specifier|const
name|int
modifier|*
name|global_options
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_OPT_MAX_OPTIONS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|command
operator|->
name|valid_options
index|[
name|i
index|]
operator|==
name|option_code
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|global_options
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|global_options
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_options
index|[
name|i
index|]
operator|==
name|option_code
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_opt_subcommand_takes_option2
parameter_list|(
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|command
parameter_list|,
name|int
name|option_code
parameter_list|)
block|{
return|return
name|svn_opt_subcommand_takes_option3
argument_list|(
name|command
argument_list|,
name|option_code
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_opt_subcommand_takes_option
parameter_list|(
specifier|const
name|svn_opt_subcommand_desc_t
modifier|*
name|command
parameter_list|,
name|int
name|option_code
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_OPT_MAX_OPTIONS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|command
operator|->
name|valid_options
index|[
name|i
index|]
operator|==
name|option_code
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Print the canonical command name for CMD, and all its aliases, to    STREAM.  If HELP is set, print CMD's help string too, in which case    obtain option usage from OPTIONS_TABLE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|print_command_info2
parameter_list|(
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|cmd
parameter_list|,
specifier|const
name|apr_getopt_option_t
modifier|*
name|options_table
parameter_list|,
specifier|const
name|int
modifier|*
name|global_options
parameter_list|,
name|svn_boolean_t
name|help
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|svn_boolean_t
name|first_time
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
comment|/* Print the canonical command name. */
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|cmd
operator|->
name|name
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print the list of aliases. */
name|first_time
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_OPT_MAX_ALIASES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|->
name|aliases
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|first_time
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|" ("
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|cmd
operator|->
name|aliases
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first_time
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|help
condition|)
block|{
specifier|const
name|apr_getopt_option_t
modifier|*
name|option
decl_stmt|;
specifier|const
name|char
modifier|*
name|long_alias
decl_stmt|;
name|svn_boolean_t
name|have_options
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|": %s"
argument_list|,
name|_
argument_list|(
name|cmd
operator|->
name|help
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop over all valid option codes attached to the subcommand */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_OPT_MAX_OPTIONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|->
name|valid_options
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|have_options
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"\nValid options:\n"
argument_list|)
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|have_options
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* convert each option code into an option */
name|option
operator|=
name|get_option_from_code
argument_list|(
operator|&
name|long_alias
argument_list|,
name|cmd
operator|->
name|valid_options
index|[
name|i
index|]
argument_list|,
name|options_table
argument_list|,
name|cmd
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* print the option's docstring */
if|if
condition|(
name|option
operator|&&
name|option
operator|->
name|description
condition|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
name|format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|option
argument_list|,
name|long_alias
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"  %s\n"
argument_list|,
name|optstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* And global options too */
if|if
condition|(
name|global_options
operator|&&
operator|*
name|global_options
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"\nGlobal options:\n"
argument_list|)
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|have_options
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|global_options
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* convert each option code into an option */
name|option
operator|=
name|get_option_from_code
argument_list|(
operator|&
name|long_alias
argument_list|,
name|global_options
index|[
name|i
index|]
argument_list|,
name|options_table
argument_list|,
name|cmd
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* print the option's docstring */
if|if
condition|(
name|option
operator|&&
name|option
operator|->
name|description
condition|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
name|format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|option
argument_list|,
name|long_alias
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"  %s\n"
argument_list|,
name|optstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|have_options
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_opt_print_generic_help2
parameter_list|(
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|cmd_table
parameter_list|,
specifier|const
name|apr_getopt_option_t
modifier|*
name|opt_table
parameter_list|,
specifier|const
name|char
modifier|*
name|footer
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|header
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|svn_cmdline_fputs
argument_list|(
name|header
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
goto|goto
name|print_error
goto|;
while|while
condition|(
name|cmd_table
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|svn_cmdline_fputs
argument_list|(
literal|"   "
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
operator|)
operator|||
operator|(
name|err
operator|=
name|print_command_info2
argument_list|(
name|cmd_table
operator|+
name|i
argument_list|,
name|opt_table
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|stream
argument_list|)
operator|)
operator|||
operator|(
name|err
operator|=
name|svn_cmdline_fputs
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
goto|goto
name|print_error
goto|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|svn_cmdline_fputs
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
goto|goto
name|print_error
goto|;
if|if
condition|(
name|footer
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|svn_cmdline_fputs
argument_list|(
name|footer
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
goto|goto
name|print_error
goto|;
return|return;
name|print_error
label|:
comment|/* Issue #3014:    * Don't print anything on broken pipes. The pipe was likely    * closed by the process at the other end. We expect that    * process to perform error reporting as necessary.    *    * ### This assumes that there is only one error in a chain for    * ### SVN_ERR_IO_PIPE_WRITE_ERROR. See svn_cmdline_fputs(). */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_IO_PIPE_WRITE_ERROR
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_opt_subcommand_help3
parameter_list|(
specifier|const
name|char
modifier|*
name|subcommand
parameter_list|,
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|table
parameter_list|,
specifier|const
name|apr_getopt_option_t
modifier|*
name|options_table
parameter_list|,
specifier|const
name|int
modifier|*
name|global_options
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|cmd
init|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|table
argument_list|,
name|subcommand
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|cmd
condition|)
name|err
operator|=
name|print_command_info2
argument_list|(
name|cmd
argument_list|,
name|options_table
argument_list|,
name|global_options
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"\"%s\": unknown command.\n\n"
argument_list|)
argument_list|,
name|subcommand
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Issue #3014: Don't print anything on broken pipes. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_IO_PIPE_WRITE_ERROR
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Parsing revision and date options. ***/
end_comment

begin_escape
end_escape

begin_comment
comment|/** Parsing "X:Y"-style arguments. **/
end_comment

begin_comment
comment|/* If WORD matches one of the special revision descriptors,  * case-insensitively, set *REVISION accordingly:  *  *   - For "head", set REVISION->kind to svn_opt_revision_head.  *  *   - For "prev", set REVISION->kind to svn_opt_revision_previous.  *  *   - For "base", set REVISION->kind to svn_opt_revision_base.  *  *   - For "committed", set REVISION->kind to svn_opt_revision_committed.  *  * If match, return 0, else return -1 and don't touch REVISION.  */
end_comment

begin_function
specifier|static
name|int
name|revision_from_word
parameter_list|(
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"head"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|revision
operator|->
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"prev"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|revision
operator|->
name|kind
operator|=
name|svn_opt_revision_previous
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"base"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|revision
operator|->
name|kind
operator|=
name|svn_opt_revision_base
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svn_cstring_casecmp
argument_list|(
name|word
argument_list|,
literal|"committed"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|revision
operator|->
name|kind
operator|=
name|svn_opt_revision_committed
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse one revision specification.  Return pointer to character    after revision, or NULL if the revision is invalid.  Modifies    str, so make sure to pass a copy of anything precious.  Uses    POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_one_rev
parameter_list|(
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|,
name|save
decl_stmt|;
comment|/* Allow any number of 'r's to prefix a revision number, because      that way if a script pastes svn output into another svn command      (like "svn log -r${REV_COPIED_FROM_OUTPUT}"), it'll Just Work,      even when compounded.       As it happens, none of our special revision words begins with      "r".  If any ever do, then this code will have to get smarter.       Incidentally, this allows "r{DATE}".  We could avoid that with      some trivial code rearrangement, but it's not clear what would      be gained by doing so. */
while|while
condition|(
operator|*
name|str
operator|==
literal|'r'
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'{'
condition|)
block|{
name|svn_boolean_t
name|matched
decl_stmt|;
name|apr_time_t
name|tm
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Brackets denote a date. */
name|str
operator|++
expr_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
return|return
name|NULL
return|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|svn_parse_date
argument_list|(
operator|&
name|matched
argument_list|,
operator|&
name|tm
argument_list|,
name|str
argument_list|,
name|apr_time_now
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
return|return
name|NULL
return|;
name|revision
operator|->
name|kind
operator|=
name|svn_opt_revision_date
expr_stmt|;
name|revision
operator|->
name|value
operator|.
name|date
operator|=
name|tm
expr_stmt|;
return|return
name|end
operator|+
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|svn_ctype_isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
comment|/* It's a number. */
name|end
operator|=
name|str
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|svn_ctype_isdigit
argument_list|(
operator|*
name|end
argument_list|)
condition|)
name|end
operator|++
expr_stmt|;
name|save
operator|=
operator|*
name|end
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|revision
operator|->
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|revision
operator|->
name|value
operator|.
name|number
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|save
expr_stmt|;
return|return
name|end
return|;
block|}
elseif|else
if|if
condition|(
name|svn_ctype_isalpha
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|end
operator|=
name|str
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|svn_ctype_isalpha
argument_list|(
operator|*
name|end
argument_list|)
condition|)
name|end
operator|++
expr_stmt|;
name|save
operator|=
operator|*
name|end
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|revision_from_word
argument_list|(
name|revision
argument_list|,
name|str
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
operator|*
name|end
operator|=
name|save
expr_stmt|;
return|return
name|end
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|svn_opt_parse_revision
parameter_list|(
name|svn_opt_revision_t
modifier|*
name|start_revision
parameter_list|,
name|svn_opt_revision_t
modifier|*
name|end_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|left_rev
decl_stmt|,
modifier|*
name|right_rev
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* Operate on a copy of the argument. */
name|left_rev
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|right_rev
operator|=
name|parse_one_rev
argument_list|(
name|start_revision
argument_list|,
name|left_rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|right_rev
operator|&&
operator|*
name|right_rev
operator|==
literal|':'
condition|)
block|{
name|right_rev
operator|++
expr_stmt|;
name|end
operator|=
name|parse_one_rev
argument_list|(
name|end_revision
argument_list|,
name|right_rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|right_rev
operator|||
operator|*
name|right_rev
operator|!=
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svn_opt_parse_revision_to_range
parameter_list|(
name|apr_array_header_t
modifier|*
name|opt_ranges
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_opt_revision_range_t
modifier|*
name|range
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|range
argument_list|)
argument_list|)
decl_stmt|;
name|range
operator|->
name|start
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|range
operator|->
name|end
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
if|if
condition|(
name|svn_opt_parse_revision
argument_list|(
operator|&
operator|(
name|range
operator|->
name|start
operator|)
argument_list|,
operator|&
operator|(
name|range
operator|->
name|end
operator|)
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|APR_ARRAY_PUSH
argument_list|(
name|opt_ranges
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
operator|=
name|range
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt_resolve_revisions
parameter_list|(
name|svn_opt_revision_t
modifier|*
name|peg_rev
parameter_list|,
name|svn_opt_revision_t
modifier|*
name|op_rev
parameter_list|,
name|svn_boolean_t
name|is_url
parameter_list|,
name|svn_boolean_t
name|notice_local_mods
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|peg_rev
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
block|{
if|if
condition|(
name|is_url
condition|)
block|{
name|peg_rev
operator|->
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|notice_local_mods
condition|)
name|peg_rev
operator|->
name|kind
operator|=
name|svn_opt_revision_working
expr_stmt|;
else|else
name|peg_rev
operator|->
name|kind
operator|=
name|svn_opt_revision_base
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op_rev
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
operator|*
name|op_rev
operator|=
operator|*
name|peg_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_opt__revision_to_string
parameter_list|(
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
switch|switch
condition|(
name|revision
operator|->
name|kind
condition|)
block|{
case|case
name|svn_opt_revision_unspecified
case|:
return|return
literal|"unspecified"
return|;
case|case
name|svn_opt_revision_number
case|:
return|return
name|apr_psprintf
argument_list|(
name|result_pool
argument_list|,
literal|"%ld"
argument_list|,
name|revision
operator|->
name|value
operator|.
name|number
argument_list|)
return|;
case|case
name|svn_opt_revision_date
case|:
comment|/* ### svn_time_to_human_cstring()? */
return|return
name|svn_time_to_cstring
argument_list|(
name|revision
operator|->
name|value
operator|.
name|date
argument_list|,
name|result_pool
argument_list|)
return|;
case|case
name|svn_opt_revision_committed
case|:
return|return
literal|"committed"
return|;
case|case
name|svn_opt_revision_previous
case|:
return|return
literal|"previous"
return|;
case|case
name|svn_opt_revision_base
case|:
return|return
literal|"base"
return|;
case|case
name|svn_opt_revision_working
case|:
return|return
literal|"working"
return|;
case|case
name|svn_opt_revision_head
case|:
return|return
literal|"head"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|svn_opt_revision_range_t
modifier|*
name|svn_opt__revision_range_create
parameter_list|(
specifier|const
name|svn_opt_revision_t
modifier|*
name|start_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|end_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_opt_revision_range_t
modifier|*
name|range
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|range
argument_list|)
argument_list|)
decl_stmt|;
name|range
operator|->
name|start
operator|=
operator|*
name|start_revision
expr_stmt|;
name|range
operator|->
name|end
operator|=
operator|*
name|end_revision
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_function
name|svn_opt_revision_range_t
modifier|*
name|svn_opt__revision_range_from_revnums
parameter_list|(
name|svn_revnum_t
name|start_revnum
parameter_list|,
name|svn_revnum_t
name|end_revnum
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_opt_revision_range_t
modifier|*
name|range
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|range
argument_list|)
argument_list|)
decl_stmt|;
name|range
operator|->
name|start
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|range
operator|->
name|start
operator|.
name|value
operator|.
name|number
operator|=
name|start_revnum
expr_stmt|;
name|range
operator|->
name|end
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|range
operator|->
name|end
operator|.
name|value
operator|.
name|number
operator|=
name|end_revnum
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Parsing arguments. ***/
end_comment

begin_define
define|#
directive|define
name|DEFAULT_ARRAY_SIZE
value|5
end_define

begin_comment
comment|/* Copy STR into POOL and push the copy onto ARRAY. */
end_comment

begin_function
specifier|static
name|void
name|array_push_str
parameter_list|(
name|apr_array_header_t
modifier|*
name|array
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* ### Not sure if this function is still necessary.  It used to      convert str to svn_stringbuf_t * and push it, but now it just      dups str in pool and pushes the copy.  So its only effect is      transfer str's lifetime to pool.  Is that something callers are      depending on? */
name|APR_ARRAY_PUSH
argument_list|(
name|array
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_opt_push_implicit_dot_target
parameter_list|(
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|0
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
literal|""
expr_stmt|;
comment|/* Ha! "", not ".", is the canonical */
name|assert
argument_list|(
name|targets
operator|->
name|nelts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt_parse_num_args
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|args_p
parameter_list|,
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|int
name|num_args
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|args
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|DEFAULT_ARRAY_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* loop for num_args and add each arg to the args array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|array_push_str
argument_list|(
name|args
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|args_p
operator|=
name|args
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt_parse_all_args
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|args_p
parameter_list|,
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|args
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|DEFAULT_ARRAY_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|ind
operator|>
name|os
operator|->
name|argc
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
while|while
condition|(
name|os
operator|->
name|ind
operator|<
name|os
operator|->
name|argc
condition|)
block|{
name|array_push_str
argument_list|(
name|args
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|args_p
operator|=
name|args
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt_parse_path
parameter_list|(
name|svn_opt_revision_t
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|truepath
parameter_list|,
specifier|const
name|char
modifier|*
name|path
comment|/* UTF-8! */
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|peg_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt__split_arg_at_peg_revision
argument_list|(
name|truepath
argument_list|,
operator|&
name|peg_rev
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse the peg revision, if one was found */
if|if
condition|(
name|strlen
argument_list|(
name|peg_rev
argument_list|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|svn_opt_revision_t
name|start_revision
decl_stmt|,
name|end_revision
decl_stmt|;
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
if|if
condition|(
name|peg_rev
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* looking at empty peg revision */
block|{
name|ret
operator|=
literal|0
expr_stmt|;
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|start_revision
operator|.
name|value
operator|.
name|number
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* looking at non-empty peg revision */
block|{
specifier|const
name|char
modifier|*
name|rev_str
init|=
operator|&
name|peg_rev
index|[
literal|1
index|]
decl_stmt|;
comment|/* URLs get treated differently from wc paths. */
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|/* URLs are URI-encoded, so we look for dates with                  URI-encoded delimeters.  */
name|size_t
name|rev_len
init|=
name|strlen
argument_list|(
name|rev_str
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev_len
operator|>
literal|6
operator|&&
name|rev_str
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|rev_str
index|[
literal|1
index|]
operator|==
literal|'7'
operator|&&
operator|(
name|rev_str
index|[
literal|2
index|]
operator|==
literal|'B'
operator|||
name|rev_str
index|[
literal|2
index|]
operator|==
literal|'b'
operator|)
operator|&&
name|rev_str
index|[
name|rev_len
operator|-
literal|3
index|]
operator|==
literal|'%'
operator|&&
name|rev_str
index|[
name|rev_len
operator|-
literal|2
index|]
operator|==
literal|'7'
operator|&&
operator|(
name|rev_str
index|[
name|rev_len
operator|-
literal|1
index|]
operator|==
literal|'D'
operator|||
name|rev_str
index|[
name|rev_len
operator|-
literal|1
index|]
operator|==
literal|'d'
operator|)
condition|)
block|{
name|rev_str
operator|=
name|svn_path_uri_decode
argument_list|(
name|rev_str
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|svn_opt_parse_revision
argument_list|(
operator|&
name|start_revision
argument_list|,
operator|&
name|end_revision
argument_list|,
name|rev_str
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|||
name|end_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
block|{
comment|/* If an svn+ssh URL was used and it contains only one @,            * provide an error message that presents a possible solution            * to the parsing error (issue #2349). */
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
literal|"svn+ssh://"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|at
decl_stmt|;
name|at
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|&&
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
operator|==
name|at
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Syntax error parsing peg revision "
literal|"'%s'; did you mean '%s@'?"
argument_list|)
argument_list|,
operator|&
name|peg_rev
index|[
literal|1
index|]
argument_list|,
name|path
argument_list|)
return|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Syntax error parsing peg revision '%s'"
argument_list|)
argument_list|,
operator|&
name|peg_rev
index|[
literal|1
index|]
argument_list|)
return|;
block|}
name|rev
operator|->
name|kind
operator|=
name|start_revision
operator|.
name|kind
expr_stmt|;
name|rev
operator|->
name|value
operator|=
name|start_revision
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Didn't find a peg revision. */
name|rev
operator|->
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Note: This is substantially copied into svn_client_args_to_target_array() in  * order to move to libsvn_client while maintaining backward compatibility. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_opt__args_to_target_array
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|targets_p
parameter_list|,
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|known_targets
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_array_header_t
modifier|*
name|input_targets
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|DEFAULT_ARRAY_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|output_targets
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|DEFAULT_ARRAY_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Step 1:  create a master array of targets that are in UTF-8      encoding, and come from concatenating the targets left by apr_getopt,      plus any extra targets (e.g., from the --targets switch.) */
for|for
control|(
init|;
name|os
operator|->
name|ind
operator|<
name|os
operator|->
name|argc
condition|;
name|os
operator|->
name|ind
operator|++
control|)
block|{
comment|/* The apr_getopt targets are still in native encoding. */
specifier|const
name|char
modifier|*
name|raw_target
init|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
index|]
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|apr_array_push
argument_list|(
name|input_targets
argument_list|)
argument_list|,
name|raw_target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|known_targets
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|known_targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* The --targets array have already been converted to UTF-8,              because we needed to split up the list with svn_cstring_split. */
specifier|const
name|char
modifier|*
name|utf8_target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|known_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|input_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|utf8_target
expr_stmt|;
block|}
block|}
comment|/* Step 2:  process each target.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|input_targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|utf8_target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|input_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|true_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
comment|/* after all processing is finished */
specifier|const
name|char
modifier|*
name|peg_rev
decl_stmt|;
comment|/*        * This is needed so that the target can be properly canonicalized,        * otherwise the canonicalization does not treat a ".@BASE" as a "."        * with a BASE peg revision, and it is not canonicalized to "@BASE".        * If any peg revision exists, it is appended to the final        * canonicalized path or URL.  Do not use svn_opt_parse_path()        * because the resulting peg revision is a structure that would have        * to be converted back into a string.  Converting from a string date        * to the apr_time_t field in the svn_opt_revision_value_t and back to        * a string would not necessarily preserve the exact bytes of the        * input date, so its easier just to keep it in string form.        */
name|SVN_ERR
argument_list|(
name|svn_opt__split_arg_at_peg_revision
argument_list|(
operator|&
name|true_target
argument_list|,
operator|&
name|peg_rev
argument_list|,
name|utf8_target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* URLs and wc-paths get treated differently. */
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|true_target
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_opt__arg_canonicalize_url
argument_list|(
operator|&
name|true_target
argument_list|,
name|true_target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* not a url, so treat as a path */
block|{
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt__arg_canonicalize_path
argument_list|(
operator|&
name|true_target
argument_list|,
name|true_target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the target has the same name as a Subversion              working copy administrative dir, skip it. */
name|base_name
operator|=
name|svn_dirent_basename
argument_list|(
name|true_target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* FIXME:              The canonical list of administrative directory names is              maintained in libsvn_wc/adm_files.c:svn_wc_set_adm_dir().              That list can't be used here, because that use would              create a circular dependency between libsvn_wc and              libsvn_subr.  Make sure changes to the lists are always              synchronized! */
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|base_name
argument_list|,
literal|".svn"
argument_list|)
operator|||
literal|0
operator|==
name|strcmp
argument_list|(
name|base_name
argument_list|,
literal|"_svn"
argument_list|)
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_RESERVED_FILENAME_SPECIFIED
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"'%s' ends in a reserved name"
argument_list|)
argument_list|,
name|utf8_target
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|target
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|true_target
argument_list|,
name|peg_rev
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|output_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|target
expr_stmt|;
block|}
comment|/* kff todo: need to remove redundancies from targets before      passing it to the cmd_func. */
operator|*
name|targets_p
operator|=
name|output_targets
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt_parse_revprop
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|revprop_table_p
parameter_list|,
specifier|const
name|char
modifier|*
name|revprop_spec
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sep
decl_stmt|,
modifier|*
name|propname
decl_stmt|;
name|svn_string_t
modifier|*
name|propval
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|revprop_spec
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision property pair is empty"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|*
name|revprop_table_p
condition|)
operator|*
name|revprop_table_p
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|sep
operator|=
name|strchr
argument_list|(
name|revprop_spec
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
block|{
name|propname
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|revprop_spec
argument_list|,
name|sep
operator|-
name|revprop_spec
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|propname
argument_list|,
name|propname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|propval
operator|=
name|svn_string_create
argument_list|(
name|sep
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|propname
argument_list|,
name|revprop_spec
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|propval
operator|=
name|svn_string_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svn_prop_name_is_valid
argument_list|(
name|propname
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid Subversion property name"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
name|svn_hash_sets
argument_list|(
operator|*
name|revprop_table_p
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt__split_arg_at_peg_revision
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|true_target
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|utf8_target
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|peg_start
init|=
name|NULL
decl_stmt|;
comment|/* pointer to the peg revision, if any */
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
operator|(
name|utf8_target
operator|+
name|strlen
argument_list|(
name|utf8_target
argument_list|)
operator|-
literal|1
operator|)
init|;
name|ptr
operator|>=
name|utf8_target
condition|;
operator|--
name|ptr
control|)
block|{
comment|/* If we hit a path separator, stop looking.  This is OK           only because our revision specifiers can't contain '/'. */
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'@'
condition|)
block|{
name|peg_start
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|peg_start
condition|)
block|{
comment|/* Error out if target is the empty string. */
if|if
condition|(
name|ptr
operator|==
name|utf8_target
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_FILENAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is just a peg revision. "
literal|"Maybe try '%s@' instead?"
argument_list|)
argument_list|,
name|utf8_target
argument_list|,
name|utf8_target
argument_list|)
return|;
operator|*
name|true_target
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|utf8_target
argument_list|,
name|ptr
operator|-
name|utf8_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|peg_revision
condition|)
operator|*
name|peg_revision
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|peg_start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|true_target
operator|=
name|utf8_target
expr_stmt|;
if|if
condition|(
name|peg_revision
condition|)
operator|*
name|peg_revision
operator|=
literal|""
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt__arg_canonicalize_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|url_out
parameter_list|,
specifier|const
name|char
modifier|*
name|url_in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
comment|/* Convert to URI. */
name|target
operator|=
name|svn_path_uri_from_iri
argument_list|(
name|url_in
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Auto-escape some ASCII characters. */
name|target
operator|=
name|svn_path_uri_autoescape
argument_list|(
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|#
directive|if
literal|'/'
operator|!=
name|SVN_PATH_LOCAL_SEPARATOR
comment|/* Allow using file:///C:\users\me/repos on Windows, like we did in 1.6 */
if|if
condition|(
name|strchr
argument_list|(
name|target
argument_list|,
name|SVN_PATH_LOCAL_SEPARATOR
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|target
operator|=
name|p
expr_stmt|;
comment|/* Convert all local-style separators to the canonical ones. */
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|SVN_PATH_LOCAL_SEPARATOR
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Verify that no backpaths are present in the URL. */
if|if
condition|(
name|svn_path_is_backpath_present
argument_list|(
name|target
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"URL '%s' contains a '..' element"
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
comment|/* Strip any trailing '/' and collapse other redundant elements. */
name|target
operator|=
name|svn_uri_canonicalize
argument_list|(
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|url_out
operator|=
name|target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt__arg_canonicalize_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path_out
parameter_list|,
specifier|const
name|char
modifier|*
name|path_in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|apr_target
decl_stmt|;
name|char
modifier|*
name|truenamed_target
decl_stmt|;
comment|/* APR-encoded */
name|apr_status_t
name|apr_err
decl_stmt|;
comment|/* canonicalize case, and change all separators to '/'. */
name|SVN_ERR
argument_list|(
name|svn_path_cstring_from_utf8
argument_list|(
operator|&
name|apr_target
argument_list|,
name|path_in
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_filepath_merge
argument_list|(
operator|&
name|truenamed_target
argument_list|,
literal|""
argument_list|,
name|apr_target
argument_list|,
name|APR_FILEPATH_TRUENAME
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apr_err
condition|)
comment|/* We have a canonicalized APR-encoded target now. */
name|apr_target
operator|=
name|truenamed_target
expr_stmt|;
elseif|else
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|apr_err
argument_list|)
condition|)
comment|/* It's okay for the file to not exist, that just means we        have to accept the case given to the client. We'll use        the original APR-encoded target. */
empty_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error resolving case of '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path_in
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* convert back to UTF-8. */
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
name|path_out
argument_list|,
name|apr_target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|path_out
operator|=
name|svn_dirent_canonicalize
argument_list|(
operator|*
name|path_out
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt__print_version_info
parameter_list|(
specifier|const
name|char
modifier|*
name|pgm_name
parameter_list|,
specifier|const
name|char
modifier|*
name|footer
parameter_list|,
specifier|const
name|svn_version_extended_t
modifier|*
name|info
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
name|svn_boolean_t
name|verbose
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|quiet
condition|)
return|return
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|SVN_VER_NUMBER
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"%s, version %s\n"
literal|"   compiled %s, %s on %s\n\n"
argument_list|)
argument_list|,
name|pgm_name
argument_list|,
name|SVN_VERSION
argument_list|,
name|svn_version_ext_build_date
argument_list|(
name|info
argument_list|)
argument_list|,
name|svn_version_ext_build_time
argument_list|(
name|info
argument_list|)
argument_list|,
name|svn_version_ext_build_host
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|svn_version_ext_copyright
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|footer
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|footer
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|libs
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"System information:\n\n"
argument_list|)
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"* running on %s\n"
argument_list|)
argument_list|,
name|svn_version_ext_runtime_host
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_version_ext_runtime_osname
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"  - %s\n"
argument_list|)
argument_list|,
name|svn_version_ext_runtime_osname
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|libs
operator|=
name|svn_version_ext_linked_libs
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|libs
operator|&&
name|libs
operator|->
name|nelts
condition|)
block|{
specifier|const
name|svn_version_ext_linked_lib_t
modifier|*
name|lib
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"* linked dependencies:\n"
argument_list|)
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|libs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|lib
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|libs
argument_list|,
name|i
argument_list|,
name|svn_version_ext_linked_lib_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|lib
operator|->
name|runtime_version
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"  - %s %s (compiled with %s)\n"
argument_list|,
name|lib
operator|->
name|name
argument_list|,
name|lib
operator|->
name|runtime_version
argument_list|,
name|lib
operator|->
name|compiled_version
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"  - %s %s (static)\n"
argument_list|,
name|lib
operator|->
name|name
argument_list|,
name|lib
operator|->
name|compiled_version
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|libs
operator|=
name|svn_version_ext_loaded_libs
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|libs
operator|&&
name|libs
operator|->
name|nelts
condition|)
block|{
specifier|const
name|svn_version_ext_loaded_lib_t
modifier|*
name|lib
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"* loaded shared libraries:\n"
argument_list|)
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|libs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|lib
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|libs
argument_list|,
name|i
argument_list|,
name|svn_version_ext_loaded_lib_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|lib
operator|->
name|version
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"  - %s   (%s)\n"
argument_list|,
name|lib
operator|->
name|name
argument_list|,
name|lib
operator|->
name|version
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"  - %s\n"
argument_list|,
name|lib
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_opt_print_help4
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
specifier|const
name|char
modifier|*
name|pgm_name
parameter_list|,
name|svn_boolean_t
name|print_version
parameter_list|,
name|svn_boolean_t
name|quiet
parameter_list|,
name|svn_boolean_t
name|verbose
parameter_list|,
specifier|const
name|char
modifier|*
name|version_footer
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|cmd_table
parameter_list|,
specifier|const
name|apr_getopt_option_t
modifier|*
name|option_table
parameter_list|,
specifier|const
name|int
modifier|*
name|global_options
parameter_list|,
specifier|const
name|char
modifier|*
name|footer
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|targets
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|os
condition|)
name|SVN_ERR
argument_list|(
name|svn_opt_parse_all_args
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|&&
name|targets
operator|->
name|nelts
condition|)
comment|/* help on subcommand(s) requested */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_opt_subcommand_help3
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|cmd_table
argument_list|,
name|option_table
argument_list|,
name|global_options
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|print_version
condition|)
comment|/* just --version */
block|{
name|SVN_ERR
argument_list|(
name|svn_opt__print_version_info
argument_list|(
name|pgm_name
argument_list|,
name|version_footer
argument_list|,
name|svn_version_extended
argument_list|(
name|verbose
argument_list|,
name|pool
argument_list|)
argument_list|,
name|quiet
argument_list|,
name|verbose
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os
operator|&&
operator|!
name|targets
operator|->
name|nelts
condition|)
comment|/* `-h', `--help', or `help' */
name|svn_opt_print_generic_help2
argument_list|(
name|header
argument_list|,
name|cmd_table
argument_list|,
name|option_table
argument_list|,
name|footer
argument_list|,
name|pool
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
comment|/* unknown option or cmd */
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Type '%s help' for usage.\n"
argument_list|)
argument_list|,
name|pgm_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

