begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * crypto.c :  cryptographic routines  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"crypto.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_CRYPTO
end_ifdef

begin_include
include|#
directive|include
file|<apr_random.h>
end_include

begin_include
include|#
directive|include
file|<apr_crypto.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_HAVE_CRYPTO */
end_comment

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_comment
comment|/* 1000 iterations is the recommended minimum, per RFC 2898, section 4.2.  */
end_comment

begin_define
define|#
directive|define
name|NUM_ITERATIONS
value|1000
end_define

begin_comment
comment|/* Size (in bytes) of the random data we'll prepend to encrypted data. */
end_comment

begin_define
define|#
directive|define
name|RANDOM_PREFIX_LEN
value|4
end_define

begin_comment
comment|/* A structure for containing Subversion's cryptography-related bits    (so we can avoid passing around APR-isms outside this module). */
end_comment

begin_struct
struct|struct
name|svn_crypto__ctx_t
block|{
ifdef|#
directive|ifdef
name|SVN_HAVE_CRYPTO
name|apr_crypto_t
modifier|*
name|crypto
decl_stmt|;
comment|/* APR cryptography context. */
if|#
directive|if
literal|0
comment|/* ### For now, we will use apr_generate_random_bytes(). If we need      ### more strength, then we can set this member using      ### apr_random_standard_new(), then use      ### apr_generate_random_bytes() to generate entropy for seeding      ### apr_random_t. See httpd/server/core.c:ap_init_rng()  */
block|apr_random_t *rand;
endif|#
directive|endif
comment|/* 0 */
else|#
directive|else
comment|/* SVN_HAVE_CRYPTO */
name|int
name|unused_but_required_to_satisfy_c_compilers
decl_stmt|;
endif|#
directive|endif
comment|/* SVN_HAVE_CRYPTO */
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/*** Helper Functions ***/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_CRYPTO
end_ifdef

begin_comment
comment|/* One-time initialization of the cryptography subsystem. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|svn_atomic_t
name|crypto_init_state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CRYPTO_INIT
parameter_list|(
name|scratch_pool
parameter_list|)
define|\
value|SVN_ERR(svn_atomic__init_once(&crypto_init_state, \                                 crypto_init, NULL, (scratch_pool)))
end_define

begin_comment
comment|/* Initialize the APR cryptography subsystem (if available), using    ANY_POOL's ancestor root pool for the registration of cleanups,    shutdowns, etc.   */
end_comment

begin_comment
comment|/* Don't call this function directly!  Use svn_atomic__init_once(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|crypto_init
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|any_pool
parameter_list|)
block|{
comment|/* NOTE: this function will locate the topmost ancestor of ANY_POOL      for its cleanup handlers. We don't have to worry about ANY_POOL      being cleared.  */
name|apr_status_t
name|apr_err
init|=
name|apr_crypto_init
argument_list|(
name|any_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Failed to initialize cryptography "
literal|"subsystem"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If APU_ERR is non-NULL, create and return a Subversion error using    APR_ERR and APU_ERR. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|err_from_apu_err
parameter_list|(
name|apr_status_t
name|apr_err
parameter_list|,
specifier|const
name|apu_err_t
modifier|*
name|apu_err
parameter_list|)
block|{
if|if
condition|(
name|apu_err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"code (%d), reason (\"%s\"), msg (\"%s\")"
argument_list|)
argument_list|,
name|apu_err
operator|->
name|rc
argument_list|,
name|apu_err
operator|->
name|reason
condition|?
name|apu_err
operator|->
name|reason
else|:
literal|""
argument_list|,
name|apu_err
operator|->
name|msg
condition|?
name|apu_err
operator|->
name|msg
else|:
literal|""
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Generate a Subversion error which describes the state reflected by    APR_ERR and any crypto errors registered with CTX. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|crypto_error_create
parameter_list|(
name|svn_crypto__ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_status_t
name|apr_err
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|apu_err_t
modifier|*
name|apu_err
decl_stmt|;
name|apr_status_t
name|rv
init|=
name|apr_crypto_error
argument_list|(
operator|&
name|apu_err
argument_list|,
name|ctx
operator|->
name|crypto
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|child
decl_stmt|;
comment|/* Ugh. The APIs are a bit slippery, so be wary.  */
if|if
condition|(
name|apr_err
operator|==
name|APR_SUCCESS
condition|)
name|apr_err
operator|=
name|APR_EGENERAL
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|APR_SUCCESS
condition|)
name|child
operator|=
name|err_from_apu_err
argument_list|(
name|apr_err
argument_list|,
name|apu_err
argument_list|)
expr_stmt|;
else|else
name|child
operator|=
name|svn_error_wrap_apr
argument_list|(
name|rv
argument_list|,
name|_
argument_list|(
literal|"Fetching error from APR"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|child
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set RAND_BYTES to a block of bytes containing random data RAND_LEN    long and allocated from RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_random_bytes
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|rand_bytes
parameter_list|,
name|svn_crypto__ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_size_t
name|rand_len
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bytes
decl_stmt|;
name|bytes
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|rand_len
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_generate_random_bytes
argument_list|(
name|bytes
argument_list|,
name|rand_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error obtaining random data"
argument_list|)
argument_list|)
return|;
operator|*
name|rand_bytes
operator|=
name|bytes
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return an svn_string_t allocated from RESULT_POOL, with its .data    and .len members set to DATA and LEN, respective.     WARNING: No lifetime management of DATA is offered here, so you    probably want to ensure that that information is allocated in a    sufficiently long-lived pool (such as, for example, RESULT_POOL). */
end_comment

begin_function
specifier|static
specifier|const
name|svn_string_t
modifier|*
name|wrap_as_string
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|s
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|->
name|data
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
expr_stmt|;
comment|/* better already be in RESULT_POOL  */
name|s
operator|->
name|len
operator|=
name|len
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_HAVE_CRYPTO */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Semi-public APIs ***/
end_comment

begin_comment
comment|/* Return TRUE iff Subversion's cryptographic support is available. */
end_comment

begin_function
name|svn_boolean_t
name|svn_crypto__is_available
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_HAVE_CRYPTO
return|return
name|TRUE
return|;
else|#
directive|else
comment|/* SVN_HAVE_CRYPTO */
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/* SVN_HAVE_CRYPTO */
block|}
end_function

begin_comment
comment|/* Set CTX to a Subversion cryptography context allocated from    RESULT_POOL.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_crypto__context_create
parameter_list|(
name|svn_crypto__ctx_t
modifier|*
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_HAVE_CRYPTO
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|apu_err_t
modifier|*
name|apu_err
init|=
name|NULL
decl_stmt|;
name|apr_crypto_t
modifier|*
name|apr_crypto
decl_stmt|;
specifier|const
name|apr_crypto_driver_t
modifier|*
name|driver
decl_stmt|;
name|CRYPTO_INIT
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Load the crypto driver.       ### TODO: For the sake of flexibility, should we use      ### APU_CRYPTO_RECOMMENDED_DRIVER instead of hard coding      ### "openssl" here?       NOTE: Potential bugs in get_driver() imply we might get      APR_SUCCESS and NULL.  Sigh. Just be a little more careful in      error generation here.  */
name|apr_err
operator|=
name|apr_crypto_get_driver
argument_list|(
operator|&
name|driver
argument_list|,
literal|"openssl"
argument_list|,
name|NULL
argument_list|,
operator|&
name|apu_err
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|err_from_apu_err
argument_list|(
name|apr_err
argument_list|,
name|apu_err
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"OpenSSL crypto driver error"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|driver
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|err_from_apu_err
argument_list|(
name|APR_EGENERAL
argument_list|,
name|apu_err
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Bad return value while loading crypto "
literal|"driver"
argument_list|)
argument_list|)
return|;
name|apr_err
operator|=
name|apr_crypto_make
argument_list|(
operator|&
name|apr_crypto
argument_list|,
name|driver
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
operator|||
name|apr_crypto
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error creating OpenSSL crypto context"
argument_list|)
argument_list|)
return|;
comment|/* Allocate and initialize our crypto context. */
operator|*
name|ctx
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ctx
operator|)
operator|->
name|crypto
operator|=
name|apr_crypto
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
else|#
directive|else
comment|/* SVN_HAVE_CRYPTO */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
literal|"Cryptographic support is not available"
argument_list|)
return|;
endif|#
directive|endif
comment|/* SVN_HAVE_CRYPTO */
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_crypto__encrypt_password
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|ciphertext
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|iv
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|salt
parameter_list|,
name|svn_crypto__ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|master
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_HAVE_CRYPTO
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|salt_vector
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|iv_vector
decl_stmt|;
name|apr_size_t
name|iv_len
decl_stmt|;
name|apr_crypto_key_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|prefix
decl_stmt|;
name|apr_crypto_block_t
modifier|*
name|block_ctx
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|block_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|assembled
decl_stmt|;
name|apr_size_t
name|password_len
decl_stmt|,
name|assembled_len
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|result_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
decl_stmt|;
name|apr_size_t
name|ignored_result_len
init|=
literal|0
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Generate the salt. */
define|#
directive|define
name|SALT_LEN
value|8
name|SVN_ERR
argument_list|(
name|get_random_bytes
argument_list|(
operator|&
name|salt_vector
argument_list|,
name|ctx
argument_list|,
name|SALT_LEN
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the passphrase.  */
name|apr_err
operator|=
name|apr_crypto_passphrase
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|iv_len
argument_list|,
name|master
operator|->
name|data
argument_list|,
name|master
operator|->
name|len
argument_list|,
name|salt_vector
argument_list|,
name|SALT_LEN
argument_list|,
name|APR_KEY_AES_256
argument_list|,
name|APR_MODE_CBC
argument_list|,
name|FALSE
comment|/* doPad */
argument_list|,
name|NUM_ITERATIONS
argument_list|,
name|ctx
operator|->
name|crypto
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error creating derived key"
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error creating derived key"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|iv_len
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected IV length returned"
argument_list|)
argument_list|)
return|;
comment|/* Generate the proper length IV.  */
name|SVN_ERR
argument_list|(
name|get_random_bytes
argument_list|(
operator|&
name|iv_vector
argument_list|,
name|ctx
argument_list|,
name|iv_len
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize block encryption. */
name|apr_err
operator|=
name|apr_crypto_block_encrypt_init
argument_list|(
operator|&
name|block_ctx
argument_list|,
operator|&
name|iv_vector
argument_list|,
name|key
argument_list|,
operator|&
name|block_size
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|apr_err
operator|!=
name|APR_SUCCESS
operator|)
operator|||
operator|(
operator|!
name|block_ctx
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error initializing block encryption"
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Generate a 4-byte prefix. */
name|SVN_ERR
argument_list|(
name|get_random_bytes
argument_list|(
operator|&
name|prefix
argument_list|,
name|ctx
argument_list|,
name|RANDOM_PREFIX_LEN
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Combine our prefix, original password, and appropriate padding.      We won't bother padding if the prefix and password combined      perfectly align on the block boundary.  If they don't,      however, we'll drop a NUL byte after the password and pad with      random stuff after that to the block boundary. */
name|password_len
operator|=
name|strlen
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|assembled_len
operator|=
name|RANDOM_PREFIX_LEN
operator|+
name|password_len
expr_stmt|;
if|if
condition|(
operator|(
name|assembled_len
operator|%
name|block_size
operator|)
operator|==
literal|0
condition|)
block|{
name|assembled
operator|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|assembled_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|assembled
argument_list|,
name|prefix
argument_list|,
name|RANDOM_PREFIX_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|assembled
operator|+
name|RANDOM_PREFIX_LEN
argument_list|,
name|password
argument_list|,
name|password_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|padding
decl_stmt|;
name|apr_size_t
name|pad_len
init|=
name|block_size
operator|-
operator|(
name|assembled_len
operator|%
name|block_size
operator|)
operator|-
literal|1
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_random_bytes
argument_list|(
operator|&
name|padding
argument_list|,
name|ctx
argument_list|,
name|pad_len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|assembled_len
operator|=
name|assembled_len
operator|+
literal|1
operator|+
name|pad_len
expr_stmt|;
name|assembled
operator|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|assembled_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|assembled
argument_list|,
name|prefix
argument_list|,
name|RANDOM_PREFIX_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|assembled
operator|+
name|RANDOM_PREFIX_LEN
argument_list|,
name|password
argument_list|,
name|password_len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|assembled
operator|+
name|RANDOM_PREFIX_LEN
operator|+
name|password_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|memcpy
argument_list|(
name|assembled
operator|+
name|RANDOM_PREFIX_LEN
operator|+
name|password_len
operator|+
literal|1
argument_list|,
name|padding
argument_list|,
name|pad_len
argument_list|)
expr_stmt|;
block|}
comment|/* Get the length that we need to allocate.  */
name|apr_err
operator|=
name|apr_crypto_block_encrypt
argument_list|(
name|NULL
argument_list|,
operator|&
name|result_len
argument_list|,
name|assembled
argument_list|,
name|assembled_len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error fetching result length"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Allocate our result buffer.  */
name|result
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|result_len
argument_list|)
expr_stmt|;
comment|/* Encrypt the block. */
name|apr_err
operator|=
name|apr_crypto_block_encrypt
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|result_len
argument_list|,
name|assembled
argument_list|,
name|assembled_len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error during block encryption"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Finalize the block encryption. Since we padded everything, this should      not produce any more encrypted output.  */
name|apr_err
operator|=
name|apr_crypto_block_encrypt_finish
argument_list|(
name|NULL
argument_list|,
operator|&
name|ignored_result_len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error finalizing block encryption"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
operator|*
name|ciphertext
operator|=
name|wrap_as_string
argument_list|(
name|result
argument_list|,
name|result_len
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|iv
operator|=
name|wrap_as_string
argument_list|(
name|iv_vector
argument_list|,
name|iv_len
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|salt
operator|=
name|wrap_as_string
argument_list|(
name|salt_vector
argument_list|,
name|SALT_LEN
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|apr_crypto_block_cleanup
argument_list|(
name|block_ctx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
else|#
directive|else
comment|/* SVN_HAVE_CRYPTO */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
literal|"Cryptographic support is not available"
argument_list|)
return|;
endif|#
directive|endif
comment|/* SVN_HAVE_CRYPTO */
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_crypto__decrypt_password
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|plaintext
parameter_list|,
name|svn_crypto__ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|ciphertext
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|iv
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|salt
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|master
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_HAVE_CRYPTO
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_crypto_block_t
modifier|*
name|block_ctx
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|block_size
decl_stmt|,
name|iv_len
decl_stmt|;
name|apr_crypto_key_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
decl_stmt|;
name|apr_size_t
name|result_len
init|=
literal|0
decl_stmt|,
name|final_len
init|=
literal|0
decl_stmt|;
comment|/* Initialize the passphrase.  */
name|apr_err
operator|=
name|apr_crypto_passphrase
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|iv_len
argument_list|,
name|master
operator|->
name|data
argument_list|,
name|master
operator|->
name|len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|salt
operator|->
name|data
argument_list|,
name|salt
operator|->
name|len
argument_list|,
name|APR_KEY_AES_256
argument_list|,
name|APR_MODE_CBC
argument_list|,
name|FALSE
comment|/* doPad */
argument_list|,
name|NUM_ITERATIONS
argument_list|,
name|ctx
operator|->
name|crypto
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error creating derived key"
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error creating derived key"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|iv_len
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected IV length returned"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|iv_len
operator|!=
name|iv
operator|->
name|len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Provided IV has incorrect length"
argument_list|)
argument_list|)
return|;
name|apr_err
operator|=
name|apr_crypto_block_decrypt_init
argument_list|(
operator|&
name|block_ctx
argument_list|,
operator|&
name|block_size
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|iv
operator|->
name|data
argument_list|,
name|key
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|apr_err
operator|!=
name|APR_SUCCESS
operator|)
operator|||
operator|(
operator|!
name|block_ctx
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error initializing block decryption"
argument_list|)
argument_list|)
argument_list|)
return|;
name|apr_err
operator|=
name|apr_crypto_block_decrypt
argument_list|(
name|NULL
argument_list|,
operator|&
name|result_len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ciphertext
operator|->
name|data
argument_list|,
name|ciphertext
operator|->
name|len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error fetching result length"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|result_len
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_crypto_block_decrypt
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|result_len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ciphertext
operator|->
name|data
argument_list|,
name|ciphertext
operator|->
name|len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error during block decryption"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|apr_err
operator|=
name|apr_crypto_block_decrypt_finish
argument_list|(
name|result
operator|+
name|result_len
argument_list|,
operator|&
name|final_len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error finalizing block decryption"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Copy the non-random bits of the resulting plaintext, skipping the      prefix and ignoring any trailing padding. */
operator|*
name|plaintext
operator|=
name|apr_pstrndup
argument_list|(
name|result_pool
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|result
operator|+
name|RANDOM_PREFIX_LEN
operator|)
argument_list|,
name|result_len
operator|+
name|final_len
operator|-
name|RANDOM_PREFIX_LEN
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|apr_crypto_block_cleanup
argument_list|(
name|block_ctx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
else|#
directive|else
comment|/* SVN_HAVE_CRYPTO */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
literal|"Cryptographic support is not available"
argument_list|)
return|;
endif|#
directive|endif
comment|/* SVN_HAVE_CRYPTO */
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_crypto__generate_secret_checktext
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|ciphertext
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|iv
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|salt
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|checktext
parameter_list|,
name|svn_crypto__ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|master
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_HAVE_CRYPTO
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|salt_vector
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|iv_vector
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|stuff_vector
decl_stmt|;
name|apr_size_t
name|iv_len
decl_stmt|;
name|apr_crypto_key_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_crypto_block_t
modifier|*
name|block_ctx
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|block_size
decl_stmt|;
name|apr_size_t
name|result_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
decl_stmt|;
name|apr_size_t
name|ignored_result_len
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|stuff_len
decl_stmt|;
name|svn_checksum_t
modifier|*
name|stuff_sum
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Generate the salt. */
name|SVN_ERR
argument_list|(
name|get_random_bytes
argument_list|(
operator|&
name|salt_vector
argument_list|,
name|ctx
argument_list|,
name|SALT_LEN
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the passphrase.  */
name|apr_err
operator|=
name|apr_crypto_passphrase
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|iv_len
argument_list|,
name|master
operator|->
name|data
argument_list|,
name|master
operator|->
name|len
argument_list|,
name|salt_vector
argument_list|,
name|SALT_LEN
argument_list|,
name|APR_KEY_AES_256
argument_list|,
name|APR_MODE_CBC
argument_list|,
name|FALSE
comment|/* doPad */
argument_list|,
name|NUM_ITERATIONS
argument_list|,
name|ctx
operator|->
name|crypto
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error creating derived key"
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error creating derived key"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|iv_len
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected IV length returned"
argument_list|)
argument_list|)
return|;
comment|/* Generate the proper length IV.  */
name|SVN_ERR
argument_list|(
name|get_random_bytes
argument_list|(
operator|&
name|iv_vector
argument_list|,
name|ctx
argument_list|,
name|iv_len
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize block encryption. */
name|apr_err
operator|=
name|apr_crypto_block_encrypt_init
argument_list|(
operator|&
name|block_ctx
argument_list|,
operator|&
name|iv_vector
argument_list|,
name|key
argument_list|,
operator|&
name|block_size
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|apr_err
operator|!=
name|APR_SUCCESS
operator|)
operator|||
operator|(
operator|!
name|block_ctx
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error initializing block encryption"
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Generate a blob of random data, block-aligned per the      requirements of the encryption algorithm, but with a minimum size      of our choosing.  */
define|#
directive|define
name|MIN_STUFF_LEN
value|32
if|if
condition|(
name|MIN_STUFF_LEN
operator|%
name|block_size
condition|)
name|stuff_len
operator|=
name|MIN_STUFF_LEN
operator|+
operator|(
name|block_size
operator|-
operator|(
name|MIN_STUFF_LEN
operator|%
name|block_size
operator|)
operator|)
expr_stmt|;
else|else
name|stuff_len
operator|=
name|MIN_STUFF_LEN
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_random_bytes
argument_list|(
operator|&
name|stuff_vector
argument_list|,
name|ctx
argument_list|,
name|stuff_len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### FIXME:  This should be a SHA-256.  */
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|stuff_sum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|stuff_vector
argument_list|,
name|stuff_len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the length that we need to allocate.  */
name|apr_err
operator|=
name|apr_crypto_block_encrypt
argument_list|(
name|NULL
argument_list|,
operator|&
name|result_len
argument_list|,
name|stuff_vector
argument_list|,
name|stuff_len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error fetching result length"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Allocate our result buffer.  */
name|result
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|result_len
argument_list|)
expr_stmt|;
comment|/* Encrypt the block. */
name|apr_err
operator|=
name|apr_crypto_block_encrypt
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|result_len
argument_list|,
name|stuff_vector
argument_list|,
name|stuff_len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error during block encryption"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Finalize the block encryption. Since we padded everything, this should      not produce any more encrypted output.  */
name|apr_err
operator|=
name|apr_crypto_block_encrypt_finish
argument_list|(
name|NULL
argument_list|,
operator|&
name|ignored_result_len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error finalizing block encryption"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
operator|*
name|ciphertext
operator|=
name|wrap_as_string
argument_list|(
name|result
argument_list|,
name|result_len
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|iv
operator|=
name|wrap_as_string
argument_list|(
name|iv_vector
argument_list|,
name|iv_len
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|salt
operator|=
name|wrap_as_string
argument_list|(
name|salt_vector
argument_list|,
name|SALT_LEN
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|checktext
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|stuff_sum
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|apr_crypto_block_cleanup
argument_list|(
name|block_ctx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
else|#
directive|else
comment|/* SVN_HAVE_CRYPTO */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
literal|"Cryptographic support is not available"
argument_list|)
return|;
endif|#
directive|endif
comment|/* SVN_HAVE_CRYPTO */
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_crypto__verify_secret
parameter_list|(
name|svn_boolean_t
modifier|*
name|is_valid
parameter_list|,
name|svn_crypto__ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|master
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|ciphertext
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|iv
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|salt
parameter_list|,
specifier|const
name|char
modifier|*
name|checktext
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_HAVE_CRYPTO
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_crypto_block_t
modifier|*
name|block_ctx
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|block_size
decl_stmt|,
name|iv_len
decl_stmt|;
name|apr_crypto_key_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
decl_stmt|;
name|apr_size_t
name|result_len
init|=
literal|0
decl_stmt|,
name|final_len
init|=
literal|0
decl_stmt|;
name|svn_checksum_t
modifier|*
name|result_sum
decl_stmt|;
operator|*
name|is_valid
operator|=
name|FALSE
expr_stmt|;
comment|/* Initialize the passphrase.  */
name|apr_err
operator|=
name|apr_crypto_passphrase
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|iv_len
argument_list|,
name|master
operator|->
name|data
argument_list|,
name|master
operator|->
name|len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|salt
operator|->
name|data
argument_list|,
name|salt
operator|->
name|len
argument_list|,
name|APR_KEY_AES_256
argument_list|,
name|APR_MODE_CBC
argument_list|,
name|FALSE
comment|/* doPad */
argument_list|,
name|NUM_ITERATIONS
argument_list|,
name|ctx
operator|->
name|crypto
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error creating derived key"
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error creating derived key"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|iv_len
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|APR_EGENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected IV length returned"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|iv_len
operator|!=
name|iv
operator|->
name|len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Provided IV has incorrect length"
argument_list|)
argument_list|)
return|;
name|apr_err
operator|=
name|apr_crypto_block_decrypt_init
argument_list|(
operator|&
name|block_ctx
argument_list|,
operator|&
name|block_size
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|iv
operator|->
name|data
argument_list|,
name|key
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|apr_err
operator|!=
name|APR_SUCCESS
operator|)
operator|||
operator|(
operator|!
name|block_ctx
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error initializing block decryption"
argument_list|)
argument_list|)
argument_list|)
return|;
name|apr_err
operator|=
name|apr_crypto_block_decrypt
argument_list|(
name|NULL
argument_list|,
operator|&
name|result_len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ciphertext
operator|->
name|data
argument_list|,
name|ciphertext
operator|->
name|len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error fetching result length"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
name|result_len
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_crypto_block_decrypt
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|result_len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ciphertext
operator|->
name|data
argument_list|,
name|ciphertext
operator|->
name|len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error during block decryption"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|apr_err
operator|=
name|apr_crypto_block_decrypt_finish
argument_list|(
name|result
operator|+
name|result_len
argument_list|,
operator|&
name|final_len
argument_list|,
name|block_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|err
operator|=
name|crypto_error_create
argument_list|(
name|ctx
argument_list|,
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Error finalizing block decryption"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* ### FIXME:  This should be a SHA-256.  */
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|result_sum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|result
argument_list|,
name|result_len
operator|+
name|final_len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|is_valid
operator|=
name|strcmp
argument_list|(
name|checktext
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|result_sum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
name|cleanup
label|:
name|apr_crypto_block_cleanup
argument_list|(
name|block_ctx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
else|#
directive|else
comment|/* SVN_HAVE_CRYPTO */
operator|*
name|is_valid
operator|=
name|FALSE
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
literal|"Cryptographic support is not available"
argument_list|)
return|;
endif|#
directive|endif
comment|/* SVN_HAVE_CRYPTO */
block|}
end_function

end_unit

