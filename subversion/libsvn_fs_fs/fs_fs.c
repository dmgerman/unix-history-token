begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fs_fs.c --- filesystem operations specific to fs_fs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"rep-cache.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_comment
comment|/* The default maximum number of files per directory to store in the    rev and revprops directory.  The number below is somewhat arbitrary,    and can be overridden by defining the macro while compiling; the    figure of 1000 is reasonable for VFAT filesystems, which are by far    the worst performers in this area. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_FS_FS_DEFAULT_MAX_FILES_PER_DIR
end_ifndef

begin_define
define|#
directive|define
name|SVN_FS_FS_DEFAULT_MAX_FILES_PER_DIR
value|1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Begin deltification after a node history exceeded this this limit.    Useful values are 4 to 64 with 16 being a good compromise between    computational overhead and repository size savings.    Should be a power of 2.    Values< 2 will result in standard skip-delta behavior. */
end_comment

begin_define
define|#
directive|define
name|SVN_FS_FS_MAX_LINEAR_DELTIFICATION
value|16
end_define

begin_comment
comment|/* Finding a deltification base takes operations proportional to the    number of changes being skipped. To prevent exploding runtime    during commits, limit the deltification range to this value.    Should be a power of 2 minus one.    Values< 1 disable deltification. */
end_comment

begin_define
define|#
directive|define
name|SVN_FS_FS_MAX_DELTIFICATION_WALK
value|1023
end_define

begin_comment
comment|/* Notes:  To avoid opening and closing the rev-files all the time, it would probably be advantageous to keep each rev-file open for the lifetime of the transaction object.  I'll leave that as a later optimization for now.  I didn't keep track of pool lifetimes at all in this code.  There are likely some errors because of that.  */
end_comment

begin_comment
comment|/* Declarations. */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|get_youngest
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pathname helper functions */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_format
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_FORMAT
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_uuid
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_UUID
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fs_fs__path_current
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CURRENT
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get a lock on empty file LOCK_FILENAME, creating it in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock_on_filesystem
parameter_list|(
specifier|const
name|char
modifier|*
name|lock_filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_io__file_lock_autocreate
argument_list|(
name|lock_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reset the HAS_WRITE_LOCK member in the FFD given as BATON_VOID.    When registered with the pool holding the lock on the lock file,    this makes sure the flag gets reset just before we release the lock. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|reset_lock_flag
parameter_list|(
name|void
modifier|*
name|baton_void
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|baton_void
decl_stmt|;
name|ffd
operator|->
name|has_write_lock
operator|=
name|FALSE
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Structure defining a file system lock to be acquired and the function    to be executed while the lock is held.     Instances of this structure may be nested to allow for multiple locks to    be taken out before executing the user-provided body.  In that case, BODY    and BATON of the outer instances will be with_lock and a with_lock_baton_t    instance (transparently, no special treatment is required.).  It is    illegal to attempt to acquire the same lock twice within the same lock    chain or via nesting calls using separate lock chains.     All instances along the chain share the same LOCK_POOL such that only one    pool needs to be created and cleared for all locks.  We also allocate as    much data from that lock pool as possible to minimize memory usage in    caller pools. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|with_lock_baton_t
block|{
comment|/* The filesystem we operate on.  Same for all instances along the chain. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* Mutex to complement the lock file in an APR threaded process.      No-op object for non-threaded processes but never NULL. */
name|svn_mutex__t
modifier|*
name|mutex
decl_stmt|;
comment|/* Path to the file to lock. */
specifier|const
name|char
modifier|*
name|lock_path
decl_stmt|;
comment|/* If true, set FS->HAS_WRITE_LOCK after we acquired the lock. */
name|svn_boolean_t
name|is_global_lock
decl_stmt|;
comment|/* Function body to execute after we acquired the lock.      This may be user-provided or a nested call to with_lock(). */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
comment|/* Baton to pass to BODY; possibly NULL.      This may be user-provided or a nested lock baton instance. */
name|void
modifier|*
name|baton
decl_stmt|;
comment|/* Pool for all allocations along the lock chain and BODY.  Will hold the      file locks and gets destroyed after the outermost BODY returned,      releasing all file locks.      Same for all instances along the chain. */
name|apr_pool_t
modifier|*
name|lock_pool
decl_stmt|;
comment|/* TRUE, iff BODY is the user-provided body. */
name|svn_boolean_t
name|is_inner_most_lock
decl_stmt|;
comment|/* TRUE, iff this is not a nested lock.      Then responsible for destroying LOCK_POOL. */
name|svn_boolean_t
name|is_outer_most_lock
decl_stmt|;
block|}
name|with_lock_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Obtain a write lock on the file BATON->LOCK_PATH and call BATON->BODY    with BATON->BATON.  If this is the outermost lock call, release all file    locks after the body returned.  If BATON->IS_GLOBAL_LOCK is set, set the    HAS_WRITE_LOCK flag while we keep the write lock. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|with_some_lock_file
parameter_list|(
name|with_lock_baton_t
modifier|*
name|baton
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|baton
operator|->
name|lock_pool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|get_lock_on_filesystem
argument_list|(
name|baton
operator|->
name|lock_path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|baton
operator|->
name|fs
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|baton
operator|->
name|is_global_lock
condition|)
block|{
comment|/* set the "got the lock" flag and register reset function */
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|ffd
argument_list|,
name|reset_lock_flag
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|has_write_lock
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* nobody else will modify the repo state          => read HEAD& pack info once */
if|if
condition|(
name|baton
operator|->
name|is_inner_most_lock
condition|)
block|{
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|err
operator|=
name|svn_fs_fs__update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|get_youngest
argument_list|(
operator|&
name|ffd
operator|->
name|youngest_rev_cache
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|baton
operator|->
name|body
argument_list|(
name|baton
operator|->
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baton
operator|->
name|is_outer_most_lock
condition|)
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wraps with_some_lock_file, protecting it with BATON->MUTEX.     POOL is unused here and only provided for signature compatibility with    WITH_LOCK_BATON_T.BODY. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|with_lock
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|with_lock_baton_t
modifier|*
name|lock_baton
init|=
name|baton
decl_stmt|;
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|lock_baton
operator|->
name|mutex
argument_list|,
name|with_some_lock_file
argument_list|(
name|lock_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Enum identifying a filesystem lock. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|lock_id_t
block|{
name|write_lock
block|,
name|txn_lock
block|,
name|pack_lock
block|}
name|lock_id_t
typedef|;
end_typedef

begin_comment
comment|/* Initialize BATON->MUTEX, BATON->LOCK_PATH and BATON->IS_GLOBAL_LOCK    according to the LOCK_ID.  All other members of BATON must already be    valid. */
end_comment

begin_function
specifier|static
name|void
name|init_lock_baton
parameter_list|(
name|with_lock_baton_t
modifier|*
name|baton
parameter_list|,
name|lock_id_t
name|lock_id
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|baton
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_shared_data_t
modifier|*
name|ffsd
init|=
name|ffd
operator|->
name|shared
decl_stmt|;
switch|switch
condition|(
name|lock_id
condition|)
block|{
case|case
name|write_lock
case|:
name|baton
operator|->
name|mutex
operator|=
name|ffsd
operator|->
name|fs_write_lock
expr_stmt|;
name|baton
operator|->
name|lock_path
operator|=
name|svn_fs_fs__path_lock
argument_list|(
name|baton
operator|->
name|fs
argument_list|,
name|baton
operator|->
name|lock_pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|is_global_lock
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|txn_lock
case|:
name|baton
operator|->
name|mutex
operator|=
name|ffsd
operator|->
name|txn_current_lock
expr_stmt|;
name|baton
operator|->
name|lock_path
operator|=
name|svn_fs_fs__path_txn_current_lock
argument_list|(
name|baton
operator|->
name|fs
argument_list|,
name|baton
operator|->
name|lock_pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|is_global_lock
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|pack_lock
case|:
name|baton
operator|->
name|mutex
operator|=
name|ffsd
operator|->
name|fs_pack_lock
expr_stmt|;
name|baton
operator|->
name|lock_path
operator|=
name|svn_fs_fs__path_pack_lock
argument_list|(
name|baton
operator|->
name|fs
argument_list|,
name|baton
operator|->
name|lock_pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|is_global_lock
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return the  baton for the innermost lock of a (potential) lock chain.    The baton shall take out LOCK_ID from FS and execute BODY with BATON    while the lock is being held.  Allocate the result in a sub-pool of POOL.  */
end_comment

begin_function
specifier|static
name|with_lock_baton_t
modifier|*
name|create_lock_baton
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|lock_id_t
name|lock_id
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Allocate everything along the lock chain into a single sub-pool.      This minimizes memory usage and cleanup overhead. */
name|apr_pool_t
modifier|*
name|lock_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|with_lock_baton_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|lock_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Store parameters. */
name|result
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|result
operator|->
name|body
operator|=
name|body
expr_stmt|;
name|result
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
comment|/* File locks etc. will use this pool as well for easy cleanup. */
name|result
operator|->
name|lock_pool
operator|=
name|lock_pool
expr_stmt|;
comment|/* Right now, we are the first, (only, ) and last struct in the chain. */
name|result
operator|->
name|is_inner_most_lock
operator|=
name|TRUE
expr_stmt|;
name|result
operator|->
name|is_outer_most_lock
operator|=
name|TRUE
expr_stmt|;
comment|/* Select mutex and lock file path depending on LOCK_ID.      Also, initialize dependent members (IS_GLOBAL_LOCK only, ATM). */
name|init_lock_baton
argument_list|(
name|result
argument_list|,
name|lock_id
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return a baton that wraps NESTED and requests LOCK_ID as additional lock.  *  * That means, when you create a lock chain, start with the last / innermost  * lock to take out and add the first / outermost lock last.  */
end_comment

begin_function
specifier|static
name|with_lock_baton_t
modifier|*
name|chain_lock_baton
parameter_list|(
name|lock_id_t
name|lock_id
parameter_list|,
name|with_lock_baton_t
modifier|*
name|nested
parameter_list|)
block|{
comment|/* Use the same pool for batons along the lock chain. */
name|apr_pool_t
modifier|*
name|lock_pool
init|=
name|nested
operator|->
name|lock_pool
decl_stmt|;
name|with_lock_baton_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|lock_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
comment|/* All locks along the chain operate on the same FS. */
name|result
operator|->
name|fs
operator|=
name|nested
operator|->
name|fs
expr_stmt|;
comment|/* Execution of this baton means acquiring the nested lock and its      execution. */
name|result
operator|->
name|body
operator|=
name|with_lock
expr_stmt|;
name|result
operator|->
name|baton
operator|=
name|nested
expr_stmt|;
comment|/* Shared among all locks along the chain. */
name|result
operator|->
name|lock_pool
operator|=
name|lock_pool
expr_stmt|;
comment|/* We are the new outermost lock but surely not the innermost lock. */
name|result
operator|->
name|is_inner_most_lock
operator|=
name|FALSE
expr_stmt|;
name|result
operator|->
name|is_outer_most_lock
operator|=
name|TRUE
expr_stmt|;
name|nested
operator|->
name|is_outer_most_lock
operator|=
name|FALSE
expr_stmt|;
comment|/* Select mutex and lock file path depending on LOCK_ID.      Also, initialize dependent members (IS_GLOBAL_LOCK only, ATM). */
name|init_lock_baton
argument_list|(
name|result
argument_list|,
name|lock_id
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__with_write_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|with_lock
argument_list|(
name|create_lock_baton
argument_list|(
name|fs
argument_list|,
name|write_lock
argument_list|,
name|body
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__with_pack_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|with_lock
argument_list|(
name|create_lock_baton
argument_list|(
name|fs
argument_list|,
name|pack_lock
argument_list|,
name|body
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__with_txn_current_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|with_lock
argument_list|(
name|create_lock_baton
argument_list|(
name|fs
argument_list|,
name|txn_lock
argument_list|,
name|body
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__with_all_locks
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Be sure to use the correct lock ordering as documented in      fs_fs_shared_data_t.  The lock chain is being created in      innermost (last to acquire) -> outermost (first to acquire) order. */
name|with_lock_baton_t
modifier|*
name|lock_baton
init|=
name|create_lock_baton
argument_list|(
name|fs
argument_list|,
name|write_lock
argument_list|,
name|body
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACK_LOCK_FORMAT
condition|)
name|lock_baton
operator|=
name|chain_lock_baton
argument_list|(
name|pack_lock
argument_list|,
name|lock_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
name|lock_baton
operator|=
name|chain_lock_baton
argument_list|(
name|txn_lock
argument_list|,
name|lock_baton
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|with_lock
argument_list|(
name|lock_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check that BUF, a nul-terminated buffer of text from format file PATH,    contains only digits at OFFSET and beyond, raising an error if not.     Uses POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_format_file_buffer_numeric
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_fs_fs__check_file_buffer_numeric
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|path
argument_list|,
literal|"Format"
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the error SVN_ERR_FS_UNSUPPORTED_FORMAT if FS's format    number is not the same as a format number supported by this    Subversion. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_format
parameter_list|(
name|int
name|format
parameter_list|)
block|{
comment|/* Blacklist.  These formats may be either younger or older than      SVN_FS_FS__FORMAT_NUMBER, but we don't support them. */
if|if
condition|(
name|format
operator|==
name|SVN_FS_FS__PACKED_REVPROP_SQLITE_DEV_FORMAT
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Found format '%d', only created by "
literal|"unreleased dev builds; see "
literal|"http://subversion.apache.org"
literal|"/docs/release-notes/1.7#revprop-packing"
argument_list|)
argument_list|,
name|format
argument_list|)
return|;
comment|/* We support all formats from 1-current simultaneously */
if|if
condition|(
literal|1
operator|<=
name|format
operator|&&
name|format
operator|<=
name|SVN_FS_FS__FORMAT_NUMBER
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected FS format between '1' and '%d'; found format '%d'"
argument_list|)
argument_list|,
name|SVN_FS_FS__FORMAT_NUMBER
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the format number and maximum number of files per directory    from PATH and return them in *PFORMAT, *MAX_FILES_PER_DIR and    USE_LOG_ADDRESSIONG respectively.     *MAX_FILES_PER_DIR is obtained from the 'layout' format option, and    will be set to zero if a linear scheme should be used.    *USE_LOG_ADDRESSIONG is obtained from the 'addressing' format option,    and will be set to FALSE for physical addressing.     Use POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_format
parameter_list|(
name|int
modifier|*
name|pformat
parameter_list|,
name|int
modifier|*
name|max_files_per_dir
parameter_list|,
name|svn_boolean_t
modifier|*
name|use_log_addressing
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|svn_boolean_t
name|eos
init|=
name|FALSE
decl_stmt|;
name|err
operator|=
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|content
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* Treat an absent format file as format 1.  Do not try to          create the format file on the fly, because the repository          might be read-only for us, or this might be a read-only          operation, and the spirit of FSFS is to make no changes          whatseover in read-only operations.  See thread starting at          http://subversion.tigris.org/servlets/ReadMsg?list=dev&msgNo=97600          for more. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|pformat
operator|=
literal|1
expr_stmt|;
operator|*
name|max_files_per_dir
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|content
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|==
literal|0
operator|&&
name|eos
condition|)
block|{
comment|/* Return a more useful error message. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't read first line of format file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Check that the first line contains only digits. */
name|SVN_ERR
argument_list|(
name|check_format_file_buffer_numeric
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
name|pformat
argument_list|,
name|buf
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that we support this format at all */
name|SVN_ERR
argument_list|(
name|check_format
argument_list|(
operator|*
name|pformat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the default values for anything that can be set via an option. */
operator|*
name|max_files_per_dir
operator|=
literal|0
expr_stmt|;
operator|*
name|use_log_addressing
operator|=
name|FALSE
expr_stmt|;
comment|/* Read any options. */
while|while
condition|(
operator|!
name|eos
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|pformat
operator|>=
name|SVN_FS_FS__MIN_LAYOUT_FORMAT_OPTION_FORMAT
operator|&&
name|strncmp
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|"layout "
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buf
operator|->
name|data
operator|+
literal|7
argument_list|,
literal|"linear"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|max_files_per_dir
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buf
operator|->
name|data
operator|+
literal|7
argument_list|,
literal|"sharded "
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Check that the argument is numeric. */
name|SVN_ERR
argument_list|(
name|check_format_file_buffer_numeric
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|15
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
name|max_files_per_dir
argument_list|,
name|buf
operator|->
name|data
operator|+
literal|15
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|*
name|pformat
operator|>=
name|SVN_FS_FS__MIN_LOG_ADDRESSING_FORMAT
operator|&&
name|strncmp
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|"addressing "
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buf
operator|->
name|data
operator|+
literal|11
argument_list|,
literal|"physical"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|use_log_addressing
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buf
operator|->
name|data
operator|+
literal|11
argument_list|,
literal|"logical"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|use_log_addressing
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' contains invalid filesystem format option '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|buf
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Non-sharded repositories never use logical addressing.    * If the format file is inconsistent in that respect, something    * probably went wrong.    */
if|if
condition|(
operator|*
name|use_log_addressing
operator|&&
operator|!
operator|*
name|max_files_per_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' specifies logical addressing for a non-sharded repository"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the format number, maximum number of files per directory and    the addressing scheme to a new format file in PATH, possibly expecting    to overwrite a previously existing file.     Use POOL for temporary allocation. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__write_format
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_boolean_t
name|overwrite
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|sb
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|path_format
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
literal|1
operator|<=
name|ffd
operator|->
name|format
operator|&&
name|ffd
operator|->
name|format
operator|<=
name|SVN_FS_FS__FORMAT_NUMBER
argument_list|)
expr_stmt|;
name|sb
operator|=
name|svn_stringbuf_createf
argument_list|(
name|pool
argument_list|,
literal|"%d\n"
argument_list|,
name|ffd
operator|->
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_LAYOUT_FORMAT_OPTION_FORMAT
condition|)
block|{
if|if
condition|(
name|ffd
operator|->
name|max_files_per_dir
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"layout sharded %d\n"
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
literal|"layout linear\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_LOG_ADDRESSING_FORMAT
condition|)
block|{
if|if
condition|(
name|ffd
operator|->
name|use_log_addressing
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
literal|"addressing logical\n"
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
literal|"addressing physical\n"
argument_list|)
expr_stmt|;
block|}
comment|/* svn_io_write_version_file() does a load of magic to allow it to      replace version files that already exist.  We only need to do      that when we're allowed to overwrite an existing file. */
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
comment|/* Create the file */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path
argument_list|,
name|sb
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_io_write_atomic
argument_list|(
name|path
argument_list|,
name|sb
operator|->
name|data
argument_list|,
name|sb
operator|->
name|len
argument_list|,
name|NULL
comment|/* copy_perms_path */
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* And set the perms to make it read only */
return|return
name|svn_io_set_file_read_only
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_fs_fs__fs_supports_mergeinfo
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_MERGEINFO_FORMAT
return|;
block|}
end_function

begin_comment
comment|/* Check that BLOCK_SIZE is a valid block / page size, i.e. it is within  * the range of what the current system may address in RAM and it is a  * power of 2.  Assume that the element size within the block is ITEM_SIZE.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_block_size
parameter_list|(
name|apr_int64_t
name|block_size
parameter_list|,
name|apr_size_t
name|item_size
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Limit range. */
if|if
condition|(
name|block_size
operator|<=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s is too small for fsfs.conf setting '%s'."
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|block_size
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
name|block_size
operator|>
name|SVN_MAX_OBJECT_SIZE
operator|/
name|item_size
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s is too large for fsfs.conf setting '%s'."
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|block_size
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Ensure it is a power of two.    * For positive X,  X& (X-1) will reset the lowest bit set.    * If the result is 0, at most one bit has been set. */
if|if
condition|(
literal|0
operator|!=
operator|(
name|block_size
operator|&
operator|(
name|block_size
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s is invalid for fsfs.conf setting '%s' "
literal|"because it is not a power of 2."
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|block_size
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the configuration information of the file system at FS_PATH  * and set the respective values in FFD.  Use pools as usual.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_config
parameter_list|(
name|fs_fs_data_t
modifier|*
name|ffd
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|config
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
operator|&
name|config
argument_list|,
name|svn_dirent_join
argument_list|(
name|fs_path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize ffd->rep_sharing_allowed. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_REP_SHARING_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|rep_sharing_allowed
argument_list|,
name|CONFIG_SECTION_REP_SHARING
argument_list|,
name|CONFIG_OPTION_ENABLE_REP_SHARING
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ffd
operator|->
name|rep_sharing_allowed
operator|=
name|FALSE
expr_stmt|;
comment|/* Initialize deltification settings in ffd. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_DELTIFICATION_FORMAT
condition|)
block|{
name|apr_int64_t
name|compression_level
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|deltify_directories
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_ENABLE_DIR_DELTIFICATION
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|deltify_properties
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_ENABLE_PROPS_DELTIFICATION
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|max_deltification_walk
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_MAX_DELTIFICATION_WALK
argument_list|,
name|SVN_FS_FS_MAX_DELTIFICATION_WALK
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|max_linear_deltification
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_MAX_LINEAR_DELTIFICATION
argument_list|,
name|SVN_FS_FS_MAX_LINEAR_DELTIFICATION
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|compression_level
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_COMPRESSION_LEVEL
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|delta_compression_level
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|MAX
argument_list|(
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
argument_list|,
name|compression_level
argument_list|)
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffd
operator|->
name|deltify_directories
operator|=
name|FALSE
expr_stmt|;
name|ffd
operator|->
name|deltify_properties
operator|=
name|FALSE
expr_stmt|;
name|ffd
operator|->
name|max_deltification_walk
operator|=
name|SVN_FS_FS_MAX_DELTIFICATION_WALK
expr_stmt|;
name|ffd
operator|->
name|max_linear_deltification
operator|=
name|SVN_FS_FS_MAX_LINEAR_DELTIFICATION
expr_stmt|;
name|ffd
operator|->
name|delta_compression_level
operator|=
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
expr_stmt|;
block|}
comment|/* Initialize revprop packing settings in ffd. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|compress_packed_revprops
argument_list|,
name|CONFIG_SECTION_PACKED_REVPROPS
argument_list|,
name|CONFIG_OPTION_COMPRESS_PACKED_REVPROPS
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|revprop_pack_size
argument_list|,
name|CONFIG_SECTION_PACKED_REVPROPS
argument_list|,
name|CONFIG_OPTION_REVPROP_PACK_SIZE
argument_list|,
name|ffd
operator|->
name|compress_packed_revprops
condition|?
literal|0x10
else|:
literal|0x4
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|revprop_pack_size
operator|*=
literal|1024
expr_stmt|;
block|}
else|else
block|{
name|ffd
operator|->
name|revprop_pack_size
operator|=
literal|0x10000
expr_stmt|;
name|ffd
operator|->
name|compress_packed_revprops
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_LOG_ADDRESSING_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|block_size
argument_list|,
name|CONFIG_SECTION_IO
argument_list|,
name|CONFIG_OPTION_BLOCK_SIZE
argument_list|,
literal|64
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|l2p_page_size
argument_list|,
name|CONFIG_SECTION_IO
argument_list|,
name|CONFIG_OPTION_L2P_PAGE_SIZE
argument_list|,
literal|0x2000
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|p2l_page_size
argument_list|,
name|CONFIG_SECTION_IO
argument_list|,
name|CONFIG_OPTION_P2L_PAGE_SIZE
argument_list|,
literal|0x400
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't accept unreasonable or illegal values.        * Block size and P2L page size are in kbytes;        * L2P blocks are arrays of apr_off_t. */
name|SVN_ERR
argument_list|(
name|verify_block_size
argument_list|(
name|ffd
operator|->
name|block_size
argument_list|,
literal|0x400
argument_list|,
name|CONFIG_OPTION_BLOCK_SIZE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_block_size
argument_list|(
name|ffd
operator|->
name|p2l_page_size
argument_list|,
literal|0x400
argument_list|,
name|CONFIG_OPTION_P2L_PAGE_SIZE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_block_size
argument_list|(
name|ffd
operator|->
name|l2p_page_size
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|,
name|CONFIG_OPTION_L2P_PAGE_SIZE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* convert kBytes to bytes */
name|ffd
operator|->
name|block_size
operator|*=
literal|0x400
expr_stmt|;
name|ffd
operator|->
name|p2l_page_size
operator|*=
literal|0x400
expr_stmt|;
comment|/* L2P pages are in entries - not in (k)Bytes */
block|}
else|else
block|{
comment|/* should be irrelevant but we initialize them anyway */
name|ffd
operator|->
name|block_size
operator|=
literal|0x1000
expr_stmt|;
comment|/* Matches default APR file buffer size. */
name|ffd
operator|->
name|l2p_page_size
operator|=
literal|0x2000
expr_stmt|;
comment|/* Matches above default. */
name|ffd
operator|->
name|p2l_page_size
operator|=
literal|0x100000
expr_stmt|;
comment|/* Matches above default in bytes. */
block|}
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|pack_after_commit
argument_list|,
name|CONFIG_SECTION_DEBUG
argument_list|,
name|CONFIG_OPTION_PACK_AFTER_COMMIT
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffd
operator|->
name|pack_after_commit
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* memcached configuration */
name|SVN_ERR
argument_list|(
name|svn_cache__make_memcache_from_config
argument_list|(
operator|&
name|ffd
operator|->
name|memcache
argument_list|,
name|config
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|fail_stop
argument_list|,
name|CONFIG_SECTION_CACHES
argument_list|,
name|CONFIG_OPTION_FAIL_STOP
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_config
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
define|#
directive|define
name|NL
value|APR_EOL_STR
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|fsfs_conf_contents
init|=
literal|"### This file controls the configuration of the FSFS filesystem."
name|NL
literal|""
name|NL
literal|"["
name|SVN_CACHE_CONFIG_CATEGORY_MEMCACHED_SERVERS
literal|"]"
name|NL
literal|"### These options name memcached servers used to cache internal FSFS"
name|NL
literal|"### data.  See http://www.danga.com/memcached/ for more information on"
name|NL
literal|"### memcached.  To use memcached with FSFS, run one or more memcached"
name|NL
literal|"### servers, and specify each of them as an option like so:"
name|NL
literal|"# first-server = 127.0.0.1:11211"
name|NL
literal|"# remote-memcached = mymemcached.corp.example.com:11212"
name|NL
literal|"### The option name is ignored; the value is of the form HOST:PORT."
name|NL
literal|"### memcached servers can be shared between multiple repositories;"
name|NL
literal|"### however, if you do this, you *must* ensure that repositories have"
name|NL
literal|"### distinct UUIDs and paths, or else cached data from one repository"
name|NL
literal|"### might be used by another accidentally.  Note also that memcached has"
name|NL
literal|"### no authentication for reads or writes, so you must ensure that your"
name|NL
literal|"### memcached servers are only accessible by trusted users."
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_CACHES
literal|"]"
name|NL
literal|"### When a cache-related error occurs, normally Subversion ignores it"
name|NL
literal|"### and continues, logging an error if the server is appropriately"
name|NL
literal|"### configured (and ignoring it with file:// access).  To make"
name|NL
literal|"### Subversion never ignore cache errors, uncomment this line."
name|NL
literal|"# "
name|CONFIG_OPTION_FAIL_STOP
literal|" = true"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_REP_SHARING
literal|"]"
name|NL
literal|"### To conserve space, the filesystem can optionally avoid storing"
name|NL
literal|"### duplicate representations.  This comes at a slight cost in"
name|NL
literal|"### performance, as maintaining a database of shared representations can"
name|NL
literal|"### increase commit times.  The space savings are dependent upon the size"
name|NL
literal|"### of the repository, the number of objects it contains and the amount of"
name|NL
literal|"### duplication between them, usually a function of the branching and"
name|NL
literal|"### merging process."
name|NL
literal|"###"
name|NL
literal|"### The following parameter enables rep-sharing in the repository.  It can"
name|NL
literal|"### be switched on and off at will, but for best space-saving results"
name|NL
literal|"### should be enabled consistently over the life of the repository."
name|NL
literal|"### 'svnadmin verify' will check the rep-cache regardless of this setting."
name|NL
literal|"### rep-sharing is enabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_ENABLE_REP_SHARING
literal|" = true"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_DELTIFICATION
literal|"]"
name|NL
literal|"### To conserve space, the filesystem stores data as differences against"
name|NL
literal|"### existing representations.  This comes at a slight cost in performance,"
name|NL
literal|"### as calculating differences can increase commit times.  Reading data"
name|NL
literal|"### will also create higher CPU load and the data will be fragmented."
name|NL
literal|"### Since deltification tends to save significant amounts of disk space,"
name|NL
literal|"### the overall I/O load can actually be lower."
name|NL
literal|"###"
name|NL
literal|"### The options in this section allow for tuning the deltification"
name|NL
literal|"### strategy.  Their effects on data size and server performance may vary"
name|NL
literal|"### from one repository to another.  Versions prior to 1.8 will ignore"
name|NL
literal|"### this section."
name|NL
literal|"###"
name|NL
literal|"### The following parameter enables deltification for directories. It can"
name|NL
literal|"### be switched on and off at will, but for best space-saving results"
name|NL
literal|"### should be enabled consistently over the lifetime of the repository."
name|NL
literal|"### Repositories containing large directories will benefit greatly."
name|NL
literal|"### In rarely accessed repositories, the I/O overhead may be significant"
name|NL
literal|"### as caches will most likely be low."
name|NL
literal|"### directory deltification is enabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_ENABLE_DIR_DELTIFICATION
literal|" = true"
name|NL
literal|"###"
name|NL
literal|"### The following parameter enables deltification for properties on files"
name|NL
literal|"### and directories.  Overall, this is a minor tuning option but can save"
name|NL
literal|"### some disk space if you merge frequently or frequently change node"
name|NL
literal|"### properties.  You should not activate this if rep-sharing has been"
name|NL
literal|"### disabled because this may result in a net increase in repository size."
name|NL
literal|"### property deltification is enabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_ENABLE_PROPS_DELTIFICATION
literal|" = true"
name|NL
literal|"###"
name|NL
literal|"### During commit, the server may need to walk the whole change history of"
name|NL
literal|"### of a given node to find a suitable deltification base.  This linear"
name|NL
literal|"### process can impact commit times, svnadmin load and similar operations."
name|NL
literal|"### This setting limits the depth of the deltification history.  If the"
name|NL
literal|"### threshold has been reached, the node will be stored as fulltext and a"
name|NL
literal|"### new deltification history begins."
name|NL
literal|"### Note, this is unrelated to svn log."
name|NL
literal|"### Very large values rarely provide significant additional savings but"
name|NL
literal|"### can impact performance greatly - in particular if directory"
name|NL
literal|"### deltification has been activated.  Very small values may be useful in"
name|NL
literal|"### repositories that are dominated by large, changing binaries."
name|NL
literal|"### Should be a power of two minus 1.  A value of 0 will effectively"
name|NL
literal|"### disable deltification."
name|NL
literal|"### For 1.8, the default value is 1023; earlier versions have no limit."
name|NL
literal|"# "
name|CONFIG_OPTION_MAX_DELTIFICATION_WALK
literal|" = 1023"
name|NL
literal|"###"
name|NL
literal|"### The skip-delta scheme used by FSFS tends to repeatably store redundant"
name|NL
literal|"### delta information where a simple delta against the latest version is"
name|NL
literal|"### often smaller.  By default, 1.8+ will therefore use skip deltas only"
name|NL
literal|"### after the linear chain of deltas has grown beyond the threshold"
name|NL
literal|"### specified by this setting."
name|NL
literal|"### Values up to 64 can result in some reduction in repository size for"
name|NL
literal|"### the cost of quickly increasing I/O and CPU costs. Similarly, smaller"
name|NL
literal|"### numbers can reduce those costs at the cost of more disk space.  For"
name|NL
literal|"### rarely read repositories or those containing larger binaries, this may"
name|NL
literal|"### present a better trade-off."
name|NL
literal|"### Should be a power of two.  A value of 1 or smaller will cause the"
name|NL
literal|"### exclusive use of skip-deltas (as in pre-1.8)."
name|NL
literal|"### For 1.8, the default value is 16; earlier versions use 1."
name|NL
literal|"# "
name|CONFIG_OPTION_MAX_LINEAR_DELTIFICATION
literal|" = 16"
name|NL
literal|"###"
name|NL
literal|"### After deltification, we compress the data through zlib to minimize on-"
name|NL
literal|"### disk size.  That can be an expensive and ineffective process.  This"
name|NL
literal|"### setting controls the usage of zlib in future revisions."
name|NL
literal|"### Revisions with highly compressible data in them may shrink in size"
name|NL
literal|"### if the setting is increased but may take much longer to commit.  The"
name|NL
literal|"### time taken to uncompress that data again is widely independent of the"
name|NL
literal|"### compression level."
name|NL
literal|"### Compression will be ineffective if the incoming content is already"
name|NL
literal|"### highly compressed.  In that case, disabling the compression entirely"
name|NL
literal|"### will speed up commits as well as reading the data.  Repositories with"
name|NL
literal|"### many small compressible files (source code) but also a high percentage"
name|NL
literal|"### of large incompressible ones (artwork) may benefit from compression"
name|NL
literal|"### levels lowered to e.g. 1."
name|NL
literal|"### Valid values are 0 to 9 with 9 providing the highest compression ratio"
name|NL
literal|"### and 0 disabling it altogether."
name|NL
literal|"### The default value is 5."
name|NL
literal|"# "
name|CONFIG_OPTION_COMPRESSION_LEVEL
literal|" = 5"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_PACKED_REVPROPS
literal|"]"
name|NL
literal|"### This parameter controls the size (in kBytes) of packed revprop files."
name|NL
literal|"### Revprops of consecutive revisions will be concatenated into a single"
name|NL
literal|"### file up to but not exceeding the threshold given here.  However, each"
name|NL
literal|"### pack file may be much smaller and revprops of a single revision may be"
name|NL
literal|"### much larger than the limit set here.  The threshold will be applied"
name|NL
literal|"### before optional compression takes place."
name|NL
literal|"### Large values will reduce disk space usage at the expense of increased"
name|NL
literal|"### latency and CPU usage reading and changing individual revprops."
name|NL
literal|"### Values smaller than 4 kByte will not improve latency any further and "
name|NL
literal|"### quickly render revprop packing ineffective."
name|NL
literal|"### revprop-pack-size is 4 kBytes by default for non-compressed revprop"
name|NL
literal|"### pack files and 16 kBytes when compression has been enabled."
name|NL
literal|"# "
name|CONFIG_OPTION_REVPROP_PACK_SIZE
literal|" = 4"
name|NL
literal|"###"
name|NL
literal|"### To save disk space, packed revprop files may be compressed.  Standard"
name|NL
literal|"### revprops tend to allow for very effective compression.  Reading and"
name|NL
literal|"### even more so writing, become significantly more CPU intensive."
name|NL
literal|"### Compressing packed revprops is disabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_COMPRESS_PACKED_REVPROPS
literal|" = false"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_IO
literal|"]"
name|NL
literal|"### Parameters in this section control the data access granularity in"
name|NL
literal|"### format 7 repositories and later.  The defaults should translate into"
name|NL
literal|"### decent performance over a wide range of setups."
name|NL
literal|"###"
name|NL
literal|"### When a specific piece of information needs to be read from disk,  a"
name|NL
literal|"### data block is being read at once and its contents are being cached."
name|NL
literal|"### If the repository is being stored on a RAID, the block size should be"
name|NL
literal|"### either 50% or 100% of RAID block size / granularity.  Also, your file"
name|NL
literal|"### system blocks/clusters should be properly aligned and sized.  In that"
name|NL
literal|"### setup, each access will hit only one disk (minimizes I/O load) but"
name|NL
literal|"### uses all the data provided by the disk in a single access."
name|NL
literal|"### For SSD-based storage systems, slightly lower values around 16 kB"
name|NL
literal|"### may improve latency while still maximizing throughput.  If block-read"
name|NL
literal|"### has not been enabled, this will be capped to 4 kBytes."
name|NL
literal|"### Can be changed at any time but must be a power of 2."
name|NL
literal|"### block-size is given in kBytes and with a default of 64 kBytes."
name|NL
literal|"# "
name|CONFIG_OPTION_BLOCK_SIZE
literal|" = 64"
name|NL
literal|"###"
name|NL
literal|"### The log-to-phys index maps data item numbers to offsets within the"
name|NL
literal|"### rev or pack file.  This index is organized in pages of a fixed maximum"
name|NL
literal|"### capacity.  To access an item, the page table and the respective page"
name|NL
literal|"### must be read."
name|NL
literal|"### This parameter only affects revisions with thousands of changed paths."
name|NL
literal|"### If you have several extremely large revisions (~1 mio changes), think"
name|NL
literal|"### about increasing this setting.  Reducing the value will rarely result"
name|NL
literal|"### in a net speedup."
name|NL
literal|"### This is an expert setting.  Must be a power of 2."
name|NL
literal|"### l2p-page-size is 8192 entries by default."
name|NL
literal|"# "
name|CONFIG_OPTION_L2P_PAGE_SIZE
literal|" = 8192"
name|NL
literal|"###"
name|NL
literal|"### The phys-to-log index maps positions within the rev or pack file to"
name|NL
literal|"### to data items,  i.e. describes what piece of information is being"
name|NL
literal|"### stored at any particular offset.  The index describes the rev file"
name|NL
literal|"### in chunks (pages) and keeps a global list of all those pages.  Large"
name|NL
literal|"### pages mean a shorter page table but a larger per-page description of"
name|NL
literal|"### data items in it.  The latency sweetspot depends on the change size"
name|NL
literal|"### distribution but covers a relatively wide range."
name|NL
literal|"### If the repository contains very large files,  i.e. individual changes"
name|NL
literal|"### of tens of MB each,  increasing the page size will shorten the index"
name|NL
literal|"### file at the expense of a slightly increased latency in sections with"
name|NL
literal|"### smaller changes."
name|NL
literal|"### For source code repositories, this should be about 16x the block-size."
name|NL
literal|"### Must be a power of 2."
name|NL
literal|"### p2l-page-size is given in kBytes and with a default of 1024 kBytes."
name|NL
literal|"# "
name|CONFIG_OPTION_P2L_PAGE_SIZE
literal|" = 1024"
name|NL
decl_stmt|;
undef|#
directive|undef
name|NL
return|return
name|svn_io_file_create
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fsfs_conf_contents
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read / Evaluate the global configuration in FS->CONFIG to set up  * parameters in FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_global_config
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Providing a config hash is optional. */
if|if
condition|(
name|fs
operator|->
name|config
condition|)
name|ffd
operator|->
name|use_block_read
operator|=
name|svn_hash__get_bool
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_FSFS_BLOCK_READ
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|ffd
operator|->
name|use_block_read
operator|=
name|FALSE
expr_stmt|;
comment|/* Ignore the user-specified larger block size if we don't use block-read.      Defaulting to 4k gives us the same access granularity in format 7 as in      older formats. */
if|if
condition|(
operator|!
name|ffd
operator|->
name|use_block_read
condition|)
name|ffd
operator|->
name|block_size
operator|=
name|MIN
argument_list|(
literal|0x1000
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read FS's UUID file and store the data in the FS struct. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_uuid
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_file_t
modifier|*
name|uuid_file
decl_stmt|;
name|char
name|buf
index|[
name|APR_UUID_FORMATTED_LENGTH
operator|+
literal|2
index|]
decl_stmt|;
name|apr_size_t
name|limit
decl_stmt|;
comment|/* Read the repository uuid. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|uuid_file
argument_list|,
name|path_uuid
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|limit
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|uuid_file
argument_list|,
name|buf
argument_list|,
operator|&
name|limit
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Read the instance ID. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_INSTANCE_ID_FORMAT
condition|)
block|{
name|limit
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|uuid_file
argument_list|,
name|buf
argument_list|,
operator|&
name|limit
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|instance_id
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffd
operator|->
name|instance_id
operator|=
name|fs
operator|->
name|uuid
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|uuid_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__read_format_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|format
decl_stmt|,
name|max_files_per_dir
decl_stmt|;
name|svn_boolean_t
name|use_log_addressing
decl_stmt|;
comment|/* Read info from format file. */
name|SVN_ERR
argument_list|(
name|read_format
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|max_files_per_dir
argument_list|,
operator|&
name|use_log_addressing
argument_list|,
name|path_format
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now that we've got *all* info, store / update values in FFD. */
name|ffd
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|ffd
operator|->
name|max_files_per_dir
operator|=
name|max_files_per_dir
expr_stmt|;
name|ffd
operator|->
name|use_log_addressing
operator|=
name|use_log_addressing
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__open
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Read the FS format file. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_format_file
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in and cache the repository uuid. */
name|SVN_ERR
argument_list|(
name|read_uuid
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the min unpacked revision. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the configuration file. */
name|SVN_ERR
argument_list|(
name|read_config
argument_list|(
name|ffd
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|fs
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Global configuration options. */
name|SVN_ERR
argument_list|(
name|read_global_config
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_youngest
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|youngest_rev_cache
operator|)
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around svn_io_file_create which ignores EEXIST. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_file_ignore_eexist
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_file_create
argument_list|(
name|file
argument_list|,
name|contents
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton type bridging svn_fs_fs__upgrade and upgrade_body carrying  * parameters over between them. */
end_comment

begin_struct
struct|struct
name|upgrade_baton_t
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_upgrade_notify_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|upgrade_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|upgrade_baton_t
modifier|*
name|upgrade_baton
init|=
name|baton
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|upgrade_baton
operator|->
name|fs
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|format
decl_stmt|,
name|max_files_per_dir
decl_stmt|;
name|svn_boolean_t
name|use_log_addressing
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_path
init|=
name|path_format
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|needs_revprop_shard_cleanup
init|=
name|FALSE
decl_stmt|;
comment|/* Read the FS format number and max-files-per-dir setting. */
name|SVN_ERR
argument_list|(
name|read_format
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|max_files_per_dir
argument_list|,
operator|&
name|use_log_addressing
argument_list|,
name|format_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the config file does not exist, create one. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|svn_node_none
case|:
name|SVN_ERR
argument_list|(
name|write_config
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_file
case|:
break|break;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a regular file."
literal|" Please move it out of "
literal|"the way and try again"
argument_list|)
argument_list|,
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* If we're already up-to-date, there's nothing else to be done here. */
if|if
condition|(
name|format
operator|==
name|SVN_FS_FS__FORMAT_NUMBER
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If our filesystem predates the existence of the 'txn-current      file', make that file and its corresponding lock file. */
if|if
condition|(
name|format
operator|<
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|create_file_ignore_eexist
argument_list|(
name|svn_fs_fs__path_txn_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_file_ignore_eexist
argument_list|(
name|svn_fs_fs__path_txn_current_lock
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If our filesystem predates the existence of the 'txn-protorevs'      dir, make that directory.  */
if|if
condition|(
name|format
operator|<
name|SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_fs_fs__path_txn_proto_revs
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If our filesystem is new enough, write the min unpacked rev file. */
if|if
condition|(
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|svn_fs_fs__path_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the file system supports revision packing but not revprop packing      *and* the FS has been sharded, pack the revprops up to the point that      revision data has been packed.  However, keep the non-packed revprop      files around until after the format bump */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
operator|&&
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
operator|&&
name|max_files_per_dir
operator|>
literal|0
condition|)
block|{
name|needs_revprop_shard_cleanup
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__upgrade_pack_revprops
argument_list|(
name|fs
argument_list|,
name|upgrade_baton
operator|->
name|notify_func
argument_list|,
name|upgrade_baton
operator|->
name|notify_baton
argument_list|,
name|upgrade_baton
operator|->
name|cancel_func
argument_list|,
name|upgrade_baton
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We will need the UUID info shortly ...      Read it before the format bump as the UUID file still uses the old      format. */
name|SVN_ERR
argument_list|(
name|read_uuid
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the format info in the FS struct.  Upgrade steps further      down will use the format from FS to create missing info. */
name|ffd
operator|->
name|format
operator|=
name|SVN_FS_FS__FORMAT_NUMBER
expr_stmt|;
name|ffd
operator|->
name|max_files_per_dir
operator|=
name|max_files_per_dir
expr_stmt|;
name|ffd
operator|->
name|use_log_addressing
operator|=
name|use_log_addressing
expr_stmt|;
comment|/* Always add / bump the instance ID such that no form of caching      accidentally uses outdated information.  Keep the UUID. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_uuid
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|uuid
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bump the format file. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_format
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|upgrade_baton
operator|->
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|upgrade_baton
operator|->
name|notify_func
argument_list|(
name|upgrade_baton
operator|->
name|notify_baton
argument_list|,
name|SVN_FS_FS__FORMAT_NUMBER
argument_list|,
name|svn_fs_upgrade_format_bumped
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, it is safe to remove the redundant revprop files. */
if|if
condition|(
name|needs_revprop_shard_cleanup
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__upgrade_cleanup_pack_revprops
argument_list|(
name|fs
argument_list|,
name|upgrade_baton
operator|->
name|notify_func
argument_list|,
name|upgrade_baton
operator|->
name|notify_baton
argument_list|,
name|upgrade_baton
operator|->
name|cancel_func
argument_list|,
name|upgrade_baton
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__upgrade
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_upgrade_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|upgrade_baton_t
name|baton
decl_stmt|;
name|baton
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|baton
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|baton
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|baton
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|baton
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
return|return
name|svn_fs_fs__with_all_locks
argument_list|(
name|fs
argument_list|,
name|upgrade_body
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the youngest revision in a repository at path FS_PATH and    return it in *YOUNGEST_P.  Perform temporary allocations in    POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_youngest
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint64_t
name|dummy
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_current
argument_list|(
name|youngest_p
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__youngest_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_youngest
argument_list|(
name|youngest_p
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|youngest_rev_cache
operator|=
operator|*
name|youngest_p
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|int
name|svn_fs_fs__shard_size
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|ffd
operator|->
name|max_files_per_dir
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__min_unpacked_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|min_unpacked
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|min_unpacked
operator|=
name|ffd
operator|->
name|min_unpacked_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__ensure_revision_exists
parameter_list|(
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision number '%ld'"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* Did the revision exist the last time we checked the current      file? */
if|if
condition|(
name|rev
operator|<=
name|ffd
operator|->
name|youngest_rev_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|get_youngest
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|youngest_rev_cache
operator|)
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check again. */
if|if
condition|(
name|rev
operator|<=
name|ffd
operator|->
name|youngest_rev_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|data_rep
init|=
name|noderev
operator|->
name|data_rep
decl_stmt|;
if|if
condition|(
operator|!
name|data_rep
condition|)
block|{
comment|/* Treat "no representation" as "empty file". */
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data_rep
operator|->
name|expanded_size
condition|)
block|{
comment|/* Standard case: a non-empty file. */
operator|*
name|length
operator|=
name|data_rep
operator|->
name|expanded_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Work around a FSFS format quirk (see issue #4554).           A plain representation may specify its EXPANDED LENGTH as "0"          in which case, the SIZE value is what we want.           Because EXPANDED_LENGTH will also be 0 for empty files, while          SIZE is non-null, we need to check wether the content is          actually empty.  We simply compare with the MD5 checksum of          empty content (sha-1 is not always available).        */
name|svn_checksum_t
modifier|*
name|empty_md5
init|=
name|svn_checksum_empty_checksum
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|empty_md5
operator|->
name|digest
argument_list|,
name|data_rep
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|data_rep
operator|->
name|md5_digest
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Contents is not empty, i.e. EXPANDED_LENGTH cannot be the              actual file length. */
operator|*
name|length
operator|=
name|data_rep
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* Contents is empty. */
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__file_text_rep_equal
parameter_list|(
name|svn_boolean_t
modifier|*
name|equal
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|a
parameter_list|,
name|node_revision_t
modifier|*
name|b
parameter_list|,
name|svn_boolean_t
name|strict
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|contents_a
decl_stmt|,
modifier|*
name|contents_b
decl_stmt|;
name|representation_t
modifier|*
name|rep_a
init|=
name|a
operator|->
name|data_rep
decl_stmt|;
name|representation_t
modifier|*
name|rep_b
init|=
name|b
operator|->
name|data_rep
decl_stmt|;
name|svn_boolean_t
name|a_empty
init|=
operator|!
name|rep_a
operator|||
name|rep_a
operator|->
name|expanded_size
operator|==
literal|0
decl_stmt|;
name|svn_boolean_t
name|b_empty
init|=
operator|!
name|rep_b
operator|||
name|rep_b
operator|->
name|expanded_size
operator|==
literal|0
decl_stmt|;
comment|/* This makes sure that neither rep will be NULL later on */
if|if
condition|(
name|a_empty
operator|&&
name|b_empty
condition|)
block|{
operator|*
name|equal
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|a_empty
operator|!=
name|b_empty
condition|)
block|{
operator|*
name|equal
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* File text representations always know their checksums - even in a txn. */
if|if
condition|(
name|memcmp
argument_list|(
name|rep_a
operator|->
name|md5_digest
argument_list|,
name|rep_b
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_a
operator|->
name|md5_digest
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|equal
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Paranoia. Compare SHA1 checksums because that's the level of      confidence we require for e.g. the working copy. */
if|if
condition|(
name|rep_a
operator|->
name|has_sha1
operator|&&
name|rep_b
operator|->
name|has_sha1
condition|)
block|{
operator|*
name|equal
operator|=
name|memcmp
argument_list|(
name|rep_a
operator|->
name|sha1_digest
argument_list|,
name|rep_b
operator|->
name|sha1_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_a
operator|->
name|sha1_digest
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Same path in same rev or txn? */
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|a
operator|->
name|id
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
block|{
operator|*
name|equal
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Old repositories may not have the SHA1 checksum handy.      This check becomes expensive.  Skip it unless explicitly required.       We already have seen that the ID is different, so produce a likely      false negative as allowed by the API description - even though the      MD5 matched, there is an extremely slim chance that the SHA1 wouldn't.    */
if|if
condition|(
operator|!
name|strict
condition|)
block|{
operator|*
name|equal
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_contents
argument_list|(
operator|&
name|contents_a
argument_list|,
name|fs
argument_list|,
name|rep_a
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_contents
argument_list|(
operator|&
name|contents_b
argument_list|,
name|fs
argument_list|,
name|rep_b
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_contents_same2
argument_list|(
name|equal
argument_list|,
name|contents_a
argument_list|,
name|contents_b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__prop_rep_equal
parameter_list|(
name|svn_boolean_t
modifier|*
name|equal
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|a
parameter_list|,
name|node_revision_t
modifier|*
name|b
parameter_list|,
name|svn_boolean_t
name|strict
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep_a
init|=
name|a
operator|->
name|prop_rep
decl_stmt|;
name|representation_t
modifier|*
name|rep_b
init|=
name|b
operator|->
name|prop_rep
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist_a
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist_b
decl_stmt|;
comment|/* Mainly for a==b==NULL */
if|if
condition|(
name|rep_a
operator|==
name|rep_b
condition|)
block|{
operator|*
name|equal
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Committed property lists can be compared quickly */
if|if
condition|(
name|rep_a
operator|&&
name|rep_b
operator|&&
operator|!
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|rep_a
operator|->
name|txn_id
argument_list|)
operator|&&
operator|!
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|rep_b
operator|->
name|txn_id
argument_list|)
condition|)
block|{
comment|/* MD5 must be given. Having the same checksum is good enough for          accepting the prop lists as equal. */
operator|*
name|equal
operator|=
name|memcmp
argument_list|(
name|rep_a
operator|->
name|md5_digest
argument_list|,
name|rep_b
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_a
operator|->
name|md5_digest
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Same path in same txn? */
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|a
operator|->
name|id
argument_list|,
name|b
operator|->
name|id
argument_list|)
condition|)
block|{
operator|*
name|equal
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Skip the expensive bits unless we are in strict mode.      Simply assume that there is a difference. */
if|if
condition|(
operator|!
name|strict
condition|)
block|{
operator|*
name|equal
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* At least one of the reps has been modified in a txn.      Fetch and compare them. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_proplist
argument_list|(
operator|&
name|proplist_a
argument_list|,
name|fs
argument_list|,
name|a
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_proplist
argument_list|(
operator|&
name|proplist_b
argument_list|,
name|fs
argument_list|,
name|b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|equal
operator|=
name|svn_fs__prop_lists_equal
argument_list|(
name|proplist_a
argument_list|,
name|proplist_b
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|checksum
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
block|{
name|svn_checksum_t
name|temp
decl_stmt|;
name|temp
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|svn_checksum_md5
case|:
name|temp
operator|.
name|digest
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|md5_digest
expr_stmt|;
break|break;
case|case
name|svn_checksum_sha1
case|:
if|if
condition|(
operator|!
name|noderev
operator|->
name|data_rep
operator|->
name|has_sha1
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|temp
operator|.
name|digest
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|sha1_digest
expr_stmt|;
break|break;
default|default:
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
name|checksum
operator|=
name|svn_checksum_dup
argument_list|(
operator|&
name|temp
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|representation_t
modifier|*
name|svn_fs_fs__rep_copy
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|rep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the zeroth revision for filesystem FS.    Perform temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revision_zero
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Use an explicit sub-pool to have full control over temp file lifetimes.    * Since we have it, use it for everything else as well. */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_revision_zero
init|=
name|svn_fs_fs__path_rev
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_string_t
name|date
decl_stmt|;
comment|/* Write out a rev file for revision 0. */
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|apr_array_header_t
modifier|*
name|index_entries
decl_stmt|;
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|l2p_proto_index
decl_stmt|,
modifier|*
name|p2l_proto_index
decl_stmt|;
comment|/* Write a skeleton r0 with no indexes. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_revision_zero
argument_list|,
literal|"PLAIN\nEND\nENDREP\n"
literal|"id: 0.0.r0/2\n"
literal|"type: dir\n"
literal|"count: 0\n"
literal|"text: 0 3 4 4 "
literal|"2d2977d1c96f487abe4a1e202dd03b4e\n"
literal|"cpath: /\n"
literal|"\n\n"
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Construct the index P2L contents: describe the 3 items we have.          Be sure to create them in on-disk order. */
name|index_entries
operator|=
name|apr_array_make
argument_list|(
name|subpool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|size
operator|=
literal|17
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|SVN_FS_FS__ITEM_TYPE_DIR_REP
expr_stmt|;
name|entry
operator|->
name|item
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|item
operator|.
name|number
operator|=
name|SVN_FS_FS__ITEM_INDEX_FIRST_USER
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|index_entries
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|17
expr_stmt|;
name|entry
operator|->
name|size
operator|=
literal|89
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|SVN_FS_FS__ITEM_TYPE_NODEREV
expr_stmt|;
name|entry
operator|->
name|item
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|item
operator|.
name|number
operator|=
name|SVN_FS_FS__ITEM_INDEX_ROOT_NODE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|index_entries
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|106
expr_stmt|;
name|entry
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|SVN_FS_FS__ITEM_TYPE_CHANGES
expr_stmt|;
name|entry
operator|->
name|item
operator|.
name|revision
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|item
operator|.
name|number
operator|=
name|SVN_FS_FS__ITEM_INDEX_CHANGES
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|index_entries
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
comment|/* Now re-open r0, create proto-index files from our entries and          rewrite the index section of r0. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file_writable
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_index_from_p2l_entries
argument_list|(
operator|&
name|p2l_proto_index
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|index_entries
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_index_from_p2l_entries
argument_list|(
operator|&
name|l2p_proto_index
argument_list|,
name|fs
argument_list|,
name|index_entries
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__add_index_data
argument_list|(
name|fs
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|l2p_proto_index
argument_list|,
name|p2l_proto_index
argument_list|,
literal|0
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_revision_zero
argument_list|,
literal|"PLAIN\nEND\nENDREP\n"
literal|"id: 0.0.r0/17\n"
literal|"type: dir\n"
literal|"count: 0\n"
literal|"text: 0 0 4 4 "
literal|"2d2977d1c96f487abe4a1e202dd03b4e\n"
literal|"cpath: /\n"
literal|"\n\n17 107\n"
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|path_revision_zero
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set a date on revision 0. */
name|date
operator|.
name|data
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|date
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|date
operator|.
name|data
argument_list|)
expr_stmt|;
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|proplist
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_revision_proplist
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|proplist
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__create_file_tree
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|shard_size
parameter_list|,
name|svn_boolean_t
name|use_log_addressing
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|format
operator|=
name|format
expr_stmt|;
comment|/* Use an appropriate sharding mode if supported by the format. */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_LAYOUT_FORMAT_OPTION_FORMAT
condition|)
name|ffd
operator|->
name|max_files_per_dir
operator|=
name|shard_size
expr_stmt|;
else|else
name|ffd
operator|->
name|max_files_per_dir
operator|=
literal|0
expr_stmt|;
comment|/* Select the addressing mode depending on the format. */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_LOG_ADDRESSING_FORMAT
condition|)
name|ffd
operator|->
name|use_log_addressing
operator|=
name|use_log_addressing
expr_stmt|;
else|else
name|ffd
operator|->
name|use_log_addressing
operator|=
name|FALSE
expr_stmt|;
comment|/* Create the revision data directories. */
if|if
condition|(
name|ffd
operator|->
name|max_files_per_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_fs_fs__path_rev_shard
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the revprops directory. */
if|if
condition|(
name|ffd
operator|->
name|max_files_per_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_fs_fs__path_revprops_shard
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the transaction directory. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_fs_fs__path_txns_dir
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the protorevs directory. */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_fs_fs__path_txn_proto_revs
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the 'current' file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|svn_fs_fs__path_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_current
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the 'uuid' file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|svn_fs_fs__path_lock
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_uuid
argument_list|(
name|fs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the fsfs.conf file if supported.  Older server versions would      simply ignore the file but that might result in a different behavior      than with the later releases.  Also, hotcopy would ignore, i.e. not      copy, a fsfs.conf with old formats. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_CONFIG_FILE
condition|)
name|SVN_ERR
argument_list|(
name|write_config
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_config
argument_list|(
name|ffd
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|fs
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Global configuration options. */
name|SVN_ERR
argument_list|(
name|read_global_config
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add revision 0. */
name|SVN_ERR
argument_list|(
name|write_revision_zero
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the min unpacked rev file. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|svn_fs_fs__path_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the txn-current file if the repository supports      the transaction sequence file. */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|svn_fs_fs__path_txn_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|svn_fs_fs__path_txn_current_lock
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffd
operator|->
name|youngest_rev_cache
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__create
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|format
init|=
name|SVN_FS_FS__FORMAT_NUMBER
decl_stmt|;
name|int
name|shard_size
init|=
name|SVN_FS_FS_DEFAULT_MAX_FILES_PER_DIR
decl_stmt|;
name|svn_boolean_t
name|log_addressing
decl_stmt|;
comment|/* Process the given filesystem config. */
if|if
condition|(
name|fs
operator|->
name|config
condition|)
block|{
name|svn_version_t
modifier|*
name|compatible_version
decl_stmt|;
specifier|const
name|char
modifier|*
name|shard_size_str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__compatible_version
argument_list|(
operator|&
name|compatible_version
argument_list|,
name|fs
operator|->
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* select format number */
switch|switch
condition|(
name|compatible_version
operator|->
name|minor
condition|)
block|{
case|case
literal|0
case|:
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"FSFS is not compatible with Subversion prior to 1.1"
argument_list|)
argument_list|)
return|;
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
name|format
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|format
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|format
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
name|format
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|format
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
name|format
operator|=
name|SVN_FS_FS__FORMAT_NUMBER
expr_stmt|;
block|}
name|shard_size_str
operator|=
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_FSFS_SHARD_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|shard_size_str
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_strtoi64
argument_list|(
operator|&
name|val
argument_list|,
name|shard_size_str
argument_list|,
literal|0
argument_list|,
name|APR_INT32_MAX
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|shard_size
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
block|}
block|}
name|log_addressing
operator|=
name|svn_hash__get_bool
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_FSFS_LOG_ADDRESSING
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Actual FS creation. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__create_file_tree
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|format
argument_list|,
name|shard_size
argument_list|,
name|log_addressing
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This filesystem is ready.  Stamp it with a format number. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_format
argument_list|(
name|fs
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_uuid
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|uuid
parameter_list|,
specifier|const
name|char
modifier|*
name|instance_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid_path
init|=
name|path_uuid
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|contents
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uuid
condition|)
name|uuid
operator|=
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance_id
condition|)
name|instance_id
operator|=
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|contents
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|contents
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_INSTANCE_ID_FORMAT
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|contents
argument_list|,
name|instance_id
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|contents
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* We use the permissions of the 'current' file, because the 'uuid'      file does not exist during repository creation. */
name|SVN_ERR
argument_list|(
name|svn_io_write_atomic
argument_list|(
name|uuid_path
argument_list|,
name|contents
operator|->
name|data
argument_list|,
name|contents
operator|->
name|len
argument_list|,
name|svn_fs_fs__path_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
comment|/* perms */
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_INSTANCE_ID_FORMAT
condition|)
name|ffd
operator|->
name|instance_id
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|instance_id
argument_list|)
expr_stmt|;
else|else
name|ffd
operator|->
name|instance_id
operator|=
name|fs
operator|->
name|uuid
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/** Node origin lazy cache. */
end_comment

begin_comment
comment|/* If directory PATH does not exist, create it and give it the same    permissions as FS_path.*/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__ensure_dir_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_dir_make
argument_list|(
name|path
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We successfully created a new directory.  Dup the permissions      from FS->path. */
return|return
name|svn_io_copy_perms
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *NODE_ORIGINS to a hash mapping 'const char *' node IDs to    'svn_string_t *' node revision IDs.  Use POOL for allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_node_origins_from_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|node_origins
parameter_list|,
specifier|const
name|char
modifier|*
name|node_origins_file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|fd
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
operator|*
name|node_origins
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|fd
argument_list|,
name|node_origins_file
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|node_origins
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_hash_read2
argument_list|(
operator|*
name|node_origins
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_quick_wrapf
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"malformed node origin data in '%s'"
argument_list|)
argument_list|,
name|node_origins_file
argument_list|)
return|;
return|return
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_node_origin
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|origin_id
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|node_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|node_origins
decl_stmt|;
operator|*
name|origin_id
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_origins_from_file
argument_list|(
name|fs
argument_list|,
operator|&
name|node_origins
argument_list|,
name|svn_fs_fs__path_node_origin
argument_list|(
name|fs
argument_list|,
name|node_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_origins
condition|)
block|{
name|char
name|node_id_ptr
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|len
init|=
name|svn__ui64tobase36
argument_list|(
name|node_id_ptr
argument_list|,
name|node_id
operator|->
name|number
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|origin_id_str
init|=
name|apr_hash_get
argument_list|(
name|node_origins
argument_list|,
name|node_id_ptr
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin_id_str
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_parse
argument_list|(
name|origin_id
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|origin_id_str
operator|->
name|data
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for svn_fs_fs__set_node_origin.  Takes a NODE_ID/NODE_REV_ID    pair and adds it to the NODE_ORIGINS_PATH file.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_node_origins_for_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|node_origins_path
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|node_id
parameter_list|,
name|svn_string_t
modifier|*
name|node_rev_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_tmp
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_hash_t
modifier|*
name|origins_hash
decl_stmt|;
name|svn_string_t
modifier|*
name|old_node_rev_id
decl_stmt|;
comment|/* the hash serialization functions require strings as keys */
name|char
name|node_id_ptr
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|len
init|=
name|svn__ui64tobase36
argument_list|(
name|node_id_ptr
argument_list|,
name|node_id
operator|->
name|number
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_dir_exists
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_NODE_ORIGINS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the previously existing origins (if any), and merge our      update with it. */
name|SVN_ERR
argument_list|(
name|get_node_origins_from_file
argument_list|(
name|fs
argument_list|,
operator|&
name|origins_hash
argument_list|,
name|node_origins_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origins_hash
condition|)
name|origins_hash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|old_node_rev_id
operator|=
name|apr_hash_get
argument_list|(
name|origins_hash
argument_list|,
name|node_id_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_node_rev_id
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|node_rev_id
argument_list|,
name|old_node_rev_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node origin for '%s' exists with a different "
literal|"value (%s) than what we were about to store "
literal|"(%s)"
argument_list|)
argument_list|,
name|node_id_ptr
argument_list|,
name|old_node_rev_id
operator|->
name|data
argument_list|,
name|node_rev_id
operator|->
name|data
argument_list|)
return|;
name|apr_hash_set
argument_list|(
name|origins_hash
argument_list|,
name|node_id_ptr
argument_list|,
name|len
argument_list|,
name|node_rev_id
argument_list|)
expr_stmt|;
comment|/* Sure, there's a race condition here.  Two processes could be      trying to add different cache elements to the same file at the      same time, and the entries added by the first one to write will      be lost.  But this is just a cache of reconstructible data, so      we'll accept this problem in return for not having to deal with      locking overhead. */
comment|/* Create a temporary file, write out our hash, and close the file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
operator|&
name|path_tmp
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|node_origins_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|origins_hash
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rename the temp file as the real destination */
return|return
name|svn_io_file_rename
argument_list|(
name|path_tmp
argument_list|,
name|node_origins_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_node_origin
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|node_id
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|node_rev_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|svn_fs_fs__path_node_origin
argument_list|(
name|fs
argument_list|,
name|node_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|err
operator|=
name|set_node_origins_for_file
argument_list|(
name|fs
argument_list|,
name|filename
argument_list|,
name|node_id
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|node_rev_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EACCES
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* It's just a cache; stop trying if I can't write. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Revisions ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__revision_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_revision_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|svn_hash_gets
argument_list|(
name|table
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used for change_rev_prop_body below. */
end_comment

begin_struct
struct|struct
name|change_rev_prop_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The work-horse for svn_fs_fs__change_rev_prop, called with the FS    write lock.  This implements the svn_fs_fs__with_write_lock()    'body' callback type.  BATON is a 'struct change_rev_prop_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_rev_prop_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|change_rev_prop_baton
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_revision_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|old_value_p
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|wanted_value
init|=
operator|*
name|cb
operator|->
name|old_value_p
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|present_value
init|=
name|svn_hash_gets
argument_list|(
name|table
argument_list|,
name|cb
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|wanted_value
operator|!=
operator|!
name|present_value
operator|)
operator|||
operator|(
name|wanted_value
operator|&&
name|present_value
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|wanted_value
argument_list|,
name|present_value
argument_list|)
operator|)
condition|)
block|{
comment|/* What we expected isn't what we found. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PROP_BASEVALUE_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"revprop '%s' has unexpected value in "
literal|"filesystem"
argument_list|)
argument_list|,
name|cb
operator|->
name|name
argument_list|)
return|;
block|}
comment|/* Fall through. */
block|}
name|svn_hash_sets
argument_list|(
name|table
argument_list|,
name|cb
operator|->
name|name
argument_list|,
name|cb
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__set_revision_proplist
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|rev
argument_list|,
name|table
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__change_rev_prop
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|change_rev_prop_baton
name|cb
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|cb
operator|.
name|rev
operator|=
name|rev
expr_stmt|;
name|cb
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|cb
operator|.
name|old_value_p
operator|=
name|old_value_p
expr_stmt|;
name|cb
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|change_rev_prop_body
argument_list|,
operator|&
name|cb
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__info_format
parameter_list|(
name|int
modifier|*
name|fs_format
parameter_list|,
name|svn_version_t
modifier|*
modifier|*
name|supports_version
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|fs_format
operator|=
name|ffd
operator|->
name|format
expr_stmt|;
operator|*
name|supports_version
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_version_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|major
operator|=
name|SVN_VER_MAJOR
expr_stmt|;
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|minor
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|patch
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|tag
operator|=
literal|""
expr_stmt|;
switch|switch
condition|(
name|ffd
operator|->
name|format
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|minor
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|minor
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|minor
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|6
case|:
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|minor
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|7
case|:
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|minor
operator|=
literal|9
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SVN_DEBUG
if|#
directive|if
name|SVN_FS_FS__FORMAT_NUMBER
operator|!=
literal|7
error|#
directive|error
literal|"Need to add a 'case' statement here"
endif|#
directive|endif
endif|#
directive|endif
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__info_config_files
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|files
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|files
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|files
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

