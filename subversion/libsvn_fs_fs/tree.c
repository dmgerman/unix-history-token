begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tree.c : tree-like filesystem, built on DAG filesystem  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* The job of this layer is to take a filesystem with lots of node    sharing going on --- the real DAG filesystem as it appears in the    database --- and make it look and act like an ordinary tree    filesystem, with no sharing.     We do just-in-time cloning: you can walk from some unfinished    transaction's root down into directories and files shared with    committed revisions; as soon as you try to change something, the    appropriate nodes get cloned (and parent directory entries updated)    invisibly, behind your back.  Any other references you have to    nodes that have been cloned by other changes, even made by other    processes, are automatically updated to point to the right clones.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"key-gen.h"
end_include

begin_include
include|#
directive|include
file|"dag.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_comment
comment|/* ### I believe this constant will become internal to reps-strings.c.    ### see the comment in window_consumer() for more information. */
end_comment

begin_comment
comment|/* ### the comment also seems to need tweaking: the log file stuff    ### is no longer an issue... */
end_comment

begin_comment
comment|/* Data written to the filesystem through the svn_fs_apply_textdelta()    interface is cached in memory until the end of the data stream, or    until a size trigger is hit.  Define that trigger here (in bytes).    Setting the value to 0 will result in no filesystem buffering at    all.  The value only really matters when dealing with file contents    bigger than the value itself.  Above that point, large values here    allow the filesystem to buffer more data in memory before flushing    to the database, which increases memory usage but greatly decreases    the amount of disk access (and log-file generation) in database.    Smaller values will limit your overall memory consumption, but can    drastically hurt throughput by necessitating more write operations    to the database (which also generates more log-files).  */
end_comment

begin_define
define|#
directive|define
name|WRITE_BUFFER_SIZE
value|512000
end_define

begin_escape
end_escape

begin_comment
comment|/* The root structures.     Why do they contain different data?  Well, transactions are mutable    enough that it isn't safe to cache the DAG node for the root    directory or the hash of copyfrom data: somebody else might modify    them concurrently on disk!  (Why is the DAG node cache safer than    the root DAG node?  When cloning transaction DAG nodes in and out    of the cache, all of the possibly-mutable data from the    node_revision_t inside the dag_node_t is dropped.)  Additionally,    revisions are immutable enough that their DAG node cache can be    kept in the FS object and shared among multiple revision root    objects. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fs_rev_root_data_t
block|{
comment|/* A dag node for the revision's root directory. */
name|dag_node_t
modifier|*
name|root_dir
decl_stmt|;
comment|/* Cache structure for mapping const char * PATH to const char      *COPYFROM_STRING, so that paths_changed can remember all the      copyfrom information in the changes file.      COPYFROM_STRING has the format "REV PATH", or is the empty string if      the path was added without history. */
name|apr_hash_t
modifier|*
name|copyfrom_cache
decl_stmt|;
block|}
name|fs_rev_root_data_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|fs_txn_root_data_t
block|{
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
comment|/* Cache of txn DAG nodes (without their nested noderevs, because    * it's mutable). Same keys/values as ffd->rev_node_cache. */
name|svn_cache__t
modifier|*
name|txn_node_cache
decl_stmt|;
block|}
name|fs_txn_root_data_t
typedef|;
end_typedef

begin_comment
comment|/* Declared here to resolve the circular dependencies. */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|get_dag
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|dag_node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|needs_lock_cache
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_fs_root_t
modifier|*
name|make_revision_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|root_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|make_txn_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn
parameter_list|,
name|svn_revnum_t
name|base_rev
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*** Node Caching ***/
end_comment

begin_comment
comment|/* 1st level cache */
end_comment

begin_comment
comment|/* An entry in the first-level cache.  REVISION and PATH form the key that    will ultimately be matched.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cache_entry_t
block|{
comment|/* hash value derived from PATH, REVISION.      Used to short-circuit failed lookups. */
name|apr_uint32_t
name|hash_value
decl_stmt|;
comment|/* revision to which the NODE belongs */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* path of the NODE */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* cached value of strlen(PATH). */
name|apr_size_t
name|path_len
decl_stmt|;
comment|/* the node allocated in the cache's pool. NULL for empty entries. */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
block|}
name|cache_entry_t
typedef|;
end_typedef

begin_comment
comment|/* Number of entries in the cache.  Keep this low to keep pressure on the    CPU caches low as well.  A binary value is most efficient.  If we walk    a directory tree, we want enough entries to store nodes for all files    without overwriting the nodes for the parent folder.  That way, there    will be no unnecessary misses (except for a few random ones caused by    hash collision).     The actual number of instances may be higher but entries that got    overwritten are no longer visible.  */
end_comment

begin_enum
enum|enum
block|{
name|BUCKET_COUNT
init|=
literal|256
block|}
enum|;
end_enum

begin_comment
comment|/* Each pool that has received a DAG node, will hold at least on lock on    our cache to ensure that the node remains valid despite being allocated    in the cache's pool.  This is the structure to represent the lock.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cache_lock_t
block|{
comment|/* pool holding the lock */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* cache being locked */
name|fs_fs_dag_cache_t
modifier|*
name|cache
decl_stmt|;
comment|/* next lock. NULL at EOL */
name|struct
name|cache_lock_t
modifier|*
name|next
decl_stmt|;
comment|/* previous lock. NULL at list head. Only then this==cache->first_lock */
name|struct
name|cache_lock_t
modifier|*
name|prev
decl_stmt|;
block|}
name|cache_lock_t
typedef|;
end_typedef

begin_comment
comment|/* The actual cache structure.  All nodes will be allocated in POOL.    When the number of INSERTIONS (i.e. objects created form that pool)    exceeds a certain threshold, the pool will be cleared and the cache    with it.     To ensure that nodes returned from this structure remain valid, the    cache will get locked for the lifetime of the _receiving_ pools (i.e.    those in which we would allocate the node if there was no cache.).    The cache will only be cleared FIRST_LOCK is 0.  */
end_comment

begin_struct
struct|struct
name|fs_fs_dag_cache_t
block|{
comment|/* fixed number of (possibly empty) cache entries */
name|cache_entry_t
name|buckets
index|[
name|BUCKET_COUNT
index|]
decl_stmt|;
comment|/* pool used for all node allocation */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* number of entries created from POOL since the last cleanup */
name|apr_size_t
name|insertions
decl_stmt|;
comment|/* Property lookups etc. have a very high locality (75% re-hit).      Thus, remember the last hit location for optimistic lookup. */
name|apr_size_t
name|last_hit
decl_stmt|;
comment|/* List of receiving pools that are still alive. */
name|cache_lock_t
modifier|*
name|first_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Cleanup function to be called when a receiving pool gets cleared.    Unlocks the cache once.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|unlock_cache
parameter_list|(
name|void
modifier|*
name|baton_void
parameter_list|)
block|{
name|cache_lock_t
modifier|*
name|lock
init|=
name|baton_void
decl_stmt|;
comment|/* remove lock from chain. Update the head */
if|if
condition|(
name|lock
operator|->
name|next
condition|)
name|lock
operator|->
name|next
operator|->
name|prev
operator|=
name|lock
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|prev
condition|)
name|lock
operator|->
name|prev
operator|->
name|next
operator|=
name|lock
operator|->
name|next
expr_stmt|;
else|else
name|lock
operator|->
name|cache
operator|->
name|first_lock
operator|=
name|lock
operator|->
name|next
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Cleanup function to be called when the cache itself gets destroyed.    In that case, we must unregister all unlock requests.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|unregister_locks
parameter_list|(
name|void
modifier|*
name|baton_void
parameter_list|)
block|{
name|fs_fs_dag_cache_t
modifier|*
name|cache
init|=
name|baton_void
decl_stmt|;
name|cache_lock_t
modifier|*
name|lock
decl_stmt|;
for|for
control|(
name|lock
operator|=
name|cache
operator|->
name|first_lock
init|;
name|lock
condition|;
name|lock
operator|=
name|lock
operator|->
name|next
control|)
name|apr_pool_cleanup_kill
argument_list|(
name|lock
operator|->
name|pool
argument_list|,
name|lock
argument_list|,
name|unlock_cache
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|fs_fs_dag_cache_t
modifier|*
name|svn_fs_fs__create_dag_cache
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_dag_cache_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|result
argument_list|,
name|unregister_locks
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Prevent the entries in CACHE from being destroyed, for as long as the    POOL lives.  */
end_comment

begin_function
specifier|static
name|void
name|lock_cache
parameter_list|(
name|fs_fs_dag_cache_t
modifier|*
name|cache
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* we only need to lock / unlock once per pool.  Since we will often ask      for multiple nodes with the same pool, we can reduce the overhead.      However, if e.g. pools are being used in an alternating pattern,      we may lock the cache more than once for the same pool (and register      just as many cleanup actions).    */
name|cache_lock_t
modifier|*
name|lock
init|=
name|cache
operator|->
name|first_lock
decl_stmt|;
comment|/* try to find an existing lock for POOL.      But limit the time spent on chasing pointers.  */
name|int
name|limiter
init|=
literal|8
decl_stmt|;
while|while
condition|(
name|lock
operator|&&
operator|--
name|limiter
condition|)
if|if
condition|(
name|lock
operator|->
name|pool
operator|==
name|pool
condition|)
return|return;
comment|/* create a new lock and put it at the beginning of the lock chain */
name|lock
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|cache
operator|=
name|cache
expr_stmt|;
name|lock
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|lock
operator|->
name|next
operator|=
name|cache
operator|->
name|first_lock
expr_stmt|;
name|lock
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|first_lock
condition|)
name|cache
operator|->
name|first_lock
operator|->
name|prev
operator|=
name|lock
expr_stmt|;
name|cache
operator|->
name|first_lock
operator|=
name|lock
expr_stmt|;
comment|/* instruct POOL to remove the look upon cleanup */
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|lock
argument_list|,
name|unlock_cache
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clears the CACHE at regular intervals (destroying all cached nodes)  */
end_comment

begin_function
specifier|static
name|void
name|auto_clear_dag_cache
parameter_list|(
name|fs_fs_dag_cache_t
modifier|*
name|cache
parameter_list|)
block|{
if|if
condition|(
name|cache
operator|->
name|first_lock
operator|==
name|NULL
operator|&&
name|cache
operator|->
name|insertions
operator|>
name|BUCKET_COUNT
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|cache
operator|->
name|pool
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cache
operator|->
name|buckets
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cache
operator|->
name|buckets
argument_list|)
argument_list|)
expr_stmt|;
name|cache
operator|->
name|insertions
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For the given REVISION and PATH, return the respective entry in CACHE.    If the entry is empty, its NODE member will be NULL and the caller    may then set it to the corresponding DAG node allocated in CACHE->POOL.  */
end_comment

begin_function
specifier|static
name|cache_entry_t
modifier|*
name|cache_lookup
parameter_list|(
name|fs_fs_dag_cache_t
modifier|*
name|cache
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|,
name|bucket_index
decl_stmt|;
name|apr_size_t
name|path_len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|apr_uint32_t
name|hash_value
init|=
operator|(
name|apr_uint32_t
operator|)
name|revision
decl_stmt|;
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* "randomizing" / distributing factor used in our hash function */
specifier|const
name|apr_uint32_t
name|factor
init|=
literal|0xd1f3da69
decl_stmt|;
endif|#
directive|endif
comment|/* optimistic lookup: hit the same bucket again? */
name|cache_entry_t
modifier|*
name|result
init|=
operator|&
name|cache
operator|->
name|buckets
index|[
name|cache
operator|->
name|last_hit
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|revision
operator|==
name|revision
operator|)
operator|&&
operator|(
name|result
operator|->
name|path_len
operator|==
name|path_len
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|result
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/* need to do a full lookup.  Calculate the hash value      (HASH_VALUE has been initialized to REVISION). */
name|i
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* We relax the dependency chain between iterations by processing      two chunks from the input per hash_value self-multiplication.      The HASH_VALUE update latency is now 1 MUL latency + 1 ADD latency      per 2 chunks instead of 1 chunk.    */
for|for
control|(
init|;
name|i
operator|+
literal|8
operator|<=
name|path_len
condition|;
name|i
operator|+=
literal|8
control|)
name|hash_value
operator|=
name|hash_value
operator|*
name|factor
operator|*
name|factor
operator|+
operator|(
operator|*
operator|(
specifier|const
name|apr_uint32_t
operator|*
operator|)
operator|(
name|path
operator|+
name|i
operator|)
operator|*
name|factor
operator|+
operator|*
operator|(
specifier|const
name|apr_uint32_t
operator|*
operator|)
operator|(
name|path
operator|+
name|i
operator|+
literal|4
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|i
operator|<
name|path_len
condition|;
operator|++
name|i
control|)
comment|/* Help GCC to minimize the HASH_VALUE update latency by splitting the        MUL 33 of the naive implementation: h = h * 33 + path[i].  This        shortens the dependency chain from 1 shift + 2 ADDs to 1 shift + 1 ADD.      */
name|hash_value
operator|=
name|hash_value
operator|*
literal|32
operator|+
operator|(
name|hash_value
operator|+
operator|(
name|unsigned
name|char
operator|)
name|path
index|[
name|i
index|]
operator|)
expr_stmt|;
name|bucket_index
operator|=
name|hash_value
operator|+
operator|(
name|hash_value
operator|>>
literal|16
operator|)
expr_stmt|;
name|bucket_index
operator|=
operator|(
name|bucket_index
operator|+
operator|(
name|bucket_index
operator|>>
literal|8
operator|)
operator|)
operator|%
name|BUCKET_COUNT
expr_stmt|;
comment|/* access the corresponding bucket and remember its location */
name|result
operator|=
operator|&
name|cache
operator|->
name|buckets
index|[
name|bucket_index
index|]
expr_stmt|;
name|cache
operator|->
name|last_hit
operator|=
name|bucket_index
expr_stmt|;
comment|/* if it is *NOT* a match,  clear the bucket, expect the caller to fill      in the node and count it as an insertion */
if|if
condition|(
operator|(
name|result
operator|->
name|hash_value
operator|!=
name|hash_value
operator|)
operator|||
operator|(
name|result
operator|->
name|revision
operator|!=
name|revision
operator|)
operator|||
operator|(
name|result
operator|->
name|path_len
operator|!=
name|path_len
operator|)
operator|||
name|memcmp
argument_list|(
name|result
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
condition|)
block|{
name|result
operator|->
name|hash_value
operator|=
name|hash_value
expr_stmt|;
name|result
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|path_len
operator|<
name|path_len
condition|)
name|result
operator|->
name|path
operator|=
name|apr_palloc
argument_list|(
name|cache
operator|->
name|pool
argument_list|,
name|path_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|->
name|path_len
operator|=
name|path_len
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|path_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|cache
operator|->
name|insertions
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* 2nd level cache */
end_comment

begin_comment
comment|/* Find and return the DAG node cache for ROOT and the key that    should be used for PATH. */
end_comment

begin_function
specifier|static
name|void
name|locate_cache
parameter_list|(
name|svn_cache__t
modifier|*
modifier|*
name|cache
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|key
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
block|{
name|fs_txn_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|cache
condition|)
operator|*
name|cache
operator|=
name|frd
operator|->
name|txn_node_cache
expr_stmt|;
if|if
condition|(
name|key
operator|&&
name|path
condition|)
operator|*
name|key
operator|=
name|path
expr_stmt|;
block|}
else|else
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|root
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|cache
condition|)
operator|*
name|cache
operator|=
name|ffd
operator|->
name|rev_node_cache
expr_stmt|;
if|if
condition|(
name|key
operator|&&
name|path
condition|)
operator|*
name|key
operator|=
name|svn_fs_fs__combine_number_and_string
argument_list|(
name|root
operator|->
name|rev
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return NODE for PATH from ROOT's node cache, or NULL if the node    isn't cached; read it from the FS. *NODE remains valid until either    POOL or the FS gets cleared or destroyed (whichever comes first).     Since locking can be expensive and POOL may be long-living, for    nodes that will not need to survive the next call to this function,    set NEEDS_LOCK_CACHE to FALSE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dag_node_cache_get
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|needs_lock_cache
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|found
decl_stmt|;
name|dag_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|svn_cache__t
modifier|*
name|cache
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|path
operator|==
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
block|{
comment|/* immutable DAG node. use the global caches for it */
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|root
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|cache_entry_t
modifier|*
name|bucket
decl_stmt|;
name|auto_clear_dag_cache
argument_list|(
name|ffd
operator|->
name|dag_node_cache
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|cache_lookup
argument_list|(
name|ffd
operator|->
name|dag_node_cache
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|->
name|node
operator|==
name|NULL
condition|)
block|{
name|locate_cache
argument_list|(
operator|&
name|cache
argument_list|,
operator|&
name|key
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|node
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
name|key
argument_list|,
name|ffd
operator|->
name|dag_node_cache
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
name|node
condition|)
block|{
comment|/* Patch up the FS, since this might have come from an old FS               * object. */
name|svn_fs_fs__dag_set_fs
argument_list|(
name|node
argument_list|,
name|root
operator|->
name|fs
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|node
operator|=
name|node
expr_stmt|;
block|}
block|}
else|else
block|{
name|node
operator|=
name|bucket
operator|->
name|node
expr_stmt|;
block|}
comment|/* if we found a node, make sure it remains valid at least as long          as it would when allocated in POOL. */
if|if
condition|(
name|node
operator|&&
name|needs_lock_cache
condition|)
name|lock_cache
argument_list|(
name|ffd
operator|->
name|dag_node_cache
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DAG is mutable / may become invalid. Use the TXN-local cache */
name|locate_cache
argument_list|(
operator|&
name|cache
argument_list|,
operator|&
name|key
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|node
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
name|key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
name|node
condition|)
block|{
comment|/* Patch up the FS, since this might have come from an old FS           * object. */
name|svn_fs_fs__dag_set_fs
argument_list|(
name|node
argument_list|,
name|root
operator|->
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|node_p
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add the NODE for PATH to ROOT's node cache. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dag_node_cache_set
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cache__t
modifier|*
name|cache
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|path
operator|==
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Do *not* attempt to dup and put the node into L1.    * dup() is twice as expensive as an L2 lookup (which will set also L1).    */
name|locate_cache
argument_list|(
operator|&
name|cache
argument_list|,
operator|&
name|key
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_cache__set
argument_list|(
name|cache
argument_list|,
name|key
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton for find_descendents_in_cache. */
end_comment

begin_struct
struct|struct
name|fdic_baton
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If the given item is a descendent of BATON->PATH, push  * it onto BATON->LIST (copying into BATON->POOL).  Implements  * the svn_iter_apr_hash_cb_t prototype. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_descendents_in_cache
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|fdic_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|item_path
init|=
name|key
decl_stmt|;
if|if
condition|(
name|svn_fspath__skip_ancestor
argument_list|(
name|b
operator|->
name|path
argument_list|,
name|item_path
argument_list|)
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|b
operator|->
name|list
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|item_path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Invalidate cache entries for PATH and any of its children.  This    should *only* be called on a transaction root! */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dag_node_cache_invalidate
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|fdic_baton
name|b
decl_stmt|;
name|svn_cache__t
modifier|*
name|cache
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|b
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|b
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|b
operator|.
name|list
operator|=
name|apr_array_make
argument_list|(
name|b
operator|.
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|root
operator|->
name|is_txn_root
argument_list|)
expr_stmt|;
name|locate_cache
argument_list|(
operator|&
name|cache
argument_list|,
name|NULL
argument_list|,
name|root
argument_list|,
name|NULL
argument_list|,
name|b
operator|.
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__iter
argument_list|(
name|NULL
argument_list|,
name|cache
argument_list|,
name|find_descendents_in_cache
argument_list|,
operator|&
name|b
argument_list|,
name|b
operator|.
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|b
operator|.
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
operator|.
name|list
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|descendent
init|=
name|APR_ARRAY_IDX
argument_list|(
name|b
operator|.
name|list
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|cache
argument_list|,
name|descendent
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|b
operator|.
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Creating transaction and revision root nodes.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__txn_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint32_t
name|flags
init|=
literal|0
decl_stmt|;
name|apr_hash_t
modifier|*
name|txnprops
decl_stmt|;
comment|/* Look for the temporary txn props representing 'flags'. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__txn_proplist
argument_list|(
operator|&
name|txnprops
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnprops
condition|)
block|{
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_OOD
argument_list|)
condition|)
name|flags
operator||=
name|SVN_FS_TXN_CHECK_OOD
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_LOCKS
argument_list|)
condition|)
name|flags
operator||=
name|SVN_FS_TXN_CHECK_LOCKS
expr_stmt|;
block|}
return|return
name|make_txn_root
argument_list|(
name|root_p
argument_list|,
name|txn
operator|->
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|txn
operator|->
name|base_rev
argument_list|,
name|flags
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__revision_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|root_dir
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_revision_root
argument_list|(
operator|&
name|root_dir
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_p
operator|=
name|make_revision_root
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|root_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Getting dag nodes for roots.  */
end_comment

begin_comment
comment|/* Set *NODE_P to a freshly opened dag node referring to the root    directory of ROOT, allocating from POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|root_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
block|{
comment|/* It's a transaction root.  Open a fresh copy.  */
return|return
name|svn_fs_fs__dag_txn_root
argument_list|(
name|node_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
return|;
block|}
else|else
block|{
comment|/* It's a revision root, so we already have its root directory          opened.  */
name|fs_rev_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|node_p
operator|=
name|svn_fs_fs__dag_dup
argument_list|(
name|frd
operator|->
name|root_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set *NODE_P to a mutable root directory for ROOT, cloning if    necessary, allocating in POOL.  ROOT must be a transaction root.    Use ERROR_PATH in error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mutable_root_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|error_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_fs_fs__dag_clone_root
argument_list|(
name|node_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
return|;
else|else
comment|/* If it's not a transaction root, we can't change its contents.  */
return|return
name|SVN_FS__ERR_NOT_MUTABLE
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|error_path
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Traversing directory paths.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|copy_id_inherit_t
block|{
name|copy_id_inherit_unknown
init|=
literal|0
block|,
name|copy_id_inherit_self
block|,
name|copy_id_inherit_parent
block|,
name|copy_id_inherit_new
block|}
name|copy_id_inherit_t
typedef|;
end_typedef

begin_comment
comment|/* A linked list representing the path from a node up to a root    directory.  We use this for cloning, and for operations that need    to deal with both a node and its parent directory.  For example, a    `delete' operation needs to know that the node actually exists, but    also needs to change the parent directory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|parent_path_t
block|{
comment|/* A node along the path.  This could be the final node, one of its      parents, or the root.  Every parent path ends with an element for      the root directory.  */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* The name NODE has in its parent directory.  This is zero for the      root directory, which (obviously) has no name in its parent.  */
name|char
modifier|*
name|entry
decl_stmt|;
comment|/* The parent of NODE, or zero if NODE is the root directory.  */
name|struct
name|parent_path_t
modifier|*
name|parent
decl_stmt|;
comment|/* The copy ID inheritance style. */
name|copy_id_inherit_t
name|copy_inherit
decl_stmt|;
comment|/* If copy ID inheritance style is copy_id_inherit_new, this is the      path which should be implicitly copied; otherwise, this is NULL. */
specifier|const
name|char
modifier|*
name|copy_src_path
decl_stmt|;
block|}
name|parent_path_t
typedef|;
end_typedef

begin_comment
comment|/* Return a text string describing the absolute path of parent_path    PARENT_PATH.  It will be allocated in POOL. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parent_path_path
parameter_list|(
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_so_far
init|=
literal|"/"
decl_stmt|;
if|if
condition|(
name|parent_path
operator|->
name|parent
condition|)
name|path_so_far
operator|=
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|parent_path
operator|->
name|entry
condition|?
name|svn_fspath__join
argument_list|(
name|path_so_far
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|pool
argument_list|)
else|:
name|path_so_far
return|;
block|}
end_function

begin_comment
comment|/* Return the FS path for the parent path chain object CHILD relative    to its ANCESTOR in the same chain, allocated in POOL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parent_path_relpath
parameter_list|(
name|parent_path_t
modifier|*
name|child
parameter_list|,
name|parent_path_t
modifier|*
name|ancestor
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_so_far
init|=
literal|""
decl_stmt|;
name|parent_path_t
modifier|*
name|this_node
init|=
name|child
decl_stmt|;
while|while
condition|(
name|this_node
operator|!=
name|ancestor
condition|)
block|{
name|assert
argument_list|(
name|this_node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|path_so_far
operator|=
name|svn_relpath_join
argument_list|(
name|this_node
operator|->
name|entry
argument_list|,
name|path_so_far
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|this_node
operator|=
name|this_node
operator|->
name|parent
expr_stmt|;
block|}
return|return
name|path_so_far
return|;
block|}
end_function

begin_comment
comment|/* Choose a copy ID inheritance method *INHERIT_P to be used in the    event that immutable node CHILD in FS needs to be made mutable.  If    the inheritance method is copy_id_inherit_new, also return a    *COPY_SRC_PATH on which to base the new copy ID (else return NULL    for that path).  CHILD must have a parent (it cannot be the root    node).  TXN_ID is the transaction in which these items might be    mutable.  Allocations are taken from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_copy_inheritance
parameter_list|(
name|copy_id_inherit_t
modifier|*
name|inherit_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|copy_src_path
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|parent_path_t
modifier|*
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|child_id
decl_stmt|,
modifier|*
name|parent_id
decl_stmt|,
modifier|*
name|copyroot_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_copy_id
decl_stmt|,
modifier|*
name|parent_copy_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|id_path
init|=
name|NULL
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copyroot_root
decl_stmt|;
name|dag_node_t
modifier|*
name|copyroot_node
decl_stmt|;
name|svn_revnum_t
name|copyroot_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyroot_path
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
operator|&&
name|child
operator|->
name|parent
operator|&&
name|txn_id
argument_list|)
expr_stmt|;
comment|/* Initialize some convenience variables. */
name|child_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|child
operator|->
name|node
argument_list|)
expr_stmt|;
name|parent_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|child
operator|->
name|parent
operator|->
name|node
argument_list|)
expr_stmt|;
name|child_copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|child_id
argument_list|)
expr_stmt|;
name|parent_copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|parent_id
argument_list|)
expr_stmt|;
comment|/* If this child is already mutable, we have nothing to do. */
if|if
condition|(
name|svn_fs_fs__id_txn_id
argument_list|(
name|child_id
argument_list|)
condition|)
block|{
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_self
expr_stmt|;
operator|*
name|copy_src_path
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* From this point on, we'll assume that the child will just take      its copy ID from its parent. */
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_parent
expr_stmt|;
operator|*
name|copy_src_path
operator|=
name|NULL
expr_stmt|;
comment|/* Special case: if the child's copy ID is '0', use the parent's      copy ID. */
if|if
condition|(
name|strcmp
argument_list|(
name|child_copy_id
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Compare the copy IDs of the child and its parent.  If they are      the same, then the child is already on the same branch as the      parent, and should use the same mutability copy ID that the      parent will use. */
if|if
condition|(
name|svn_fs_fs__key_compare
argument_list|(
name|child_copy_id
argument_list|,
name|parent_copy_id
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the child is on the same branch that the parent is on, the      child should just use the same copy ID that the parent would use.      Else, the child needs to generate a new copy ID to use should it      need to be made mutable.  We will claim that child is on the same      branch as its parent if the child itself is not a branch point,      or if it is a branch point that we are accessing via its original      copy destination path. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyroot
argument_list|(
operator|&
name|copyroot_rev
argument_list|,
operator|&
name|copyroot_path
argument_list|,
name|child
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|copyroot_root
argument_list|,
name|fs
argument_list|,
name|copyroot_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|copyroot_node
argument_list|,
name|copyroot_root
argument_list|,
name|copyroot_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|copyroot_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|copyroot_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__id_compare
argument_list|(
name|copyroot_id
argument_list|,
name|child_id
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Determine if we are looking at the child via its original path or      as a subtree item of a copied tree. */
name|id_path
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|child
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|id_path
argument_list|,
name|parent_path_path
argument_list|(
name|child
argument_list|,
name|pool
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_self
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We are pretty sure that the child node is an unedited nested      branched node.  When it needs to be made mutable, it should claim      a new copy ID. */
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_new
expr_stmt|;
operator|*
name|copy_src_path
operator|=
name|id_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new parent_path_t node from POOL, referring to NODE,    ENTRY, PARENT, and COPY_ID.  */
end_comment

begin_function
specifier|static
name|parent_path_t
modifier|*
name|make_parent_path
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|entry
parameter_list|,
name|parent_path_t
modifier|*
name|parent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parent_path
argument_list|)
argument_list|)
decl_stmt|;
name|parent_path
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|parent_path
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|parent_path
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|copy_id_inherit_unknown
expr_stmt|;
name|parent_path
operator|->
name|copy_src_path
operator|=
name|NULL
expr_stmt|;
return|return
name|parent_path
return|;
block|}
end_function

begin_comment
comment|/* Flags for open_path.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|open_path_flags_t
block|{
comment|/* The last component of the PATH need not exist.  (All parent      directories must exist, as usual.)  If the last component doesn't      exist, simply leave the `node' member of the bottom parent_path      component zero.  */
name|open_path_last_optional
init|=
literal|1
block|,
comment|/* When this flag is set, don't bother to lookup the DAG node in      our caches because we already tried this.  Ignoring this flag      has no functional impact.  */
name|open_path_uncached
init|=
literal|2
block|,
comment|/* The caller does not care about the parent node chain but only      the final DAG node. */
name|open_path_node_only
init|=
literal|4
block|}
name|open_path_flags_t
typedef|;
end_typedef

begin_comment
comment|/* Open the node identified by PATH in ROOT, allocating in POOL.  Set    *PARENT_PATH_P to a path from the node up to ROOT.  The resulting    **PARENT_PATH_P value is guaranteed to contain at least one    *element, for the root directory.  PATH must be in canonical form.     If resulting *PARENT_PATH_P will eventually be made mutable and    modified, or if copy ID inheritance information is otherwise    needed, TXN_ID should be the ID of the mutability transaction.  If    TXN_ID is NULL, no copy ID inheritance information will be    calculated for the *PARENT_PATH_P chain.     If FLAGS& open_path_last_optional is zero, return the error    SVN_ERR_FS_NOT_FOUND if the node PATH refers to does not exist.  If    non-zero, require all the parent directories to exist as normal,    but if the final path component doesn't exist, simply return a path    whose bottom `node' member is zero.  This option is useful for    callers that create new nodes --- we find the parent directory for    them, and tell them whether the entry exists already.     The remaining bits in FLAGS are hints that allow this function    to take shortcuts based on knowledge that the caller provides,    such as the caller is not actually being interested in PARENT_PATH_P,    but only in (*PARENT_PATH_P)->NODE.     NOTE: Public interfaces which only *read* from the filesystem    should not call this function directly, but should instead use    get_dag(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_path
parameter_list|(
name|parent_path_t
modifier|*
modifier|*
name|parent_path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|dag_node_t
modifier|*
name|here
init|=
name|NULL
decl_stmt|;
comment|/* The directory we're currently looking at.  */
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
comment|/* The path from HERE up to the root. */
specifier|const
name|char
modifier|*
name|rest
decl_stmt|;
comment|/* The portion of PATH we haven't traversed yet.  */
comment|/* ensure a canonical path representation */
specifier|const
name|char
modifier|*
name|path_so_far
init|=
literal|"/"
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* callers often traverse the tree in some path-based order.  That means      a sibling of PATH has been presently accessed.  Try to start the lookup      directly at the parent node, if the caller did not requested the full      parent chain. */
specifier|const
name|char
modifier|*
name|directory
decl_stmt|;
name|assert
argument_list|(
name|svn_fs__is_canonical_abspath
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|open_path_node_only
condition|)
block|{
name|directory
operator|=
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|directory
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
comment|/* root nodes are covered anyway */
name|SVN_ERR
argument_list|(
name|dag_node_cache_get
argument_list|(
operator|&
name|here
argument_list|,
name|root
argument_list|,
name|directory
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* did the shortcut work? */
if|if
condition|(
name|here
condition|)
block|{
name|path_so_far
operator|=
name|directory
expr_stmt|;
name|rest
operator|=
name|path
operator|+
name|strlen
argument_list|(
name|directory
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Make a parent_path item for the root node, using its own current          copy id.  */
name|SVN_ERR
argument_list|(
name|root_node
argument_list|(
operator|&
name|here
argument_list|,
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rest
operator|=
name|path
operator|+
literal|1
expr_stmt|;
comment|/* skip the leading '/', it saves in iteration */
block|}
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|here
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|copy_id_inherit_self
expr_stmt|;
comment|/* Whenever we are at the top of this loop:      - HERE is our current directory,      - ID is the node revision ID of HERE,      - REST is the path we're going to find in HERE, and      - PARENT_PATH includes HERE and all its parents.  */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
name|dag_node_t
modifier|*
name|child
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Parse out the next entry from the path.  */
name|entry
operator|=
name|svn_fs__next_entry_name
argument_list|(
operator|&
name|next
argument_list|,
name|rest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Calculate the path traversed thus far. */
name|path_so_far
operator|=
name|svn_fspath__join
argument_list|(
name|path_so_far
argument_list|,
name|entry
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry
operator|==
literal|'\0'
condition|)
block|{
comment|/* Given the behavior of svn_fs__next_entry_name(), this              happens when the path either starts or ends with a slash.              In either case, we stay put: the current directory stays              the same, and we add nothing to the parent path. */
name|child
operator|=
name|here
expr_stmt|;
block|}
else|else
block|{
name|copy_id_inherit_t
name|inherit
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_path
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|dag_node_t
modifier|*
name|cached_node
init|=
name|NULL
decl_stmt|;
comment|/* If we found a directory entry, follow it.  First, we              check our node cache, and, failing that, we hit the DAG              layer.  Don't bother to contact the cache for the last              element if we already know the lookup to fail for the              complete path. */
if|if
condition|(
name|next
operator|||
operator|!
operator|(
name|flags
operator|&
name|open_path_uncached
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|dag_node_cache_get
argument_list|(
operator|&
name|cached_node
argument_list|,
name|root
argument_list|,
name|path_so_far
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_node
condition|)
name|child
operator|=
name|cached_node
expr_stmt|;
else|else
name|err
operator|=
name|svn_fs_fs__dag_open
argument_list|(
operator|&
name|child
argument_list|,
name|here
argument_list|,
name|entry
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* "file not found" requires special handling.  */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
comment|/* If this was the last path component, and the caller                  said it was optional, then don't return an error;                  just put a NULL node pointer in the path.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|open_path_last_optional
operator|)
operator|&&
operator|(
operator|!
name|next
operator|||
operator|*
name|next
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|NULL
argument_list|,
name|entry
argument_list|,
name|parent_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Build a better error message than svn_fs_fs__dag_open                      can provide, giving the root and full path name.  */
return|return
name|SVN_FS__NOT_FOUND
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
comment|/* Other errors we return normally.  */
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|open_path_node_only
condition|)
block|{
comment|/* Shortcut: the caller only wan'ts the final DAG node. */
name|parent_path
operator|->
name|node
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
comment|/* Now, make a parent_path item for CHILD. */
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|child
argument_list|,
name|entry
argument_list|,
name|parent_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|txn_id
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_copy_inheritance
argument_list|(
operator|&
name|inherit
argument_list|,
operator|&
name|copy_path
argument_list|,
name|fs
argument_list|,
name|parent_path
argument_list|,
name|txn_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|inherit
expr_stmt|;
name|parent_path
operator|->
name|copy_src_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|copy_path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Cache the node we found (if it wasn't already cached). */
if|if
condition|(
operator|!
name|cached_node
condition|)
name|SVN_ERR
argument_list|(
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|path_so_far
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Are we finished traversing the path?  */
if|if
condition|(
operator|!
name|next
condition|)
break|break;
comment|/* The path isn't finished yet; we'd better be in a directory.  */
if|if
condition|(
name|svn_fs_fs__dag_node_kind
argument_list|(
name|child
argument_list|)
operator|!=
name|svn_node_dir
condition|)
name|SVN_ERR_W
argument_list|(
name|SVN_FS__ERR_NOT_DIRECTORY
argument_list|(
name|fs
argument_list|,
name|path_so_far
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Failure opening '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|rest
operator|=
name|next
expr_stmt|;
name|here
operator|=
name|child
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|parent_path_p
operator|=
name|parent_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make the node referred to by PARENT_PATH mutable, if it isn't    already, allocating from POOL.  ROOT must be the root from which    PARENT_PATH descends.  Clone any parent directories as needed.    Adjust the dag nodes in PARENT_PATH to refer to the clones.  Use    ERROR_PATH in error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_path_mutable
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|error_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|clone
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|root
operator|->
name|txn
decl_stmt|;
comment|/* Is the node mutable already?  */
if|if
condition|(
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Are we trying to clone the root, or somebody's child node?  */
if|if
condition|(
name|parent_path
operator|->
name|parent
condition|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|parent_id
decl_stmt|,
modifier|*
name|child_id
decl_stmt|,
modifier|*
name|copyroot_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_id
init|=
name|NULL
decl_stmt|;
name|copy_id_inherit_t
name|inherit
init|=
name|parent_path
operator|->
name|copy_inherit
decl_stmt|;
specifier|const
name|char
modifier|*
name|clone_path
decl_stmt|,
modifier|*
name|copyroot_path
decl_stmt|;
name|svn_revnum_t
name|copyroot_rev
decl_stmt|;
name|svn_boolean_t
name|is_parent_copyroot
init|=
name|FALSE
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copyroot_root
decl_stmt|;
name|dag_node_t
modifier|*
name|copyroot_node
decl_stmt|;
comment|/* We're trying to clone somebody's child.  Make sure our parent          is mutable.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|error_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inherit
condition|)
block|{
case|case
name|copy_id_inherit_parent
case|:
name|parent_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|)
expr_stmt|;
name|copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|parent_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_id_inherit_new
case|:
name|SVN_ERR
argument_list|(
name|svn_fs_fs__reserve_copy_id
argument_list|(
operator|&
name|copy_id
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_id_inherit_self
case|:
name|copy_id
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|copy_id_inherit_unknown
case|:
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* uh-oh -- somebody didn't calculate copy-ID                       inheritance data. */
block|}
comment|/* Determine what copyroot our new child node should use. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyroot
argument_list|(
operator|&
name|copyroot_rev
argument_list|,
operator|&
name|copyroot_path
argument_list|,
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|copyroot_root
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|copyroot_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|copyroot_node
argument_list|,
name|copyroot_root
argument_list|,
name|copyroot_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|child_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
expr_stmt|;
name|copyroot_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|copyroot_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|svn_fs_fs__id_node_id
argument_list|(
name|child_id
argument_list|)
argument_list|,
name|svn_fs_fs__id_node_id
argument_list|(
name|copyroot_id
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|is_parent_copyroot
operator|=
name|TRUE
expr_stmt|;
comment|/* Now make this node mutable.  */
name|clone_path
operator|=
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_clone_child
argument_list|(
operator|&
name|clone
argument_list|,
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|clone_path
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|is_parent_copyroot
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the path cache. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|clone
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're trying to clone the root directory.  */
name|SVN_ERR
argument_list|(
name|mutable_root_node
argument_list|(
operator|&
name|clone
argument_list|,
name|root
argument_list|,
name|error_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update the PARENT_PATH link to refer to the clone.  */
name|parent_path
operator|->
name|node
operator|=
name|clone
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open the node identified by PATH in ROOT.  Set DAG_NODE_P to the    node we find, allocated in POOL.  Return the error    SVN_ERR_FS_NOT_FOUND if this node doesn't exist.     Since locking can be expensive and POOL may be long-living, for    nodes that will not need to survive the next call to this function,    set NEEDS_LOCK_CACHE to FALSE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dag
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|dag_node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|needs_lock_cache
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
comment|/* First we look for the DAG in our cache      (if the path may be canonical). */
if|if
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|SVN_ERR
argument_list|(
name|dag_node_cache_get
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|needs_lock_cache
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
comment|/* Canonicalize the input PATH. */
if|if
condition|(
operator|!
name|svn_fs__is_canonical_abspath
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Try again with the corrected path. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_get
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|needs_lock_cache
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node
condition|)
block|{
comment|/* Call open_path with no flags, as we want this to return an            * error if the node for which we are searching doesn't exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|open_path_uncached
operator||
name|open_path_node_only
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
comment|/* No need to cache our find -- open_path() will do that for us. */
block|}
block|}
operator|*
name|dag_node_p
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Populating the `changes' table. */
end_comment

begin_comment
comment|/* Add a change to the changes table in FS, keyed on transaction id    TXN_ID, and indicated that a change of kind CHANGE_KIND occurred on    PATH (whose node revision id is--or was, in the case of a    deletion--NODEREV_ID), and optionally that TEXT_MODs or PROP_MODs    occurred.  If the change resulted from a copy, COPYFROM_REV and    COPYFROM_PATH specify under which revision and path the node was    copied from.  If this was not part of a copy, COPYFROM_REV should    be SVN_INVALID_REVNUM.  Do all this as part of POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_change
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|noderev_id
parameter_list|,
name|svn_fs_path_change_kind_t
name|change_kind
parameter_list|,
name|svn_boolean_t
name|text_mod
parameter_list|,
name|svn_boolean_t
name|prop_mod
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_fs_fs__add_change
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|noderev_id
argument_list|,
name|change_kind
argument_list|,
name|text_mod
argument_list|,
name|prop_mod
argument_list|,
name|node_kind
argument_list|,
name|copyfrom_rev
argument_list|,
name|copyfrom_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic node operations.  */
end_comment

begin_comment
comment|/* Get the id of a node referenced by path PATH in ROOT.  Return the    id in *ID_P allocated in POOL. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__node_id
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|root
operator|->
name|is_txn_root
operator|)
operator|&&
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|path
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Optimize the case where we don't need any db access at all.          The root directory ("" or "/") node is stored in the          svn_fs_root_t object, and never changes when it's a revision          root, so we can just reach in and grab it directly. */
name|fs_rev_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|id_p
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|frd
operator|->
name|root_dir
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__node_created_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_get_revision
argument_list|(
name|revision
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *CREATED_PATH to the path at which PATH under ROOT was created.    Return a string allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_created_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|created_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|created_path
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *KIND_P to the type of node located at PATH under ROOT.    Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|node_kind
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Get the node id. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_id
argument_list|(
operator|&
name|node_id
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the node id to get the real kind. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|node_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|kind_p
operator|=
name|svn_fs_fs__dag_node_kind
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *KIND_P to the type of node present at PATH under ROOT.  If    PATH does not exist under ROOT, set *KIND_P to svn_node_none.  Use    POOL for temporary allocation. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__check_path
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|node_kind
argument_list|(
name|kind_p
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_DIRECTORY
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
operator|*
name|kind_p
operator|=
name|svn_node_none
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *VALUE_P to the value of the property named PROPNAME of PATH in    ROOT.  If the node has no property by that name, set *VALUE_P to    zero.  Allocate the result in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|proplist
condition|)
operator|*
name|value_p
operator|=
name|svn_hash_gets
argument_list|(
name|proplist
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *TABLE_P to the entire property list of PATH under ROOT, as an    APR hash table allocated in POOL.  The resulting property table    maps property names to pointers to svn_string_t objects containing    the property value. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|table_p
operator|=
name|table
condition|?
name|table
else|:
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|increment_mergeinfo_up_tree
parameter_list|(
name|parent_path_t
modifier|*
name|pp
parameter_list|,
name|apr_int64_t
name|increment
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
for|for
control|(
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|parent
control|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_increment_mergeinfo_count
argument_list|(
name|pp
operator|->
name|node
argument_list|,
name|increment
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Change, add, or delete a node's property value.  The affected node    is PATH under ROOT, the property value to modify is NAME, and VALUE    points to either a string value to set the new contents to, or NULL    if the property should be deleted.  Perform temporary allocations    in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_change_node_prop
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|root
argument_list|)
return|;
name|txn_id
operator|=
name|root
operator|->
name|txn
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check (non-recursively) to see if path is locked; if so, check      that we can use it. */
if|if
condition|(
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|parent_path
operator|->
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's no proplist, but we're just deleting a property, exit now. */
if|if
condition|(
operator|(
operator|!
name|proplist
operator|)
operator|&&
operator|(
operator|!
name|value
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Now, if there's no proplist, we know we need to make one. */
if|if
condition|(
operator|!
name|proplist
condition|)
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|root
operator|->
name|fs
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_int64_t
name|increment
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|had_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_mergeinfo
argument_list|(
operator|&
name|had_mergeinfo
argument_list|,
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
operator|!
name|had_mergeinfo
condition|)
name|increment
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|value
operator|&&
name|had_mergeinfo
condition|)
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|increment
operator|!=
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|increment_mergeinfo_up_tree
argument_list|(
name|parent_path
argument_list|,
name|increment
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_set_has_mergeinfo
argument_list|(
name|parent_path
operator|->
name|node
argument_list|,
operator|(
name|value
operator|!=
name|NULL
operator|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set the property. */
name|svn_hash_sets
argument_list|(
name|proplist
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Overwrite the node's proplist. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_set_proplist
argument_list|(
name|parent_path
operator|->
name|node
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_modify
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|svn_fs_fs__dag_node_kind
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if the properties of two path/root combinations are    different.  Set *CHANGED_P to TRUE if the properties at PATH1 under    ROOT1 differ from those at PATH2 under ROOT2, or FALSE otherwise.    Both roots must be in the same filesystem. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_props_changed
parameter_list|(
name|svn_boolean_t
modifier|*
name|changed_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root1
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root2
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node1
decl_stmt|,
modifier|*
name|node2
decl_stmt|;
comment|/* Check that roots are in the same fs. */
if|if
condition|(
name|root1
operator|->
name|fs
operator|!=
name|root2
operator|->
name|fs
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot compare property value between two different filesystems"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node1
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node2
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_things_different
argument_list|(
name|changed_p
argument_list|,
name|NULL
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Merges and commits. */
end_comment

begin_comment
comment|/* Set *NODE to the root node of ROOT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|get_dag
argument_list|(
name|node
argument_list|,
name|root
argument_list|,
literal|"/"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the contents of CONFLICT_PATH to PATH, and return an    SVN_ERR_FS_CONFLICT error that indicates that there was a conflict    at PATH.  Perform all allocations in POOL (except the allocation of    CONFLICT_PATH, which should be handled outside this function).  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict_err
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|conflict_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|svn_stringbuf_set
argument_list|(
name|conflict_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict at '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Merge changes between ANCESTOR and SOURCE into TARGET.  ANCESTOR  * and TARGET must be distinct node revisions.  TARGET_PATH should  * correspond to TARGET's full path in its filesystem, and is used for  * reporting conflict location.  *  * SOURCE, TARGET, and ANCESTOR are generally directories; this  * function recursively merges the directories' contents.  If any are  * files, this function simply returns an error whenever SOURCE,  * TARGET, and ANCESTOR are all distinct node revisions.  *  * If there are differences between ANCESTOR and SOURCE that conflict  * with changes between ANCESTOR and TARGET, this function returns an  * SVN_ERR_FS_CONFLICT error, and updates CONFLICT_P to the name of the  * conflicting node in TARGET, with TARGET_PATH prepended as a path.  *  * If there are no conflicting differences, CONFLICT_P is updated to  * the empty string.  *  * CONFLICT_P must point to a valid svn_stringbuf_t.  *  * Do any necessary temporary allocation in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|conflict_p
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|dag_node_t
modifier|*
name|target
parameter_list|,
name|dag_node_t
modifier|*
name|source
parameter_list|,
name|dag_node_t
modifier|*
name|ancestor
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_int64_t
modifier|*
name|mergeinfo_increment_out
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|source_id
decl_stmt|,
modifier|*
name|target_id
decl_stmt|,
modifier|*
name|ancestor_id
decl_stmt|;
name|apr_hash_t
modifier|*
name|s_entries
decl_stmt|,
modifier|*
name|t_entries
decl_stmt|,
modifier|*
name|a_entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_int64_t
name|mergeinfo_increment
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|fs_supports_mergeinfo
decl_stmt|;
comment|/* Make sure everyone comes from the same filesystem. */
name|fs
operator|=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|!=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|source
argument_list|)
operator|)
operator|||
operator|(
name|fs
operator|!=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|target
argument_list|)
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad merge; ancestor, source, and target not all in same fs"
argument_list|)
argument_list|)
return|;
block|}
comment|/* We have the same fs, now check it. */
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|source_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|ancestor_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
comment|/* It's improper to call this function with ancestor == target. */
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|ancestor_id
argument_list|,
name|target_id
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|target_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad merge; target '%s' has id '%s', same as ancestor"
argument_list|)
argument_list|,
name|target_path
argument_list|,
name|id_str
operator|->
name|data
argument_list|)
return|;
block|}
name|svn_stringbuf_setempty
argument_list|(
name|conflict_p
argument_list|)
expr_stmt|;
comment|/* Base cases:    * Either no change made in source, or same change as made in target.    * Both mean nothing to merge here.    */
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|ancestor_id
argument_list|,
name|source_id
argument_list|)
operator|||
operator|(
name|svn_fs_fs__id_eq
argument_list|(
name|source_id
argument_list|,
name|target_id
argument_list|)
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Else proceed, knowing all three are distinct node revisions.    *    * How to merge from this point:    *    * if (not all 3 are directories)    *   {    *     early exit with conflict;    *   }    *    * // Property changes may only be made to up-to-date    * // directories, because once the client commits the prop    * // change, it bumps the directory's revision, and therefore    * // must be able to depend on there being no other changes to    * // that directory in the repository.    * if (target's property list differs from ancestor's)    *    conflict;    *    * For each entry NAME in the directory ANCESTOR:    *    *   Let ANCESTOR-ENTRY, SOURCE-ENTRY, and TARGET-ENTRY be the IDs of    *   the name within ANCESTOR, SOURCE, and TARGET respectively.    *   (Possibly null if NAME does not exist in SOURCE or TARGET.)    *    *   If ANCESTOR-ENTRY == SOURCE-ENTRY, then:    *     No changes were made to this entry while the transaction was in    *     progress, so do nothing to the target.    *    *   Else if ANCESTOR-ENTRY == TARGET-ENTRY, then:    *     A change was made to this entry while the transaction was in    *     process, but the transaction did not touch this entry.  Replace    *     TARGET-ENTRY with SOURCE-ENTRY.    *    *   Else:    *     Changes were made to this entry both within the transaction and    *     to the repository while the transaction was in progress.  They    *     must be merged or declared to be in conflict.    *    *     If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a    *     double delete; flag a conflict.    *    *     If any of the three entries is of type file, declare a conflict.    *    *     If either SOURCE-ENTRY or TARGET-ENTRY is not a direct    *     modification of ANCESTOR-ENTRY (determine by comparing the    *     node-id fields), declare a conflict.  A replacement is    *     incompatible with a modification or other replacement--even    *     an identical replacement.    *    *     Direct modifications were made to the directory ANCESTOR-ENTRY    *     in both SOURCE and TARGET.  Recursively merge these    *     modifications.    *    * For each leftover entry NAME in the directory SOURCE:    *    *   If NAME exists in TARGET, declare a conflict.  Even if SOURCE and    *   TARGET are adding exactly the same thing, two additions are not    *   auto-mergeable with each other.    *    *   Add NAME to TARGET with the entry from SOURCE.    *    * Now that we are done merging the changes from SOURCE into the    * directory TARGET, update TARGET's predecessor to be SOURCE.    */
if|if
condition|(
operator|(
name|svn_fs_fs__dag_node_kind
argument_list|(
name|source
argument_list|)
operator|!=
name|svn_node_dir
operator|)
operator|||
operator|(
name|svn_fs_fs__dag_node_kind
argument_list|(
name|target
argument_list|)
operator|!=
name|svn_node_dir
operator|)
operator|||
operator|(
name|svn_fs_fs__dag_node_kind
argument_list|(
name|ancestor
argument_list|)
operator|!=
name|svn_node_dir
operator|)
condition|)
block|{
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|target_path
argument_list|)
return|;
block|}
comment|/* Possible early merge failure: if target and ancestor have      different property lists, then the merge should fail.      Propchanges can *only* be committed on an up-to-date directory.      ### TODO: see issue #418 about the inelegance of this.       Another possible, similar, early merge failure: if source and      ancestor have different property lists (meaning someone else      changed directory properties while our commit transaction was      happening), the merge should fail.  See issue #2751.   */
block|{
name|node_revision_t
modifier|*
name|tgt_nr
decl_stmt|,
modifier|*
name|anc_nr
decl_stmt|,
modifier|*
name|src_nr
decl_stmt|;
comment|/* Get node revisions for our id's. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|tgt_nr
argument_list|,
name|fs
argument_list|,
name|target_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|anc_nr
argument_list|,
name|fs
argument_list|,
name|ancestor_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|src_nr
argument_list|,
name|fs
argument_list|,
name|source_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now compare the prop-keys of the skels.  Note that just because        the keys are different -doesn't- mean the proplists have        different contents.  But merge() isn't concerned with contents;        it doesn't do a brute-force comparison on textual contents, so        it won't do that here either.  Checking to see if the propkey        atoms are `equal' is enough. */
if|if
condition|(
operator|!
name|svn_fs_fs__noderev_same_rep_key
argument_list|(
name|tgt_nr
operator|->
name|prop_rep
argument_list|,
name|anc_nr
operator|->
name|prop_rep
argument_list|)
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|target_path
argument_list|)
return|;
if|if
condition|(
operator|!
name|svn_fs_fs__noderev_same_rep_key
argument_list|(
name|src_nr
operator|->
name|prop_rep
argument_list|,
name|anc_nr
operator|->
name|prop_rep
argument_list|)
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|target_path
argument_list|)
return|;
block|}
comment|/* ### todo: it would be more efficient to simply check for a NULL      entries hash where necessary below than to allocate an empty hash      here, but another day, another day... */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|s_entries
argument_list|,
name|source
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|t_entries
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|a_entries
argument_list|,
name|ancestor
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs_supports_mergeinfo
operator|=
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* for each entry E in a_entries... */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|a_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|t_entry
decl_stmt|,
modifier|*
name|a_entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|name
operator|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|klen
operator|=
name|svn__apr_hash_index_klen
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|a_entry
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|s_entry
operator|=
name|apr_hash_get
argument_list|(
name|s_entries
argument_list|,
name|name
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|t_entry
operator|=
name|apr_hash_get
argument_list|(
name|t_entries
argument_list|,
name|name
argument_list|,
name|klen
argument_list|)
expr_stmt|;
comment|/* No changes were made to this entry while the transaction was          in progress, so do nothing to the target. */
if|if
condition|(
name|s_entry
operator|&&
name|svn_fs_fs__id_eq
argument_list|(
name|a_entry
operator|->
name|id
argument_list|,
name|s_entry
operator|->
name|id
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* A change was made to this entry while the transaction was in          process, but the transaction did not touch this entry. */
elseif|else
if|if
condition|(
name|t_entry
operator|&&
name|svn_fs_fs__id_eq
argument_list|(
name|a_entry
operator|->
name|id
argument_list|,
name|t_entry
operator|->
name|id
argument_list|)
condition|)
block|{
name|dag_node_t
modifier|*
name|t_ent_node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|t_ent_node
argument_list|,
name|fs
argument_list|,
name|t_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
block|{
name|apr_int64_t
name|mergeinfo_start
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_start
argument_list|,
name|t_ent_node
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|-=
name|mergeinfo_start
expr_stmt|;
block|}
if|if
condition|(
name|s_entry
condition|)
block|{
name|dag_node_t
modifier|*
name|s_ent_node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|s_ent_node
argument_list|,
name|fs
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
block|{
name|apr_int64_t
name|mergeinfo_end
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_end
argument_list|,
name|s_ent_node
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|+=
name|mergeinfo_end
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_set_entry
argument_list|(
name|target
argument_list|,
name|name
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|s_entry
operator|->
name|kind
argument_list|,
name|txn_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_delete
argument_list|(
name|target
argument_list|,
name|name
argument_list|,
name|txn_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Changes were made to this entry both within the transaction          and to the repository while the transaction was in progress.          They must be merged or declared to be in conflict. */
else|else
block|{
name|dag_node_t
modifier|*
name|s_ent_node
decl_stmt|,
modifier|*
name|t_ent_node
decl_stmt|,
modifier|*
name|a_ent_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_tpath
decl_stmt|;
name|apr_int64_t
name|sub_mergeinfo_increment
decl_stmt|;
comment|/* If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a              double delete; if one of them is null, that's a delete versus              a modification. In any of these cases, flag a conflict. */
if|if
condition|(
name|s_entry
operator|==
name|NULL
operator|||
name|t_entry
operator|==
name|NULL
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* If any of the three entries is of type file, flag a conflict. */
if|if
condition|(
name|s_entry
operator|->
name|kind
operator|==
name|svn_node_file
operator|||
name|t_entry
operator|->
name|kind
operator|==
name|svn_node_file
operator|||
name|a_entry
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* If either SOURCE-ENTRY or TARGET-ENTRY is not a direct              modification of ANCESTOR-ENTRY, declare a conflict. */
if|if
condition|(
name|strcmp
argument_list|(
name|svn_fs_fs__id_node_id
argument_list|(
name|s_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_node_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|svn_fs_fs__id_copy_id
argument_list|(
name|s_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_copy_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|svn_fs_fs__id_node_id
argument_list|(
name|t_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_node_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|svn_fs_fs__id_copy_id
argument_list|(
name|t_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_copy_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* Direct modifications were made to the directory              ANCESTOR-ENTRY in both SOURCE and TARGET.  Recursively              merge these modifications. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|s_ent_node
argument_list|,
name|fs
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|t_ent_node
argument_list|,
name|fs
argument_list|,
name|t_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|a_ent_node
argument_list|,
name|fs
argument_list|,
name|a_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|new_tpath
operator|=
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|merge
argument_list|(
name|conflict_p
argument_list|,
name|new_tpath
argument_list|,
name|t_ent_node
argument_list|,
name|s_ent_node
argument_list|,
name|a_ent_node
argument_list|,
name|txn_id
argument_list|,
operator|&
name|sub_mergeinfo_increment
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
name|mergeinfo_increment
operator|+=
name|sub_mergeinfo_increment
expr_stmt|;
block|}
comment|/* We've taken care of any possible implications E could have.          Remove it from source_entries, so it's easy later to loop          over all the source entries that didn't exist in          ancestor_entries. */
name|end
label|:
name|apr_hash_set
argument_list|(
name|s_entries
argument_list|,
name|name
argument_list|,
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* For each entry E in source but not in ancestor */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|s_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|t_entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|klen
init|=
name|svn__apr_hash_index_klen
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|dag_node_t
modifier|*
name|s_ent_node
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|s_entry
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|t_entry
operator|=
name|apr_hash_get
argument_list|(
name|t_entries
argument_list|,
name|name
argument_list|,
name|klen
argument_list|)
expr_stmt|;
comment|/* If NAME exists in TARGET, declare a conflict. */
if|if
condition|(
name|t_entry
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|s_ent_node
argument_list|,
name|fs
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
block|{
name|apr_int64_t
name|mergeinfo_s
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_s
argument_list|,
name|s_ent_node
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|+=
name|mergeinfo_s
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_set_entry
argument_list|(
name|target
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|s_entry
operator|->
name|kind
argument_list|,
name|txn_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_update_ancestry
argument_list|(
name|target
argument_list|,
name|source
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_increment_mergeinfo_count
argument_list|(
name|target
argument_list|,
name|mergeinfo_increment
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergeinfo_increment_out
condition|)
operator|*
name|mergeinfo_increment_out
operator|=
name|mergeinfo_increment
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Merge changes between an ancestor and SOURCE_NODE into    TXN.  The ancestor is either ANCESTOR_NODE, or if    that is null, TXN's base node.     If the merge is successful, TXN's base will become    SOURCE_NODE, and its root node will have a new ID, a    successor of SOURCE_NODE.     If a conflict results, update *CONFLICT to the path in the txn that    conflicted; see the CONFLICT_P parameter of merge() for details. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_changes
parameter_list|(
name|dag_node_t
modifier|*
name|ancestor_node
parameter_list|,
name|dag_node_t
modifier|*
name|source_node
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|conflict
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|txn_root_node
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|txn
operator|->
name|id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_txn_root
argument_list|(
operator|&
name|txn_root_node
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ancestor_node
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_txn_base_root
argument_list|(
operator|&
name|ancestor_node
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|ancestor_node
argument_list|)
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|txn_root_node
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If no changes have been made in TXN since its current base,          then it can't conflict with any changes since that base.          The caller isn't supposed to call us in that case. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|merge
argument_list|(
name|conflict
argument_list|,
literal|"/"
argument_list|,
name|txn_root_node
argument_list|,
name|source_node
argument_list|,
name|ancestor_node
argument_list|,
name|txn_id
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__commit_txn
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|conflict_p
parameter_list|,
name|svn_revnum_t
modifier|*
name|new_rev
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* How do commits work in Subversion?    *    * When you're ready to commit, here's what you have:    *    *    1. A transaction, with a mutable tree hanging off it.    *    2. A base revision, against which TXN_TREE was made.    *    3. A latest revision, which may be newer than the base rev.    *    * The problem is that if latest != base, then one can't simply    * attach the txn root as the root of the new revision, because that    * would lose all the changes between base and latest.  It is also    * not acceptable to insist that base == latest; in a busy    * repository, commits happen too fast to insist that everyone keep    * their entire tree up-to-date at all times.  Non-overlapping    * changes should not interfere with each other.    *    * The solution is to merge the changes between base and latest into    * the txn tree [see the function merge()].  The txn tree is the    * only one of the three trees that is mutable, so it has to be the    * one to adjust.    *    * You might have to adjust it more than once, if a new latest    * revision gets committed while you were merging in the previous    * one.  For example:    *    *    1. Jane starts txn T, based at revision 6.    *    2. Someone commits (or already committed) revision 7.    *    3. Jane's starts merging the changes between 6 and 7 into T.    *    4. Meanwhile, someone commits revision 8.    *    5. Jane finishes the 6-->7 merge.  T could now be committed    *       against a latest revision of 7, if only that were still the    *       latest.  Unfortunately, 8 is now the latest, so...    *    6. Jane starts merging the changes between 7 and 8 into T.    *    7. Meanwhile, no one commits any new revisions.  Whew.    *    8. Jane commits T, creating revision 9, whose tree is exactly    *       T's tree, except immutable now.    *    * Lather, rinse, repeat.    */
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|conflict
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
comment|/* Limit memory usage when the repository has a high commit rate and      needs to run the following while loop multiple times.  The memory      growth without an iteration pool is very noticeable when the      transaction modifies a node that has 20,000 sibling nodes. */
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Initialize output params. */
operator|*
name|new_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|conflict_p
condition|)
operator|*
name|conflict_p
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1729
condition|)
block|{
name|svn_revnum_t
name|youngish_rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|youngish_root
decl_stmt|;
name|dag_node_t
modifier|*
name|youngish_root_node
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the *current* youngest revision.  We call it "youngish"          because new revisions might get committed after we've          obtained it. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__youngest_rev
argument_list|(
operator|&
name|youngish_rev
argument_list|,
name|fs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|youngish_root
argument_list|,
name|fs
argument_list|,
name|youngish_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the dag node for the youngest revision.  Later we'll use          it as the SOURCE argument to a merge, and if the merge          succeeds, this youngest root node will become the new base          root for the svn txn that was the target of the merge (but          note that the youngest rev may have changed by then -- that's          why we're careful to get this root in its own bdb txn          here). */
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|youngish_root_node
argument_list|,
name|youngish_root
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to merge.  If the merge succeeds, the base root node of          TARGET's txn will become the same as youngish_root_node, so          any future merges will only be between that node and whatever          the root node of the youngest rev is by then. */
name|err
operator|=
name|merge_changes
argument_list|(
name|NULL
argument_list|,
name|youngish_root_node
argument_list|,
name|txn
argument_list|,
name|conflict
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CONFLICT
operator|)
operator|&&
name|conflict_p
condition|)
operator|*
name|conflict_p
operator|=
name|conflict
operator|->
name|data
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|txn
operator|->
name|base_rev
operator|=
name|youngish_rev
expr_stmt|;
comment|/* Try to commit. */
name|err
operator|=
name|svn_fs_fs__commit
argument_list|(
name|new_rev
argument_list|,
name|fs
argument_list|,
name|txn
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_TXN_OUT_OF_DATE
operator|)
condition|)
block|{
comment|/* Did someone else finish committing a new revision while we              were in mid-merge or mid-commit?  If so, we'll need to              loop again to merge the new changes in, then try to              commit again.  Or if that's not what happened, then just              return the error. */
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|youngest_rev
operator|==
name|youngish_rev
condition|)
goto|goto
name|cleanup
goto|;
else|else
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|cleanup
label|:
name|svn_fs_fs__reset_txn_caches
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Merge changes between two nodes into a third node.  Given nodes    SOURCE_PATH under SOURCE_ROOT, TARGET_PATH under TARGET_ROOT and    ANCESTOR_PATH under ANCESTOR_ROOT, modify target to contain all the    changes between the ancestor and source.  If there are conflicts,    return SVN_ERR_FS_CONFLICT and set *CONFLICT_P to a textual    description of the offending changes.  Perform any temporary    allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_merge
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|conflict_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|source_root
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|target_root
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|ancestor_root
parameter_list|,
specifier|const
name|char
modifier|*
name|ancestor_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|source
decl_stmt|,
modifier|*
name|ancestor
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|conflict
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|target_root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|target_root
argument_list|)
return|;
comment|/* Paranoia. */
if|if
condition|(
operator|(
name|source_root
operator|->
name|fs
operator|!=
name|ancestor_root
operator|->
name|fs
operator|)
operator|||
operator|(
name|target_root
operator|->
name|fs
operator|!=
name|ancestor_root
operator|->
name|fs
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad merge; ancestor, source, and target not all in same fs"
argument_list|)
argument_list|)
return|;
block|}
comment|/* ### kff todo: is there any compelling reason to get the nodes in      one db transaction?  Right now we don't; txn_body_get_root() gets      one node at a time.  This will probably need to change:       Jim Blandy<jimb@zwingli.cygnus.com> writes:> svn_fs_merge needs to be a single transaction, to protect it against> people deleting parents of nodes it's working on, etc.   */
comment|/* Get the ancestor node. */
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|ancestor
argument_list|,
name|ancestor_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the source node. */
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|source
argument_list|,
name|source_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open a txn for the txn root into which we're merging. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|ancestor_root
operator|->
name|fs
argument_list|,
name|target_root
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Merge changes between ANCESTOR and SOURCE into TXN. */
name|err
operator|=
name|merge_changes
argument_list|(
name|ancestor
argument_list|,
name|source
argument_list|,
name|txn
argument_list|,
name|conflict
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CONFLICT
operator|)
operator|&&
name|conflict_p
condition|)
operator|*
name|conflict_p
operator|=
name|conflict
operator|->
name|data
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deltify
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Deltify is a no-op for fs_fs. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Directories.  */
end_comment

begin_comment
comment|/* Set *TABLE_P to a newly allocated APR hash table containing the    entries of the directory at PATH in ROOT.  The keys of the table    are entry names, as byte strings, excluding the final null    character; the table's values are pointers to svn_fs_dirent_t    structures.  Allocate the table and its contents in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_dir_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Get the entries for this path in the caller's pool. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_dir_entries
argument_list|(
name|table_p
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Raise an error if PATH contains a newline because FSFS cannot handle  * such paths. See issue #4340. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_newline
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|c
init|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PATH_SYNTAX
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid control character '0x%02x' in path '%s'"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|c
argument_list|,
name|svn_path_illegal_path_escape
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a new directory named PATH in ROOT.  The new directory has    no entries, and no properties.  ROOT must be the root of a    transaction, not a revision.  Do any necessary temporary allocation    in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_make_dir
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|sub_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|root
operator|->
name|txn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_newline
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|open_path_last_optional
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check (recursively) to see if some lock is 'reserving' a path at      that location, or even some child-path; if so, check that we can      use it. */
if|if
condition|(
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's already a sub-directory by that name, complain.  This      also catches the case of trying to make a subdirectory named `/'.  */
if|if
condition|(
name|parent_path
operator|->
name|node
condition|)
return|return
name|SVN_FS__ALREADY_EXISTS
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
comment|/* Create the subdirectory.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_make_dir
argument_list|(
operator|&
name|sub_dir
argument_list|,
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add this directory to the path cache. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|sub_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|sub_dir
argument_list|)
argument_list|,
name|svn_fs_path_change_add
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|svn_node_dir
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Delete the node at PATH under ROOT.  ROOT must be a transaction    root.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_delete_node
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|root
operator|->
name|txn
decl_stmt|;
name|apr_int64_t
name|mergeinfo_count
init|=
literal|0
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|root
argument_list|)
return|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|svn_fs_fs__dag_node_kind
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* We can't remove the root of the filesystem.  */
if|if
condition|(
operator|!
name|parent_path
operator|->
name|parent
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_ROOT_DIR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The root directory cannot be deleted"
argument_list|)
argument_list|)
return|;
comment|/* Check to see if path (or any child thereof) is locked; if so,      check that we can use the existing lock(s). */
if|if
condition|(
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the parent directory mutable, and do the deletion.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|root
operator|->
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_count
argument_list|,
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_delete
argument_list|(
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove this node and any children from the path cache. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_invalidate
argument_list|(
name|root
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update mergeinfo counts for parents */
if|if
condition|(
name|mergeinfo_count
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|increment_mergeinfo_up_tree
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
operator|-
name|mergeinfo_count
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_delete
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|kind
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *SAME_P to TRUE if FS1 and FS2 have the same UUID, else set to FALSE.    Use POOL for temporary allocation only.    Note: this code is duplicated between libsvn_fs_fs and libsvn_fs_base. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_same_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|same_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs1
parameter_list|,
name|svn_fs_t
modifier|*
name|fs2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|same_p
operator|=
operator|!
name|strcmp
argument_list|(
name|fs1
operator|->
name|uuid
argument_list|,
name|fs2
operator|->
name|uuid
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy the node at FROM_PATH under FROM_ROOT to TO_PATH under    TO_ROOT.  If PRESERVE_HISTORY is set, then the copy is recorded in    the copies table.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_helper
parameter_list|(
name|svn_fs_root_t
modifier|*
name|from_root
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|to_root
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|svn_boolean_t
name|preserve_history
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|from_node
decl_stmt|;
name|parent_path_t
modifier|*
name|to_parent_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|to_root
operator|->
name|txn
decl_stmt|;
name|svn_boolean_t
name|same_p
decl_stmt|;
comment|/* Use an error check, not an assert, because even the caller cannot      guarantee that a filesystem's UUID has not changed "on the fly". */
name|SVN_ERR
argument_list|(
name|fs_same_p
argument_list|(
operator|&
name|same_p
argument_list|,
name|from_root
operator|->
name|fs
argument_list|,
name|to_root
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_p
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot copy between two different filesystems ('%s' and '%s')"
argument_list|)
argument_list|,
name|from_root
operator|->
name|fs
operator|->
name|path
argument_list|,
name|to_root
operator|->
name|fs
operator|->
name|path
argument_list|)
return|;
if|if
condition|(
name|from_root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Copy from mutable tree not currently supported"
argument_list|)
argument_list|)
return|;
comment|/* Get the NODE for FROM_PATH in FROM_ROOT.*/
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|from_node
argument_list|,
name|from_root
argument_list|,
name|from_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build up the parent path from TO_PATH in TO_ROOT.  If the last      component does not exist, it's not that big a deal.  We'll just      make one there. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|to_parent_path
argument_list|,
name|to_root
argument_list|,
name|to_path
argument_list|,
name|open_path_last_optional
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if path (or any child thereof) is locked; if so,      check that we can use the existing lock(s). */
if|if
condition|(
name|to_root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|to_path
argument_list|,
name|to_root
operator|->
name|fs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the destination node already exists as the same node as the      source (in other words, this operation would result in nothing      happening at all), just do nothing an return successfully,      proud that you saved yourself from a tiresome task. */
if|if
condition|(
name|to_parent_path
operator|->
name|node
operator|&&
name|svn_fs_fs__id_eq
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|from_node
argument_list|)
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|to_parent_path
operator|->
name|node
argument_list|)
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
name|from_root
operator|->
name|is_txn_root
condition|)
block|{
name|svn_fs_path_change_kind_t
name|kind
decl_stmt|;
name|dag_node_t
modifier|*
name|new_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_canonpath
decl_stmt|;
name|apr_int64_t
name|mergeinfo_start
decl_stmt|;
name|apr_int64_t
name|mergeinfo_end
decl_stmt|;
comment|/* If TO_PATH already existed prior to the copy, note that this          operation is a replacement, not an addition. */
if|if
condition|(
name|to_parent_path
operator|->
name|node
condition|)
block|{
name|kind
operator|=
name|svn_fs_path_change_replace
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|to_root
operator|->
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_start
argument_list|,
name|to_parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kind
operator|=
name|svn_fs_path_change_add
expr_stmt|;
name|mergeinfo_start
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|to_root
operator|->
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_end
argument_list|,
name|from_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the target node's parents are mutable.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|to_root
argument_list|,
name|to_parent_path
operator|->
name|parent
argument_list|,
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Canonicalize the copyfrom path. */
name|from_canonpath
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|from_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_copy
argument_list|(
name|to_parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|to_parent_path
operator|->
name|entry
argument_list|,
name|from_node
argument_list|,
name|preserve_history
argument_list|,
name|from_root
operator|->
name|rev
argument_list|,
name|from_canonpath
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_fs_path_change_replace
condition|)
name|SVN_ERR
argument_list|(
name|dag_node_cache_invalidate
argument_list|(
name|to_root
argument_list|,
name|parent_path_path
argument_list|(
name|to_parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|to_root
operator|->
name|fs
argument_list|)
operator|&&
name|mergeinfo_start
operator|!=
name|mergeinfo_end
condition|)
name|SVN_ERR
argument_list|(
name|increment_mergeinfo_up_tree
argument_list|(
name|to_parent_path
operator|->
name|parent
argument_list|,
name|mergeinfo_end
operator|-
name|mergeinfo_start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|new_node
argument_list|,
name|to_root
argument_list|,
name|to_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_change
argument_list|(
name|to_root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|to_path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|new_node
argument_list|)
argument_list|,
name|kind
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|svn_fs_fs__dag_node_kind
argument_list|(
name|from_node
argument_list|)
argument_list|,
name|from_root
operator|->
name|rev
argument_list|,
name|from_canonpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* See IZ Issue #436 */
comment|/* Copying from transaction roots not currently available.           ### cmpilato todo someday: make this not so. :-) Note that          when copying from mutable trees, you have to make sure that          you aren't creating a cyclic graph filesystem, and a simple          referencing operation won't cut it.  Currently, we should not          be able to reach this clause, and the interface reports that          this only works from immutable trees anyway, but JimB has          stated that this requirement need not be necessary in the          future. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a copy of FROM_PATH in FROM_ROOT named TO_PATH in TO_ROOT.    If FROM_PATH is a directory, copy it recursively.  Temporary    allocations are from POOL.*/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_copy
parameter_list|(
name|svn_fs_root_t
modifier|*
name|from_root
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|to_root
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|check_newline
argument_list|(
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|copy_helper
argument_list|(
name|from_root
argument_list|,
name|svn_fs__canonicalize_abspath
argument_list|(
name|from_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|to_root
argument_list|,
name|svn_fs__canonicalize_abspath
argument_list|(
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a copy of FROM_PATH in FROM_ROOT named TO_PATH in TO_ROOT.    If FROM_PATH is a directory, copy it recursively.  No history is    preserved.  Temporary allocations are from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_revision_link
parameter_list|(
name|svn_fs_root_t
modifier|*
name|from_root
parameter_list|,
name|svn_fs_root_t
modifier|*
name|to_root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|to_root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|to_root
argument_list|)
return|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|copy_helper
argument_list|(
name|from_root
argument_list|,
name|path
argument_list|,
name|to_root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discover the copy ancestry of PATH under ROOT.  Return a relevant    ancestor/revision combination in *PATH_P and *REV_P.  Temporary    allocations are in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_copied_from
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|,
modifier|*
name|copyfrom_str
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
comment|/* Check to see if there is a cached version of this copyfrom      entry. */
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
block|{
name|fs_rev_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
name|copyfrom_str
operator|=
name|svn_hash_gets
argument_list|(
name|frd
operator|->
name|copyfrom_cache
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copyfrom_str
condition|)
block|{
if|if
condition|(
operator|*
name|copyfrom_str
operator|==
literal|0
condition|)
block|{
comment|/* We have a cached entry that says there is no copyfrom              here. */
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse the copyfrom string for our cached entry. */
name|buf
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|copyfrom_str
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|copyfrom_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|copyfrom_path
operator|=
name|buf
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is no cached entry, look it up the old-fashioned          way. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyfrom_rev
argument_list|(
operator|&
name|copyfrom_rev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyfrom_path
argument_list|(
operator|&
name|copyfrom_path
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|rev_p
operator|=
name|copyfrom_rev
expr_stmt|;
operator|*
name|path_p
operator|=
name|copyfrom_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Files.  */
end_comment

begin_comment
comment|/* Create the empty file PATH under ROOT.  Temporary allocations are    in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_make_file
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|child
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|root
operator|->
name|txn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_newline
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|open_path_last_optional
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's already a file by that name, complain.      This also catches the case of trying to make a file named `/'.  */
if|if
condition|(
name|parent_path
operator|->
name|node
condition|)
return|return
name|SVN_FS__ALREADY_EXISTS
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
comment|/* Check (non-recursively) to see if path is locked;  if so, check      that we can use it. */
if|if
condition|(
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the file.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_make_file
argument_list|(
operator|&
name|child
argument_list|,
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add this file to the path cache. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|child
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|child
argument_list|)
argument_list|,
name|svn_fs_path_change_add
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|svn_node_file
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *LENGTH_P to the size of the file PATH under ROOT.  Temporary    allocations are in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|file
decl_stmt|;
comment|/* First create a dag_node_t from the root/path pair. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|file
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now fetch its length */
return|return
name|svn_fs_fs__dag_file_length
argument_list|(
name|length_p
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *CHECKSUM to the checksum of type KIND for PATH under ROOT, or    NULL if that information isn't available.  Temporary allocations    are from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|file
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_file_checksum
argument_list|(
name|checksum
argument_list|,
name|file
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --- Machinery for svn_fs_file_contents() ---  */
end_comment

begin_comment
comment|/* Set *CONTENTS to a readable stream that will return the contents of    PATH under ROOT.  The stream is allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_file_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
comment|/* First create a dag_node_t from the root/path pair. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Then create a readable stream from the dag_node_t. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_contents
argument_list|(
operator|&
name|file_stream
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents
operator|=
name|file_stream
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_file_contents() ---  */
end_comment

begin_comment
comment|/* --- Machinery for svn_fs_try_process_file_contents() ---  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_try_process_file_contents
parameter_list|(
name|svn_boolean_t
modifier|*
name|success
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_process_contents_func_t
name|processor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_try_process_file_contents
argument_list|(
name|success
argument_list|,
name|node
argument_list|,
name|processor
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_try_process_file_contents() ---  */
end_comment

begin_comment
comment|/* --- Machinery for svn_fs_apply_textdelta() ---  */
end_comment

begin_comment
comment|/* Local baton type for all the helper functions below. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|txdelta_baton_t
block|{
comment|/* This is the custom-built window consumer given to us by the delta      library;  it uniquely knows how to read data from our designated      "source" stream, interpret the window, and write data to our      designated "target" stream (in this case, our repos file.) */
name|svn_txdelta_window_handler_t
name|interpreter
decl_stmt|;
name|void
modifier|*
name|interpreter_baton
decl_stmt|;
comment|/* The original file info */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Derived from the file info */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_stream_t
modifier|*
name|source_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|target_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|string_stream
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|target_string
decl_stmt|;
comment|/* MD5 digest for the base text against which a delta is to be      applied, and for the resultant fulltext, respectively.  Either or      both may be null, in which case ignored. */
name|svn_checksum_t
modifier|*
name|base_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|result_checksum
decl_stmt|;
comment|/* Pool used by db txns */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|txdelta_baton_t
typedef|;
end_typedef

begin_comment
comment|/* ### see comment in window_consumer() regarding this function. */
end_comment

begin_comment
comment|/* Helper function of generic type `svn_write_fn_t'.  Implements a    writable stream which appends to an svn_stringbuf_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_to_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
operator|(
name|txdelta_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|tb
operator|->
name|target_string
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The main window handler returned by svn_fs_apply_textdelta. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_consumer
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
operator|(
name|txdelta_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
comment|/* Send the window right through to the custom window interpreter.      In theory, the interpreter will then write more data to      cb->target_string. */
name|SVN_ERR
argument_list|(
name|tb
operator|->
name|interpreter
argument_list|(
name|window
argument_list|,
name|tb
operator|->
name|interpreter_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### the write_to_string() callback for the txdelta's output stream      ### should be doing all the flush determination logic, not here.      ### in a drastic case, a window could generate a LOT more than the      ### maximum buffer size. we want to flush to the underlying target      ### stream much sooner (e.g. also in a streamy fashion). also, by      ### moving this logic inside the stream, the stream becomes nice      ### and encapsulated: it holds all the logic about buffering and      ### flushing.      ###      ### further: I believe the buffering should be removed from tree.c      ### the buffering should go into the target_stream itself, which      ### is defined by reps-string.c. Specifically, I think the      ### rep_write_contents() function will handle the buffering and      ### the spill to the underlying DB. by locating it there, then      ### anybody who gets a writable stream for FS content can take      ### advantage of the buffering capability. this will be important      ### when we export an FS API function for writing a fulltext into      ### the FS, rather than forcing that fulltext thru apply_textdelta.   */
comment|/* Check to see if we need to purge the portion of the contents that      have been written thus far. */
if|if
condition|(
operator|(
operator|!
name|window
operator|)
operator|||
operator|(
name|tb
operator|->
name|target_string
operator|->
name|len
operator|>
name|WRITE_BUFFER_SIZE
operator|)
condition|)
block|{
name|apr_size_t
name|len
init|=
name|tb
operator|->
name|target_string
operator|->
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|tb
operator|->
name|target_stream
argument_list|,
name|tb
operator|->
name|target_string
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|tb
operator|->
name|target_string
argument_list|)
expr_stmt|;
block|}
comment|/* Is the window NULL?  If so, we're done. */
if|if
condition|(
operator|!
name|window
condition|)
block|{
comment|/* Close the internal-use stream.  ### This used to be inside of          txn_body_fulltext_finalize_edits(), but that invoked a nested          Berkeley DB transaction -- scandalous! */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|tb
operator|->
name|target_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_finalize_edits
argument_list|(
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|result_checksum
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function for fs_apply_textdelta.  BATON is of type    txdelta_baton_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
operator|(
name|txdelta_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|tb
operator|->
name|root
operator|->
name|txn
decl_stmt|;
comment|/* Call open_path with no flags, as we want this to return an error      if the node for which we are searching doesn't exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|tb
operator|->
name|root
argument_list|,
name|tb
operator|->
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check (non-recursively) to see if path is locked; if so, check      that we can use it. */
if|if
condition|(
name|tb
operator|->
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|tb
operator|->
name|path
argument_list|,
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, make sure this path is mutable. */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|tb
operator|->
name|root
argument_list|,
name|parent_path
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|->
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|base_checksum
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
comment|/* Until we finalize the node, its data_key points to the old          contents, in other words, the base text. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|base_checksum
operator|->
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|tb
operator|->
name|base_checksum
argument_list|,
name|checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|tb
operator|->
name|base_checksum
argument_list|,
name|checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Base checksum mismatch on '%s'"
argument_list|)
argument_list|,
name|tb
operator|->
name|path
argument_list|)
return|;
block|}
comment|/* Make a readable "source" stream out of the current contents of      ROOT/PATH; obviously, this must done in the context of a db_txn.      The stream is returned in tb->source_stream. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_contents
argument_list|(
operator|&
operator|(
name|tb
operator|->
name|source_stream
operator|)
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a writable "target" stream */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_edit_stream
argument_list|(
operator|&
operator|(
name|tb
operator|->
name|target_stream
operator|)
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a writable "string" stream which writes data to      tb->target_string. */
name|tb
operator|->
name|target_string
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|tb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|tb
operator|->
name|string_stream
operator|=
name|svn_stream_create
argument_list|(
name|tb
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|tb
operator|->
name|string_stream
argument_list|,
name|write_to_string
argument_list|)
expr_stmt|;
comment|/* Now, create a custom window handler that uses our two streams. */
name|svn_txdelta_apply
argument_list|(
name|tb
operator|->
name|source_stream
argument_list|,
name|tb
operator|->
name|string_stream
argument_list|,
name|NULL
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|tb
operator|->
name|pool
argument_list|,
operator|&
operator|(
name|tb
operator|->
name|interpreter
operator|)
argument_list|,
operator|&
operator|(
name|tb
operator|->
name|interpreter_baton
operator|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|tb
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_modify
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|svn_node_file
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *CONTENTS_P and *CONTENTS_BATON_P to a window handler and baton    that will accept text delta windows to modify the contents of PATH    under ROOT.  Allocations are in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_apply_textdelta
parameter_list|(
name|svn_txdelta_window_handler_t
modifier|*
name|contents_p
parameter_list|,
name|void
modifier|*
modifier|*
name|contents_baton_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_checksum_t
modifier|*
name|base_checksum
parameter_list|,
name|svn_checksum_t
modifier|*
name|result_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
argument_list|)
argument_list|)
decl_stmt|;
name|tb
operator|->
name|root
operator|=
name|root
expr_stmt|;
name|tb
operator|->
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|tb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|tb
operator|->
name|base_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|base_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|tb
operator|->
name|result_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|result_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|apply_textdelta
argument_list|(
name|tb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|window_consumer
expr_stmt|;
operator|*
name|contents_baton_p
operator|=
name|tb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_apply_textdelta() ---  */
end_comment

begin_comment
comment|/* --- Machinery for svn_fs_apply_text() ---  */
end_comment

begin_comment
comment|/* Baton for svn_fs_apply_text(). */
end_comment

begin_struct
struct|struct
name|text_baton_t
block|{
comment|/* The original file info */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Derived from the file info */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* The returned stream that will accept the file's new contents. */
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* The actual fs stream that the returned stream will write to. */
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
comment|/* MD5 digest for the final fulltext written to the file.  May      be null, in which case ignored. */
name|svn_checksum_t
modifier|*
name|result_checksum
decl_stmt|;
comment|/* Pool used by db txns */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A wrapper around svn_fs_fs__dag_finalize_edits, but for  * fulltext data, not text deltas.  Closes BATON->file_stream.  *  * Note: If you're confused about how this function relates to another  * of similar name, think of it this way:  *  * svn_fs_apply_textdelta() ==> ... ==> txn_body_txdelta_finalize_edits()  * svn_fs_apply_text()      ==> ... ==> txn_body_fulltext_finalize_edits()  */
end_comment

begin_comment
comment|/* Write function for the publically returned stream. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|text_stream_writer
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
comment|/* Psst, here's some data.  Pass it on to the -real- file stream. */
return|return
name|svn_stream_write
argument_list|(
name|tb
operator|->
name|file_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close function for the publically returned stream. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|text_stream_closer
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
comment|/* Close the internal-use stream.  ### This used to be inside of      txn_body_fulltext_finalize_edits(), but that invoked a nested      Berkeley DB transaction -- scandalous! */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|tb
operator|->
name|file_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Need to tell fs that we're done sending text */
return|return
name|svn_fs_fs__dag_finalize_edits
argument_list|(
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|result_checksum
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for fs_apply_text.  BATON is of type    text_baton_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_text
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|tb
operator|->
name|root
operator|->
name|txn
decl_stmt|;
comment|/* Call open_path with no flags, as we want this to return an error      if the node for which we are searching doesn't exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|tb
operator|->
name|root
argument_list|,
name|tb
operator|->
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check (non-recursively) to see if path is locked; if so, check      that we can use it. */
if|if
condition|(
name|tb
operator|->
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|tb
operator|->
name|path
argument_list|,
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, make sure this path is mutable. */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|tb
operator|->
name|root
argument_list|,
name|parent_path
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|->
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
comment|/* Make a writable stream for replacing the file's text. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_edit_stream
argument_list|(
operator|&
operator|(
name|tb
operator|->
name|file_stream
operator|)
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a 'returnable' stream which writes to the file_stream. */
name|tb
operator|->
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|tb
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|tb
operator|->
name|stream
argument_list|,
name|text_stream_writer
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|tb
operator|->
name|stream
argument_list|,
name|text_stream_closer
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|tb
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_modify
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|svn_node_file
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a writable stream that will set the contents of PATH under    ROOT.  RESULT_CHECKSUM is the MD5 checksum of the final result.    Temporary allocations are in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_apply_text
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_checksum_t
modifier|*
name|result_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
argument_list|)
argument_list|)
decl_stmt|;
name|tb
operator|->
name|root
operator|=
name|root
expr_stmt|;
name|tb
operator|->
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|tb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|tb
operator|->
name|result_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|result_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|apply_text
argument_list|(
name|tb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|tb
operator|->
name|stream
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_apply_text() ---  */
end_comment

begin_comment
comment|/* Check if the contents of PATH1 under ROOT1 are different from the    contents of PATH2 under ROOT2.  If they are different set    *CHANGED_P to TRUE, otherwise set it to FALSE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_contents_changed
parameter_list|(
name|svn_boolean_t
modifier|*
name|changed_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root1
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root2
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node1
decl_stmt|,
modifier|*
name|node2
decl_stmt|;
comment|/* Check that roots are in the same fs. */
if|if
condition|(
name|root1
operator|->
name|fs
operator|!=
name|root2
operator|->
name|fs
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot compare file contents between two different filesystems"
argument_list|)
argument_list|)
return|;
comment|/* Check that both paths are files. */
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|path1
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|path2
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node1
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node2
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_things_different
argument_list|(
name|NULL
argument_list|,
name|changed_p
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Public interface to computing file text deltas.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_get_file_delta_stream
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|source_root
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|target_root
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|source_node
decl_stmt|,
modifier|*
name|target_node
decl_stmt|;
if|if
condition|(
name|source_root
operator|&&
name|source_path
condition|)
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|source_node
argument_list|,
name|source_root
argument_list|,
name|source_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|source_node
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|target_node
argument_list|,
name|target_root
argument_list|,
name|target_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a delta stream that turns the source into the target.  */
return|return
name|svn_fs_fs__dag_get_file_delta_stream
argument_list|(
name|stream_p
argument_list|,
name|source_node
argument_list|,
name|target_node
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finding Changes */
end_comment

begin_comment
comment|/* Set *CHANGED_PATHS_P to a newly allocated hash containing    descriptions of the paths changed under ROOT.  The hash is keyed    with const char * paths and has svn_fs_path_change2_t * values.  Use    POOL for all allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_paths_changed
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|changed_paths_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_fs_fs__txn_changes_fetch
argument_list|(
name|changed_paths_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
return|;
else|else
block|{
name|fs_rev_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
return|return
name|svn_fs_fs__paths_changed
argument_list|(
name|changed_paths_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|frd
operator|->
name|copyfrom_cache
argument_list|,
name|pool
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Our coolio opaque history object. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fs_history_data_t
block|{
comment|/* filesystem object */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* path and revision of historical location */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* internal-use hints about where to resume the history search. */
specifier|const
name|char
modifier|*
name|path_hint
decl_stmt|;
name|svn_revnum_t
name|rev_hint
decl_stmt|;
comment|/* FALSE until the first call to svn_fs_history_prev(). */
name|svn_boolean_t
name|is_interesting
decl_stmt|;
block|}
name|fs_history_data_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|svn_fs_history_t
modifier|*
name|assemble_history
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_boolean_t
name|is_interesting
parameter_list|,
specifier|const
name|char
modifier|*
name|path_hint
parameter_list|,
name|svn_revnum_t
name|rev_hint
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set *HISTORY_P to an opaque node history object which represents    PATH under ROOT.  ROOT must be a revision root.  Use POOL for all    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_history
parameter_list|(
name|svn_fs_history_t
modifier|*
modifier|*
name|history_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* We require a revision root. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_REVISION_ROOT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* And we require that the path exist in the root. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|SVN_FS__NOT_FOUND
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
comment|/* Okay, all seems well.  Build our history object and return it. */
operator|*
name|history_p
operator|=
name|assemble_history
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find the youngest copyroot for path PARENT_PATH or its parents in    filesystem FS, and store the copyroot in *REV_P and *PATH_P.    Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_youngest_copyroot
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|rev_mine
decl_stmt|;
name|svn_revnum_t
name|rev_parent
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_mine
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_parent
init|=
name|NULL
decl_stmt|;
comment|/* First find our parent's youngest copyroot. */
if|if
condition|(
name|parent_path
operator|->
name|parent
condition|)
name|SVN_ERR
argument_list|(
name|find_youngest_copyroot
argument_list|(
operator|&
name|rev_parent
argument_list|,
operator|&
name|path_parent
argument_list|,
name|fs
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find our copyroot. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyroot
argument_list|(
operator|&
name|rev_mine
argument_list|,
operator|&
name|path_mine
argument_list|,
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a parent and child were copied to in the same revision, prefer      the child copy target, since it is the copy relevant to the      history of the child. */
if|if
condition|(
name|rev_mine
operator|>=
name|rev_parent
condition|)
block|{
operator|*
name|rev_p
operator|=
name|rev_mine
expr_stmt|;
operator|*
name|path_p
operator|=
name|path_mine
expr_stmt|;
block|}
else|else
block|{
operator|*
name|rev_p
operator|=
name|rev_parent
expr_stmt|;
operator|*
name|path_p
operator|=
name|path_parent
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_closest_copy
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|,
modifier|*
name|copy_dst_parent_path
decl_stmt|;
name|svn_revnum_t
name|copy_dst_rev
decl_stmt|,
name|created_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_dst_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copy_dst_root
decl_stmt|;
name|dag_node_t
modifier|*
name|copy_dst_node
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* Initialize return values. */
operator|*
name|root_p
operator|=
name|NULL
expr_stmt|;
operator|*
name|path_p
operator|=
name|NULL
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the youngest copyroot in the path of this node-rev, which      will indicate the target of the innermost copy affecting the      node-rev. */
name|SVN_ERR
argument_list|(
name|find_youngest_copyroot
argument_list|(
operator|&
name|copy_dst_rev
argument_list|,
operator|&
name|copy_dst_path
argument_list|,
name|fs
argument_list|,
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_dst_rev
operator|==
literal|0
condition|)
comment|/* There are no copies affecting this node-rev. */
return|return
name|SVN_NO_ERROR
return|;
comment|/* It is possible that this node was created from scratch at some      revision between COPY_DST_REV and REV.  Make sure that PATH      exists as of COPY_DST_REV and is related to this node-rev. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|copy_dst_root
argument_list|,
name|fs
argument_list|,
name|copy_dst_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|copy_dst_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|copy_dst_parent_path
argument_list|,
name|copy_dst_root
argument_list|,
name|path
argument_list|,
name|open_path_node_only
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|copy_dst_node
operator|=
name|copy_dst_parent_path
operator|->
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__id_check_related
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|copy_dst_node
argument_list|)
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* One final check must be done here.  If you copy a directory and      create a new entity somewhere beneath that directory in the same      txn, then we can't claim that the copy affected the new entity.      For example, if you do:          copy dir1 dir2         create dir2/new-thing         commit       then dir2/new-thing was not affected by the copy of dir1 to dir2.      We detect this situation by asking if PATH@COPY_DST_REV's      created-rev is COPY_DST_REV, and that node-revision has no      predecessors, then there is no relevant closest copy.   */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
operator|&
name|created_rev
argument_list|,
name|copy_dst_node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|created_rev
operator|==
name|copy_dst_rev
condition|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|pred
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred
argument_list|,
name|copy_dst_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pred
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The copy destination checks out.  Return it. */
operator|*
name|root_p
operator|=
name|copy_dst_root
expr_stmt|;
operator|*
name|path_p
operator|=
name|copy_dst_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *PREV_PATH and *PREV_REV to the path and revision which    represent the location at which PATH in FS was located immediately    prior to REVISION iff there was a copy operation (to PATH or one of    its parent directories) between that previous location and    PATH@REVISION.     If there was no such copy operation in that portion of PATH's    history, set *PREV_PATH to NULL and *PREV_REV to SVN_INVALID_REVNUM.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prev_location
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|prev_path
parameter_list|,
name|svn_revnum_t
modifier|*
name|prev_rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|copy_path
decl_stmt|,
modifier|*
name|copy_src_path
decl_stmt|,
modifier|*
name|remainder_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copy_root
decl_stmt|;
name|svn_revnum_t
name|copy_src_rev
decl_stmt|;
comment|/* Ask about the most recent copy which affected PATH@REVISION.  If      there was no such copy, we're done.  */
name|SVN_ERR
argument_list|(
name|fs_closest_copy
argument_list|(
operator|&
name|copy_root
argument_list|,
operator|&
name|copy_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy_root
condition|)
block|{
operator|*
name|prev_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
operator|*
name|prev_path
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Ultimately, it's not the path of the closest copy's source that      we care about -- it's our own path's location in the copy source      revision.  So we'll tack the relative path that expresses the      difference between the copy destination and our path in the copy      revision onto the copy source path to determine this information.       In other words, if our path is "/branches/my-branch/foo/bar", and      we know that the closest relevant copy was a copy of "/trunk" to      "/branches/my-branch", then that relative path under the copy      destination is "/foo/bar".  Tacking that onto the copy source      path tells us that our path was located at "/trunk/foo/bar"      before the copy.   */
name|SVN_ERR
argument_list|(
name|fs_copied_from
argument_list|(
operator|&
name|copy_src_rev
argument_list|,
operator|&
name|copy_src_path
argument_list|,
name|copy_root
argument_list|,
name|copy_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|remainder_path
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|copy_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
name|prev_path
operator|=
name|svn_fspath__join
argument_list|(
name|copy_src_path
argument_list|,
name|remainder_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|prev_rev
operator|=
name|copy_src_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_origin_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|given_noderev_id
decl_stmt|,
modifier|*
name|cached_origin_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_id
decl_stmt|,
modifier|*
name|dash
decl_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check the cache first. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_id
argument_list|(
operator|&
name|given_noderev_id
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_id
operator|=
name|svn_fs_fs__id_node_id
argument_list|(
name|given_noderev_id
argument_list|)
expr_stmt|;
comment|/* Is it a brand new uncommitted node? */
if|if
condition|(
name|node_id
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
operator|*
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Maybe this is a new-style node ID that just has the revision      sitting right in it. */
name|dash
operator|=
name|strchr
argument_list|(
name|node_id
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dash
operator|&&
operator|*
operator|(
name|dash
operator|+
literal|1
operator|)
condition|)
block|{
operator|*
name|revision
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The root node always has ID 0, created in revision 0 and will never      use the new-style ID format. */
if|if
condition|(
name|strcmp
argument_list|(
name|node_id
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|revision
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* OK, it's an old-style ID?  Maybe it's cached. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_origin
argument_list|(
operator|&
name|cached_origin_id
argument_list|,
name|fs
argument_list|,
name|node_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_origin_id
operator|!=
name|NULL
condition|)
block|{
operator|*
name|revision
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|cached_origin_id
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|{
comment|/* Ah well, the answer isn't in the ID itself or in the cache.        Let's actually calculate it, then. */
name|svn_fs_root_t
modifier|*
name|curroot
init|=
name|root
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|predidpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|lastpath
init|=
name|svn_stringbuf_create
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|lastrev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
comment|/* Walk the closest-copy chain back to the first copy in our history.         NOTE: We merely *assume* that this is faster than walking the        predecessor chain, because we *assume* that copies of parent        directories happen less often than modifications to a given item. */
while|while
condition|(
literal|1
condition|)
block|{
name|svn_revnum_t
name|currev
decl_stmt|;
specifier|const
name|char
modifier|*
name|curpath
init|=
name|lastpath
operator|->
name|data
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Get a root pointing to LASTREV.  (The first time around,            LASTREV is invalid, but that's cool because CURROOT is            already initialized.)  */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|lastrev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|curroot
argument_list|,
name|fs
argument_list|,
name|lastrev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the previous location using the closest-copy shortcut. */
name|SVN_ERR
argument_list|(
name|prev_location
argument_list|(
operator|&
name|curpath
argument_list|,
operator|&
name|currev
argument_list|,
name|fs
argument_list|,
name|curroot
argument_list|,
name|curpath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curpath
condition|)
break|break;
comment|/* Update our LASTPATH and LASTREV variables (which survive            SUBPOOL). */
name|svn_stringbuf_set
argument_list|(
name|lastpath
argument_list|,
name|curpath
argument_list|)
expr_stmt|;
name|lastrev
operator|=
name|currev
expr_stmt|;
block|}
comment|/* Walk the predecessor links back to origin. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|curroot
argument_list|,
name|lastpath
operator|->
name|data
argument_list|,
name|predidpool
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|pred_id
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Why not just fetch the predecessor ID in PREDIDPOOL?            Because svn_fs_fs__dag_get_predecessor_id() doesn't            necessarily honor the passed-in pool, and might return a            value cached in the node (which is allocated in            SUBPOOL... maybe). */
name|svn_pool_clear
argument_list|(
name|predidpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|pred_id
operator|=
name|pred_id
condition|?
name|svn_fs_fs__id_copy
argument_list|(
name|pred_id
argument_list|,
name|predidpool
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|pred_id
condition|)
do|;
comment|/* When we get here, NODE should be the first node-revision in our        chain. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
name|revision
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wow, I don't want to have to do all that again.  Let's cache        the result. */
if|if
condition|(
name|node_id
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_node_origin
argument_list|(
name|fs
argument_list|,
name|node_id
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|predidpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
end_function

begin_struct
struct|struct
name|history_prev_args
block|{
name|svn_fs_history_t
modifier|*
modifier|*
name|prev_history_p
decl_stmt|;
name|svn_fs_history_t
modifier|*
name|history
decl_stmt|;
name|svn_boolean_t
name|cross_copies
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|history_prev
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|history_prev_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_fs_history_t
modifier|*
modifier|*
name|prev_history
init|=
name|args
operator|->
name|prev_history_p
decl_stmt|;
name|svn_fs_history_t
modifier|*
name|history
init|=
name|args
operator|->
name|history
decl_stmt|;
name|fs_history_data_t
modifier|*
name|fhd
init|=
name|history
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|commit_path
decl_stmt|,
modifier|*
name|src_path
decl_stmt|,
modifier|*
name|path
init|=
name|fhd
operator|->
name|path
decl_stmt|;
name|svn_revnum_t
name|commit_rev
decl_stmt|,
name|src_rev
decl_stmt|,
name|dst_rev
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|fhd
operator|->
name|revision
decl_stmt|;
name|apr_pool_t
modifier|*
name|retpool
init|=
name|args
operator|->
name|pool
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|fhd
operator|->
name|fs
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_boolean_t
name|reported
init|=
name|fhd
operator|->
name|is_interesting
decl_stmt|;
name|svn_revnum_t
name|copyroot_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyroot_path
decl_stmt|;
comment|/* Initialize our return value. */
operator|*
name|prev_history
operator|=
name|NULL
expr_stmt|;
comment|/* If our last history report left us hints about where to pickup      the chase, then our last report was on the destination of a      copy.  If we are crossing copies, start from those locations,      otherwise, we're all done here.  */
if|if
condition|(
name|fhd
operator|->
name|path_hint
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|fhd
operator|->
name|rev_hint
argument_list|)
condition|)
block|{
name|reported
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|->
name|cross_copies
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|path
operator|=
name|fhd
operator|->
name|path_hint
expr_stmt|;
name|revision
operator|=
name|fhd
operator|->
name|rev_hint
expr_stmt|;
block|}
comment|/* Construct a ROOT for the current revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open PATH/REVISION, and get its node and a bunch of other      goodies.  */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
name|commit_path
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
operator|&
name|commit_rev
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The Subversion filesystem is written in such a way that a given      line of history may have at most one interesting history point      per filesystem revision.  Either that node was edited (and      possibly copied), or it was copied but not edited.  And a copy      source cannot be from the same revision as its destination.  So,      if our history revision matches its node's commit revision, we      know that ... */
if|if
condition|(
name|revision
operator|==
name|commit_rev
condition|)
block|{
if|if
condition|(
operator|!
name|reported
condition|)
block|{
comment|/* ... we either have not yet reported on this revision (and              need now to do so) ... */
operator|*
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
name|apr_pstrdup
argument_list|(
name|retpool
argument_list|,
name|commit_path
argument_list|)
argument_list|,
name|commit_rev
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|retpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* ... or we *have* reported on this revision, and must now              progress toward this node's predecessor (unless there is              no predecessor, in which case we're all done!). */
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pred_id
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Replace NODE and friends with the information from its              predecessor. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|pred_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|commit_path
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
operator|&
name|commit_rev
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find the youngest copyroot in the path of this node, including      itself. */
name|SVN_ERR
argument_list|(
name|find_youngest_copyroot
argument_list|(
operator|&
name|copyroot_rev
argument_list|,
operator|&
name|copyroot_path
argument_list|,
name|fs
argument_list|,
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize some state variables. */
name|src_path
operator|=
name|NULL
expr_stmt|;
name|src_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|dst_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|copyroot_rev
operator|>
name|commit_rev
condition|)
block|{
specifier|const
name|char
modifier|*
name|remainder_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_dst
decl_stmt|,
modifier|*
name|copy_src
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copyroot_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|copyroot_root
argument_list|,
name|fs
argument_list|,
name|copyroot_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|copyroot_root
argument_list|,
name|copyroot_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|copy_dst
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* If our current path was the very destination of the copy,          then our new current path will be the copy source.  If our          current path was instead the *child* of the destination of          the copy, then figure out its previous location by taking its          path relative to the copy destination and appending that to          the copy source.  Finally, if our current path doesn't meet          one of these other criteria ... ### for now just fallback to          the old copy hunt algorithm. */
name|remainder_path
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|copy_dst
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder_path
condition|)
block|{
comment|/* If we get here, then our current path is the destination              of, or the child of the destination of, a copy.  Fill              in the return values and get outta here.  */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyfrom_rev
argument_list|(
operator|&
name|src_rev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyfrom_path
argument_list|(
operator|&
name|copy_src
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|dst_rev
operator|=
name|copyroot_rev
expr_stmt|;
name|src_path
operator|=
name|svn_fspath__join
argument_list|(
name|copy_src
argument_list|,
name|remainder_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we calculated a copy source path and revision, we'll make a      'copy-style' history object. */
if|if
condition|(
name|src_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|src_rev
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|retry
init|=
name|FALSE
decl_stmt|;
comment|/* It's possible for us to find a copy location that is the same          as the history point we've just reported.  If that happens,          we simply need to take another trip through this history          search. */
if|if
condition|(
operator|(
name|dst_rev
operator|==
name|revision
operator|)
operator|&&
name|reported
condition|)
name|retry
operator|=
name|TRUE
expr_stmt|;
operator|*
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
name|apr_pstrdup
argument_list|(
name|retpool
argument_list|,
name|path
argument_list|)
argument_list|,
name|dst_rev
argument_list|,
operator|!
name|retry
argument_list|,
name|src_path
argument_list|,
name|src_rev
argument_list|,
name|retpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
name|apr_pstrdup
argument_list|(
name|retpool
argument_list|,
name|commit_path
argument_list|)
argument_list|,
name|commit_rev
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|retpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implement svn_fs_history_prev, set *PREV_HISTORY_P to a new    svn_fs_history_t object that represents the predecessory of    HISTORY.  If CROSS_COPIES is true, *PREV_HISTORY_P may be related    only through a copy operation.  Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_history_prev
parameter_list|(
name|svn_fs_history_t
modifier|*
modifier|*
name|prev_history_p
parameter_list|,
name|svn_fs_history_t
modifier|*
name|history
parameter_list|,
name|svn_boolean_t
name|cross_copies
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_history_t
modifier|*
name|prev_history
init|=
name|NULL
decl_stmt|;
name|fs_history_data_t
modifier|*
name|fhd
init|=
name|history
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|fhd
operator|->
name|fs
decl_stmt|;
comment|/* Special case: the root directory changes in every single      revision, no exceptions.  And, the root can't be the target (or      child of a target -- duh) of a copy.  So, if that's our path,      then we need only decrement our revision by 1, and there you go. */
if|if
condition|(
name|strcmp
argument_list|(
name|fhd
operator|->
name|path
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fhd
operator|->
name|is_interesting
condition|)
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
literal|"/"
argument_list|,
name|fhd
operator|->
name|revision
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fhd
operator|->
name|revision
operator|>
literal|0
condition|)
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
literal|"/"
argument_list|,
name|fhd
operator|->
name|revision
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|history_prev_args
name|args
decl_stmt|;
name|prev_history
operator|=
name|history
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|args
operator|.
name|prev_history_p
operator|=
operator|&
name|prev_history
expr_stmt|;
name|args
operator|.
name|history
operator|=
name|prev_history
expr_stmt|;
name|args
operator|.
name|cross_copies
operator|=
name|cross_copies
expr_stmt|;
name|args
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|history_prev
argument_list|(
operator|&
name|args
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev_history
condition|)
break|break;
name|fhd
operator|=
name|prev_history
operator|->
name|fsap_data
expr_stmt|;
if|if
condition|(
name|fhd
operator|->
name|is_interesting
condition|)
break|break;
block|}
block|}
operator|*
name|prev_history_p
operator|=
name|prev_history
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *PATH and *REVISION to the path and revision for the HISTORY    object.  Use POOL for all allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_history_location
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_fs_history_t
modifier|*
name|history
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_history_data_t
modifier|*
name|fhd
init|=
name|history
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|fhd
operator|->
name|path
argument_list|)
expr_stmt|;
operator|*
name|revision
operator|=
name|fhd
operator|->
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|history_vtable_t
name|history_vtable
init|=
block|{
name|fs_history_prev
block|,
name|fs_history_location
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a new history object (marked as "interesting") for PATH and    REVISION, allocated in POOL, and with its members set to the values    of the parameters provided.  Note that PATH and PATH_HINT are not    duped into POOL -- it is the responsibility of the caller to ensure    that this happens. */
end_comment

begin_function
specifier|static
name|svn_fs_history_t
modifier|*
name|assemble_history
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_boolean_t
name|is_interesting
parameter_list|,
specifier|const
name|char
modifier|*
name|path_hint
parameter_list|,
name|svn_revnum_t
name|rev_hint
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_history_t
modifier|*
name|history
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|history
argument_list|)
argument_list|)
decl_stmt|;
name|fs_history_data_t
modifier|*
name|fhd
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fhd
argument_list|)
argument_list|)
decl_stmt|;
name|fhd
operator|->
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fhd
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|fhd
operator|->
name|is_interesting
operator|=
name|is_interesting
expr_stmt|;
name|fhd
operator|->
name|path_hint
operator|=
name|path_hint
expr_stmt|;
name|fhd
operator|->
name|rev_hint
operator|=
name|rev_hint
expr_stmt|;
name|fhd
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|history
operator|->
name|vtable
operator|=
operator|&
name|history_vtable
expr_stmt|;
name|history
operator|->
name|fsap_data
operator|=
name|fhd
expr_stmt|;
return|return
name|history
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* mergeinfo queries */
end_comment

begin_comment
comment|/* DIR_DAG is a directory DAG node which has mergeinfo in its    descendants.  This function iterates over its children.  For each    child with immediate mergeinfo, it adds its mergeinfo to    RESULT_CATALOG.  appropriate arguments.  For each child with    descendants with mergeinfo, it recurses.  Note that it does *not*    call the action on the path for DIR_DAG itself.     POOL is used for temporary allocations, including the mergeinfo    hashes passed to actions; RESULT_POOL is used for the mergeinfo added    to RESULT_CATALOG.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|crawl_directory_dag_for_mergeinfo
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|this_path
parameter_list|,
name|dag_node_t
modifier|*
name|dir_dag
parameter_list|,
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|dir_dag
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|kid_path
decl_stmt|;
name|dag_node_t
modifier|*
name|kid_dag
decl_stmt|;
name|svn_boolean_t
name|has_mergeinfo
decl_stmt|,
name|go_down
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|kid_path
operator|=
name|svn_fspath__join
argument_list|(
name|this_path
argument_list|,
name|dirent
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|kid_dag
argument_list|,
name|root
argument_list|,
name|kid_path
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_mergeinfo
argument_list|(
operator|&
name|has_mergeinfo
argument_list|,
name|kid_dag
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_descendants_with_mergeinfo
argument_list|(
operator|&
name|go_down
argument_list|,
name|kid_dag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mergeinfo
condition|)
block|{
comment|/* Save this particular node's mergeinfo. */
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_mergeinfo_t
name|kid_mergeinfo
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|kid_dag
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_string
operator|=
name|svn_hash_gets
argument_list|(
name|proplist
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mergeinfo_string
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|dirent
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node-revision #'%s' claims to have mergeinfo but doesn't"
argument_list|)
argument_list|,
name|idstr
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Issue #3896: If a node has syntactically invalid mergeinfo, then              treat it as if no mergeinfo is present rather than raising a parse              error. */
name|err
operator|=
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|kid_mergeinfo
argument_list|,
name|mergeinfo_string
operator|->
name|data
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
block|{
name|svn_hash_sets
argument_list|(
name|result_catalog
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|kid_path
argument_list|)
argument_list|,
name|kid_mergeinfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|go_down
condition|)
name|SVN_ERR
argument_list|(
name|crawl_directory_dag_for_mergeinfo
argument_list|(
name|root
argument_list|,
name|kid_path
argument_list|,
name|kid_dag
argument_list|,
name|result_catalog
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the cache key as a combination of REV_ROOT->REV, the inheritance    flags INHERIT and ADJUST_INHERITED_MERGEINFO, and the PATH.  The result    will be allocated in POOL..  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mergeinfo_cache_key
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|rev_root
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_int64_t
name|number
init|=
name|rev_root
operator|->
name|rev
decl_stmt|;
name|number
operator|=
name|number
operator|*
literal|4
operator|+
operator|(
name|inherit
operator|==
name|svn_mergeinfo_nearest_ancestor
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
operator|(
name|adjust_inherited_mergeinfo
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|svn_fs_fs__combine_number_and_string
argument_list|(
name|number
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Calculates the mergeinfo for PATH under REV_ROOT using inheritance    type INHERIT.  Returns it in *MERGEINFO, or NULL if there is none.    The result is allocated in RESULT_POOL; SCRATCH_POOL is    used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfo_for_path_internal
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_fs_root_t
modifier|*
name|rev_root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|,
modifier|*
name|nearest_ancestor
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
decl_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|rev_root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inherit
operator|==
name|svn_mergeinfo_nearest_ancestor
operator|&&
operator|!
name|parent_path
operator|->
name|parent
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|inherit
operator|==
name|svn_mergeinfo_nearest_ancestor
condition|)
name|nearest_ancestor
operator|=
name|parent_path
operator|->
name|parent
expr_stmt|;
else|else
name|nearest_ancestor
operator|=
name|parent_path
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|svn_boolean_t
name|has_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_mergeinfo
argument_list|(
operator|&
name|has_mergeinfo
argument_list|,
name|nearest_ancestor
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mergeinfo
condition|)
break|break;
comment|/* No need to loop if we're looking for explicit mergeinfo. */
if|if
condition|(
name|inherit
operator|==
name|svn_mergeinfo_explicit
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
name|nearest_ancestor
operator|=
name|nearest_ancestor
operator|->
name|parent
expr_stmt|;
comment|/* Run out?  There's no mergeinfo. */
if|if
condition|(
operator|!
name|nearest_ancestor
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|nearest_ancestor
operator|->
name|node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_string
operator|=
name|svn_hash_gets
argument_list|(
name|proplist
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mergeinfo_string
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node-revision '%s@%ld' claims to have mergeinfo but doesn't"
argument_list|)
argument_list|,
name|parent_path_path
argument_list|(
name|nearest_ancestor
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|rev_root
operator|->
name|rev
argument_list|)
return|;
comment|/* Parse the mergeinfo; store the result in *MERGEINFO. */
block|{
comment|/* Issue #3896: If a node has syntactically invalid mergeinfo, then        treat it as if no mergeinfo is present rather than raising a parse        error. */
name|svn_error_t
modifier|*
name|err
init|=
name|svn_mergeinfo_parse
argument_list|(
name|mergeinfo
argument_list|,
name|mergeinfo_string
operator|->
name|data
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
operator|*
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* If our nearest ancestor is the very path we inquired about, we      can return the mergeinfo results directly.  Otherwise, we're      inheriting the mergeinfo, so we need to a) remove non-inheritable      ranges and b) telescope the merged-from paths. */
if|if
condition|(
name|adjust_inherited_mergeinfo
operator|&&
operator|(
name|nearest_ancestor
operator|!=
name|parent_path
operator|)
condition|)
block|{
name|svn_mergeinfo_t
name|tmp_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_inheritable2
argument_list|(
operator|&
name|tmp_mergeinfo
argument_list|,
operator|*
name|mergeinfo
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__append_to_merged_froms
argument_list|(
name|mergeinfo
argument_list|,
name|tmp_mergeinfo
argument_list|,
name|parent_path_relpath
argument_list|(
name|parent_path
argument_list|,
name|nearest_ancestor
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Caching wrapper around get_mergeinfo_for_path_internal().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfo_for_path
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_fs_root_t
modifier|*
name|rev_root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|rev_root
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|cache_key
decl_stmt|;
name|svn_boolean_t
name|found
init|=
name|FALSE
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|mergeinfo_exists
decl_stmt|;
operator|*
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
name|cache_key
operator|=
name|mergeinfo_cache_key
argument_list|(
name|path
argument_list|,
name|rev_root
argument_list|,
name|inherit
argument_list|,
name|adjust_inherited_mergeinfo
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|mergeinfo_existence_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mergeinfo_exists
argument_list|,
operator|&
name|found
argument_list|,
name|ffd
operator|->
name|mergeinfo_existence_cache
argument_list|,
name|cache_key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
name|mergeinfo_exists
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'1'
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|mergeinfo
argument_list|,
operator|&
name|found
argument_list|,
name|ffd
operator|->
name|mergeinfo_cache
argument_list|,
name|cache_key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_mergeinfo_for_path_internal
argument_list|(
name|mergeinfo
argument_list|,
name|rev_root
argument_list|,
name|path
argument_list|,
name|inherit
argument_list|,
name|adjust_inherited_mergeinfo
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|mergeinfo_existence_cache
condition|)
block|{
name|mergeinfo_exists
operator|=
name|svn_stringbuf_create
argument_list|(
operator|*
name|mergeinfo
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|mergeinfo_existence_cache
argument_list|,
name|cache_key
argument_list|,
name|mergeinfo_exists
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|mergeinfo_cache
argument_list|,
name|cache_key
argument_list|,
operator|*
name|mergeinfo
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Adds mergeinfo for each descendant of PATH (but not PATH itself)    under ROOT to RESULT_CATALOG.  Returned values are allocated in    RESULT_POOL; temporary values in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_descendant_mergeinfo
parameter_list|(
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|this_dag
decl_stmt|;
name|svn_boolean_t
name|go_down
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|this_dag
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_descendants_with_mergeinfo
argument_list|(
operator|&
name|go_down
argument_list|,
name|this_dag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|go_down
condition|)
name|SVN_ERR
argument_list|(
name|crawl_directory_dag_for_mergeinfo
argument_list|(
name|root
argument_list|,
name|path
argument_list|,
name|this_dag
argument_list|,
name|result_catalog
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get the mergeinfo for a set of paths, returned in    *MERGEINFO_CATALOG.  Returned values are allocated in    POOL, while temporary values are allocated in a sub-pool. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfos_for_paths
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|svn_mergeinfo_catalog_t
modifier|*
name|mergeinfo_catalog
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_catalog_t
name|result_catalog
init|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_mergeinfo_t
name|path_mergeinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_mergeinfo_for_path
argument_list|(
operator|&
name|path_mergeinfo
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|inherit
argument_list|,
name|adjust_inherited_mergeinfo
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|path_mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|path_mergeinfo
condition|)
name|svn_hash_sets
argument_list|(
name|result_catalog
argument_list|,
name|path
argument_list|,
name|path_mergeinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_descendants
condition|)
name|SVN_ERR
argument_list|(
name|add_descendant_mergeinfo
argument_list|(
name|result_catalog
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|mergeinfo_catalog
operator|=
name|result_catalog
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_fs_get_mergeinfo. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_get_mergeinfo
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|catalog
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|root
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* We require a revision root. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_REVISION_ROOT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* We have to actually be able to find the mergeinfo metadata! */
if|if
condition|(
operator|!
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|root
operator|->
name|fs
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Querying mergeinfo requires version %d of the FSFS filesystem "
literal|"schema; filesystem '%s' uses only version %d"
argument_list|)
argument_list|,
name|SVN_FS_FS__MIN_MERGEINFO_FORMAT
argument_list|,
name|root
operator|->
name|fs
operator|->
name|path
argument_list|,
name|ffd
operator|->
name|format
argument_list|)
return|;
comment|/* Retrieve a path -> mergeinfo hash mapping. */
return|return
name|get_mergeinfos_for_paths
argument_list|(
name|root
argument_list|,
name|catalog
argument_list|,
name|paths
argument_list|,
name|inherit
argument_list|,
name|include_descendants
argument_list|,
name|adjust_inherited_mergeinfo
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The vtable associated with root objects. */
end_comment

begin_decl_stmt
specifier|static
name|root_vtable_t
name|root_vtable
init|=
block|{
name|fs_paths_changed
block|,
name|svn_fs_fs__check_path
block|,
name|fs_node_history
block|,
name|svn_fs_fs__node_id
block|,
name|svn_fs_fs__node_created_rev
block|,
name|fs_node_origin_rev
block|,
name|fs_node_created_path
block|,
name|fs_delete_node
block|,
name|fs_copied_from
block|,
name|fs_closest_copy
block|,
name|fs_node_prop
block|,
name|fs_node_proplist
block|,
name|fs_change_node_prop
block|,
name|fs_props_changed
block|,
name|fs_dir_entries
block|,
name|fs_make_dir
block|,
name|fs_copy
block|,
name|fs_revision_link
block|,
name|fs_file_length
block|,
name|fs_file_checksum
block|,
name|fs_file_contents
block|,
name|fs_try_process_file_contents
block|,
name|fs_make_file
block|,
name|fs_apply_textdelta
block|,
name|fs_apply_text
block|,
name|fs_contents_changed
block|,
name|fs_get_file_delta_stream
block|,
name|fs_merge
block|,
name|fs_get_mergeinfo
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Construct a new root object in FS, allocated from POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_root_t
modifier|*
name|make_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|root
argument_list|)
argument_list|)
decl_stmt|;
name|root
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|root
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|root
operator|->
name|vtable
operator|=
operator|&
name|root_vtable
expr_stmt|;
return|return
name|root
return|;
block|}
end_function

begin_comment
comment|/* Construct a root object referring to the root of REVISION in FS,    whose root directory is ROOT_DIR.  Create the new root in POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_root_t
modifier|*
name|make_revision_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|root_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|make_root
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|fs_rev_root_data_t
modifier|*
name|frd
init|=
name|apr_pcalloc
argument_list|(
name|root
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frd
argument_list|)
argument_list|)
decl_stmt|;
name|root
operator|->
name|is_txn_root
operator|=
name|FALSE
expr_stmt|;
name|root
operator|->
name|rev
operator|=
name|rev
expr_stmt|;
name|frd
operator|->
name|root_dir
operator|=
name|root_dir
expr_stmt|;
name|frd
operator|->
name|copyfrom_cache
operator|=
name|svn_hash__make
argument_list|(
name|root
operator|->
name|pool
argument_list|)
expr_stmt|;
name|root
operator|->
name|fsap_data
operator|=
name|frd
expr_stmt|;
return|return
name|root
return|;
block|}
end_function

begin_comment
comment|/* Construct a root object referring to the root of the transaction    named TXN and based on revision BASE_REV in FS, with FLAGS to    describe transaction's behavior.  Create the new root in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_txn_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn
parameter_list|,
name|svn_revnum_t
name|base_rev
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|make_root
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|fs_txn_root_data_t
modifier|*
name|frd
init|=
name|apr_pcalloc
argument_list|(
name|root
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frd
argument_list|)
argument_list|)
decl_stmt|;
name|root
operator|->
name|is_txn_root
operator|=
name|TRUE
expr_stmt|;
name|root
operator|->
name|txn
operator|=
name|apr_pstrdup
argument_list|(
name|root
operator|->
name|pool
argument_list|,
name|txn
argument_list|)
expr_stmt|;
name|root
operator|->
name|txn_flags
operator|=
name|flags
expr_stmt|;
name|root
operator|->
name|rev
operator|=
name|base_rev
expr_stmt|;
name|frd
operator|->
name|txn_id
operator|=
name|txn
expr_stmt|;
comment|/* Because this cache actually tries to invalidate elements, keep      the number of elements per page down.       Note that since dag_node_cache_invalidate uses svn_cache__iter,      this *cannot* be a memcache-based cache.  */
name|SVN_ERR
argument_list|(
name|svn_cache__create_inprocess
argument_list|(
operator|&
operator|(
name|frd
operator|->
name|txn_node_cache
operator|)
argument_list|,
name|svn_fs_fs__dag_serialize
argument_list|,
name|svn_fs_fs__dag_deserialize
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
literal|32
argument_list|,
literal|20
argument_list|,
name|FALSE
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|txn
argument_list|,
literal|":TXN"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|root
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize transaction-local caches in FS.       Note that we cannot put those caches in frd because that content      fs root object is not available where we would need it. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__initialize_txn_caches
argument_list|(
name|fs
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|->
name|fsap_data
operator|=
name|frd
expr_stmt|;
operator|*
name|root_p
operator|=
name|root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify. */
end_comment

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|stringify_node
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* ### TODO: print some PATH@REV to it, too. */
return|return
name|svn_fs_fs__id_unparse
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|,
name|pool
argument_list|)
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Check metadata sanity on NODE, and on its children.  Manually verify    information for DAG nodes in revision REV, and trust the metadata    accuracy for nodes belonging to older revisions. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_node
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|has_mergeinfo
decl_stmt|;
name|apr_int64_t
name|mergeinfo_count
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|pred_count
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Fetch some data. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_mergeinfo
argument_list|(
operator|&
name|has_mergeinfo
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_count
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_count
argument_list|(
operator|&
name|pred_count
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|svn_fs_fs__dag_node_kind
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|mergeinfo_count
operator|<
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Negative mergeinfo-count %"
name|APR_INT64_T_FMT
literal|" on node '%s'"
argument_list|,
name|mergeinfo_count
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* Issue #4129. (This check will explicitly catch non-root instances too.) */
if|if
condition|(
name|pred_id
condition|)
block|{
name|dag_node_t
modifier|*
name|pred
decl_stmt|;
name|int
name|pred_pred_count
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|pred
argument_list|,
name|fs
argument_list|,
name|pred_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_count
argument_list|(
operator|&
name|pred_pred_count
argument_list|,
name|pred
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred_pred_count
operator|+
literal|1
operator|!=
name|pred_count
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Predecessor count mismatch: "
literal|"%s has %d, but %s has %d"
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|pred_count
argument_list|,
name|stringify_node
argument_list|(
name|pred
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|pred_pred_count
argument_list|)
return|;
block|}
comment|/* Kind-dependent verifications. */
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Node '%s' has kind 'none'"
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
if|if
condition|(
name|has_mergeinfo
operator|!=
name|mergeinfo_count
condition|)
comment|/* comparing int to bool */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"File node '%s' has inconsistent mergeinfo: "
literal|"has_mergeinfo=%d, "
literal|"mergeinfo_count=%"
name|APR_INT64_T_FMT
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|has_mergeinfo
argument_list|,
name|mergeinfo_count
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_int64_t
name|children_mergeinfo
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute CHILDREN_MERGEINFO. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|dag_node_t
modifier|*
name|child
decl_stmt|;
name|svn_revnum_t
name|child_rev
decl_stmt|;
name|apr_int64_t
name|child_mergeinfo
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Compute CHILD_REV. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|child
argument_list|,
name|fs
argument_list|,
name|dirent
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
operator|&
name|child_rev
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_rev
operator|==
name|rev
condition|)
name|SVN_ERR
argument_list|(
name|verify_node
argument_list|(
name|child
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|child_mergeinfo
argument_list|,
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|children_mergeinfo
operator|+=
name|child_mergeinfo
expr_stmt|;
block|}
comment|/* Side-effect of issue #4129. */
if|if
condition|(
name|children_mergeinfo
operator|+
name|has_mergeinfo
operator|!=
name|mergeinfo_count
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Mergeinfo-count discrepancy on '%s': "
literal|"expected %"
name|APR_INT64_T_FMT
literal|"+%d, "
literal|"counted %"
name|APR_INT64_T_FMT
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|mergeinfo_count
argument_list|,
name|has_mergeinfo
argument_list|,
name|children_mergeinfo
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__verify_root
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|dag_node_t
modifier|*
name|root_dir
decl_stmt|;
comment|/* Issue #4129: bogus pred-counts and minfo-cnt's on the root node-rev      (and elsewhere).  This code makes more thorough checks than the      commit-time checks in validate_root_noderev(). */
comment|/* Callers should disable caches by setting SVN_FS_CONFIG_FSFS_CACHE_NS;      see r1462436.       When this code is called in the library, we want to ensure we      use the on-disk data --- rather than some data that was read      in the possibly-distance past and cached since. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
block|{
name|fs_txn_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_txn_root
argument_list|(
operator|&
name|root_dir
argument_list|,
name|fs
argument_list|,
name|frd
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fs_rev_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
name|root_dir
operator|=
name|frd
operator|->
name|root_dir
expr_stmt|;
block|}
comment|/* Recursively verify ROOT_DIR. */
name|SVN_ERR
argument_list|(
name|verify_node
argument_list|(
name|root_dir
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify explicitly the predecessor of the root. */
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
comment|/* Only r0 should have no predecessor. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|root_dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
operator|&&
operator|!
operator|!
name|pred_id
operator|!=
operator|!
operator|!
name|root
operator|->
name|rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"r%ld's root node's predecessor is "
literal|"unexpectedly '%s'"
argument_list|,
name|root
operator|->
name|rev
argument_list|,
operator|(
name|pred_id
condition|?
name|svn_fs_fs__id_unparse
argument_list|(
name|pred_id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
else|:
literal|"(null)"
operator|)
argument_list|)
return|;
if|if
condition|(
name|root
operator|->
name|is_txn_root
operator|&&
operator|!
name|pred_id
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Transaction '%s''s root node's predecessor is "
literal|"unexpectedly NULL"
argument_list|,
name|root
operator|->
name|txn
argument_list|)
return|;
comment|/* Check the predecessor's revision. */
if|if
condition|(
name|pred_id
condition|)
block|{
name|svn_revnum_t
name|pred_rev
init|=
name|svn_fs_fs__id_rev
argument_list|(
name|pred_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
operator|&&
name|pred_rev
operator|+
literal|1
operator|!=
name|root
operator|->
name|rev
condition|)
comment|/* Issue #4129. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"r%ld's root node's predecessor is r%ld"
literal|" but should be r%ld"
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|pred_rev
argument_list|,
name|root
operator|->
name|rev
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
name|root
operator|->
name|is_txn_root
operator|&&
name|pred_rev
operator|!=
name|root
operator|->
name|rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Transaction '%s''s root node's predecessor"
literal|" is r%ld"
literal|" but should be r%ld"
argument_list|,
name|root
operator|->
name|txn
argument_list|,
name|pred_rev
argument_list|,
name|root
operator|->
name|rev
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

