begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* reps-strings.c : intepreting representations with respect to strings  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"err.h"
end_include

begin_include
include|#
directive|include
file|"trail.h"
end_include

begin_include
include|#
directive|include
file|"reps-strings.h"
end_include

begin_include
include|#
directive|include
file|"bdb/reps-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/strings-table.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_define
define|#
directive|define
name|SVN_WANT_BDB
end_define

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Helper Functions ***/
end_comment

begin_comment
comment|/* Return non-zero iff REP is mutable under transaction TXN_ID. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|rep_is_mutable
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|rep
operator|->
name|txn_id
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|rep
operator|->
name|txn_id
argument_list|,
name|txn_id
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Helper macro that evaluates to an error message indicating that    the representation referred to by X has an unknown node kind. */
end_comment

begin_define
define|#
directive|define
name|UNKNOWN_NODE_KIND
parameter_list|(
name|x
parameter_list|)
define|\
value|svn_error_createf                                            \     (SVN_ERR_FS_CORRUPT, NULL,                                 \      _("Unknown node kind for representation '%s'"), x)
end_define

begin_comment
comment|/* Return a `fulltext' representation, allocated in POOL, which  * references the string STR_KEY.  *  * If TXN_ID is non-zero and non-NULL, make the representation mutable  * under that TXN_ID.  *  * If STR_KEY is non-null, copy it into an allocation from POOL.  *  * If MD5_CHECKSUM is non-null, use it as the MD5 checksum for the new  * rep; else initialize the rep with an all-zero (i.e., always  * successful) MD5 checksum.  *  * If SHA1_CHECKSUM is non-null, use it as the SHA1 checksum for the new  * rep; else initialize the rep with an all-zero (i.e., always  * successful) SHA1 checksum.  */
end_comment

begin_function
specifier|static
name|representation_t
modifier|*
name|make_fulltext_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|str_key
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|svn_checksum_t
modifier|*
name|md5_checksum
parameter_list|,
name|svn_checksum_t
modifier|*
name|sha1_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|txn_id
operator|&&
operator|*
name|txn_id
condition|)
name|rep
operator|->
name|txn_id
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|txn_id
argument_list|)
expr_stmt|;
name|rep
operator|->
name|kind
operator|=
name|rep_kind_fulltext
expr_stmt|;
name|rep
operator|->
name|md5_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|md5_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|rep
operator|->
name|sha1_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|sha1_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
operator|=
name|str_key
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|str_key
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|rep
return|;
block|}
end_function

begin_comment
comment|/* Set *KEYS to an array of string keys gleaned from `delta'    representation REP.  Allocate *KEYS in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_string_keys
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|keys
parameter_list|,
specifier|const
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|chunks
decl_stmt|;
if|if
condition|(
name|rep
operator|->
name|kind
operator|!=
name|rep_kind_delta
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Representation is not of type 'delta'"
argument_list|)
argument_list|)
return|;
comment|/* Set up a convenience variable. */
name|chunks
operator|=
name|rep
operator|->
name|contents
operator|.
name|delta
operator|.
name|chunks
expr_stmt|;
comment|/* Initialize *KEYS to an empty array. */
operator|*
name|keys
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|chunks
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chunks
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Now, push the string keys for each window into *KEYS */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|rep_delta_chunk_t
modifier|*
name|chunk
init|=
name|APR_ARRAY_IDX
argument_list|(
name|chunks
argument_list|,
name|i
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
decl_stmt|;
name|key
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|chunk
operator|->
name|string_key
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|keys
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|key
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Delete the strings associated with array KEYS in FS as part of TRAIL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_strings
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|keys
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|str_key
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keys
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|str_key
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|keys
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_delete
argument_list|(
name|fs
argument_list|,
name|str_key
argument_list|,
name|trail
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Reading the contents from a representation. ***/
end_comment

begin_struct
struct|struct
name|compose_handler_baton
block|{
comment|/* The combined window, and the pool it's allocated from. */
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
name|apr_pool_t
modifier|*
name|window_pool
decl_stmt|;
comment|/* If the incoming window was self-compressed, and the combined WINDOW      exists from previous iterations, SOURCE_BUF will point to the      expanded self-compressed window. */
name|char
modifier|*
name|source_buf
decl_stmt|;
comment|/* The trail for this operation. WINDOW_POOL will be a child of      TRAIL->pool. No allocations will be made from TRAIL->pool itself. */
name|trail_t
modifier|*
name|trail
decl_stmt|;
comment|/* TRUE when no more windows have to be read/combined. */
name|svn_boolean_t
name|done
decl_stmt|;
comment|/* TRUE if we've just started reading a new window. We need this      because the svndiff handler will push a NULL window at the end of      the stream, and we have to ignore that; but we must also know      when it's appropriate to push a NULL window at the combiner. */
name|svn_boolean_t
name|init
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Handle one window. If BATON is emtpy, copy the WINDOW into it;    otherwise, combine WINDOW with the one in BATON, unless WINDOW    is self-compressed (i.e., does not copy from the source view),    in which case expand. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|compose_handler
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|compose_handler_baton
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|cb
operator|->
name|done
operator|||
name|window
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|cb
operator|->
name|trail
operator|&&
name|cb
operator|->
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|init
operator|&&
operator|!
name|window
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* We should never get here if we've already expanded a      self-compressed window. */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|cb
operator|->
name|source_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|window
condition|)
block|{
if|if
condition|(
name|window
operator|&&
operator|(
name|window
operator|->
name|sview_len
operator|==
literal|0
operator|||
name|window
operator|->
name|src_ops
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* This is a self-compressed window. Don't combine it with              the others, because the combiner may go quadratic. Instead,              expand it here and signal that the combination has              ended. */
name|apr_size_t
name|source_len
init|=
name|window
operator|->
name|tview_len
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|cb
operator|->
name|window
operator|->
name|sview_len
operator|==
name|source_len
argument_list|)
expr_stmt|;
name|cb
operator|->
name|source_buf
operator|=
name|apr_palloc
argument_list|(
name|cb
operator|->
name|window_pool
argument_list|,
name|source_len
argument_list|)
expr_stmt|;
name|svn_txdelta_apply_instructions
argument_list|(
name|window
argument_list|,
name|NULL
argument_list|,
name|cb
operator|->
name|source_buf
argument_list|,
operator|&
name|source_len
argument_list|)
expr_stmt|;
name|cb
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Combine the incoming window with whatever's in the baton. */
name|apr_pool_t
modifier|*
name|composite_pool
init|=
name|svn_pool_create
argument_list|(
name|cb
operator|->
name|trail
operator|->
name|pool
argument_list|)
decl_stmt|;
name|svn_txdelta_window_t
modifier|*
name|composite
decl_stmt|;
name|composite
operator|=
name|svn_txdelta_compose_windows
argument_list|(
name|window
argument_list|,
name|cb
operator|->
name|window
argument_list|,
name|composite_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|cb
operator|->
name|window_pool
argument_list|)
expr_stmt|;
name|cb
operator|->
name|window
operator|=
name|composite
expr_stmt|;
name|cb
operator|->
name|window_pool
operator|=
name|composite_pool
expr_stmt|;
name|cb
operator|->
name|done
operator|=
operator|(
name|composite
operator|->
name|sview_len
operator|==
literal|0
operator|||
name|composite
operator|->
name|src_ops
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|window
condition|)
block|{
comment|/* Copy the (first) window into the baton. */
name|apr_pool_t
modifier|*
name|window_pool
init|=
name|svn_pool_create
argument_list|(
name|cb
operator|->
name|trail
operator|->
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|cb
operator|->
name|window_pool
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|cb
operator|->
name|window
operator|=
name|svn_txdelta_window_dup
argument_list|(
name|window
argument_list|,
name|window_pool
argument_list|)
expr_stmt|;
name|cb
operator|->
name|window_pool
operator|=
name|window_pool
expr_stmt|;
name|cb
operator|->
name|done
operator|=
operator|(
name|window
operator|->
name|sview_len
operator|==
literal|0
operator|||
name|window
operator|->
name|src_ops
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
name|cb
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
name|cb
operator|->
name|init
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read one delta window from REP[CUR_CHUNK] and push it at the    composition handler. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_one_window
parameter_list|(
name|struct
name|compose_handler_baton
modifier|*
name|cb
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|int
name|cur_chunk
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|wstream
decl_stmt|;
name|char
name|diffdata
index|[
literal|4096
index|]
decl_stmt|;
comment|/* hunk of svndiff data */
name|svn_filesize_t
name|off
decl_stmt|;
comment|/* offset into svndiff data */
name|apr_size_t
name|amt
decl_stmt|;
comment|/* how much svndiff data to/was read */
specifier|const
name|char
modifier|*
name|str_key
decl_stmt|;
name|apr_array_header_t
modifier|*
name|chunks
init|=
name|rep
operator|->
name|contents
operator|.
name|delta
operator|.
name|chunks
decl_stmt|;
name|rep_delta_chunk_t
modifier|*
name|this_chunk
decl_stmt|,
modifier|*
name|first_chunk
decl_stmt|;
name|cb
operator|->
name|init
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|chunks
operator|->
name|nelts
operator|<=
name|cur_chunk
condition|)
return|return
name|compose_handler
argument_list|(
name|NULL
argument_list|,
name|cb
argument_list|)
return|;
comment|/* Set up a window handling stream for the svndiff data. */
name|wstream
operator|=
name|svn_txdelta_parse_svndiff
argument_list|(
name|compose_handler
argument_list|,
name|cb
argument_list|,
name|TRUE
argument_list|,
name|cb
operator|->
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* First things first:  send the "SVN"{version} header through the      stream.  ### For now, we will just use the version specified      in the first chunk, and then verify that no chunks have a      different version number than the one used.  In the future,      we might simply convert chunks that use a different version      of the diff format -- or, heck, a different format      altogether -- to the format/version of the first chunk.  */
name|first_chunk
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|chunks
argument_list|,
literal|0
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
expr_stmt|;
name|diffdata
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|diffdata
index|[
literal|1
index|]
operator|=
literal|'V'
expr_stmt|;
name|diffdata
index|[
literal|2
index|]
operator|=
literal|'N'
expr_stmt|;
name|diffdata
index|[
literal|3
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|first_chunk
operator|->
name|version
argument_list|)
expr_stmt|;
name|amt
operator|=
literal|4
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|wstream
argument_list|,
name|diffdata
argument_list|,
operator|&
name|amt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: The stream write handler is borked; assert (amt == 4); */
comment|/* Get this string key which holds this window's data.      ### todo: make sure this is an `svndiff' DIFF skel here. */
name|this_chunk
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|chunks
argument_list|,
name|cur_chunk
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
expr_stmt|;
name|str_key
operator|=
name|this_chunk
operator|->
name|string_key
expr_stmt|;
comment|/* Run through the svndiff data, at least as far as necessary. */
name|off
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|diffdata
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_read
argument_list|(
name|fs
argument_list|,
name|str_key
argument_list|,
name|diffdata
argument_list|,
name|off
argument_list|,
operator|&
name|amt
argument_list|,
name|cb
operator|->
name|trail
argument_list|,
name|cb
operator|->
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|+=
name|amt
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|wstream
argument_list|,
name|diffdata
argument_list|,
operator|&
name|amt
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|amt
operator|!=
literal|0
condition|)
do|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|wstream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|cb
operator|->
name|init
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|cb
operator|->
name|window
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|cb
operator|->
name|window_pool
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Undeltify a range of data. DELTAS is the set of delta windows to    combine, FULLTEXT is the source text, CUR_CHUNK is the index of the    delta chunk we're starting from. OFFSET is the relative offset of    the requested data within the chunk; BUF and LEN are what we're    undeltifying to. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_undeltify_range
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|deltas
parameter_list|,
name|representation_t
modifier|*
name|fulltext
parameter_list|,
name|int
name|cur_chunk
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len_read
init|=
literal|0
decl_stmt|;
do|do
block|{
name|struct
name|compose_handler_baton
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|source_buf
decl_stmt|,
modifier|*
name|target_buf
decl_stmt|;
name|apr_size_t
name|target_len
decl_stmt|;
name|int
name|cur_rep
decl_stmt|;
name|cb
operator|.
name|trail
operator|=
name|trail
expr_stmt|;
name|cb
operator|.
name|done
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cur_rep
operator|=
literal|0
init|;
operator|!
name|cb
operator|.
name|done
operator|&&
name|cur_rep
operator|<
name|deltas
operator|->
name|nelts
condition|;
operator|++
name|cur_rep
control|)
block|{
name|representation_t
modifier|*
specifier|const
name|rep
init|=
name|APR_ARRAY_IDX
argument_list|(
name|deltas
argument_list|,
name|cur_rep
argument_list|,
name|representation_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_one_window
argument_list|(
operator|&
name|cb
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|cur_chunk
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cb
operator|.
name|window
condition|)
comment|/* That's it, no more source data is available. */
break|break;
comment|/* The source view length should not be 0 if there are source          copy ops in the window. */
name|SVN_ERR_ASSERT
argument_list|(
name|cb
operator|.
name|window
operator|->
name|sview_len
operator|>
literal|0
operator|||
name|cb
operator|.
name|window
operator|->
name|src_ops
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* cb.window is the combined delta window. Read the source text          into a buffer. */
if|if
condition|(
name|cb
operator|.
name|source_buf
condition|)
block|{
comment|/* The combiner already created the source text from a              self-compressed window. */
name|source_buf
operator|=
name|cb
operator|.
name|source_buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fulltext
operator|&&
name|cb
operator|.
name|window
operator|->
name|sview_len
operator|>
literal|0
operator|&&
name|cb
operator|.
name|window
operator|->
name|src_ops
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|source_len
init|=
name|cb
operator|.
name|window
operator|->
name|sview_len
decl_stmt|;
name|source_buf
operator|=
name|apr_palloc
argument_list|(
name|cb
operator|.
name|window_pool
argument_list|,
name|source_len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_read
argument_list|(
name|fs
argument_list|,
name|fulltext
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
argument_list|,
name|source_buf
argument_list|,
name|cb
operator|.
name|window
operator|->
name|sview_offset
argument_list|,
operator|&
name|source_len
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_len
operator|!=
name|cb
operator|.
name|window
operator|->
name|sview_len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Svndiff source length inconsistency"
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|source_buf
operator|=
name|NULL
expr_stmt|;
comment|/* Won't read anything from here. */
block|}
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|target_len
operator|=
operator|*
name|len
operator|-
name|len_read
operator|+
name|offset
expr_stmt|;
name|target_buf
operator|=
name|apr_palloc
argument_list|(
name|cb
operator|.
name|window_pool
argument_list|,
name|target_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target_len
operator|=
operator|*
name|len
operator|-
name|len_read
expr_stmt|;
name|target_buf
operator|=
name|buf
expr_stmt|;
block|}
name|svn_txdelta_apply_instructions
argument_list|(
name|cb
operator|.
name|window
argument_list|,
name|source_buf
argument_list|,
name|target_buf
argument_list|,
operator|&
name|target_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|target_len
operator|>
name|offset
argument_list|)
expr_stmt|;
name|target_len
operator|-=
name|offset
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|target_buf
operator|+
name|offset
argument_list|,
name|target_len
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Read from the beginning of the next chunk. */
block|}
comment|/* Don't need this window any more. */
name|svn_pool_destroy
argument_list|(
name|cb
operator|.
name|window_pool
argument_list|)
expr_stmt|;
name|len_read
operator|+=
name|target_len
expr_stmt|;
name|buf
operator|+=
name|target_len
expr_stmt|;
operator|++
name|cur_chunk
expr_stmt|;
block|}
do|while
condition|(
name|len_read
operator|<
operator|*
name|len
condition|)
do|;
operator|*
name|len
operator|=
name|len_read
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the index of the chunk in REP that contains REP_OFFSET,    and find the relative CHUNK_OFFSET within the chunk.    Return -1 if offset is beyond the end of the represented data.    ### The basic assumption is that all delta windows are the same size    and aligned at the same offset, so this number is the same in all    dependent deltas.  Oh, and the chunks in REP must be ordered. */
end_comment

begin_function
specifier|static
name|int
name|get_chunk_offset
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|svn_filesize_t
name|rep_offset
parameter_list|,
name|apr_size_t
modifier|*
name|chunk_offset
parameter_list|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|chunks
init|=
name|rep
operator|->
name|contents
operator|.
name|delta
operator|.
name|chunks
decl_stmt|;
name|int
name|cur_chunk
decl_stmt|;
name|assert
argument_list|(
name|chunks
operator|->
name|nelts
argument_list|)
expr_stmt|;
comment|/* ### Yes, this is a linear search.  I'll change this to bisection      the very second we notice it's slowing us down. */
for|for
control|(
name|cur_chunk
operator|=
literal|0
init|;
name|cur_chunk
operator|<
name|chunks
operator|->
name|nelts
condition|;
operator|++
name|cur_chunk
control|)
block|{
specifier|const
name|rep_delta_chunk_t
modifier|*
specifier|const
name|this_chunk
init|=
name|APR_ARRAY_IDX
argument_list|(
name|chunks
argument_list|,
name|cur_chunk
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|this_chunk
operator|->
name|offset
operator|+
name|this_chunk
operator|->
name|size
operator|)
operator|>
name|rep_offset
condition|)
block|{
name|assert
argument_list|(
name|this_chunk
operator|->
name|offset
operator|<=
name|rep_offset
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rep_offset
operator|-
name|this_chunk
operator|->
name|offset
operator|<
name|SVN_MAX_OBJECT_SIZE
argument_list|)
expr_stmt|;
operator|*
name|chunk_offset
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|rep_offset
operator|-
name|this_chunk
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
name|cur_chunk
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copy into BUF *LEN bytes starting at OFFSET from the string    represented via REP_KEY in FS, as part of TRAIL.    The number of bytes actually copied is stored in *LEN.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_range
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
name|svn_filesize_t
name|offset
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|apr_size_t
name|chunk_offset
decl_stmt|;
comment|/* Read in our REP. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_fulltext
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_read
argument_list|(
name|fs
argument_list|,
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_delta
condition|)
block|{
specifier|const
name|int
name|cur_chunk
init|=
name|get_chunk_offset
argument_list|(
name|rep
argument_list|,
name|offset
argument_list|,
operator|&
name|chunk_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_chunk
operator|<
literal|0
condition|)
operator|*
name|len
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Preserve for potential use in error message. */
specifier|const
name|char
modifier|*
name|first_rep_key
init|=
name|rep_key
decl_stmt|;
comment|/* Make a list of all the rep's we need to undeltify this range.              We'll have to read them within this trail anyway, so we might              as well do it once and up front. */
name|apr_array_header_t
modifier|*
name|reps
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|30
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
argument_list|)
argument_list|)
decl_stmt|;
do|do
block|{
specifier|const
name|rep_delta_chunk_t
modifier|*
specifier|const
name|first_chunk
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rep
operator|->
name|contents
operator|.
name|delta
operator|.
name|chunks
argument_list|,
literal|0
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|rep_delta_chunk_t
modifier|*
specifier|const
name|chunk
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rep
operator|->
name|contents
operator|.
name|delta
operator|.
name|chunks
argument_list|,
name|cur_chunk
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
decl_stmt|;
comment|/* Verify that this chunk is of the same version as the first. */
if|if
condition|(
name|first_chunk
operator|->
name|version
operator|!=
name|chunk
operator|->
name|version
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Diff version inconsistencies in representation '%s'"
argument_list|)
argument_list|,
name|rep_key
argument_list|)
return|;
name|rep_key
operator|=
name|chunk
operator|->
name|rep_key
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|reps
argument_list|,
name|representation_t
operator|*
argument_list|)
operator|=
name|rep
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_delta
operator|&&
name|rep
operator|->
name|contents
operator|.
name|delta
operator|.
name|chunks
operator|->
name|nelts
operator|>
name|cur_chunk
condition|)
do|;
comment|/* Right. We've either just read the fulltext rep, or a rep that's              too short, in which case we'll undeltify without source data.*/
if|if
condition|(
name|rep
operator|->
name|kind
operator|!=
name|rep_kind_delta
operator|&&
name|rep
operator|->
name|kind
operator|!=
name|rep_kind_fulltext
condition|)
return|return
name|UNKNOWN_NODE_KIND
argument_list|(
name|rep_key
argument_list|)
return|;
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_delta
condition|)
name|rep
operator|=
name|NULL
expr_stmt|;
comment|/* Don't use source data */
name|err
operator|=
name|rep_undeltify_range
argument_list|(
name|fs
argument_list|,
name|reps
argument_list|,
name|rep
argument_list|,
name|cur_chunk
argument_list|,
name|buf
argument_list|,
name|chunk_offset
argument_list|,
name|len
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CORRUPT
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Corruption detected whilst reading delta chain from "
literal|"representation '%s' to '%s'"
argument_list|)
argument_list|,
name|first_rep_key
argument_list|,
name|rep_key
argument_list|)
return|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
block|}
else|else
comment|/* unknown kind */
return|return
name|UNKNOWN_NODE_KIND
argument_list|(
name|rep_key
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__get_mutable_rep
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|new_rep_key
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_str
init|=
name|NULL
decl_stmt|;
comment|/* We were passed an existing REP_KEY, so examine it.  If it is      mutable already, then just return REP_KEY as the mutable result      key.  */
if|if
condition|(
name|rep_key
operator|&&
operator|(
name|rep_key
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep_is_mutable
argument_list|(
name|rep
argument_list|,
name|txn_id
argument_list|)
condition|)
block|{
operator|*
name|new_rep_key
operator|=
name|rep_key
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Either we weren't provided a base key to examine, or the base key      we were provided was not mutable.  So, let's make a new      representation and return its key to the caller. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_append
argument_list|(
name|fs
argument_list|,
operator|&
name|new_str
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|=
name|make_fulltext_rep
argument_list|(
name|new_str
argument_list|,
name|txn_id
argument_list|,
name|svn_checksum_empty_checksum
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_checksum_empty_checksum
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_fs_bdb__write_new_rep
argument_list|(
name|new_rep_key
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__delete_rep_if_mutable
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rep_is_mutable
argument_list|(
name|rep
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_fulltext
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_delete
argument_list|(
name|fs
argument_list|,
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_delta
condition|)
block|{
name|apr_array_header_t
modifier|*
name|keys
decl_stmt|;
name|SVN_ERR
argument_list|(
name|delta_string_keys
argument_list|(
operator|&
name|keys
argument_list|,
name|rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delete_strings
argument_list|(
name|keys
argument_list|,
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* unknown kind */
return|return
name|UNKNOWN_NODE_KIND
argument_list|(
name|rep_key
argument_list|)
return|;
return|return
name|svn_fs_bdb__delete_rep
argument_list|(
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Reading and writing data via representations. ***/
end_comment

begin_comment
comment|/** Reading. **/
end_comment

begin_struct
struct|struct
name|rep_read_baton
block|{
comment|/* The FS from which we're reading. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* The representation skel whose contents we want to read.  If this      is NULL, the rep has never had any contents, so all reads fetch 0      bytes.       Formerly, we cached the entire rep skel here, not just the key.      That way we didn't have to fetch the rep from the db every time      we want to read a little bit more of the file.  Unfortunately,      this has a problem: if, say, a file's representation changes      while we're reading (changes from fulltext to delta, for      example), we'll never know it.  So for correctness, we now      refetch the representation skel every time we want to read      another chunk.  */
specifier|const
name|char
modifier|*
name|rep_key
decl_stmt|;
comment|/* How many bytes have been read already. */
name|svn_filesize_t
name|offset
decl_stmt|;
comment|/* If present, the read will be done as part of this trail, and the      trail's pool will be used.  Otherwise, see `pool' below.  */
name|trail_t
modifier|*
name|trail
decl_stmt|;
comment|/* MD5 checksum context.  Initialized when the baton is created, updated as      we read data, and finalized when the stream is closed. */
name|svn_checksum_ctx_t
modifier|*
name|md5_checksum_ctx
decl_stmt|;
comment|/* Final resting place of the checksum created by md5_checksum_cxt. */
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
comment|/* SHA1 checksum context.  Initialized when the baton is created, updated as      we read data, and finalized when the stream is closed. */
name|svn_checksum_ctx_t
modifier|*
name|sha1_checksum_ctx
decl_stmt|;
comment|/* Final resting place of the checksum created by sha1_checksum_cxt. */
name|svn_checksum_t
modifier|*
name|sha1_checksum
decl_stmt|;
comment|/* The length of the rep's contents (as fulltext, that is,      independent of how the rep actually stores the data.)  This is      retrieved when the baton is created, and used to determine when      we have read the last byte, at which point we compare checksums.       Getting this at baton creation time makes interleaved reads and      writes on the same rep in the same trail impossible.  But we're      not doing that, and probably no one ever should.  And anyway if      they do, they should see problems immediately. */
name|svn_filesize_t
name|size
decl_stmt|;
comment|/* Set to FALSE when the baton is created, TRUE when the checksum_ctx      is digestified. */
name|svn_boolean_t
name|checksum_finalized
decl_stmt|;
comment|/* Used for temporary allocations.  This pool is cleared at the      start of each invocation of the relevant stream read function --      see rep_read_contents().  */
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_get_baton
parameter_list|(
name|struct
name|rep_read_baton
modifier|*
modifier|*
name|rb_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
name|svn_boolean_t
name|use_trail_for_reads
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_read_baton
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|md5_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|sha1_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep_key
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_size
argument_list|(
operator|&
operator|(
name|b
operator|->
name|size
operator|)
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|checksum_finalized
operator|=
name|FALSE
expr_stmt|;
name|b
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|->
name|trail
operator|=
name|use_trail_for_reads
condition|?
name|trail
else|:
name|NULL
expr_stmt|;
name|b
operator|->
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|rep_key
operator|=
name|rep_key
expr_stmt|;
name|b
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
operator|*
name|rb_p
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Retrieving data. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__rep_contents_size
parameter_list|(
name|svn_filesize_t
modifier|*
name|size_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_fulltext
condition|)
block|{
comment|/* Get the size by asking Berkeley for the string's length. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_size
argument_list|(
name|size_p
argument_list|,
name|fs
argument_list|,
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_delta
condition|)
block|{
comment|/* Get the size by finding the last window pkg in the delta and          adding its offset to its size.  This way, we won't even be          messed up by overlapping windows, as long as the window pkgs          are still ordered. */
name|apr_array_header_t
modifier|*
name|chunks
init|=
name|rep
operator|->
name|contents
operator|.
name|delta
operator|.
name|chunks
decl_stmt|;
name|rep_delta_chunk_t
modifier|*
name|last_chunk
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|chunks
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|last_chunk
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|chunks
argument_list|,
name|chunks
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
expr_stmt|;
operator|*
name|size_p
operator|=
name|last_chunk
operator|->
name|offset
operator|+
name|last_chunk
operator|->
name|size
expr_stmt|;
block|}
else|else
comment|/* unknown kind */
return|return
name|UNKNOWN_NODE_KIND
argument_list|(
name|rep_key
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__rep_contents_checksums
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|md5_checksum
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|sha1_checksum
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|md5_checksum
condition|)
operator|*
name|md5_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|rep
operator|->
name|md5_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1_checksum
condition|)
operator|*
name|sha1_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__rep_contents
parameter_list|(
name|svn_string_t
modifier|*
name|str
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_filesize_t
name|contents_size
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_size
argument_list|(
operator|&
name|contents_size
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* What if the contents are larger than we can handle? */
if|if
condition|(
name|contents_size
operator|>
name|SVN_MAX_OBJECT_SIZE
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Rep contents are too large: "
literal|"got %s, limit is %s"
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|SVN_FILESIZE_T_FMT
argument_list|,
name|contents_size
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
argument_list|,
name|SVN_MAX_OBJECT_SIZE
argument_list|)
argument_list|)
return|;
else|else
name|str
operator|->
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|contents_size
expr_stmt|;
name|data
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|str
operator|->
name|len
argument_list|)
expr_stmt|;
name|str
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|len
operator|=
name|str
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|rep_read_range
argument_list|(
name|fs
argument_list|,
name|rep_key
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
operator|&
name|len
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Paranoia. */
if|if
condition|(
name|len
operator|!=
name|str
operator|->
name|len
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failure reading representation '%s'"
argument_list|)
argument_list|,
name|rep_key
argument_list|)
return|;
comment|/* Just the standard paranoia. */
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|,
modifier|*
name|rep_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep_checksum
operator|=
name|rep
operator|->
name|sha1_checksum
condition|?
name|rep
operator|->
name|sha1_checksum
else|:
name|rep
operator|->
name|md5_checksum
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|rep_checksum
operator|->
name|kind
argument_list|,
name|str
operator|->
name|data
argument_list|,
name|str
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|checksum
argument_list|,
name|rep_checksum
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|svn_checksum_mismatch_err
argument_list|(
name|rep_checksum
argument_list|,
name|checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch on representation '%s'"
argument_list|)
argument_list|,
name|rep_key
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|read_rep_args
block|{
name|struct
name|rep_read_baton
modifier|*
name|rb
decl_stmt|;
comment|/* The data source.             */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where to put what we read.   */
name|apr_size_t
modifier|*
name|len
decl_stmt|;
comment|/* How much to read / was read. */
block|}
struct|;
end_struct

begin_comment
comment|/* BATON is of type `read_rep_args':     Read into BATON->rb->buf the *(BATON->len) bytes starting at    BATON->rb->offset from the data represented at BATON->rb->rep_key    in BATON->rb->fs, as part of TRAIL.     Afterwards, *(BATON->len) is the number of bytes actually read, and    BATON->rb->offset is incremented by that amount.     If BATON->rb->rep_key is null, this is assumed to mean the file's    contents have no representation, i.e., the file has no contents.    In that case, if BATON->rb->offset> 0, return the error    SVN_ERR_FS_FILE_CONTENTS_CHANGED, else just set *(BATON->len) to    zero and return.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_read_rep
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|read_rep_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|rb
operator|->
name|rep_key
condition|)
block|{
name|SVN_ERR
argument_list|(
name|rep_read_range
argument_list|(
name|args
operator|->
name|rb
operator|->
name|fs
argument_list|,
name|args
operator|->
name|rb
operator|->
name|rep_key
argument_list|,
name|args
operator|->
name|rb
operator|->
name|offset
argument_list|,
name|args
operator|->
name|buf
argument_list|,
name|args
operator|->
name|len
argument_list|,
name|trail
argument_list|,
name|args
operator|->
name|rb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|rb
operator|->
name|offset
operator|+=
operator|*
operator|(
name|args
operator|->
name|len
operator|)
expr_stmt|;
comment|/* We calculate the checksum just once, the moment we see the        * last byte of data.  But we can't assume there was a short        * read.  The caller may have known the length of the data and        * requested exactly that amount, so there would never be a        * short read.  (That's why the read baton has to know the        * length of the data in advance.)        *        * On the other hand, some callers invoke the stream reader in a        * loop whose termination condition is that the read returned        * zero bytes of data -- which usually results in the read        * function being called one more time *after* the call that got        * a short read (indicating end-of-stream).        *        * The conditions below ensure that we compare checksums even        * when there is no short read associated with the last byte of        * data, while also ensuring that it's harmless to repeatedly        * read 0 bytes from the stream.        */
if|if
condition|(
operator|!
name|args
operator|->
name|rb
operator|->
name|checksum_finalized
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|args
operator|->
name|rb
operator|->
name|md5_checksum_ctx
argument_list|,
name|args
operator|->
name|buf
argument_list|,
operator|*
operator|(
name|args
operator|->
name|len
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|args
operator|->
name|rb
operator|->
name|sha1_checksum_ctx
argument_list|,
name|args
operator|->
name|buf
argument_list|,
operator|*
operator|(
name|args
operator|->
name|len
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|rb
operator|->
name|offset
operator|==
name|args
operator|->
name|rb
operator|->
name|size
condition|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|args
operator|->
name|rb
operator|->
name|md5_checksum
argument_list|,
name|args
operator|->
name|rb
operator|->
name|md5_checksum_ctx
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|args
operator|->
name|rb
operator|->
name|sha1_checksum
argument_list|,
name|args
operator|->
name|rb
operator|->
name|sha1_checksum_ctx
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|rb
operator|->
name|checksum_finalized
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|args
operator|->
name|rb
operator|->
name|fs
argument_list|,
name|args
operator|->
name|rb
operator|->
name|rep_key
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|md5_checksum
operator|&&
operator|(
operator|!
name|svn_checksum_match
argument_list|(
name|rep
operator|->
name|md5_checksum
argument_list|,
name|args
operator|->
name|rb
operator|->
name|md5_checksum
argument_list|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|svn_checksum_mismatch_err
argument_list|(
name|rep
operator|->
name|md5_checksum
argument_list|,
name|args
operator|->
name|rb
operator|->
name|sha1_checksum
argument_list|,
name|trail
operator|->
name|pool
argument_list|,
name|_
argument_list|(
literal|"MD5 checksum mismatch on representation '%s'"
argument_list|)
argument_list|,
name|args
operator|->
name|rb
operator|->
name|rep_key
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|rep
operator|->
name|sha1_checksum
operator|&&
operator|(
operator|!
name|svn_checksum_match
argument_list|(
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|args
operator|->
name|rb
operator|->
name|sha1_checksum
argument_list|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|svn_checksum_mismatch_err
argument_list|(
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|args
operator|->
name|rb
operator|->
name|sha1_checksum
argument_list|,
name|trail
operator|->
name|pool
argument_list|,
name|_
argument_list|(
literal|"SHA1 checksum mismatch on representation '%s'"
argument_list|)
argument_list|,
name|args
operator|->
name|rb
operator|->
name|rep_key
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|args
operator|->
name|rb
operator|->
name|offset
operator|>
literal|0
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_REP_CHANGED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Null rep, but offset past zero already"
argument_list|)
argument_list|)
return|;
block|}
else|else
operator|*
operator|(
name|args
operator|->
name|len
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|rep_read_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|struct
name|read_rep_args
name|args
decl_stmt|;
comment|/* Clear the scratch pool of the results of previous invocations. */
name|svn_pool_clear
argument_list|(
name|rb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|args
operator|.
name|rb
operator|=
name|rb
expr_stmt|;
name|args
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|args
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* If we got a trail, use it; else make one. */
if|if
condition|(
name|rb
operator|->
name|trail
condition|)
name|SVN_ERR
argument_list|(
name|txn_body_read_rep
argument_list|(
operator|&
name|args
argument_list|,
name|rb
operator|->
name|trail
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* In the case of reading from the db, any returned data should          live in our pre-allocated buffer, so the whole operation can          happen within a single malloc/free cycle.  This prevents us          from creating millions of unnecessary trail subpools when          reading a big file.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|rb
operator|->
name|fs
argument_list|,
name|txn_body_read_rep
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|rb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/** Writing. **/
end_comment

begin_struct
struct|struct
name|rep_write_baton
block|{
comment|/* The FS in which we're writing. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* The representation skel whose contents we want to write. */
specifier|const
name|char
modifier|*
name|rep_key
decl_stmt|;
comment|/* The transaction id under which this write action will take      place. */
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
comment|/* If present, do the write as part of this trail, and use trail's      pool.  Otherwise, see `pool' below.  */
name|trail_t
modifier|*
name|trail
decl_stmt|;
comment|/* SHA1 and MD5 checksums.  Initialized when the baton is created,      updated as we write data, and finalized and stored when the      stream is closed. */
name|svn_checksum_ctx_t
modifier|*
name|md5_checksum_ctx
decl_stmt|;
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|sha1_checksum_ctx
decl_stmt|;
name|svn_checksum_t
modifier|*
name|sha1_checksum
decl_stmt|;
name|svn_boolean_t
name|finalized
decl_stmt|;
comment|/* Used for temporary allocations, iff `trail' (above) is null.  */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|rep_write_baton
modifier|*
name|rep_write_get_baton
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|md5_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|sha1_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|->
name|trail
operator|=
name|trail
expr_stmt|;
name|b
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|b
operator|->
name|rep_key
operator|=
name|rep_key
expr_stmt|;
name|b
operator|->
name|txn_id
operator|=
name|txn_id
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Write LEN bytes from BUF into the end of the string represented via    REP_KEY in FS, as part of TRAIL.  If the representation is not    mutable, return the error SVN_FS_REP_NOT_MUTABLE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_write
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rep_is_mutable
argument_list|(
name|rep
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_REP_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Rep '%s' is not mutable"
argument_list|)
argument_list|,
name|rep_key
argument_list|)
return|;
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_fulltext
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_append
argument_list|(
name|fs
argument_list|,
operator|&
operator|(
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
operator|)
argument_list|,
name|len
argument_list|,
name|buf
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_delta
condition|)
block|{
comment|/* There should never be a case when we have a mutable          non-fulltext rep.  The only code that creates mutable reps is          in this file, and it creates them fulltext. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Rep '%s' both mutable and non-fulltext"
argument_list|)
argument_list|,
name|rep_key
argument_list|)
return|;
block|}
else|else
comment|/* unknown kind */
return|return
name|UNKNOWN_NODE_KIND
argument_list|(
name|rep_key
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|write_rep_args
block|{
name|struct
name|rep_write_baton
modifier|*
name|wb
decl_stmt|;
comment|/* Destination.       */
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Data.              */
name|apr_size_t
name|len
decl_stmt|;
comment|/* How much to write. */
block|}
struct|;
end_struct

begin_comment
comment|/* BATON is of type `write_rep_args':    Append onto BATON->wb->rep_key's contents BATON->len bytes of    data from BATON->wb->buf, in BATON->rb->fs, as part of TRAIL.     If the representation is not mutable, return the error    SVN_FS_REP_NOT_MUTABLE.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_write_rep
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|write_rep_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|rep_write
argument_list|(
name|args
operator|->
name|wb
operator|->
name|fs
argument_list|,
name|args
operator|->
name|wb
operator|->
name|rep_key
argument_list|,
name|args
operator|->
name|buf
argument_list|,
name|args
operator|->
name|len
argument_list|,
name|args
operator|->
name|wb
operator|->
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|args
operator|->
name|wb
operator|->
name|md5_checksum_ctx
argument_list|,
name|args
operator|->
name|buf
argument_list|,
name|args
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|args
operator|->
name|wb
operator|->
name|sha1_checksum_ctx
argument_list|,
name|args
operator|->
name|buf
argument_list|,
name|args
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_write_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|wb
init|=
name|baton
decl_stmt|;
name|struct
name|write_rep_args
name|args
decl_stmt|;
comment|/* We toss LEN's indirectness because if not all the bytes are      written, it's an error, so we wouldn't be reporting anything back      through *LEN anyway. */
name|args
operator|.
name|wb
operator|=
name|wb
expr_stmt|;
name|args
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|args
operator|.
name|len
operator|=
operator|*
name|len
expr_stmt|;
comment|/* If we got a trail, use it; else make one. */
if|if
condition|(
name|wb
operator|->
name|trail
condition|)
name|SVN_ERR
argument_list|(
name|txn_body_write_rep
argument_list|(
operator|&
name|args
argument_list|,
name|wb
operator|->
name|trail
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* In the case of simply writing the rep to the db, we're          *certain* that there's no data coming back to us that needs          to be preserved... so the whole operation can happen within a          single malloc/free cycle.  This prevents us from creating          millions of unnecessary trail subpools when writing a big          file. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|wb
operator|->
name|fs
argument_list|,
name|txn_body_write_rep
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|wb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for rep_write_close_contents(); see that doc string for    more.  BATON is of type `struct rep_write_baton'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_write_close_rep
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|wb
init|=
name|baton
decl_stmt|;
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|wb
operator|->
name|fs
argument_list|,
name|wb
operator|->
name|rep_key
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|md5_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|wb
operator|->
name|md5_checksum
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
name|rep
operator|->
name|sha1_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|wb
operator|->
name|sha1_checksum
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_fs_bdb__write_rep
argument_list|(
name|wb
operator|->
name|fs
argument_list|,
name|wb
operator|->
name|rep_key
argument_list|,
name|rep
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* BATON is of type `struct rep_write_baton'.  *  * Finalize BATON->md5_context and store the resulting digest under  * BATON->rep_key.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_write_close_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|wb
init|=
name|baton
decl_stmt|;
comment|/* ### Thought: if we fixed apr-util MD5 contexts to allow repeated      digestification, then we wouldn't need a stream close function at      all -- instead, we could update the stored checksum each time a      write occurred, which would have the added advantage of making      interleaving reads and writes work.  Currently, they'd fail with      a checksum mismatch, it just happens that our code never tries to      do that anyway. */
if|if
condition|(
operator|!
name|wb
operator|->
name|finalized
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|wb
operator|->
name|md5_checksum
argument_list|,
name|wb
operator|->
name|md5_checksum_ctx
argument_list|,
name|wb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|wb
operator|->
name|sha1_checksum
argument_list|,
name|wb
operator|->
name|sha1_checksum_ctx
argument_list|,
name|wb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|wb
operator|->
name|finalized
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If we got a trail, use it; else make one. */
if|if
condition|(
name|wb
operator|->
name|trail
condition|)
return|return
name|txn_body_write_close_rep
argument_list|(
name|wb
argument_list|,
name|wb
operator|->
name|trail
argument_list|)
return|;
else|else
comment|/* We need to keep our trail pool around this time so the        checksums we've calculated survive. */
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|wb
operator|->
name|fs
argument_list|,
name|txn_body_write_close_rep
argument_list|,
name|wb
argument_list|,
name|FALSE
argument_list|,
name|wb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Public read and write stream constructors. **/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__rep_contents_read_stream
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|rs_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
name|svn_boolean_t
name|use_trail_for_reads
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_read_baton
modifier|*
name|rb
decl_stmt|;
name|SVN_ERR
argument_list|(
name|rep_read_get_baton
argument_list|(
operator|&
name|rb
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|use_trail_for_reads
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rs_p
operator|=
name|svn_stream_create
argument_list|(
name|rb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
operator|*
name|rs_p
argument_list|,
name|rep_read_contents
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Clear the contents of REP_KEY, so that it represents the empty    string, as part of TRAIL.  TXN_ID is the id of the Subversion    transaction under which this occurs.  If REP_KEY is not mutable,    return the error SVN_ERR_FS_REP_NOT_MUTABLE.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_contents_clear
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
specifier|const
name|char
modifier|*
name|str_key
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|rep_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure it's mutable. */
if|if
condition|(
operator|!
name|rep_is_mutable
argument_list|(
name|rep
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_REP_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Rep '%s' is not mutable"
argument_list|)
argument_list|,
name|rep_key
argument_list|)
return|;
name|SVN_ERR_ASSERT
argument_list|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_fulltext
argument_list|)
expr_stmt|;
comment|/* If rep has no string, just return success.  Else, clear the      underlying string.  */
name|str_key
operator|=
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
expr_stmt|;
if|if
condition|(
name|str_key
operator|&&
operator|*
name|str_key
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_clear
argument_list|(
name|fs
argument_list|,
name|str_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|md5_checksum
operator|=
name|NULL
expr_stmt|;
name|rep
operator|->
name|sha1_checksum
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__write_rep
argument_list|(
name|fs
argument_list|,
name|rep_key
argument_list|,
name|rep
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__rep_contents_write_stream
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|ws_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|rep_key
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|svn_boolean_t
name|use_trail_for_writes
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|wb
decl_stmt|;
comment|/* Clear the current rep contents (free mutability check!). */
name|SVN_ERR
argument_list|(
name|rep_contents_clear
argument_list|(
name|fs
argument_list|,
name|rep_key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, generate the write baton and stream. */
name|wb
operator|=
name|rep_write_get_baton
argument_list|(
name|fs
argument_list|,
name|rep_key
argument_list|,
name|txn_id
argument_list|,
name|use_trail_for_writes
condition|?
name|trail
else|:
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|ws_p
operator|=
name|svn_stream_create
argument_list|(
name|wb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
operator|*
name|ws_p
argument_list|,
name|rep_write_contents
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
operator|*
name|ws_p
argument_list|,
name|rep_write_close_contents
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Deltified storage. ***/
end_comment

begin_comment
comment|/* Baton for svn_write_fn_t write_string_set(). */
end_comment

begin_struct
struct|struct
name|write_svndiff_strings_baton
block|{
comment|/* The fs where lives the string we're writing. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* The key of the string we're writing to.  Typically this is      initialized to NULL, so svn_fs_base__string_append() can fill in a      value. */
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
comment|/* The amount of txdelta data written to the current      string-in-progress. */
name|apr_size_t
name|size
decl_stmt|;
comment|/* The amount of svndiff header information we've written thus far      to the strings table. */
name|apr_size_t
name|header_read
decl_stmt|;
comment|/* The version number of the svndiff data written.  ### You'd better      not count on this being populated after the first chunk is sent      through the interface, since it lives at the 4th byte of the      stream. */
name|apr_byte_t
name|version
decl_stmt|;
comment|/* The trail we're writing in. */
name|trail_t
modifier|*
name|trail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Function of type `svn_write_fn_t', for writing to a collection of    strings; BATON is `struct write_svndiff_strings_baton *'.     On the first call, BATON->key is null.  A new string key in    BATON->fs is chosen and stored in BATON->key; each call appends    *LEN bytes from DATA onto the string.  *LEN is never changed; if    the write fails to write all *LEN bytes, an error is returned.    BATON->size is used to track the total amount of data written via    this handler, and must be reset by the caller to 0 when appropriate.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_svndiff_strings
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|write_svndiff_strings_baton
modifier|*
name|wb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
init|=
name|data
decl_stmt|;
name|apr_size_t
name|nheader
init|=
literal|0
decl_stmt|;
comment|/* If we haven't stripped all the header information from this      stream yet, keep stripping.  If someone sends a first window      through here that's shorter than 4 bytes long, this will probably      cause a nuclear reactor meltdown somewhere in the American      midwest.  */
if|if
condition|(
name|wb
operator|->
name|header_read
operator|<
literal|4
condition|)
block|{
name|nheader
operator|=
literal|4
operator|-
name|wb
operator|->
name|header_read
expr_stmt|;
operator|*
name|len
operator|-=
name|nheader
expr_stmt|;
name|buf
operator|+=
name|nheader
expr_stmt|;
name|wb
operator|->
name|header_read
operator|+=
name|nheader
expr_stmt|;
comment|/* If we have *now* read the full 4-byte header, check that          least byte for the version number of the svndiff format. */
if|if
condition|(
name|wb
operator|->
name|header_read
operator|==
literal|4
condition|)
name|wb
operator|->
name|version
operator|=
operator|*
operator|(
name|buf
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Append to the current string we're writing (or create a new one      if WB->key is NULL). */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_append
argument_list|(
name|wb
operator|->
name|fs
argument_list|,
operator|&
operator|(
name|wb
operator|->
name|key
operator|)
argument_list|,
operator|*
name|len
argument_list|,
name|buf
argument_list|,
name|wb
operator|->
name|trail
argument_list|,
name|wb
operator|->
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure we (still) have a key. */
if|if
condition|(
name|wb
operator|->
name|key
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to get new string key"
argument_list|)
argument_list|)
return|;
comment|/* Restore *LEN to the value it *would* have been were it not for      header stripping. */
operator|*
name|len
operator|+=
name|nheader
expr_stmt|;
comment|/* Increment our running total of bytes written to this string. */
name|wb
operator|->
name|size
operator|+=
operator|*
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|window_write_t
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
comment|/* string key for this window */
name|apr_size_t
name|svndiff_len
decl_stmt|;
comment|/* amount of svndiff data written to the string */
name|svn_filesize_t
name|text_off
decl_stmt|;
comment|/* offset of fulltext represented by this window */
name|apr_size_t
name|text_len
decl_stmt|;
comment|/* amount of fulltext data represented by this window */
block|}
name|window_write_t
typedef|;
end_typedef

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__rep_deltify
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|source_stream
decl_stmt|;
comment|/* stream to read the source */
name|svn_stream_t
modifier|*
name|target_stream
decl_stmt|;
comment|/* stream to read the target */
name|svn_txdelta_stream_t
modifier|*
name|txdelta_stream
decl_stmt|;
comment|/* stream to read delta windows  */
comment|/* window-y things, and an array to track them */
name|window_write_t
modifier|*
name|ww
decl_stmt|;
name|apr_array_header_t
modifier|*
name|windows
decl_stmt|;
comment|/* stream to write new (deltified) target data and its baton */
name|svn_stream_t
modifier|*
name|new_target_stream
decl_stmt|;
name|struct
name|write_svndiff_strings_baton
name|new_target_baton
decl_stmt|;
comment|/* window handler/baton for writing to above stream */
name|svn_txdelta_window_handler_t
name|new_target_handler
decl_stmt|;
name|void
modifier|*
name|new_target_handler_baton
decl_stmt|;
comment|/* yes, we do windows */
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
comment|/* The current offset into the fulltext that our window is about to      write.  This doubles, after all windows are written, as the      total size of the svndiff data for the deltification process. */
name|svn_filesize_t
name|tview_off
init|=
literal|0
decl_stmt|;
comment|/* The total amount of diff data written while deltifying. */
name|svn_filesize_t
name|diffsize
init|=
literal|0
decl_stmt|;
comment|/* TARGET's original string keys */
name|apr_array_header_t
modifier|*
name|orig_str_keys
decl_stmt|;
comment|/* The checksums for the representation's fulltext contents. */
name|svn_checksum_t
modifier|*
name|rep_md5_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|rep_sha1_checksum
decl_stmt|;
comment|/* MD5 digest */
specifier|const
name|unsigned
name|char
modifier|*
name|digest
decl_stmt|;
comment|/* pool for holding the windows */
name|apr_pool_t
modifier|*
name|wpool
decl_stmt|;
comment|/* Paranoia: never allow a rep to be deltified against itself,      because then there would be no fulltext reachable in the delta      chain, and badness would ensue.  */
if|if
condition|(
name|strcmp
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempt to deltify '%s' against itself"
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
comment|/* Set up a handler for the svndiff data, which will write each      window to its own string in the `strings' table. */
name|new_target_baton
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|new_target_baton
operator|.
name|trail
operator|=
name|trail
expr_stmt|;
name|new_target_baton
operator|.
name|header_read
operator|=
name|FALSE
expr_stmt|;
name|new_target_stream
operator|=
name|svn_stream_create
argument_list|(
operator|&
name|new_target_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|new_target_stream
argument_list|,
name|write_svndiff_strings
argument_list|)
expr_stmt|;
comment|/* Get streams to our source and target text data. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_read_stream
argument_list|(
operator|&
name|source_stream
argument_list|,
name|fs
argument_list|,
name|source
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__rep_contents_read_stream
argument_list|(
operator|&
name|target_stream
argument_list|,
name|fs
argument_list|,
name|target
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup a stream to convert the textdelta data into svndiff windows. */
name|svn_txdelta2
argument_list|(
operator|&
name|txdelta_stream
argument_list|,
name|source_stream
argument_list|,
name|target_stream
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_SVNDIFF1_FORMAT
condition|)
name|svn_txdelta_to_svndiff3
argument_list|(
operator|&
name|new_target_handler
argument_list|,
operator|&
name|new_target_handler_baton
argument_list|,
name|new_target_stream
argument_list|,
literal|1
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_txdelta_to_svndiff3
argument_list|(
operator|&
name|new_target_handler
argument_list|,
operator|&
name|new_target_handler_baton
argument_list|,
name|new_target_stream
argument_list|,
literal|0
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* subpool for the windows */
name|wpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Now, loop, manufacturing and dispatching windows of svndiff data. */
name|windows
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ww
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Reset some baton variables. */
name|new_target_baton
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|new_target_baton
operator|.
name|key
operator|=
name|NULL
expr_stmt|;
comment|/* Free the window. */
name|svn_pool_clear
argument_list|(
name|wpool
argument_list|)
expr_stmt|;
comment|/* Fetch the next window of txdelta data. */
name|SVN_ERR
argument_list|(
name|svn_txdelta_next_window
argument_list|(
operator|&
name|window
argument_list|,
name|txdelta_stream
argument_list|,
name|wpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send off this package to be written as svndiff data. */
name|SVN_ERR
argument_list|(
name|new_target_handler
argument_list|(
name|window
argument_list|,
name|new_target_handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
condition|)
block|{
comment|/* Add a new window description to our array. */
name|ww
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ww
argument_list|)
argument_list|)
expr_stmt|;
name|ww
operator|->
name|key
operator|=
name|new_target_baton
operator|.
name|key
expr_stmt|;
name|ww
operator|->
name|svndiff_len
operator|=
name|new_target_baton
operator|.
name|size
expr_stmt|;
name|ww
operator|->
name|text_off
operator|=
name|tview_off
expr_stmt|;
name|ww
operator|->
name|text_len
operator|=
name|window
operator|->
name|tview_len
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|windows
argument_list|,
name|window_write_t
operator|*
argument_list|)
operator|=
name|ww
expr_stmt|;
comment|/* Update our recordkeeping variables. */
name|tview_off
operator|+=
name|window
operator|->
name|tview_len
expr_stmt|;
name|diffsize
operator|+=
name|ww
operator|->
name|svndiff_len
expr_stmt|;
block|}
block|}
do|while
condition|(
name|window
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|wpool
argument_list|)
expr_stmt|;
comment|/* Having processed all the windows, we can query the MD5 digest      from the stream.  */
name|digest
operator|=
name|svn_txdelta_md5_digest
argument_list|(
name|txdelta_stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|digest
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_DELTA_MD5_CHECKSUM_ABSENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to calculate MD5 digest for '%s'"
argument_list|)
argument_list|,
name|source
argument_list|)
return|;
comment|/* Construct a list of the strings used by the old representation so      that we can delete them later.  While we are here, if the old      representation was a fulltext, check to make sure the delta we're      replacing it with is actually smaller.  (Don't perform this check      if we're replacing a delta; in that case, we're going for a time      optimization, not a space optimization.)  */
block|{
name|representation_t
modifier|*
name|old_rep
decl_stmt|;
specifier|const
name|char
modifier|*
name|str_key
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__read_rep
argument_list|(
operator|&
name|old_rep
argument_list|,
name|fs
argument_list|,
name|target
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_rep
operator|->
name|kind
operator|==
name|rep_kind_fulltext
condition|)
block|{
name|svn_filesize_t
name|old_size
init|=
literal|0
decl_stmt|;
name|str_key
operator|=
name|old_rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_size
argument_list|(
operator|&
name|old_size
argument_list|,
name|fs
argument_list|,
name|str_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|orig_str_keys
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|str_key
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|orig_str_keys
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|str_key
expr_stmt|;
comment|/* If the new data is NOT an space optimization, destroy the            string(s) we created, and get outta here. */
if|if
condition|(
name|diffsize
operator|>=
name|old_size
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|windows
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|ww
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|windows
argument_list|,
name|i
argument_list|,
name|window_write_t
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__string_delete
argument_list|(
name|fs
argument_list|,
name|ww
operator|->
name|key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|old_rep
operator|->
name|kind
operator|==
name|rep_kind_delta
condition|)
name|SVN_ERR
argument_list|(
name|delta_string_keys
argument_list|(
operator|&
name|orig_str_keys
argument_list|,
name|old_rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* unknown kind */
return|return
name|UNKNOWN_NODE_KIND
argument_list|(
name|target
argument_list|)
return|;
comment|/* Save the checksums, since the new rep needs them. */
name|rep_md5_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|old_rep
operator|->
name|md5_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|rep_sha1_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|old_rep
operator|->
name|sha1_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Hook the new strings we wrote into the rest of the filesystem by      building a new representation to replace our old one. */
block|{
name|representation_t
name|new_rep
decl_stmt|;
name|rep_delta_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|apr_array_header_t
modifier|*
name|chunks
decl_stmt|;
name|int
name|i
decl_stmt|;
name|new_rep
operator|.
name|kind
operator|=
name|rep_kind_delta
expr_stmt|;
name|new_rep
operator|.
name|txn_id
operator|=
name|NULL
expr_stmt|;
comment|/* Migrate the old rep's checksums to the new rep. */
name|new_rep
operator|.
name|md5_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|rep_md5_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_rep
operator|.
name|sha1_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|rep_sha1_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|chunks
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|windows
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|chunk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop through the windows we wrote, creating and adding new        chunks to the representation. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|windows
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|ww
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|windows
argument_list|,
name|i
argument_list|,
name|window_write_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Allocate a chunk and its window */
name|chunk
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chunk
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|offset
operator|=
name|ww
operator|->
name|text_off
expr_stmt|;
comment|/* Populate the window */
name|chunk
operator|->
name|version
operator|=
name|new_target_baton
operator|.
name|version
expr_stmt|;
name|chunk
operator|->
name|string_key
operator|=
name|ww
operator|->
name|key
expr_stmt|;
name|chunk
operator|->
name|size
operator|=
name|ww
operator|->
name|text_len
expr_stmt|;
name|chunk
operator|->
name|rep_key
operator|=
name|source
expr_stmt|;
comment|/* Add this chunk to the array. */
name|APR_ARRAY_PUSH
argument_list|(
name|chunks
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
operator|=
name|chunk
expr_stmt|;
block|}
comment|/* Put the chunks array into the representation. */
name|new_rep
operator|.
name|contents
operator|.
name|delta
operator|.
name|chunks
operator|=
name|chunks
expr_stmt|;
comment|/* Write out the new representation. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__write_rep
argument_list|(
name|fs
argument_list|,
name|target
argument_list|,
operator|&
name|new_rep
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete the original pre-deltified strings. */
name|SVN_ERR
argument_list|(
name|delete_strings
argument_list|(
name|orig_str_keys
argument_list|,
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

