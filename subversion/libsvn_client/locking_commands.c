begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * locking_commands.c:  Implementation of lock and unlock.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* For use with store_locks_callback, below. */
end_comment

begin_struct
struct|struct
name|lock_baton
block|{
specifier|const
name|char
modifier|*
name|base_dir_abspath
decl_stmt|;
name|apr_hash_t
modifier|*
name|urls_to_paths
decl_stmt|;
comment|/* url -> abspath */
specifier|const
name|char
modifier|*
name|base_url
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This callback is called by the ra_layer for each path locked.  * BATON is a 'struct lock_baton *', PATH is the path being locked,  * and LOCK is the lock itself.  *  * If BATON->urls_to_paths is not null, then this function either  * stores the LOCK on REL_URL or removes any lock tokens from REL_URL  * (depending on whether DO_LOCK is true or false respectively), but  * only if RA_ERR is null, or (in the unlock case) is something other  * than SVN_ERR_FS_LOCK_OWNER_MISMATCH.  *  * Implements svn_ra_lock_callback_t.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_locks_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_url
parameter_list|,
name|svn_boolean_t
name|do_lock
parameter_list|,
specifier|const
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|svn_error_t
modifier|*
name|ra_err
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|lock_baton
modifier|*
name|lb
init|=
name|baton
decl_stmt|;
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|lb
operator|->
name|urls_to_paths
condition|?
name|svn_hash_gets
argument_list|(
name|lb
operator|->
name|urls_to_paths
argument_list|,
name|rel_url
argument_list|)
else|:
name|NULL
decl_stmt|;
comment|/* Create the notify struct first, so we can tweak it below. */
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
condition|?
name|local_abspath
else|:
name|rel_url
argument_list|,
name|do_lock
condition|?
operator|(
name|ra_err
condition|?
name|svn_wc_notify_failed_lock
else|:
name|svn_wc_notify_locked
operator|)
else|:
operator|(
name|ra_err
condition|?
name|svn_wc_notify_failed_unlock
else|:
name|svn_wc_notify_unlocked
operator|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
name|notify
operator|->
name|err
operator|=
name|ra_err
expr_stmt|;
if|if
condition|(
name|local_abspath
condition|)
block|{
comment|/* Notify a valid working copy path */
name|notify
operator|->
name|path_prefix
operator|=
name|lb
operator|->
name|base_dir_abspath
expr_stmt|;
if|if
condition|(
name|do_lock
condition|)
block|{
if|if
condition|(
operator|!
name|ra_err
operator|&&
name|lock
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_add_lock2
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|lock
argument_list|,
name|lb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_locked
expr_stmt|;
block|}
else|else
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_unchanged
expr_stmt|;
block|}
else|else
comment|/* unlocking */
block|{
comment|/* Remove our wc lock token either a) if we got no error, or b) if              we got any error except for owner mismatch or hook failure (the              hook would be pre-unlock rather than post-unlock). Note that the              only errors that are handed to this callback will be              locking-related errors. */
if|if
condition|(
operator|!
name|ra_err
operator|||
operator|(
name|ra_err
operator|&&
operator|(
name|ra_err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_FS_LOCK_OWNER_MISMATCH
operator|&&
name|ra_err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_REPOS_HOOK_FAILURE
operator|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_remove_lock2
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|lb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_unlocked
expr_stmt|;
block|}
else|else
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_unchanged
expr_stmt|;
block|}
block|}
else|else
name|notify
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|lb
operator|->
name|base_url
argument_list|,
name|rel_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lb
operator|->
name|ctx
operator|->
name|notify_func2
condition|)
name|lb
operator|->
name|ctx
operator|->
name|notify_func2
argument_list|(
name|lb
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is a wrapper around svn_uri_condense_targets() and  * svn_dirent_condense_targets() (the choice of which is made based on  * the value of TARGETS_ARE_URIS) which takes care of the  * single-target special case.  *  * Callers are expected to check for an empty *COMMON_PARENT (which  * means, "there was nothing common") for themselves.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|condense_targets
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|common_parent
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|target_relpaths
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_boolean_t
name|targets_are_uris
parameter_list|,
name|svn_boolean_t
name|remove_redundancies
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|targets_are_uris
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_uri_condense_targets
argument_list|(
name|common_parent
argument_list|,
name|target_relpaths
argument_list|,
name|targets
argument_list|,
name|remove_redundancies
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_dirent_condense_targets
argument_list|(
name|common_parent
argument_list|,
name|target_relpaths
argument_list|,
name|targets
argument_list|,
name|remove_redundancies
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* svn_*_condense_targets leaves *TARGET_RELPATHS empty if TARGETS only      had 1 member, so we special case that. */
if|if
condition|(
name|apr_is_empty_array
argument_list|(
operator|*
name|target_relpaths
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
if|if
condition|(
name|targets_are_uris
condition|)
block|{
name|svn_uri_split
argument_list|(
name|common_parent
argument_list|,
operator|&
name|base_name
argument_list|,
operator|*
name|common_parent
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_dirent_split
argument_list|(
name|common_parent
argument_list|,
operator|&
name|base_name
argument_list|,
operator|*
name|common_parent
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|target_relpaths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|base_name
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Lock info. Used in organize_lock_targets.    ### Maybe return this instead of the ugly hashes? */
end_comment

begin_struct
struct|struct
name|wc_lock_item_t
block|{
name|svn_revnum_t
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_token
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Sets LOCK_PATHS to an array of working copy paths that this function  * has obtained lock on. The caller is responsible to release the locks  * EVEN WHEN THIS FUNCTION RETURNS AN ERROR.  *  * Set *COMMON_PARENT_URL to the nearest common parent URL of all TARGETS.  * If TARGETS are local paths, then the entry for each path is examined  * and *COMMON_PARENT is set to the common parent URL for all the  * targets (as opposed to the common local path).  *  * If there is no common parent, either because the targets are a  * mixture of URLs and local paths, or because they simply do not  * share a common parent, then return SVN_ERR_UNSUPPORTED_FEATURE.  *  * DO_LOCK is TRUE for locking TARGETS, and FALSE for unlocking them.  * FORCE is TRUE for breaking or stealing locks, and FALSE otherwise.  *  * Each key stored in *REL_TARGETS_P is a path relative to  * *COMMON_PARENT.  If TARGETS are local paths, then: if DO_LOCK is  * true, the value is a pointer to the corresponding base_revision  * (allocated in POOL) for the path, else the value is the lock token  * (or "" if no token found in the wc).  *  * If TARGETS is an array of urls, REL_FS_PATHS_P is set to NULL.  * Otherwise each key in REL_FS_PATHS_P is an repository path (relative to  * COMMON_PARENT) mapped to the absolute path for TARGET.  *  * If *COMMON_PARENT is a URL, then the values are a pointer to  * SVN_INVALID_REVNUM (allocated in pool) if DO_LOCK, else "".  *  * TARGETS may not be empty.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|organize_lock_targets
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|lock_paths
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|common_parent_url
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|base_dir_abspath
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|rel_targets_p
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|rel_fs_paths_p
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_boolean_t
name|do_lock
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|common_url
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|rel_targets_ret
init|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|rel_fs_paths
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|wc_info
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|url_mode
decl_stmt|;
operator|*
name|lock_paths
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|targets
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__assert_homogeneous_target_type
argument_list|(
name|targets
argument_list|)
argument_list|)
expr_stmt|;
name|url_mode
operator|=
name|svn_path_is_url
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|url_mode
condition|)
block|{
name|apr_array_header_t
modifier|*
name|rel_targets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_revnum_t
modifier|*
name|invalid_revnum
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|invalid_revnum
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|invalid_revnum
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Get the common parent URL and a bunch of relpaths, one per target. */
name|SVN_ERR
argument_list|(
name|condense_targets
argument_list|(
operator|&
name|common_url
argument_list|,
operator|&
name|rel_targets
argument_list|,
name|targets
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|common_url
operator|&&
operator|*
name|common_url
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No common parent found, unable to operate "
literal|"on disjoint arguments"
argument_list|)
argument_list|)
return|;
comment|/* Create mapping of the target relpaths to either          SVN_INVALID_REVNUM (if our caller is locking) or to an empty          lock token string (if the caller is unlocking). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rel_targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_hash_sets
argument_list|(
name|rel_targets_ret
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|rel_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|do_lock
condition|?
operator|(
specifier|const
name|void
operator|*
operator|)
name|invalid_revnum
else|:
operator|(
specifier|const
name|void
operator|*
operator|)
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|apr_array_header_t
modifier|*
name|rel_urls
decl_stmt|,
modifier|*
name|target_urls
decl_stmt|;
name|apr_hash_t
modifier|*
name|wcroot_target
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|lock_paths
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|wc_targets
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|target_abspath
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|wc_targets
operator|=
name|svn_hash_gets
argument_list|(
name|wcroot_target
argument_list|,
name|wcroot_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wc_targets
condition|)
block|{
name|wc_targets
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|wcroot_target
argument_list|,
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|wcroot_abspath
argument_list|)
argument_list|,
name|wc_targets
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|wc_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|target_abspath
expr_stmt|;
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|wcroot_target
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|lock_abspath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
comment|/* Use parent dir of a single file target */
if|if
condition|(
name|paths
operator|->
name|nelts
operator|==
literal|1
condition|)
name|lock_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_dirent_condense_targets
argument_list|(
operator|&
name|lock_abspath
argument_list|,
name|NULL
argument_list|,
name|paths
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__acquire_write_lock
argument_list|(
operator|&
name|lock_abspath
argument_list|,
name|wc_ctx
argument_list|,
name|lock_abspath
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|lock_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|lock_abspath
expr_stmt|;
block|}
comment|/* Get the URL for each target (which also serves to verify that          the dirent targets are sane).  */
name|target_urls
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|targets
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|wcroot_target
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|apr_array_header_t
modifier|*
name|wc_targets
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wc_targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|struct
name|wc_lock_item_t
modifier|*
name|wli
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|wc_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|wli
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wli
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_base
argument_list|(
operator|&
name|kind
argument_list|,
operator|&
name|wli
operator|->
name|revision
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|NULL
argument_list|,
operator|&
name|wli
operator|->
name|lock_token
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* ignore_enoent */
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' is not a file"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
name|wli
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|wc_info
argument_list|,
name|local_abspath
argument_list|,
name|wli
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|target_urls
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|wli
operator|->
name|url
expr_stmt|;
block|}
block|}
comment|/* Now that we have a bunch of URLs for our dirent targets,          condense those into a single common parent URL and a bunch of          paths relative to that. */
name|SVN_ERR
argument_list|(
name|condense_targets
argument_list|(
operator|&
name|common_url
argument_list|,
operator|&
name|rel_urls
argument_list|,
name|target_urls
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|common_url
operator|&&
operator|*
name|common_url
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to lock/unlock across multiple "
literal|"repositories"
argument_list|)
argument_list|)
return|;
comment|/* Now we need to create our mapping. */
name|rel_fs_paths
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|wc_info
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|struct
name|wc_lock_item_t
modifier|*
name|wli
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_url
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|rel_url
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|common_url
argument_list|,
name|wli
operator|->
name|url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|rel_fs_paths
argument_list|,
name|rel_url
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lock
condition|)
comment|/* Lock. */
block|{
name|svn_revnum_t
modifier|*
name|revnum
decl_stmt|;
name|revnum
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|revnum
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|revnum
operator|=
name|wli
operator|->
name|revision
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|rel_targets_ret
argument_list|,
name|rel_url
argument_list|,
name|revnum
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Unlock. */
block|{
specifier|const
name|char
modifier|*
name|lock_token
decl_stmt|;
comment|/* If not forcing the unlock, get the lock token. */
if|if
condition|(
operator|!
name|force
condition|)
block|{
if|if
condition|(
operator|!
name|wli
operator|->
name|lock_token
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_MISSING_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not locked in this working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|lock_token
operator|=
name|wli
operator|->
name|lock_token
condition|?
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|wli
operator|->
name|lock_token
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
else|else
name|lock_token
operator|=
name|NULL
expr_stmt|;
comment|/* If breaking a lock, we shouldn't pass any lock token. */
name|svn_hash_sets
argument_list|(
name|rel_targets_ret
argument_list|,
name|rel_url
argument_list|,
name|lock_token
condition|?
name|lock_token
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* Set our return variables. */
operator|*
name|common_parent_url
operator|=
name|common_url
expr_stmt|;
if|if
condition|(
operator|*
name|lock_paths
operator|&&
operator|(
operator|*
name|lock_paths
operator|)
operator|->
name|nelts
operator|==
literal|1
condition|)
operator|*
name|base_dir_abspath
operator|=
name|APR_ARRAY_IDX
argument_list|(
operator|*
name|lock_paths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
else|else
operator|*
name|base_dir_abspath
operator|=
name|NULL
expr_stmt|;
operator|*
name|rel_targets_p
operator|=
name|rel_targets_ret
expr_stmt|;
operator|*
name|rel_fs_paths_p
operator|=
name|rel_fs_paths
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fetch lock tokens from the repository for the paths in PATH_TOKENS,    setting the values to the fetched tokens, allocated in pool. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_tokens
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_tokens
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_lock
argument_list|(
name|ra_session
argument_list|,
operator|&
name|lock
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_MISSING_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not locked"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
name|svn_hash_sets
argument_list|(
name|path_tokens
argument_list|,
name|path
argument_list|,
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|lock
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_lock
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base_dir_abspath
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|common_parent_url
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|apr_hash_t
modifier|*
name|path_revs
decl_stmt|,
modifier|*
name|urls_to_paths
decl_stmt|;
name|struct
name|lock_baton
name|cb
decl_stmt|;
name|apr_array_header_t
modifier|*
name|lock_abspaths
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|apr_is_empty_array
argument_list|(
name|targets
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Enforce that the comment be xml-escapable. */
if|if
condition|(
name|comment
condition|)
block|{
if|if
condition|(
operator|!
name|svn_xml_is_xml_safe
argument_list|(
name|comment
argument_list|,
name|strlen
argument_list|(
name|comment
argument_list|)
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_XML_UNESCAPABLE_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Lock comment contains illegal characters"
argument_list|)
argument_list|)
return|;
block|}
name|err
operator|=
name|organize_lock_targets
argument_list|(
operator|&
name|lock_abspaths
argument_list|,
operator|&
name|common_parent_url
argument_list|,
operator|&
name|base_dir_abspath
argument_list|,
operator|&
name|path_revs
argument_list|,
operator|&
name|urls_to_paths
argument_list|,
name|targets
argument_list|,
name|TRUE
argument_list|,
name|steal_lock
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|release_locks
goto|;
comment|/* Open an RA session to the common parent URL of TARGETS. */
name|err
operator|=
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|common_parent_url
argument_list|,
name|base_dir_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|release_locks
goto|;
name|cb
operator|.
name|base_dir_abspath
operator|=
name|base_dir_abspath
expr_stmt|;
name|cb
operator|.
name|base_url
operator|=
name|common_parent_url
expr_stmt|;
name|cb
operator|.
name|urls_to_paths
operator|=
name|urls_to_paths
expr_stmt|;
name|cb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|cb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Lock the paths. */
name|err
operator|=
name|svn_ra_lock
argument_list|(
name|ra_session
argument_list|,
name|path_revs
argument_list|,
name|comment
argument_list|,
name|steal_lock
argument_list|,
name|store_locks_callback
argument_list|,
operator|&
name|cb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|release_locks
label|:
if|if
condition|(
name|lock_abspaths
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lock_abspaths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_wc__release_write_lock
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|lock_abspaths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_unlock
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_boolean_t
name|break_lock
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base_dir_abspath
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|common_parent_url
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|apr_hash_t
modifier|*
name|path_tokens
decl_stmt|,
modifier|*
name|urls_to_paths
decl_stmt|;
name|apr_array_header_t
modifier|*
name|lock_abspaths
decl_stmt|;
name|struct
name|lock_baton
name|cb
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|apr_is_empty_array
argument_list|(
name|targets
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|err
operator|=
name|organize_lock_targets
argument_list|(
operator|&
name|lock_abspaths
argument_list|,
operator|&
name|common_parent_url
argument_list|,
operator|&
name|base_dir_abspath
argument_list|,
operator|&
name|path_tokens
argument_list|,
operator|&
name|urls_to_paths
argument_list|,
name|targets
argument_list|,
name|FALSE
argument_list|,
name|break_lock
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|release_locks
goto|;
comment|/* Open an RA session to the common parent URL of TARGETS. */
name|err
operator|=
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|common_parent_url
argument_list|,
name|base_dir_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|release_locks
goto|;
comment|/* If break_lock is not set, lock tokens are required by the server.      If the targets were all URLs, ensure that we provide lock tokens,      so the repository will only check that the user owns the      locks. */
if|if
condition|(
operator|!
name|lock_abspaths
operator|&&
operator|!
name|break_lock
condition|)
block|{
name|err
operator|=
name|fetch_tokens
argument_list|(
name|ra_session
argument_list|,
name|path_tokens
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|release_locks
goto|;
block|}
name|cb
operator|.
name|base_dir_abspath
operator|=
name|base_dir_abspath
expr_stmt|;
name|cb
operator|.
name|base_url
operator|=
name|common_parent_url
expr_stmt|;
name|cb
operator|.
name|urls_to_paths
operator|=
name|urls_to_paths
expr_stmt|;
name|cb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|cb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Unlock the paths. */
name|err
operator|=
name|svn_ra_unlock
argument_list|(
name|ra_session
argument_list|,
name|path_tokens
argument_list|,
name|break_lock
argument_list|,
name|store_locks_callback
argument_list|,
operator|&
name|cb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|release_locks
label|:
if|if
condition|(
name|lock_abspaths
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lock_abspaths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_wc__release_write_lock
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|lock_abspaths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

end_unit

