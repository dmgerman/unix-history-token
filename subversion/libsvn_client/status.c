begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * status.c:  return the status of a working copy dirent  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Getting update information ***/
end_comment

begin_comment
comment|/* Baton for tweak_status.  It wraps a bit of extra functionality    around the received status func/baton, so we can remember if the    target was deleted in HEAD and tweak incoming status structures    accordingly. */
end_comment

begin_struct
struct|struct
name|status_baton
block|{
name|svn_boolean_t
name|deleted_in_repos
decl_stmt|;
comment|/* target is deleted in repos */
name|apr_hash_t
modifier|*
name|changelist_hash
decl_stmt|;
comment|/* keys are changelist names */
name|svn_client_status_func_t
name|real_status_func
decl_stmt|;
comment|/* real status function */
name|void
modifier|*
name|real_status_baton
decl_stmt|;
comment|/* real status baton */
specifier|const
name|char
modifier|*
name|anchor_abspath
decl_stmt|;
comment|/* Absolute path of anchor */
specifier|const
name|char
modifier|*
name|anchor_relpath
decl_stmt|;
comment|/* Relative path of anchor */
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
comment|/* A working copy context. */
block|}
struct|;
end_struct

begin_comment
comment|/* A status callback function which wraps the *real* status    function/baton.   This sucker takes care of any status tweaks we    need to make (such as noting that the target of the status is    missing from HEAD in the repository).     This implements the 'svn_wc_status_func4_t' function type.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tweak_status
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|status_baton
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|local_abspath
decl_stmt|;
name|svn_client_status_t
modifier|*
name|cst
decl_stmt|;
if|if
condition|(
name|sb
operator|->
name|anchor_abspath
condition|)
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|sb
operator|->
name|anchor_relpath
argument_list|,
name|svn_dirent_skip_ancestor
argument_list|(
name|sb
operator|->
name|anchor_abspath
argument_list|,
name|path
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If the status item has an entry, but doesn't belong to one of the      changelists our caller is interested in, we filter out this status      transmission.  */
if|if
condition|(
name|sb
operator|->
name|changelist_hash
operator|&&
operator|(
operator|!
name|status
operator|->
name|changelist
operator|||
operator|!
name|svn_hash_gets
argument_list|(
name|sb
operator|->
name|changelist_hash
argument_list|,
name|status
operator|->
name|changelist
argument_list|)
operator|)
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If we know that the target was deleted in HEAD of the repository,      we need to note that fact in all the status structures that come      through here. */
if|if
condition|(
name|sb
operator|->
name|deleted_in_repos
condition|)
block|{
name|svn_wc_status3_t
modifier|*
name|new_status
init|=
name|svn_wc_dup_status3
argument_list|(
name|status
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|new_status
operator|->
name|repos_node_status
operator|=
name|svn_wc_status_deleted
expr_stmt|;
name|status
operator|=
name|new_status
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__create_status
argument_list|(
operator|&
name|cst
argument_list|,
name|sb
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|status
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the real status function/baton. */
return|return
name|sb
operator|->
name|real_status_func
argument_list|(
name|sb
operator|->
name|real_status_baton
argument_list|,
name|path
argument_list|,
name|cst
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A baton for our reporter that is used to collect locks. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|report_baton_t
block|{
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|wrapped_reporter
decl_stmt|;
name|void
modifier|*
name|wrapped_report_baton
decl_stmt|;
comment|/* The common ancestor URL of all paths included in the report. */
name|char
modifier|*
name|ancestor
decl_stmt|;
name|void
modifier|*
name|set_locks_baton
decl_stmt|;
name|svn_depth_t
name|depth
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
comment|/* Pool to store locks in. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|report_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Implements svn_ra_reporter3_t->set_path. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_set_path
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_baton_t
modifier|*
name|rb
init|=
name|report_baton
decl_stmt|;
return|return
name|rb
operator|->
name|wrapped_reporter
operator|->
name|set_path
argument_list|(
name|rb
operator|->
name|wrapped_report_baton
argument_list|,
name|path
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_reporter3_t->delete_path. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_delete_path
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_baton_t
modifier|*
name|rb
init|=
name|report_baton
decl_stmt|;
return|return
name|rb
operator|->
name|wrapped_reporter
operator|->
name|delete_path
argument_list|(
name|rb
operator|->
name|wrapped_report_baton
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_reporter3_t->link_path. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_link_path
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_baton_t
modifier|*
name|rb
init|=
name|report_baton
decl_stmt|;
if|if
condition|(
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|rb
operator|->
name|ancestor
argument_list|,
name|url
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|ancestor
decl_stmt|;
name|ancestor
operator|=
name|svn_uri_get_longest_ancestor
argument_list|(
name|url
argument_list|,
name|rb
operator|->
name|ancestor
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we got a shorter ancestor, truncate our current ancestor.          Note that svn_uri_get_longest_ancestor will allocate its return          value even if it identical to one of its arguments. */
name|rb
operator|->
name|ancestor
index|[
name|strlen
argument_list|(
name|ancestor
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rb
operator|->
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
block|}
return|return
name|rb
operator|->
name|wrapped_reporter
operator|->
name|link_path
argument_list|(
name|rb
operator|->
name|wrapped_report_baton
argument_list|,
name|path
argument_list|,
name|url
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_reporter3_t->finish_report. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_finish_report
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_baton_t
modifier|*
name|rb
init|=
name|report_baton
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ras
decl_stmt|;
name|apr_hash_t
modifier|*
name|locks
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* Open an RA session to our common ancestor and grab the locks under it.    */
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ras
argument_list|,
name|rb
operator|->
name|ancestor
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|ctx
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The locks need to live throughout the edit.  Note that if the      server doesn't support lock discovery, we'll just not do locky      stuff. */
name|err
operator|=
name|svn_ra_get_locks2
argument_list|(
name|ras
argument_list|,
operator|&
name|locks
argument_list|,
literal|""
argument_list|,
name|rb
operator|->
name|depth
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_NOT_IMPLEMENTED
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_UNSUPPORTED_FEATURE
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|locks
operator|=
name|apr_hash_make
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ras
argument_list|,
operator|&
name|repos_root
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close the RA session. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_status_set_repos_locks
argument_list|(
name|rb
operator|->
name|set_locks_baton
argument_list|,
name|locks
argument_list|,
name|repos_root
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rb
operator|->
name|wrapped_reporter
operator|->
name|finish_report
argument_list|(
name|rb
operator|->
name|wrapped_report_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_ra_reporter3_t->abort_report. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_abort_report
parameter_list|(
name|void
modifier|*
name|report_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|report_baton_t
modifier|*
name|rb
init|=
name|report_baton
decl_stmt|;
return|return
name|rb
operator|->
name|wrapped_reporter
operator|->
name|abort_report
argument_list|(
name|rb
operator|->
name|wrapped_report_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A reporter that keeps track of the common URL ancestor of all paths in    the WC and fetches repository locks for all paths under this ancestor. */
end_comment

begin_decl_stmt
specifier|static
name|svn_ra_reporter3_t
name|lock_fetch_reporter
init|=
block|{
name|reporter_set_path
block|,
name|reporter_delete_path
block|,
name|reporter_link_path
block|,
name|reporter_finish_report
block|,
name|reporter_abort_report
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Perform status operations on each external in EXTERNAL_MAP, a const char *    local_abspath of all externals mapping to the const char* defining_abspath.    All other options are the same as those passed to svn_client_status().     If ANCHOR_ABSPATH and ANCHOR-RELPATH are not null, use them to provide    properly formatted relative paths */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_external_status
parameter_list|(
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_hash_t
modifier|*
name|external_map
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_boolean_t
name|update
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_relpath
parameter_list|,
name|svn_client_status_func_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Loop over the hash of new values (we don't care about the old      ones).  This is a mapping of versioned directories to property      values. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|external_map
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_node_kind_t
name|external_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|defining_abspath
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_opt_revision_t
name|opt_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|status_path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Obtain information on the expected external. */
name|SVN_ERR
argument_list|(
name|svn_wc__read_external_info
argument_list|(
operator|&
name|external_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|opt_rev
operator|.
name|value
operator|.
name|number
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|defining_abspath
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_kind
operator|!=
name|svn_node_dir
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
continue|continue;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|opt_rev
operator|.
name|value
operator|.
name|number
argument_list|)
condition|)
name|opt_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
else|else
name|opt_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
comment|/* Tell the client we're starting an external status set. */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_status_external
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|status_path
operator|=
name|local_abspath
expr_stmt|;
if|if
condition|(
name|anchor_abspath
condition|)
block|{
name|status_path
operator|=
name|svn_dirent_join
argument_list|(
name|anchor_relpath
argument_list|,
name|svn_dirent_skip_ancestor
argument_list|(
name|anchor_abspath
argument_list|,
name|status_path
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* And then do the status. */
name|SVN_ERR
argument_list|(
name|svn_client_status5
argument_list|(
name|NULL
argument_list|,
name|ctx
argument_list|,
name|status_path
argument_list|,
operator|&
name|opt_rev
argument_list|,
name|depth
argument_list|,
name|get_all
argument_list|,
name|update
argument_list|,
name|no_ignore
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy SUBPOOL and (implicitly) ITERPOOL. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public Interface. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client_status5
parameter_list|(
name|svn_revnum_t
modifier|*
name|result_rev
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|get_all
parameter_list|,
name|svn_boolean_t
name|update
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_boolean_t
name|depth_as_sticky
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
name|svn_client_status_func_t
name|status_func
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
comment|/* ### aka scratch_pool */
block|{
name|struct
name|status_baton
name|sb
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|,
modifier|*
name|dir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_basename
decl_stmt|;
name|apr_array_header_t
modifier|*
name|ignores
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_hash_t
modifier|*
name|changelist_hash
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
if|if
condition|(
name|changelists
operator|&&
name|changelists
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|svn_hash_from_cstring_keys
argument_list|(
operator|&
name|changelist_hash
argument_list|,
name|changelists
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_rev
condition|)
operator|*
name|result_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|sb
operator|.
name|real_status_func
operator|=
name|status_func
expr_stmt|;
name|sb
operator|.
name|real_status_baton
operator|=
name|status_baton
expr_stmt|;
name|sb
operator|.
name|deleted_in_repos
operator|=
name|FALSE
expr_stmt|;
name|sb
operator|.
name|changelist_hash
operator|=
name|changelist_hash
expr_stmt|;
name|sb
operator|.
name|wc_ctx
operator|=
name|ctx
operator|->
name|wc_ctx
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|target_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
comment|/* The status editor only works on directories, so get the ancestor          if necessary */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dir must be a working copy directory or the status editor fails */
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|dir_abspath
operator|=
name|target_abspath
expr_stmt|;
name|target_basename
operator|=
literal|""
expr_stmt|;
name|dir
operator|=
name|path
expr_stmt|;
block|}
else|else
block|{
name|dir_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|target_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|target_basename
operator|=
name|svn_dirent_basename
argument_list|(
name|target_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dir
operator|=
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
if|if
condition|(
name|depth
operator|==
name|svn_depth_empty
condition|)
name|depth
operator|=
name|svn_depth_files
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dir_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
block|}
else|else
block|{
name|dir
operator|=
name|path
expr_stmt|;
name|dir_abspath
operator|=
name|target_abspath
expr_stmt|;
block|}
if|if
condition|(
name|svn_dirent_is_absolute
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|sb
operator|.
name|anchor_abspath
operator|=
name|NULL
expr_stmt|;
name|sb
operator|.
name|anchor_relpath
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|anchor_abspath
operator|=
name|dir_abspath
expr_stmt|;
name|sb
operator|.
name|anchor_relpath
operator|=
name|dir
expr_stmt|;
block|}
comment|/* Get the status edit, and use our wrapping status function/baton      as the callback pair. */
name|SVN_ERR
argument_list|(
name|svn_wc_get_default_ignores
argument_list|(
operator|&
name|ignores
argument_list|,
name|ctx
operator|->
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we want to know about out-of-dateness, we crawl the working copy and      let the RA layer drive the editor for real.  Otherwise, we just close the      edit.  :-) */
if|if
condition|(
name|update
condition|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
specifier|const
name|char
modifier|*
name|URL
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|server_supports_depth
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|,
modifier|*
name|set_locks_baton
decl_stmt|;
name|svn_revnum_t
name|edit_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* Get full URL from the ANCHOR. */
name|SVN_ERR
argument_list|(
name|svn_client_url_from_path2
argument_list|(
operator|&
name|URL
argument_list|,
name|dir_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|URL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_MISSING_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Entry '%s' has no URL"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dir
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* Open a repository session to the URL. */
name|SVN_ERR
argument_list|(
name|svn_client__open_ra_session_internal
argument_list|(
operator|&
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|URL
argument_list|,
name|dir_abspath
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|server_supports_depth
argument_list|,
name|SVN_RA_CAPABILITY_DEPTH
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_status_editor
argument_list|(
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
operator|&
name|set_locks_baton
argument_list|,
operator|&
name|edit_revision
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dir_abspath
argument_list|,
name|target_basename
argument_list|,
name|depth
argument_list|,
name|get_all
argument_list|,
name|no_ignore
argument_list|,
name|depth_as_sticky
argument_list|,
name|server_supports_depth
argument_list|,
name|ignores
argument_list|,
name|tweak_status
argument_list|,
operator|&
name|sb
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify that URL exists in HEAD.  If it doesn't, this can save          us a whole lot of hassle; if it does, the cost of this          request should be minimal compared to the size of getting          back the average amount of "out-of-date" information. */
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* Our status target does not exist in HEAD.  If we've got              it locally added, that's okay.  But if it was previously              versioned, then it must have since been deleted from the              repository.  (Note that "locally replaced" doesn't count              as "added" in this case.)  */
name|SVN_ERR
argument_list|(
name|svn_wc__node_is_added
argument_list|(
operator|&
name|added
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dir_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|added
condition|)
name|sb
operator|.
name|deleted_in_repos
operator|=
name|TRUE
expr_stmt|;
comment|/* And now close the edit. */
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_revnum_t
name|revnum
decl_stmt|;
name|report_baton_t
name|rb
decl_stmt|;
name|svn_depth_t
name|status_depth
decl_stmt|;
if|if
condition|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_head
condition|)
block|{
comment|/* Cause the revision number to be omitted from the request,                  which implies HEAD. */
name|revnum
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
comment|/* Get a revision number for our status operation. */
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|revnum
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|ra_session
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth_as_sticky
operator|||
operator|!
name|server_supports_depth
condition|)
name|status_depth
operator|=
name|depth
expr_stmt|;
else|else
name|status_depth
operator|=
name|svn_depth_unknown
expr_stmt|;
comment|/* Use depth from WC */
comment|/* Do the deed.  Let the RA layer drive the status editor. */
name|SVN_ERR
argument_list|(
name|svn_ra_do_status2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|rb
operator|.
name|wrapped_reporter
argument_list|,
operator|&
name|rb
operator|.
name|wrapped_report_baton
argument_list|,
name|target_basename
argument_list|,
name|revnum
argument_list|,
name|status_depth
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Init the report baton. */
name|rb
operator|.
name|ancestor
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|URL
argument_list|)
expr_stmt|;
comment|/* Edited later */
name|rb
operator|.
name|set_locks_baton
operator|=
name|set_locks_baton
expr_stmt|;
name|rb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|rb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|rb
operator|.
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
else|else
name|rb
operator|.
name|depth
operator|=
name|depth
expr_stmt|;
comment|/* Drive the reporter structure, describing the revisions              within PATH.  When we call reporter->finish_report,              EDITOR will be driven to describe differences between our              working copy and HEAD. */
name|SVN_ERR
argument_list|(
name|svn_wc_crawl_revisions5
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
operator|&
name|lock_fetch_reporter
argument_list|,
operator|&
name|rb
argument_list|,
name|FALSE
comment|/* restore_files */
argument_list|,
name|depth
argument_list|,
operator|(
operator|!
name|depth_as_sticky
operator|)
argument_list|,
operator|(
operator|!
name|server_supports_depth
operator|)
argument_list|,
name|FALSE
comment|/* use_commit_times */
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|target_abspath
argument_list|,
name|svn_wc_notify_status_completed
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|revision
operator|=
name|edit_revision
expr_stmt|;
call|(
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If the caller wants the result revision, give it to them. */
if|if
condition|(
name|result_rev
condition|)
operator|*
name|result_rev
operator|=
name|edit_revision
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|svn_wc_walk_status
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|depth
argument_list|,
name|get_all
argument_list|,
name|no_ignore
argument_list|,
name|FALSE
argument_list|,
name|ignores
argument_list|,
name|tweak_status
argument_list|,
operator|&
name|sb
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_MISSING
condition|)
block|{
comment|/* This error code is checked for in svn to continue after              this error */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* If there are svn:externals set, we don't want those to show up as      unversioned or unrecognized, so patch up the hash.  If caller wants      all the statuses, we will change unversioned status items that      are interesting to an svn:externals property to      svn_wc_status_unversioned, otherwise we'll just remove the status      item altogether.       We only descend into an external if depth is svn_depth_infinity or      svn_depth_unknown.  However, there are conceivable behaviors that      would involve descending under other circumstances; thus, we pass      depth anyway, so the code will DTRT if we change the conditional      in the future.   */
if|if
condition|(
name|SVN_DEPTH_IS_RECURSIVE
argument_list|(
name|depth
argument_list|)
operator|&&
operator|(
operator|!
name|ignore_externals
operator|)
condition|)
block|{
name|apr_hash_t
modifier|*
name|external_map
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__externals_defined_below
argument_list|(
operator|&
name|external_map
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_external_status
argument_list|(
name|ctx
argument_list|,
name|external_map
argument_list|,
name|depth
argument_list|,
name|get_all
argument_list|,
name|update
argument_list|,
name|no_ignore
argument_list|,
name|sb
operator|.
name|anchor_abspath
argument_list|,
name|sb
operator|.
name|anchor_relpath
argument_list|,
name|status_func
argument_list|,
name|status_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_client_status_t
modifier|*
name|svn_client_status_dup
parameter_list|(
specifier|const
name|svn_client_status_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_client_status_t
modifier|*
name|st
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|st
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|st
operator|=
operator|*
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|local_abspath
condition|)
name|st
operator|->
name|local_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|status
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|repos_root_url
condition|)
name|st
operator|->
name|repos_root_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|status
operator|->
name|repos_root_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|repos_uuid
condition|)
name|st
operator|->
name|repos_uuid
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|status
operator|->
name|repos_uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|repos_relpath
condition|)
name|st
operator|->
name|repos_relpath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|status
operator|->
name|repos_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|changed_author
condition|)
name|st
operator|->
name|changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|status
operator|->
name|changed_author
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|lock
condition|)
name|st
operator|->
name|lock
operator|=
name|svn_lock_dup
argument_list|(
name|status
operator|->
name|lock
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|changelist
condition|)
name|st
operator|->
name|changelist
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|status
operator|->
name|changelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|ood_changed_author
condition|)
name|st
operator|->
name|ood_changed_author
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|status
operator|->
name|ood_changed_author
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|repos_lock
condition|)
name|st
operator|->
name|repos_lock
operator|=
name|svn_lock_dup
argument_list|(
name|status
operator|->
name|repos_lock
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|backwards_compatibility_baton
condition|)
block|{
specifier|const
name|svn_wc_status3_t
modifier|*
name|wc_st
init|=
name|status
operator|->
name|backwards_compatibility_baton
decl_stmt|;
name|st
operator|->
name|backwards_compatibility_baton
operator|=
name|svn_wc_dup_status3
argument_list|(
name|wc_st
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|->
name|moved_from_abspath
condition|)
name|st
operator|->
name|moved_from_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|status
operator|->
name|moved_from_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|moved_to_abspath
condition|)
name|st
operator|->
name|moved_to_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|status
operator|->
name|moved_to_abspath
argument_list|)
expr_stmt|;
return|return
name|st
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__create_status
parameter_list|(
name|svn_client_status_t
modifier|*
modifier|*
name|cst
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|cst
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|cst
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|kind
operator|=
name|status
operator|->
name|kind
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|local_abspath
operator|=
name|local_abspath
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|filesize
operator|=
name|status
operator|->
name|filesize
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|versioned
operator|=
name|status
operator|->
name|versioned
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|conflicted
operator|=
name|status
operator|->
name|conflicted
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|node_status
operator|=
name|status
operator|->
name|node_status
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|text_status
operator|=
name|status
operator|->
name|text_status
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|prop_status
operator|=
name|status
operator|->
name|prop_status
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
operator|(
operator|*
name|cst
operator|)
operator|->
name|wc_is_locked
operator|=
name|status
operator|->
name|locked
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|copied
operator|=
name|status
operator|->
name|copied
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|revision
operator|=
name|status
operator|->
name|revision
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|changed_rev
operator|=
name|status
operator|->
name|changed_rev
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|changed_date
operator|=
name|status
operator|->
name|changed_date
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|changed_author
operator|=
name|status
operator|->
name|changed_author
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|repos_root_url
operator|=
name|status
operator|->
name|repos_root_url
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|repos_uuid
operator|=
name|status
operator|->
name|repos_uuid
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|repos_relpath
operator|=
name|status
operator|->
name|repos_relpath
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|switched
operator|=
name|status
operator|->
name|switched
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|file_external
operator|=
name|status
operator|->
name|file_external
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|file_external
condition|)
block|{
operator|(
operator|*
name|cst
operator|)
operator|->
name|switched
operator|=
name|FALSE
expr_stmt|;
block|}
operator|(
operator|*
name|cst
operator|)
operator|->
name|lock
operator|=
name|status
operator|->
name|lock
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|changelist
operator|=
name|status
operator|->
name|changelist
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|depth
operator|=
name|status
operator|->
name|depth
expr_stmt|;
comment|/* Out of date information */
operator|(
operator|*
name|cst
operator|)
operator|->
name|ood_kind
operator|=
name|status
operator|->
name|ood_kind
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|repos_node_status
operator|=
name|status
operator|->
name|repos_node_status
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|repos_text_status
operator|=
name|status
operator|->
name|repos_text_status
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|repos_prop_status
operator|=
name|status
operator|->
name|repos_prop_status
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|repos_lock
operator|=
name|status
operator|->
name|repos_lock
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|ood_changed_rev
operator|=
name|status
operator|->
name|ood_changed_rev
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|ood_changed_date
operator|=
name|status
operator|->
name|ood_changed_date
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|ood_changed_author
operator|=
name|status
operator|->
name|ood_changed_author
expr_stmt|;
comment|/* When changing the value of backwards_compatibility_baton, also      change its use in status4_wrapper_func in deprecated.c */
operator|(
operator|*
name|cst
operator|)
operator|->
name|backwards_compatibility_baton
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|versioned
operator|&&
name|status
operator|->
name|conflicted
condition|)
block|{
name|svn_boolean_t
name|text_conflicted
decl_stmt|,
name|prop_conflicted
decl_stmt|,
name|tree_conflicted
decl_stmt|;
comment|/* Note: This checks the on disk markers to automatically hide                text/property conflicts that are hidden by removing their                markers */
name|SVN_ERR
argument_list|(
name|svn_wc_conflicted_p3
argument_list|(
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_conflicted
condition|)
operator|(
operator|*
name|cst
operator|)
operator|->
name|text_status
operator|=
name|svn_wc_status_conflicted
expr_stmt|;
if|if
condition|(
name|prop_conflicted
condition|)
operator|(
operator|*
name|cst
operator|)
operator|->
name|prop_status
operator|=
name|svn_wc_status_conflicted
expr_stmt|;
comment|/* ### Also set this for tree_conflicts? */
if|if
condition|(
name|text_conflicted
operator|||
name|prop_conflicted
condition|)
operator|(
operator|*
name|cst
operator|)
operator|->
name|node_status
operator|=
name|svn_wc_status_conflicted
expr_stmt|;
block|}
operator|(
operator|*
name|cst
operator|)
operator|->
name|moved_from_abspath
operator|=
name|status
operator|->
name|moved_from_abspath
expr_stmt|;
operator|(
operator|*
name|cst
operator|)
operator|->
name|moved_to_abspath
operator|=
name|status
operator|->
name|moved_to_abspath
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

