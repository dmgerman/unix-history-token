begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * log.c:  return log messages  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_compat.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_escape
end_escape

begin_comment
comment|/*** Getting misc. information ***/
end_comment

begin_comment
comment|/* The baton for use with copyfrom_info_receiver(). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|copyfrom_info_t
block|{
name|svn_boolean_t
name|is_first
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|copyfrom_info_t
typedef|;
end_typedef

begin_comment
comment|/* A location segment callback for obtaining the copy source of    a node at a path and storing it in *BATON (a struct copyfrom_info_t *).    Implements svn_location_segment_receiver_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copyfrom_info_receiver
parameter_list|(
name|svn_location_segment_t
modifier|*
name|segment
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|copyfrom_info_t
modifier|*
name|copyfrom_info
init|=
name|baton
decl_stmt|;
comment|/* If we've already identified the copy source, there's nothing more      to do.      ### FIXME:  We *should* be able to send */
if|if
condition|(
name|copyfrom_info
operator|->
name|path
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If this is the first segment, it's not of interest to us. Otherwise      (so long as this segment doesn't represent a history gap), it holds      our path's previous location (from which it was last copied). */
if|if
condition|(
name|copyfrom_info
operator|->
name|is_first
condition|)
block|{
name|copyfrom_info
operator|->
name|is_first
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|segment
operator|->
name|path
condition|)
block|{
comment|/* The end of the second non-gap segment is the location copied from.  */
name|copyfrom_info
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|copyfrom_info
operator|->
name|pool
argument_list|,
name|segment
operator|->
name|path
argument_list|)
expr_stmt|;
name|copyfrom_info
operator|->
name|rev
operator|=
name|segment
operator|->
name|range_end
expr_stmt|;
comment|/* ### FIXME: We *should* be able to return SVN_ERR_CEASE_INVOCATION          ### here so we don't get called anymore. */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_copy_source
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|original_repos_relpath
parameter_list|,
name|svn_revnum_t
modifier|*
name|original_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|copyfrom_info_t
name|copyfrom_info
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_pool_t
modifier|*
name|sesspool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|at_loc
decl_stmt|;
name|copyfrom_info
operator|.
name|is_first
operator|=
name|TRUE
expr_stmt|;
name|copyfrom_info
operator|.
name|path
operator|=
name|NULL
expr_stmt|;
name|copyfrom_info
operator|.
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|copyfrom_info
operator|.
name|pool
operator|=
name|result_pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|at_loc
argument_list|,
name|path_or_url
argument_list|,
name|NULL
argument_list|,
name|revision
argument_list|,
name|revision
argument_list|,
name|ctx
argument_list|,
name|sesspool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the copy source.  Walk the location segments to find the revision      at which this node was created (copied or added). */
name|err
operator|=
name|svn_ra_get_location_segments
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|at_loc
operator|->
name|rev
argument_list|,
name|at_loc
operator|->
name|rev
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|copyfrom_info_receiver
argument_list|,
operator|&
name|copyfrom_info
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|sesspool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_REQUEST_FAILED
condition|)
block|{
comment|/* A locally-added but uncommitted versioned resource won't              exist in the repository. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
operator|*
name|original_repos_relpath
operator|=
name|NULL
expr_stmt|;
operator|*
name|original_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
operator|*
name|original_repos_relpath
operator|=
name|copyfrom_info
operator|.
name|path
expr_stmt|;
operator|*
name|original_revision
operator|=
name|copyfrom_info
operator|.
name|rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* compatibility with pre-1.5 servers, which send only author/date/log  *revprops in log entries */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pre_15_receiver_baton_t
block|{
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
comment|/* ra session for retrieving revprops from old servers */
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
comment|/* caller's list of requested revprops, receiver, and baton */
specifier|const
name|char
modifier|*
name|ra_session_url
decl_stmt|;
name|apr_pool_t
modifier|*
name|ra_session_pool
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
decl_stmt|;
name|svn_log_entry_receiver_t
name|receiver
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
block|}
name|pre_15_receiver_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pre_15_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|pre_15_receiver_baton_t
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
return|return
name|rb
operator|->
name|receiver
argument_list|(
name|rb
operator|->
name|baton
argument_list|,
name|log_entry
argument_list|,
name|pool
argument_list|)
return|;
comment|/* If only some revprops are requested, get them one at a time on the      second ra connection.  If all are requested, get them all with      svn_ra_rev_proplist.  This avoids getting unrequested revprops (which      may be arbitrarily large), but means one round-trip per requested      revprop.  epg isn't entirely sure which should be optimized for. */
if|if
condition|(
name|rb
operator|->
name|revprops
condition|)
block|{
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|want_author
decl_stmt|,
name|want_date
decl_stmt|,
name|want_log
decl_stmt|;
name|want_author
operator|=
name|want_date
operator|=
name|want_log
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rb
operator|->
name|revprops
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|revprops
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
comment|/* If a standard revprop is requested, we know it is already in              log_entry->revprops if available. */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
operator|==
literal|0
condition|)
block|{
name|want_author
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|want_date
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|want_log
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rb
operator|->
name|ra_session
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|rb
operator|->
name|ra_session
argument_list|,
name|rb
operator|->
name|ra_session_url
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|ctx
argument_list|,
name|rb
operator|->
name|ra_session_pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_rev_prop
argument_list|(
name|rb
operator|->
name|ra_session
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|name
argument_list|,
operator|&
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revprops
operator|==
name|NULL
condition|)
name|log_entry
operator|->
name|revprops
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_entry
operator|->
name|revprops
condition|)
block|{
comment|/* Pre-1.5 servers send the standard revprops unconditionally;              clear those the caller doesn't want. */
if|if
condition|(
operator|!
name|want_author
condition|)
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|want_date
condition|)
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|want_log
condition|)
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rb
operator|->
name|ra_session
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|rb
operator|->
name|ra_session
argument_list|,
name|rb
operator|->
name|ra_session_url
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|ctx
argument_list|,
name|rb
operator|->
name|ra_session_pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_rev_proplist
argument_list|(
name|rb
operator|->
name|ra_session
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
operator|&
name|log_entry
operator|->
name|revprops
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rb
operator|->
name|receiver
argument_list|(
name|rb
operator|->
name|baton
argument_list|,
name|log_entry
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* limit receiver */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|limit_receiver_baton_t
block|{
name|int
name|limit
decl_stmt|;
name|svn_log_entry_receiver_t
name|receiver
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
block|}
name|limit_receiver_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|limit_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|limit_receiver_baton_t
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|rb
operator|->
name|limit
operator|--
expr_stmt|;
return|return
name|rb
operator|->
name|receiver
argument_list|(
name|rb
operator|->
name|baton
argument_list|,
name|log_entry
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resolve the URLs or WC path in TARGETS as per the svn_client_log5 API.     The limitations on TARGETS specified by svn_client_log5 are enforced here.    So TARGETS can only contain a single WC path or a URL and zero or more    relative paths -- anything else will raise an error.      PEG_REVISION, TARGETS, and CTX are as per svn_client_log5.     If TARGETS contains a single WC path then set *RA_TARGET to the absolute    path of that single path if PEG_REVISION is dependent on the working copy    (e.g. PREV).  Otherwise set *RA_TARGET to the corresponding URL for the    single WC path.  Set *RELATIVE_TARGETS to an array with a single    element "".     If TARGETS contains only a single URL, then set *RA_TARGET to a copy of    that URL and *RELATIVE_TARGETS to an array with a single element "".     If TARGETS contains a single URL and one or more relative paths, then    set *RA_TARGET to a copy of that URL and *RELATIVE_TARGETS to a copy of    each relative path after the URL.     If *PEG_REVISION is svn_opt_revision_unspecified, then *PEG_REVISION is    set to svn_opt_revision_head for URLs or svn_opt_revision_working for a    WC path.     *RA_TARGET and *RELATIVE_TARGETS are allocated in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_log_targets
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|relative_targets
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|ra_target
parameter_list|,
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|url_targets
decl_stmt|;
comment|/* Per svn_client_log5, TARGETS contains either a URL followed by zero or      more relative paths, or one working copy path. */
specifier|const
name|char
modifier|*
name|url_or_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* svn_client_log5 requires at least one target. */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No valid target found"
argument_list|)
argument_list|)
return|;
comment|/* Initialize the output array.  At a minimum, we need room for one      (possibly empty) relpath.  Otherwise, we have to hold a relpath      for every item in TARGETS except the first.  */
operator|*
name|relative_targets
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|MAX
argument_list|(
literal|1
argument_list|,
name|targets
operator|->
name|nelts
operator|-
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|url_or_path
argument_list|)
condition|)
block|{
comment|/* An unspecified PEG_REVISION for a URL path defaults          to svn_opt_revision_head. */
if|if
condition|(
name|peg_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|peg_revision
operator|->
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
comment|/* The logic here is this: If we get passed one argument, we assume          it is the full URL to a file/dir we want log info for. If we get          a URL plus some paths, then we assume that the URL is the base,          and that the paths passed are relative to it.  */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
comment|/* We have some paths, let's use them. Start after the URL.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|target
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
operator|||
name|svn_dirent_is_absolute
argument_list|(
name|target
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a relative path"
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|relative_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we have a single URL, then the session will be rooted at              it, so just send an empty string for the paths we are              interested in. */
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|relative_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
literal|""
expr_stmt|;
block|}
comment|/* Remember that our targets are URLs. */
name|url_targets
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
comment|/* WC path target. */
block|{
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
name|url_targets
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"When specifying working copy paths, only "
literal|"one target may be given"
argument_list|)
argument_list|)
return|;
comment|/* An unspecified PEG_REVISION for a working copy path defaults          to svn_opt_revision_working. */
if|if
condition|(
name|peg_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|peg_revision
operator|->
name|kind
operator|=
name|svn_opt_revision_working
expr_stmt|;
comment|/* Get URLs for each target */
name|target
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|target_abspath
argument_list|,
name|target
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_url
argument_list|(
operator|&
name|url_or_path
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|relative_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
literal|""
expr_stmt|;
block|}
comment|/* If this is a revision type that requires access to the working copy,    * we use our initial target path to figure out where to root the RA    * session, otherwise we use our URL. */
if|if
condition|(
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|peg_revision
operator|->
name|kind
argument_list|)
condition|)
block|{
if|if
condition|(
name|url_targets
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"PREV, BASE, or COMMITTED revision "
literal|"keywords are invalid for URL"
argument_list|)
argument_list|)
return|;
else|else
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
name|ra_target
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ra_target
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|url_or_path
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Keep track of oldest and youngest opt revs found.     If REV is younger than *YOUNGEST_REV, or *YOUNGEST_REV is    svn_opt_revision_unspecified, then set *YOUNGEST_REV equal to REV.     If REV is older than *OLDEST_REV, or *OLDEST_REV is    svn_opt_revision_unspecified, then set *OLDEST_REV equal to REV. */
end_comment

begin_function
specifier|static
name|void
name|find_youngest_and_oldest_revs
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_rev
parameter_list|,
name|svn_revnum_t
modifier|*
name|oldest_rev
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|)
block|{
comment|/* Is REV younger than YOUNGEST_REV? */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|youngest_rev
argument_list|)
operator|||
name|rev
operator|>
operator|*
name|youngest_rev
condition|)
operator|*
name|youngest_rev
operator|=
name|rev
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|oldest_rev
argument_list|)
operator|||
name|rev
operator|<
operator|*
name|oldest_rev
condition|)
operator|*
name|oldest_rev
operator|=
name|rev
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|rev_range_t
block|{
name|svn_revnum_t
name|range_start
decl_stmt|;
name|svn_revnum_t
name|range_end
decl_stmt|;
block|}
name|rev_range_t
typedef|;
end_typedef

begin_comment
comment|/* Convert array of svn_opt_revision_t ranges to an array of svn_revnum_t    ranges.     Given a log target URL_OR_ABSPATH@PEG_REV and an array of    svn_opt_revision_range_t's OPT_REV_RANGES, resolve the opt revs in    OPT_REV_RANGES to svn_revnum_t's and return these in *REVISION_RANGES, an    array of rev_range_t *.     Set *YOUNGEST_REV and *OLDEST_REV to the youngest and oldest revisions    found in *REVISION_RANGES.     If the repository needs to be contacted to resolve svn_opt_revision_date or    svn_opt_revision_head revisions, then the session used to do this is    RA_SESSION; it must be an open session to any URL in the right repository. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|convert_opt_rev_array_to_rev_range_array
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|revision_ranges
parameter_list|,
name|svn_revnum_t
modifier|*
name|youngest_rev
parameter_list|,
name|svn_revnum_t
modifier|*
name|oldest_rev
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url_or_abspath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|opt_rev_ranges
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_rev
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_revnum_t
name|head_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* Initialize the input/output parameters. */
operator|*
name|youngest_rev
operator|=
operator|*
name|oldest_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Convert OPT_REV_RANGES to an array of rev_range_t and find the youngest      and oldest revision range that spans all of OPT_REV_RANGES. */
operator|*
name|revision_ranges
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|opt_rev_ranges
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|rev_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opt_rev_ranges
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_opt_revision_range_t
modifier|*
name|range
decl_stmt|;
name|rev_range_t
modifier|*
name|rev_range
decl_stmt|;
name|svn_boolean_t
name|start_same_as_end
init|=
name|FALSE
decl_stmt|;
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|opt_rev_ranges
argument_list|,
name|i
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Right now RANGE can be any valid pair of svn_opt_revision_t's.  We          will now convert all RANGEs in place to the corresponding          svn_opt_revision_number kind. */
if|if
condition|(
operator|(
name|range
operator|->
name|start
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
operator|)
operator|&&
operator|(
name|range
operator|->
name|end
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
condition|)
block|{
comment|/* If the user specified exactly one revision, then start rev is            * set but end is not.  We show the log message for just that            * revision by making end equal to start.            *            * Note that if the user requested a single dated revision, then            * this will cause the same date to be resolved twice.  The            * extra code complexity to get around this slight inefficiency            * doesn't seem worth it, however. */
name|range
operator|->
name|end
operator|=
name|range
operator|->
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|range
operator|->
name|start
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
block|{
comment|/* Default to any specified peg revision.  Otherwise, if the            * first target is a URL, then we default to HEAD:0.  Lastly,            * the default is BASE:0 since WC@HEAD may not exist. */
if|if
condition|(
name|peg_rev
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|url_or_abspath
argument_list|)
condition|)
name|range
operator|->
name|start
operator|.
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
else|else
name|range
operator|->
name|start
operator|.
name|kind
operator|=
name|svn_opt_revision_base
expr_stmt|;
block|}
else|else
name|range
operator|->
name|start
operator|=
operator|*
name|peg_rev
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|end
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
block|{
name|range
operator|->
name|end
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|range
operator|->
name|end
operator|.
name|value
operator|.
name|number
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|range
operator|->
name|start
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|||
operator|(
name|range
operator|->
name|end
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing required revision specification"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Does RANGE describe a single svn_opt_revision_t? */
if|if
condition|(
name|range
operator|->
name|start
operator|.
name|kind
operator|==
name|range
operator|->
name|end
operator|.
name|kind
condition|)
block|{
if|if
condition|(
name|range
operator|->
name|start
operator|.
name|kind
operator|==
name|svn_opt_revision_number
condition|)
block|{
if|if
condition|(
name|range
operator|->
name|start
operator|.
name|value
operator|.
name|number
operator|==
name|range
operator|->
name|end
operator|.
name|value
operator|.
name|number
condition|)
name|start_same_as_end
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|range
operator|->
name|start
operator|.
name|kind
operator|==
name|svn_opt_revision_date
condition|)
block|{
if|if
condition|(
name|range
operator|->
name|start
operator|.
name|value
operator|.
name|date
operator|==
name|range
operator|->
name|end
operator|.
name|value
operator|.
name|date
condition|)
name|start_same_as_end
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|start_same_as_end
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|rev_range
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rev_range
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|rev_range
operator|->
name|range_start
argument_list|,
operator|&
name|head_rev
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|url_or_abspath
argument_list|,
name|ra_session
argument_list|,
operator|&
name|range
operator|->
name|start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_same_as_end
condition|)
name|rev_range
operator|->
name|range_end
operator|=
name|rev_range
operator|->
name|range_start
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|rev_range
operator|->
name|range_end
argument_list|,
operator|&
name|head_rev
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|url_or_abspath
argument_list|,
name|ra_session
argument_list|,
operator|&
name|range
operator|->
name|end
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Possibly update the oldest and youngest revisions requested. */
name|find_youngest_and_oldest_revs
argument_list|(
name|youngest_rev
argument_list|,
name|oldest_rev
argument_list|,
name|rev_range
operator|->
name|range_start
argument_list|)
expr_stmt|;
name|find_youngest_and_oldest_revs
argument_list|(
name|youngest_rev
argument_list|,
name|oldest_rev
argument_list|,
name|rev_range
operator|->
name|range_end
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|revision_ranges
argument_list|,
name|rev_range_t
operator|*
argument_list|)
operator|=
name|rev_range
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_rev_to_segment
parameter_list|(
specifier|const
name|void
modifier|*
name|key_p
parameter_list|,
specifier|const
name|void
modifier|*
name|element_p
parameter_list|)
block|{
name|svn_revnum_t
name|rev
init|=
operator|*
operator|(
name|svn_revnum_t
operator|*
operator|)
name|key_p
decl_stmt|;
specifier|const
name|svn_location_segment_t
modifier|*
name|segment
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_location_segment_t
operator|*
specifier|const
operator|*
operator|)
name|element_p
operator|)
decl_stmt|;
if|if
condition|(
name|rev
operator|<
name|segment
operator|->
name|range_start
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|rev
operator|>
name|segment
operator|->
name|range_end
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Run svn_ra_get_log2 for PATHS, one or more paths relative to RA_SESSION's    common parent, for each revision in REVISION_RANGES, an array of    rev_range_t.     RA_SESSION is an open session pointing to ACTUAL_LOC.     LOG_SEGMENTS is an array of svn_location_segment_t * items representing the    history of PATHS from the oldest to youngest revisions found in    REVISION_RANGES.     The TARGETS, LIMIT, DISCOVER_CHANGED_PATHS, STRICT_NODE_HISTORY,    INCLUDE_MERGED_REVISIONS, REVPROPS, REAL_RECEIVER, and REAL_RECEIVER_BATON    parameters are all as per the svn_client_log5 API. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_ra_get_log
parameter_list|(
name|apr_array_header_t
modifier|*
name|revision_ranges
parameter_list|,
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|apr_array_header_t
modifier|*
name|log_segments
parameter_list|,
name|svn_client__pathrev_t
modifier|*
name|actual_loc
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
comment|/* The following are as per svn_client_log5. */
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_log_entry_receiver_t
name|real_receiver
parameter_list|,
name|void
modifier|*
name|real_receiver_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pre_15_receiver_baton_t
name|rb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|has_log_revprops
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|has_log_revprops
argument_list|,
name|SVN_RA_CAPABILITY_LOG_REVPROPS
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_log_revprops
condition|)
block|{
comment|/* See above pre-1.5 notes. */
name|rb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
comment|/* Create ra session on first use */
name|rb
operator|.
name|ra_session_pool
operator|=
name|scratch_pool
expr_stmt|;
name|rb
operator|.
name|ra_session_url
operator|=
name|actual_loc
operator|->
name|url
expr_stmt|;
block|}
comment|/* It's a bit complex to correctly handle the special revision words    * such as "BASE", "COMMITTED", and "PREV".  For example, if the    * user runs    *    *   $ svn log -rCOMMITTED foo.txt bar.c    *    * which committed rev should be used?  The younger of the two?  The    * first one?  Should we just error?    *    * None of the above, I think.  Rather, the committed rev of each    * target in turn should be used.  This is what most users would    * expect, and is the most useful interpretation.  Of course, this    * goes for the other dynamic (i.e., local) revision words too.    *    * Note that the code to do this is a bit more complex than a simple    * loop, because the user might run    *    *    $ svn log -rCOMMITTED:42 foo.txt bar.c    *    * in which case we want to avoid recomputing the static revision on    * every iteration.    *    * ### FIXME: However, we can't yet handle multiple wc targets anyway.    *    * We used to iterate over each target in turn, getting the logs for    * the named range.  This led to revisions being printed in strange    * order or being printed more than once.  This is issue 1550.    *    * In r851673, jpieper blocked multiple wc targets in svn/log-cmd.c,    * meaning this block not only doesn't work right in that case, but isn't    * even testable that way (svn has no unit test suite; we can only test    * via the svn command).  So, that check is now moved into this function    * (see above).    *    * kfogel ponders future enhancements in r844260:    * I think that's okay behavior, since the sense of the command is    * that one wants a particular range of logs for *this* file, then    * another range for *that* file, and so on.  But we should    * probably put some sort of separator header between the log    * groups.  Of course, libsvn_client can't just print stuff out --    * it has to take a callback from the client to do that.  So we    * need to define that callback interface, then have the command    * line client pass one down here.    *    * epg wonders if the repository could send a unified stream of log    * entries if the paths and revisions were passed down.    */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revision_ranges
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|old_session_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath_or_url
decl_stmt|;
name|rev_range_t
modifier|*
name|range
decl_stmt|;
name|limit_receiver_baton_t
name|lb
decl_stmt|;
name|svn_log_entry_receiver_t
name|passed_receiver
decl_stmt|;
name|void
modifier|*
name|passed_receiver_baton
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|passed_receiver_revprops
decl_stmt|;
name|svn_location_segment_t
modifier|*
modifier|*
name|matching_segment
decl_stmt|;
name|svn_revnum_t
name|younger_rev
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath_or_url
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|local_abspath_or_url
operator|=
name|path
expr_stmt|;
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|revision_ranges
argument_list|,
name|i
argument_list|,
name|rev_range_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Issue #4355: Account for renames spanning requested          revision ranges. */
name|younger_rev
operator|=
name|MAX
argument_list|(
name|range
operator|->
name|range_start
argument_list|,
name|range
operator|->
name|range_end
argument_list|)
expr_stmt|;
name|matching_segment
operator|=
name|bsearch
argument_list|(
operator|&
name|younger_rev
argument_list|,
name|log_segments
operator|->
name|elts
argument_list|,
name|log_segments
operator|->
name|nelts
argument_list|,
name|log_segments
operator|->
name|elt_size
argument_list|,
name|compare_rev_to_segment
argument_list|)
expr_stmt|;
comment|/* LOG_SEGMENTS is supposed to represent the history of PATHS from          the oldest to youngest revs in REVISION_RANGES.  This function's          current sole caller svn_client_log5 *should* be providing          LOG_SEGMENTS that span the oldest to youngest revs in          REVISION_RANGES, even if one or more of the svn_location_segment_t's          returned have NULL path members indicating a gap in the history. So          MATCHING_SEGMENT should never be NULL, but clearly sometimes it is,          see http://svn.haxx.se/dev/archive-2013-06/0522.shtml          So to be safe we handle that case. */
if|if
condition|(
name|matching_segment
operator|==
name|NULL
condition|)
continue|continue;
comment|/* A segment with a NULL path means there is gap in the history.          We'll just proceed and let svn_ra_get_log2 fail with a useful          error...*/
if|if
condition|(
operator|(
operator|*
name|matching_segment
operator|)
operator|->
name|path
operator|!=
name|NULL
condition|)
block|{
comment|/* ...but if there is history, then we must account for issue              #4355 and make sure our RA session is pointing at the correct              location. */
specifier|const
name|char
modifier|*
name|segment_url
init|=
name|svn_path_url_add_component2
argument_list|(
name|actual_loc
operator|->
name|repos_root_url
argument_list|,
operator|(
operator|*
name|matching_segment
operator|)
operator|->
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_session_url
argument_list|,
name|ra_session
argument_list|,
name|segment_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_log_revprops
condition|)
block|{
name|passed_receiver
operator|=
name|real_receiver
expr_stmt|;
name|passed_receiver_baton
operator|=
name|real_receiver_baton
expr_stmt|;
name|passed_receiver_revprops
operator|=
name|revprops
expr_stmt|;
block|}
else|else
block|{
name|rb
operator|.
name|revprops
operator|=
name|revprops
expr_stmt|;
name|rb
operator|.
name|receiver
operator|=
name|real_receiver
expr_stmt|;
name|rb
operator|.
name|baton
operator|=
name|real_receiver_baton
expr_stmt|;
name|passed_receiver
operator|=
name|pre_15_receiver
expr_stmt|;
name|passed_receiver_baton
operator|=
operator|&
name|rb
expr_stmt|;
name|passed_receiver_revprops
operator|=
name|svn_compat_log_revprops_in
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|&&
name|revision_ranges
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
name|lb
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
name|lb
operator|.
name|receiver
operator|=
name|passed_receiver
expr_stmt|;
name|lb
operator|.
name|baton
operator|=
name|passed_receiver_baton
expr_stmt|;
name|passed_receiver
operator|=
name|limit_receiver
expr_stmt|;
name|passed_receiver_baton
operator|=
operator|&
name|lb
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_get_log2
argument_list|(
name|ra_session
argument_list|,
name|paths
argument_list|,
name|range
operator|->
name|range_start
argument_list|,
name|range
operator|->
name|range_end
argument_list|,
name|limit
argument_list|,
name|discover_changed_paths
argument_list|,
name|strict_node_history
argument_list|,
name|include_merged_revisions
argument_list|,
name|passed_receiver_revprops
argument_list|,
name|passed_receiver
argument_list|,
name|passed_receiver_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|&&
name|revision_ranges
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
name|limit
operator|=
name|lb
operator|.
name|limit
expr_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*** Public Interface. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client_log5
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|opt_rev_ranges
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_log_entry_receiver_t
name|real_receiver
parameter_list|,
name|void
modifier|*
name|real_receiver_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_session_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|ra_target
decl_stmt|;
name|svn_opt_revision_t
name|youngest_opt_rev
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_revnum_t
name|oldest_rev
decl_stmt|;
name|svn_opt_revision_t
name|peg_rev
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|actual_loc
decl_stmt|;
name|apr_array_header_t
modifier|*
name|log_segments
decl_stmt|;
name|apr_array_header_t
modifier|*
name|revision_ranges
decl_stmt|;
name|apr_array_header_t
modifier|*
name|relative_targets
decl_stmt|;
if|if
condition|(
name|opt_rev_ranges
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing required revision specification"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Make a copy of PEG_REVISION, we may need to change it to a      default value. */
name|peg_rev
operator|=
operator|*
name|peg_revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|resolve_log_targets
argument_list|(
operator|&
name|relative_targets
argument_list|,
operator|&
name|ra_target
argument_list|,
operator|&
name|peg_rev
argument_list|,
name|targets
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|actual_loc
argument_list|,
name|ra_target
argument_list|,
name|NULL
argument_list|,
operator|&
name|peg_rev
argument_list|,
operator|&
name|peg_rev
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert OPT_REV_RANGES to an array of rev_range_t and find the youngest      and oldest revision range that spans all of OPT_REV_RANGES. */
name|SVN_ERR
argument_list|(
name|convert_opt_rev_array_to_rev_range_array
argument_list|(
operator|&
name|revision_ranges
argument_list|,
operator|&
name|youngest_rev
argument_list|,
operator|&
name|oldest_rev
argument_list|,
name|ra_session
argument_list|,
name|ra_target
argument_list|,
name|opt_rev_ranges
argument_list|,
operator|&
name|peg_rev
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make ACTUAL_LOC and RA_SESSION point to the youngest operative rev. */
name|youngest_opt_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|youngest_opt_rev
operator|.
name|value
operator|.
name|number
operator|=
name|youngest_rev
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__resolve_rev_and_url
argument_list|(
operator|&
name|actual_loc
argument_list|,
name|ra_session
argument_list|,
name|ra_target
argument_list|,
operator|&
name|peg_rev
argument_list|,
operator|&
name|youngest_opt_rev
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_session_url
argument_list|,
name|ra_session
argument_list|,
name|actual_loc
operator|->
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save us an RA layer round trip if we are on the repository root and      know the result in advance, or if we don't need multiple ranges.      All the revision data has already been validated.    */
if|if
condition|(
name|strcmp
argument_list|(
name|actual_loc
operator|->
name|url
argument_list|,
name|actual_loc
operator|->
name|repos_root_url
argument_list|)
operator|==
literal|0
operator|||
name|opt_rev_ranges
operator|->
name|nelts
operator|<=
literal|1
condition|)
block|{
name|svn_location_segment_t
modifier|*
name|segment
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|segment
argument_list|)
argument_list|)
decl_stmt|;
name|log_segments
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|segment
argument_list|)
argument_list|)
expr_stmt|;
name|segment
operator|->
name|range_start
operator|=
name|oldest_rev
expr_stmt|;
name|segment
operator|->
name|range_end
operator|=
name|actual_loc
operator|->
name|rev
expr_stmt|;
name|segment
operator|->
name|path
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|actual_loc
operator|->
name|repos_root_url
argument_list|,
name|actual_loc
operator|->
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|log_segments
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
operator|=
name|segment
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the svn_location_segment_t's representing the requested log        * ranges. */
name|SVN_ERR
argument_list|(
name|svn_client__repos_location_segments
argument_list|(
operator|&
name|log_segments
argument_list|,
name|ra_session
argument_list|,
name|actual_loc
operator|->
name|url
argument_list|,
name|actual_loc
operator|->
name|rev
argument_list|,
comment|/* peg */
name|actual_loc
operator|->
name|rev
argument_list|,
comment|/* start */
name|oldest_rev
argument_list|,
comment|/* end */
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|run_ra_get_log
argument_list|(
name|revision_ranges
argument_list|,
name|relative_targets
argument_list|,
name|log_segments
argument_list|,
name|actual_loc
argument_list|,
name|ra_session
argument_list|,
name|targets
argument_list|,
name|limit
argument_list|,
name|discover_changed_paths
argument_list|,
name|strict_node_history
argument_list|,
name|include_merged_revisions
argument_list|,
name|revprops
argument_list|,
name|real_receiver
argument_list|,
name|real_receiver_baton
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

