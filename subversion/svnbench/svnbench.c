begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svnbench.c:  Subversion benchmark client.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_opt_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Option Processing ***/
end_comment

begin_comment
comment|/* Add an identifier here for long options that don't have a short    option. Options that have both long and short options should just    use the short option letter as identifier.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|svn_cl__longopt_t
block|{
name|opt_auth_password
init|=
name|SVN_OPT_FIRST_LONGOPT_ID
block|,
name|opt_auth_username
block|,
name|opt_config_dir
block|,
name|opt_config_options
block|,
name|opt_depth
block|,
name|opt_no_auth_cache
block|,
name|opt_non_interactive
block|,
name|opt_stop_on_copy
block|,
name|opt_strict
block|,
name|opt_targets
block|,
name|opt_version
block|,
name|opt_with_revprop
block|,
name|opt_with_all_revprops
block|,
name|opt_with_no_revprops
block|,
name|opt_trust_server_cert
block|,
name|opt_trust_server_cert_failures
block|,
name|opt_changelist
block|}
name|svn_cl__longopt_t
typedef|;
end_typedef

begin_comment
comment|/* Option codes and descriptions for the command line client.  *  * The entire list must be terminated with an entry of nulls.  */
end_comment

begin_decl_stmt
specifier|const
name|apr_getopt_option_t
name|svn_cl__options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|'h'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
literal|'?'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
literal|"quiet"
block|,
literal|'q'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"print nothing, or only summary information"
argument_list|)
block|}
block|,
block|{
literal|"recursive"
block|,
literal|'R'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"descend recursively, same as --depth=infinity"
argument_list|)
block|}
block|,
block|{
literal|"non-recursive"
block|,
literal|'N'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"obsolete; try --depth=files or --depth=immediates"
argument_list|)
block|}
block|,
block|{
literal|"change"
block|,
literal|'c'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"the change made by revision ARG (like -r ARG-1:ARG)\n"
literal|"                             "
literal|"If ARG is negative this is like -r ARG:ARG-1\n"
literal|"                             "
literal|"If ARG is of the form ARG1-ARG2 then this is like\n"
literal|"                             "
literal|"ARG1:ARG2, where ARG1 is inclusive"
argument_list|)
block|}
block|,
block|{
literal|"revision"
block|,
literal|'r'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"ARG (some commands also take ARG1:ARG2 range)\n"
literal|"                             "
literal|"A revision argument can be one of:\n"
literal|"                             "
literal|"   NUMBER       revision number\n"
literal|"                             "
literal|"   '{' DATE '}' revision at start of the date\n"
literal|"                             "
literal|"   'HEAD'       latest in repository\n"
literal|"                             "
literal|"   'BASE'       base rev of item's working copy\n"
literal|"                             "
literal|"   'COMMITTED'  last commit at or before BASE\n"
literal|"                             "
literal|"   'PREV'       revision just before COMMITTED"
argument_list|)
block|}
block|,
block|{
literal|"version"
block|,
name|opt_version
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show program version information"
argument_list|)
block|}
block|,
block|{
literal|"verbose"
block|,
literal|'v'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"print extra information"
argument_list|)
block|}
block|,
block|{
literal|"username"
block|,
name|opt_auth_username
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify a username ARG"
argument_list|)
block|}
block|,
block|{
literal|"password"
block|,
name|opt_auth_password
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify a password ARG"
argument_list|)
block|}
block|,
block|{
literal|"targets"
block|,
name|opt_targets
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"pass contents of file ARG as additional args"
argument_list|)
block|}
block|,
block|{
literal|"depth"
block|,
name|opt_depth
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"limit operation by depth ARG ('empty', 'files',\n"
literal|"                             "
literal|"'immediates', or 'infinity')"
argument_list|)
block|}
block|,
block|{
literal|"strict"
block|,
name|opt_strict
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"use strict semantics"
argument_list|)
block|}
block|,
block|{
literal|"stop-on-copy"
block|,
name|opt_stop_on_copy
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do not cross copies while traversing history"
argument_list|)
block|}
block|,
block|{
literal|"no-auth-cache"
block|,
name|opt_no_auth_cache
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do not cache authentication tokens"
argument_list|)
block|}
block|,
block|{
literal|"trust-server-cert"
block|,
name|opt_trust_server_cert
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"deprecated; same as\n"
literal|"                             "
literal|"--trust-server-cert-failures=unknown-ca"
argument_list|)
block|}
block|,
block|{
literal|"trust-server-cert-failures"
block|,
name|opt_trust_server_cert_failures
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"with --non-interactive, accept SSL server\n"
literal|"                             "
literal|"certificates with failures; ARG is comma-separated\n"
literal|"                             "
literal|"list of 'unknown-ca' (Unknown Authority),\n"
literal|"                             "
literal|"'cn-mismatch' (Hostname mismatch), 'expired'\n"
literal|"                             "
literal|"(Expired certificate), 'not-yet-valid' (Not yet\n"
literal|"                             "
literal|"valid certificate) and 'other' (all other not\n"
literal|"                             "
literal|"separately classified certificate errors)."
argument_list|)
block|}
block|,
block|{
literal|"non-interactive"
block|,
name|opt_non_interactive
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do no interactive prompting"
argument_list|)
block|}
block|,
block|{
literal|"config-dir"
block|,
name|opt_config_dir
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"read user configuration files from directory ARG"
argument_list|)
block|}
block|,
block|{
literal|"config-option"
block|,
name|opt_config_options
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"set user configuration option in the format:\n"
literal|"                             "
literal|"    FILE:SECTION:OPTION=[VALUE]\n"
literal|"                             "
literal|"For example:\n"
literal|"                             "
literal|"    servers:global:http-library=serf"
argument_list|)
block|}
block|,
block|{
literal|"limit"
block|,
literal|'l'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"maximum number of log entries"
argument_list|)
block|}
block|,
block|{
literal|"with-all-revprops"
block|,
name|opt_with_all_revprops
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"retrieve all revision properties"
argument_list|)
block|}
block|,
block|{
literal|"with-no-revprops"
block|,
name|opt_with_no_revprops
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"retrieve no revision properties"
argument_list|)
block|}
block|,
block|{
literal|"with-revprop"
block|,
name|opt_with_revprop
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"set revision property ARG in new revision\n"
literal|"                             "
literal|"using the name[=value] format"
argument_list|)
block|}
block|,
block|{
literal|"use-merge-history"
block|,
literal|'g'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"use/display additional information from merge\n"
literal|"                             "
literal|"history"
argument_list|)
block|}
block|,
comment|/* Long-opt Aliases    *    * These have NULL desriptions, but an option code that matches some    * other option (whose description should probably mention its aliases).   */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*** Command dispatch. ***/
end_comment

begin_comment
comment|/* Our array of available subcommands.  *  * The entire list must be terminated with an entry of nulls.  *  * In most of the help text "PATH" is used where a working copy path is  * required, "URL" where a repository URL is required and "TARGET" when  * either a path or a url can be used.  Hmm, should this be part of the  * help text?  */
end_comment

begin_comment
comment|/* Options that apply to all commands.  (While not every command may    currently require authentication or be interactive, allowing every    command to take these arguments allows scripts to just pass them    willy-nilly to every invocation of 'svn') . */
end_comment

begin_decl_stmt
specifier|const
name|int
name|svn_cl__global_options
index|[]
init|=
block|{
name|opt_auth_username
block|,
name|opt_auth_password
block|,
name|opt_no_auth_cache
block|,
name|opt_non_interactive
block|,
name|opt_trust_server_cert
block|,
name|opt_trust_server_cert_failures
block|,
name|opt_config_dir
block|,
name|opt_config_options
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|svn_opt_subcommand_desc2_t
name|svn_cl__cmd_table
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|svn_cl__help
block|,
block|{
literal|"?"
block|,
literal|"h"
block|}
block|,
name|N_
argument_list|(
literal|"Describe the usage of this program or its subcommands.\n"
literal|"usage: help [SUBCOMMAND...]\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
comment|/* This command is also invoked if we see option "--help", "-h" or "-?". */
block|{
literal|"null-blame"
block|,
name|svn_cl__null_blame
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"Fetch all versions of a file in a batch.\n"
literal|"usage: null-blame [-rM:N] TARGET[@REV]...\n"
literal|"\n"
literal|"  With no revision range (same as -r0:REV), or with '-r M:N' where M< N,\n"
literal|"  annotate each line that is present in revision N of the file, with\n"
literal|"  the last revision at or before rN that changed or added the line,\n"
literal|"  looking back no further than rM.\n"
literal|"\n"
literal|"  With a reverse revision range '-r M:N' where M> N,\n"
literal|"  annotate each line that is present in revision N of the file, with\n"
literal|"  the next revision after rN that changed or deleted the line,\n"
literal|"  looking forward no further than rM.\n"
literal|"\n"
literal|"  If specified, REV determines in which revision the target is first\n"
literal|"  looked up.\n"
literal|"\n"
literal|"  Write the annotated result to standard output.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'g'
block|}
block|}
block|,
block|{
literal|"null-export"
block|,
name|svn_cl__null_export
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"Create an unversioned copy of a tree.\n"
literal|"usage: null-export [-r REV] URL[@PEGREV]\n"
literal|"\n"
literal|"  Exports a clean directory tree from the repository specified by\n"
literal|"  URL, at revision REV if it is given, otherwise at HEAD.\n"
literal|"\n"
literal|"  If specified, PEGREV determines in which revision the target is first\n"
literal|"  looked up.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'q'
block|,
literal|'N'
block|,
name|opt_depth
block|}
block|}
block|,
block|{
literal|"null-list"
block|,
name|svn_cl__null_list
block|,
block|{
literal|"ls"
block|}
block|,
name|N_
argument_list|(
literal|"List directory entries in the repository.\n"
literal|"usage: null-list [TARGET[@REV]...]\n"
literal|"\n"
literal|"  List each TARGET file and the contents of each TARGET directory as\n"
literal|"  they exist in the repository.  If TARGET is a working copy path, the\n"
literal|"  corresponding repository URL will be used. If specified, REV determines\n"
literal|"  in which revision the target is first looked up.\n"
literal|"\n"
literal|"  The default TARGET is '.', meaning the repository URL of the current\n"
literal|"  working directory.\n"
literal|"\n"
literal|"  With --verbose, the following fields will be fetched for each item:\n"
literal|"\n"
literal|"    Revision number of the last commit\n"
literal|"    Author of the last commit\n"
literal|"    If locked, the letter 'O'.  (Use 'svn info URL' to see details)\n"
literal|"    Size (in bytes)\n"
literal|"    Date and time of the last commit\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'v'
block|,
literal|'q'
block|,
literal|'R'
block|,
name|opt_depth
block|}
block|}
block|,
block|{
literal|"null-log"
block|,
name|svn_cl__null_log
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"Fetch the log messages for a set of revision(s) and/or path(s).\n"
literal|"usage: 1. null-log [PATH][@REV]\n"
literal|"       2. null-log URL[@REV] [PATH...]\n"
literal|"\n"
literal|"  1. Fetch the log messages for the URL corresponding to PATH\n"
literal|"     (default: '.'). If specified, REV is the revision in which the\n"
literal|"     URL is first looked up, and the default revision range is REV:1.\n"
literal|"     If REV is not specified, the default revision range is BASE:1,\n"
literal|"     since the URL might not exist in the HEAD revision.\n"
literal|"\n"
literal|"  2. Fetch the log messages for the PATHs (default: '.') under URL.\n"
literal|"     If specified, REV is the revision in which the URL is first\n"
literal|"     looked up, and the default revision range is REV:1; otherwise,\n"
literal|"     the URL is looked up in HEAD, and the default revision range is\n"
literal|"     HEAD:1.\n"
literal|"\n"
literal|"  Multiple '-c' or '-r' options may be specified (but not a\n"
literal|"  combination of '-c' and '-r' options), and mixing of forward and\n"
literal|"  reverse ranges is allowed.\n"
literal|"\n"
literal|"  With -v, also print all affected paths with each log message.\n"
literal|"  With -q, don't print the log message body itself (note that this is\n"
literal|"  compatible with -v).\n"
literal|"\n"
literal|"  Each log message is printed just once, even if more than one of the\n"
literal|"  affected paths for that revision were explicitly requested.  Logs\n"
literal|"  follow copy history by default.  Use --stop-on-copy to disable this\n"
literal|"  behavior, which can be useful for determining branchpoints.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'q'
block|,
literal|'v'
block|,
literal|'g'
block|,
literal|'c'
block|,
name|opt_targets
block|,
name|opt_stop_on_copy
block|,
literal|'l'
block|,
name|opt_with_all_revprops
block|,
name|opt_with_no_revprops
block|,
name|opt_with_revprop
block|,}
block|,
block|{
block|{
name|opt_with_revprop
block|,
name|N_
argument_list|(
literal|"retrieve revision property ARG"
argument_list|)
block|}
block|,
block|{
literal|'c'
block|,
name|N_
argument_list|(
literal|"the change made in revision ARG"
argument_list|)
block|}
block|}
block|}
block|,
block|{
literal|"null-info"
block|,
name|svn_cl__null_info
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"Display information about a local or remote item.\n"
literal|"usage: null-info [TARGET[@REV]...]\n"
literal|"\n"
literal|"  Print information about each TARGET (default: '.').\n"
literal|"  TARGET may be either a working-copy path or URL.  If specified, REV\n"
literal|"  determines in which revision the target is first looked up.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'R'
block|,
name|opt_depth
block|,
name|opt_targets
block|,
name|opt_changelist
block|}
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Version compatibility check */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lib_versions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_client"
block|,
name|svn_client_version
block|}
block|,
block|{
literal|"svn_wc"
block|,
name|svn_wc_version
block|}
block|,
block|{
literal|"svn_ra"
block|,
name|svn_ra_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
return|return
name|svn_ver_check_list2
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A flag to see if we've been cancelled by the client or not. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|cancelled
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A signal handler to support cancellation. */
end_comment

begin_function
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|apr_signal
argument_list|(
name|signum
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|cancelled
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Our cancellation callback. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cl__check_cancel
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
if|if
condition|(
name|cancelled
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CANCELLED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Caught signal"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Main. ***/
end_comment

begin_comment
comment|/*  * On success, leave *EXIT_CODE untouched and return SVN_NO_ERROR. On error,  * either return an error to be displayed, or set *EXIT_CODE to non-zero and  * return SVN_NO_ERROR.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sub_main
parameter_list|(
name|int
modifier|*
name|exit_code
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|opt_id
decl_stmt|;
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
name|svn_cl__opt_state_t
name|opt_state
init|=
block|{
literal|0
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|apr_array_header_t
modifier|*
name|received_opts
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|subcommand
init|=
name|NULL
decl_stmt|;
name|svn_cl__cmd_baton_t
name|command_baton
decl_stmt|;
name|svn_auth_baton_t
modifier|*
name|ab
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg_config
decl_stmt|;
name|svn_boolean_t
name|descend
init|=
name|TRUE
decl_stmt|;
name|svn_boolean_t
name|use_notifier
init|=
name|TRUE
decl_stmt|;
name|received_opts
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|SVN_OPT_MAX_OPTIONS
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check library versions */
name|SVN_ERR
argument_list|(
name|check_lib_versions
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Set the working copy administrative directory name. */
if|if
condition|(
name|getenv
argument_list|(
literal|"SVN_ASP_DOT_NET_HACK"
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_set_adm_dir
argument_list|(
literal|"_svn"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize the RA library. */
name|SVN_ERR
argument_list|(
name|svn_ra_initialize
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Begin processing arguments. */
name|opt_state
operator|.
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_state
operator|.
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_state
operator|.
name|revision_ranges
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_opt_revision_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|opt_state
operator|.
name|depth
operator|=
name|svn_depth_unknown
expr_stmt|;
comment|/* No args?  Show usage. */
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cl__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Else, parse options. */
name|SVN_ERR
argument_list|(
name|svn_cmdline__getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|interleave
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|utf8_opt_arg
decl_stmt|;
comment|/* Parse the next option. */
name|apr_status_t
name|apr_err
init|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|svn_cl__options
argument_list|,
operator|&
name|opt_id
argument_list|,
operator|&
name|opt_arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|apr_err
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|apr_err
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cl__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Stash the option code in an array before parsing it. */
name|APR_ARRAY_PUSH
argument_list|(
name|received_opts
argument_list|,
name|int
argument_list|)
operator|=
name|opt_id
expr_stmt|;
switch|switch
condition|(
name|opt_id
condition|)
block|{
case|case
literal|'l'
case|:
block|{
name|err
operator|=
name|svn_cstring_atoi
argument_list|(
operator|&
name|opt_state
operator|.
name|limit
argument_list|,
name|opt_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Non-numeric limit argument given"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|opt_state
operator|.
name|limit
operator|<=
literal|0
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Argument to --limit must be positive"
argument_list|)
argument_list|)
return|;
block|}
block|}
break|break;
case|case
literal|'c'
case|:
block|{
name|apr_array_header_t
modifier|*
name|change_revs
init|=
name|svn_cstring_split
argument_list|(
name|opt_arg
argument_list|,
literal|", \n\r\t\v"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|change_revs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|svn_revnum_t
name|changeno
decl_stmt|,
name|changeno_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|change_str
init|=
name|APR_ARRAY_IDX
argument_list|(
name|change_revs
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|change_str
decl_stmt|;
name|svn_boolean_t
name|is_negative
decl_stmt|;
comment|/* Check for a leading minus to allow "-c -r42".                * The is_negative flag is used to handle "-c -42" and "-c -r42".                * The "-c r-42" case is handled by strtol() returning a                * negative number. */
name|is_negative
operator|=
operator|(
operator|*
name|s
operator|==
literal|'-'
operator|)
expr_stmt|;
if|if
condition|(
name|is_negative
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Allow any number of 'r's to prefix a revision number. */
while|while
condition|(
operator|*
name|s
operator|==
literal|'r'
condition|)
name|s
operator|++
expr_stmt|;
name|changeno
operator|=
name|changeno_end
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|s
operator|&&
operator|*
name|end
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|changeno
operator|<
literal|0
operator|||
name|is_negative
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Negative number in range (%s)"
literal|" not supported with -c"
argument_list|)
argument_list|,
name|change_str
argument_list|)
return|;
block|}
name|s
operator|=
name|end
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'r'
condition|)
name|s
operator|++
expr_stmt|;
name|changeno_end
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|==
name|change_str
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Non-numeric change argument (%s) "
literal|"given to -c"
argument_list|)
argument_list|,
name|change_str
argument_list|)
return|;
block|}
if|if
condition|(
name|changeno
operator|==
literal|0
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"There is no change 0"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|is_negative
condition|)
name|changeno
operator|=
operator|-
name|changeno
expr_stmt|;
comment|/* Figure out the range:                     -c N  -> -r N-1:N                     -c -N -> -r N:N-1                     -c M-N -> -r M-1:N for M< N                     -c M-N -> -r M:N-1 for M> N                     -c -M-N -> error (too confusing/no valid use case)               */
if|if
condition|(
name|changeno
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|changeno
operator|<=
name|changeno_end
condition|)
name|changeno
operator|--
expr_stmt|;
else|else
name|changeno_end
operator|--
expr_stmt|;
block|}
else|else
block|{
name|changeno
operator|=
operator|-
name|changeno
expr_stmt|;
name|changeno_end
operator|=
name|changeno
operator|-
literal|1
expr_stmt|;
block|}
name|opt_state
operator|.
name|used_change_arg
operator|=
name|TRUE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|opt_state
operator|.
name|revision_ranges
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
operator|=
name|svn_opt__revision_range_from_revnums
argument_list|(
name|changeno
argument_list|,
name|changeno_end
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'r'
case|:
name|opt_state
operator|.
name|used_revision_arg
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|svn_opt_parse_revision_to_range
argument_list|(
name|opt_state
operator|.
name|revision_ranges
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Syntax error in revision argument '%s'"
argument_list|)
argument_list|,
name|utf8_opt_arg
argument_list|)
return|;
block|}
break|break;
case|case
literal|'v'
case|:
name|opt_state
operator|.
name|verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
name|opt_state
operator|.
name|help
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|opt_state
operator|.
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_targets
case|:
block|{
name|svn_stringbuf_t
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|buffer_utf8
decl_stmt|;
comment|/* We need to convert to UTF-8 now, even before we divide              the targets into an array, because otherwise we wouldn't              know what delimiter to use for svn_cstring_split().  */
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|buffer
argument_list|,
name|utf8_opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_stringbuf_to_utf8
argument_list|(
operator|&
name|buffer_utf8
argument_list|,
name|buffer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|opt_state
operator|.
name|targets
operator|=
name|svn_cstring_split
argument_list|(
name|buffer_utf8
operator|->
name|data
argument_list|,
literal|"\n\r"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
name|opt_state
operator|.
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|descend
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|opt_depth
case|:
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Error converting depth "
literal|"from locale to UTF-8"
argument_list|)
argument_list|)
return|;
name|opt_state
operator|.
name|depth
operator|=
name|svn_depth_from_word
argument_list|(
name|utf8_opt_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|.
name|depth
operator|==
name|svn_depth_unknown
operator|||
name|opt_state
operator|.
name|depth
operator|==
name|svn_depth_exclude
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid depth; try "
literal|"'empty', 'files', 'immediates', "
literal|"or 'infinity'"
argument_list|)
argument_list|,
name|utf8_opt_arg
argument_list|)
return|;
block|}
break|break;
case|case
name|opt_version
case|:
name|opt_state
operator|.
name|version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_auth_username
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_state
operator|.
name|auth_username
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|opt_auth_password
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_state
operator|.
name|auth_password
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|opt_stop_on_copy
case|:
name|opt_state
operator|.
name|stop_on_copy
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_strict
case|:
name|opt_state
operator|.
name|strict
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_no_auth_cache
case|:
name|opt_state
operator|.
name|no_auth_cache
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_non_interactive
case|:
name|opt_state
operator|.
name|non_interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_trust_server_cert
case|:
comment|/* backwards compat to 1.8 */
name|opt_state
operator|.
name|trust_server_cert_unknown_ca
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_trust_server_cert_failures
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_trust_options
argument_list|(
operator|&
name|opt_state
operator|.
name|trust_server_cert_unknown_ca
argument_list|,
operator|&
name|opt_state
operator|.
name|trust_server_cert_cn_mismatch
argument_list|,
operator|&
name|opt_state
operator|.
name|trust_server_cert_expired
argument_list|,
operator|&
name|opt_state
operator|.
name|trust_server_cert_not_yet_valid
argument_list|,
operator|&
name|opt_state
operator|.
name|trust_server_cert_other_failure
argument_list|,
name|utf8_opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|opt_config_dir
case|:
block|{
specifier|const
name|char
modifier|*
name|path_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|path_utf8
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|opt_state
operator|.
name|config_dir
operator|=
name|svn_dirent_internal_style
argument_list|(
name|path_utf8
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|opt_config_options
case|:
if|if
condition|(
operator|!
name|opt_state
operator|.
name|config_options
condition|)
name|opt_state
operator|.
name|config_options
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_config_option
argument_list|(
name|opt_state
operator|.
name|config_options
argument_list|,
name|opt_arg
argument_list|,
literal|"svnbench: "
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|opt_with_all_revprops
case|:
comment|/* If --with-all-revprops is specified along with one or more          * --with-revprops options, --with-all-revprops takes precedence. */
name|opt_state
operator|.
name|all_revprops
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_with_no_revprops
case|:
name|opt_state
operator|.
name|no_revprops
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|opt_with_revprop
case|:
name|SVN_ERR
argument_list|(
name|svn_opt_parse_revprop
argument_list|(
operator|&
name|opt_state
operator|.
name|revprop_table
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|opt_state
operator|.
name|use_merge_history
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
comment|/* Hmmm. Perhaps this would be a good place to squirrel away            opts that commands like svn diff might need. Hmmm indeed. */
break|break;
block|}
block|}
comment|/* ### This really belongs in libsvn_client.  The trouble is,      there's no one place there to run it from, no      svn_client_init().  We'd have to add it to all the public      functions that a client might call.  It's unmaintainable to do      initialization from within libsvn_client itself, but it seems      burdensome to demand that all clients call svn_client_init()      before calling any other libsvn_client function... On the other      hand, the alternative is effectively to demand that they call      svn_config_ensure() instead, so maybe we should have a generic      init function anyway.  Thoughts?  */
name|SVN_ERR
argument_list|(
name|svn_config_ensure
argument_list|(
name|opt_state
operator|.
name|config_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the user asked for help, then the rest of the arguments are      the names of subcommands to get help on (if any), or else they're      just typos/mistakes.  Whatever the case, the subcommand to      actually run is svn_cl__help(). */
if|if
condition|(
name|opt_state
operator|.
name|help
condition|)
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|svn_cl__cmd_table
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
comment|/* If we're not running the `help' subcommand, then look for a      subcommand in the first argument. */
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
if|if
condition|(
name|opt_state
operator|.
name|version
condition|)
block|{
comment|/* Use the "help" subcommand to handle the "--version" option. */
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|pseudo_cmd
init|=
block|{
literal|"--version"
block|,
name|svn_cl__help
block|,
block|{
literal|0
block|}
block|,
literal|""
block|,
block|{
name|opt_version
block|,
comment|/* must accept its own option */
literal|'q'
block|,
comment|/* brief output */
literal|'v'
block|,
comment|/* verbose output */
name|opt_config_dir
comment|/* all commands accept this */
block|}
block|}
decl_stmt|;
name|subcommand
operator|=
operator|&
name|pseudo_cmd
expr_stmt|;
block|}
else|else
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Subcommand argument required\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|first_arg
init|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
decl_stmt|;
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|svn_cl__cmd_table
argument_list|,
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|first_arg_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|first_arg_utf8
argument_list|,
name|first_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Unknown subcommand: '%s'\n"
argument_list|)
argument_list|,
name|first_arg_utf8
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
comment|/* Check that the subcommand wasn't passed any inappropriate options. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|received_opts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|opt_id
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|received_opts
argument_list|,
name|i
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* All commands implicitly accept --help, so just skip over this          when we see it. Note that we don't want to include this option          in their "accepted options" list because it would be awfully          redundant to display it in every commands' help text. */
if|if
condition|(
name|opt_id
operator|==
literal|'h'
operator|||
name|opt_id
operator|==
literal|'?'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|svn_opt_subcommand_takes_option3
argument_list|(
name|subcommand
argument_list|,
name|opt_id
argument_list|,
name|svn_cl__global_options
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
specifier|const
name|apr_getopt_option_t
modifier|*
name|badopt
init|=
name|svn_opt_get_option_from_code2
argument_list|(
name|opt_id
argument_list|,
name|svn_cl__options
argument_list|,
name|subcommand
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_opt_format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|badopt
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|SVN_ERR
argument_list|(
name|svn_cl__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Subcommand '%s' doesn't accept option '%s'\n"
literal|"Type 'svnbench help %s' for usage.\n"
argument_list|)
argument_list|,
name|subcommand
operator|->
name|name
argument_list|,
name|optstr
argument_list|,
name|subcommand
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Only merge and log support multiple revisions/revision ranges. */
if|if
condition|(
name|subcommand
operator|->
name|cmd_func
operator|!=
name|svn_cl__null_log
condition|)
block|{
if|if
condition|(
name|opt_state
operator|.
name|revision_ranges
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Multiple revision arguments "
literal|"encountered; can't specify -c twice, "
literal|"or both -c and -r"
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Disallow simultaneous use of both --with-all-revprops and      --with-no-revprops.  */
if|if
condition|(
name|opt_state
operator|.
name|all_revprops
operator|&&
name|opt_state
operator|.
name|no_revprops
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--with-all-revprops and --with-no-revprops "
literal|"are mutually exclusive"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Disallow simultaneous use of both --with-revprop and      --with-no-revprops.  */
if|if
condition|(
name|opt_state
operator|.
name|revprop_table
operator|&&
name|opt_state
operator|.
name|no_revprops
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--with-revprop and --with-no-revprops "
literal|"are mutually exclusive"
argument_list|)
argument_list|)
return|;
block|}
comment|/* --trust-* options can only be used with --non-interactive */
if|if
condition|(
operator|!
name|opt_state
operator|.
name|non_interactive
condition|)
block|{
if|if
condition|(
name|opt_state
operator|.
name|trust_server_cert_unknown_ca
operator|||
name|opt_state
operator|.
name|trust_server_cert_cn_mismatch
operator|||
name|opt_state
operator|.
name|trust_server_cert_expired
operator|||
name|opt_state
operator|.
name|trust_server_cert_not_yet_valid
operator|||
name|opt_state
operator|.
name|trust_server_cert_other_failure
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--trust-server-cert-failures requires "
literal|"--non-interactive"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Ensure that 'revision_ranges' has at least one item, and make      'start_revision' and 'end_revision' match that item. */
if|if
condition|(
name|opt_state
operator|.
name|revision_ranges
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
name|svn_opt_revision_range_t
modifier|*
name|range
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|range
argument_list|)
argument_list|)
decl_stmt|;
name|range
operator|->
name|start
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|range
operator|->
name|end
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|opt_state
operator|.
name|revision_ranges
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
operator|=
name|range
expr_stmt|;
block|}
name|opt_state
operator|.
name|start_revision
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|opt_state
operator|.
name|revision_ranges
argument_list|,
literal|0
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
operator|->
name|start
expr_stmt|;
name|opt_state
operator|.
name|end_revision
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|opt_state
operator|.
name|revision_ranges
argument_list|,
literal|0
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
operator|->
name|end
expr_stmt|;
comment|/* Create a client context object. */
name|command_baton
operator|.
name|opt_state
operator|=
operator|&
name|opt_state
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_create_context2
argument_list|(
operator|&
name|ctx
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|command_baton
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
comment|/* Only a few commands can accept a revision range; the rest can take at      most one revision number. */
if|if
condition|(
name|subcommand
operator|->
name|cmd_func
operator|!=
name|svn_cl__null_blame
operator|&&
name|subcommand
operator|->
name|cmd_func
operator|!=
name|svn_cl__null_log
condition|)
block|{
if|if
condition|(
name|opt_state
operator|.
name|end_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_REVISION_RANGE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
comment|/* -N has a different meaning depending on the command */
if|if
condition|(
operator|!
name|descend
condition|)
name|opt_state
operator|.
name|depth
operator|=
name|svn_depth_files
expr_stmt|;
name|err
operator|=
name|svn_config_get_config
argument_list|(
operator|&
operator|(
name|ctx
operator|->
name|config
operator|)
argument_list|,
name|opt_state
operator|.
name|config_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Fallback to default config if the config directory isn't readable          or is not a directory. */
if|if
condition|(
name|APR_STATUS_IS_EACCES
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|err
return|;
block|}
name|cfg_config
operator|=
name|apr_hash_get
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|)
expr_stmt|;
comment|/* Update the options in the config */
if|if
condition|(
name|opt_state
operator|.
name|config_options
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline__apply_config_options
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|opt_state
operator|.
name|config_options
argument_list|,
literal|"svn: "
argument_list|,
literal|"--config-option"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the notifier.       In general, we use it any time we aren't in --quiet mode.  'svn      status' is unique, though, in that we don't want it in --quiet mode      unless we're also in --verbose mode.  When in --xml mode,      though, we never want it.  */
if|if
condition|(
name|opt_state
operator|.
name|quiet
condition|)
name|use_notifier
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|use_notifier
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cl__get_notifier
argument_list|(
operator|&
name|ctx
operator|->
name|notify_func2
argument_list|,
operator|&
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set up our cancellation support. */
name|ctx
operator|->
name|cancel_func
operator|=
name|svn_cl__check_cancel
expr_stmt|;
name|apr_signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBREAK
comment|/* SIGBREAK is a Win32 specific signal generated by ctrl-break. */
name|apr_signal
argument_list|(
name|SIGBREAK
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|apr_signal
argument_list|(
name|SIGHUP
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|apr_signal
argument_list|(
name|SIGTERM
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* Disable SIGPIPE generation for the platforms that have it. */
name|apr_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
comment|/* Disable SIGXFSZ generation for the platforms that have it, otherwise    * working with large files when compiled against an APR that doesn't have    * large file support will crash the program, which is uncool. */
name|apr_signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up Authentication stuff. */
name|SVN_ERR
argument_list|(
name|svn_cmdline_create_auth_baton2
argument_list|(
operator|&
name|ab
argument_list|,
name|opt_state
operator|.
name|non_interactive
argument_list|,
name|opt_state
operator|.
name|auth_username
argument_list|,
name|opt_state
operator|.
name|auth_password
argument_list|,
name|opt_state
operator|.
name|config_dir
argument_list|,
name|opt_state
operator|.
name|no_auth_cache
argument_list|,
name|opt_state
operator|.
name|trust_server_cert_unknown_ca
argument_list|,
name|opt_state
operator|.
name|trust_server_cert_cn_mismatch
argument_list|,
name|opt_state
operator|.
name|trust_server_cert_expired
argument_list|,
name|opt_state
operator|.
name|trust_server_cert_not_yet_valid
argument_list|,
name|opt_state
operator|.
name|trust_server_cert_other_failure
argument_list|,
name|cfg_config
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|auth_baton
operator|=
name|ab
expr_stmt|;
comment|/* The new svn behavior is to postpone everything until after the operation      completed */
name|ctx
operator|->
name|conflict_func
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|conflict_baton
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|conflict_func2
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|conflict_baton2
operator|=
name|NULL
expr_stmt|;
comment|/* And now we finally run the subcommand. */
name|err
operator|=
call|(
modifier|*
name|subcommand
operator|->
name|cmd_func
call|)
argument_list|(
name|os
argument_list|,
operator|&
name|command_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* For argument-related problems, suggest using the 'help'          subcommand. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_INSUFFICIENT_ARGS
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_ARG_PARSING_ERROR
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrapf
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Try 'svnbench help %s' for more information"
argument_list|)
argument_list|,
name|subcommand
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_UPGRADE_REQUIRED
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Please see the 'svn upgrade' command"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell the user about 'svn cleanup' if any error on the stack          was about locked working copies. */
if|if
condition|(
name|svn_error_find_cause
argument_list|(
name|err
argument_list|,
name|SVN_ERR_WC_LOCKED
argument_list|)
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Run 'svn cleanup' to remove locks "
literal|"(type 'svn help cleanup' for details)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|int
name|exit_code
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svnbench"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool.  Use a separate mutexless allocator,    * given this application is single threaded.    */
name|pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|sub_main
argument_list|(
operator|&
name|exit_code
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Flush stdout and report if it fails. It would be flushed on exit anyway      but this makes sure that output is not silently lost if it fails. */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|,
literal|"svnbench: "
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function

end_unit

