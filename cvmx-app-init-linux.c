begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  * Simple executive application initialization for Linux user space. This  * file should be used instead of cvmx-app-init.c for running simple executive  * applications under Linux in userspace. The following are some of the key  * points to remember when writing applications to run both under the  * standalone simple executive and userspace under Linux.  *  * -# Application main must be called "appmain" under Linux. Use and ifdef  *      based on __linux__ to determine the proper name.  * -# Be careful to use cvmx_ptr_to_phys() and cvmx_phys_to_ptr. The simple  *      executive 1-1 TLB mappings allow you to be sloppy and interchange  *      hardware addresses with virtual address. This isn't true under Linux.  * -# If you're talking directly to hardware, be careful. The normal Linux  *      protections are circumvented. If you do something bad, Linux won't  *      save you.  * -# Most hardware can only be initialized once. Unless you're very careful,  *      this also means you Linux application can only run once.  *  *<hr>$Revision: 41757 $<hr>  *  */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/statfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmips.h>
end_include

begin_include
include|#
directive|include
file|<sched.h>
end_include

begin_include
include|#
directive|include
file|<octeon-app-init.h>
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-atomic.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-coremask.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_function_decl
name|int
name|octeon_model_version_check
parameter_list|(
name|uint32_t
name|chip_id
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OCTEON_ECLOCK_MULT_INPUT_X16
value|((int)(33.4*16))
end_define

begin_comment
comment|/* Applications using the simple executive libraries under Linux userspace must     rename their "main" function to match the prototype below. This allows the     simple executive to perform needed memory initialization and process     creation before the application runs. */
end_comment

begin_function_decl
specifier|extern
name|int
name|appmain
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* These two external addresses provide the beginning and end markers for the     CVMX_SHARED section. These are defined by the cvmx-shared.ld linker script.     If they aren't defined, you probably forgot to link using this script. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|__cvmx_shared_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|__cvmx_shared_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|linux_mem32_min
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|linux_mem32_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|linux_mem32_wired
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|linux_mem32_offset
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIPS_CAVIUM_XKPHYS_READ
value|2010
end_define

begin_comment
comment|/* XKPHYS */
end_comment

begin_define
define|#
directive|define
name|MIPS_CAVIUM_XKPHYS_WRITE
value|2011
end_define

begin_comment
comment|/* XKPHYS */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|int32_t
name|warn_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * This function performs some default initialization of the Octeon executive.  It initializes  * the cvmx_bootmem memory allocator with the list of physical memory shared by the bootloader.  * This function should be called on all cores that will use the bootmem allocator.  * Applications which require a different configuration can replace this function with a suitable application  * specific one.  *  * @return 0 on success  *         -1 on failure  */
end_comment

begin_function
name|int
name|cvmx_user_app_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Simulator magic is not supported in user mode under Linux.  * This version of simprintf simply calls the underlying C  * library printf for output. It also makes sure that two  * calls to simprintf provide atomic output.  *  * @param fmt    Format string in the same format as printf.  */
end_comment

begin_function
name|void
name|simprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|CVMX_SHARED
specifier|static
name|cvmx_spinlock_t
name|simprintf_lock
init|=
name|CVMX_SPINLOCK_UNLOCKED_INITIALIZER
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|simprintf_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SIMPRINTF(%d): "
argument_list|,
operator|(
name|int
operator|)
name|cvmx_get_core_num
argument_list|()
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|simprintf_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Setup the CVMX_SHARED data section to be shared across  * all processors running this application. A memory mapped  * region is allocated using shm_open and mmap. The current  * contents of the CVMX_SHARED section are copied into the  * region. Then the new region is remapped to replace the  * existing CVMX_SHARED data.  *  * This function will display a message and abort the  * application under any error conditions. The Linux tmpfs  * filesystem must be mounted under /dev/shm.  */
end_comment

begin_function
specifier|static
name|void
name|setup_cvmx_shared
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|SHM_NAME
init|=
literal|"cvmx_shared"
decl_stmt|;
name|unsigned
name|long
name|shared_size
init|=
operator|&
name|__cvmx_shared_end
operator|-
operator|&
name|__cvmx_shared_start
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* If there isn't and shared data we can skip all this */
if|if
condition|(
name|shared_size
condition|)
block|{
name|char
name|shm_name
index|[
literal|30
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"CVMX_SHARED: %p-%p\n"
argument_list|,
operator|&
name|__cvmx_shared_start
argument_list|,
operator|&
name|__cvmx_shared_end
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__UCLIBC__
specifier|const
name|char
modifier|*
name|defaultdir
init|=
literal|"/dev/shm/"
decl_stmt|;
name|struct
name|statfs
name|f
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* The canonical place is /dev/shm. */
if|if
condition|(
name|statfs
argument_list|(
name|defaultdir
argument_list|,
operator|&
name|f
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|shm_name
argument_list|,
literal|"%s%s-%d"
argument_list|,
name|defaultdir
argument_list|,
name|SHM_NAME
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|perror
argument_list|(
literal|"/dev/shm is not mounted"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* shm_open(), shm_unlink() are not implemented in uClibc. Do the 	   same thing using open() and close() system calls.  */
name|fd
operator|=
name|open
argument_list|(
name|shm_name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Failed to open CVMX_SHARED(shm_name)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|shm_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|shm_name
argument_list|,
literal|"%s-%d"
argument_list|,
name|SHM_NAME
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Open a new shared memory region for use as CVMX_SHARED */
name|fd
operator|=
name|shm_open
argument_list|(
name|shm_name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Failed to setup CVMX_SHARED(shm_open)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
comment|/* We don't want the file on the filesystem. Immediately unlink it so             another application can create its own shared region */
name|shm_unlink
argument_list|(
name|shm_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Resize the region to match the size of CVMX_SHARED */
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|shared_size
argument_list|)
expr_stmt|;
comment|/* Map the region into some random location temporarily so we can             copy the shared data to it */
name|void
modifier|*
name|ptr
init|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|shared_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"Failed to setup CVMX_SHARED(mmap copy)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
comment|/* Copy CVMX_SHARED to the new shared region so we don't lose             initializers */
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|__cvmx_shared_start
argument_list|,
name|shared_size
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|ptr
argument_list|,
name|shared_size
argument_list|)
expr_stmt|;
comment|/* Remap the shared region to replace the old CVMX_SHARED region */
name|ptr
operator|=
name|mmap
argument_list|(
operator|&
name|__cvmx_shared_start
argument_list|,
name|shared_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
operator||
name|MAP_FIXED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"Failed to setup CVMX_SHARED(mmap final)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
comment|/* Once mappings are setup, the file handle isn't needed anymore */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Shutdown and free the shared CVMX_SHARED region setup by  * setup_cvmx_shared.  */
end_comment

begin_function
specifier|static
name|void
name|shutdown_cvmx_shared
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|shared_size
init|=
operator|&
name|__cvmx_shared_end
operator|-
operator|&
name|__cvmx_shared_start
decl_stmt|;
if|if
condition|(
name|shared_size
condition|)
name|munmap
argument_list|(
operator|&
name|__cvmx_shared_start
argument_list|,
name|shared_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Setup access to the CONFIG_CAVIUM_RESERVE32 memory section  * created by the kernel. This memory is used for shared  * hardware buffers with 32 bit userspace applications.  */
end_comment

begin_function
specifier|static
name|void
name|setup_reserve32
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|linux_mem32_min
operator|&&
name|linux_mem32_max
condition|)
block|{
name|int
name|region_size
init|=
name|linux_mem32_max
operator|-
name|linux_mem32_min
operator|+
literal|1
decl_stmt|;
name|int
name|mmap_flags
init|=
name|MAP_SHARED
decl_stmt|;
name|void
modifier|*
name|linux_mem32_base_ptr
init|=
name|NULL
decl_stmt|;
comment|/* Although not strictly necessary, we are going to mmap() the wired             TLB region so it is in the process page tables. These pages will             never fault in, but they will allow GDB to access the wired             region. We need the mappings to exactly match the wired TLB             entry. */
if|if
condition|(
name|linux_mem32_wired
condition|)
block|{
name|mmap_flags
operator||=
name|MAP_FIXED
expr_stmt|;
name|linux_mem32_base_ptr
operator|=
name|CASTPTR
argument_list|(
name|void
argument_list|,
operator|(
literal|1ull
operator|<<
literal|31
operator|)
operator|-
name|region_size
argument_list|)
expr_stmt|;
block|}
name|int
name|fd
init|=
name|open
argument_list|(
literal|"/dev/mem"
argument_list|,
name|O_RDWR
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ERROR opening /dev/mem"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|linux_mem32_base_ptr
operator|=
name|mmap64
argument_list|(
name|linux_mem32_base_ptr
argument_list|,
name|region_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|mmap_flags
argument_list|,
name|fd
argument_list|,
name|linux_mem32_min
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAP_FAILED
operator|==
name|linux_mem32_base_ptr
condition|)
block|{
name|perror
argument_list|(
literal|"Error mapping reserve32"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|linux_mem32_offset
operator|=
name|CAST64
argument_list|(
name|linux_mem32_base_ptr
argument_list|)
operator|-
name|linux_mem32_min
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Main entrypoint of the application. Here we setup shared  * memory and fork processes for each cpu. This simulates the  * normal simple executive environment of one process per  * cpu core.  *  * @param argc   Number of command line arguments  * @param argv   The command line arguments  * @return Return value for the process  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|CVMX_SHARED
specifier|static
name|cvmx_spinlock_t
name|mask_lock
init|=
name|CVMX_SPINLOCK_UNLOCKED_INITIALIZER
decl_stmt|;
name|CVMX_SHARED
specifier|static
name|int32_t
name|pending_fork
decl_stmt|;
name|unsigned
name|long
name|cpumask
decl_stmt|;
name|unsigned
name|long
name|cpu
decl_stmt|;
name|int
name|lastcpu
init|=
literal|0
decl_stmt|;
name|cvmx_sysinfo_linux_userspace_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|linux_mem32_min
condition|)
name|setup_reserve32
argument_list|()
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\nFailed to access 32bit shared memory region. Most likely the Kernel\n"
literal|"has not been configured for 32bit shared memory access. Check the\n"
literal|"kernel configuration.\n"
literal|"Aborting...\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|setup_cvmx_shared
argument_list|()
expr_stmt|;
name|cvmx_bootmem_init
argument_list|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|phy_mem_desc_ptr
argument_list|)
expr_stmt|;
comment|/* Check to make sure the Chip version matches the configured version */
name|octeon_model_version_check
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Get the list of logical cpus we should run on */
if|if
condition|(
name|sched_getaffinity
argument_list|(
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cpumask
argument_list|)
argument_list|,
operator|(
name|cpu_set_t
operator|*
operator|)
operator|&
name|cpumask
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"sched_getaffinity failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
name|cvmx_sysinfo_t
modifier|*
name|system_info
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|cvmx_atomic_set32
argument_list|(
operator|&
name|pending_fork
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
literal|16
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|cpumask
operator|&
operator|(
literal|1
operator|<<
name|cpu
operator|)
condition|)
block|{
comment|/* Turn off the bit for this CPU number. We've counted him */
name|cpumask
operator|^=
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
comment|/* If this is the last CPU to run on, use this process instead of forking another one */
if|if
condition|(
name|cpumask
operator|==
literal|0
condition|)
block|{
name|lastcpu
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Increment the number of CPUs running this app */
name|cvmx_atomic_add32
argument_list|(
operator|&
name|pending_fork
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Flush all IO streams before the fork. Otherwise any buffered                 data in the C library will be duplicated. This results in                 duplicate output from a single print */
name|fflush
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fork a process for the new CPU */
name|int
name|pid
init|=
name|fork
argument_list|()
decl_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"Fork failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Set affinity to lock me to the correct CPU */
name|cpumask
operator|=
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
if|if
condition|(
name|sched_setaffinity
argument_list|(
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cpumask
argument_list|)
argument_list|,
operator|(
name|cpu_set_t
operator|*
operator|)
operator|&
name|cpumask
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"sched_setaffinity failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|mask_lock
argument_list|)
expr_stmt|;
name|system_info
operator|->
name|core_mask
operator||=
literal|1
operator|<<
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|cvmx_atomic_add32
argument_list|(
operator|&
name|pending_fork
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_atomic_get32
argument_list|(
operator|&
name|pending_fork
argument_list|)
operator|==
literal|0
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Active coremask = 0x%x\n"
argument_list|,
name|system_info
operator|->
name|core_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastcpu
condition|)
name|system_info
operator|->
name|init_core
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|mask_lock
argument_list|)
expr_stmt|;
comment|/* Spinning waiting for forks to complete */
while|while
condition|(
name|cvmx_atomic_get32
argument_list|(
operator|&
name|pending_fork
argument_list|)
condition|)
block|{}
name|cvmx_coremask_barrier_sync
argument_list|(
name|system_info
operator|->
name|core_mask
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|sysmips
argument_list|(
name|MIPS_CAVIUM_XKPHYS_WRITE
argument_list|,
name|getpid
argument_list|()
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|int32_t
name|w
init|=
name|cvmx_atomic_fetch_and_add32
argument_list|(
operator|&
name|warn_count
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINVAL
case|:
name|perror
argument_list|(
literal|"sysmips(MIPS_CAVIUM_XKPHYS_WRITE) failed.\n"
literal|"  Did you configure your kernel with both:\n"
literal|"     CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS *and*\n"
literal|"     CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPERM
case|:
name|perror
argument_list|(
literal|"sysmips(MIPS_CAVIUM_XKPHYS_WRITE) failed.\n"
literal|"  Are you running as root?"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"sysmips(MIPS_CAVIUM_XKPHYS_WRITE) failed"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|int
name|result
init|=
name|appmain
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
comment|/* Wait for all forks to complete. This needs to be the core that started         all of the forks. It may not be the lowest numbered core! */
if|if
condition|(
name|cvmx_get_core_num
argument_list|()
operator|==
name|system_info
operator|->
name|init_core
condition|)
block|{
name|int
name|num_waits
decl_stmt|;
name|CVMX_POP
argument_list|(
name|num_waits
argument_list|,
name|system_info
operator|->
name|core_mask
argument_list|)
expr_stmt|;
name|num_waits
operator|--
expr_stmt|;
while|while
condition|(
name|num_waits
operator|--
condition|)
block|{
if|if
condition|(
name|wait
argument_list|(
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"CVMX: Wait for forked child failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|shutdown_cvmx_shared
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

