begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * services/cache/dns.c - Cache services for DNS using msg and rrset caches.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains the DNS cache.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_delegpt.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_nsec.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_comment
comment|/** store rrsets in the rrset cache.   * @param env: module environment with caches.  * @param rep: contains list of rrsets to store.  * @param now: current time.  * @param leeway: during prefetch how much leeway to update TTLs.  * 	This makes rrsets (other than type NS) timeout sooner so they get  * 	updated with a new full TTL.  * 	Type NS does not get this, because it must not be refreshed from the  * 	child domain, but keep counting down properly.  * @param pside: if from parentside discovered NS, so that its NS is okay  * 	in a prefetch situation to be updated (without becoming sticky).  * @param qrep: update rrsets here if cache is better  * @param region: for qrep allocs.  */
end_comment

begin_function
specifier|static
name|void
name|store_rrsets
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|time_t
name|now
parameter_list|,
name|time_t
name|leeway
parameter_list|,
name|int
name|pside
parameter_list|,
name|struct
name|reply_info
modifier|*
name|qrep
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* see if rrset already exists in cache, if not insert it. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|id
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|id
expr_stmt|;
comment|/* update ref if it was in the cache */
switch|switch
condition|(
name|rrset_cache_update
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
operator|&
name|rep
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|env
operator|->
name|alloc
argument_list|,
name|now
operator|+
operator|(
operator|(
name|ntohs
argument_list|(
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
operator|!
name|pside
operator|)
condition|?
literal|0
else|:
name|leeway
operator|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* ref unchanged, item inserted */
break|break;
case|case
literal|2
case|:
comment|/* ref updated, cache is superior */
if|if
condition|(
name|region
condition|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|ck
decl_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* if deleted rrset, do not copy it */
if|if
condition|(
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|id
operator|==
literal|0
condition|)
name|ck
operator|=
name|NULL
expr_stmt|;
else|else
name|ck
operator|=
name|packed_rrset_copy_region
argument_list|(
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|region
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ck
condition|)
block|{
comment|/* use cached copy if memory allows */
name|qrep
operator|->
name|rrsets
index|[
name|i
index|]
operator|=
name|ck
expr_stmt|;
block|}
block|}
comment|/* no break: also copy key item */
case|case
literal|1
case|:
comment|/* ref updated, item inserted */
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|=
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|dns_cache_store_msg
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|hashvalue_t
name|hash
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|time_t
name|leeway
parameter_list|,
name|int
name|pside
parameter_list|,
name|struct
name|reply_info
modifier|*
name|qrep
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|msgreply_entry
modifier|*
name|e
decl_stmt|;
name|time_t
name|ttl
init|=
name|rep
operator|->
name|ttl
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* store RRsets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|rep
operator|->
name|ref
index|[
name|i
index|]
operator|.
name|id
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|id
expr_stmt|;
block|}
comment|/* there was a reply_info_sortref(rep) here but it seems to be 	 * unnecessary, because the cache gets locked per rrset. */
name|reply_info_set_ttls
argument_list|(
name|rep
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
name|store_rrsets
argument_list|(
name|env
argument_list|,
name|rep
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
name|leeway
argument_list|,
name|pside
argument_list|,
name|qrep
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttl
operator|==
literal|0
condition|)
block|{
comment|/* we do not store the message, but we did store the RRs, 		 * which could be useful for delegation information */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"TTL 0: dropped msg from cache"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rep
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* store msg in the cache */
name|reply_info_sortref
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|=
name|query_info_entrysetup
argument_list|(
name|qinfo
argument_list|,
name|rep
argument_list|,
name|hash
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"store_msg: malloc failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|slabhash_insert
argument_list|(
name|env
operator|->
name|msg_cache
argument_list|,
name|hash
argument_list|,
operator|&
name|e
operator|->
name|entry
argument_list|,
name|rep
argument_list|,
name|env
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** find closest NS or DNAME and returns the rrset (locked) */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|find_closest_of_type
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|time_t
name|now
parameter_list|,
name|uint16_t
name|searchtype
parameter_list|,
name|int
name|stripfront
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
decl_stmt|;
name|uint8_t
name|lablen
decl_stmt|;
if|if
condition|(
name|stripfront
condition|)
block|{
comment|/* strip off so that DNAMEs have strict subdomain match */
name|lablen
operator|=
operator|*
name|qname
expr_stmt|;
name|qname
operator|+=
name|lablen
operator|+
literal|1
expr_stmt|;
name|qnamelen
operator|-=
name|lablen
operator|+
literal|1
expr_stmt|;
block|}
comment|/* snip off front part of qname until the type is found */
while|while
condition|(
name|qnamelen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rrset
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|,
name|searchtype
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|rrset
return|;
comment|/* snip off front label */
name|lablen
operator|=
operator|*
name|qname
expr_stmt|;
name|qname
operator|+=
name|lablen
operator|+
literal|1
expr_stmt|;
name|qnamelen
operator|-=
name|lablen
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** add addr to additional section */
end_comment

begin_function
specifier|static
name|void
name|addr_to_additional
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
if|if
condition|(
operator|(
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|msg
operator|->
name|rep
operator|->
name|rrset_count
index|]
operator|=
name|packed_rrset_copy_region
argument_list|(
name|rrset
argument_list|,
name|region
argument_list|,
name|now
argument_list|)
operator|)
condition|)
block|{
name|msg
operator|->
name|rep
operator|->
name|ar_numrrsets
operator|++
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** lookup message in message cache */
end_comment

begin_function
specifier|static
name|struct
name|msgreply_entry
modifier|*
name|msg_cache_lookup
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|time_t
name|now
parameter_list|,
name|int
name|wr
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|query_info
name|k
decl_stmt|;
name|hashvalue_t
name|h
decl_stmt|;
name|k
operator|.
name|qname
operator|=
name|qname
expr_stmt|;
name|k
operator|.
name|qname_len
operator|=
name|qnamelen
expr_stmt|;
name|k
operator|.
name|qtype
operator|=
name|qtype
expr_stmt|;
name|k
operator|.
name|qclass
operator|=
name|qclass
expr_stmt|;
name|h
operator|=
name|query_info_hash
argument_list|(
operator|&
name|k
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|e
operator|=
name|slabhash_lookup
argument_list|(
name|env
operator|->
name|msg_cache
argument_list|,
name|h
argument_list|,
operator|&
name|k
argument_list|,
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|now
operator|>
operator|(
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|ttl
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
expr|struct
name|msgreply_entry
operator|*
operator|)
name|e
operator|->
name|key
return|;
block|}
end_function

begin_comment
comment|/** find and add A and AAAA records for nameservers in delegpt */
end_comment

begin_function
specifier|static
name|int
name|find_add_addrs
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|dns_msg
modifier|*
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
name|struct
name|msgreply_entry
modifier|*
name|neg
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|akey
decl_stmt|;
for|for
control|(
name|ns
operator|=
name|dp
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
name|akey
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|akey
condition|)
block|{
if|if
condition|(
operator|!
name|delegpt_add_rrset_A
argument_list|(
name|dp
argument_list|,
name|region
argument_list|,
name|akey
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|msg
condition|)
name|addr_to_additional
argument_list|(
name|akey
argument_list|,
name|region
argument_list|,
operator|*
name|msg
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* BIT_CD on false because delegpt lookup does 			 * not use dns64 translation */
name|neg
operator|=
name|msg_cache_lookup
argument_list|(
name|env
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|delegpt_add_neg_msg
argument_list|(
name|dp
argument_list|,
name|neg
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|neg
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
name|akey
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|akey
condition|)
block|{
if|if
condition|(
operator|!
name|delegpt_add_rrset_AAAA
argument_list|(
name|dp
argument_list|,
name|region
argument_list|,
name|akey
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|msg
condition|)
name|addr_to_additional
argument_list|(
name|akey
argument_list|,
name|region
argument_list|,
operator|*
name|msg
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* BIT_CD on false because delegpt lookup does 			 * not use dns64 translation */
name|neg
operator|=
name|msg_cache_lookup
argument_list|(
name|env
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|delegpt_add_neg_msg
argument_list|(
name|dp
argument_list|,
name|neg
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|neg
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** find and add A and AAAA records for missing nameservers in delegpt */
end_comment

begin_function
name|int
name|cache_fill_missing
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|delegpt_ns
modifier|*
name|ns
decl_stmt|;
name|struct
name|msgreply_entry
modifier|*
name|neg
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|akey
decl_stmt|;
name|time_t
name|now
init|=
operator|*
name|env
operator|->
name|now
decl_stmt|;
for|for
control|(
name|ns
operator|=
name|dp
operator|->
name|nslist
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
name|akey
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|akey
condition|)
block|{
if|if
condition|(
operator|!
name|delegpt_add_rrset_A
argument_list|(
name|dp
argument_list|,
name|region
argument_list|,
name|akey
argument_list|,
name|ns
operator|->
name|lame
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"found in cache"
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* BIT_CD on false because delegpt lookup does 			 * not use dns64 translation */
name|neg
operator|=
name|msg_cache_lookup
argument_list|(
name|env
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|delegpt_add_neg_msg
argument_list|(
name|dp
argument_list|,
name|neg
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|neg
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
name|akey
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|akey
condition|)
block|{
if|if
condition|(
operator|!
name|delegpt_add_rrset_AAAA
argument_list|(
name|dp
argument_list|,
name|region
argument_list|,
name|akey
argument_list|,
name|ns
operator|->
name|lame
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"found in cache"
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|akey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* BIT_CD on false because delegpt lookup does 			 * not use dns64 translation */
name|neg
operator|=
name|msg_cache_lookup
argument_list|(
name|env
argument_list|,
name|ns
operator|->
name|name
argument_list|,
name|ns
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|delegpt_add_neg_msg
argument_list|(
name|dp
argument_list|,
name|neg
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|neg
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** find and add DS or NSEC to delegation msg */
end_comment

begin_function
specifier|static
name|void
name|find_add_ds
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
comment|/* Lookup the DS or NSEC at the delegation point. */
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
init|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|msg
operator|->
name|qinfo
operator|.
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rrset
condition|)
block|{
comment|/* NOTE: this won't work for alternate NSEC schemes  		 *	(opt-in, NSEC3) */
name|rrset
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_NSEC
argument_list|,
name|msg
operator|->
name|qinfo
operator|.
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Note: the PACKED_RRSET_NSEC_AT_APEX flag is not used. 		 * since this is a referral, we need the NSEC at the parent 		 * side of the zone cut, not the NSEC at apex side. */
if|if
condition|(
name|rrset
operator|&&
name|nsec_has_type
argument_list|(
name|rrset
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|rrset
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|rrset
operator|=
name|NULL
expr_stmt|;
comment|/* discard wrong NSEC */
block|}
block|}
if|if
condition|(
name|rrset
condition|)
block|{
comment|/* add it to auth section. This is the second rrset. */
if|if
condition|(
operator|(
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|msg
operator|->
name|rep
operator|->
name|rrset_count
index|]
operator|=
name|packed_rrset_copy_region
argument_list|(
name|rrset
argument_list|,
name|region
argument_list|,
name|now
argument_list|)
operator|)
condition|)
block|{
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|++
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|++
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|rrset
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|dns_msg
modifier|*
name|dns_msg_create
parameter_list|(
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|size_t
name|capacity
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
init|=
operator|(
expr|struct
name|dns_msg
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns_msg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
return|return
name|NULL
return|;
name|msg
operator|->
name|qinfo
operator|.
name|qname
operator|=
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|->
name|qinfo
operator|.
name|qname
condition|)
return|return
name|NULL
return|;
name|msg
operator|->
name|qinfo
operator|.
name|qname_len
operator|=
name|qnamelen
expr_stmt|;
name|msg
operator|->
name|qinfo
operator|.
name|qtype
operator|=
name|qtype
expr_stmt|;
name|msg
operator|->
name|qinfo
operator|.
name|qclass
operator|=
name|qclass
expr_stmt|;
comment|/* non-packed reply_info, because it needs to grow the array */
name|msg
operator|->
name|rep
operator|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reply_info
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|->
name|rep
condition|)
return|return
name|NULL
return|;
name|msg
operator|->
name|rep
operator|->
name|flags
operator|=
name|BIT_QR
expr_stmt|;
comment|/* with QR, no AA */
name|msg
operator|->
name|rep
operator|->
name|qdcount
operator|=
literal|1
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrsets
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
name|capacity
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|->
name|rep
operator|->
name|rrsets
condition|)
return|return
name|NULL
return|;
return|return
name|msg
return|;
block|}
end_function

begin_function
name|int
name|dns_msg_authadd
parameter_list|(
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|++
index|]
operator|=
name|packed_rrset_copy_region
argument_list|(
name|rrset
argument_list|,
name|region
argument_list|,
name|now
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|delegpt
modifier|*
name|dns_cache_find_delegation
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|dns_msg
modifier|*
modifier|*
name|msg
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
comment|/* try to find closest NS rrset */
name|struct
name|ub_packed_rrset_key
modifier|*
name|nskey
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|nsdata
decl_stmt|;
name|struct
name|delegpt
modifier|*
name|dp
decl_stmt|;
name|nskey
operator|=
name|find_closest_of_type
argument_list|(
name|env
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|,
name|qclass
argument_list|,
name|now
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nskey
condition|)
comment|/* hope the caller has hints to prime or something */
return|return
name|NULL
return|;
name|nsdata
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|nskey
operator|->
name|entry
operator|.
name|data
expr_stmt|;
comment|/* got the NS key, create delegation point */
name|dp
operator|=
name|delegpt_create
argument_list|(
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
operator|||
operator|!
name|delegpt_set_name
argument_list|(
name|dp
argument_list|,
name|region
argument_list|,
name|nskey
operator|->
name|rk
operator|.
name|dname
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|nskey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"find_delegation: out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* create referral message */
if|if
condition|(
name|msg
condition|)
block|{
comment|/* allocate the array to as much as we could need: 		 *	NS rrset + DS/NSEC rrset + 		 *	A rrset for every NS RR 		 *	AAAA rrset for every NS RR 		 */
operator|*
name|msg
operator|=
name|dns_msg_create
argument_list|(
name|qname
argument_list|,
name|qnamelen
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|region
argument_list|,
literal|2
operator|+
name|nsdata
operator|->
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|msg
operator|||
operator|!
name|dns_msg_authadd
argument_list|(
operator|*
name|msg
argument_list|,
name|region
argument_list|,
name|nskey
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|nskey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"find_delegation: out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|!
name|delegpt_rrset_add_ns
argument_list|(
name|dp
argument_list|,
name|region
argument_list|,
name|nskey
argument_list|,
literal|0
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"find_delegation: addns out of memory"
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|nskey
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* first unlock before next lookup*/
comment|/* find and add DS/NSEC (if any) */
if|if
condition|(
name|msg
condition|)
name|find_add_ds
argument_list|(
name|env
argument_list|,
name|region
argument_list|,
operator|*
name|msg
argument_list|,
name|dp
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|/* find and add A entries */
if|if
condition|(
operator|!
name|find_add_addrs
argument_list|(
name|env
argument_list|,
name|qclass
argument_list|,
name|region
argument_list|,
name|dp
argument_list|,
name|now
argument_list|,
name|msg
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"find_delegation: addrs out of memory"
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_comment
comment|/** allocate dns_msg from query_info and reply_info */
end_comment

begin_function
specifier|static
name|struct
name|dns_msg
modifier|*
name|gen_dns_msg
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|query_info
modifier|*
name|q
parameter_list|,
name|size_t
name|num
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
init|=
operator|(
expr|struct
name|dns_msg
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns_msg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|->
name|qinfo
argument_list|,
name|q
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|query_info
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|->
name|qinfo
operator|.
name|qname
operator|=
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|q
operator|->
name|qname
argument_list|,
name|q
operator|->
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|->
name|qinfo
operator|.
name|qname
condition|)
return|return
name|NULL
return|;
comment|/* allocate replyinfo struct and rrset key array separately */
name|msg
operator|->
name|rep
operator|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reply_info
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|->
name|rep
condition|)
return|return
name|NULL
return|;
name|msg
operator|->
name|rep
operator|->
name|rrsets
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|->
name|rep
operator|->
name|rrsets
condition|)
return|return
name|NULL
return|;
return|return
name|msg
return|;
block|}
end_function

begin_comment
comment|/** generate dns_msg from cached message */
end_comment

begin_function
specifier|static
name|struct
name|dns_msg
modifier|*
name|tomsg
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|query_info
modifier|*
name|q
parameter_list|,
name|struct
name|reply_info
modifier|*
name|r
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|regional
modifier|*
name|scratch
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|now
operator|>
name|r
operator|->
name|ttl
condition|)
return|return
name|NULL
return|;
name|msg
operator|=
name|gen_dns_msg
argument_list|(
name|region
argument_list|,
name|q
argument_list|,
name|r
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
return|return
name|NULL
return|;
name|msg
operator|->
name|rep
operator|->
name|flags
operator|=
name|r
operator|->
name|flags
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|qdcount
operator|=
name|r
operator|->
name|qdcount
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ttl
operator|=
name|r
operator|->
name|ttl
operator|-
name|now
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|prefetch_ttl
operator|>
name|now
condition|)
name|msg
operator|->
name|rep
operator|->
name|prefetch_ttl
operator|=
name|r
operator|->
name|prefetch_ttl
operator|-
name|now
expr_stmt|;
else|else
name|msg
operator|->
name|rep
operator|->
name|prefetch_ttl
operator|=
name|PREFETCH_TTL_CALC
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|security
operator|=
name|r
operator|->
name|security
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|=
name|r
operator|->
name|an_numrrsets
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|=
name|r
operator|->
name|ns_numrrsets
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ar_numrrsets
operator|=
name|r
operator|->
name|ar_numrrsets
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|=
name|r
operator|->
name|rrset_count
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|authoritative
operator|=
name|r
operator|->
name|authoritative
expr_stmt|;
if|if
condition|(
operator|!
name|rrset_array_lock
argument_list|(
name|r
operator|->
name|ref
argument_list|,
name|r
operator|->
name|rrset_count
argument_list|,
name|now
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|r
operator|->
name|an_numrrsets
operator|>
literal|0
operator|&&
operator|(
name|r
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|type
operator|==
name|htons
argument_list|(
name|LDNS_RR_TYPE_CNAME
argument_list|)
operator|||
name|r
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|type
operator|==
name|htons
argument_list|(
name|LDNS_RR_TYPE_DNAME
argument_list|)
operator|)
operator|&&
operator|!
name|reply_check_cname_chain
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* cname chain is now invalid, reconstruct msg */
name|rrset_array_unlock
argument_list|(
name|r
operator|->
name|ref
argument_list|,
name|r
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|r
operator|->
name|security
operator|==
name|sec_status_secure
operator|&&
operator|!
name|reply_all_rrsets_secure
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* message rrsets have changed status, revalidate */
name|rrset_array_unlock
argument_list|(
name|r
operator|->
name|ref
argument_list|,
name|r
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|=
name|packed_rrset_copy_region
argument_list|(
name|r
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
name|region
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
condition|)
block|{
name|rrset_array_unlock
argument_list|(
name|r
operator|->
name|ref
argument_list|,
name|r
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|rrset_array_unlock_touch
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|scratch
argument_list|,
name|r
operator|->
name|ref
argument_list|,
name|r
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

begin_comment
comment|/** synthesize RRset-only response from cached RRset item */
end_comment

begin_function
specifier|static
name|struct
name|dns_msg
modifier|*
name|rrset_msg
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|query_info
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|now
operator|>
name|d
operator|->
name|ttl
condition|)
return|return
name|NULL
return|;
name|msg
operator|=
name|gen_dns_msg
argument_list|(
name|region
argument_list|,
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* only the CNAME (or other) RRset */
if|if
condition|(
operator|!
name|msg
condition|)
return|return
name|NULL
return|;
name|msg
operator|->
name|rep
operator|->
name|flags
operator|=
name|BIT_QR
expr_stmt|;
comment|/* reply, no AA, no error */
name|msg
operator|->
name|rep
operator|->
name|authoritative
operator|=
literal|0
expr_stmt|;
comment|/* reply stored in cache can't be authoritative */
name|msg
operator|->
name|rep
operator|->
name|qdcount
operator|=
literal|1
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ttl
operator|=
name|d
operator|->
name|ttl
operator|-
name|now
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|prefetch_ttl
operator|=
name|PREFETCH_TTL_CALC
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|security
operator|=
name|sec_status_unchecked
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|=
literal|1
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|=
literal|0
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ar_numrrsets
operator|=
literal|0
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|=
literal|1
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|=
name|packed_rrset_copy_region
argument_list|(
name|rrset
argument_list|,
name|region
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
condition|)
comment|/* copy CNAME */
return|return
name|NULL
return|;
return|return
name|msg
return|;
block|}
end_function

begin_comment
comment|/** synthesize DNAME+CNAME response from cached DNAME item */
end_comment

begin_function
specifier|static
name|struct
name|dns_msg
modifier|*
name|synth_dname_msg
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|query_info
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|ck
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|newd
decl_stmt|,
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|newname
decl_stmt|,
modifier|*
name|dtarg
init|=
name|NULL
decl_stmt|;
name|size_t
name|newlen
decl_stmt|,
name|dtarglen
decl_stmt|;
if|if
condition|(
name|now
operator|>
name|d
operator|->
name|ttl
condition|)
return|return
name|NULL
return|;
comment|/* only allow validated (with DNSSEC) DNAMEs used from cache  	 * for insecure DNAMEs, query again. */
if|if
condition|(
name|d
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
return|return
name|NULL
return|;
name|msg
operator|=
name|gen_dns_msg
argument_list|(
name|region
argument_list|,
name|q
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* DNAME + CNAME RRset */
if|if
condition|(
operator|!
name|msg
condition|)
return|return
name|NULL
return|;
name|msg
operator|->
name|rep
operator|->
name|flags
operator|=
name|BIT_QR
expr_stmt|;
comment|/* reply, no AA, no error */
name|msg
operator|->
name|rep
operator|->
name|authoritative
operator|=
literal|0
expr_stmt|;
comment|/* reply stored in cache can't be authoritative */
name|msg
operator|->
name|rep
operator|->
name|qdcount
operator|=
literal|1
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ttl
operator|=
name|d
operator|->
name|ttl
operator|-
name|now
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|prefetch_ttl
operator|=
name|PREFETCH_TTL_CALC
argument_list|(
name|msg
operator|->
name|rep
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|security
operator|=
name|sec_status_unchecked
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|=
literal|1
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ns_numrrsets
operator|=
literal|0
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ar_numrrsets
operator|=
literal|0
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|=
literal|1
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|=
name|packed_rrset_copy_region
argument_list|(
name|rrset
argument_list|,
name|region
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
condition|)
comment|/* copy DNAME */
return|return
name|NULL
return|;
comment|/* synth CNAME rrset */
name|get_cname_target
argument_list|(
name|rrset
argument_list|,
operator|&
name|dtarg
argument_list|,
operator|&
name|dtarglen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtarg
condition|)
return|return
name|NULL
return|;
name|newlen
operator|=
name|q
operator|->
name|qname_len
operator|+
name|dtarglen
operator|-
name|rrset
operator|->
name|rk
operator|.
name|dname_len
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|LDNS_MAX_DOMAINLEN
condition|)
block|{
name|msg
operator|->
name|rep
operator|->
name|flags
operator||=
name|LDNS_RCODE_YXDOMAIN
expr_stmt|;
return|return
name|msg
return|;
block|}
name|newname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newname
condition|)
return|return
name|NULL
return|;
comment|/* new name is concatenation of qname front (without DNAME owner) 	 * and DNAME target name */
name|memcpy
argument_list|(
name|newname
argument_list|,
name|q
operator|->
name|qname
argument_list|,
name|q
operator|->
name|qname_len
operator|-
name|rrset
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|newname
operator|+
operator|(
name|q
operator|->
name|qname_len
operator|-
name|rrset
operator|->
name|rk
operator|.
name|dname_len
operator|)
argument_list|,
name|dtarg
argument_list|,
name|dtarglen
argument_list|)
expr_stmt|;
comment|/* create rest of CNAME rrset */
name|ck
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ck
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
operator|&
name|ck
operator|->
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ck
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
literal|1
index|]
operator|=
name|ck
expr_stmt|;
name|ck
operator|->
name|entry
operator|.
name|key
operator|=
name|ck
expr_stmt|;
name|ck
operator|->
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|LDNS_RR_TYPE_CNAME
argument_list|)
expr_stmt|;
name|ck
operator|->
name|rk
operator|.
name|rrset_class
operator|=
name|rrset
operator|->
name|rk
operator|.
name|rrset_class
expr_stmt|;
name|ck
operator|->
name|rk
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|ck
operator|->
name|rk
operator|.
name|dname
operator|=
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|q
operator|->
name|qname
argument_list|,
name|q
operator|->
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ck
operator|->
name|rk
operator|.
name|dname
condition|)
return|return
name|NULL
return|;
name|ck
operator|->
name|rk
operator|.
name|dname_len
operator|=
name|q
operator|->
name|qname_len
expr_stmt|;
name|ck
operator|->
name|entry
operator|.
name|hash
operator|=
name|rrset_key_hash
argument_list|(
operator|&
name|ck
operator|->
name|rk
argument_list|)
expr_stmt|;
name|newd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|packed_rrset_data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newd
condition|)
return|return
name|NULL
return|;
name|ck
operator|->
name|entry
operator|.
name|data
operator|=
name|newd
expr_stmt|;
name|newd
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
comment|/* 0 for synthesized CNAME TTL */
name|newd
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|newd
operator|->
name|rrsig_count
operator|=
literal|0
expr_stmt|;
name|newd
operator|->
name|trust
operator|=
name|rrset_trust_ans_noAA
expr_stmt|;
name|newd
operator|->
name|rr_len
operator|=
operator|(
name|size_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|newd
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|packed_rrset_data
argument_list|)
operator|)
expr_stmt|;
name|newd
operator|->
name|rr_len
index|[
literal|0
index|]
operator|=
name|newlen
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|packed_rrset_ptr_fixup
argument_list|(
name|newd
argument_list|)
expr_stmt|;
name|newd
operator|->
name|rr_ttl
index|[
literal|0
index|]
operator|=
name|newd
operator|->
name|ttl
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|ttl
operator|=
name|newd
operator|->
name|ttl
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|prefetch_ttl
operator|=
name|PREFETCH_TTL_CALC
argument_list|(
name|newd
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|sldns_write_uint16
argument_list|(
name|newd
operator|->
name|rr_data
index|[
literal|0
index|]
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|newd
operator|->
name|rr_data
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|newname
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|an_numrrsets
operator|++
expr_stmt|;
name|msg
operator|->
name|rep
operator|->
name|rrset_count
operator|++
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

begin_function
name|struct
name|dns_msg
modifier|*
name|dns_cache_lookup
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|regional
modifier|*
name|scratch
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|query_info
name|k
decl_stmt|;
name|hashvalue_t
name|h
decl_stmt|;
name|time_t
name|now
init|=
operator|*
name|env
operator|->
name|now
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
decl_stmt|;
comment|/* lookup first, this has both NXdomains and ANSWER responses */
name|k
operator|.
name|qname
operator|=
name|qname
expr_stmt|;
name|k
operator|.
name|qname_len
operator|=
name|qnamelen
expr_stmt|;
name|k
operator|.
name|qtype
operator|=
name|qtype
expr_stmt|;
name|k
operator|.
name|qclass
operator|=
name|qclass
expr_stmt|;
name|h
operator|=
name|query_info_hash
argument_list|(
operator|&
name|k
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|e
operator|=
name|slabhash_lookup
argument_list|(
name|env
operator|->
name|msg_cache
argument_list|,
name|h
argument_list|,
operator|&
name|k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|struct
name|msgreply_entry
modifier|*
name|key
init|=
operator|(
expr|struct
name|msgreply_entry
operator|*
operator|)
name|e
operator|->
name|key
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|data
init|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
name|struct
name|dns_msg
modifier|*
name|msg
init|=
name|tomsg
argument_list|(
name|env
argument_list|,
operator|&
name|key
operator|->
name|key
argument_list|,
name|data
argument_list|,
name|region
argument_list|,
name|now
argument_list|,
name|scratch
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
comment|/* could be msg==NULL; due to TTL or not all rrsets available */
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* see if a DNAME exists. Checked for first, to enforce that DNAMEs 	 * are more important, the CNAME is resynthesized and thus  	 * consistent with the DNAME */
if|if
condition|(
operator|(
name|rrset
operator|=
name|find_closest_of_type
argument_list|(
name|env
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|,
name|qclass
argument_list|,
name|now
argument_list|,
name|LDNS_RR_TYPE_DNAME
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
comment|/* synthesize a DNAME+CNAME message based on this */
name|struct
name|dns_msg
modifier|*
name|msg
init|=
name|synth_dname_msg
argument_list|(
name|rrset
argument_list|,
name|region
argument_list|,
name|now
argument_list|,
operator|&
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|rrset
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|rrset
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* see if we have CNAME for this domain, 	 * but not for DS records (which are part of the parent) */
if|if
condition|(
name|qtype
operator|!=
name|LDNS_RR_TYPE_DS
operator|&&
operator|(
name|rrset
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|,
name|LDNS_RR_TYPE_CNAME
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
init|=
name|rrset_msg
argument_list|(
name|rrset
argument_list|,
name|region
argument_list|,
name|now
argument_list|,
operator|&
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|rrset
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|rrset
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* construct DS, DNSKEY, DLV messages from rrset cache. */
if|if
condition|(
operator|(
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|||
name|qtype
operator|==
name|LDNS_RR_TYPE_DNSKEY
operator|||
name|qtype
operator|==
name|LDNS_RR_TYPE_DLV
operator|)
operator|&&
operator|(
name|rrset
operator|=
name|rrset_cache_lookup
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
literal|0
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* if the rrset is from the additional section, and the 		 * signatures have fallen off, then do not synthesize a msg 		 * instead, allow a full query for signed results to happen. 		 * Forego all rrset data from additional section, because 		 * some signatures may not be present and cause validation 		 * failure. 		 */
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|trust
operator|!=
name|rrset_trust_add_noAA
operator|&&
name|d
operator|->
name|trust
operator|!=
name|rrset_trust_add_AA
operator|&&
operator|(
name|qtype
operator|==
name|LDNS_RR_TYPE_DS
operator|||
operator|(
name|d
operator|->
name|trust
operator|!=
name|rrset_trust_auth_noAA
operator|&&
name|d
operator|->
name|trust
operator|!=
name|rrset_trust_auth_AA
operator|)
operator|)
condition|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
init|=
name|rrset_msg
argument_list|(
name|rrset
argument_list|,
name|region
argument_list|,
name|now
argument_list|,
operator|&
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|rrset
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|rrset
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* stop downwards cache search on NXDOMAIN. 	 * Empty nonterminals are NOERROR, so an NXDOMAIN for foo 	 * means bla.foo also does not exist.  The DNSSEC proofs are 	 * the same.  We search upwards for NXDOMAINs. */
if|if
condition|(
name|env
operator|->
name|cfg
operator|->
name|harden_below_nxdomain
condition|)
while|while
condition|(
operator|!
name|dname_is_root
argument_list|(
name|k
operator|.
name|qname
argument_list|)
condition|)
block|{
name|dname_remove_label
argument_list|(
operator|&
name|k
operator|.
name|qname
argument_list|,
operator|&
name|k
operator|.
name|qname_len
argument_list|)
expr_stmt|;
name|h
operator|=
name|query_info_hash
argument_list|(
operator|&
name|k
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|e
operator|=
name|slabhash_lookup
argument_list|(
name|env
operator|->
name|msg_cache
argument_list|,
name|h
argument_list|,
operator|&
name|k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|struct
name|reply_info
modifier|*
name|data
init|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|FLAGS_GET_RCODE
argument_list|(
name|data
operator|->
name|flags
argument_list|)
operator|==
name|LDNS_RCODE_NXDOMAIN
operator|&&
name|data
operator|->
name|security
operator|==
name|sec_status_secure
operator|&&
operator|(
name|msg
operator|=
name|tomsg
argument_list|(
name|env
argument_list|,
operator|&
name|k
argument_list|,
name|data
argument_list|,
name|region
argument_list|,
name|now
argument_list|,
name|scratch
argument_list|)
operator|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
name|msg
operator|->
name|qinfo
operator|.
name|qname
operator|=
name|qname
expr_stmt|;
name|msg
operator|->
name|qinfo
operator|.
name|qname_len
operator|=
name|qnamelen
expr_stmt|;
comment|/* check that DNSSEC really works out */
name|msg
operator|->
name|rep
operator|->
name|security
operator|=
name|sec_status_unchecked
expr_stmt|;
return|return
name|msg
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|dns_cache_store
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|query_info
modifier|*
name|msgqinf
parameter_list|,
name|struct
name|reply_info
modifier|*
name|msgrep
parameter_list|,
name|int
name|is_referral
parameter_list|,
name|time_t
name|leeway
parameter_list|,
name|int
name|pside
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|struct
name|reply_info
modifier|*
name|rep
init|=
name|NULL
decl_stmt|;
comment|/* alloc, malloc properly (not in region, like msg is) */
name|rep
operator|=
name|reply_info_copy
argument_list|(
name|msgrep
argument_list|,
name|env
operator|->
name|alloc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rep
condition|)
return|return
literal|0
return|;
comment|/* ttl must be relative ;i.e. 0..86400 not  time(0)+86400.  	 * the env->now is added to message and RRsets in this routine. */
comment|/* the leeway is used to invalidate other rrsets earlier */
if|if
condition|(
name|is_referral
condition|)
block|{
comment|/* store rrsets */
name|struct
name|rrset_ref
name|ref
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|packed_rrset_ttl_add
argument_list|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|)
expr_stmt|;
name|ref
operator|.
name|key
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|ref
operator|.
name|id
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|id
expr_stmt|;
comment|/*ignore ret: it was in the cache, ref updated */
comment|/* no leeway for typeNS */
operator|(
name|void
operator|)
name|rrset_cache_update
argument_list|(
name|env
operator|->
name|rrset_cache
argument_list|,
operator|&
name|ref
argument_list|,
name|env
operator|->
name|alloc
argument_list|,
operator|*
name|env
operator|->
name|now
operator|+
operator|(
operator|(
name|ntohs
argument_list|(
name|ref
operator|.
name|key
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
operator|&&
operator|!
name|pside
operator|)
condition|?
literal|0
else|:
name|leeway
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rep
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* store msg, and rrsets */
name|struct
name|query_info
name|qinf
decl_stmt|;
name|hashvalue_t
name|h
decl_stmt|;
name|qinf
operator|=
operator|*
name|msgqinf
expr_stmt|;
name|qinf
operator|.
name|qname
operator|=
name|memdup
argument_list|(
name|msgqinf
operator|->
name|qname
argument_list|,
name|msgqinf
operator|->
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qinf
operator|.
name|qname
condition|)
block|{
name|reply_info_parsedelete
argument_list|(
name|rep
argument_list|,
name|env
operator|->
name|alloc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* fixup flags to be sensible for a reply based on the cache */
comment|/* this module means that RA is available. It is an answer QR.  		 * Not AA from cache. Not CD in cache (depends on client bit). */
name|rep
operator|->
name|flags
operator||=
operator|(
name|BIT_RA
operator||
name|BIT_QR
operator|)
expr_stmt|;
name|rep
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BIT_AA
operator||
name|BIT_CD
operator|)
expr_stmt|;
name|h
operator|=
name|query_info_hash
argument_list|(
operator|&
name|qinf
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dns_cache_store_msg
argument_list|(
name|env
argument_list|,
operator|&
name|qinf
argument_list|,
name|h
argument_list|,
name|rep
argument_list|,
name|leeway
argument_list|,
name|pside
argument_list|,
name|msgrep
argument_list|,
name|region
argument_list|)
expr_stmt|;
comment|/* qname is used inside query_info_entrysetup, and set to  		 * NULL. If it has not been used, free it. free(0) is safe. */
name|free
argument_list|(
name|qinf
operator|.
name|qname
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|dns_cache_prefetch_adjust
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|time_t
name|adjust
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|struct
name|msgreply_entry
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|msg_cache_lookup
argument_list|(
name|env
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|flags
argument_list|,
operator|*
name|env
operator|->
name|now
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|struct
name|reply_info
modifier|*
name|rep
init|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|msg
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
name|rep
operator|->
name|prefetch_ttl
operator|+=
name|adjust
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|msg
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|msg
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

