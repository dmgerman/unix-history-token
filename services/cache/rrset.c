begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * services/cache/rrset.c - Resource record set cache.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains the rrset cache.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"sldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/slabhash.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/alloc.h"
end_include

begin_function
name|void
name|rrset_markdel
parameter_list|(
name|void
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|r
init|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|key
decl_stmt|;
name|r
operator|->
name|id
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|rrset_cache
modifier|*
name|rrset_cache_create
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
name|size_t
name|slabs
init|=
operator|(
name|cfg
condition|?
name|cfg
operator|->
name|rrset_cache_slabs
else|:
name|HASH_DEFAULT_SLABS
operator|)
decl_stmt|;
name|size_t
name|startarray
init|=
name|HASH_DEFAULT_STARTARRAY
decl_stmt|;
name|size_t
name|maxmem
init|=
operator|(
name|cfg
condition|?
name|cfg
operator|->
name|rrset_cache_size
else|:
name|HASH_DEFAULT_MAXMEM
operator|)
decl_stmt|;
name|struct
name|rrset_cache
modifier|*
name|r
init|=
operator|(
expr|struct
name|rrset_cache
operator|*
operator|)
name|slabhash_create
argument_list|(
name|slabs
argument_list|,
name|startarray
argument_list|,
name|maxmem
argument_list|,
name|ub_rrset_sizefunc
argument_list|,
name|ub_rrset_compare
argument_list|,
name|ub_rrset_key_delete
argument_list|,
name|rrset_data_delete
argument_list|,
name|alloc
argument_list|)
decl_stmt|;
name|slabhash_setmarkdel
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|,
operator|&
name|rrset_markdel
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|rrset_cache_delete
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
operator|!
name|r
condition|)
return|return;
name|slabhash_delete
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|)
expr_stmt|;
comment|/* slabhash delete also does free(r), since table is first in struct*/
block|}
end_function

begin_function
name|struct
name|rrset_cache
modifier|*
name|rrset_cache_adjust
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|r
operator|||
operator|!
name|cfg
operator|||
name|cfg
operator|->
name|rrset_cache_slabs
operator|!=
name|r
operator|->
name|table
operator|.
name|size
operator|||
name|cfg
operator|->
name|rrset_cache_size
operator|!=
name|slabhash_get_size
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|)
condition|)
block|{
name|rrset_cache_delete
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|rrset_cache_create
argument_list|(
name|cfg
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|rrset_cache_touch
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|key
parameter_list|,
name|hashvalue_t
name|hash
parameter_list|,
name|rrset_id_t
name|id
parameter_list|)
block|{
name|struct
name|lruhash
modifier|*
name|table
init|=
name|slabhash_gettable
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|,
name|hash
argument_list|)
decl_stmt|;
comment|/*  	 * This leads to locking problems, deadlocks, if the caller is  	 * holding any other rrset lock. 	 * Because a lookup through the hashtable does: 	 *	tablelock -> entrylock  (for that entry caller holds) 	 * And this would do 	 *	entrylock(already held) -> tablelock 	 * And if two threads do this, it results in deadlock. 	 * So, the caller must not hold entrylock. 	 */
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* we have locked the hash table, the item can still be deleted. 	 * because it could already have been reclaimed, but not yet set id=0. 	 * This is because some lruhash routines have lazy deletion. 	 * so, we must acquire a lock on the item to verify the id != 0. 	 * also, with hash not changed, we are using the right slab. 	 */
name|lock_rw_rdlock
argument_list|(
operator|&
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|id
operator|==
name|id
operator|&&
name|key
operator|->
name|entry
operator|.
name|hash
operator|==
name|hash
condition|)
block|{
name|lru_touch
argument_list|(
name|table
argument_list|,
operator|&
name|key
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** see if rrset needs to be updated in the cache */
end_comment

begin_function
specifier|static
name|int
name|need_to_update_rrset
parameter_list|(
name|void
modifier|*
name|nd
parameter_list|,
name|void
modifier|*
name|cd
parameter_list|,
name|time_t
name|timenow
parameter_list|,
name|int
name|equal
parameter_list|,
name|int
name|ns
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|newd
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|nd
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|cached
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|cd
decl_stmt|;
comment|/* 	o store if rrset has been validated  	 *  		everything better than bogus data  	 *  		secure is preferred */
if|if
condition|(
name|newd
operator|->
name|security
operator|==
name|sec_status_secure
operator|&&
name|cached
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|cached
operator|->
name|security
operator|==
name|sec_status_bogus
operator|&&
name|newd
operator|->
name|security
operator|!=
name|sec_status_bogus
operator|&&
operator|!
name|equal
condition|)
return|return
literal|1
return|;
comment|/*      o if current RRset is more trustworthy - insert it */
if|if
condition|(
name|newd
operator|->
name|trust
operator|>
name|cached
operator|->
name|trust
condition|)
block|{
comment|/* if the cached rrset is bogus, and this one equal, 		 * do not update the TTL - let it expire. */
if|if
condition|(
name|equal
operator|&&
name|cached
operator|->
name|ttl
operator|>=
name|timenow
operator|&&
name|cached
operator|->
name|security
operator|==
name|sec_status_bogus
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/*	o item in cache has expired */
if|if
condition|(
name|cached
operator|->
name|ttl
operator|<
name|timenow
condition|)
return|return
literal|1
return|;
comment|/*  o same trust, but different in data - insert it */
if|if
condition|(
name|newd
operator|->
name|trust
operator|==
name|cached
operator|->
name|trust
operator|&&
operator|!
name|equal
condition|)
block|{
comment|/* if this is type NS, do not 'stick' to owner that changes 		 * the NS RRset, but use the old TTL for the new data, and 		 * update to fetch the latest data. ttl is not expired, because 		 * that check was before this one. */
if|if
condition|(
name|ns
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|newd
operator|->
name|ttl
operator|=
name|cached
operator|->
name|ttl
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|newd
operator|->
name|count
operator|+
name|newd
operator|->
name|rrsig_count
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|newd
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|>
name|newd
operator|->
name|ttl
condition|)
name|newd
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|=
name|newd
operator|->
name|ttl
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Update RRSet special key ID */
end_comment

begin_function
specifier|static
name|void
name|rrset_update_id
parameter_list|(
name|struct
name|rrset_ref
modifier|*
name|ref
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|)
block|{
comment|/* this may clear the cache and invalidate lock below */
name|uint64_t
name|newid
init|=
name|alloc_get_id
argument_list|(
name|alloc
argument_list|)
decl_stmt|;
comment|/* obtain writelock */
name|lock_rw_wrlock
argument_list|(
operator|&
name|ref
operator|->
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* check if it was deleted in the meantime, if so, skip update */
if|if
condition|(
name|ref
operator|->
name|key
operator|->
name|id
operator|==
name|ref
operator|->
name|id
condition|)
block|{
name|ref
operator|->
name|key
operator|->
name|id
operator|=
name|newid
expr_stmt|;
name|ref
operator|->
name|id
operator|=
name|newid
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|ref
operator|->
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rrset_cache_update
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|struct
name|rrset_ref
modifier|*
name|ref
parameter_list|,
name|struct
name|alloc_cache
modifier|*
name|alloc
parameter_list|,
name|time_t
name|timenow
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
init|=
name|ref
operator|->
name|key
decl_stmt|;
name|hashvalue_t
name|h
init|=
name|k
operator|->
name|entry
operator|.
name|hash
decl_stmt|;
name|uint16_t
name|rrset_type
init|=
name|ntohs
argument_list|(
name|k
operator|->
name|rk
operator|.
name|type
argument_list|)
decl_stmt|;
name|int
name|equal
init|=
literal|0
decl_stmt|;
name|log_assert
argument_list|(
name|ref
operator|->
name|id
operator|!=
literal|0
operator|&&
name|k
operator|->
name|id
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|k
operator|->
name|rk
operator|.
name|dname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* looks up item with a readlock - no editing! */
if|if
condition|(
operator|(
name|e
operator|=
name|slabhash_lookup
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|,
name|h
argument_list|,
name|k
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* return id and key as they will be used in the cache 		 * since the lruhash_insert, if item already exists, deallocs 		 * the passed key in favor of the already stored key. 		 * because of the small gap (see below) this key ptr and id 		 * may prove later to be already deleted, which is no problem 		 * as it only makes a cache miss.  		 */
name|ref
operator|->
name|key
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|e
operator|->
name|key
expr_stmt|;
name|ref
operator|->
name|id
operator|=
name|ref
operator|->
name|key
operator|->
name|id
expr_stmt|;
name|equal
operator|=
name|rrsetdata_equal
argument_list|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
argument_list|,
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_to_update_rrset
argument_list|(
name|k
operator|->
name|entry
operator|.
name|data
argument_list|,
name|e
operator|->
name|data
argument_list|,
name|timenow
argument_list|,
name|equal
argument_list|,
operator|(
name|rrset_type
operator|==
name|LDNS_RR_TYPE_NS
operator|)
argument_list|)
condition|)
block|{
comment|/* cache is superior, return that value */
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ub_packed_rrset_parsedelete
argument_list|(
name|k
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Go on and insert the passed item. 		 * small gap here, where entry is not locked. 		 * possibly entry is updated with something else. 		 * we then overwrite that with our data. 		 * this is just too bad, its cache anyway. */
comment|/* use insert to update entry to manage lruhash 		 * cache size values nicely. */
block|}
name|log_assert
argument_list|(
name|ref
operator|->
name|key
operator|->
name|id
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|slabhash_insert
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|,
name|h
argument_list|,
operator|&
name|k
operator|->
name|entry
argument_list|,
name|k
operator|->
name|entry
operator|.
name|data
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
comment|/* For NSEC, NSEC3, DNAME, when rdata is updated, update  		 * the ID number so that proofs in message cache are  		 * invalidated */
if|if
condition|(
operator|(
name|rrset_type
operator|==
name|LDNS_RR_TYPE_NSEC
operator|||
name|rrset_type
operator|==
name|LDNS_RR_TYPE_NSEC3
operator|||
name|rrset_type
operator|==
name|LDNS_RR_TYPE_DNAME
operator|)
operator|&&
operator|!
name|equal
condition|)
block|{
name|rrset_update_id
argument_list|(
name|ref
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset_cache_lookup
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|time_t
name|timenow
parameter_list|,
name|int
name|wr
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|ub_packed_rrset_key
name|key
decl_stmt|;
name|key
operator|.
name|entry
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|entry
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|dname
operator|=
name|qname
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|dname_len
operator|=
name|qnamelen
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|qtype
argument_list|)
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|rrset_class
operator|=
name|htons
argument_list|(
name|qclass
argument_list|)
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|key
operator|.
name|entry
operator|.
name|hash
operator|=
name|rrset_key_hash
argument_list|(
operator|&
name|key
operator|.
name|rk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|slabhash_lookup
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|,
name|key
operator|.
name|entry
operator|.
name|hash
argument_list|,
operator|&
name|key
argument_list|,
name|wr
argument_list|)
operator|)
condition|)
block|{
comment|/* check TTL */
name|struct
name|packed_rrset_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|timenow
operator|>
name|data
operator|->
name|ttl
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* we're done */
return|return
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|e
operator|->
name|key
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|rrset_array_lock
parameter_list|(
name|struct
name|rrset_ref
modifier|*
name|ref
parameter_list|,
name|size_t
name|count
parameter_list|,
name|time_t
name|timenow
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|==
name|ref
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|key
condition|)
continue|continue;
comment|/* only lock items once */
name|lock_rw_rdlock
argument_list|(
operator|&
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|id
operator|||
name|timenow
operator|>
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
operator|(
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|entry
operator|.
name|data
operator|)
operator|)
operator|->
name|ttl
condition|)
block|{
comment|/* failure! rollback our readlocks */
name|rrset_array_unlock
argument_list|(
name|ref
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|rrset_array_unlock
parameter_list|(
name|struct
name|rrset_ref
modifier|*
name|ref
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|==
name|ref
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|key
condition|)
continue|continue;
comment|/* only unlock items once */
name|lock_rw_unlock
argument_list|(
operator|&
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rrset_array_unlock_touch
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|struct
name|regional
modifier|*
name|scratch
parameter_list|,
name|struct
name|rrset_ref
modifier|*
name|ref
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|hashvalue_t
modifier|*
name|h
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|>
name|RR_COUNT_MAX
operator|||
operator|!
operator|(
name|h
operator|=
operator|(
name|hashvalue_t
operator|*
operator|)
name|regional_alloc
argument_list|(
name|scratch
argument_list|,
sizeof|sizeof
argument_list|(
name|hashvalue_t
argument_list|)
operator|*
name|count
argument_list|)
operator|)
condition|)
block|{
name|log_warn
argument_list|(
literal|"rrset LRU: memory allocation failed"
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* store hash values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|h
index|[
name|i
index|]
operator|=
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|entry
operator|.
name|hash
expr_stmt|;
comment|/* unlock */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|==
name|ref
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|key
condition|)
continue|continue;
comment|/* only unlock items once */
name|lock_rw_unlock
argument_list|(
operator|&
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
condition|)
block|{
comment|/* LRU touch, with no rrset locks held */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|ref
index|[
name|i
index|]
operator|.
name|key
operator|==
name|ref
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|key
condition|)
continue|continue;
comment|/* only touch items once */
name|rrset_cache_touch
argument_list|(
name|r
argument_list|,
name|ref
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|h
index|[
name|i
index|]
argument_list|,
name|ref
index|[
name|i
index|]
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|rrset_update_sec_status
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|updata
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|cachedata
decl_stmt|;
comment|/* hash it again to make sure it has a hash */
name|rrset
operator|->
name|entry
operator|.
name|hash
operator|=
name|rrset_key_hash
argument_list|(
operator|&
name|rrset
operator|->
name|rk
argument_list|)
expr_stmt|;
name|e
operator|=
name|slabhash_lookup
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|,
name|rrset
operator|->
name|entry
operator|.
name|hash
argument_list|,
name|rrset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return;
comment|/* not in the cache anymore */
name|cachedata
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|rrsetdata_equal
argument_list|(
name|updata
argument_list|,
name|cachedata
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
comment|/* rrset has changed in the meantime */
block|}
comment|/* update the cached rrset */
if|if
condition|(
name|updata
operator|->
name|security
operator|>
name|cachedata
operator|->
name|security
condition|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|updata
operator|->
name|trust
operator|>
name|cachedata
operator|->
name|trust
condition|)
name|cachedata
operator|->
name|trust
operator|=
name|updata
operator|->
name|trust
expr_stmt|;
name|cachedata
operator|->
name|security
operator|=
name|updata
operator|->
name|security
expr_stmt|;
comment|/* for NS records only shorter TTLs, other types: update it */
if|if
condition|(
name|ntohs
argument_list|(
name|rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NS
operator|||
name|updata
operator|->
name|ttl
operator|+
name|now
operator|<
name|cachedata
operator|->
name|ttl
operator|||
name|cachedata
operator|->
name|ttl
operator|<
name|now
operator|||
name|updata
operator|->
name|security
operator|==
name|sec_status_bogus
condition|)
block|{
name|cachedata
operator|->
name|ttl
operator|=
name|updata
operator|->
name|ttl
operator|+
name|now
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cachedata
operator|->
name|count
operator|+
name|cachedata
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
name|cachedata
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|=
name|updata
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|+
name|now
expr_stmt|;
block|}
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rrset_check_sec_status
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|updata
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|cachedata
decl_stmt|;
comment|/* hash it again to make sure it has a hash */
name|rrset
operator|->
name|entry
operator|.
name|hash
operator|=
name|rrset_key_hash
argument_list|(
operator|&
name|rrset
operator|->
name|rk
argument_list|)
expr_stmt|;
name|e
operator|=
name|slabhash_lookup
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|,
name|rrset
operator|->
name|entry
operator|.
name|hash
argument_list|,
name|rrset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return;
comment|/* not in the cache anymore */
name|cachedata
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|e
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|now
operator|>
name|cachedata
operator|->
name|ttl
operator|||
operator|!
name|rrsetdata_equal
argument_list|(
name|updata
argument_list|,
name|cachedata
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
comment|/* expired, or rrset has changed in the meantime */
block|}
if|if
condition|(
name|cachedata
operator|->
name|security
operator|>
name|updata
operator|->
name|security
condition|)
block|{
name|updata
operator|->
name|security
operator|=
name|cachedata
operator|->
name|security
expr_stmt|;
if|if
condition|(
name|cachedata
operator|->
name|security
operator|==
name|sec_status_bogus
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|updata
operator|->
name|ttl
operator|=
name|cachedata
operator|->
name|ttl
operator|-
name|now
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cachedata
operator|->
name|count
operator|+
name|cachedata
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cachedata
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|<
name|now
condition|)
name|updata
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|updata
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|=
name|cachedata
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|-
name|now
expr_stmt|;
block|}
if|if
condition|(
name|cachedata
operator|->
name|trust
operator|>
name|updata
operator|->
name|trust
condition|)
name|updata
operator|->
name|trust
operator|=
name|cachedata
operator|->
name|trust
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rrset_cache_remove
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|r
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
name|key
decl_stmt|;
name|key
operator|.
name|entry
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|dname
operator|=
name|nm
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|dname_len
operator|=
name|nmlen
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|rrset_class
operator|=
name|htons
argument_list|(
name|dclass
argument_list|)
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|key
operator|.
name|rk
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|key
operator|.
name|entry
operator|.
name|hash
operator|=
name|rrset_key_hash
argument_list|(
operator|&
name|key
operator|.
name|rk
argument_list|)
expr_stmt|;
name|slabhash_remove
argument_list|(
operator|&
name|r
operator|->
name|table
argument_list|,
name|key
operator|.
name|entry
operator|.
name|hash
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

