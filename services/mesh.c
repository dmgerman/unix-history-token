begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * services/mesh.c - deal with mesh of query states and handle events for that.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains functions to assist in dealing with a mesh of  * query states. This mesh is supposed to be thread-specific.  * It consists of query states (per qname, qtype, qclass) and connections  * between query states and the super and subquery states, and replies to  * send back to clients.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"services/mesh.h"
end_include

begin_include
include|#
directive|include
file|"services/outbound_list.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"util/timehist.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"util/alloc.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_comment
comment|/** subtract timers and the values do not overflow or become negative */
end_comment

begin_function
specifier|static
name|void
name|timeval_subtract
parameter_list|(
name|struct
name|timeval
modifier|*
name|d
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|end
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|start
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|time_t
name|end_usec
init|=
name|end
operator|->
name|tv_usec
decl_stmt|;
name|d
operator|->
name|tv_sec
operator|=
name|end
operator|->
name|tv_sec
operator|-
name|start
operator|->
name|tv_sec
expr_stmt|;
if|if
condition|(
name|end_usec
operator|<
name|start
operator|->
name|tv_usec
condition|)
block|{
name|end_usec
operator|+=
literal|1000000
expr_stmt|;
name|d
operator|->
name|tv_sec
operator|--
expr_stmt|;
block|}
name|d
operator|->
name|tv_usec
operator|=
name|end_usec
operator|-
name|start
operator|->
name|tv_usec
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** add timers and the values do not overflow or become negative */
end_comment

begin_function
specifier|static
name|void
name|timeval_add
parameter_list|(
name|struct
name|timeval
modifier|*
name|d
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|add
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|d
operator|->
name|tv_sec
operator|+=
name|add
operator|->
name|tv_sec
expr_stmt|;
name|d
operator|->
name|tv_usec
operator|+=
name|add
operator|->
name|tv_usec
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|d
operator|->
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
name|d
operator|->
name|tv_sec
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** divide sum of timers to get average */
end_comment

begin_function
specifier|static
name|void
name|timeval_divide
parameter_list|(
name|struct
name|timeval
modifier|*
name|avg
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|sum
parameter_list|,
name|size_t
name|d
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|size_t
name|leftover
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
name|avg
operator|->
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|avg
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|avg
operator|->
name|tv_sec
operator|=
name|sum
operator|->
name|tv_sec
operator|/
name|d
expr_stmt|;
name|avg
operator|->
name|tv_usec
operator|=
name|sum
operator|->
name|tv_usec
operator|/
name|d
expr_stmt|;
comment|/* handle fraction from seconds divide */
name|leftover
operator|=
name|sum
operator|->
name|tv_sec
operator|-
name|avg
operator|->
name|tv_sec
operator|*
name|d
expr_stmt|;
name|avg
operator|->
name|tv_usec
operator|+=
operator|(
name|leftover
operator|*
literal|1000000
operator|)
operator|/
name|d
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** histogram compare of time values */
end_comment

begin_function
specifier|static
name|int
name|timeval_smaller
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|x
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|y
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|S_SPLINT_S
if|if
condition|(
name|x
operator|->
name|tv_sec
operator|<
name|y
operator|->
name|tv_sec
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|x
operator|->
name|tv_sec
operator|==
name|y
operator|->
name|tv_sec
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|tv_usec
operator|<=
name|y
operator|->
name|tv_usec
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|mesh_state_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|mesh_state
modifier|*
name|a
init|=
operator|(
expr|struct
name|mesh_state
operator|*
operator|)
name|ap
decl_stmt|;
name|struct
name|mesh_state
modifier|*
name|b
init|=
operator|(
expr|struct
name|mesh_state
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|s
operator|.
name|is_priming
operator|&&
operator|!
name|b
operator|->
name|s
operator|.
name|is_priming
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|a
operator|->
name|s
operator|.
name|is_priming
operator|&&
name|b
operator|->
name|s
operator|.
name|is_priming
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_RD
operator|)
operator|&&
operator|!
operator|(
name|b
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_RD
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_RD
operator|)
operator|&&
operator|(
name|b
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_RD
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_CD
operator|)
operator|&&
operator|!
operator|(
name|b
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_CD
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_CD
operator|)
operator|&&
operator|(
name|b
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_CD
operator|)
condition|)
return|return
literal|1
return|;
return|return
name|query_info_compare
argument_list|(
operator|&
name|a
operator|->
name|s
operator|.
name|qinfo
argument_list|,
operator|&
name|b
operator|->
name|s
operator|.
name|qinfo
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mesh_state_ref_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|mesh_state_ref
modifier|*
name|a
init|=
operator|(
expr|struct
name|mesh_state_ref
operator|*
operator|)
name|ap
decl_stmt|;
name|struct
name|mesh_state_ref
modifier|*
name|b
init|=
operator|(
expr|struct
name|mesh_state_ref
operator|*
operator|)
name|bp
decl_stmt|;
return|return
name|mesh_state_compare
argument_list|(
name|a
operator|->
name|s
argument_list|,
name|b
operator|->
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|mesh_area
modifier|*
name|mesh_create
parameter_list|(
name|struct
name|module_stack
modifier|*
name|stack
parameter_list|,
name|struct
name|module_env
modifier|*
name|env
parameter_list|)
block|{
name|struct
name|mesh_area
modifier|*
name|mesh
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mesh_area
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mesh
condition|)
block|{
name|log_err
argument_list|(
literal|"mesh area alloc: out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mesh
operator|->
name|histogram
operator|=
name|timehist_setup
argument_list|()
expr_stmt|;
name|mesh
operator|->
name|qbuf_bak
operator|=
name|sldns_buffer_new
argument_list|(
name|env
operator|->
name|cfg
operator|->
name|msg_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mesh
operator|->
name|histogram
operator|||
operator|!
name|mesh
operator|->
name|qbuf_bak
condition|)
block|{
name|free
argument_list|(
name|mesh
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"mesh area alloc: out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mesh
operator|->
name|mods
operator|=
operator|*
name|stack
expr_stmt|;
name|mesh
operator|->
name|env
operator|=
name|env
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|mesh
operator|->
name|run
argument_list|,
operator|&
name|mesh_state_compare
argument_list|)
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|mesh
operator|->
name|all
argument_list|,
operator|&
name|mesh_state_compare
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|num_reply_addrs
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|num_reply_states
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|num_detached_states
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|num_forever_states
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|stats_jostled
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|stats_dropped
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|max_reply_states
operator|=
name|env
operator|->
name|cfg
operator|->
name|num_queries_per_thread
expr_stmt|;
name|mesh
operator|->
name|max_forever_states
operator|=
operator|(
name|mesh
operator|->
name|max_reply_states
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|mesh
operator|->
name|jostle_max
operator|.
name|tv_sec
operator|=
call|(
name|time_t
call|)
argument_list|(
name|env
operator|->
name|cfg
operator|->
name|jostle_time
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|jostle_max
operator|.
name|tv_usec
operator|=
call|(
name|time_t
call|)
argument_list|(
operator|(
name|env
operator|->
name|cfg
operator|->
name|jostle_time
operator|%
literal|1000
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|mesh
return|;
block|}
end_function

begin_comment
comment|/** help mesh delete delete mesh states */
end_comment

begin_function
specifier|static
name|void
name|mesh_delete_helper
parameter_list|(
name|rbnode_t
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|mesh_state
modifier|*
name|mstate
init|=
operator|(
expr|struct
name|mesh_state
operator|*
operator|)
name|n
operator|->
name|key
decl_stmt|;
comment|/* perform a full delete, not only 'cleanup' routine, 	 * because other callbacks expect a clean state in the mesh. 	 * For 're-entrant' calls */
name|mesh_state_delete
argument_list|(
operator|&
name|mstate
operator|->
name|s
argument_list|)
expr_stmt|;
comment|/* but because these delete the items from the tree, postorder 	 * traversal and rbtree rebalancing do not work together */
block|}
end_function

begin_function
name|void
name|mesh_delete
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mesh
condition|)
return|return;
comment|/* free all query states */
while|while
condition|(
name|mesh
operator|->
name|all
operator|.
name|count
condition|)
name|mesh_delete_helper
argument_list|(
name|mesh
operator|->
name|all
operator|.
name|root
argument_list|)
expr_stmt|;
name|timehist_delete
argument_list|(
name|mesh
operator|->
name|histogram
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|mesh
operator|->
name|qbuf_bak
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mesh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mesh_delete_all
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|)
block|{
comment|/* free all query states */
while|while
condition|(
name|mesh
operator|->
name|all
operator|.
name|count
condition|)
name|mesh_delete_helper
argument_list|(
name|mesh
operator|->
name|all
operator|.
name|root
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|stats_dropped
operator|+=
name|mesh
operator|->
name|num_reply_addrs
expr_stmt|;
comment|/* clear mesh area references */
name|rbtree_init
argument_list|(
operator|&
name|mesh
operator|->
name|run
argument_list|,
operator|&
name|mesh_state_compare
argument_list|)
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|mesh
operator|->
name|all
argument_list|,
operator|&
name|mesh_state_compare
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|num_reply_addrs
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|num_reply_states
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|num_detached_states
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|num_forever_states
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|forever_first
operator|=
name|NULL
expr_stmt|;
name|mesh
operator|->
name|forever_last
operator|=
name|NULL
expr_stmt|;
name|mesh
operator|->
name|jostle_first
operator|=
name|NULL
expr_stmt|;
name|mesh
operator|->
name|jostle_last
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mesh_make_new_space
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|sldns_buffer
modifier|*
name|qbuf
parameter_list|)
block|{
name|struct
name|mesh_state
modifier|*
name|m
init|=
name|mesh
operator|->
name|jostle_first
decl_stmt|;
comment|/* free space is available */
if|if
condition|(
name|mesh
operator|->
name|num_reply_states
operator|<
name|mesh
operator|->
name|max_reply_states
condition|)
return|return
literal|1
return|;
comment|/* try to kick out a jostle-list item */
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|reply_list
operator|&&
name|m
operator|->
name|list_select
operator|==
name|mesh_jostle_list
condition|)
block|{
comment|/* how old is it? */
name|struct
name|timeval
name|age
decl_stmt|;
name|timeval_subtract
argument_list|(
operator|&
name|age
argument_list|,
name|mesh
operator|->
name|env
operator|->
name|now_tv
argument_list|,
operator|&
name|m
operator|->
name|reply_list
operator|->
name|start_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeval_smaller
argument_list|(
operator|&
name|mesh
operator|->
name|jostle_max
argument_list|,
operator|&
name|age
argument_list|)
condition|)
block|{
comment|/* its a goner */
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"query jostled out to "
literal|"make space for a new one"
argument_list|,
name|m
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname
argument_list|,
name|m
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qtype
argument_list|,
name|m
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
comment|/* backup the query */
if|if
condition|(
name|qbuf
condition|)
name|sldns_buffer_copy
argument_list|(
name|mesh
operator|->
name|qbuf_bak
argument_list|,
name|qbuf
argument_list|)
expr_stmt|;
comment|/* notify supers */
if|if
condition|(
name|m
operator|->
name|super_set
operator|.
name|count
operator|>
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"notify supers of failure"
argument_list|)
expr_stmt|;
name|m
operator|->
name|s
operator|.
name|return_msg
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|s
operator|.
name|return_rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
name|mesh_walk_supers
argument_list|(
name|mesh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|mesh
operator|->
name|stats_jostled
operator|++
expr_stmt|;
name|mesh_state_delete
argument_list|(
operator|&
name|m
operator|->
name|s
argument_list|)
expr_stmt|;
comment|/* restore the query - note that the qinfo ptr to 			 * the querybuffer is then correct again. */
if|if
condition|(
name|qbuf
condition|)
name|sldns_buffer_copy
argument_list|(
name|qbuf
argument_list|,
name|mesh
operator|->
name|qbuf_bak
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* no space for new item */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mesh_new_client
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|qflags
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|rep
parameter_list|,
name|uint16_t
name|qid
parameter_list|)
block|{
comment|/* do not use CD flag from user for mesh state, we want the CD-query 	 * to receive validation anyway, to protect out cache contents and 	 * avoid bad-data in this cache that a downstream validator cannot 	 * remove from this cache */
name|struct
name|mesh_state
modifier|*
name|s
init|=
name|mesh_area_find
argument_list|(
name|mesh
argument_list|,
name|qinfo
argument_list|,
name|qflags
operator|&
name|BIT_RD
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|was_detached
init|=
literal|0
decl_stmt|;
name|int
name|was_noreply
init|=
literal|0
decl_stmt|;
name|int
name|added
init|=
literal|0
decl_stmt|;
comment|/* does this create a new reply state? */
if|if
condition|(
operator|!
name|s
operator|||
name|s
operator|->
name|list_select
operator|==
name|mesh_no_list
condition|)
block|{
if|if
condition|(
operator|!
name|mesh_make_new_space
argument_list|(
name|mesh
argument_list|,
name|rep
operator|->
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Too many queries. dropping "
literal|"incoming query."
argument_list|)
expr_stmt|;
name|comm_point_drop_reply
argument_list|(
name|rep
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|stats_dropped
operator|++
expr_stmt|;
return|return;
block|}
comment|/* for this new reply state, the reply address is free, 		 * so the limit of reply addresses does not stop reply states*/
block|}
else|else
block|{
comment|/* protect our memory usage from storing reply addresses */
if|if
condition|(
name|mesh
operator|->
name|num_reply_addrs
operator|>
name|mesh
operator|->
name|max_reply_states
operator|*
literal|16
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Too many requests queued. "
literal|"dropping incoming query."
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|stats_dropped
operator|++
expr_stmt|;
name|comm_point_drop_reply
argument_list|(
name|rep
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* see if it already exists, if not, create one */
if|if
condition|(
operator|!
name|s
condition|)
block|{
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|struct
name|rbnode_t
modifier|*
name|n
decl_stmt|;
endif|#
directive|endif
name|s
operator|=
name|mesh_state_create
argument_list|(
name|mesh
operator|->
name|env
argument_list|,
name|qinfo
argument_list|,
name|qflags
operator|&
name|BIT_RD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log_err
argument_list|(
literal|"mesh_state_create: out of memory; SERVFAIL"
argument_list|)
expr_stmt|;
name|error_encode
argument_list|(
name|rep
operator|->
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|,
name|qinfo
argument_list|,
name|qid
argument_list|,
name|qflags
argument_list|,
name|edns
argument_list|)
expr_stmt|;
name|comm_point_send_reply
argument_list|(
name|rep
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|n
operator|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_insert
argument_list|(
operator|&
name|mesh
operator|->
name|all
argument_list|,
operator|&
name|s
operator|->
name|node
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* set detached (it is now) */
name|mesh
operator|->
name|num_detached_states
operator|++
expr_stmt|;
name|added
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|reply_list
operator|&&
operator|!
name|s
operator|->
name|cb_list
operator|&&
name|s
operator|->
name|super_set
operator|.
name|count
operator|==
literal|0
condition|)
name|was_detached
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|reply_list
operator|&&
operator|!
name|s
operator|->
name|cb_list
condition|)
name|was_noreply
operator|=
literal|1
expr_stmt|;
comment|/* add reply to s */
if|if
condition|(
operator|!
name|mesh_state_add_reply
argument_list|(
name|s
argument_list|,
name|edns
argument_list|,
name|rep
argument_list|,
name|qid
argument_list|,
name|qflags
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mesh_new_client: out of memory; SERVFAIL"
argument_list|)
expr_stmt|;
name|error_encode
argument_list|(
name|rep
operator|->
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|,
name|qinfo
argument_list|,
name|qid
argument_list|,
name|qflags
argument_list|,
name|edns
argument_list|)
expr_stmt|;
name|comm_point_send_reply
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
condition|)
name|mesh_state_delete
argument_list|(
operator|&
name|s
operator|->
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* update statistics */
if|if
condition|(
name|was_detached
condition|)
block|{
name|log_assert
argument_list|(
name|mesh
operator|->
name|num_detached_states
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|num_detached_states
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|was_noreply
condition|)
block|{
name|mesh
operator|->
name|num_reply_states
operator|++
expr_stmt|;
block|}
name|mesh
operator|->
name|num_reply_addrs
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|list_select
operator|==
name|mesh_no_list
condition|)
block|{
comment|/* move to either the forever or the jostle_list */
if|if
condition|(
name|mesh
operator|->
name|num_forever_states
operator|<
name|mesh
operator|->
name|max_forever_states
condition|)
block|{
name|mesh
operator|->
name|num_forever_states
operator|++
expr_stmt|;
name|mesh_list_insert
argument_list|(
name|s
argument_list|,
operator|&
name|mesh
operator|->
name|forever_first
argument_list|,
operator|&
name|mesh
operator|->
name|forever_last
argument_list|)
expr_stmt|;
name|s
operator|->
name|list_select
operator|=
name|mesh_forever_list
expr_stmt|;
block|}
else|else
block|{
name|mesh_list_insert
argument_list|(
name|s
argument_list|,
operator|&
name|mesh
operator|->
name|jostle_first
argument_list|,
operator|&
name|mesh
operator|->
name|jostle_last
argument_list|)
expr_stmt|;
name|s
operator|->
name|list_select
operator|=
name|mesh_jostle_list
expr_stmt|;
block|}
block|}
if|if
condition|(
name|added
condition|)
name|mesh_run
argument_list|(
name|mesh
argument_list|,
name|s
argument_list|,
name|module_event_new
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mesh_new_callback
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|qflags
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|uint16_t
name|qid
parameter_list|,
name|mesh_cb_func_t
name|cb
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|mesh_state
modifier|*
name|s
init|=
name|mesh_area_find
argument_list|(
name|mesh
argument_list|,
name|qinfo
argument_list|,
name|qflags
operator|&
name|BIT_RD
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|was_detached
init|=
literal|0
decl_stmt|;
name|int
name|was_noreply
init|=
literal|0
decl_stmt|;
name|int
name|added
init|=
literal|0
decl_stmt|;
comment|/* there are no limits on the number of callbacks */
comment|/* see if it already exists, if not, create one */
if|if
condition|(
operator|!
name|s
condition|)
block|{
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|struct
name|rbnode_t
modifier|*
name|n
decl_stmt|;
endif|#
directive|endif
name|s
operator|=
name|mesh_state_create
argument_list|(
name|mesh
operator|->
name|env
argument_list|,
name|qinfo
argument_list|,
name|qflags
operator|&
name|BIT_RD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|n
operator|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_insert
argument_list|(
operator|&
name|mesh
operator|->
name|all
argument_list|,
operator|&
name|s
operator|->
name|node
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* set detached (it is now) */
name|mesh
operator|->
name|num_detached_states
operator|++
expr_stmt|;
name|added
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|reply_list
operator|&&
operator|!
name|s
operator|->
name|cb_list
operator|&&
name|s
operator|->
name|super_set
operator|.
name|count
operator|==
literal|0
condition|)
name|was_detached
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|reply_list
operator|&&
operator|!
name|s
operator|->
name|cb_list
condition|)
name|was_noreply
operator|=
literal|1
expr_stmt|;
comment|/* add reply to s */
if|if
condition|(
operator|!
name|mesh_state_add_cb
argument_list|(
name|s
argument_list|,
name|edns
argument_list|,
name|buf
argument_list|,
name|cb
argument_list|,
name|cb_arg
argument_list|,
name|qid
argument_list|,
name|qflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|added
condition|)
name|mesh_state_delete
argument_list|(
operator|&
name|s
operator|->
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* update statistics */
if|if
condition|(
name|was_detached
condition|)
block|{
name|log_assert
argument_list|(
name|mesh
operator|->
name|num_detached_states
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|num_detached_states
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|was_noreply
condition|)
block|{
name|mesh
operator|->
name|num_reply_states
operator|++
expr_stmt|;
block|}
name|mesh
operator|->
name|num_reply_addrs
operator|++
expr_stmt|;
if|if
condition|(
name|added
condition|)
name|mesh_run
argument_list|(
name|mesh
argument_list|,
name|s
argument_list|,
name|module_event_new
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|mesh_new_prefetch
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|qflags
parameter_list|,
name|time_t
name|leeway
parameter_list|)
block|{
name|struct
name|mesh_state
modifier|*
name|s
init|=
name|mesh_area_find
argument_list|(
name|mesh
argument_list|,
name|qinfo
argument_list|,
name|qflags
operator|&
name|BIT_RD
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|struct
name|rbnode_t
modifier|*
name|n
decl_stmt|;
endif|#
directive|endif
comment|/* already exists, and for a different purpose perhaps. 	 * if mesh_no_list, keep it that way. */
if|if
condition|(
name|s
condition|)
block|{
comment|/* make it ignore the cache from now on */
if|if
condition|(
operator|!
name|s
operator|->
name|s
operator|.
name|blacklist
condition|)
name|sock_list_insert
argument_list|(
operator|&
name|s
operator|->
name|s
operator|.
name|blacklist
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|s
operator|.
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s
operator|.
name|prefetch_leeway
operator|<
name|leeway
condition|)
name|s
operator|->
name|s
operator|.
name|prefetch_leeway
operator|=
name|leeway
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|mesh_make_new_space
argument_list|(
name|mesh
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Too many queries. dropped prefetch."
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|stats_dropped
operator|++
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|mesh_state_create
argument_list|(
name|mesh
operator|->
name|env
argument_list|,
name|qinfo
argument_list|,
name|qflags
operator|&
name|BIT_RD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log_err
argument_list|(
literal|"prefetch mesh_state_create: out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|n
operator|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_insert
argument_list|(
operator|&
name|mesh
operator|->
name|all
argument_list|,
operator|&
name|s
operator|->
name|node
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* set detached (it is now) */
name|mesh
operator|->
name|num_detached_states
operator|++
expr_stmt|;
comment|/* make it ignore the cache */
name|sock_list_insert
argument_list|(
operator|&
name|s
operator|->
name|s
operator|.
name|blacklist
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|s
operator|.
name|region
argument_list|)
expr_stmt|;
name|s
operator|->
name|s
operator|.
name|prefetch_leeway
operator|=
name|leeway
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|list_select
operator|==
name|mesh_no_list
condition|)
block|{
comment|/* move to either the forever or the jostle_list */
if|if
condition|(
name|mesh
operator|->
name|num_forever_states
operator|<
name|mesh
operator|->
name|max_forever_states
condition|)
block|{
name|mesh
operator|->
name|num_forever_states
operator|++
expr_stmt|;
name|mesh_list_insert
argument_list|(
name|s
argument_list|,
operator|&
name|mesh
operator|->
name|forever_first
argument_list|,
operator|&
name|mesh
operator|->
name|forever_last
argument_list|)
expr_stmt|;
name|s
operator|->
name|list_select
operator|=
name|mesh_forever_list
expr_stmt|;
block|}
else|else
block|{
name|mesh_list_insert
argument_list|(
name|s
argument_list|,
operator|&
name|mesh
operator|->
name|jostle_first
argument_list|,
operator|&
name|mesh
operator|->
name|jostle_last
argument_list|)
expr_stmt|;
name|s
operator|->
name|list_select
operator|=
name|mesh_jostle_list
expr_stmt|;
block|}
block|}
name|mesh_run
argument_list|(
name|mesh
argument_list|,
name|s
argument_list|,
name|module_event_new
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mesh_report_reply
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|struct
name|outbound_entry
modifier|*
name|e
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|reply
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|enum
name|module_ev
name|event
init|=
name|module_event_reply
decl_stmt|;
name|e
operator|->
name|qstate
operator|->
name|reply
operator|=
name|reply
expr_stmt|;
if|if
condition|(
name|what
operator|!=
name|NETEVENT_NOERROR
condition|)
block|{
name|event
operator|=
name|module_event_noreply
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|NETEVENT_CAPSFAIL
condition|)
name|event
operator|=
name|module_event_capsfail
expr_stmt|;
block|}
name|mesh_run
argument_list|(
name|mesh
argument_list|,
name|e
operator|->
name|qstate
operator|->
name|mesh_info
argument_list|,
name|event
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mesh_state
modifier|*
name|mesh_state_create
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|qflags
parameter_list|,
name|int
name|prime
parameter_list|)
block|{
name|struct
name|regional
modifier|*
name|region
init|=
name|alloc_reg_obtain
argument_list|(
name|env
operator|->
name|alloc
argument_list|)
decl_stmt|;
name|struct
name|mesh_state
modifier|*
name|mstate
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|region
condition|)
return|return
name|NULL
return|;
name|mstate
operator|=
operator|(
expr|struct
name|mesh_state
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mesh_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mstate
condition|)
block|{
name|alloc_reg_release
argument_list|(
name|env
operator|->
name|alloc
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|mstate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mstate
argument_list|)
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|node
operator|=
operator|*
name|RBTREE_NULL
expr_stmt|;
name|mstate
operator|->
name|run_node
operator|=
operator|*
name|RBTREE_NULL
expr_stmt|;
name|mstate
operator|->
name|node
operator|.
name|key
operator|=
name|mstate
expr_stmt|;
name|mstate
operator|->
name|run_node
operator|.
name|key
operator|=
name|mstate
expr_stmt|;
name|mstate
operator|->
name|reply_list
operator|=
name|NULL
expr_stmt|;
name|mstate
operator|->
name|list_select
operator|=
name|mesh_no_list
expr_stmt|;
name|mstate
operator|->
name|replies_sent
operator|=
literal|0
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|mstate
operator|->
name|super_set
argument_list|,
operator|&
name|mesh_state_ref_compare
argument_list|)
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|mstate
operator|->
name|sub_set
argument_list|,
operator|&
name|mesh_state_ref_compare
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|num_activated
operator|=
literal|0
expr_stmt|;
comment|/* init module qstate */
name|mstate
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qtype
operator|=
name|qinfo
operator|->
name|qtype
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qclass
operator|=
name|qinfo
operator|->
name|qclass
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname_len
operator|=
name|qinfo
operator|->
name|qname_len
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname
operator|=
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mstate
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname
condition|)
block|{
name|alloc_reg_release
argument_list|(
name|env
operator|->
name|alloc
argument_list|,
name|region
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* remove all weird bits from qflags */
name|mstate
operator|->
name|s
operator|.
name|query_flags
operator|=
operator|(
name|qflags
operator|&
operator|(
name|BIT_RD
operator||
name|BIT_CD
operator|)
operator|)
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|is_priming
operator|=
name|prime
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|reply
operator|=
name|NULL
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|region
operator|=
name|region
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|curmod
operator|=
literal|0
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|return_msg
operator|=
literal|0
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|return_rcode
operator|=
name|LDNS_RCODE_NOERROR
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|env
operator|=
name|env
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|mesh_info
operator|=
name|mstate
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|prefetch_leeway
operator|=
literal|0
expr_stmt|;
comment|/* init modules */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|mesh
operator|->
name|mods
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
name|mstate
operator|->
name|s
operator|.
name|minfo
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|ext_state
index|[
name|i
index|]
operator|=
name|module_state_initial
expr_stmt|;
block|}
return|return
name|mstate
return|;
block|}
end_function

begin_function
name|void
name|mesh_state_cleanup
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|mstate
parameter_list|)
block|{
name|struct
name|mesh_area
modifier|*
name|mesh
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|mstate
condition|)
return|return;
name|mesh
operator|=
name|mstate
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
expr_stmt|;
comment|/* drop unsent replies */
if|if
condition|(
operator|!
name|mstate
operator|->
name|replies_sent
condition|)
block|{
name|struct
name|mesh_reply
modifier|*
name|rep
decl_stmt|;
name|struct
name|mesh_cb
modifier|*
name|cb
decl_stmt|;
for|for
control|(
name|rep
operator|=
name|mstate
operator|->
name|reply_list
init|;
name|rep
condition|;
name|rep
operator|=
name|rep
operator|->
name|next
control|)
block|{
name|comm_point_drop_reply
argument_list|(
operator|&
name|rep
operator|->
name|query_reply
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|num_reply_addrs
operator|--
expr_stmt|;
block|}
for|for
control|(
name|cb
operator|=
name|mstate
operator|->
name|cb_list
init|;
name|cb
condition|;
name|cb
operator|=
name|cb
operator|->
name|next
control|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mesh_cb
argument_list|(
name|cb
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cb
operator|->
name|cb
call|)
argument_list|(
name|cb
operator|->
name|cb_arg
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|,
name|NULL
argument_list|,
name|sec_status_unchecked
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|num_reply_addrs
operator|--
expr_stmt|;
block|}
block|}
comment|/* de-init modules */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mesh
operator|->
name|mods
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mod_clear
argument_list|(
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|clear
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|clear
operator|)
operator|(
operator|&
name|mstate
operator|->
name|s
operator|,
name|i
operator|)
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|minfo
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|ext_state
index|[
name|i
index|]
operator|=
name|module_finished
expr_stmt|;
block|}
name|alloc_reg_release
argument_list|(
name|mstate
operator|->
name|s
operator|.
name|env
operator|->
name|alloc
argument_list|,
name|mstate
operator|->
name|s
operator|.
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mesh_state_delete
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|)
block|{
name|struct
name|mesh_area
modifier|*
name|mesh
decl_stmt|;
name|struct
name|mesh_state_ref
modifier|*
name|super
decl_stmt|,
name|ref
decl_stmt|;
name|struct
name|mesh_state
modifier|*
name|mstate
decl_stmt|;
if|if
condition|(
operator|!
name|qstate
condition|)
return|return;
name|mstate
operator|=
name|qstate
operator|->
name|mesh_info
expr_stmt|;
name|mesh
operator|=
name|mstate
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
expr_stmt|;
name|mesh_detach_subs
argument_list|(
operator|&
name|mstate
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mstate
operator|->
name|list_select
operator|==
name|mesh_forever_list
condition|)
block|{
name|mesh
operator|->
name|num_forever_states
operator|--
expr_stmt|;
name|mesh_list_remove
argument_list|(
name|mstate
argument_list|,
operator|&
name|mesh
operator|->
name|forever_first
argument_list|,
operator|&
name|mesh
operator|->
name|forever_last
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mstate
operator|->
name|list_select
operator|==
name|mesh_jostle_list
condition|)
block|{
name|mesh_list_remove
argument_list|(
name|mstate
argument_list|,
operator|&
name|mesh
operator|->
name|jostle_first
argument_list|,
operator|&
name|mesh
operator|->
name|jostle_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mstate
operator|->
name|reply_list
operator|&&
operator|!
name|mstate
operator|->
name|cb_list
operator|&&
name|mstate
operator|->
name|super_set
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|log_assert
argument_list|(
name|mesh
operator|->
name|num_detached_states
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|num_detached_states
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|mstate
operator|->
name|reply_list
operator|||
name|mstate
operator|->
name|cb_list
condition|)
block|{
name|log_assert
argument_list|(
name|mesh
operator|->
name|num_reply_states
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|num_reply_states
operator|--
expr_stmt|;
block|}
name|ref
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|ref
expr_stmt|;
name|ref
operator|.
name|s
operator|=
name|mstate
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|super
argument_list|,
argument|struct mesh_state_ref*
argument_list|,
argument|&mstate->super_set
argument_list|)
block|{
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|super
operator|->
name|s
operator|->
name|sub_set
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|mesh
operator|->
name|run
argument_list|,
name|mstate
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|mesh
operator|->
name|all
argument_list|,
name|mstate
argument_list|)
expr_stmt|;
name|mesh_state_cleanup
argument_list|(
name|mstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** helper recursive rbtree find routine */
end_comment

begin_function
specifier|static
name|int
name|find_in_subsub
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|m
parameter_list|,
name|struct
name|mesh_state
modifier|*
name|tofind
parameter_list|,
name|size_t
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|mesh_state_ref
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|++
operator|>
name|MESH_MAX_SUBSUB
condition|)
return|return
literal|1
return|;
name|RBTREE_FOR
argument_list|(
argument|r
argument_list|,
argument|struct mesh_state_ref*
argument_list|,
argument|&m->sub_set
argument_list|)
block|{
if|if
condition|(
name|r
operator|->
name|s
operator|==
name|tofind
operator|||
name|find_in_subsub
argument_list|(
name|r
operator|->
name|s
argument_list|,
name|tofind
argument_list|,
name|c
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** find cycle for already looked up mesh_state */
end_comment

begin_function
specifier|static
name|int
name|mesh_detect_cycle_found
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|mesh_state
modifier|*
name|dep_m
parameter_list|)
block|{
name|struct
name|mesh_state
modifier|*
name|cyc_m
init|=
name|qstate
operator|->
name|mesh_info
decl_stmt|;
name|size_t
name|counter
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dep_m
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dep_m
operator|==
name|cyc_m
operator|||
name|find_in_subsub
argument_list|(
name|dep_m
argument_list|,
name|cyc_m
argument_list|,
operator|&
name|counter
argument_list|)
condition|)
block|{
if|if
condition|(
name|counter
operator|>
name|MESH_MAX_SUBSUB
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mesh_detach_subs
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|)
block|{
name|struct
name|mesh_area
modifier|*
name|mesh
init|=
name|qstate
operator|->
name|env
operator|->
name|mesh
decl_stmt|;
name|struct
name|mesh_state_ref
modifier|*
name|ref
decl_stmt|,
name|lookup
decl_stmt|;
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|struct
name|rbnode_t
modifier|*
name|n
decl_stmt|;
endif|#
directive|endif
name|lookup
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|lookup
expr_stmt|;
name|lookup
operator|.
name|s
operator|=
name|qstate
operator|->
name|mesh_info
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|ref
argument_list|,
argument|struct mesh_state_ref*
argument_list|,
argument|&qstate->mesh_info->sub_set
argument_list|)
block|{
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|n
operator|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_delete
argument_list|(
operator|&
name|ref
operator|->
name|s
operator|->
name|super_set
argument_list|,
operator|&
name|lookup
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* must have been present */
if|if
condition|(
operator|!
name|ref
operator|->
name|s
operator|->
name|reply_list
operator|&&
operator|!
name|ref
operator|->
name|s
operator|->
name|cb_list
operator|&&
name|ref
operator|->
name|s
operator|->
name|super_set
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|mesh
operator|->
name|num_detached_states
operator|++
expr_stmt|;
name|log_assert
argument_list|(
name|mesh
operator|->
name|num_detached_states
operator|+
name|mesh
operator|->
name|num_reply_states
operator|<=
name|mesh
operator|->
name|all
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|rbtree_init
argument_list|(
operator|&
name|qstate
operator|->
name|mesh_info
operator|->
name|sub_set
argument_list|,
operator|&
name|mesh_state_ref_compare
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mesh_attach_sub
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|qflags
parameter_list|,
name|int
name|prime
parameter_list|,
name|struct
name|module_qstate
modifier|*
modifier|*
name|newq
parameter_list|)
block|{
comment|/* find it, if not, create it */
name|struct
name|mesh_area
modifier|*
name|mesh
init|=
name|qstate
operator|->
name|env
operator|->
name|mesh
decl_stmt|;
name|struct
name|mesh_state
modifier|*
name|sub
init|=
name|mesh_area_find
argument_list|(
name|mesh
argument_list|,
name|qinfo
argument_list|,
name|qflags
argument_list|,
name|prime
argument_list|)
decl_stmt|;
name|int
name|was_detached
decl_stmt|;
if|if
condition|(
name|mesh_detect_cycle_found
argument_list|(
name|qstate
argument_list|,
name|sub
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"attach failed, cycle detected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|sub
condition|)
block|{
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|struct
name|rbnode_t
modifier|*
name|n
decl_stmt|;
endif|#
directive|endif
comment|/* create a new one */
name|sub
operator|=
name|mesh_state_create
argument_list|(
name|qstate
operator|->
name|env
argument_list|,
name|qinfo
argument_list|,
name|qflags
argument_list|,
name|prime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sub
condition|)
block|{
name|log_err
argument_list|(
literal|"mesh_attach_sub: out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|n
operator|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_insert
argument_list|(
operator|&
name|mesh
operator|->
name|all
argument_list|,
operator|&
name|sub
operator|->
name|node
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* set detached (it is now) */
name|mesh
operator|->
name|num_detached_states
operator|++
expr_stmt|;
comment|/* set new query state to run */
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|n
operator|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_insert
argument_list|(
operator|&
name|mesh
operator|->
name|run
argument_list|,
operator|&
name|sub
operator|->
name|run_node
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|newq
operator|=
operator|&
name|sub
operator|->
name|s
expr_stmt|;
block|}
else|else
operator|*
name|newq
operator|=
name|NULL
expr_stmt|;
name|was_detached
operator|=
operator|(
name|sub
operator|->
name|super_set
operator|.
name|count
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|mesh_state_attachment
argument_list|(
name|qstate
operator|->
name|mesh_info
argument_list|,
name|sub
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* if it was a duplicate  attachment, the count was not zero before */
if|if
condition|(
operator|!
name|sub
operator|->
name|reply_list
operator|&&
operator|!
name|sub
operator|->
name|cb_list
operator|&&
name|was_detached
operator|&&
name|sub
operator|->
name|super_set
operator|.
name|count
operator|==
literal|1
condition|)
block|{
comment|/* it used to be detached, before this one got added */
name|log_assert
argument_list|(
name|mesh
operator|->
name|num_detached_states
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|num_detached_states
operator|--
expr_stmt|;
block|}
comment|/* *newq will be run when inited after the current module stops */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|mesh_state_attachment
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|super
parameter_list|,
name|struct
name|mesh_state
modifier|*
name|sub
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|struct
name|rbnode_t
modifier|*
name|n
decl_stmt|;
endif|#
directive|endif
name|struct
name|mesh_state_ref
modifier|*
name|subref
decl_stmt|;
comment|/* points to sub, inserted in super */
name|struct
name|mesh_state_ref
modifier|*
name|superref
decl_stmt|;
comment|/* points to super, inserted in sub */
if|if
condition|(
operator|!
operator|(
name|subref
operator|=
name|regional_alloc
argument_list|(
name|super
operator|->
name|s
operator|.
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mesh_state_ref
argument_list|)
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|superref
operator|=
name|regional_alloc
argument_list|(
name|sub
operator|->
name|s
operator|.
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mesh_state_ref
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"mesh_state_attachment: out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|superref
operator|->
name|node
operator|.
name|key
operator|=
name|superref
expr_stmt|;
name|superref
operator|->
name|s
operator|=
name|super
expr_stmt|;
name|subref
operator|->
name|node
operator|.
name|key
operator|=
name|subref
expr_stmt|;
name|subref
operator|->
name|s
operator|=
name|sub
expr_stmt|;
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
operator|&
name|sub
operator|->
name|super_set
argument_list|,
operator|&
name|superref
operator|->
name|node
argument_list|)
condition|)
block|{
comment|/* this should not happen, iterator and validator do not 		 * attach subqueries that are identical. */
comment|/* already attached, we are done, nothing todo. 		 * since superref and subref already allocated in region, 		 * we cannot free them */
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|n
operator|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_insert
argument_list|(
operator|&
name|super
operator|->
name|sub_set
argument_list|,
operator|&
name|subref
operator|->
name|node
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* we checked above if statement, the reverse 	  administration should not fail now, unless they are out of sync */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * callback results to mesh cb entry  * @param m: mesh state to send it for.  * @param rcode: if not 0, error code.  * @param rep: reply to send (or NULL if rcode is set).  * @param r: callback entry  */
end_comment

begin_function
specifier|static
name|void
name|mesh_do_callback
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|m
parameter_list|,
name|int
name|rcode
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|mesh_cb
modifier|*
name|r
parameter_list|)
block|{
name|int
name|secure
decl_stmt|;
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
comment|/* bogus messages are not made into servfail, sec_status passed  	 * to the callback function */
if|if
condition|(
name|rep
operator|&&
name|rep
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
name|secure
operator|=
literal|1
expr_stmt|;
else|else
name|secure
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rep
operator|&&
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
condition|)
name|rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
if|if
condition|(
operator|!
name|rcode
operator|&&
name|rep
operator|->
name|security
operator|==
name|sec_status_bogus
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|reason
operator|=
name|errinf_to_str
argument_list|(
operator|&
name|m
operator|->
name|s
argument_list|)
operator|)
condition|)
name|rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
block|}
comment|/* send the reply */
if|if
condition|(
name|rcode
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mesh_cb
argument_list|(
name|r
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|r
operator|->
name|cb
call|)
argument_list|(
name|r
operator|->
name|cb_arg
argument_list|,
name|rcode
argument_list|,
name|r
operator|->
name|buf
argument_list|,
name|sec_status_unchecked
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|udp_size
init|=
name|r
operator|->
name|edns
operator|.
name|udp_size
decl_stmt|;
name|sldns_buffer_clear
argument_list|(
name|r
operator|->
name|buf
argument_list|)
expr_stmt|;
name|r
operator|->
name|edns
operator|.
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|r
operator|->
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|r
operator|->
name|edns
operator|.
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|edns
operator|.
name|bits
operator|&=
name|EDNS_DO
expr_stmt|;
if|if
condition|(
operator|!
name|reply_info_answer_encode
argument_list|(
operator|&
name|m
operator|->
name|s
operator|.
name|qinfo
argument_list|,
name|rep
argument_list|,
name|r
operator|->
name|qid
argument_list|,
name|r
operator|->
name|qflags
argument_list|,
name|r
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|scratch
argument_list|,
name|udp_size
argument_list|,
operator|&
name|r
operator|->
name|edns
argument_list|,
call|(
name|int
call|)
argument_list|(
name|r
operator|->
name|edns
operator|.
name|bits
operator|&
name|EDNS_DO
argument_list|)
argument_list|,
name|secure
argument_list|)
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mesh_cb
argument_list|(
name|r
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|r
operator|->
name|cb
call|)
argument_list|(
name|r
operator|->
name|cb_arg
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|,
name|r
operator|->
name|buf
argument_list|,
name|sec_status_unchecked
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mesh_cb
argument_list|(
name|r
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|r
operator|->
name|cb
call|)
argument_list|(
name|r
operator|->
name|cb_arg
argument_list|,
name|LDNS_RCODE_NOERROR
argument_list|,
name|r
operator|->
name|buf
argument_list|,
name|rep
operator|->
name|security
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
operator|->
name|num_reply_addrs
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Send reply to mesh reply entry  * @param m: mesh state to send it for.  * @param rcode: if not 0, error code.  * @param rep: reply to send (or NULL if rcode is set).  * @param r: reply entry  * @param prev: previous reply, already has its answer encoded in buffer.  */
end_comment

begin_function
specifier|static
name|void
name|mesh_send_reply
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|m
parameter_list|,
name|int
name|rcode
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|mesh_reply
modifier|*
name|r
parameter_list|,
name|struct
name|mesh_reply
modifier|*
name|prev
parameter_list|)
block|{
name|struct
name|timeval
name|end_time
decl_stmt|;
name|struct
name|timeval
name|duration
decl_stmt|;
name|int
name|secure
decl_stmt|;
comment|/* examine security status */
if|if
condition|(
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|need_to_validate
operator|&&
operator|(
operator|!
operator|(
name|r
operator|->
name|qflags
operator|&
name|BIT_CD
operator|)
operator|||
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|cfg
operator|->
name|ignore_cd
operator|)
operator|&&
name|rep
operator|&&
name|rep
operator|->
name|security
operator|<=
name|sec_status_bogus
condition|)
block|{
name|rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|cfg
operator|->
name|stat_extended
condition|)
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
operator|->
name|ans_bogus
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|&&
name|rep
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
name|secure
operator|=
literal|1
expr_stmt|;
else|else
name|secure
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rep
operator|&&
name|rcode
operator|==
name|LDNS_RCODE_NOERROR
condition|)
name|rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
comment|/* send the reply */
if|if
condition|(
name|prev
operator|&&
name|prev
operator|->
name|qflags
operator|==
name|r
operator|->
name|qflags
operator|&&
name|prev
operator|->
name|edns
operator|.
name|edns_present
operator|==
name|r
operator|->
name|edns
operator|.
name|edns_present
operator|&&
name|prev
operator|->
name|edns
operator|.
name|bits
operator|==
name|r
operator|->
name|edns
operator|.
name|bits
operator|&&
name|prev
operator|->
name|edns
operator|.
name|udp_size
operator|==
name|r
operator|->
name|edns
operator|.
name|udp_size
condition|)
block|{
comment|/* if the previous reply is identical to this one, fix ID */
if|if
condition|(
name|prev
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
operator|!=
name|r
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
condition|)
name|sldns_buffer_copy
argument_list|(
name|r
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
argument_list|,
name|prev
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|sldns_buffer_write_at
argument_list|(
name|r
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
operator|&
name|r
operator|->
name|qid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_write_at
argument_list|(
name|r
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
argument_list|,
literal|12
argument_list|,
name|r
operator|->
name|qname
argument_list|,
name|m
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname_len
argument_list|)
expr_stmt|;
name|comm_point_send_reply
argument_list|(
operator|&
name|r
operator|->
name|query_reply
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rcode
condition|)
block|{
name|m
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname
operator|=
name|r
operator|->
name|qname
expr_stmt|;
name|error_encode
argument_list|(
name|r
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
argument_list|,
name|rcode
argument_list|,
operator|&
name|m
operator|->
name|s
operator|.
name|qinfo
argument_list|,
name|r
operator|->
name|qid
argument_list|,
name|r
operator|->
name|qflags
argument_list|,
operator|&
name|r
operator|->
name|edns
argument_list|)
expr_stmt|;
name|comm_point_send_reply
argument_list|(
operator|&
name|r
operator|->
name|query_reply
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|udp_size
init|=
name|r
operator|->
name|edns
operator|.
name|udp_size
decl_stmt|;
name|r
operator|->
name|edns
operator|.
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|r
operator|->
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|r
operator|->
name|edns
operator|.
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|edns
operator|.
name|bits
operator|&=
name|EDNS_DO
expr_stmt|;
name|m
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname
operator|=
name|r
operator|->
name|qname
expr_stmt|;
if|if
condition|(
operator|!
name|reply_info_answer_encode
argument_list|(
operator|&
name|m
operator|->
name|s
operator|.
name|qinfo
argument_list|,
name|rep
argument_list|,
name|r
operator|->
name|qid
argument_list|,
name|r
operator|->
name|qflags
argument_list|,
name|r
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|scratch
argument_list|,
name|udp_size
argument_list|,
operator|&
name|r
operator|->
name|edns
argument_list|,
call|(
name|int
call|)
argument_list|(
name|r
operator|->
name|edns
operator|.
name|bits
operator|&
name|EDNS_DO
argument_list|)
argument_list|,
name|secure
argument_list|)
condition|)
block|{
name|error_encode
argument_list|(
name|r
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|,
operator|&
name|m
operator|->
name|s
operator|.
name|qinfo
argument_list|,
name|r
operator|->
name|qid
argument_list|,
name|r
operator|->
name|qflags
argument_list|,
operator|&
name|r
operator|->
name|edns
argument_list|)
expr_stmt|;
block|}
name|comm_point_send_reply
argument_list|(
operator|&
name|r
operator|->
name|query_reply
argument_list|)
expr_stmt|;
block|}
comment|/* account */
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
operator|->
name|num_reply_addrs
operator|--
expr_stmt|;
name|end_time
operator|=
operator|*
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|now_tv
expr_stmt|;
name|timeval_subtract
argument_list|(
operator|&
name|duration
argument_list|,
operator|&
name|end_time
argument_list|,
operator|&
name|r
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"query took "
name|ARG_LL
literal|"d.%6.6d sec"
argument_list|,
operator|(
name|long
name|long
operator|)
name|duration
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|duration
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
operator|->
name|replies_sent
operator|++
expr_stmt|;
name|timeval_add
argument_list|(
operator|&
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
operator|->
name|replies_sum_wait
argument_list|,
operator|&
name|duration
argument_list|)
expr_stmt|;
name|timehist_insert
argument_list|(
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
operator|->
name|histogram
argument_list|,
operator|&
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|cfg
operator|->
name|stat_extended
condition|)
block|{
name|uint16_t
name|rc
init|=
name|FLAGS_GET_RCODE
argument_list|(
name|sldns_buffer_read_u16_at
argument_list|(
name|r
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|secure
condition|)
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
operator|->
name|ans_secure
operator|++
expr_stmt|;
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
operator|->
name|ans_rcode
index|[
name|rc
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|LDNS_ANCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|r
operator|->
name|query_reply
operator|.
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|m
operator|->
name|s
operator|.
name|env
operator|->
name|mesh
operator|->
name|ans_nodata
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mesh_query_done
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|mstate
parameter_list|)
block|{
name|struct
name|mesh_reply
modifier|*
name|r
decl_stmt|;
name|struct
name|mesh_reply
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|struct
name|mesh_cb
modifier|*
name|c
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|rep
init|=
operator|(
name|mstate
operator|->
name|s
operator|.
name|return_msg
condition|?
name|mstate
operator|->
name|s
operator|.
name|return_msg
operator|->
name|rep
else|:
name|NULL
operator|)
decl_stmt|;
for|for
control|(
name|r
operator|=
name|mstate
operator|->
name|reply_list
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|mesh_send_reply
argument_list|(
name|mstate
argument_list|,
name|mstate
operator|->
name|s
operator|.
name|return_rcode
argument_list|,
name|rep
argument_list|,
name|r
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|r
expr_stmt|;
block|}
name|mstate
operator|->
name|replies_sent
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
name|mstate
operator|->
name|cb_list
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
name|mesh_do_callback
argument_list|(
name|mstate
argument_list|,
name|mstate
operator|->
name|s
operator|.
name|return_rcode
argument_list|,
name|rep
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mesh_walk_supers
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|struct
name|mesh_state
modifier|*
name|mstate
parameter_list|)
block|{
name|struct
name|mesh_state_ref
modifier|*
name|ref
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|ref
argument_list|,
argument|struct mesh_state_ref*
argument_list|,
argument|&mstate->super_set
argument_list|)
block|{
comment|/* make super runnable */
operator|(
name|void
operator|)
name|rbtree_insert
argument_list|(
operator|&
name|mesh
operator|->
name|run
argument_list|,
operator|&
name|ref
operator|->
name|s
operator|->
name|run_node
argument_list|)
expr_stmt|;
comment|/* callback the function to inform super of result */
name|fptr_ok
argument_list|(
name|fptr_whitelist_mod_inform_super
argument_list|(
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|ref
operator|->
name|s
operator|->
name|s
operator|.
name|curmod
index|]
operator|->
name|inform_super
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|ref
operator|->
name|s
operator|->
name|s
operator|.
name|curmod
index|]
operator|->
name|inform_super
operator|)
operator|(
operator|&
name|mstate
operator|->
name|s
operator|,
name|ref
operator|->
name|s
operator|->
name|s
operator|.
name|curmod
operator|,
operator|&
name|ref
operator|->
name|s
operator|->
name|s
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|mesh_state
modifier|*
name|mesh_area_find
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|qflags
parameter_list|,
name|int
name|prime
parameter_list|)
block|{
name|struct
name|mesh_state
name|key
decl_stmt|;
name|struct
name|mesh_state
modifier|*
name|result
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|s
operator|.
name|is_priming
operator|=
name|prime
expr_stmt|;
name|key
operator|.
name|s
operator|.
name|qinfo
operator|=
operator|*
name|qinfo
expr_stmt|;
name|key
operator|.
name|s
operator|.
name|query_flags
operator|=
name|qflags
expr_stmt|;
name|result
operator|=
operator|(
expr|struct
name|mesh_state
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|mesh
operator|->
name|all
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|mesh_state_add_cb
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|s
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|mesh_cb_func_t
name|cb
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|,
name|uint16_t
name|qid
parameter_list|,
name|uint16_t
name|qflags
parameter_list|)
block|{
name|struct
name|mesh_cb
modifier|*
name|r
init|=
name|regional_alloc
argument_list|(
name|s
operator|->
name|s
operator|.
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mesh_cb
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
literal|0
return|;
name|r
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|log_assert
argument_list|(
name|fptr_whitelist_mesh_cb
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* early failure ifmissing*/
name|r
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|r
operator|->
name|cb_arg
operator|=
name|cb_arg
expr_stmt|;
name|r
operator|->
name|edns
operator|=
operator|*
name|edns
expr_stmt|;
name|r
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|r
operator|->
name|qflags
operator|=
name|qflags
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|s
operator|->
name|cb_list
expr_stmt|;
name|s
operator|->
name|cb_list
operator|=
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|mesh_state_add_reply
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|s
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|rep
parameter_list|,
name|uint16_t
name|qid
parameter_list|,
name|uint16_t
name|qflags
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|)
block|{
name|struct
name|mesh_reply
modifier|*
name|r
init|=
name|regional_alloc
argument_list|(
name|s
operator|->
name|s
operator|.
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mesh_reply
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
literal|0
return|;
name|r
operator|->
name|query_reply
operator|=
operator|*
name|rep
expr_stmt|;
name|r
operator|->
name|edns
operator|=
operator|*
name|edns
expr_stmt|;
name|r
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|r
operator|->
name|qflags
operator|=
name|qflags
expr_stmt|;
name|r
operator|->
name|start_time
operator|=
operator|*
name|s
operator|->
name|s
operator|.
name|env
operator|->
name|now_tv
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|s
operator|->
name|reply_list
expr_stmt|;
name|r
operator|->
name|qname
operator|=
name|regional_alloc_init
argument_list|(
name|s
operator|->
name|s
operator|.
name|region
argument_list|,
name|qname
argument_list|,
name|s
operator|->
name|s
operator|.
name|qinfo
operator|.
name|qname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|qname
condition|)
return|return
literal|0
return|;
name|s
operator|->
name|reply_list
operator|=
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Continue processing the mesh state at another module.  * Handles module to modules tranfer of control.  * Handles module finished.  * @param mesh: the mesh area.  * @param mstate: currently active mesh state.  * 	Deleted if finished, calls _done and _supers to   * 	send replies to clients and inform other mesh states.  * 	This in turn may create additional runnable mesh states.  * @param s: state at which the current module exited.  * @param ev: the event sent to the module.  * 	returned is the event to send to the next module.  * @return true if continue processing at the new module.  * 	false if not continued processing is needed.  */
end_comment

begin_function
specifier|static
name|int
name|mesh_continue
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|struct
name|mesh_state
modifier|*
name|mstate
parameter_list|,
name|enum
name|module_ext_state
name|s
parameter_list|,
name|enum
name|module_ev
modifier|*
name|ev
parameter_list|)
block|{
name|mstate
operator|->
name|num_activated
operator|++
expr_stmt|;
if|if
condition|(
name|mstate
operator|->
name|num_activated
operator|>
name|MESH_MAX_ACTIVATION
condition|)
block|{
comment|/* module is looping. Stop it. */
name|log_err
argument_list|(
literal|"internal error: looping module stopped"
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"pass error for qstate"
argument_list|,
operator|&
name|mstate
operator|->
name|s
operator|.
name|qinfo
argument_list|)
expr_stmt|;
name|s
operator|=
name|module_error
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|module_wait_module
operator|||
name|s
operator|==
name|module_restart_next
condition|)
block|{
comment|/* start next module */
name|mstate
operator|->
name|s
operator|.
name|curmod
operator|++
expr_stmt|;
if|if
condition|(
name|mesh
operator|->
name|mods
operator|.
name|num
operator|==
name|mstate
operator|->
name|s
operator|.
name|curmod
condition|)
block|{
name|log_err
argument_list|(
literal|"Cannot pass to next module; at last module"
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"pass error for qstate"
argument_list|,
operator|&
name|mstate
operator|->
name|s
operator|.
name|qinfo
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|curmod
operator|--
expr_stmt|;
return|return
name|mesh_continue
argument_list|(
name|mesh
argument_list|,
name|mstate
argument_list|,
name|module_error
argument_list|,
name|ev
argument_list|)
return|;
block|}
if|if
condition|(
name|s
operator|==
name|module_restart_next
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mod_clear
argument_list|(
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|mstate
operator|->
name|s
operator|.
name|curmod
index|]
operator|->
name|clear
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|mstate
operator|->
name|s
operator|.
name|curmod
index|]
operator|->
name|clear
operator|)
operator|(
operator|&
name|mstate
operator|->
name|s
operator|,
name|mstate
operator|->
name|s
operator|.
name|curmod
operator|)
expr_stmt|;
name|mstate
operator|->
name|s
operator|.
name|minfo
index|[
name|mstate
operator|->
name|s
operator|.
name|curmod
index|]
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|ev
operator|=
name|module_event_pass
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|s
operator|==
name|module_error
operator|&&
name|mstate
operator|->
name|s
operator|.
name|return_rcode
operator|==
name|LDNS_RCODE_NOERROR
condition|)
block|{
comment|/* error is bad, handle pass back up below */
name|mstate
operator|->
name|s
operator|.
name|return_rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|module_error
operator|||
name|s
operator|==
name|module_finished
condition|)
block|{
if|if
condition|(
name|mstate
operator|->
name|s
operator|.
name|curmod
operator|==
literal|0
condition|)
block|{
name|mesh_query_done
argument_list|(
name|mstate
argument_list|)
expr_stmt|;
name|mesh_walk_supers
argument_list|(
name|mesh
argument_list|,
name|mstate
argument_list|)
expr_stmt|;
name|mesh_state_delete
argument_list|(
operator|&
name|mstate
operator|->
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* pass along the locus of control */
name|mstate
operator|->
name|s
operator|.
name|curmod
operator|--
expr_stmt|;
operator|*
name|ev
operator|=
name|module_event_moddone
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mesh_run
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
name|struct
name|mesh_state
modifier|*
name|mstate
parameter_list|,
name|enum
name|module_ev
name|ev
parameter_list|,
name|struct
name|outbound_entry
modifier|*
name|e
parameter_list|)
block|{
name|enum
name|module_ext_state
name|s
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"mesh_run: start"
argument_list|)
expr_stmt|;
while|while
condition|(
name|mstate
condition|)
block|{
comment|/* run the module */
name|fptr_ok
argument_list|(
name|fptr_whitelist_mod_operate
argument_list|(
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|mstate
operator|->
name|s
operator|.
name|curmod
index|]
operator|->
name|operate
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|mstate
operator|->
name|s
operator|.
name|curmod
index|]
operator|->
name|operate
operator|)
operator|(
operator|&
name|mstate
operator|->
name|s
operator|,
name|ev
operator|,
name|mstate
operator|->
name|s
operator|.
name|curmod
operator|,
name|e
operator|)
expr_stmt|;
comment|/* examine results */
name|mstate
operator|->
name|s
operator|.
name|reply
operator|=
name|NULL
expr_stmt|;
name|regional_free_all
argument_list|(
name|mstate
operator|->
name|s
operator|.
name|env
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|s
operator|=
name|mstate
operator|->
name|s
operator|.
name|ext_state
index|[
name|mstate
operator|->
name|s
operator|.
name|curmod
index|]
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"mesh_run: %s module exit state is %s"
argument_list|,
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|mstate
operator|->
name|s
operator|.
name|curmod
index|]
operator|->
name|name
argument_list|,
name|strextstate
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mesh_continue
argument_list|(
name|mesh
argument_list|,
name|mstate
argument_list|,
name|s
argument_list|,
operator|&
name|ev
argument_list|)
condition|)
continue|continue;
comment|/* run more modules */
name|ev
operator|=
name|module_event_pass
expr_stmt|;
if|if
condition|(
name|mesh
operator|->
name|run
operator|.
name|count
operator|>
literal|0
condition|)
block|{
comment|/* pop random element off the runnable tree */
name|mstate
operator|=
operator|(
expr|struct
name|mesh_state
operator|*
operator|)
name|mesh
operator|->
name|run
operator|.
name|root
operator|->
name|key
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|mesh
operator|->
name|run
argument_list|,
name|mstate
argument_list|)
expr_stmt|;
block|}
else|else
name|mstate
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
block|{
name|mesh_stats
argument_list|(
name|mesh
argument_list|,
literal|"mesh_run: end"
argument_list|)
expr_stmt|;
name|mesh_log_list
argument_list|(
name|mesh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mesh_log_list
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|struct
name|mesh_state
modifier|*
name|m
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|m
argument_list|,
argument|struct mesh_state*
argument_list|,
argument|&mesh->all
argument_list|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d%s%s%s%s%s mod%d %s%s"
argument_list|,
name|num
operator|++
argument_list|,
operator|(
name|m
operator|->
name|s
operator|.
name|is_priming
operator|)
condition|?
literal|"p"
else|:
literal|""
argument_list|,
comment|/* prime */
operator|(
name|m
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_RD
operator|)
condition|?
literal|"RD"
else|:
literal|""
argument_list|,
operator|(
name|m
operator|->
name|s
operator|.
name|query_flags
operator|&
name|BIT_CD
operator|)
condition|?
literal|"CD"
else|:
literal|""
argument_list|,
operator|(
name|m
operator|->
name|super_set
operator|.
name|count
operator|==
literal|0
operator|)
condition|?
literal|"d"
else|:
literal|""
argument_list|,
comment|/* detached */
operator|(
name|m
operator|->
name|sub_set
operator|.
name|count
operator|!=
literal|0
operator|)
condition|?
literal|"c"
else|:
literal|""
argument_list|,
comment|/* children */
name|m
operator|->
name|s
operator|.
name|curmod
argument_list|,
operator|(
name|m
operator|->
name|reply_list
operator|)
condition|?
literal|"rep"
else|:
literal|""
argument_list|,
comment|/*hasreply*/
operator|(
name|m
operator|->
name|cb_list
operator|)
condition|?
literal|"cb"
else|:
literal|""
comment|/* callbacks */
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
name|buf
argument_list|,
operator|&
name|m
operator|->
name|s
operator|.
name|qinfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mesh_stats
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"%s %u recursion states (%u with reply, "
literal|"%u detached), %u waiting replies, %u recursion replies "
literal|"sent, %d replies dropped, %d states jostled out"
argument_list|,
name|str
argument_list|,
operator|(
name|unsigned
operator|)
name|mesh
operator|->
name|all
operator|.
name|count
argument_list|,
operator|(
name|unsigned
operator|)
name|mesh
operator|->
name|num_reply_states
argument_list|,
operator|(
name|unsigned
operator|)
name|mesh
operator|->
name|num_detached_states
argument_list|,
operator|(
name|unsigned
operator|)
name|mesh
operator|->
name|num_reply_addrs
argument_list|,
operator|(
name|unsigned
operator|)
name|mesh
operator|->
name|replies_sent
argument_list|,
operator|(
name|unsigned
operator|)
name|mesh
operator|->
name|stats_dropped
argument_list|,
operator|(
name|unsigned
operator|)
name|mesh
operator|->
name|stats_jostled
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesh
operator|->
name|replies_sent
operator|>
literal|0
condition|)
block|{
name|struct
name|timeval
name|avg
decl_stmt|;
name|timeval_divide
argument_list|(
operator|&
name|avg
argument_list|,
operator|&
name|mesh
operator|->
name|replies_sum_wait
argument_list|,
name|mesh
operator|->
name|replies_sent
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"average recursion processing time "
name|ARG_LL
literal|"d.%6.6d sec"
argument_list|,
operator|(
name|long
name|long
operator|)
name|avg
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|avg
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"histogram of recursion processing times"
argument_list|)
expr_stmt|;
name|timehist_log
argument_list|(
name|mesh
operator|->
name|histogram
argument_list|,
literal|"recursions"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mesh_stats_clear
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mesh
condition|)
return|return;
name|mesh
operator|->
name|replies_sent
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|replies_sum_wait
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|replies_sum_wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|stats_jostled
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|stats_dropped
operator|=
literal|0
expr_stmt|;
name|timehist_clear
argument_list|(
name|mesh
operator|->
name|histogram
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|ans_secure
operator|=
literal|0
expr_stmt|;
name|mesh
operator|->
name|ans_bogus
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mesh
operator|->
name|ans_rcode
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|16
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|ans_nodata
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|mesh_get_mem
parameter_list|(
name|struct
name|mesh_area
modifier|*
name|mesh
parameter_list|)
block|{
name|struct
name|mesh_state
modifier|*
name|m
decl_stmt|;
name|size_t
name|s
init|=
sizeof|sizeof
argument_list|(
operator|*
name|mesh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|timehist
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|th_buck
argument_list|)
operator|*
name|mesh
operator|->
name|histogram
operator|->
name|num
operator|+
sizeof|sizeof
argument_list|(
name|sldns_buffer
argument_list|)
operator|+
name|sldns_buffer_capacity
argument_list|(
name|mesh
operator|->
name|qbuf_bak
argument_list|)
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|m
argument_list|,
argument|struct mesh_state*
argument_list|,
argument|&mesh->all
argument_list|)
block|{
comment|/* all, including m itself allocated in qstate region */
name|s
operator|+=
name|regional_get_mem
argument_list|(
name|m
operator|->
name|s
operator|.
name|region
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|mesh_detect_cycle
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|int
name|prime
parameter_list|)
block|{
name|struct
name|mesh_area
modifier|*
name|mesh
init|=
name|qstate
operator|->
name|env
operator|->
name|mesh
decl_stmt|;
name|struct
name|mesh_state
modifier|*
name|dep_m
init|=
name|mesh_area_find
argument_list|(
name|mesh
argument_list|,
name|qinfo
argument_list|,
name|flags
argument_list|,
name|prime
argument_list|)
decl_stmt|;
return|return
name|mesh_detect_cycle_found
argument_list|(
name|qstate
argument_list|,
name|dep_m
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mesh_list_insert
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|m
parameter_list|,
name|struct
name|mesh_state
modifier|*
modifier|*
name|fp
parameter_list|,
name|struct
name|mesh_state
modifier|*
modifier|*
name|lp
parameter_list|)
block|{
comment|/* insert as last element */
name|m
operator|->
name|prev
operator|=
operator|*
name|lp
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|lp
condition|)
operator|(
operator|*
name|lp
operator|)
operator|->
name|next
operator|=
name|m
expr_stmt|;
else|else
operator|*
name|fp
operator|=
name|m
expr_stmt|;
operator|*
name|lp
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mesh_list_remove
parameter_list|(
name|struct
name|mesh_state
modifier|*
name|m
parameter_list|,
name|struct
name|mesh_state
modifier|*
modifier|*
name|fp
parameter_list|,
name|struct
name|mesh_state
modifier|*
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|next
condition|)
name|m
operator|->
name|next
operator|->
name|prev
operator|=
name|m
operator|->
name|prev
expr_stmt|;
else|else
operator|*
name|lp
operator|=
name|m
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|prev
condition|)
name|m
operator|->
name|prev
operator|->
name|next
operator|=
name|m
operator|->
name|next
expr_stmt|;
else|else
operator|*
name|fp
operator|=
name|m
operator|->
name|next
expr_stmt|;
block|}
end_function

end_unit

