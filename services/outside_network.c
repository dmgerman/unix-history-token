begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * services/outside_network.c - implement sending of queries and wait answer.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file has functions to send queries to authoritative servers and  * wait for the pending answer events.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"services/outside_network.h"
end_include

begin_include
include|#
directive|include
file|"services/listen_dnsport.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/random.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_SSL_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/** number of times to retry making a random ID that is unique. */
end_comment

begin_define
define|#
directive|define
name|MAX_ID_RETRY
value|1000
end_define

begin_comment
comment|/** number of times to retry finding interface, port that can be opened. */
end_comment

begin_define
define|#
directive|define
name|MAX_PORT_RETRY
value|10000
end_define

begin_comment
comment|/** number of retries on outgoing UDP queries */
end_comment

begin_define
define|#
directive|define
name|OUTBOUND_UDP_RETRY
value|1
end_define

begin_comment
comment|/** initiate TCP transaction for serviced query */
end_comment

begin_function_decl
specifier|static
name|void
name|serviced_tcp_initiate
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|sldns_buffer
modifier|*
name|buff
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/** with a fd available, randomize and send UDP */
end_comment

begin_function_decl
specifier|static
name|int
name|randomize_and_send_udp
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|pending
modifier|*
name|pend
parameter_list|,
name|sldns_buffer
modifier|*
name|packet
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|pending_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|key1
parameter_list|,
specifier|const
name|void
modifier|*
name|key2
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|p1
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|key1
decl_stmt|;
name|struct
name|pending
modifier|*
name|p2
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|key2
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|id
operator|<
name|p2
operator|->
name|id
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|p1
operator|->
name|id
operator|>
name|p2
operator|->
name|id
condition|)
return|return
literal|1
return|;
name|log_assert
argument_list|(
name|p1
operator|->
name|id
operator|==
name|p2
operator|->
name|id
argument_list|)
expr_stmt|;
return|return
name|sockaddr_cmp
argument_list|(
operator|&
name|p1
operator|->
name|addr
argument_list|,
name|p1
operator|->
name|addrlen
argument_list|,
operator|&
name|p2
operator|->
name|addr
argument_list|,
name|p2
operator|->
name|addrlen
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|serviced_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|key1
parameter_list|,
specifier|const
name|void
modifier|*
name|key2
parameter_list|)
block|{
name|struct
name|serviced_query
modifier|*
name|q1
init|=
operator|(
expr|struct
name|serviced_query
operator|*
operator|)
name|key1
decl_stmt|;
name|struct
name|serviced_query
modifier|*
name|q2
init|=
operator|(
expr|struct
name|serviced_query
operator|*
operator|)
name|key2
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|q1
operator|->
name|qbuflen
operator|<
name|q2
operator|->
name|qbuflen
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|q1
operator|->
name|qbuflen
operator|>
name|q2
operator|->
name|qbuflen
condition|)
return|return
literal|1
return|;
name|log_assert
argument_list|(
name|q1
operator|->
name|qbuflen
operator|==
name|q2
operator|->
name|qbuflen
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|q1
operator|->
name|qbuflen
operator|>=
literal|15
comment|/* 10 header, root, type, class */
argument_list|)
expr_stmt|;
comment|/* alternate casing of qname is still the same query */
if|if
condition|(
operator|(
name|r
operator|=
name|memcmp
argument_list|(
name|q1
operator|->
name|qbuf
argument_list|,
name|q2
operator|->
name|qbuf
argument_list|,
literal|10
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|memcmp
argument_list|(
name|q1
operator|->
name|qbuf
operator|+
name|q1
operator|->
name|qbuflen
operator|-
literal|4
argument_list|,
name|q2
operator|->
name|qbuf
operator|+
name|q2
operator|->
name|qbuflen
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|q1
operator|->
name|dnssec
operator|!=
name|q2
operator|->
name|dnssec
condition|)
block|{
if|if
condition|(
name|q1
operator|->
name|dnssec
operator|<
name|q2
operator|->
name|dnssec
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|query_dname_compare
argument_list|(
name|q1
operator|->
name|qbuf
operator|+
literal|10
argument_list|,
name|q2
operator|->
name|qbuf
operator|+
literal|10
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
return|return
name|sockaddr_cmp
argument_list|(
operator|&
name|q1
operator|->
name|addr
argument_list|,
name|q1
operator|->
name|addrlen
argument_list|,
operator|&
name|q2
operator|->
name|addr
argument_list|,
name|q2
operator|->
name|addrlen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** delete waiting_tcp entry. Does not unlink from waiting list.   * @param w: to delete.  */
end_comment

begin_function
specifier|static
name|void
name|waiting_tcp_delete
parameter_list|(
name|struct
name|waiting_tcp
modifier|*
name|w
parameter_list|)
block|{
if|if
condition|(
operator|!
name|w
condition|)
return|return;
if|if
condition|(
name|w
operator|->
name|timer
condition|)
name|comm_timer_delete
argument_list|(
name|w
operator|->
name|timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   * Pick random outgoing-interface of that family, and bind it.  * port set to 0 so OS picks a port number for us.  * if it is the ANY address, do not bind.  * @param w: tcp structure with destination address.  * @param s: socket fd.  * @return false on error, socket closed.  */
end_comment

begin_function
specifier|static
name|int
name|pick_outgoing_tcp
parameter_list|(
name|struct
name|waiting_tcp
modifier|*
name|w
parameter_list|,
name|int
name|s
parameter_list|)
block|{
name|struct
name|port_if
modifier|*
name|pi
init|=
name|NULL
decl_stmt|;
name|int
name|num
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr_is_ip6
argument_list|(
operator|&
name|w
operator|->
name|addr
argument_list|,
name|w
operator|->
name|addrlen
argument_list|)
condition|)
name|num
operator|=
name|w
operator|->
name|outnet
operator|->
name|num_ip6
expr_stmt|;
else|else
endif|#
directive|endif
name|num
operator|=
name|w
operator|->
name|outnet
operator|->
name|num_ip4
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"no TCP outgoing interfaces of family"
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_OPS
argument_list|,
literal|"for addr"
argument_list|,
operator|&
name|w
operator|->
name|addr
argument_list|,
name|w
operator|->
name|addrlen
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr_is_ip6
argument_list|(
operator|&
name|w
operator|->
name|addr
argument_list|,
name|w
operator|->
name|addrlen
argument_list|)
condition|)
name|pi
operator|=
operator|&
name|w
operator|->
name|outnet
operator|->
name|ip6_ifs
index|[
name|ub_random_max
argument_list|(
name|w
operator|->
name|outnet
operator|->
name|rnd
argument_list|,
name|num
argument_list|)
index|]
expr_stmt|;
else|else
endif|#
directive|endif
name|pi
operator|=
operator|&
name|w
operator|->
name|outnet
operator|->
name|ip4_ifs
index|[
name|ub_random_max
argument_list|(
name|w
operator|->
name|outnet
operator|->
name|rnd
argument_list|,
name|num
argument_list|)
index|]
expr_stmt|;
name|log_assert
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_is_any
argument_list|(
operator|&
name|pi
operator|->
name|addr
argument_list|,
name|pi
operator|->
name|addrlen
argument_list|)
condition|)
block|{
comment|/* binding to the ANY interface is for listening sockets */
return|return
literal|1
return|;
block|}
comment|/* set port to 0 */
if|if
condition|(
name|addr_is_ip6
argument_list|(
operator|&
name|pi
operator|->
name|addr
argument_list|,
name|pi
operator|->
name|addrlen
argument_list|)
condition|)
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|pi
operator|->
name|addr
operator|)
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
else|else
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|pi
operator|->
name|addr
operator|)
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|pi
operator|->
name|addr
argument_list|,
name|pi
operator|->
name|addrlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"outgoing tcp: bind: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"outgoing tcp: bind: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"tcp bound to src"
argument_list|,
operator|&
name|pi
operator|->
name|addr
argument_list|,
name|pi
operator|->
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** use next free buffer to service a tcp query */
end_comment

begin_function
specifier|static
name|int
name|outnet_tcp_take_into_use
parameter_list|(
name|struct
name|waiting_tcp
modifier|*
name|w
parameter_list|,
name|uint8_t
modifier|*
name|pkt
parameter_list|,
name|size_t
name|pkt_len
parameter_list|)
block|{
name|struct
name|pending_tcp
modifier|*
name|pend
init|=
name|w
operator|->
name|outnet
operator|->
name|tcp_free
decl_stmt|;
name|int
name|s
decl_stmt|;
name|log_assert
argument_list|(
name|pend
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|w
operator|->
name|addrlen
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* open socket */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr_is_ip6
argument_list|(
operator|&
name|w
operator|->
name|addr
argument_list|,
name|w
operator|->
name|addrlen
argument_list|)
condition|)
name|s
operator|=
name|socket
argument_list|(
name|PF_INET6
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|s
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"outgoing tcp: socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"outgoing tcp: socket: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"failed address"
argument_list|,
operator|&
name|w
operator|->
name|addr
argument_list|,
name|w
operator|->
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|pick_outgoing_tcp
argument_list|(
name|w
argument_list|,
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
name|fd_set_nonblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|w
operator|->
name|addr
argument_list|,
name|w
operator|->
name|addrlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
ifdef|#
directive|ifdef
name|EINPROGRESS
if|if
condition|(
name|errno
operator|!=
name|EINPROGRESS
condition|)
block|{
else|#
directive|else
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|tcp_connect_errno_needs_log
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|w
operator|->
name|addr
argument_list|,
name|w
operator|->
name|addrlen
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"outgoing tcp: connect: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_WINSOCK */
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEINPROGRESS
operator|&&
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEWOULDBLOCK
condition|)
block|{
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log_addr
argument_list|(
literal|0
argument_list|,
literal|"failed address"
argument_list|,
operator|&
name|w
operator|->
name|addr
argument_list|,
name|w
operator|->
name|addrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|w
operator|->
name|outnet
operator|->
name|sslctx
operator|&&
name|w
operator|->
name|ssl_upstream
condition|)
block|{
name|pend
operator|->
name|c
operator|->
name|ssl
operator|=
name|outgoing_ssl_fd
argument_list|(
name|w
operator|->
name|outnet
operator|->
name|sslctx
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pend
operator|->
name|c
operator|->
name|ssl
condition|)
block|{
name|pend
operator|->
name|c
operator|->
name|fd
operator|=
name|s
expr_stmt|;
name|comm_point_close
argument_list|(
name|pend
operator|->
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|comm_point_tcp_win_bio_cb
argument_list|(
name|pend
operator|->
name|c
argument_list|,
name|pend
operator|->
name|c
operator|->
name|ssl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pend
operator|->
name|c
operator|->
name|ssl_shake_state
operator|=
name|comm_ssl_shake_write
expr_stmt|;
block|}
name|w
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|next_waiting
operator|=
operator|(
name|void
operator|*
operator|)
name|pend
expr_stmt|;
name|pend
operator|->
name|id
operator|=
name|LDNS_ID_WIRE
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|w
operator|->
name|outnet
operator|->
name|tcp_free
operator|=
name|pend
operator|->
name|next_free
expr_stmt|;
name|pend
operator|->
name|next_free
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|query
operator|=
name|w
expr_stmt|;
name|pend
operator|->
name|c
operator|->
name|repinfo
operator|.
name|addrlen
operator|=
name|w
operator|->
name|addrlen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pend
operator|->
name|c
operator|->
name|repinfo
operator|.
name|addr
argument_list|,
operator|&
name|w
operator|->
name|addr
argument_list|,
name|w
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|sldns_buffer_clear
argument_list|(
name|pend
operator|->
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|pend
operator|->
name|c
operator|->
name|buffer
argument_list|,
name|pkt
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|pend
operator|->
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|pend
operator|->
name|c
operator|->
name|tcp_is_reading
operator|=
literal|0
expr_stmt|;
name|pend
operator|->
name|c
operator|->
name|tcp_byte_count
operator|=
literal|0
expr_stmt|;
name|comm_point_start_listening
argument_list|(
name|pend
operator|->
name|c
argument_list|,
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/** see if buffers can be used to service TCP queries */
specifier|static
name|void
name|use_free_buffer
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|)
block|{
name|struct
name|waiting_tcp
modifier|*
name|w
decl_stmt|;
while|while
condition|(
name|outnet
operator|->
name|tcp_free
operator|&&
name|outnet
operator|->
name|tcp_wait_first
operator|&&
operator|!
name|outnet
operator|->
name|want_to_quit
condition|)
block|{
name|w
operator|=
name|outnet
operator|->
name|tcp_wait_first
expr_stmt|;
name|outnet
operator|->
name|tcp_wait_first
operator|=
name|w
operator|->
name|next_waiting
expr_stmt|;
if|if
condition|(
name|outnet
operator|->
name|tcp_wait_last
operator|==
name|w
condition|)
name|outnet
operator|->
name|tcp_wait_last
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|outnet_tcp_take_into_use
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|pkt
argument_list|,
name|w
operator|->
name|pkt_len
argument_list|)
condition|)
block|{
name|comm_point_callback_t
modifier|*
name|cb
init|=
name|w
operator|->
name|cb
decl_stmt|;
name|void
modifier|*
name|cb_arg
init|=
name|w
operator|->
name|cb_arg
decl_stmt|;
name|waiting_tcp_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_pending_tcp
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|cb
argument_list|)
argument_list|(
name|NULL
argument_list|,
name|cb_arg
argument_list|,
name|NETEVENT_CLOSED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** decomission a tcp buffer, closes commpoint and frees waiting_tcp entry */
specifier|static
name|void
name|decomission_pending_tcp
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|pending_tcp
modifier|*
name|pend
parameter_list|)
block|{
if|if
condition|(
name|pend
operator|->
name|c
operator|->
name|ssl
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SSL
name|SSL_shutdown
argument_list|(
name|pend
operator|->
name|c
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|pend
operator|->
name|c
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|pend
operator|->
name|c
operator|->
name|ssl
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|comm_point_close
argument_list|(
name|pend
operator|->
name|c
argument_list|)
expr_stmt|;
name|pend
operator|->
name|next_free
operator|=
name|outnet
operator|->
name|tcp_free
expr_stmt|;
name|outnet
operator|->
name|tcp_free
operator|=
name|pend
expr_stmt|;
name|waiting_tcp_delete
argument_list|(
name|pend
operator|->
name|query
argument_list|)
expr_stmt|;
name|pend
operator|->
name|query
operator|=
name|NULL
expr_stmt|;
name|use_free_buffer
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
block|}
name|int
name|outnet_tcp_cb
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|reply_info
parameter_list|)
block|{
name|struct
name|pending_tcp
modifier|*
name|pend
init|=
operator|(
expr|struct
name|pending_tcp
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|outside_network
modifier|*
name|outnet
init|=
name|pend
operator|->
name|query
operator|->
name|outnet
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"outnettcp cb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NETEVENT_NOERROR
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"outnettcp got tcp error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* pass error below and exit */
block|}
else|else
block|{
comment|/* check ID */
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|||
name|LDNS_ID_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|!=
name|pend
operator|->
name|id
condition|)
block|{
name|log_addr
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"outnettcp: bad ID in reply, from:"
argument_list|,
operator|&
name|pend
operator|->
name|query
operator|->
name|addr
argument_list|,
name|pend
operator|->
name|query
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|NETEVENT_CLOSED
expr_stmt|;
block|}
block|}
name|fptr_ok
argument_list|(
name|fptr_whitelist_pending_tcp
argument_list|(
name|pend
operator|->
name|query
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|pend
operator|->
name|query
operator|->
name|cb
argument_list|)
argument_list|(
name|c
argument_list|,
name|pend
operator|->
name|query
operator|->
name|cb_arg
argument_list|,
name|error
argument_list|,
name|reply_info
argument_list|)
expr_stmt|;
name|decomission_pending_tcp
argument_list|(
name|outnet
argument_list|,
name|pend
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** lower use count on pc, see if it can be closed */
specifier|static
name|void
name|portcomm_loweruse
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|port_comm
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|port_if
modifier|*
name|pif
decl_stmt|;
name|pc
operator|->
name|num_outstanding
operator|--
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|num_outstanding
operator|>
literal|0
condition|)
block|{
return|return;
block|}
comment|/* close it and replace in unused list */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"close of port %d"
argument_list|,
name|pc
operator|->
name|number
argument_list|)
expr_stmt|;
name|comm_point_close
argument_list|(
name|pc
operator|->
name|cp
argument_list|)
expr_stmt|;
name|pif
operator|=
name|pc
operator|->
name|pif
expr_stmt|;
name|log_assert
argument_list|(
name|pif
operator|->
name|inuse
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pif
operator|->
name|avail_ports
index|[
name|pif
operator|->
name|avail_total
operator|-
name|pif
operator|->
name|inuse
index|]
operator|=
name|pc
operator|->
name|number
expr_stmt|;
name|pif
operator|->
name|inuse
operator|--
expr_stmt|;
name|pif
operator|->
name|out
index|[
name|pc
operator|->
name|index
index|]
operator|=
name|pif
operator|->
name|out
index|[
name|pif
operator|->
name|inuse
index|]
expr_stmt|;
name|pif
operator|->
name|out
index|[
name|pc
operator|->
name|index
index|]
operator|->
name|index
operator|=
name|pc
operator|->
name|index
expr_stmt|;
name|pc
operator|->
name|next
operator|=
name|outnet
operator|->
name|unused_fds
expr_stmt|;
name|outnet
operator|->
name|unused_fds
operator|=
name|pc
expr_stmt|;
block|}
comment|/** try to send waiting UDP queries */
specifier|static
name|void
name|outnet_send_wait_udp
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|pend
decl_stmt|;
comment|/* process waiting queries */
while|while
condition|(
name|outnet
operator|->
name|udp_wait_first
operator|&&
name|outnet
operator|->
name|unused_fds
operator|&&
operator|!
name|outnet
operator|->
name|want_to_quit
condition|)
block|{
name|pend
operator|=
name|outnet
operator|->
name|udp_wait_first
expr_stmt|;
name|outnet
operator|->
name|udp_wait_first
operator|=
name|pend
operator|->
name|next_waiting
expr_stmt|;
if|if
condition|(
operator|!
name|pend
operator|->
name|next_waiting
condition|)
name|outnet
operator|->
name|udp_wait_last
operator|=
name|NULL
expr_stmt|;
name|sldns_buffer_clear
argument_list|(
name|outnet
operator|->
name|udp_buff
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|outnet
operator|->
name|udp_buff
argument_list|,
name|pend
operator|->
name|pkt
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|outnet
operator|->
name|udp_buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pend
operator|->
name|pkt
argument_list|)
expr_stmt|;
comment|/* freeing now makes get_mem correct */
name|pend
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|pkt_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|randomize_and_send_udp
argument_list|(
name|outnet
argument_list|,
name|pend
argument_list|,
name|outnet
operator|->
name|udp_buff
argument_list|,
name|pend
operator|->
name|timeout
argument_list|)
condition|)
block|{
comment|/* callback error on pending */
if|if
condition|(
name|pend
operator|->
name|cb
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_pending_udp
argument_list|(
name|pend
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|pend
operator|->
name|cb
argument_list|)
argument_list|(
name|outnet
operator|->
name|unused_fds
operator|->
name|cp
argument_list|,
name|pend
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_CLOSED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|pending_delete
argument_list|(
name|outnet
argument_list|,
name|pend
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|outnet_udp_cb
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|reply_info
parameter_list|)
block|{
name|struct
name|outside_network
modifier|*
name|outnet
init|=
operator|(
expr|struct
name|outside_network
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|pending
name|key
decl_stmt|;
name|struct
name|pending
modifier|*
name|p
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"answer cb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NETEVENT_NOERROR
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"outnetudp got udp error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|<
name|LDNS_HEADER_SIZE
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"outnetudp udp too short"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_assert
argument_list|(
name|reply_info
argument_list|)
expr_stmt|;
comment|/* setup lookup key */
name|key
operator|.
name|id
operator|=
operator|(
name|unsigned
operator|)
name|LDNS_ID_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
operator|.
name|addr
argument_list|,
operator|&
name|reply_info
operator|->
name|addr
argument_list|,
name|reply_info
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|key
operator|.
name|addrlen
operator|=
name|reply_info
operator|->
name|addrlen
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Incoming reply id = %4.4x"
argument_list|,
name|key
operator|.
name|id
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Incoming reply addr ="
argument_list|,
operator|&
name|reply_info
operator|->
name|addr
argument_list|,
name|reply_info
operator|->
name|addrlen
argument_list|)
expr_stmt|;
comment|/* find it, see if this thing is a valid query response */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"lookup size is %d entries"
argument_list|,
operator|(
name|int
operator|)
name|outnet
operator|->
name|pending
operator|->
name|count
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|rbtree_search
argument_list|(
name|outnet
operator|->
name|pending
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"received unwanted or unsolicited udp reply dropped."
argument_list|)
expr_stmt|;
name|log_buf
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"dropped message"
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|outnet
operator|->
name|unwanted_replies
operator|++
expr_stmt|;
if|if
condition|(
name|outnet
operator|->
name|unwanted_threshold
operator|&&
operator|++
name|outnet
operator|->
name|unwanted_total
operator|>=
name|outnet
operator|->
name|unwanted_threshold
condition|)
block|{
name|log_warn
argument_list|(
literal|"unwanted reply total reached threshold (%u)"
literal|" you may be under attack."
literal|" defensive action: clearing the cache"
argument_list|,
operator|(
name|unsigned
operator|)
name|outnet
operator|->
name|unwanted_threshold
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_alloc_cleanup
argument_list|(
name|outnet
operator|->
name|unwanted_action
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|outnet
operator|->
name|unwanted_action
call|)
argument_list|(
name|outnet
operator|->
name|unwanted_param
argument_list|)
expr_stmt|;
name|outnet
operator|->
name|unwanted_total
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"received udp reply."
argument_list|)
expr_stmt|;
name|log_buf
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"udp message"
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pc
operator|->
name|cp
operator|!=
name|c
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"received reply id,addr on wrong port. "
literal|"dropped."
argument_list|)
expr_stmt|;
name|outnet
operator|->
name|unwanted_replies
operator|++
expr_stmt|;
if|if
condition|(
name|outnet
operator|->
name|unwanted_threshold
operator|&&
operator|++
name|outnet
operator|->
name|unwanted_total
operator|>=
name|outnet
operator|->
name|unwanted_threshold
condition|)
block|{
name|log_warn
argument_list|(
literal|"unwanted reply total reached threshold (%u)"
literal|" you may be under attack."
literal|" defensive action: clearing the cache"
argument_list|,
operator|(
name|unsigned
operator|)
name|outnet
operator|->
name|unwanted_threshold
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_alloc_cleanup
argument_list|(
name|outnet
operator|->
name|unwanted_action
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|outnet
operator|->
name|unwanted_action
call|)
argument_list|(
name|outnet
operator|->
name|unwanted_param
argument_list|)
expr_stmt|;
name|outnet
operator|->
name|unwanted_total
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|comm_timer_disable
argument_list|(
name|p
operator|->
name|timer
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"outnet handle udp reply"
argument_list|)
expr_stmt|;
comment|/* delete from tree first in case callback creates a retry */
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|outnet
operator|->
name|pending
argument_list|,
name|p
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|cb
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_pending_udp
argument_list|(
name|p
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|p
operator|->
name|cb
argument_list|)
argument_list|(
name|p
operator|->
name|pc
operator|->
name|cp
argument_list|,
name|p
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_NOERROR
argument_list|,
name|reply_info
argument_list|)
expr_stmt|;
block|}
name|portcomm_loweruse
argument_list|(
name|outnet
argument_list|,
name|p
operator|->
name|pc
argument_list|)
expr_stmt|;
name|pending_delete
argument_list|(
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|outnet_send_wait_udp
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** calculate number of ip4 and ip6 interfaces*/
specifier|static
name|void
name|calc_num46
parameter_list|(
name|char
modifier|*
modifier|*
name|ifs
parameter_list|,
name|int
name|num_ifs
parameter_list|,
name|int
name|do_ip4
parameter_list|,
name|int
name|do_ip6
parameter_list|,
name|int
modifier|*
name|num_ip4
parameter_list|,
name|int
modifier|*
name|num_ip6
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|num_ip4
operator|=
literal|0
expr_stmt|;
operator|*
name|num_ip6
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|num_ifs
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|do_ip4
condition|)
operator|*
name|num_ip4
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|do_ip6
condition|)
operator|*
name|num_ip6
operator|=
literal|1
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ifs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str_is_ip6
argument_list|(
name|ifs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_ip6
condition|)
operator|(
operator|*
name|num_ip6
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_ip4
condition|)
operator|(
operator|*
name|num_ip4
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
name|void
name|pending_udp_timer_delay_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|p
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|outside_network
modifier|*
name|outnet
init|=
name|p
operator|->
name|outnet
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"timeout udp with delay"
argument_list|)
expr_stmt|;
name|portcomm_loweruse
argument_list|(
name|outnet
argument_list|,
name|p
operator|->
name|pc
argument_list|)
expr_stmt|;
name|pending_delete
argument_list|(
name|outnet
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|outnet_send_wait_udp
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
block|}
name|void
name|pending_udp_timer_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|p
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|outside_network
modifier|*
name|outnet
init|=
name|p
operator|->
name|outnet
decl_stmt|;
comment|/* it timed out */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"timeout udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|cb
condition|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_pending_udp
argument_list|(
name|p
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|p
operator|->
name|cb
argument_list|)
argument_list|(
name|p
operator|->
name|pc
operator|->
name|cp
argument_list|,
name|p
operator|->
name|cb_arg
argument_list|,
name|NETEVENT_TIMEOUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* if delayclose, keep port open for a longer time. 	 * But if the udpwaitlist exists, then we are struggling to 	 * keep up with demand for sockets, so do not wait, but service 	 * the customer (customer service more important than portICMPs) */
if|if
condition|(
name|outnet
operator|->
name|delayclose
operator|&&
operator|!
name|outnet
operator|->
name|udp_wait_first
condition|)
block|{
name|p
operator|->
name|cb
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|timer
operator|->
name|callback
operator|=
operator|&
name|pending_udp_timer_delay_cb
expr_stmt|;
name|comm_timer_set
argument_list|(
name|p
operator|->
name|timer
argument_list|,
operator|&
name|outnet
operator|->
name|delay_tv
argument_list|)
expr_stmt|;
return|return;
block|}
name|portcomm_loweruse
argument_list|(
name|outnet
argument_list|,
name|p
operator|->
name|pc
argument_list|)
expr_stmt|;
name|pending_delete
argument_list|(
name|outnet
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|outnet_send_wait_udp
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
block|}
comment|/** create pending_tcp buffers */
specifier|static
name|int
name|create_pending_tcp
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|size_t
name|bufsize
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|outnet
operator|->
name|num_tcp
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* no tcp needed, nothing to do */
if|if
condition|(
operator|!
operator|(
name|outnet
operator|->
name|tcp_conns
operator|=
operator|(
expr|struct
name|pending_tcp
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|outnet
operator|->
name|num_tcp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_tcp
operator|*
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outnet
operator|->
name|num_tcp
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|pending_tcp
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_tcp
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
operator|->
name|next_free
operator|=
name|outnet
operator|->
name|tcp_free
expr_stmt|;
name|outnet
operator|->
name|tcp_free
operator|=
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
expr_stmt|;
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
operator|->
name|c
operator|=
name|comm_point_create_tcp_out
argument_list|(
name|outnet
operator|->
name|base
argument_list|,
name|bufsize
argument_list|,
name|outnet_tcp_cb
argument_list|,
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
operator|->
name|c
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/** setup an outgoing interface, ready address */
specifier|static
name|int
name|setup_if
parameter_list|(
name|struct
name|port_if
modifier|*
name|pif
parameter_list|,
specifier|const
name|char
modifier|*
name|addrstr
parameter_list|,
name|int
modifier|*
name|avail
parameter_list|,
name|int
name|numavail
parameter_list|,
name|size_t
name|numfd
parameter_list|)
block|{
name|pif
operator|->
name|avail_total
operator|=
name|numavail
expr_stmt|;
name|pif
operator|->
name|avail_ports
operator|=
operator|(
name|int
operator|*
operator|)
name|memdup
argument_list|(
name|avail
argument_list|,
operator|(
name|size_t
operator|)
name|numavail
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pif
operator|->
name|avail_ports
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ipstrtoaddr
argument_list|(
name|addrstr
argument_list|,
name|UNBOUND_DNS_PORT
argument_list|,
operator|&
name|pif
operator|->
name|addr
argument_list|,
operator|&
name|pif
operator|->
name|addrlen
argument_list|)
condition|)
return|return
literal|0
return|;
name|pif
operator|->
name|maxout
operator|=
operator|(
name|int
operator|)
name|numfd
expr_stmt|;
name|pif
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
name|pif
operator|->
name|out
operator|=
operator|(
expr|struct
name|port_comm
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|numfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|port_comm
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pif
operator|->
name|out
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
name|struct
name|outside_network
modifier|*
name|outside_network_create
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|size_t
name|num_ports
parameter_list|,
name|char
modifier|*
modifier|*
name|ifs
parameter_list|,
name|int
name|num_ifs
parameter_list|,
name|int
name|do_ip4
parameter_list|,
name|int
name|do_ip6
parameter_list|,
name|size_t
name|num_tcp
parameter_list|,
name|struct
name|infra_cache
modifier|*
name|infra
parameter_list|,
name|struct
name|ub_randstate
modifier|*
name|rnd
parameter_list|,
name|int
name|use_caps_for_id
parameter_list|,
name|int
modifier|*
name|availports
parameter_list|,
name|int
name|numavailports
parameter_list|,
name|size_t
name|unwanted_threshold
parameter_list|,
name|void
function_decl|(
modifier|*
name|unwanted_action
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|unwanted_param
parameter_list|,
name|int
name|do_udp
parameter_list|,
name|void
modifier|*
name|sslctx
parameter_list|,
name|int
name|delayclose
parameter_list|)
block|{
name|struct
name|outside_network
modifier|*
name|outnet
init|=
operator|(
expr|struct
name|outside_network
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|outside_network
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|outnet
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|comm_base_timept
argument_list|(
name|base
argument_list|,
operator|&
name|outnet
operator|->
name|now_secs
argument_list|,
operator|&
name|outnet
operator|->
name|now_tv
argument_list|)
expr_stmt|;
name|outnet
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|outnet
operator|->
name|num_tcp
operator|=
name|num_tcp
expr_stmt|;
name|outnet
operator|->
name|infra
operator|=
name|infra
expr_stmt|;
name|outnet
operator|->
name|rnd
operator|=
name|rnd
expr_stmt|;
name|outnet
operator|->
name|sslctx
operator|=
name|sslctx
expr_stmt|;
name|outnet
operator|->
name|svcd_overhead
operator|=
literal|0
expr_stmt|;
name|outnet
operator|->
name|want_to_quit
operator|=
literal|0
expr_stmt|;
name|outnet
operator|->
name|unwanted_threshold
operator|=
name|unwanted_threshold
expr_stmt|;
name|outnet
operator|->
name|unwanted_action
operator|=
name|unwanted_action
expr_stmt|;
name|outnet
operator|->
name|unwanted_param
operator|=
name|unwanted_param
expr_stmt|;
name|outnet
operator|->
name|use_caps_for_id
operator|=
name|use_caps_for_id
expr_stmt|;
name|outnet
operator|->
name|do_udp
operator|=
name|do_udp
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
if|if
condition|(
name|delayclose
condition|)
block|{
name|outnet
operator|->
name|delayclose
operator|=
literal|1
expr_stmt|;
name|outnet
operator|->
name|delay_tv
operator|.
name|tv_sec
operator|=
name|delayclose
operator|/
literal|1000
expr_stmt|;
name|outnet
operator|->
name|delay_tv
operator|.
name|tv_usec
operator|=
operator|(
name|delayclose
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|numavailports
operator|==
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"no outgoing ports available"
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifndef|#
directive|ifndef
name|INET6
name|do_ip6
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|calc_num46
argument_list|(
name|ifs
argument_list|,
name|num_ifs
argument_list|,
name|do_ip4
argument_list|,
name|do_ip6
argument_list|,
operator|&
name|outnet
operator|->
name|num_ip4
argument_list|,
operator|&
name|outnet
operator|->
name|num_ip6
argument_list|)
expr_stmt|;
if|if
condition|(
name|outnet
operator|->
name|num_ip4
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|outnet
operator|->
name|ip4_ifs
operator|=
operator|(
expr|struct
name|port_if
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|outnet
operator|->
name|num_ip4
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|port_if
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|outnet
operator|->
name|num_ip6
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|outnet
operator|->
name|ip6_ifs
operator|=
operator|(
expr|struct
name|port_if
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|outnet
operator|->
name|num_ip6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|port_if
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|outnet
operator|->
name|udp_buff
operator|=
name|sldns_buffer_new
argument_list|(
name|bufsize
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|outnet
operator|->
name|pending
operator|=
name|rbtree_create
argument_list|(
name|pending_cmp
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|outnet
operator|->
name|serviced
operator|=
name|rbtree_create
argument_list|(
name|serviced_cmp
argument_list|)
operator|)
operator|||
operator|!
name|create_pending_tcp
argument_list|(
name|outnet
argument_list|,
name|bufsize
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* allocate commpoints */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_ports
condition|;
name|k
operator|++
control|)
block|{
name|struct
name|port_comm
modifier|*
name|pc
decl_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|port_comm
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pc
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pc
operator|->
name|cp
operator|=
name|comm_point_create_udp
argument_list|(
name|outnet
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|outnet
operator|->
name|udp_buff
argument_list|,
name|outnet_udp_cb
argument_list|,
name|outnet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pc
operator|->
name|cp
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pc
operator|->
name|next
operator|=
name|outnet
operator|->
name|unused_fds
expr_stmt|;
name|outnet
operator|->
name|unused_fds
operator|=
name|pc
expr_stmt|;
block|}
comment|/* allocate interfaces */
if|if
condition|(
name|num_ifs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_ip4
operator|&&
operator|!
name|setup_if
argument_list|(
operator|&
name|outnet
operator|->
name|ip4_ifs
index|[
literal|0
index|]
argument_list|,
literal|"0.0.0.0"
argument_list|,
name|availports
argument_list|,
name|numavailports
argument_list|,
name|num_ports
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|do_ip6
operator|&&
operator|!
name|setup_if
argument_list|(
operator|&
name|outnet
operator|->
name|ip6_ifs
index|[
literal|0
index|]
argument_list|,
literal|"::"
argument_list|,
name|availports
argument_list|,
name|numavailports
argument_list|,
name|num_ports
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|size_t
name|done_4
init|=
literal|0
decl_stmt|,
name|done_6
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ifs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str_is_ip6
argument_list|(
name|ifs
index|[
name|i
index|]
argument_list|)
operator|&&
name|do_ip6
condition|)
block|{
if|if
condition|(
operator|!
name|setup_if
argument_list|(
operator|&
name|outnet
operator|->
name|ip6_ifs
index|[
name|done_6
index|]
argument_list|,
name|ifs
index|[
name|i
index|]
argument_list|,
name|availports
argument_list|,
name|numavailports
argument_list|,
name|num_ports
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|done_6
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|str_is_ip6
argument_list|(
name|ifs
index|[
name|i
index|]
argument_list|)
operator|&&
name|do_ip4
condition|)
block|{
if|if
condition|(
operator|!
name|setup_if
argument_list|(
operator|&
name|outnet
operator|->
name|ip4_ifs
index|[
name|done_4
index|]
argument_list|,
name|ifs
index|[
name|i
index|]
argument_list|,
name|availports
argument_list|,
name|numavailports
argument_list|,
name|num_ports
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|done_4
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|outnet
return|;
block|}
comment|/** helper pending delete */
specifier|static
name|void
name|pending_node_del
parameter_list|(
name|rbnode_t
modifier|*
name|node
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|pend
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|node
decl_stmt|;
name|struct
name|outside_network
modifier|*
name|outnet
init|=
operator|(
expr|struct
name|outside_network
operator|*
operator|)
name|arg
decl_stmt|;
name|pending_delete
argument_list|(
name|outnet
argument_list|,
name|pend
argument_list|)
expr_stmt|;
block|}
comment|/** helper serviced delete */
specifier|static
name|void
name|serviced_node_del
parameter_list|(
name|rbnode_t
modifier|*
name|node
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|serviced_query
modifier|*
name|sq
init|=
operator|(
expr|struct
name|serviced_query
operator|*
operator|)
name|node
decl_stmt|;
name|struct
name|service_callback
modifier|*
name|p
init|=
name|sq
operator|->
name|cblist
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|free
argument_list|(
name|sq
operator|->
name|qbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
operator|->
name|zone
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|free
argument_list|(
name|sq
argument_list|)
expr_stmt|;
block|}
name|void
name|outside_network_quit_prepare
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|)
block|{
if|if
condition|(
operator|!
name|outnet
condition|)
return|return;
comment|/* prevent queued items from being sent */
name|outnet
operator|->
name|want_to_quit
operator|=
literal|1
expr_stmt|;
block|}
name|void
name|outside_network_delete
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|)
block|{
if|if
condition|(
operator|!
name|outnet
condition|)
return|return;
name|outnet
operator|->
name|want_to_quit
operator|=
literal|1
expr_stmt|;
comment|/* check every element, since we can be called on malloc error */
if|if
condition|(
name|outnet
operator|->
name|pending
condition|)
block|{
comment|/* free pending elements, but do no unlink from tree. */
name|traverse_postorder
argument_list|(
name|outnet
operator|->
name|pending
argument_list|,
name|pending_node_del
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outnet
operator|->
name|pending
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outnet
operator|->
name|serviced
condition|)
block|{
name|traverse_postorder
argument_list|(
name|outnet
operator|->
name|serviced
argument_list|,
name|serviced_node_del
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outnet
operator|->
name|serviced
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outnet
operator|->
name|udp_buff
condition|)
name|sldns_buffer_free
argument_list|(
name|outnet
operator|->
name|udp_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|outnet
operator|->
name|unused_fds
condition|)
block|{
name|struct
name|port_comm
modifier|*
name|p
init|=
name|outnet
operator|->
name|unused_fds
decl_stmt|,
modifier|*
name|np
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|comm_point_delete
argument_list|(
name|p
operator|->
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|outnet
operator|->
name|unused_fds
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|outnet
operator|->
name|ip4_ifs
condition|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outnet
operator|->
name|num_ip4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|outnet
operator|->
name|ip4_ifs
index|[
name|i
index|]
operator|.
name|inuse
condition|;
name|k
operator|++
control|)
block|{
name|struct
name|port_comm
modifier|*
name|pc
init|=
name|outnet
operator|->
name|ip4_ifs
index|[
name|i
index|]
operator|.
name|out
index|[
name|k
index|]
decl_stmt|;
name|comm_point_delete
argument_list|(
name|pc
operator|->
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|outnet
operator|->
name|ip4_ifs
index|[
name|i
index|]
operator|.
name|avail_ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outnet
operator|->
name|ip4_ifs
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|outnet
operator|->
name|ip4_ifs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outnet
operator|->
name|ip6_ifs
condition|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outnet
operator|->
name|num_ip6
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|outnet
operator|->
name|ip6_ifs
index|[
name|i
index|]
operator|.
name|inuse
condition|;
name|k
operator|++
control|)
block|{
name|struct
name|port_comm
modifier|*
name|pc
init|=
name|outnet
operator|->
name|ip6_ifs
index|[
name|i
index|]
operator|.
name|out
index|[
name|k
index|]
decl_stmt|;
name|comm_point_delete
argument_list|(
name|pc
operator|->
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|outnet
operator|->
name|ip6_ifs
index|[
name|i
index|]
operator|.
name|avail_ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outnet
operator|->
name|ip6_ifs
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|outnet
operator|->
name|ip6_ifs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outnet
operator|->
name|tcp_conns
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outnet
operator|->
name|num_tcp
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
condition|)
block|{
name|comm_point_delete
argument_list|(
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
operator|->
name|c
argument_list|)
expr_stmt|;
name|waiting_tcp_delete
argument_list|(
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
operator|->
name|query
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|outnet
operator|->
name|tcp_conns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outnet
operator|->
name|tcp_wait_first
condition|)
block|{
name|struct
name|waiting_tcp
modifier|*
name|p
init|=
name|outnet
operator|->
name|tcp_wait_first
decl_stmt|,
modifier|*
name|np
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next_waiting
expr_stmt|;
name|waiting_tcp_delete
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outnet
operator|->
name|udp_wait_first
condition|)
block|{
name|struct
name|pending
modifier|*
name|p
init|=
name|outnet
operator|->
name|udp_wait_first
decl_stmt|,
modifier|*
name|np
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|next_waiting
expr_stmt|;
name|pending_delete
argument_list|(
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
block|}
name|void
name|pending_delete
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|pending
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return;
if|if
condition|(
name|outnet
operator|&&
name|outnet
operator|->
name|udp_wait_first
operator|&&
operator|(
name|p
operator|->
name|next_waiting
operator|||
name|p
operator|==
name|outnet
operator|->
name|udp_wait_last
operator|)
condition|)
block|{
comment|/* delete from waiting list, if it is in the waiting list */
name|struct
name|pending
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|x
init|=
name|outnet
operator|->
name|udp_wait_first
decl_stmt|;
while|while
condition|(
name|x
operator|&&
name|x
operator|!=
name|p
condition|)
block|{
name|prev
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|x
operator|->
name|next_waiting
expr_stmt|;
block|}
if|if
condition|(
name|x
condition|)
block|{
name|log_assert
argument_list|(
name|x
operator|==
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_waiting
operator|=
name|p
operator|->
name|next_waiting
expr_stmt|;
else|else
name|outnet
operator|->
name|udp_wait_first
operator|=
name|p
operator|->
name|next_waiting
expr_stmt|;
if|if
condition|(
name|outnet
operator|->
name|udp_wait_last
operator|==
name|p
condition|)
name|outnet
operator|->
name|udp_wait_last
operator|=
name|prev
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outnet
condition|)
block|{
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|outnet
operator|->
name|pending
argument_list|,
name|p
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|timer
condition|)
name|comm_timer_delete
argument_list|(
name|p
operator|->
name|timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|pkt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/**  * Try to open a UDP socket for outgoing communication.  * Sets sockets options as needed.  * @param addr: socket address.  * @param addrlen: length of address.  * @param port: port override for addr.  * @param inuse: if -1 is returned, this bool means the port was in use.  * @return fd or -1  */
specifier|static
name|int
name|udp_sockport
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|port
parameter_list|,
name|int
modifier|*
name|inuse
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|noproto
decl_stmt|;
if|if
condition|(
name|addr_is_ip6
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sa
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
decl_stmt|;
name|sa
operator|->
name|sin6_port
operator|=
operator|(
name|in_port_t
operator|)
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|port
argument_list|)
expr_stmt|;
name|fd
operator|=
name|create_udp_sock
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|,
literal|1
argument_list|,
name|inuse
argument_list|,
operator|&
name|noproto
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sockaddr_in
modifier|*
name|sa
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
decl_stmt|;
name|sa
operator|->
name|sin_port
operator|=
operator|(
name|in_port_t
operator|)
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|port
argument_list|)
expr_stmt|;
name|fd
operator|=
name|create_udp_sock
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|,
literal|1
argument_list|,
name|inuse
argument_list|,
operator|&
name|noproto
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
comment|/** Select random ID */
specifier|static
name|int
name|select_id
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|pending
modifier|*
name|pend
parameter_list|,
name|sldns_buffer
modifier|*
name|packet
parameter_list|)
block|{
name|int
name|id_tries
init|=
literal|0
decl_stmt|;
name|pend
operator|->
name|id
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|ub_random
argument_list|(
name|outnet
operator|->
name|rnd
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|LDNS_ID_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|pend
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* insert in tree */
name|pend
operator|->
name|node
operator|.
name|key
operator|=
name|pend
expr_stmt|;
while|while
condition|(
operator|!
name|rbtree_insert
argument_list|(
name|outnet
operator|->
name|pending
argument_list|,
operator|&
name|pend
operator|->
name|node
argument_list|)
condition|)
block|{
comment|/* change ID to avoid collision */
name|pend
operator|->
name|id
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|ub_random
argument_list|(
name|outnet
operator|->
name|rnd
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|LDNS_ID_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|pend
operator|->
name|id
argument_list|)
expr_stmt|;
name|id_tries
operator|++
expr_stmt|;
if|if
condition|(
name|id_tries
operator|==
name|MAX_ID_RETRY
condition|)
block|{
name|pend
operator|->
name|id
operator|=
literal|99999
expr_stmt|;
comment|/* non existant ID */
name|log_err
argument_list|(
literal|"failed to generate unique ID, drop msg"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"inserted new pending reply id=%4.4x"
argument_list|,
name|pend
operator|->
name|id
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/** Select random interface and port */
specifier|static
name|int
name|select_ifport
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|pending
modifier|*
name|pend
parameter_list|,
name|int
name|num_if
parameter_list|,
name|struct
name|port_if
modifier|*
name|ifs
parameter_list|)
block|{
name|int
name|my_if
decl_stmt|,
name|my_port
decl_stmt|,
name|fd
decl_stmt|,
name|portno
decl_stmt|,
name|inuse
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|struct
name|port_if
modifier|*
name|pif
decl_stmt|;
comment|/* randomly select interface and port */
if|if
condition|(
name|num_if
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Need to send query but have no "
literal|"outgoing interfaces of that family"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_assert
argument_list|(
name|outnet
operator|->
name|unused_fds
argument_list|)
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|my_if
operator|=
name|ub_random_max
argument_list|(
name|outnet
operator|->
name|rnd
argument_list|,
name|num_if
argument_list|)
expr_stmt|;
name|pif
operator|=
operator|&
name|ifs
index|[
name|my_if
index|]
expr_stmt|;
name|my_port
operator|=
name|ub_random_max
argument_list|(
name|outnet
operator|->
name|rnd
argument_list|,
name|pif
operator|->
name|avail_total
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_port
operator|<
name|pif
operator|->
name|inuse
condition|)
block|{
comment|/* port already open */
name|pend
operator|->
name|pc
operator|=
name|pif
operator|->
name|out
index|[
name|my_port
index|]
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"using UDP if=%d port=%d"
argument_list|,
name|my_if
argument_list|,
name|pend
operator|->
name|pc
operator|->
name|number
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* try to open new port, if fails, loop to try again */
name|log_assert
argument_list|(
name|pif
operator|->
name|inuse
operator|<
name|pif
operator|->
name|maxout
argument_list|)
expr_stmt|;
name|portno
operator|=
name|pif
operator|->
name|avail_ports
index|[
name|my_port
operator|-
name|pif
operator|->
name|inuse
index|]
expr_stmt|;
name|fd
operator|=
name|udp_sockport
argument_list|(
operator|&
name|pif
operator|->
name|addr
argument_list|,
name|pif
operator|->
name|addrlen
argument_list|,
name|portno
argument_list|,
operator|&
name|inuse
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
operator|!
name|inuse
condition|)
block|{
comment|/* nonrecoverable error making socket */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"opened UDP if=%d port=%d"
argument_list|,
name|my_if
argument_list|,
name|portno
argument_list|)
expr_stmt|;
comment|/* grab fd */
name|pend
operator|->
name|pc
operator|=
name|outnet
operator|->
name|unused_fds
expr_stmt|;
name|outnet
operator|->
name|unused_fds
operator|=
name|pend
operator|->
name|pc
operator|->
name|next
expr_stmt|;
comment|/* setup portcomm */
name|pend
operator|->
name|pc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|pc
operator|->
name|number
operator|=
name|portno
expr_stmt|;
name|pend
operator|->
name|pc
operator|->
name|pif
operator|=
name|pif
expr_stmt|;
name|pend
operator|->
name|pc
operator|->
name|index
operator|=
name|pif
operator|->
name|inuse
expr_stmt|;
name|pend
operator|->
name|pc
operator|->
name|num_outstanding
operator|=
literal|0
expr_stmt|;
name|comm_point_start_listening
argument_list|(
name|pend
operator|->
name|pc
operator|->
name|cp
argument_list|,
name|fd
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* grab port in interface */
name|pif
operator|->
name|out
index|[
name|pif
operator|->
name|inuse
index|]
operator|=
name|pend
operator|->
name|pc
expr_stmt|;
name|pif
operator|->
name|avail_ports
index|[
name|my_port
operator|-
name|pif
operator|->
name|inuse
index|]
operator|=
name|pif
operator|->
name|avail_ports
index|[
name|pif
operator|->
name|avail_total
operator|-
name|pif
operator|->
name|inuse
operator|-
literal|1
index|]
expr_stmt|;
name|pif
operator|->
name|inuse
operator|++
expr_stmt|;
break|break;
block|}
comment|/* failed, already in use */
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"port %d in use, trying another"
argument_list|,
name|portno
argument_list|)
expr_stmt|;
name|tries
operator|++
expr_stmt|;
if|if
condition|(
name|tries
operator|==
name|MAX_PORT_RETRY
condition|)
block|{
name|log_err
argument_list|(
literal|"failed to find an open port, drop msg"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|log_assert
argument_list|(
name|pend
operator|->
name|pc
argument_list|)
expr_stmt|;
name|pend
operator|->
name|pc
operator|->
name|num_outstanding
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|static
name|int
name|randomize_and_send_udp
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|pending
modifier|*
name|pend
parameter_list|,
name|sldns_buffer
modifier|*
name|packet
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* select id */
if|if
condition|(
operator|!
name|select_id
argument_list|(
name|outnet
argument_list|,
name|pend
argument_list|,
name|packet
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* select src_if, port */
if|if
condition|(
name|addr_is_ip6
argument_list|(
operator|&
name|pend
operator|->
name|addr
argument_list|,
name|pend
operator|->
name|addrlen
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|select_ifport
argument_list|(
name|outnet
argument_list|,
name|pend
argument_list|,
name|outnet
operator|->
name|num_ip6
argument_list|,
name|outnet
operator|->
name|ip6_ifs
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|select_ifport
argument_list|(
name|outnet
argument_list|,
name|pend
argument_list|,
name|outnet
operator|->
name|num_ip4
argument_list|,
name|outnet
operator|->
name|ip4_ifs
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|log_assert
argument_list|(
name|pend
operator|->
name|pc
operator|&&
name|pend
operator|->
name|pc
operator|->
name|cp
argument_list|)
expr_stmt|;
comment|/* send it over the commlink */
if|if
condition|(
operator|!
name|comm_point_send_udp_msg
argument_list|(
name|pend
operator|->
name|pc
operator|->
name|cp
argument_list|,
name|packet
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|pend
operator|->
name|addr
argument_list|,
name|pend
operator|->
name|addrlen
argument_list|)
condition|)
block|{
name|portcomm_loweruse
argument_list|(
name|outnet
argument_list|,
name|pend
operator|->
name|pc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* system calls to set timeout after sending UDP to make roundtrip 	   smaller. */
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|tv
operator|.
name|tv_sec
operator|=
name|timeout
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
endif|#
directive|endif
name|comm_timer_set
argument_list|(
name|pend
operator|->
name|timer
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|struct
name|pending
modifier|*
name|pending_udp_query
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|sldns_buffer
modifier|*
name|packet
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|timeout
parameter_list|,
name|comm_point_callback_t
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|pend
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pend
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pend
condition|)
return|return
name|NULL
return|;
name|pend
operator|->
name|outnet
operator|=
name|outnet
expr_stmt|;
name|pend
operator|->
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|pend
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|pend
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|pend
operator|->
name|cb_arg
operator|=
name|cb_arg
expr_stmt|;
name|pend
operator|->
name|node
operator|.
name|key
operator|=
name|pend
expr_stmt|;
name|pend
operator|->
name|timer
operator|=
name|comm_timer_create
argument_list|(
name|outnet
operator|->
name|base
argument_list|,
name|pending_udp_timer_cb
argument_list|,
name|pend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pend
operator|->
name|timer
condition|)
block|{
name|free
argument_list|(
name|pend
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|outnet
operator|->
name|unused_fds
operator|==
name|NULL
condition|)
block|{
comment|/* no unused fd, cannot create a new port (randomly) */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"no fds available, udp query waiting"
argument_list|)
expr_stmt|;
name|pend
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|pend
operator|->
name|pkt_len
operator|=
name|sldns_buffer_limit
argument_list|(
name|packet
argument_list|)
expr_stmt|;
name|pend
operator|->
name|pkt
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|memdup
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|pend
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pend
operator|->
name|pkt
condition|)
block|{
name|comm_timer_delete
argument_list|(
name|pend
operator|->
name|timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pend
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* put at end of waiting list */
if|if
condition|(
name|outnet
operator|->
name|udp_wait_last
condition|)
name|outnet
operator|->
name|udp_wait_last
operator|->
name|next_waiting
operator|=
name|pend
expr_stmt|;
else|else
name|outnet
operator|->
name|udp_wait_first
operator|=
name|pend
expr_stmt|;
name|outnet
operator|->
name|udp_wait_last
operator|=
name|pend
expr_stmt|;
return|return
name|pend
return|;
block|}
if|if
condition|(
operator|!
name|randomize_and_send_udp
argument_list|(
name|outnet
argument_list|,
name|pend
argument_list|,
name|packet
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
name|pending_delete
argument_list|(
name|outnet
argument_list|,
name|pend
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|pend
return|;
block|}
name|void
name|outnet_tcptimer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|waiting_tcp
modifier|*
name|w
init|=
operator|(
expr|struct
name|waiting_tcp
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|outside_network
modifier|*
name|outnet
init|=
name|w
operator|->
name|outnet
decl_stmt|;
name|comm_point_callback_t
modifier|*
name|cb
decl_stmt|;
name|void
modifier|*
name|cb_arg
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|pkt
condition|)
block|{
comment|/* it is on the waiting list */
name|struct
name|waiting_tcp
modifier|*
name|p
init|=
name|outnet
operator|->
name|tcp_wait_first
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|w
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_waiting
operator|=
name|w
operator|->
name|next_waiting
expr_stmt|;
else|else
name|outnet
operator|->
name|tcp_wait_first
operator|=
name|w
operator|->
name|next_waiting
expr_stmt|;
name|outnet
operator|->
name|tcp_wait_last
operator|=
name|prev
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next_waiting
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* it was in use */
name|struct
name|pending_tcp
modifier|*
name|pend
init|=
operator|(
expr|struct
name|pending_tcp
operator|*
operator|)
name|w
operator|->
name|next_waiting
decl_stmt|;
name|comm_point_close
argument_list|(
name|pend
operator|->
name|c
argument_list|)
expr_stmt|;
name|pend
operator|->
name|query
operator|=
name|NULL
expr_stmt|;
name|pend
operator|->
name|next_free
operator|=
name|outnet
operator|->
name|tcp_free
expr_stmt|;
name|outnet
operator|->
name|tcp_free
operator|=
name|pend
expr_stmt|;
block|}
name|cb
operator|=
name|w
operator|->
name|cb
expr_stmt|;
name|cb_arg
operator|=
name|w
operator|->
name|cb_arg
expr_stmt|;
name|waiting_tcp_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_pending_tcp
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|cb
argument_list|)
argument_list|(
name|NULL
argument_list|,
name|cb_arg
argument_list|,
name|NETEVENT_TIMEOUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|use_free_buffer
argument_list|(
name|outnet
argument_list|)
expr_stmt|;
block|}
name|struct
name|waiting_tcp
modifier|*
name|pending_tcp_query
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|sldns_buffer
modifier|*
name|packet
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|timeout
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|,
name|int
name|ssl_upstream
parameter_list|)
block|{
name|struct
name|pending_tcp
modifier|*
name|pend
init|=
name|outnet
operator|->
name|tcp_free
decl_stmt|;
name|struct
name|waiting_tcp
modifier|*
name|w
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|uint16_t
name|id
decl_stmt|;
comment|/* if no buffer is free allocate space to store query */
name|w
operator|=
operator|(
expr|struct
name|waiting_tcp
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|waiting_tcp
argument_list|)
operator|+
operator|(
name|pend
condition|?
literal|0
else|:
name|sldns_buffer_limit
argument_list|(
name|packet
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|timer
operator|=
name|comm_timer_create
argument_list|(
name|outnet
operator|->
name|base
argument_list|,
name|outnet_tcptimer
argument_list|,
name|w
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|w
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|pkt_len
operator|=
literal|0
expr_stmt|;
name|id
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|ub_random
argument_list|(
name|outnet
operator|->
name|rnd
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|LDNS_ID_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|w
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|w
operator|->
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|w
operator|->
name|outnet
operator|=
name|outnet
expr_stmt|;
name|w
operator|->
name|cb
operator|=
name|callback
expr_stmt|;
name|w
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
name|w
operator|->
name|ssl_upstream
operator|=
name|ssl_upstream
expr_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|tv
operator|.
name|tv_sec
operator|=
name|timeout
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|comm_timer_set
argument_list|(
name|w
operator|->
name|timer
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
condition|)
block|{
comment|/* we have a buffer available right now */
if|if
condition|(
operator|!
name|outnet_tcp_take_into_use
argument_list|(
name|w
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|packet
argument_list|)
argument_list|)
condition|)
block|{
name|waiting_tcp_delete
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
comment|/* queue up */
name|w
operator|->
name|pkt
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|w
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|waiting_tcp
argument_list|)
expr_stmt|;
name|w
operator|->
name|pkt_len
operator|=
name|sldns_buffer_limit
argument_list|(
name|packet
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|w
operator|->
name|pkt
argument_list|,
name|sldns_buffer_begin
argument_list|(
name|packet
argument_list|)
argument_list|,
name|w
operator|->
name|pkt_len
argument_list|)
expr_stmt|;
name|w
operator|->
name|next_waiting
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|outnet
operator|->
name|tcp_wait_last
condition|)
name|outnet
operator|->
name|tcp_wait_last
operator|->
name|next_waiting
operator|=
name|w
expr_stmt|;
else|else
name|outnet
operator|->
name|tcp_wait_first
operator|=
name|w
expr_stmt|;
name|outnet
operator|->
name|tcp_wait_last
operator|=
name|w
expr_stmt|;
block|}
return|return
name|w
return|;
block|}
comment|/** create query for serviced queries */
specifier|static
name|void
name|serviced_gen_query
parameter_list|(
name|sldns_buffer
modifier|*
name|buff
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|sldns_buffer_clear
argument_list|(
name|buff
argument_list|)
expr_stmt|;
comment|/* skip id */
name|sldns_buffer_write_u16
argument_list|(
name|buff
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* qdcount */
name|sldns_buffer_write_u16
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ancount */
name|sldns_buffer_write_u16
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* nscount */
name|sldns_buffer_write_u16
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* arcount */
name|sldns_buffer_write
argument_list|(
name|buff
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|buff
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|buff
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
comment|/** lookup serviced query in serviced query rbtree */
specifier|static
name|struct
name|serviced_query
modifier|*
name|lookup_serviced
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|sldns_buffer
modifier|*
name|buff
parameter_list|,
name|int
name|dnssec
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|struct
name|serviced_query
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|qbuf
operator|=
name|sldns_buffer_begin
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|key
operator|.
name|qbuflen
operator|=
name|sldns_buffer_limit
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|key
operator|.
name|dnssec
operator|=
name|dnssec
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
operator|.
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|key
operator|.
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|key
operator|.
name|outnet
operator|=
name|outnet
expr_stmt|;
return|return
operator|(
expr|struct
name|serviced_query
operator|*
operator|)
name|rbtree_search
argument_list|(
name|outnet
operator|->
name|serviced
argument_list|,
operator|&
name|key
argument_list|)
return|;
block|}
comment|/** Create new serviced entry */
specifier|static
name|struct
name|serviced_query
modifier|*
name|serviced_create
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|sldns_buffer
modifier|*
name|buff
parameter_list|,
name|int
name|dnssec
parameter_list|,
name|int
name|want_dnssec
parameter_list|,
name|int
name|tcp_upstream
parameter_list|,
name|int
name|ssl_upstream
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|zone
parameter_list|,
name|size_t
name|zonelen
parameter_list|,
name|int
name|qtype
parameter_list|)
block|{
name|struct
name|serviced_query
modifier|*
name|sq
init|=
operator|(
expr|struct
name|serviced_query
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sq
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|rbnode_t
modifier|*
name|ins
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|sq
condition|)
return|return
name|NULL
return|;
name|sq
operator|->
name|node
operator|.
name|key
operator|=
name|sq
expr_stmt|;
name|sq
operator|->
name|qbuf
operator|=
name|memdup
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|buff
argument_list|)
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sq
operator|->
name|qbuf
condition|)
block|{
name|free
argument_list|(
name|sq
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sq
operator|->
name|qbuflen
operator|=
name|sldns_buffer_limit
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|sq
operator|->
name|zone
operator|=
name|memdup
argument_list|(
name|zone
argument_list|,
name|zonelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sq
operator|->
name|zone
condition|)
block|{
name|free
argument_list|(
name|sq
operator|->
name|qbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sq
operator|->
name|zonelen
operator|=
name|zonelen
expr_stmt|;
name|sq
operator|->
name|qtype
operator|=
name|qtype
expr_stmt|;
name|sq
operator|->
name|dnssec
operator|=
name|dnssec
expr_stmt|;
name|sq
operator|->
name|want_dnssec
operator|=
name|want_dnssec
expr_stmt|;
name|sq
operator|->
name|tcp_upstream
operator|=
name|tcp_upstream
expr_stmt|;
name|sq
operator|->
name|ssl_upstream
operator|=
name|ssl_upstream
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|sq
operator|->
name|addrlen
operator|=
name|addrlen
expr_stmt|;
name|sq
operator|->
name|outnet
operator|=
name|outnet
expr_stmt|;
name|sq
operator|->
name|cblist
operator|=
name|NULL
expr_stmt|;
name|sq
operator|->
name|pending
operator|=
name|NULL
expr_stmt|;
name|sq
operator|->
name|status
operator|=
name|serviced_initial
expr_stmt|;
name|sq
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
name|sq
operator|->
name|to_be_deleted
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|ins
operator|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_insert
argument_list|(
name|outnet
operator|->
name|serviced
argument_list|,
operator|&
name|sq
operator|->
name|node
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|ins
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* must not be already present */
return|return
name|sq
return|;
block|}
comment|/** remove waiting tcp from the outnet waiting list */
specifier|static
name|void
name|waiting_list_remove
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|waiting_tcp
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|waiting_tcp
modifier|*
name|p
init|=
name|outnet
operator|->
name|tcp_wait_first
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|w
condition|)
block|{
comment|/* remove w */
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next_waiting
operator|=
name|w
operator|->
name|next_waiting
expr_stmt|;
else|else
name|outnet
operator|->
name|tcp_wait_first
operator|=
name|w
operator|->
name|next_waiting
expr_stmt|;
if|if
condition|(
name|outnet
operator|->
name|tcp_wait_last
operator|==
name|w
condition|)
name|outnet
operator|->
name|tcp_wait_last
operator|=
name|prev
expr_stmt|;
return|return;
block|}
name|prev
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next_waiting
expr_stmt|;
block|}
block|}
comment|/** cleanup serviced query entry */
specifier|static
name|void
name|serviced_delete
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|)
block|{
if|if
condition|(
name|sq
operator|->
name|pending
condition|)
block|{
comment|/* clear up the pending query */
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_PROBE_EDNS
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_FRAG
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_fallback
condition|)
block|{
name|struct
name|pending
modifier|*
name|p
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|sq
operator|->
name|pending
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pc
condition|)
name|portcomm_loweruse
argument_list|(
name|sq
operator|->
name|outnet
argument_list|,
name|p
operator|->
name|pc
argument_list|)
expr_stmt|;
name|pending_delete
argument_list|(
name|sq
operator|->
name|outnet
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* this call can cause reentrant calls back into the 			 * mesh */
name|outnet_send_wait_udp
argument_list|(
name|sq
operator|->
name|outnet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|waiting_tcp
modifier|*
name|p
init|=
operator|(
expr|struct
name|waiting_tcp
operator|*
operator|)
name|sq
operator|->
name|pending
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pkt
operator|==
name|NULL
condition|)
block|{
name|decomission_pending_tcp
argument_list|(
name|sq
operator|->
name|outnet
argument_list|,
operator|(
expr|struct
name|pending_tcp
operator|*
operator|)
name|p
operator|->
name|next_waiting
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|waiting_list_remove
argument_list|(
name|sq
operator|->
name|outnet
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|waiting_tcp_delete
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* does not delete from tree, caller has to do that */
name|serviced_node_del
argument_list|(
operator|&
name|sq
operator|->
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/** perturb a dname capitalization randomly */
specifier|static
name|void
name|serviced_perturb_qname
parameter_list|(
name|struct
name|ub_randstate
modifier|*
name|rnd
parameter_list|,
name|uint8_t
modifier|*
name|qbuf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint8_t
name|lablen
decl_stmt|;
name|uint8_t
modifier|*
name|d
init|=
name|qbuf
operator|+
literal|10
decl_stmt|;
name|long
name|int
name|random
init|=
literal|0
decl_stmt|;
name|int
name|bits
init|=
literal|0
decl_stmt|;
name|log_assert
argument_list|(
name|len
operator|>=
literal|10
operator|+
literal|5
comment|/* offset qname, root, qtype, qclass */
argument_list|)
expr_stmt|;
name|lablen
operator|=
operator|*
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|lablen
condition|)
block|{
while|while
condition|(
name|lablen
operator|--
condition|)
block|{
comment|/* only perturb A-Z, a-z */
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|int
operator|)
operator|*
name|d
argument_list|)
condition|)
block|{
comment|/* get a random bit */
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
block|{
name|random
operator|=
name|ub_random
argument_list|(
name|rnd
argument_list|)
expr_stmt|;
name|bits
operator|=
literal|30
expr_stmt|;
block|}
if|if
condition|(
name|random
operator|&
literal|0x1
condition|)
block|{
operator|*
name|d
operator|=
operator|(
name|uint8_t
operator|)
name|toupper
argument_list|(
operator|(
name|int
operator|)
operator|*
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|=
operator|(
name|uint8_t
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
operator|*
name|d
argument_list|)
expr_stmt|;
block|}
name|random
operator|>>=
literal|1
expr_stmt|;
name|bits
operator|--
expr_stmt|;
block|}
name|d
operator|++
expr_stmt|;
block|}
name|lablen
operator|=
operator|*
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
block|{
name|char
name|buf
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
name|dname_str
argument_list|(
name|qbuf
operator|+
literal|10
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"qname perturbed to %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** put serviced query into a buffer */
specifier|static
name|void
name|serviced_encode
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|sldns_buffer
modifier|*
name|buff
parameter_list|,
name|int
name|with_edns
parameter_list|)
block|{
comment|/* if we are using 0x20 bits for ID randomness, perturb them */
if|if
condition|(
name|sq
operator|->
name|outnet
operator|->
name|use_caps_for_id
condition|)
block|{
name|serviced_perturb_qname
argument_list|(
name|sq
operator|->
name|outnet
operator|->
name|rnd
argument_list|,
name|sq
operator|->
name|qbuf
argument_list|,
name|sq
operator|->
name|qbuflen
argument_list|)
expr_stmt|;
block|}
comment|/* generate query */
name|sldns_buffer_clear
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* id placeholder */
name|sldns_buffer_write
argument_list|(
name|buff
argument_list|,
name|sq
operator|->
name|qbuf
argument_list|,
name|sq
operator|->
name|qbuflen
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_edns
condition|)
block|{
comment|/* add edns section */
name|struct
name|edns_data
name|edns
decl_stmt|;
name|edns
operator|.
name|edns_present
operator|=
literal|1
expr_stmt|;
name|edns
operator|.
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|.
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_FRAG
condition|)
block|{
if|if
condition|(
name|addr_is_ip6
argument_list|(
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|EDNS_FRAG_SIZE_IP6
operator|<
name|EDNS_ADVERTISED_SIZE
condition|)
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_FRAG_SIZE_IP6
expr_stmt|;
else|else
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|EDNS_FRAG_SIZE_IP4
operator|<
name|EDNS_ADVERTISED_SIZE
condition|)
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_FRAG_SIZE_IP4
expr_stmt|;
else|else
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
block|}
block|}
else|else
block|{
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
block|}
name|edns
operator|.
name|bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|dnssec
operator|&
name|EDNS_DO
condition|)
name|edns
operator|.
name|bits
operator|=
name|EDNS_DO
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|dnssec
operator|&
name|BIT_CD
condition|)
name|LDNS_CD_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|attach_edns_record
argument_list|(
name|buff
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Perform serviced query UDP sending operation.  * Sends UDP with EDNS, unless infra host marked non EDNS.  * @param sq: query to send.  * @param buff: buffer scratch space.  * @return 0 on error.  */
specifier|static
name|int
name|serviced_udp_send
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|sldns_buffer
modifier|*
name|buff
parameter_list|)
block|{
name|int
name|rtt
decl_stmt|,
name|vs
decl_stmt|;
name|uint8_t
name|edns_lame_known
decl_stmt|;
name|time_t
name|now
init|=
operator|*
name|sq
operator|->
name|outnet
operator|->
name|now_secs
decl_stmt|;
if|if
condition|(
operator|!
name|infra_host
argument_list|(
name|sq
operator|->
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|,
name|now
argument_list|,
operator|&
name|vs
argument_list|,
operator|&
name|edns_lame_known
argument_list|,
operator|&
name|rtt
argument_list|)
condition|)
return|return
literal|0
return|;
name|sq
operator|->
name|last_rtt
operator|=
name|rtt
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"EDNS lookup known=%d vs=%d"
argument_list|,
name|edns_lame_known
argument_list|,
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_initial
condition|)
block|{
if|if
condition|(
name|edns_lame_known
operator|==
literal|0
operator|&&
name|rtt
operator|>
literal|5000
operator|&&
name|rtt
operator|<
literal|10001
condition|)
block|{
comment|/* perform EDNS lame probe - check if server is 			 * EDNS lame (EDNS queries to it are dropped) */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"serviced query: send probe to see "
literal|" if use of EDNS causes timeouts"
argument_list|)
expr_stmt|;
comment|/* even 700 msec may be too small */
name|rtt
operator|=
literal|1000
expr_stmt|;
name|sq
operator|->
name|status
operator|=
name|serviced_query_PROBE_EDNS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vs
operator|!=
operator|-
literal|1
condition|)
block|{
name|sq
operator|->
name|status
operator|=
name|serviced_query_UDP_EDNS
expr_stmt|;
block|}
else|else
block|{
name|sq
operator|->
name|status
operator|=
name|serviced_query_UDP
expr_stmt|;
block|}
block|}
name|serviced_encode
argument_list|(
name|sq
argument_list|,
name|buff
argument_list|,
operator|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS
operator|)
operator|||
operator|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_FRAG
operator|)
argument_list|)
expr_stmt|;
name|sq
operator|->
name|last_sent_time
operator|=
operator|*
name|sq
operator|->
name|outnet
operator|->
name|now_tv
expr_stmt|;
name|sq
operator|->
name|edns_lame_known
operator|=
operator|(
name|int
operator|)
name|edns_lame_known
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"serviced query UDP timeout=%d msec"
argument_list|,
name|rtt
argument_list|)
expr_stmt|;
name|sq
operator|->
name|pending
operator|=
name|pending_udp_query
argument_list|(
name|sq
operator|->
name|outnet
argument_list|,
name|buff
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|rtt
argument_list|,
name|serviced_udp_callback
argument_list|,
name|sq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sq
operator|->
name|pending
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/** check that perturbed qname is identical */
specifier|static
name|int
name|serviced_check_qname
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|uint8_t
modifier|*
name|qbuf
parameter_list|,
name|size_t
name|qbuflen
parameter_list|)
block|{
name|uint8_t
modifier|*
name|d1
init|=
name|sldns_buffer_at
argument_list|(
name|pkt
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|d2
init|=
name|qbuf
operator|+
literal|10
decl_stmt|;
name|uint8_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|log_assert
argument_list|(
name|qbuflen
operator|>=
literal|15
comment|/* 10 header, root, type, class */
argument_list|)
expr_stmt|;
name|len1
operator|=
operator|*
name|d1
operator|++
expr_stmt|;
name|len2
operator|=
operator|*
name|d2
operator|++
expr_stmt|;
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
operator|<
literal|12
operator|+
literal|1
operator|+
literal|4
condition|)
comment|/* packet too small for qname */
return|return
literal|0
return|;
while|while
condition|(
name|len1
operator|!=
literal|0
operator|||
name|len2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|LABEL_IS_PTR
argument_list|(
name|len1
argument_list|)
condition|)
block|{
name|d1
operator|=
name|sldns_buffer_at
argument_list|(
name|pkt
argument_list|,
name|PTR_OFFSET
argument_list|(
name|len1
argument_list|,
operator|*
name|d1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|>=
name|sldns_buffer_at
argument_list|(
name|pkt
argument_list|,
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|len1
operator|=
operator|*
name|d1
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|++
operator|>
name|MAX_COMPRESS_PTRS
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
if|if
condition|(
name|d2
operator|>
name|qbuf
operator|+
name|qbuflen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len1
operator|!=
name|len2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len1
operator|>
name|LDNS_MAX_LABELLEN
condition|)
return|return
literal|0
return|;
name|log_assert
argument_list|(
name|len1
operator|<=
name|LDNS_MAX_LABELLEN
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|len2
operator|<=
name|LDNS_MAX_LABELLEN
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|len1
operator|==
name|len2
operator|&&
name|len1
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* compare the labels - bitwise identical */
if|if
condition|(
name|memcmp
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|,
name|len1
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|d1
operator|+=
name|len1
expr_stmt|;
name|d2
operator|+=
name|len2
expr_stmt|;
name|len1
operator|=
operator|*
name|d1
operator|++
expr_stmt|;
name|len2
operator|=
operator|*
name|d2
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/** call the callbacks for a serviced query */
specifier|static
name|void
name|serviced_callbacks
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|service_callback
modifier|*
name|p
decl_stmt|;
name|int
name|dobackup
init|=
operator|(
name|sq
operator|->
name|cblist
operator|&&
name|sq
operator|->
name|cblist
operator|->
name|next
operator|)
decl_stmt|;
comment|/*>1 cb*/
name|uint8_t
modifier|*
name|backup_p
init|=
name|NULL
decl_stmt|;
name|size_t
name|backlen
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|rbnode_t
modifier|*
name|rem
init|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
comment|/* remove from tree, and schedule for deletion, so that callbacks 	 * can safely deregister themselves and even create new serviced 	 * queries that are identical to this one. */
name|rbtree_delete
argument_list|(
name|sq
operator|->
name|outnet
operator|->
name|serviced
argument_list|,
name|sq
argument_list|)
decl_stmt|;
name|log_assert
argument_list|(
name|rem
argument_list|)
expr_stmt|;
comment|/* should have been present */
name|sq
operator|->
name|to_be_deleted
operator|=
literal|1
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"svcd callbacks start"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|outnet
operator|->
name|use_caps_for_id
operator|&&
name|error
operator|==
name|NETEVENT_NOERROR
operator|&&
name|c
condition|)
block|{
comment|/* noerror and nxdomain must have a qname in reply */
if|if
condition|(
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_NOERROR
operator|||
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_NXDOMAIN
operator|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"no qname in reply to check 0x20ID"
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"from server"
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|log_buf
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"for packet"
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|error
operator|=
name|NETEVENT_CLOSED
expr_stmt|;
name|c
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|4
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|serviced_check_qname
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|sq
operator|->
name|qbuf
argument_list|,
name|sq
operator|->
name|qbuflen
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"wrong 0x20-ID in reply qname"
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"from server"
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|log_buf
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"for packet"
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|error
operator|=
name|NETEVENT_CAPSFAIL
expr_stmt|;
comment|/* and cleanup too */
name|pkt_dname_tolower
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|sldns_buffer_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"good 0x20-ID in reply qname"
argument_list|)
expr_stmt|;
comment|/* cleanup caps, prettier cache contents. */
name|pkt_dname_tolower
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|sldns_buffer_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dobackup
operator|&&
name|c
condition|)
block|{
comment|/* make a backup of the query, since the querystate processing 		 * may send outgoing queries that overwrite the buffer. 		 * use secondary buffer to store the query. 		 * This is a data copy, but faster than packet to server */
name|backlen
operator|=
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|backup_p
operator|=
name|memdup
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|backlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|backup_p
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure in serviced query callbacks"
argument_list|)
expr_stmt|;
name|error
operator|=
name|NETEVENT_CLOSED
expr_stmt|;
name|c
operator|=
name|NULL
expr_stmt|;
block|}
name|sq
operator|->
name|outnet
operator|->
name|svcd_overhead
operator|=
name|backlen
expr_stmt|;
block|}
comment|/* test the actual sq->cblist, because the next elem could be deleted*/
while|while
condition|(
operator|(
name|p
operator|=
name|sq
operator|->
name|cblist
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sq
operator|->
name|cblist
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* remove this element */
if|if
condition|(
name|dobackup
operator|&&
name|c
condition|)
block|{
name|sldns_buffer_clear
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|backup_p
argument_list|,
name|backlen
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|fptr_ok
argument_list|(
name|fptr_whitelist_serviced_query
argument_list|(
name|p
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|p
operator|->
name|cb
argument_list|)
argument_list|(
name|c
argument_list|,
name|p
operator|->
name|cb_arg
argument_list|,
name|error
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|backup_p
condition|)
block|{
name|free
argument_list|(
name|backup_p
argument_list|)
expr_stmt|;
name|sq
operator|->
name|outnet
operator|->
name|svcd_overhead
operator|=
literal|0
expr_stmt|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"svcd callbacks end"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|sq
operator|->
name|cblist
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|serviced_delete
argument_list|(
name|sq
argument_list|)
expr_stmt|;
block|}
name|int
name|serviced_tcp_callback
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|serviced_query
modifier|*
name|sq
init|=
operator|(
expr|struct
name|serviced_query
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|comm_reply
name|r2
decl_stmt|;
name|sq
operator|->
name|pending
operator|=
name|NULL
expr_stmt|;
comment|/* removed after this callback */
if|if
condition|(
name|error
operator|!=
name|NETEVENT_NOERROR
condition|)
name|log_addr
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"tcp error for address"
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NETEVENT_NOERROR
condition|)
name|infra_update_tcp_works
argument_list|(
name|sq
operator|->
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NETEVENT_NOERROR
operator|&&
name|sq
operator|->
name|status
operator|==
name|serviced_query_TCP_EDNS
operator|&&
operator|(
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_FORMERR
operator|||
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_NOTIMPL
operator|)
condition|)
block|{
comment|/* attempt to fallback to nonEDNS */
name|sq
operator|->
name|status
operator|=
name|serviced_query_TCP_EDNS_fallback
expr_stmt|;
name|serviced_tcp_initiate
argument_list|(
name|sq
operator|->
name|outnet
argument_list|,
name|sq
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|NETEVENT_NOERROR
operator|&&
name|sq
operator|->
name|status
operator|==
name|serviced_query_TCP_EDNS_fallback
operator|&&
operator|(
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_NOERROR
operator|||
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_NXDOMAIN
operator|||
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_YXDOMAIN
operator|)
condition|)
block|{
comment|/* the fallback produced a result that looks promising, note 		 * that this server should be approached without EDNS */
comment|/* only store noEDNS in cache if domain is noDNSSEC */
if|if
condition|(
operator|!
name|sq
operator|->
name|want_dnssec
condition|)
if|if
condition|(
operator|!
name|infra_edns_update
argument_list|(
name|sq
operator|->
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|,
operator|-
literal|1
argument_list|,
operator|*
name|sq
operator|->
name|outnet
operator|->
name|now_secs
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"Out of memory caching no edns for host"
argument_list|)
expr_stmt|;
name|sq
operator|->
name|status
operator|=
name|serviced_query_TCP
expr_stmt|;
block|}
if|if
condition|(
name|sq
operator|->
name|tcp_upstream
operator|||
name|sq
operator|->
name|ssl_upstream
condition|)
block|{
name|struct
name|timeval
name|now
init|=
operator|*
name|sq
operator|->
name|outnet
operator|->
name|now_tv
decl_stmt|;
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|>
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_sec
operator|||
operator|(
name|now
operator|.
name|tv_sec
operator|==
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_sec
operator|&&
name|now
operator|.
name|tv_usec
operator|>
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_usec
operator|)
condition|)
block|{
comment|/* convert from microseconds to milliseconds */
name|int
name|roundtime
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|now
operator|.
name|tv_sec
operator|-
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_sec
argument_list|)
operator|)
operator|*
literal|1000
operator|+
operator|(
operator|(
name|int
operator|)
name|now
operator|.
name|tv_usec
operator|-
operator|(
name|int
operator|)
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_usec
operator|)
operator|/
literal|1000
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"measured TCP-time at %d msec"
argument_list|,
name|roundtime
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|roundtime
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* only store if less then AUTH_TIMEOUT seconds, it could be 		 * huge due to system-hibernated and we woke up */
if|if
condition|(
name|roundtime
operator|<
name|TCP_AUTH_QUERY_TIMEOUT
operator|*
literal|1000
condition|)
block|{
if|if
condition|(
operator|!
name|infra_rtt_update
argument_list|(
name|sq
operator|->
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|,
name|sq
operator|->
name|qtype
argument_list|,
name|roundtime
argument_list|,
name|sq
operator|->
name|last_rtt
argument_list|,
operator|(
name|time_t
operator|)
name|now
operator|.
name|tv_sec
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"out of memory noting rtt."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* insert address into reply info */
if|if
condition|(
operator|!
name|rep
condition|)
block|{
comment|/* create one if there isn't (on errors) */
name|rep
operator|=
operator|&
name|r2
expr_stmt|;
name|r2
operator|.
name|c
operator|=
name|c
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|rep
operator|->
name|addr
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|rep
operator|->
name|addrlen
operator|=
name|sq
operator|->
name|addrlen
expr_stmt|;
name|serviced_callbacks
argument_list|(
name|sq
argument_list|,
name|error
argument_list|,
name|c
argument_list|,
name|rep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|void
name|serviced_tcp_initiate
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|sldns_buffer
modifier|*
name|buff
parameter_list|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"initiate TCP query %s"
argument_list|,
name|sq
operator|->
name|status
operator|==
name|serviced_query_TCP_EDNS
condition|?
literal|"EDNS"
else|:
literal|""
argument_list|)
expr_stmt|;
name|serviced_encode
argument_list|(
name|sq
argument_list|,
name|buff
argument_list|,
name|sq
operator|->
name|status
operator|==
name|serviced_query_TCP_EDNS
argument_list|)
expr_stmt|;
name|sq
operator|->
name|last_sent_time
operator|=
operator|*
name|sq
operator|->
name|outnet
operator|->
name|now_tv
expr_stmt|;
name|sq
operator|->
name|pending
operator|=
name|pending_tcp_query
argument_list|(
name|outnet
argument_list|,
name|buff
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|TCP_AUTH_QUERY_TIMEOUT
argument_list|,
name|serviced_tcp_callback
argument_list|,
name|sq
argument_list|,
name|sq
operator|->
name|ssl_upstream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sq
operator|->
name|pending
condition|)
block|{
comment|/* delete from tree so that a retry by above layer does not 		 * clash with this entry */
name|log_err
argument_list|(
literal|"serviced_tcp_initiate: failed to send tcp query"
argument_list|)
expr_stmt|;
name|serviced_callbacks
argument_list|(
name|sq
argument_list|,
name|NETEVENT_CLOSED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Send serviced query over TCP return false on initial failure */
specifier|static
name|int
name|serviced_tcp_send
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|sldns_buffer
modifier|*
name|buff
parameter_list|)
block|{
name|int
name|vs
decl_stmt|,
name|rtt
decl_stmt|;
name|uint8_t
name|edns_lame_known
decl_stmt|;
if|if
condition|(
operator|!
name|infra_host
argument_list|(
name|sq
operator|->
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|,
operator|*
name|sq
operator|->
name|outnet
operator|->
name|now_secs
argument_list|,
operator|&
name|vs
argument_list|,
operator|&
name|edns_lame_known
argument_list|,
operator|&
name|rtt
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vs
operator|!=
operator|-
literal|1
condition|)
name|sq
operator|->
name|status
operator|=
name|serviced_query_TCP_EDNS
expr_stmt|;
else|else
name|sq
operator|->
name|status
operator|=
name|serviced_query_TCP
expr_stmt|;
name|serviced_encode
argument_list|(
name|sq
argument_list|,
name|buff
argument_list|,
name|sq
operator|->
name|status
operator|==
name|serviced_query_TCP_EDNS
argument_list|)
expr_stmt|;
name|sq
operator|->
name|last_sent_time
operator|=
operator|*
name|sq
operator|->
name|outnet
operator|->
name|now_tv
expr_stmt|;
name|sq
operator|->
name|pending
operator|=
name|pending_tcp_query
argument_list|(
name|sq
operator|->
name|outnet
argument_list|,
name|buff
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|TCP_AUTH_QUERY_TIMEOUT
argument_list|,
name|serviced_tcp_callback
argument_list|,
name|sq
argument_list|,
name|sq
operator|->
name|ssl_upstream
argument_list|)
expr_stmt|;
return|return
name|sq
operator|->
name|pending
operator|!=
name|NULL
return|;
block|}
name|int
name|serviced_udp_callback
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|serviced_query
modifier|*
name|sq
init|=
operator|(
expr|struct
name|serviced_query
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|outside_network
modifier|*
name|outnet
init|=
name|sq
operator|->
name|outnet
decl_stmt|;
name|struct
name|timeval
name|now
init|=
operator|*
name|sq
operator|->
name|outnet
operator|->
name|now_tv
decl_stmt|;
name|int
name|fallback_tcp
init|=
literal|0
decl_stmt|;
name|sq
operator|->
name|pending
operator|=
name|NULL
expr_stmt|;
comment|/* removed after callback */
if|if
condition|(
name|error
operator|==
name|NETEVENT_TIMEOUT
condition|)
block|{
name|int
name|rto
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_PROBE_EDNS
condition|)
block|{
comment|/* non-EDNS probe failed; we do not know its status, 			 * keep trying with EDNS, timeout may not be caused 			 * by EDNS. */
name|sq
operator|->
name|status
operator|=
name|serviced_query_UDP_EDNS
expr_stmt|;
block|}
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS
operator|&&
name|sq
operator|->
name|last_rtt
operator|<
literal|5000
condition|)
block|{
comment|/* fallback to 1480/1280 */
name|sq
operator|->
name|status
operator|=
name|serviced_query_UDP_EDNS_FRAG
expr_stmt|;
name|log_name_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"try edns1xx0"
argument_list|,
name|sq
operator|->
name|qbuf
operator|+
literal|10
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|serviced_udp_send
argument_list|(
name|sq
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|serviced_callbacks
argument_list|(
name|sq
argument_list|,
name|NETEVENT_CLOSED
argument_list|,
name|c
argument_list|,
name|rep
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_FRAG
condition|)
block|{
comment|/* fragmentation size did not fix it */
name|sq
operator|->
name|status
operator|=
name|serviced_query_UDP_EDNS
expr_stmt|;
block|}
name|sq
operator|->
name|retry
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rto
operator|=
name|infra_rtt_update
argument_list|(
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|,
name|sq
operator|->
name|qtype
argument_list|,
operator|-
literal|1
argument_list|,
name|sq
operator|->
name|last_rtt
argument_list|,
operator|(
name|time_t
operator|)
name|now
operator|.
name|tv_sec
argument_list|)
operator|)
condition|)
name|log_err
argument_list|(
literal|"out of memory in UDP exponential backoff"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|retry
operator|<
name|OUTBOUND_UDP_RETRY
condition|)
block|{
name|log_name_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"retry query"
argument_list|,
name|sq
operator|->
name|qbuf
operator|+
literal|10
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|serviced_udp_send
argument_list|(
name|sq
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|serviced_callbacks
argument_list|(
name|sq
argument_list|,
name|NETEVENT_CLOSED
argument_list|,
name|c
argument_list|,
name|rep
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|rto
operator|>=
name|RTT_MAX_TIMEOUT
condition|)
block|{
name|fallback_tcp
operator|=
literal|1
expr_stmt|;
comment|/* UDP does not work, fallback to TCP below */
block|}
else|else
block|{
name|serviced_callbacks
argument_list|(
name|sq
argument_list|,
name|NETEVENT_TIMEOUT
argument_list|,
name|c
argument_list|,
name|rep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
name|NETEVENT_NOERROR
condition|)
block|{
comment|/* udp returns error (due to no ID or interface available) */
name|serviced_callbacks
argument_list|(
name|sq
argument_list|,
name|error
argument_list|,
name|c
argument_list|,
name|rep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|fallback_tcp
condition|)
block|{
if|if
condition|(
operator|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_FRAG
operator|)
operator|&&
operator|(
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_FORMERR
operator|||
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_NOTIMPL
operator|)
condition|)
block|{
comment|/* try to get an answer by falling back without EDNS */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"serviced query: attempt without EDNS"
argument_list|)
expr_stmt|;
name|sq
operator|->
name|status
operator|=
name|serviced_query_UDP_EDNS_fallback
expr_stmt|;
name|sq
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|serviced_udp_send
argument_list|(
name|sq
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|serviced_callbacks
argument_list|(
name|sq
argument_list|,
name|NETEVENT_CLOSED
argument_list|,
name|c
argument_list|,
name|rep
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_PROBE_EDNS
condition|)
block|{
comment|/* probe without EDNS succeeds, so we conclude that this 		 * host likely has EDNS packets dropped */
name|log_addr
argument_list|(
name|VERB_DETAIL
argument_list|,
literal|"timeouts, concluded that connection to "
literal|"host drops EDNS packets"
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
comment|/* only store noEDNS in cache if domain is noDNSSEC */
if|if
condition|(
operator|!
name|sq
operator|->
name|want_dnssec
condition|)
if|if
condition|(
operator|!
name|infra_edns_update
argument_list|(
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|time_t
operator|)
name|now
operator|.
name|tv_sec
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Out of memory caching no edns for host"
argument_list|)
expr_stmt|;
block|}
name|sq
operator|->
name|status
operator|=
name|serviced_query_UDP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS
operator|&&
operator|!
name|sq
operator|->
name|edns_lame_known
condition|)
block|{
comment|/* now we know that edns queries received answers store that */
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"serviced query: EDNS works for"
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|infra_edns_update
argument_list|(
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|,
literal|0
argument_list|,
operator|(
name|time_t
operator|)
name|now
operator|.
name|tv_sec
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Out of memory caching edns works"
argument_list|)
expr_stmt|;
block|}
name|sq
operator|->
name|edns_lame_known
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_fallback
operator|&&
operator|!
name|sq
operator|->
name|edns_lame_known
operator|&&
operator|(
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_NOERROR
operator|||
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_NXDOMAIN
operator|||
name|LDNS_RCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|==
name|LDNS_RCODE_YXDOMAIN
operator|)
condition|)
block|{
comment|/* the fallback produced a result that looks promising, note 		 * that this server should be approached without EDNS */
comment|/* only store noEDNS in cache if domain is noDNSSEC */
if|if
condition|(
operator|!
name|sq
operator|->
name|want_dnssec
condition|)
block|{
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"serviced query: EDNS fails for"
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|infra_edns_update
argument_list|(
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|time_t
operator|)
name|now
operator|.
name|tv_sec
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Out of memory caching no edns for host"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"serviced query: EDNS fails, but "
literal|"not stored because need DNSSEC for"
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|)
expr_stmt|;
block|}
name|sq
operator|->
name|status
operator|=
name|serviced_query_UDP
expr_stmt|;
block|}
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|>
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_sec
operator|||
operator|(
name|now
operator|.
name|tv_sec
operator|==
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_sec
operator|&&
name|now
operator|.
name|tv_usec
operator|>
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_usec
operator|)
condition|)
block|{
comment|/* convert from microseconds to milliseconds */
name|int
name|roundtime
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|now
operator|.
name|tv_sec
operator|-
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_sec
argument_list|)
operator|)
operator|*
literal|1000
operator|+
operator|(
operator|(
name|int
operator|)
name|now
operator|.
name|tv_usec
operator|-
operator|(
name|int
operator|)
name|sq
operator|->
name|last_sent_time
operator|.
name|tv_usec
operator|)
operator|/
literal|1000
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"measured roundtrip at %d msec"
argument_list|,
name|roundtime
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|roundtime
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* in case the system hibernated, do not enter a huge value, 		 * above this value gives trouble with server selection */
if|if
condition|(
name|roundtime
operator|<
literal|60000
condition|)
block|{
if|if
condition|(
operator|!
name|infra_rtt_update
argument_list|(
name|outnet
operator|->
name|infra
argument_list|,
operator|&
name|sq
operator|->
name|addr
argument_list|,
name|sq
operator|->
name|addrlen
argument_list|,
name|sq
operator|->
name|zone
argument_list|,
name|sq
operator|->
name|zonelen
argument_list|,
name|sq
operator|->
name|qtype
argument_list|,
name|roundtime
argument_list|,
name|sq
operator|->
name|last_rtt
argument_list|,
operator|(
name|time_t
operator|)
name|now
operator|.
name|tv_sec
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"out of memory noting rtt."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* end of if_!fallback_tcp */
comment|/* perform TC flag check and TCP fallback after updating our 	 * cache entries for EDNS status and RTT times */
if|if
condition|(
name|LDNS_TC_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|||
name|fallback_tcp
condition|)
block|{
comment|/* fallback to TCP */
comment|/* this discards partial UDP contents */
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_FRAG
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_fallback
condition|)
comment|/* if we have unfinished EDNS_fallback, start again */
name|sq
operator|->
name|status
operator|=
name|serviced_query_TCP_EDNS
expr_stmt|;
else|else
name|sq
operator|->
name|status
operator|=
name|serviced_query_TCP
expr_stmt|;
name|serviced_tcp_initiate
argument_list|(
name|outnet
argument_list|,
name|sq
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* yay! an answer */
name|serviced_callbacks
argument_list|(
name|sq
argument_list|,
name|error
argument_list|,
name|c
argument_list|,
name|rep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|struct
name|serviced_query
modifier|*
name|outnet_serviced_query
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|int
name|dnssec
parameter_list|,
name|int
name|want_dnssec
parameter_list|,
name|int
name|tcp_upstream
parameter_list|,
name|int
name|ssl_upstream
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|zone
parameter_list|,
name|size_t
name|zonelen
parameter_list|,
name|comm_point_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|,
name|sldns_buffer
modifier|*
name|buff
parameter_list|)
block|{
name|struct
name|serviced_query
modifier|*
name|sq
decl_stmt|;
name|struct
name|service_callback
modifier|*
name|cb
decl_stmt|;
name|serviced_gen_query
argument_list|(
name|buff
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|sq
operator|=
name|lookup_serviced
argument_list|(
name|outnet
argument_list|,
name|buff
argument_list|,
name|dnssec
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
comment|/* duplicate entries are included in the callback list, because 	 * there is a counterpart registration by our caller that needs to 	 * be doubly-removed (with callbacks perhaps). */
if|if
condition|(
operator|!
operator|(
name|cb
operator|=
operator|(
expr|struct
name|service_callback
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cb
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|sq
condition|)
block|{
comment|/* make new serviced query entry */
name|sq
operator|=
name|serviced_create
argument_list|(
name|outnet
argument_list|,
name|buff
argument_list|,
name|dnssec
argument_list|,
name|want_dnssec
argument_list|,
name|tcp_upstream
argument_list|,
name|ssl_upstream
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|zone
argument_list|,
name|zonelen
argument_list|,
operator|(
name|int
operator|)
name|qtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sq
condition|)
block|{
name|free
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* perform first network action */
if|if
condition|(
name|outnet
operator|->
name|do_udp
operator|&&
operator|!
operator|(
name|tcp_upstream
operator|||
name|ssl_upstream
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|serviced_udp_send
argument_list|(
name|sq
argument_list|,
name|buff
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|outnet
operator|->
name|serviced
argument_list|,
name|sq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
operator|->
name|qbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
operator|->
name|zone
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|serviced_tcp_send
argument_list|(
name|sq
argument_list|,
name|buff
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|outnet
operator|->
name|serviced
argument_list|,
name|sq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
operator|->
name|qbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
operator|->
name|zone
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
comment|/* add callback to list of callbacks */
name|cb
operator|->
name|cb
operator|=
name|callback
expr_stmt|;
name|cb
operator|->
name|cb_arg
operator|=
name|callback_arg
expr_stmt|;
name|cb
operator|->
name|next
operator|=
name|sq
operator|->
name|cblist
expr_stmt|;
name|sq
operator|->
name|cblist
operator|=
name|cb
expr_stmt|;
return|return
name|sq
return|;
block|}
comment|/** remove callback from list */
specifier|static
name|void
name|callback_list_remove
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|service_callback
modifier|*
modifier|*
name|pp
init|=
operator|&
name|sq
operator|->
name|cblist
decl_stmt|;
while|while
condition|(
operator|*
name|pp
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|cb_arg
operator|==
name|cb_arg
condition|)
block|{
name|struct
name|service_callback
modifier|*
name|del
init|=
operator|*
name|pp
decl_stmt|;
operator|*
name|pp
operator|=
name|del
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|del
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
block|}
block|}
name|void
name|outnet_serviced_query_stop
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sq
condition|)
return|return;
name|callback_list_remove
argument_list|(
name|sq
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
comment|/* if callbacks() routine scheduled deletion, let it do that */
if|if
condition|(
operator|!
name|sq
operator|->
name|cblist
operator|&&
operator|!
name|sq
operator|->
name|to_be_deleted
condition|)
block|{
ifdef|#
directive|ifdef
name|UNBOUND_DEBUG
name|rbnode_t
modifier|*
name|rem
init|=
else|#
directive|else
operator|(
name|void
operator|)
endif|#
directive|endif
name|rbtree_delete
argument_list|(
name|sq
operator|->
name|outnet
operator|->
name|serviced
argument_list|,
name|sq
argument_list|)
decl_stmt|;
name|log_assert
argument_list|(
name|rem
argument_list|)
expr_stmt|;
comment|/* should be present */
name|serviced_delete
argument_list|(
name|sq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** get memory used by waiting tcp entry (in use or not) */
specifier|static
name|size_t
name|waiting_tcp_get_mem
parameter_list|(
name|struct
name|waiting_tcp
modifier|*
name|w
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
literal|0
return|;
name|s
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|w
argument_list|)
operator|+
name|w
operator|->
name|pkt_len
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|timer
condition|)
name|s
operator|+=
name|comm_timer_get_mem
argument_list|(
name|w
operator|->
name|timer
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/** get memory used by port if */
specifier|static
name|size_t
name|if_get_mem
parameter_list|(
name|struct
name|port_if
modifier|*
name|pif
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pif
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|pif
operator|->
name|avail_total
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|port_comm
operator|*
argument_list|)
operator|*
name|pif
operator|->
name|maxout
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pif
operator|->
name|inuse
condition|;
name|i
operator|++
control|)
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|pif
operator|->
name|out
index|[
name|i
index|]
argument_list|)
operator|+
name|comm_point_get_mem
argument_list|(
name|pif
operator|->
name|out
index|[
name|i
index|]
operator|->
name|cp
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/** get memory used by waiting udp */
specifier|static
name|size_t
name|waiting_udp_get_mem
parameter_list|(
name|struct
name|pending
modifier|*
name|w
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
name|s
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|w
argument_list|)
operator|+
name|comm_timer_get_mem
argument_list|(
name|w
operator|->
name|timer
argument_list|)
operator|+
name|w
operator|->
name|pkt_len
expr_stmt|;
return|return
name|s
return|;
block|}
name|size_t
name|outnet_get_mem
parameter_list|(
name|struct
name|outside_network
modifier|*
name|outnet
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
name|struct
name|waiting_tcp
modifier|*
name|w
decl_stmt|;
name|struct
name|pending
modifier|*
name|u
decl_stmt|;
name|struct
name|serviced_query
modifier|*
name|sq
decl_stmt|;
name|struct
name|service_callback
modifier|*
name|sb
decl_stmt|;
name|struct
name|port_comm
modifier|*
name|pc
decl_stmt|;
name|size_t
name|s
init|=
sizeof|sizeof
argument_list|(
operator|*
name|outnet
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|outnet
operator|->
name|base
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|outnet
operator|->
name|udp_buff
argument_list|)
operator|+
name|sldns_buffer_capacity
argument_list|(
name|outnet
operator|->
name|udp_buff
argument_list|)
decl_stmt|;
comment|/* second buffer is not ours */
for|for
control|(
name|pc
operator|=
name|outnet
operator|->
name|unused_fds
init|;
name|pc
condition|;
name|pc
operator|=
name|pc
operator|->
name|next
control|)
block|{
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|pc
argument_list|)
operator|+
name|comm_point_get_mem
argument_list|(
name|pc
operator|->
name|cp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|outnet
operator|->
name|num_ip4
condition|;
name|k
operator|++
control|)
name|s
operator|+=
name|if_get_mem
argument_list|(
operator|&
name|outnet
operator|->
name|ip4_ifs
index|[
name|k
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|outnet
operator|->
name|num_ip6
condition|;
name|k
operator|++
control|)
name|s
operator|+=
name|if_get_mem
argument_list|(
operator|&
name|outnet
operator|->
name|ip6_ifs
index|[
name|k
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|outnet
operator|->
name|udp_wait_first
init|;
name|u
condition|;
name|u
operator|=
name|u
operator|->
name|next_waiting
control|)
name|s
operator|+=
name|waiting_udp_get_mem
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pending_tcp
operator|*
argument_list|)
operator|*
name|outnet
operator|->
name|num_tcp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outnet
operator|->
name|num_tcp
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pending_tcp
argument_list|)
expr_stmt|;
name|s
operator|+=
name|comm_point_get_mem
argument_list|(
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
operator|->
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
operator|->
name|query
condition|)
name|s
operator|+=
name|waiting_tcp_get_mem
argument_list|(
name|outnet
operator|->
name|tcp_conns
index|[
name|i
index|]
operator|->
name|query
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|w
operator|=
name|outnet
operator|->
name|tcp_wait_first
init|;
name|w
condition|;
name|w
operator|=
name|w
operator|->
name|next_waiting
control|)
name|s
operator|+=
name|waiting_tcp_get_mem
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|outnet
operator|->
name|pending
argument_list|)
expr_stmt|;
name|s
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending
argument_list|)
operator|+
name|comm_timer_get_mem
argument_list|(
name|NULL
argument_list|)
operator|)
operator|*
name|outnet
operator|->
name|pending
operator|->
name|count
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|outnet
operator|->
name|serviced
argument_list|)
expr_stmt|;
name|s
operator|+=
name|outnet
operator|->
name|svcd_overhead
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|sq
argument_list|,
argument|struct serviced_query*
argument_list|,
argument|outnet->serviced
argument_list|)
block|{
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sq
argument_list|)
operator|+
name|sq
operator|->
name|qbuflen
expr_stmt|;
for|for
control|(
name|sb
operator|=
name|sq
operator|->
name|cblist
init|;
name|sb
condition|;
name|sb
operator|=
name|sb
operator|->
name|next
control|)
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
name|size_t
name|serviced_get_mem
parameter_list|(
name|struct
name|serviced_query
modifier|*
name|sq
parameter_list|)
block|{
name|struct
name|service_callback
modifier|*
name|sb
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|s
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sq
argument_list|)
operator|+
name|sq
operator|->
name|qbuflen
expr_stmt|;
for|for
control|(
name|sb
operator|=
name|sq
operator|->
name|cblist
init|;
name|sb
condition|;
name|sb
operator|=
name|sb
operator|->
name|next
control|)
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_PROBE_EDNS
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_FRAG
operator|||
name|sq
operator|->
name|status
operator|==
name|serviced_query_UDP_EDNS_fallback
condition|)
block|{
name|s
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pending
argument_list|)
expr_stmt|;
name|s
operator|+=
name|comm_timer_get_mem
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* does not have size of the pkt pointer */
comment|/* always has a timer except on malloc failures */
comment|/* these sizes are part of the main outside network mem */
comment|/* 		s += sizeof(struct waiting_tcp); 		s += comm_timer_get_mem(NULL); 		*/
block|}
return|return
name|s
return|;
block|}
end_function

end_unit

