begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * services/localzone.c - local zones authority service.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains functions to enable local zone authority service.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"services/localzone.h"
end_include

begin_include
include|#
directive|include
file|"sldns/str2wire.h"
end_include

begin_include
include|#
directive|include
file|"sldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/as112.h"
end_include

begin_function
name|struct
name|local_zones
modifier|*
name|local_zones_create
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|local_zones
modifier|*
name|zones
init|=
operator|(
expr|struct
name|local_zones
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zones
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|zones
condition|)
return|return
name|NULL
return|;
name|rbtree_init
argument_list|(
operator|&
name|zones
operator|->
name|ztree
argument_list|,
operator|&
name|local_zone_cmp
argument_list|)
expr_stmt|;
name|lock_rw_init
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|,
operator|&
name|zones
operator|->
name|ztree
argument_list|,
sizeof|sizeof
argument_list|(
name|zones
operator|->
name|ztree
argument_list|)
argument_list|)
expr_stmt|;
comment|/* also lock protects the rbnode's in struct local_zone */
return|return
name|zones
return|;
block|}
end_function

begin_comment
comment|/** helper traverse to delete zones */
end_comment

begin_function
specifier|static
name|void
name|lzdel
parameter_list|(
name|rbnode_t
modifier|*
name|n
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|local_zone
modifier|*
name|z
init|=
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|n
operator|->
name|key
decl_stmt|;
name|local_zone_delete
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|local_zones_delete
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|)
block|{
if|if
condition|(
operator|!
name|zones
condition|)
return|return;
name|lock_rw_destroy
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* walk through zones and delete them all */
name|traverse_postorder
argument_list|(
operator|&
name|zones
operator|->
name|ztree
argument_list|,
name|lzdel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zones
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|local_zone_delete
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|)
block|{
if|if
condition|(
operator|!
name|z
condition|)
return|return;
name|lock_rw_destroy
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|z
operator|->
name|region
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
operator|->
name|taglist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|local_zone_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|z1
parameter_list|,
specifier|const
name|void
modifier|*
name|z2
parameter_list|)
block|{
comment|/* first sort on class, so that hierarchy can be maintained within 	 * a class */
name|struct
name|local_zone
modifier|*
name|a
init|=
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|z1
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|b
init|=
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|z2
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|dclass
operator|!=
name|b
operator|->
name|dclass
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|dclass
operator|<
name|b
operator|->
name|dclass
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
return|return
name|dname_lab_cmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|a
operator|->
name|namelabs
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|b
operator|->
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|local_data_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|d1
parameter_list|,
specifier|const
name|void
modifier|*
name|d2
parameter_list|)
block|{
name|struct
name|local_data
modifier|*
name|a
init|=
operator|(
expr|struct
name|local_data
operator|*
operator|)
name|d1
decl_stmt|;
name|struct
name|local_data
modifier|*
name|b
init|=
operator|(
expr|struct
name|local_data
operator|*
operator|)
name|d2
decl_stmt|;
name|int
name|m
decl_stmt|;
return|return
name|dname_canon_lab_cmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|a
operator|->
name|namelabs
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|b
operator|->
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* form wireformat from text format domain name */
end_comment

begin_function
name|int
name|parse_dname
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|res
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|labs
parameter_list|)
block|{
operator|*
name|res
operator|=
name|sldns_str2wire_dname
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|labs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|res
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse name %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|labs
operator|=
name|dname_count_size_labels
argument_list|(
operator|*
name|res
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** create a new localzone */
end_comment

begin_function
specifier|static
name|struct
name|local_zone
modifier|*
name|local_zone_create
parameter_list|(
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|enum
name|localzone_type
name|t
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|local_zone
modifier|*
name|z
init|=
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|z
operator|->
name|node
operator|.
name|key
operator|=
name|z
expr_stmt|;
name|z
operator|->
name|dclass
operator|=
name|dclass
expr_stmt|;
name|z
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|z
operator|->
name|name
operator|=
name|nm
expr_stmt|;
name|z
operator|->
name|namelen
operator|=
name|len
expr_stmt|;
name|z
operator|->
name|namelabs
operator|=
name|labs
expr_stmt|;
name|lock_rw_init
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|z
operator|->
name|region
operator|=
name|regional_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|z
operator|->
name|region
condition|)
block|{
name|free
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rbtree_init
argument_list|(
operator|&
name|z
operator|->
name|data
argument_list|,
operator|&
name|local_data_cmp
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|,
operator|&
name|z
operator|->
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|z
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|rbnode_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* also the zones->lock protects node, parent, name*, class */
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/** enter a new zone with allocated dname returns with WRlock */
end_comment

begin_function
specifier|static
name|struct
name|local_zone
modifier|*
name|lz_enter_zone_dname
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|enum
name|localzone_type
name|t
parameter_list|,
name|uint16_t
name|c
parameter_list|)
block|{
name|struct
name|local_zone
modifier|*
name|z
init|=
name|local_zone_create
argument_list|(
name|nm
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|t
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
block|{
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* add to rbtree */
name|lock_rw_wrlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_rw_wrlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
operator|&
name|zones
operator|->
name|ztree
argument_list|,
operator|&
name|z
operator|->
name|node
argument_list|)
condition|)
block|{
name|log_warn
argument_list|(
literal|"duplicate local-zone"
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|local_zone_delete
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/** enter a new zone */
end_comment

begin_function
specifier|static
name|struct
name|local_zone
modifier|*
name|lz_enter_zone
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|enum
name|localzone_type
name|t
decl_stmt|;
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|labs
decl_stmt|;
if|if
condition|(
operator|!
name|parse_dname
argument_list|(
name|name
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|labs
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"bad zone name %s %s"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|local_zone_str2type
argument_list|(
name|type
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"bad lz_enter_zone type %s %s"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|lz_enter_zone_dname
argument_list|(
name|zones
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|t
argument_list|,
name|dclass
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"could not enter zone %s %s"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/** return name and class and rdata of rr; parses string */
end_comment

begin_function
specifier|static
name|int
name|get_rr_content
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|nm
parameter_list|,
name|uint16_t
modifier|*
name|type
parameter_list|,
name|uint16_t
modifier|*
name|dclass
parameter_list|,
name|time_t
modifier|*
name|ttl
parameter_list|,
name|uint8_t
modifier|*
name|rr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|rdata
parameter_list|,
name|size_t
modifier|*
name|rdata_len
parameter_list|)
block|{
name|size_t
name|dname_len
init|=
literal|0
decl_stmt|;
name|int
name|e
init|=
name|sldns_str2wire_rr_buf
argument_list|(
name|str
argument_list|,
name|rr
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|dname_len
argument_list|,
literal|3600
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|log_err
argument_list|(
literal|"error parsing local-data at %d: '%s': %s"
argument_list|,
name|LDNS_WIREPARSE_OFFSET
argument_list|(
name|e
argument_list|)
argument_list|,
name|str
argument_list|,
name|sldns_get_errorstr_parse
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|nm
operator|=
name|memdup
argument_list|(
name|rr
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|nm
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|dclass
operator|=
name|sldns_wirerr_get_class
argument_list|(
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
operator|*
name|ttl
operator|=
operator|(
name|time_t
operator|)
name|sldns_wirerr_get_ttl
argument_list|(
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
operator|*
name|rdata
operator|=
name|sldns_wirerr_get_rdatawl
argument_list|(
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
operator|*
name|rdata_len
operator|=
name|sldns_wirerr_get_rdatalen
argument_list|(
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
operator|+
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** return name and class of rr; parses string */
end_comment

begin_function
specifier|static
name|int
name|get_rr_nameclass
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|nm
parameter_list|,
name|uint16_t
modifier|*
name|dclass
parameter_list|)
block|{
name|uint8_t
name|rr
index|[
name|LDNS_RR_BUF_SIZE
index|]
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|rr
argument_list|)
decl_stmt|,
name|dname_len
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|sldns_str2wire_rr_buf
argument_list|(
name|str
argument_list|,
name|rr
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|dname_len
argument_list|,
literal|3600
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"error parsing local-data at %d '%s': %s"
argument_list|,
name|LDNS_WIREPARSE_OFFSET
argument_list|(
name|s
argument_list|)
argument_list|,
name|str
argument_list|,
name|sldns_get_errorstr_parse
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|nm
operator|=
name|memdup
argument_list|(
name|rr
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
operator|*
name|dclass
operator|=
name|sldns_wirerr_get_class
argument_list|(
name|rr
argument_list|,
name|len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|nm
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Find an rrset in local data structure.  * @param data: local data domain name structure.  * @param type: type to look for (host order).  * @return rrset pointer or NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|local_rrset
modifier|*
name|local_data_find_type
parameter_list|(
name|struct
name|local_data
modifier|*
name|data
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|local_rrset
modifier|*
name|p
decl_stmt|;
name|type
operator|=
name|htons
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|data
operator|->
name|rrsets
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|rrset
operator|->
name|rk
operator|.
name|type
operator|==
name|type
condition|)
return|return
name|p
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** check for RR duplicates */
end_comment

begin_function
specifier|static
name|int
name|rr_is_duplicate
parameter_list|(
name|struct
name|packed_rrset_data
modifier|*
name|pd
parameter_list|,
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|rdata_len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|rr_len
index|[
name|i
index|]
operator|==
name|rdata_len
operator|&&
name|memcmp
argument_list|(
name|pd
operator|->
name|rr_data
index|[
name|i
index|]
argument_list|,
name|rdata
argument_list|,
name|rdata_len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** new local_rrset */
end_comment

begin_function
specifier|static
name|struct
name|local_rrset
modifier|*
name|new_local_rrset
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|local_data
modifier|*
name|node
parameter_list|,
name|uint16_t
name|rrtype
parameter_list|,
name|uint16_t
name|rrclass
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|pd
decl_stmt|;
name|struct
name|local_rrset
modifier|*
name|rrset
init|=
operator|(
expr|struct
name|local_rrset
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rrset
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rrset
operator|->
name|next
operator|=
name|node
operator|->
name|rrsets
expr_stmt|;
name|node
operator|->
name|rrsets
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|->
name|rrset
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrset
operator|->
name|rrset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrset
operator|->
name|rrset
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rrset
operator|->
name|rrset
operator|->
name|entry
operator|.
name|key
operator|=
name|rrset
operator|->
name|rrset
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pd
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pd
operator|->
name|trust
operator|=
name|rrset_trust_prim_noglue
expr_stmt|;
name|pd
operator|->
name|security
operator|=
name|sec_status_insecure
expr_stmt|;
name|rrset
operator|->
name|rrset
operator|->
name|entry
operator|.
name|data
operator|=
name|pd
expr_stmt|;
name|rrset
operator|->
name|rrset
operator|->
name|rk
operator|.
name|dname
operator|=
name|node
operator|->
name|name
expr_stmt|;
name|rrset
operator|->
name|rrset
operator|->
name|rk
operator|.
name|dname_len
operator|=
name|node
operator|->
name|namelen
expr_stmt|;
name|rrset
operator|->
name|rrset
operator|->
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|rrtype
argument_list|)
expr_stmt|;
name|rrset
operator|->
name|rrset
operator|->
name|rk
operator|.
name|rrset_class
operator|=
name|htons
argument_list|(
name|rrclass
argument_list|)
expr_stmt|;
return|return
name|rrset
return|;
block|}
end_function

begin_comment
comment|/** insert RR into RRset data structure; Wastes a couple of bytes */
end_comment

begin_function
specifier|static
name|int
name|insert_rr
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
name|pd
parameter_list|,
name|uint8_t
modifier|*
name|rdata
parameter_list|,
name|size_t
name|rdata_len
parameter_list|,
name|time_t
name|ttl
parameter_list|)
block|{
name|size_t
modifier|*
name|oldlen
init|=
name|pd
operator|->
name|rr_len
decl_stmt|;
name|time_t
modifier|*
name|oldttl
init|=
name|pd
operator|->
name|rr_ttl
decl_stmt|;
name|uint8_t
modifier|*
modifier|*
name|olddata
init|=
name|pd
operator|->
name|rr_data
decl_stmt|;
comment|/* add RR to rrset */
name|pd
operator|->
name|count
operator|++
expr_stmt|;
name|pd
operator|->
name|rr_len
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
operator|->
name|rr_len
argument_list|)
operator|*
name|pd
operator|->
name|count
argument_list|)
expr_stmt|;
name|pd
operator|->
name|rr_ttl
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
operator|->
name|rr_ttl
argument_list|)
operator|*
name|pd
operator|->
name|count
argument_list|)
expr_stmt|;
name|pd
operator|->
name|rr_data
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
operator|->
name|rr_data
argument_list|)
operator|*
name|pd
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pd
operator|->
name|rr_len
operator|||
operator|!
name|pd
operator|->
name|rr_ttl
operator|||
operator|!
name|pd
operator|->
name|rr_data
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pd
operator|->
name|count
operator|>
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|pd
operator|->
name|rr_len
operator|+
literal|1
argument_list|,
name|oldlen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
operator|->
name|rr_len
argument_list|)
operator|*
operator|(
name|pd
operator|->
name|count
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pd
operator|->
name|rr_ttl
operator|+
literal|1
argument_list|,
name|oldttl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
operator|->
name|rr_ttl
argument_list|)
operator|*
operator|(
name|pd
operator|->
name|count
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pd
operator|->
name|rr_data
operator|+
literal|1
argument_list|,
name|olddata
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pd
operator|->
name|rr_data
argument_list|)
operator|*
operator|(
name|pd
operator|->
name|count
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|pd
operator|->
name|rr_len
index|[
literal|0
index|]
operator|=
name|rdata_len
expr_stmt|;
name|pd
operator|->
name|rr_ttl
index|[
literal|0
index|]
operator|=
name|ttl
expr_stmt|;
name|pd
operator|->
name|rr_data
index|[
literal|0
index|]
operator|=
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|rdata
argument_list|,
name|rdata_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pd
operator|->
name|rr_data
index|[
literal|0
index|]
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** find a data node by exact name */
end_comment

begin_function
specifier|static
name|struct
name|local_data
modifier|*
name|lz_find_node
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|int
name|nmlabs
parameter_list|)
block|{
name|struct
name|local_data
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
name|nmlen
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|nmlabs
expr_stmt|;
return|return
operator|(
expr|struct
name|local_data
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|z
operator|->
name|data
argument_list|,
operator|&
name|key
operator|.
name|node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** find a node, create it if not and all its empty nonterminal parents */
end_comment

begin_function
specifier|static
name|int
name|lz_find_create_node
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|int
name|nmlabs
parameter_list|,
name|struct
name|local_data
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|local_data
modifier|*
name|ld
init|=
name|lz_find_node
argument_list|(
name|z
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ld
condition|)
block|{
comment|/* create a domain name to store rr. */
name|ld
operator|=
operator|(
expr|struct
name|local_data
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|z
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ld
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ld
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory adding local data"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ld
operator|->
name|node
operator|.
name|key
operator|=
name|ld
expr_stmt|;
name|ld
operator|->
name|name
operator|=
name|regional_alloc_init
argument_list|(
name|z
operator|->
name|region
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ld
operator|->
name|name
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ld
operator|->
name|namelen
operator|=
name|nmlen
expr_stmt|;
name|ld
operator|->
name|namelabs
operator|=
name|nmlabs
expr_stmt|;
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
operator|&
name|z
operator|->
name|data
argument_list|,
operator|&
name|ld
operator|->
name|node
argument_list|)
condition|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* duplicate name */
block|}
comment|/* see if empty nonterminals need to be created */
if|if
condition|(
name|nmlabs
operator|>
name|z
operator|->
name|namelabs
condition|)
block|{
name|dname_remove_label
argument_list|(
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lz_find_create_node
argument_list|(
name|z
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
operator|-
literal|1
argument_list|,
name|res
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
operator|*
name|res
operator|=
name|ld
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** enter data RR into auth zone */
end_comment

begin_function
specifier|static
name|int
name|lz_enter_rr_into_zone
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|,
specifier|const
name|char
modifier|*
name|rrstr
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|struct
name|local_data
modifier|*
name|node
decl_stmt|;
name|struct
name|local_rrset
modifier|*
name|rrset
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|pd
decl_stmt|;
name|uint16_t
name|rrtype
init|=
literal|0
decl_stmt|,
name|rrclass
init|=
literal|0
decl_stmt|;
name|time_t
name|ttl
init|=
literal|0
decl_stmt|;
name|uint8_t
name|rr
index|[
name|LDNS_RR_BUF_SIZE
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|rdata
decl_stmt|;
name|size_t
name|rdata_len
decl_stmt|;
if|if
condition|(
operator|!
name|get_rr_content
argument_list|(
name|rrstr
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|rrtype
argument_list|,
operator|&
name|rrclass
argument_list|,
operator|&
name|ttl
argument_list|,
name|rr
argument_list|,
sizeof|sizeof
argument_list|(
name|rr
argument_list|)
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|rdata_len
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"bad local-data: %s"
argument_list|,
name|rrstr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_assert
argument_list|(
name|z
operator|->
name|dclass
operator|==
name|rrclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|local_zone_redirect
operator|&&
name|query_dname_compare
argument_list|(
name|z
operator|->
name|name
argument_list|,
name|nm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"local-data in redirect zone must reside at top of zone"
literal|", not at %s"
argument_list|,
name|rrstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nmlabs
operator|=
name|dname_count_size_labels
argument_list|(
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lz_find_create_node
argument_list|(
name|z
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|,
operator|&
name|node
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_assert
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|rrset
operator|=
name|local_data_find_type
argument_list|(
name|node
argument_list|,
name|rrtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrset
condition|)
block|{
name|rrset
operator|=
name|new_local_rrset
argument_list|(
name|z
operator|->
name|region
argument_list|,
name|node
argument_list|,
name|rrtype
argument_list|,
name|rrclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrset
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|node
operator|->
name|name
argument_list|,
name|z
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rrtype
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
name|rrset
operator|->
name|rrset
operator|->
name|rk
operator|.
name|flags
operator|=
name|PACKED_RRSET_NSEC_AT_APEX
expr_stmt|;
if|if
condition|(
name|rrtype
operator|==
name|LDNS_RR_TYPE_SOA
condition|)
name|z
operator|->
name|soa
operator|=
name|rrset
operator|->
name|rrset
expr_stmt|;
block|}
block|}
name|pd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rrset
operator|->
name|rrset
operator|->
name|entry
operator|.
name|data
expr_stmt|;
name|log_assert
argument_list|(
name|rrset
operator|&&
name|pd
argument_list|)
expr_stmt|;
comment|/* check for duplicate RR */
if|if
condition|(
name|rr_is_duplicate
argument_list|(
name|pd
argument_list|,
name|rdata
argument_list|,
name|rdata_len
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"ignoring duplicate RR: %s"
argument_list|,
name|rrstr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|insert_rr
argument_list|(
name|z
operator|->
name|region
argument_list|,
name|pd
argument_list|,
name|rdata
argument_list|,
name|rdata_len
argument_list|,
name|ttl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** enter a data RR into auth data; a zone for it must exist */
end_comment

begin_function
specifier|static
name|int
name|lz_enter_rr_str
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
specifier|const
name|char
modifier|*
name|rr
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rr_name
decl_stmt|;
name|uint16_t
name|rr_class
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|labs
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|get_rr_nameclass
argument_list|(
name|rr
argument_list|,
operator|&
name|rr_name
argument_list|,
operator|&
name|rr_class
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"bad rr %s"
argument_list|,
name|rr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|labs
operator|=
name|dname_count_size_labels
argument_list|(
name|rr_name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|z
operator|=
name|local_zones_lookup
argument_list|(
name|zones
argument_list|,
name|rr_name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|rr_class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"internal error: no zone for rr %s"
argument_list|,
name|rr
argument_list|)
expr_stmt|;
block|}
name|lock_rw_wrlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rr_name
argument_list|)
expr_stmt|;
name|r
operator|=
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/** enter tagstring into zone */
end_comment

begin_function
specifier|static
name|int
name|lz_enter_zone_tag
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|char
modifier|*
name|zname
parameter_list|,
name|uint8_t
modifier|*
name|list
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint16_t
name|rr_class
parameter_list|)
block|{
name|uint8_t
name|dname
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
name|size_t
name|dname_len
init|=
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
decl_stmt|;
name|int
name|dname_labs
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|sldns_str2wire_dname_buf
argument_list|(
name|zname
argument_list|,
name|dname
argument_list|,
operator|&
name|dname_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse zone name in local-zone-tag: %s"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dname_labs
operator|=
name|dname_count_labels
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|z
operator|=
name|local_zones_lookup
argument_list|(
name|zones
argument_list|,
name|dname
argument_list|,
name|dname_len
argument_list|,
name|dname_labs
argument_list|,
name|rr_class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"no local-zone for tag %s"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_rw_wrlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
operator|->
name|taglist
argument_list|)
expr_stmt|;
name|z
operator|->
name|taglist
operator|=
name|memdup
argument_list|(
name|list
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|z
operator|->
name|taglen
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|taglist
condition|)
name|r
operator|=
literal|1
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/** parse local-zone: statements */
end_comment

begin_function
specifier|static
name|int
name|lz_enter_zones
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|config_str2list
modifier|*
name|p
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
for|for
control|(
name|p
operator|=
name|cfg
operator|->
name|local_zones
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|lz_enter_zone
argument_list|(
name|zones
argument_list|,
name|p
operator|->
name|str
argument_list|,
name|p
operator|->
name|str2
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** lookup a zone in rbtree; exact match only; SLOW due to parse */
end_comment

begin_function
specifier|static
name|int
name|lz_exists
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|local_zone
name|z
decl_stmt|;
name|z
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|z
expr_stmt|;
name|z
operator|.
name|dclass
operator|=
name|LDNS_RR_CLASS_IN
expr_stmt|;
if|if
condition|(
operator|!
name|parse_dname
argument_list|(
name|name
argument_list|,
operator|&
name|z
operator|.
name|name
argument_list|,
operator|&
name|z
operator|.
name|namelen
argument_list|,
operator|&
name|z
operator|.
name|namelabs
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"bad name %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_rw_rdlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtree_search
argument_list|(
operator|&
name|zones
operator|->
name|ztree
argument_list|,
operator|&
name|z
operator|.
name|node
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** lookup a zone in cfg->nodefault list */
end_comment

begin_function
specifier|static
name|int
name|lz_nodefault
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|config_strlist
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|len
operator|--
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cfg
operator|->
name|local_zones_nodefault
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* compare zone name, lowercase, compare without ending . */
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
operator|->
name|str
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|strlen
argument_list|(
name|p
operator|->
name|str
argument_list|)
operator|==
name|len
operator|||
operator|(
name|strlen
argument_list|(
name|p
operator|->
name|str
argument_list|)
operator|==
name|len
operator|+
literal|1
operator|&&
name|p
operator|->
name|str
index|[
name|len
index|]
operator|==
literal|'.'
operator|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** enter AS112 default zone */
end_comment

begin_function
specifier|static
name|int
name|add_as112_default
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|char
name|str
index|[
literal|1024
index|]
decl_stmt|;
comment|/* known long enough */
if|if
condition|(
name|lz_exists
argument_list|(
name|zones
argument_list|,
name|name
argument_list|)
operator|||
name|lz_nodefault
argument_list|(
name|cfg
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* do not enter default content */
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|lz_enter_zone
argument_list|(
name|zones
argument_list|,
name|name
argument_list|,
literal|"static"
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%s 10800 IN SOA localhost. "
literal|"nobody.invalid. 1 3600 1200 604800 10800"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%s 10800 IN NS localhost. "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** enter default zones */
end_comment

begin_function
specifier|static
name|int
name|lz_enter_defaults
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|zstr
decl_stmt|;
comment|/* this list of zones is from RFC 6303 and RFC 7686 */
comment|/* block localhost level zones first, then onion and later the LAN zones */
comment|/* localhost. zone */
if|if
condition|(
operator|!
name|lz_exists
argument_list|(
name|zones
argument_list|,
literal|"localhost."
argument_list|)
operator|&&
operator|!
name|lz_nodefault
argument_list|(
name|cfg
argument_list|,
literal|"localhost."
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|lz_enter_zone
argument_list|(
name|zones
argument_list|,
literal|"localhost."
argument_list|,
literal|"static"
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"localhost. 10800 IN NS localhost."
argument_list|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"localhost. 10800 IN SOA localhost. nobody.invalid. "
literal|"1 3600 1200 604800 10800"
argument_list|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"localhost. 10800 IN A 127.0.0.1"
argument_list|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"localhost. 10800 IN AAAA ::1"
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory adding default zone"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* reverse ip4 zone */
if|if
condition|(
operator|!
name|lz_exists
argument_list|(
name|zones
argument_list|,
literal|"127.in-addr.arpa."
argument_list|)
operator|&&
operator|!
name|lz_nodefault
argument_list|(
name|cfg
argument_list|,
literal|"127.in-addr.arpa."
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|lz_enter_zone
argument_list|(
name|zones
argument_list|,
literal|"127.in-addr.arpa."
argument_list|,
literal|"static"
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"127.in-addr.arpa. 10800 IN NS localhost."
argument_list|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"127.in-addr.arpa. 10800 IN SOA localhost. "
literal|"nobody.invalid. 1 3600 1200 604800 10800"
argument_list|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"1.0.0.127.in-addr.arpa. 10800 IN PTR localhost."
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory adding default zone"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* reverse ip6 zone */
if|if
condition|(
operator|!
name|lz_exists
argument_list|(
name|zones
argument_list|,
literal|"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa."
argument_list|)
operator|&&
operator|!
name|lz_nodefault
argument_list|(
name|cfg
argument_list|,
literal|"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa."
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|lz_enter_zone
argument_list|(
name|zones
argument_list|,
literal|"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa."
argument_list|,
literal|"static"
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa. 10800 IN NS localhost."
argument_list|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa. 10800 IN SOA localhost. "
literal|"nobody.invalid. 1 3600 1200 604800 10800"
argument_list|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa. 10800 IN PTR localhost."
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory adding default zone"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* onion. zone (RFC 7686) */
if|if
condition|(
operator|!
name|lz_exists
argument_list|(
name|zones
argument_list|,
literal|"onion."
argument_list|)
operator|&&
operator|!
name|lz_nodefault
argument_list|(
name|cfg
argument_list|,
literal|"onion."
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|lz_enter_zone
argument_list|(
name|zones
argument_list|,
literal|"onion."
argument_list|,
literal|"static"
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"onion. 10800 IN NS localhost."
argument_list|)
operator|||
operator|!
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
literal|"onion. 10800 IN SOA localhost. nobody.invalid. "
literal|"1 3600 1200 604800 10800"
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory adding default zone"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* block AS112 zones, unless asked not to */
if|if
condition|(
operator|!
name|cfg
operator|->
name|unblock_lan_zones
condition|)
block|{
for|for
control|(
name|zstr
operator|=
name|as112_zones
init|;
operator|*
name|zstr
condition|;
name|zstr
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|add_as112_default
argument_list|(
name|zones
argument_list|,
name|cfg
argument_list|,
operator|*
name|zstr
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory adding default zone"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** setup parent pointers, so that a lookup can be done for closest match */
end_comment

begin_function
specifier|static
name|void
name|init_parents
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|)
block|{
name|struct
name|local_zone
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|m
decl_stmt|;
name|lock_rw_wrlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|node
argument_list|,
argument|struct local_zone*
argument_list|,
argument|&zones->ztree
argument_list|)
block|{
name|lock_rw_wrlock
argument_list|(
operator|&
name|node
operator|->
name|lock
argument_list|)
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
name|prev
operator|->
name|dclass
operator|!=
name|node
operator|->
name|dclass
condition|)
block|{
name|prev
operator|=
name|node
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|node
operator|->
name|lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|prev
operator|->
name|name
argument_list|,
name|prev
operator|->
name|namelabs
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* we know prev is smaller */
comment|/* sort order like: . com. bla.com. zwb.com. net. */
comment|/* find the previous, or parent-parent-parent */
for|for
control|(
name|p
operator|=
name|prev
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
comment|/* looking for name with few labels, a parent */
if|if
condition|(
name|p
operator|->
name|namelabs
operator|<=
name|m
condition|)
block|{
comment|/* ==: since prev matched m, this is closest*/
comment|/*<: prev matches more, but is not a parent,                                  * this one is a (grand)parent */
name|node
operator|->
name|parent
operator|=
name|p
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|node
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|node
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** enter implicit transparent zone for local-data: without local-zone: */
end_comment

begin_function
specifier|static
name|int
name|lz_setup_implicit
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
comment|/* walk over all items that have no parent zone and find 	 * the name that covers them all (could be the root) and 	 * add that as a transparent zone */
name|struct
name|config_strlist
modifier|*
name|p
decl_stmt|;
name|int
name|have_name
init|=
literal|0
decl_stmt|;
name|int
name|have_other_classes
init|=
literal|0
decl_stmt|;
name|uint16_t
name|dclass
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
literal|0
decl_stmt|;
name|size_t
name|nmlen
init|=
literal|0
decl_stmt|;
name|int
name|nmlabs
init|=
literal|0
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
comment|/* number of labels match count */
name|init_parents
argument_list|(
name|zones
argument_list|)
expr_stmt|;
comment|/* to enable local_zones_lookup() */
for|for
control|(
name|p
operator|=
name|cfg
operator|->
name|local_data
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|uint8_t
modifier|*
name|rr_name
decl_stmt|;
name|uint16_t
name|rr_class
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|labs
decl_stmt|;
if|if
condition|(
operator|!
name|get_rr_nameclass
argument_list|(
name|p
operator|->
name|str
argument_list|,
operator|&
name|rr_name
argument_list|,
operator|&
name|rr_class
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Bad local-data RR %s"
argument_list|,
name|p
operator|->
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|labs
operator|=
name|dname_count_size_labels
argument_list|(
name|rr_name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_zones_lookup
argument_list|(
name|zones
argument_list|,
name|rr_name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|rr_class
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|have_name
condition|)
block|{
name|dclass
operator|=
name|rr_class
expr_stmt|;
name|nm
operator|=
name|rr_name
expr_stmt|;
name|nmlen
operator|=
name|len
expr_stmt|;
name|nmlabs
operator|=
name|labs
expr_stmt|;
name|match
operator|=
name|labs
expr_stmt|;
name|have_name
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|m
decl_stmt|;
if|if
condition|(
name|rr_class
operator|!=
name|dclass
condition|)
block|{
comment|/* process other classes later */
name|free
argument_list|(
name|rr_name
argument_list|)
expr_stmt|;
name|have_other_classes
operator|=
literal|1
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* find smallest shared topdomain */
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|nm
argument_list|,
name|nmlabs
argument_list|,
name|rr_name
argument_list|,
name|labs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<
name|match
condition|)
name|match
operator|=
name|m
expr_stmt|;
block|}
block|}
else|else
name|free
argument_list|(
name|rr_name
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_name
condition|)
block|{
name|uint8_t
modifier|*
name|n2
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
comment|/* allocate zone of smallest shared topdomain to contain em */
name|n2
operator|=
name|nm
expr_stmt|;
name|dname_remove_labels
argument_list|(
operator|&
name|n2
argument_list|,
operator|&
name|nmlen
argument_list|,
name|nmlabs
operator|-
name|match
argument_list|)
expr_stmt|;
name|n2
operator|=
name|memdup
argument_list|(
name|n2
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n2
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"implicit transparent local-zone"
argument_list|,
name|n2
argument_list|,
literal|0
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|lz_enter_zone_dname
argument_list|(
name|zones
argument_list|,
name|n2
argument_list|,
name|nmlen
argument_list|,
name|match
argument_list|,
name|local_zone_transparent
argument_list|,
name|dclass
argument_list|)
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_other_classes
condition|)
block|{
comment|/* restart to setup other class */
return|return
name|lz_setup_implicit
argument_list|(
name|zones
argument_list|,
name|cfg
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** enter local-zone-tag info */
end_comment

begin_function
specifier|static
name|int
name|lz_enter_zone_tags
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|config_strbytelist
modifier|*
name|p
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|cfg
operator|->
name|local_zone_tags
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|lz_enter_zone_tag
argument_list|(
name|zones
argument_list|,
name|p
operator|->
name|str
argument_list|,
name|p
operator|->
name|str2
argument_list|,
name|p
operator|->
name|str2len
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
condition|)
return|return
literal|0
return|;
name|c
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"applied tags to %d local zones"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** enter auth data */
end_comment

begin_function
specifier|static
name|int
name|lz_enter_data
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|config_strlist
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|cfg
operator|->
name|local_data
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|lz_enter_rr_str
argument_list|(
name|zones
argument_list|,
name|p
operator|->
name|str
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** free memory from config */
end_comment

begin_function
specifier|static
name|void
name|lz_freeup_cfg
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|config_deldblstrlist
argument_list|(
name|cfg
operator|->
name|local_zones
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|local_zones
operator|=
name|NULL
expr_stmt|;
name|config_delstrlist
argument_list|(
name|cfg
operator|->
name|local_zones_nodefault
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|local_zones_nodefault
operator|=
name|NULL
expr_stmt|;
name|config_delstrlist
argument_list|(
name|cfg
operator|->
name|local_data
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|local_data
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|local_zones_apply_cfg
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
comment|/* create zones from zone statements. */
if|if
condition|(
operator|!
name|lz_enter_zones
argument_list|(
name|zones
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* apply default zones+content (unless disabled, or overridden) */
if|if
condition|(
operator|!
name|lz_enter_defaults
argument_list|(
name|zones
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* create implicit transparent zone from data. */
if|if
condition|(
operator|!
name|lz_setup_implicit
argument_list|(
name|zones
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* setup parent ptrs for lookup during data entry */
name|init_parents
argument_list|(
name|zones
argument_list|)
expr_stmt|;
comment|/* insert local zone tags */
if|if
condition|(
operator|!
name|lz_enter_zone_tags
argument_list|(
name|zones
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* insert local data */
if|if
condition|(
operator|!
name|lz_enter_data
argument_list|(
name|zones
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* freeup memory from cfg struct. */
name|lz_freeup_cfg
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|local_zone
modifier|*
name|local_zones_lookup
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|rbnode_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|result
decl_stmt|;
name|struct
name|local_zone
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|dclass
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
name|len
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|labs
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
operator|&
name|zones
operator|->
name|ztree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
comment|/* exact */
return|return
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|res
return|;
block|}
else|else
block|{
comment|/* smaller element (or no element) */
name|int
name|m
decl_stmt|;
name|result
operator|=
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|res
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|||
name|result
operator|->
name|dclass
operator|!=
name|dclass
condition|)
return|return
name|NULL
return|;
comment|/* count number of labels matched */
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|result
operator|->
name|name
argument_list|,
name|result
operator|->
name|namelabs
argument_list|,
name|key
operator|.
name|name
argument_list|,
name|key
operator|.
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
comment|/* go up until qname is subdomain of zone */
if|if
condition|(
name|result
operator|->
name|namelabs
operator|<=
name|m
condition|)
break|break;
name|result
operator|=
name|result
operator|->
name|parent
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_function

begin_function
name|struct
name|local_zone
modifier|*
name|local_zones_find
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|local_zone
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|dclass
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
name|len
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|labs
expr_stmt|;
comment|/* exact */
return|return
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|zones
operator|->
name|ztree
argument_list|,
operator|&
name|key
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** print all RRsets in local zone */
end_comment

begin_function
specifier|static
name|void
name|local_zone_out
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|)
block|{
name|struct
name|local_data
modifier|*
name|d
decl_stmt|;
name|struct
name|local_rrset
modifier|*
name|p
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|d
argument_list|,
argument|struct local_data*
argument_list|,
argument|&z->data
argument_list|)
block|{
for|for
control|(
name|p
operator|=
name|d
operator|->
name|rrsets
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"rrset"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|ntohs
argument_list|(
name|p
operator|->
name|rrset
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|p
operator|->
name|rrset
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|local_zones_print
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|)
block|{
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"number of auth zones %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|zones
operator|->
name|ztree
operator|.
name|count
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|z
argument_list|,
argument|struct local_zone*
argument_list|,
argument|&zones->ztree
argument_list|)
block|{
name|lock_rw_rdlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|z
operator|->
name|type
condition|)
block|{
case|case
name|local_zone_deny
case|:
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"deny zone"
argument_list|,
name|z
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|z
operator|->
name|dclass
argument_list|)
expr_stmt|;
break|break;
case|case
name|local_zone_refuse
case|:
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"refuse zone"
argument_list|,
name|z
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|z
operator|->
name|dclass
argument_list|)
expr_stmt|;
break|break;
case|case
name|local_zone_redirect
case|:
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"redirect zone"
argument_list|,
name|z
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|z
operator|->
name|dclass
argument_list|)
expr_stmt|;
break|break;
case|case
name|local_zone_transparent
case|:
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"transparent zone"
argument_list|,
name|z
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|z
operator|->
name|dclass
argument_list|)
expr_stmt|;
break|break;
case|case
name|local_zone_typetransparent
case|:
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"typetransparent zone"
argument_list|,
name|z
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|z
operator|->
name|dclass
argument_list|)
expr_stmt|;
break|break;
case|case
name|local_zone_static
case|:
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"static zone"
argument_list|,
name|z
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|z
operator|->
name|dclass
argument_list|)
expr_stmt|;
break|break;
case|case
name|local_zone_inform
case|:
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"inform zone"
argument_list|,
name|z
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|z
operator|->
name|dclass
argument_list|)
expr_stmt|;
break|break;
case|case
name|local_zone_inform_deny
case|:
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"inform_deny zone"
argument_list|,
name|z
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|z
operator|->
name|dclass
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
literal|"badtyped zone"
argument_list|,
name|z
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|z
operator|->
name|dclass
argument_list|)
expr_stmt|;
break|break;
block|}
name|local_zone_out
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** encode answer consisting of 1 rrset */
end_comment

begin_function
specifier|static
name|int
name|local_encode
parameter_list|(
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|regional
modifier|*
name|temp
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|,
name|int
name|ansec
parameter_list|,
name|int
name|rcode
parameter_list|)
block|{
name|struct
name|reply_info
name|rep
decl_stmt|;
name|uint16_t
name|udpsize
decl_stmt|;
comment|/* make answer with time=0 for fixed TTL values */
name|memset
argument_list|(
operator|&
name|rep
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|.
name|flags
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|BIT_QR
operator||
name|BIT_AA
operator||
name|BIT_RA
operator|)
operator||
name|rcode
argument_list|)
expr_stmt|;
name|rep
operator|.
name|qdcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ansec
condition|)
name|rep
operator|.
name|an_numrrsets
operator|=
literal|1
expr_stmt|;
else|else
name|rep
operator|.
name|ns_numrrsets
operator|=
literal|1
expr_stmt|;
name|rep
operator|.
name|rrset_count
operator|=
literal|1
expr_stmt|;
name|rep
operator|.
name|rrsets
operator|=
operator|&
name|rrset
expr_stmt|;
name|udpsize
operator|=
name|edns
operator|->
name|udp_size
expr_stmt|;
name|edns
operator|->
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|edns
operator|->
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|->
name|bits
operator|&=
name|EDNS_DO
expr_stmt|;
if|if
condition|(
operator|!
name|edns_opt_inplace_reply
argument_list|(
name|edns
argument_list|,
name|temp
argument_list|)
operator|||
operator|!
name|reply_info_answer_encode
argument_list|(
name|qinfo
argument_list|,
operator|&
name|rep
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
name|udpsize
argument_list|,
name|edns
argument_list|,
call|(
name|int
call|)
argument_list|(
name|edns
operator|->
name|bits
operator|&
name|EDNS_DO
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|error_encode
argument_list|(
name|buf
argument_list|,
operator|(
name|LDNS_RCODE_SERVFAIL
operator||
name|BIT_AA
operator|)
argument_list|,
name|qinfo
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
argument_list|,
name|edns
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** answer local data match */
end_comment

begin_function
specifier|static
name|int
name|local_data_answer
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|regional
modifier|*
name|temp
parameter_list|,
name|int
name|labs
parameter_list|,
name|struct
name|local_data
modifier|*
modifier|*
name|ldp
parameter_list|)
block|{
name|struct
name|local_data
name|key
decl_stmt|;
name|struct
name|local_data
modifier|*
name|ld
decl_stmt|;
name|struct
name|local_rrset
modifier|*
name|lr
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|qinfo
operator|->
name|qname
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
name|qinfo
operator|->
name|qname_len
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|labs
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|local_zone_redirect
condition|)
block|{
name|key
operator|.
name|name
operator|=
name|z
operator|->
name|name
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
name|z
operator|->
name|namelen
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|z
operator|->
name|namelabs
expr_stmt|;
block|}
name|ld
operator|=
operator|(
expr|struct
name|local_data
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|z
operator|->
name|data
argument_list|,
operator|&
name|key
operator|.
name|node
argument_list|)
expr_stmt|;
operator|*
name|ldp
operator|=
name|ld
expr_stmt|;
if|if
condition|(
operator|!
name|ld
condition|)
block|{
return|return
literal|0
return|;
block|}
name|lr
operator|=
name|local_data_find_type
argument_list|(
name|ld
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|local_zone_redirect
condition|)
block|{
comment|/* convert rrset name to query name; like a wildcard */
name|struct
name|ub_packed_rrset_key
name|r
init|=
operator|*
name|lr
operator|->
name|rrset
decl_stmt|;
name|r
operator|.
name|rk
operator|.
name|dname
operator|=
name|qinfo
operator|->
name|qname
expr_stmt|;
name|r
operator|.
name|rk
operator|.
name|dname_len
operator|=
name|qinfo
operator|->
name|qname_len
expr_stmt|;
return|return
name|local_encode
argument_list|(
name|qinfo
argument_list|,
name|edns
argument_list|,
name|buf
argument_list|,
name|temp
argument_list|,
operator|&
name|r
argument_list|,
literal|1
argument_list|,
name|LDNS_RCODE_NOERROR
argument_list|)
return|;
block|}
return|return
name|local_encode
argument_list|(
name|qinfo
argument_list|,
name|edns
argument_list|,
name|buf
argument_list|,
name|temp
argument_list|,
name|lr
operator|->
name|rrset
argument_list|,
literal|1
argument_list|,
name|LDNS_RCODE_NOERROR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   * answer in case where no exact match is found   * @param z: zone for query  * @param qinfo: query  * @param edns: edns from query  * @param buf: buffer for answer.  * @param temp: temp region for encoding  * @param ld: local data, if NULL, no such name exists in localdata.  * @return 1 if a reply is to be sent, 0 if not.  */
end_comment

begin_function
specifier|static
name|int
name|lz_zone_answer
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|regional
modifier|*
name|temp
parameter_list|,
name|struct
name|local_data
modifier|*
name|ld
parameter_list|)
block|{
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|local_zone_deny
operator|||
name|z
operator|->
name|type
operator|==
name|local_zone_inform_deny
condition|)
block|{
comment|/** no reply at all, signal caller by clearing buffer. */
name|sldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|local_zone_refuse
condition|)
block|{
name|error_encode
argument_list|(
name|buf
argument_list|,
operator|(
name|LDNS_RCODE_REFUSED
operator||
name|BIT_AA
operator|)
argument_list|,
name|qinfo
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
argument_list|,
name|edns
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|local_zone_static
operator|||
name|z
operator|->
name|type
operator|==
name|local_zone_redirect
condition|)
block|{
comment|/* for static, reply nodata or nxdomain 		 * for redirect, reply nodata */
comment|/* no additional section processing, 		 * cname, dname or wildcard processing, 		 * or using closest match for NSEC. 		 * or using closest match for returning delegation downwards 		 */
name|int
name|rcode
init|=
name|ld
condition|?
name|LDNS_RCODE_NOERROR
else|:
name|LDNS_RCODE_NXDOMAIN
decl_stmt|;
if|if
condition|(
name|z
operator|->
name|soa
condition|)
return|return
name|local_encode
argument_list|(
name|qinfo
argument_list|,
name|edns
argument_list|,
name|buf
argument_list|,
name|temp
argument_list|,
name|z
operator|->
name|soa
argument_list|,
literal|0
argument_list|,
name|rcode
argument_list|)
return|;
name|error_encode
argument_list|(
name|buf
argument_list|,
operator|(
name|rcode
operator||
name|BIT_AA
operator|)
argument_list|,
name|qinfo
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
argument_list|,
name|edns
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|local_zone_typetransparent
condition|)
block|{
comment|/* no NODATA or NXDOMAINS for this zone type */
return|return
literal|0
return|;
block|}
comment|/* else z->type == local_zone_transparent */
comment|/* if the zone is transparent and the name exists, but the type 	 * does not, then we should make this noerror/nodata */
if|if
condition|(
name|ld
operator|&&
name|ld
operator|->
name|rrsets
condition|)
block|{
name|int
name|rcode
init|=
name|LDNS_RCODE_NOERROR
decl_stmt|;
if|if
condition|(
name|z
operator|->
name|soa
condition|)
return|return
name|local_encode
argument_list|(
name|qinfo
argument_list|,
name|edns
argument_list|,
name|buf
argument_list|,
name|temp
argument_list|,
name|z
operator|->
name|soa
argument_list|,
literal|0
argument_list|,
name|rcode
argument_list|)
return|;
name|error_encode
argument_list|(
name|buf
argument_list|,
operator|(
name|rcode
operator||
name|BIT_AA
operator|)
argument_list|,
name|qinfo
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
argument_list|,
name|edns
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* stop here, and resolve further on */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** print log information for an inform zone query */
end_comment

begin_function
specifier|static
name|void
name|lz_inform_print
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
name|char
name|ip
index|[
literal|128
index|]
decl_stmt|,
name|txt
index|[
literal|512
index|]
decl_stmt|;
name|char
name|zname
index|[
name|LDNS_MAX_DOMAINLEN
operator|+
literal|1
index|]
decl_stmt|;
name|uint16_t
name|port
init|=
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|repinfo
operator|->
name|addr
operator|)
operator|->
name|sin_port
argument_list|)
decl_stmt|;
name|dname_str
argument_list|(
name|z
operator|->
name|name
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|addr_to_str
argument_list|(
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|,
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|txt
argument_list|,
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
argument_list|,
literal|"%s inform %s@%u"
argument_list|,
name|zname
argument_list|,
name|ip
argument_list|,
operator|(
name|unsigned
operator|)
name|port
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
name|txt
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|local_zones_answer
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|regional
modifier|*
name|temp
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
comment|/* see if query is covered by a zone, 	 * 	if so:	- try to match (exact) local data  	 * 		- look at zone type for negative response. */
name|int
name|labs
init|=
name|dname_count_labels
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|)
decl_stmt|;
name|struct
name|local_data
modifier|*
name|ld
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|int
name|r
decl_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|z
operator|=
name|local_zones_lookup
argument_list|(
name|zones
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|labs
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_rw_rdlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|->
name|type
operator|==
name|local_zone_inform
operator|||
name|z
operator|->
name|type
operator|==
name|local_zone_inform_deny
operator|)
operator|&&
name|repinfo
condition|)
name|lz_inform_print
argument_list|(
name|z
argument_list|,
name|qinfo
argument_list|,
name|repinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_data_answer
argument_list|(
name|z
argument_list|,
name|qinfo
argument_list|,
name|edns
argument_list|,
name|buf
argument_list|,
name|temp
argument_list|,
name|labs
argument_list|,
operator|&
name|ld
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|r
operator|=
name|lz_zone_answer
argument_list|(
name|z
argument_list|,
name|qinfo
argument_list|,
name|edns
argument_list|,
name|buf
argument_list|,
name|temp
argument_list|,
name|ld
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|local_zone_type2str
parameter_list|(
name|enum
name|localzone_type
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|local_zone_deny
case|:
return|return
literal|"deny"
return|;
case|case
name|local_zone_refuse
case|:
return|return
literal|"refuse"
return|;
case|case
name|local_zone_redirect
case|:
return|return
literal|"redirect"
return|;
case|case
name|local_zone_transparent
case|:
return|return
literal|"transparent"
return|;
case|case
name|local_zone_typetransparent
case|:
return|return
literal|"typetransparent"
return|;
case|case
name|local_zone_static
case|:
return|return
literal|"static"
return|;
case|case
name|local_zone_nodefault
case|:
return|return
literal|"nodefault"
return|;
case|case
name|local_zone_inform
case|:
return|return
literal|"inform"
return|;
case|case
name|local_zone_inform_deny
case|:
return|return
literal|"inform_deny"
return|;
block|}
return|return
literal|"badtyped"
return|;
block|}
end_function

begin_function
name|int
name|local_zone_str2type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|enum
name|localzone_type
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"deny"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|t
operator|=
name|local_zone_deny
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"refuse"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|t
operator|=
name|local_zone_refuse
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"static"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|t
operator|=
name|local_zone_static
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"transparent"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|t
operator|=
name|local_zone_transparent
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"typetransparent"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|t
operator|=
name|local_zone_typetransparent
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"redirect"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|t
operator|=
name|local_zone_redirect
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"inform"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|t
operator|=
name|local_zone_inform
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"inform_deny"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|t
operator|=
name|local_zone_inform_deny
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** iterate over the kiddies of the given name and set their parent ptr */
end_comment

begin_function
specifier|static
name|void
name|set_kiddo_parents
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|,
name|struct
name|local_zone
modifier|*
name|match
parameter_list|,
name|struct
name|local_zone
modifier|*
name|newp
parameter_list|)
block|{
comment|/* both zones and z are locked already */
comment|/* in the sorted rbtree, the kiddies of z are located after z */
comment|/* z must be present in the tree */
name|struct
name|local_zone
modifier|*
name|p
init|=
name|z
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|rbtree_next
argument_list|(
operator|&
name|p
operator|->
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|RBTREE_NULL
operator|&&
name|p
operator|->
name|dclass
operator|==
name|z
operator|->
name|dclass
operator|&&
name|dname_strict_subdomain
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|namelabs
argument_list|,
name|z
operator|->
name|name
argument_list|,
name|z
operator|->
name|namelabs
argument_list|)
condition|)
block|{
comment|/* update parent ptr */
comment|/* only when matches with existing parent pointer, so that 		 * deeper child structures are not touched, i.e. 		 * update of x, and a.x, b.x, f.b.x, g.b.x, c.x, y 		 * gets to update a.x, b.x and c.x */
name|lock_rw_wrlock
argument_list|(
operator|&
name|p
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|parent
operator|==
name|match
condition|)
name|p
operator|->
name|parent
operator|=
name|newp
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|p
operator|->
name|lock
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|local_zone
operator|*
operator|)
name|rbtree_next
argument_list|(
operator|&
name|p
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|local_zone
modifier|*
name|local_zones_add_zone
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|enum
name|localzone_type
name|tp
parameter_list|)
block|{
comment|/* create */
name|struct
name|local_zone
modifier|*
name|z
init|=
name|local_zone_create
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|tp
argument_list|,
name|dclass
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lock_rw_wrlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* find the closest parent */
name|z
operator|->
name|parent
operator|=
name|local_zones_find
argument_list|(
name|zones
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
comment|/* insert into the tree */
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
operator|&
name|zones
operator|->
name|ztree
argument_list|,
operator|&
name|z
operator|->
name|node
argument_list|)
condition|)
block|{
comment|/* duplicate entry! */
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|local_zone_delete
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"internal: duplicate entry in local_zones_add_zone"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* set parent pointers right */
name|set_kiddo_parents
argument_list|(
name|z
argument_list|,
name|z
operator|->
name|parent
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_function
name|void
name|local_zones_del_zone
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|struct
name|local_zone
modifier|*
name|z
parameter_list|)
block|{
comment|/* fix up parents in tree */
name|lock_rw_wrlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|set_kiddo_parents
argument_list|(
name|z
argument_list|,
name|z
argument_list|,
name|z
operator|->
name|parent
argument_list|)
expr_stmt|;
comment|/* remove from tree */
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|zones
operator|->
name|ztree
argument_list|,
name|z
argument_list|)
expr_stmt|;
comment|/* delete the zone */
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|local_zone_delete
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|local_zones_add_RR
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
specifier|const
name|char
modifier|*
name|rr
parameter_list|)
block|{
name|uint8_t
modifier|*
name|rr_name
decl_stmt|;
name|uint16_t
name|rr_class
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|labs
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|get_rr_nameclass
argument_list|(
name|rr
argument_list|,
operator|&
name|rr_name
argument_list|,
operator|&
name|rr_class
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|labs
operator|=
name|dname_count_size_labels
argument_list|(
name|rr_name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* could first try readlock then get writelock if zone does not exist, 	 * but we do not add enough RRs (from multiple threads) to optimize */
name|lock_rw_wrlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|z
operator|=
name|local_zones_lookup
argument_list|(
name|zones
argument_list|,
name|rr_name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|rr_class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
block|{
name|z
operator|=
name|local_zones_add_zone
argument_list|(
name|zones
argument_list|,
name|rr_name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|rr_class
argument_list|,
name|local_zone_transparent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|rr_name
argument_list|)
expr_stmt|;
block|}
name|lock_rw_wrlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|lz_enter_rr_into_zone
argument_list|(
name|z
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/** returns true if the node is terminal so no deeper domain names exist */
end_comment

begin_function
specifier|static
name|int
name|is_terminal
parameter_list|(
name|struct
name|local_data
modifier|*
name|d
parameter_list|)
block|{
comment|/* for empty nonterminals, the deeper domain names are sorted 	 * right after them, so simply check the next name in the tree  	 */
name|struct
name|local_data
modifier|*
name|n
init|=
operator|(
expr|struct
name|local_data
operator|*
operator|)
name|rbtree_next
argument_list|(
operator|&
name|d
operator|->
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|(
expr|struct
name|local_data
operator|*
operator|)
name|RBTREE_NULL
condition|)
return|return
literal|1
return|;
comment|/* last in tree, no deeper node */
if|if
condition|(
name|dname_strict_subdomain
argument_list|(
name|n
operator|->
name|name
argument_list|,
name|n
operator|->
name|namelabs
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|namelabs
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* there is a deeper node */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** delete empty terminals from tree when final data is deleted */
end_comment

begin_function
specifier|static
name|void
name|del_empty_term
parameter_list|(
name|struct
name|local_zone
modifier|*
name|z
parameter_list|,
name|struct
name|local_data
modifier|*
name|d
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|)
block|{
while|while
condition|(
name|d
operator|&&
name|d
operator|->
name|rrsets
operator|==
name|NULL
operator|&&
name|is_terminal
argument_list|(
name|d
argument_list|)
condition|)
block|{
comment|/* is this empty nonterminal? delete */
comment|/* note, no memory recycling in zone region */
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|z
operator|->
name|data
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* go up and to the next label */
if|if
condition|(
name|dname_is_root
argument_list|(
name|name
argument_list|)
condition|)
return|return;
name|dname_remove_label
argument_list|(
operator|&
name|name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|labs
operator|--
expr_stmt|;
name|d
operator|=
name|lz_find_node
argument_list|(
name|z
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|local_zones_del_data
parameter_list|(
name|struct
name|local_zones
modifier|*
name|zones
parameter_list|,
name|uint8_t
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
comment|/* find zone */
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|struct
name|local_data
modifier|*
name|d
decl_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|z
operator|=
name|local_zones_lookup
argument_list|(
name|zones
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
block|{
comment|/* no such zone, we're done */
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|lock_rw_wrlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|zones
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* find the domain */
name|d
operator|=
name|lz_find_node
argument_list|(
name|z
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
comment|/* no memory recycling for zone deletions ... */
name|d
operator|->
name|rrsets
operator|=
name|NULL
expr_stmt|;
comment|/* did we delete the soa record ? */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|z
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|z
operator|->
name|soa
operator|=
name|NULL
expr_stmt|;
comment|/* cleanup the empty nonterminals for this name */
name|del_empty_term
argument_list|(
name|z
argument_list|,
name|d
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|labs
argument_list|)
expr_stmt|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

