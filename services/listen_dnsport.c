begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * services/listen_dnsport.c - listen on port 53 for incoming DNS queries.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file has functions to get queries from clients.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_TCP_FASTOPEN
end_ifdef

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"services/listen_dnsport.h"
end_include

begin_include
include|#
directive|include
file|"services/outside_network.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"sldns/sbuffer.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UN_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** number of queued TCP connections for listen() */
end_comment

begin_define
define|#
directive|define
name|TCP_BACKLOG
value|256
end_define

begin_comment
comment|/**  * Debug print of the getaddrinfo returned address.  * @param addr: the address returned.  */
end_comment

begin_function
specifier|static
name|void
name|verbose_print_addr
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
name|verbosity
operator|>=
name|VERB_ALGO
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|void
modifier|*
name|sinaddr
init|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|->
name|ai_addr
operator|)
operator|->
name|sin_addr
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
name|sinaddr
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|inet_ntop
argument_list|(
name|addr
operator|->
name|ai_family
argument_list|,
name|sinaddr
argument_list|,
name|buf
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"(null)"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"creating %s%s socket %s %d"
argument_list|,
name|addr
operator|->
name|ai_socktype
operator|==
name|SOCK_DGRAM
condition|?
literal|"udp"
else|:
name|addr
operator|->
name|ai_socktype
operator|==
name|SOCK_STREAM
condition|?
literal|"tcp"
else|:
literal|"otherproto"
argument_list|,
name|addr
operator|->
name|ai_family
operator|==
name|AF_INET
condition|?
literal|"4"
else|:
name|addr
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|?
literal|"6"
else|:
literal|"_otherfam"
argument_list|,
name|buf
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|->
name|ai_addr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|create_udp_sock
parameter_list|(
name|int
name|family
parameter_list|,
name|int
name|socktype
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|v6only
parameter_list|,
name|int
modifier|*
name|inuse
parameter_list|,
name|int
modifier|*
name|noproto
parameter_list|,
name|int
name|rcv
parameter_list|,
name|int
name|snd
parameter_list|,
name|int
name|listen
parameter_list|,
name|int
modifier|*
name|reuseport
parameter_list|,
name|int
name|transparent
parameter_list|,
name|int
name|freebind
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_REUSEADDR
argument_list|)
operator|||
name|defined
argument_list|(
name|SO_REUSEPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|IPV6_USE_MIN_MTU
argument_list|)
operator|||
name|defined
argument_list|(
name|IP_TRANSPARENT
argument_list|)
operator|||
name|defined
argument_list|(
name|IP_BINDANY
argument_list|)
operator|||
name|defined
argument_list|(
name|IP_FREEBIND
argument_list|)
name|int
name|on
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPV6_MTU
name|int
name|mtu
init|=
name|IPV6_MIN_MTU
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SO_RCVBUFFORCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SO_RCVBUF
argument_list|)
operator|(
name|void
operator|)
name|rcv
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SO_SNDBUFFORCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SO_SNDBUF
argument_list|)
operator|(
name|void
operator|)
name|snd
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|IPV6_V6ONLY
operator|(
name|void
operator|)
name|v6only
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IP_TRANSPARENT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IP_BINDANY
argument_list|)
operator|(
name|void
operator|)
name|transparent
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IP_FREEBIND
argument_list|)
operator|(
name|void
operator|)
name|freebind
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|family
argument_list|,
name|socktype
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EAFNOSUPPORT
operator|||
name|errno
operator|==
name|EPROTONOSUPPORT
condition|)
block|{
operator|*
name|noproto
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"can't create socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEAFNOSUPPORT
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEPROTONOSUPPORT
condition|)
block|{
operator|*
name|noproto
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"can't create socket: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|listen
condition|)
block|{
ifdef|#
directive|ifdef
name|SO_REUSEADDR
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(.. SO_REUSEADDR ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOSYS
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(.. SO_REUSEADDR ..) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* SO_REUSEADDR */
ifdef|#
directive|ifdef
name|SO_REUSEPORT
comment|/* try to set SO_REUSEPORT so that incoming 		 * queries are distributed evenly among the receiving threads. 		 * Each thread must have its own socket bound to the same port, 		 * with SO_REUSEPORT set on each socket. 		 */
if|if
condition|(
name|reuseport
operator|&&
operator|*
name|reuseport
operator|&&
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEPORT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ENOPROTOOPT
if|if
condition|(
name|errno
operator|!=
name|ENOPROTOOPT
operator|||
name|verbosity
operator|>=
literal|3
condition|)
name|log_warn
argument_list|(
literal|"setsockopt(.. SO_REUSEPORT ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* this option is not essential, we can continue */
operator|*
name|reuseport
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|reuseport
expr_stmt|;
endif|#
directive|endif
comment|/* defined(SO_REUSEPORT) */
ifdef|#
directive|ifdef
name|IP_TRANSPARENT
if|if
condition|(
name|transparent
operator|&&
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TRANSPARENT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"setsockopt(.. IP_TRANSPARENT ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|IP_BINDANY
argument_list|)
if|if
condition|(
name|transparent
operator|&&
name|setsockopt
argument_list|(
name|s
argument_list|,
operator|(
name|family
operator|==
name|AF_INET6
condition|?
name|IPPROTO_IPV6
else|:
name|IPPROTO_IP
operator|)
argument_list|,
operator|(
name|family
operator|==
name|AF_INET6
condition|?
name|IPV6_BINDANY
else|:
name|IP_BINDANY
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"setsockopt(.. IP%s_BINDANY ..) failed: %s"
argument_list|,
operator|(
name|family
operator|==
name|AF_INET6
condition|?
literal|"V6"
else|:
literal|""
operator|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IP_TRANSPARENT || IP_BINDANY */
block|}
ifdef|#
directive|ifdef
name|IP_FREEBIND
if|if
condition|(
name|freebind
operator|&&
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_FREEBIND
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"setsockopt(.. IP_FREEBIND ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IP_FREEBIND */
if|if
condition|(
name|rcv
condition|)
block|{
ifdef|#
directive|ifdef
name|SO_RCVBUF
name|int
name|got
decl_stmt|;
name|socklen_t
name|slen
init|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|got
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SO_RCVBUFFORCE
comment|/* Linux specific: try to use root permission to override 		 * system limits on rcvbuf. The limit is stored in  		 * /proc/sys/net/core/rmem_max or sysctl net.core.rmem_max */
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUFFORCE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rcv
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|rcv
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EPERM
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(..., SO_RCVBUFFORCE, "
literal|"...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(..., SO_RCVBUFFORCE, "
literal|"...) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* SO_RCVBUFFORCE */
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rcv
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|rcv
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(..., SO_RCVBUF, "
literal|"...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(..., SO_RCVBUF, "
literal|"...) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* check if we got the right thing or if system 			 * reduced to some system max.  Warn if so */
if|if
condition|(
name|getsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|got
argument_list|,
operator|&
name|slen
argument_list|)
operator|>=
literal|0
operator|&&
name|got
operator|<
name|rcv
operator|/
literal|2
condition|)
block|{
name|log_warn
argument_list|(
literal|"so-rcvbuf %u was not granted. "
literal|"Got %u. To fix: start with "
literal|"root permissions(linux) or sysctl "
literal|"bigger net.core.rmem_max(linux) or "
literal|"kern.ipc.maxsockbuf(bsd) values."
argument_list|,
operator|(
name|unsigned
operator|)
name|rcv
argument_list|,
operator|(
name|unsigned
operator|)
name|got
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SO_RCVBUFFORCE
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SO_RCVBUF */
block|}
comment|/* first do RCVBUF as the receive buffer is more important */
if|if
condition|(
name|snd
condition|)
block|{
ifdef|#
directive|ifdef
name|SO_SNDBUF
name|int
name|got
decl_stmt|;
name|socklen_t
name|slen
init|=
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|got
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SO_SNDBUFFORCE
comment|/* Linux specific: try to use root permission to override 		 * system limits on sndbuf. The limit is stored in  		 * /proc/sys/net/core/wmem_max or sysctl net.core.wmem_max */
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUFFORCE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|snd
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|snd
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EPERM
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(..., SO_SNDBUFFORCE, "
literal|"...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(..., SO_SNDBUFFORCE, "
literal|"...) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* SO_SNDBUFFORCE */
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|snd
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|snd
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(..., SO_SNDBUF, "
literal|"...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(..., SO_SNDBUF, "
literal|"...) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* check if we got the right thing or if system 			 * reduced to some system max.  Warn if so */
if|if
condition|(
name|getsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|got
argument_list|,
operator|&
name|slen
argument_list|)
operator|>=
literal|0
operator|&&
name|got
operator|<
name|snd
operator|/
literal|2
condition|)
block|{
name|log_warn
argument_list|(
literal|"so-sndbuf %u was not granted. "
literal|"Got %u. To fix: start with "
literal|"root permissions(linux) or sysctl "
literal|"bigger net.core.wmem_max(linux) or "
literal|"kern.ipc.maxsockbuf(bsd) values."
argument_list|,
operator|(
name|unsigned
operator|)
name|snd
argument_list|,
operator|(
name|unsigned
operator|)
name|got
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SO_SNDBUFFORCE
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SO_SNDBUF */
block|}
if|if
condition|(
name|family
operator|==
name|AF_INET6
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPV6_V6ONLY
argument_list|)
if|if
condition|(
name|v6only
condition|)
block|{
name|int
name|val
init|=
operator|(
name|v6only
operator|==
literal|2
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|val
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_V6ONLY"
literal|", ...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_V6ONLY"
literal|", ...) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|IPV6_USE_MIN_MTU
argument_list|)
comment|/* 		 * There is no fragmentation of IPv6 datagrams 		 * during forwarding in the network. Therefore 		 * we do not send UDP datagrams larger than 		 * the minimum IPv6 MTU of 1280 octets. The 		 * EDNS0 message length can be larger if the 		 * network stack supports IPV6_USE_MIN_MTU. 		 */
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_USE_MIN_MTU
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_USE_MIN_MTU, "
literal|"...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_USE_MIN_MTU, "
literal|"...) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|IPV6_MTU
argument_list|)
comment|/* 		 * On Linux, to send no larger than 1280, the PMTUD is 		 * disabled by default for datagrams anyway, so we set 		 * the MTU to use. 		 */
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MTU
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|mtu
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|mtu
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_MTU, ...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_MTU, ...) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* IPv6 MTU */
block|}
elseif|else
if|if
condition|(
name|family
operator|==
name|AF_INET
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IP_MTU_DISCOVER
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_PMTUDISC_DONT
argument_list|)
comment|/* linux 3.15 has IP_PMTUDISC_OMIT, Hannes Frederic Sowa made it so that  * PMTU information is not accepted, but fragmentation is allowed  * if and only if the packet size exceeds the outgoing interface MTU  * (and also uses the interface mtu to determine the size of the packets).  * So there won't be any EMSGSIZE error.  Against DNS fragmentation attacks.  * FreeBSD already has same semantics without setting the option. */
name|int
name|omit_set
init|=
literal|0
decl_stmt|;
name|int
name|action
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IP_PMTUDISC_OMIT
argument_list|)
name|action
operator|=
name|IP_PMTUDISC_OMIT
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MTU_DISCOVER
argument_list|,
operator|&
name|action
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|action
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|log_err
argument_list|(
literal|"setsockopt(..., IP_MTU_DISCOVER, IP_PMTUDISC_OMIT...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|omit_set
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|omit_set
operator|==
literal|0
condition|)
block|{
name|action
operator|=
name|IP_PMTUDISC_DONT
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MTU_DISCOVER
argument_list|,
operator|&
name|action
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|action
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"setsockopt(..., IP_MTU_DISCOVER, IP_PMTUDISC_DONT...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|IP_DONTFRAG
argument_list|)
name|int
name|off
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DONTFRAG
argument_list|,
operator|&
name|off
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"setsockopt(..., IP_DONTFRAG, ...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* IPv4 MTU */
block|}
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
ifdef|#
directive|ifdef
name|EADDRINUSE
operator|*
name|inuse
operator|=
operator|(
name|errno
operator|==
name|EADDRINUSE
operator|)
expr_stmt|;
comment|/* detect freebsd jail with no ipv6 permission */
if|if
condition|(
name|family
operator|==
name|AF_INET6
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
operator|*
name|noproto
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EADDRINUSE
condition|)
block|{
name|log_err_addr
argument_list|(
literal|"can't bind socket"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EADDRINUSE */
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_WINSOCK */
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEADDRINUSE
operator|&&
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEADDRNOTAVAIL
condition|)
block|{
name|log_err_addr
argument_list|(
literal|"can't bind socket"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
block|}
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|fd_set_nonblock
argument_list|(
name|s
argument_list|)
condition|)
block|{
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
operator|*
name|inuse
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|create_tcp_accept_sock
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|addr
parameter_list|,
name|int
name|v6only
parameter_list|,
name|int
modifier|*
name|noproto
parameter_list|,
name|int
modifier|*
name|reuseport
parameter_list|,
name|int
name|transparent
parameter_list|,
name|int
name|mss
parameter_list|,
name|int
name|freebind
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_REUSEADDR
argument_list|)
operator|||
name|defined
argument_list|(
name|SO_REUSEPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|IPV6_V6ONLY
argument_list|)
operator|||
name|defined
argument_list|(
name|IP_TRANSPARENT
argument_list|)
operator|||
name|defined
argument_list|(
name|IP_BINDANY
argument_list|)
operator|||
name|defined
argument_list|(
name|IP_FREEBIND
argument_list|)
name|int
name|on
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_TCP_FASTOPEN
name|int
name|qlen
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IP_TRANSPARENT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IP_BINDANY
argument_list|)
operator|(
name|void
operator|)
name|transparent
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IP_FREEBIND
argument_list|)
operator|(
name|void
operator|)
name|freebind
expr_stmt|;
endif|#
directive|endif
name|verbose_print_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
operator|*
name|noproto
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|addr
operator|->
name|ai_family
argument_list|,
name|addr
operator|->
name|ai_socktype
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
if|if
condition|(
name|errno
operator|==
name|EAFNOSUPPORT
operator|||
name|errno
operator|==
name|EPROTONOSUPPORT
condition|)
block|{
operator|*
name|noproto
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"can't create socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEAFNOSUPPORT
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEPROTONOSUPPORT
condition|)
block|{
operator|*
name|noproto
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|log_err
argument_list|(
literal|"can't create socket: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mss
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPPROTO_TCP
argument_list|)
operator|&&
name|defined
argument_list|(
name|TCP_MAXSEG
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_MAXSEG
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|mss
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|mss
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|" setsockopt(.. TCP_MAXSEG ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|" setsockopt(.. TCP_MAXSEG ..) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|" tcp socket mss set to %d"
argument_list|,
name|mss
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|log_warn
argument_list|(
literal|" setsockopt(TCP_MAXSEG) unsupported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(IPPROTO_TCP)&& defined(TCP_MAXSEG) */
block|}
ifdef|#
directive|ifdef
name|SO_REUSEADDR
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(.. SO_REUSEADDR ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(.. SO_REUSEADDR ..) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* SO_REUSEADDR */
ifdef|#
directive|ifdef
name|IP_FREEBIND
if|if
condition|(
name|freebind
operator|&&
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_FREEBIND
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"setsockopt(.. IP_FREEBIND ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IP_FREEBIND */
ifdef|#
directive|ifdef
name|SO_REUSEPORT
comment|/* try to set SO_REUSEPORT so that incoming 	 * connections are distributed evenly among the receiving threads. 	 * Each thread must have its own socket bound to the same port, 	 * with SO_REUSEPORT set on each socket. 	 */
if|if
condition|(
name|reuseport
operator|&&
operator|*
name|reuseport
operator|&&
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEPORT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ENOPROTOOPT
if|if
condition|(
name|errno
operator|!=
name|ENOPROTOOPT
operator|||
name|verbosity
operator|>=
literal|3
condition|)
name|log_warn
argument_list|(
literal|"setsockopt(.. SO_REUSEPORT ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* this option is not essential, we can continue */
operator|*
name|reuseport
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|reuseport
expr_stmt|;
endif|#
directive|endif
comment|/* defined(SO_REUSEPORT) */
if|#
directive|if
name|defined
argument_list|(
name|IPV6_V6ONLY
argument_list|)
if|if
condition|(
name|addr
operator|->
name|ai_family
operator|==
name|AF_INET6
operator|&&
name|v6only
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_V6ONLY, ...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_V6ONLY, ...) failed: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|v6only
expr_stmt|;
endif|#
directive|endif
comment|/* IPV6_V6ONLY */
ifdef|#
directive|ifdef
name|IP_TRANSPARENT
if|if
condition|(
name|transparent
operator|&&
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TRANSPARENT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"setsockopt(.. IP_TRANSPARENT ..) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|IP_BINDANY
argument_list|)
if|if
condition|(
name|transparent
operator|&&
name|setsockopt
argument_list|(
name|s
argument_list|,
operator|(
name|addr
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|?
name|IPPROTO_IPV6
else|:
name|IPPROTO_IP
operator|)
argument_list|,
operator|(
name|addr
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|?
name|IPV6_BINDANY
else|:
name|IP_BINDANY
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"setsockopt(.. IP%s_BINDANY ..) failed: %s"
argument_list|,
operator|(
name|addr
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|?
literal|"V6"
else|:
literal|""
operator|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IP_TRANSPARENT || IP_BINDANY */
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
name|addr
operator|->
name|ai_addr
argument_list|,
name|addr
operator|->
name|ai_addrlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
comment|/* detect freebsd jail with no ipv6 permission */
if|if
condition|(
name|addr
operator|->
name|ai_family
operator|==
name|AF_INET6
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
operator|*
name|noproto
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|log_err_addr
argument_list|(
literal|"can't bind socket"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|addr
operator|->
name|ai_addr
argument_list|,
name|addr
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err_addr
argument_list|(
literal|"can't bind socket"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|addr
operator|->
name|ai_addr
argument_list|,
name|addr
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|fd_set_nonblock
argument_list|(
name|s
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|s
argument_list|,
name|TCP_BACKLOG
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|log_err
argument_list|(
literal|"can't listen: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_err
argument_list|(
literal|"can't listen: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|USE_TCP_FASTOPEN
comment|/* qlen specifies how many outstanding TFO requests to allow. Limit is a defense 	   against IP spoofing attacks as suggested in RFC7413 */
ifdef|#
directive|ifdef
name|__APPLE__
comment|/* OS X implementation only supports qlen of 1 via this call. Actual 	   value is configured by the net.inet.tcp.fastopen_backlog kernel parm. */
name|qlen
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* 5 is recommended on linux */
name|qlen
operator|=
literal|5
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_FASTOPEN
argument_list|,
operator|&
name|qlen
argument_list|,
sizeof|sizeof
argument_list|(
name|qlen
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"Setting TCP Fast Open as server failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|create_local_accept_sock
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
modifier|*
name|noproto
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYS_UN_H
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_un
name|usock
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"creating unix socket %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_UN_SUN_LEN
comment|/* this member exists on BSDs, not Linux */
name|usock
operator|.
name|sun_len
operator|=
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|usock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usock
operator|.
name|sun_family
operator|=
name|AF_LOCAL
expr_stmt|;
comment|/* length is 92-108, 104 on FreeBSD */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|usock
operator|.
name|sun_path
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|usock
operator|.
name|sun_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_LOCAL
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"Cannot create local socket %s (%s)"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|path
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
comment|/* The socket already exists and cannot be removed */
name|log_err
argument_list|(
literal|"Cannot remove old local socket %s (%s)"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|usock
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"Cannot bind local socket %s (%s)"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|fd_set_nonblock
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Cannot set non-blocking mode"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|s
argument_list|,
name|TCP_BACKLOG
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_err
argument_list|(
literal|"can't listen: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|noproto
expr_stmt|;
comment|/*unused*/
return|return
name|s
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|path
expr_stmt|;
name|log_err
argument_list|(
literal|"Local sockets are not supported"
argument_list|)
expr_stmt|;
operator|*
name|noproto
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * Create socket from getaddrinfo results  */
end_comment

begin_function
specifier|static
name|int
name|make_sock
parameter_list|(
name|int
name|stype
parameter_list|,
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
specifier|const
name|char
modifier|*
name|port
parameter_list|,
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
name|int
name|v6only
parameter_list|,
name|int
modifier|*
name|noip6
parameter_list|,
name|size_t
name|rcv
parameter_list|,
name|size_t
name|snd
parameter_list|,
name|int
modifier|*
name|reuseport
parameter_list|,
name|int
name|transparent
parameter_list|,
name|int
name|tcp_mss
parameter_list|,
name|int
name|freebind
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|,
name|s
decl_stmt|,
name|inuse
decl_stmt|,
name|noproto
decl_stmt|;
name|hints
operator|->
name|ai_socktype
operator|=
name|stype
expr_stmt|;
operator|*
name|noip6
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|getaddrinfo
argument_list|(
name|ifname
argument_list|,
name|port
argument_list|,
name|hints
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|!
name|res
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_WINSOCK
if|if
condition|(
name|r
operator|==
name|EAI_NONAME
operator|&&
name|hints
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
block|{
operator|*
name|noip6
operator|=
literal|1
expr_stmt|;
comment|/* 'Host not found' for IP6 on winXP */
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
name|log_err
argument_list|(
literal|"node %s:%s getaddrinfo: %s %s"
argument_list|,
name|ifname
condition|?
name|ifname
else|:
literal|"default"
argument_list|,
name|port
argument_list|,
name|gai_strerror
argument_list|(
name|r
argument_list|)
argument_list|,
ifdef|#
directive|ifdef
name|EAI_SYSTEM
name|r
operator|==
name|EAI_SYSTEM
condition|?
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|""
else|#
directive|else
literal|""
endif|#
directive|endif
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|stype
operator|==
name|SOCK_DGRAM
condition|)
block|{
name|verbose_print_addr
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|s
operator|=
name|create_udp_sock
argument_list|(
name|res
operator|->
name|ai_family
argument_list|,
name|res
operator|->
name|ai_socktype
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|,
name|v6only
argument_list|,
operator|&
name|inuse
argument_list|,
operator|&
name|noproto
argument_list|,
operator|(
name|int
operator|)
name|rcv
argument_list|,
operator|(
name|int
operator|)
name|snd
argument_list|,
literal|1
argument_list|,
name|reuseport
argument_list|,
name|transparent
argument_list|,
name|freebind
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
operator|&&
name|inuse
condition|)
block|{
name|log_err
argument_list|(
literal|"bind: address already in use"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
operator|-
literal|1
operator|&&
name|noproto
operator|&&
name|hints
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
block|{
operator|*
name|noip6
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|s
operator|=
name|create_tcp_accept_sock
argument_list|(
name|res
argument_list|,
name|v6only
argument_list|,
operator|&
name|noproto
argument_list|,
name|reuseport
argument_list|,
name|transparent
argument_list|,
name|tcp_mss
argument_list|,
name|freebind
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
operator|&&
name|noproto
operator|&&
name|hints
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
block|{
operator|*
name|noip6
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/** make socket and first see if ifname contains port override info */
end_comment

begin_function
specifier|static
name|int
name|make_sock_port
parameter_list|(
name|int
name|stype
parameter_list|,
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
specifier|const
name|char
modifier|*
name|port
parameter_list|,
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
name|int
name|v6only
parameter_list|,
name|int
modifier|*
name|noip6
parameter_list|,
name|size_t
name|rcv
parameter_list|,
name|size_t
name|snd
parameter_list|,
name|int
modifier|*
name|reuseport
parameter_list|,
name|int
name|transparent
parameter_list|,
name|int
name|tcp_mss
parameter_list|,
name|int
name|freebind
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|strchr
argument_list|(
name|ifname
argument_list|,
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* override port with ifspec@port */
name|char
name|p
index|[
literal|16
index|]
decl_stmt|;
name|char
name|newif
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|s
operator|-
name|ifname
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|newif
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"ifname too long: %s"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
operator|*
name|noip6
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|+
literal|1
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"portnumber too long: %s"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
operator|*
name|noip6
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|newif
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|newif
argument_list|)
argument_list|)
expr_stmt|;
name|newif
index|[
name|s
operator|-
name|ifname
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|p
argument_list|,
name|s
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
index|[
name|strlen
argument_list|(
name|s
operator|+
literal|1
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|make_sock
argument_list|(
name|stype
argument_list|,
name|newif
argument_list|,
name|p
argument_list|,
name|hints
argument_list|,
name|v6only
argument_list|,
name|noip6
argument_list|,
name|rcv
argument_list|,
name|snd
argument_list|,
name|reuseport
argument_list|,
name|transparent
argument_list|,
name|tcp_mss
argument_list|,
name|freebind
argument_list|)
return|;
block|}
return|return
name|make_sock
argument_list|(
name|stype
argument_list|,
name|ifname
argument_list|,
name|port
argument_list|,
name|hints
argument_list|,
name|v6only
argument_list|,
name|noip6
argument_list|,
name|rcv
argument_list|,
name|snd
argument_list|,
name|reuseport
argument_list|,
name|transparent
argument_list|,
name|tcp_mss
argument_list|,
name|freebind
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Add port to open ports list.  * @param list: list head. changed.  * @param s: fd.  * @param ftype: if fd is UDP.  * @return false on failure. list in unchanged then.  */
end_comment

begin_function
specifier|static
name|int
name|port_insert
parameter_list|(
name|struct
name|listen_port
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|s
parameter_list|,
name|enum
name|listen_type
name|ftype
parameter_list|)
block|{
name|struct
name|listen_port
modifier|*
name|item
init|=
operator|(
expr|struct
name|listen_port
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listen_port
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
literal|0
return|;
name|item
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
name|item
operator|->
name|fd
operator|=
name|s
expr_stmt|;
name|item
operator|->
name|ftype
operator|=
name|ftype
expr_stmt|;
operator|*
name|list
operator|=
name|item
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** set fd to receive source address packet info */
end_comment

begin_function
specifier|static
name|int
name|set_recvpktinfo
parameter_list|(
name|int
name|s
parameter_list|,
name|int
name|family
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPV6_RECVPKTINFO
argument_list|)
operator|||
name|defined
argument_list|(
name|IPV6_PKTINFO
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|IP_RECVDSTADDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_SENDSRCADDR
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|IP_PKTINFO
argument_list|)
name|int
name|on
init|=
literal|1
decl_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|s
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|family
operator|==
name|AF_INET6
condition|)
block|{
ifdef|#
directive|ifdef
name|IPV6_RECVPKTINFO
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_RECVPKTINFO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_RECVPKTINFO, ...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|IPV6_PKTINFO
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_PKTINFO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"setsockopt(..., IPV6_PKTINFO, ...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|#
directive|else
name|log_err
argument_list|(
literal|"no IPV6_RECVPKTINFO and no IPV6_PKTINFO option, please "
literal|"disable interface-automatic in config"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* defined IPV6_RECVPKTINFO */
block|}
elseif|else
if|if
condition|(
name|family
operator|==
name|AF_INET
condition|)
block|{
ifdef|#
directive|ifdef
name|IP_PKTINFO
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_PKTINFO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"setsockopt(..., IP_PKTINFO, ...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|IP_RECVDSTADDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_SENDSRCADDR
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_RECVDSTADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"setsockopt(..., IP_RECVDSTADDR, ...) failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|#
directive|else
name|log_err
argument_list|(
literal|"no IP_SENDSRCADDR or IP_PKTINFO option, please disable "
literal|"interface-automatic in config"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* IP_PKTINFO */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Helper for ports_open. Creates one interface (or NULL for default).  * @param ifname: The interface ip address.  * @param do_auto: use automatic interface detection.  * 	If enabled, then ifname must be the wildcard name.  * @param do_udp: if udp should be used.  * @param do_tcp: if udp should be used.  * @param hints: for getaddrinfo. family and flags have to be set by caller.  * @param port: Port number to use (as string).  * @param list: list of open ports, appended to, changed to point to list head.  * @param rcv: receive buffer size for UDP  * @param snd: send buffer size for UDP  * @param ssl_port: ssl service port number  * @param reuseport: try to set SO_REUSEPORT if nonNULL and true.  * 	set to false on exit if reuseport failed due to no kernel support.  * @param transparent: set IP_TRANSPARENT socket option.  * @param tcp_mss: maximum segment size of tcp socket. default if zero.  * @param freebind: set IP_FREEBIND socket option.  * @return: returns false on error.  */
end_comment

begin_function
specifier|static
name|int
name|ports_create_if
parameter_list|(
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
name|int
name|do_auto
parameter_list|,
name|int
name|do_udp
parameter_list|,
name|int
name|do_tcp
parameter_list|,
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
specifier|const
name|char
modifier|*
name|port
parameter_list|,
name|struct
name|listen_port
modifier|*
modifier|*
name|list
parameter_list|,
name|size_t
name|rcv
parameter_list|,
name|size_t
name|snd
parameter_list|,
name|int
name|ssl_port
parameter_list|,
name|int
modifier|*
name|reuseport
parameter_list|,
name|int
name|transparent
parameter_list|,
name|int
name|tcp_mss
parameter_list|,
name|int
name|freebind
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|noip6
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|do_udp
operator|&&
operator|!
name|do_tcp
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|do_auto
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|make_sock_port
argument_list|(
name|SOCK_DGRAM
argument_list|,
name|ifname
argument_list|,
name|port
argument_list|,
name|hints
argument_list|,
literal|1
argument_list|,
operator|&
name|noip6
argument_list|,
name|rcv
argument_list|,
name|snd
argument_list|,
name|reuseport
argument_list|,
name|transparent
argument_list|,
name|tcp_mss
argument_list|,
name|freebind
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|noip6
condition|)
block|{
name|log_warn
argument_list|(
literal|"IPv6 protocol not available"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* getting source addr packet info is highly non-portable */
if|if
condition|(
operator|!
name|set_recvpktinfo
argument_list|(
name|s
argument_list|,
name|hints
operator|->
name|ai_family
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|port_insert
argument_list|(
name|list
argument_list|,
name|s
argument_list|,
name|listen_type_udpancil
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|do_udp
condition|)
block|{
comment|/* regular udp socket */
if|if
condition|(
operator|(
name|s
operator|=
name|make_sock_port
argument_list|(
name|SOCK_DGRAM
argument_list|,
name|ifname
argument_list|,
name|port
argument_list|,
name|hints
argument_list|,
literal|1
argument_list|,
operator|&
name|noip6
argument_list|,
name|rcv
argument_list|,
name|snd
argument_list|,
name|reuseport
argument_list|,
name|transparent
argument_list|,
name|tcp_mss
argument_list|,
name|freebind
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|noip6
condition|)
block|{
name|log_warn
argument_list|(
literal|"IPv6 protocol not available"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|port_insert
argument_list|(
name|list
argument_list|,
name|s
argument_list|,
name|listen_type_udp
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|do_tcp
condition|)
block|{
name|int
name|is_ssl
init|=
operator|(
operator|(
name|strchr
argument_list|(
name|ifname
argument_list|,
literal|'@'
argument_list|)
operator|&&
name|atoi
argument_list|(
name|strchr
argument_list|(
name|ifname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
argument_list|)
operator|==
name|ssl_port
operator|)
operator|||
operator|(
operator|!
name|strchr
argument_list|(
name|ifname
argument_list|,
literal|'@'
argument_list|)
operator|&&
name|atoi
argument_list|(
name|port
argument_list|)
operator|==
name|ssl_port
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|make_sock_port
argument_list|(
name|SOCK_STREAM
argument_list|,
name|ifname
argument_list|,
name|port
argument_list|,
name|hints
argument_list|,
literal|1
argument_list|,
operator|&
name|noip6
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|reuseport
argument_list|,
name|transparent
argument_list|,
name|tcp_mss
argument_list|,
name|freebind
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|noip6
condition|)
block|{
comment|/*log_warn("IPv6 protocol not available");*/
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_ssl
condition|)
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"setup TCP for SSL service"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_insert
argument_list|(
name|list
argument_list|,
name|s
argument_list|,
name|is_ssl
condition|?
name|listen_type_ssl
else|:
name|listen_type_tcp
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**   * Add items to commpoint list in front.  * @param c: commpoint to add.  * @param front: listen struct.  * @return: false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|listen_cp_insert
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|struct
name|listen_dnsport
modifier|*
name|front
parameter_list|)
block|{
name|struct
name|listen_list
modifier|*
name|item
init|=
operator|(
expr|struct
name|listen_list
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listen_list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
literal|0
return|;
name|item
operator|->
name|com
operator|=
name|c
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|front
operator|->
name|cps
expr_stmt|;
name|front
operator|->
name|cps
operator|=
name|item
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|listen_dnsport
modifier|*
name|listen_create
parameter_list|(
name|struct
name|comm_base
modifier|*
name|base
parameter_list|,
name|struct
name|listen_port
modifier|*
name|ports
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|int
name|tcp_accept_count
parameter_list|,
name|void
modifier|*
name|sslctx
parameter_list|,
name|struct
name|dt_env
modifier|*
name|dtenv
parameter_list|,
name|comm_point_callback_t
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|listen_dnsport
modifier|*
name|front
init|=
operator|(
expr|struct
name|listen_dnsport
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listen_dnsport
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|front
condition|)
return|return
name|NULL
return|;
name|front
operator|->
name|cps
operator|=
name|NULL
expr_stmt|;
name|front
operator|->
name|udp_buff
operator|=
name|sldns_buffer_new
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|front
operator|->
name|udp_buff
condition|)
block|{
name|free
argument_list|(
name|front
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* create comm points as needed */
while|while
condition|(
name|ports
condition|)
block|{
name|struct
name|comm_point
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ports
operator|->
name|ftype
operator|==
name|listen_type_udp
condition|)
name|cp
operator|=
name|comm_point_create_udp
argument_list|(
name|base
argument_list|,
name|ports
operator|->
name|fd
argument_list|,
name|front
operator|->
name|udp_buff
argument_list|,
name|cb
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ports
operator|->
name|ftype
operator|==
name|listen_type_tcp
condition|)
name|cp
operator|=
name|comm_point_create_tcp
argument_list|(
name|base
argument_list|,
name|ports
operator|->
name|fd
argument_list|,
name|tcp_accept_count
argument_list|,
name|bufsize
argument_list|,
name|cb
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ports
operator|->
name|ftype
operator|==
name|listen_type_ssl
condition|)
block|{
name|cp
operator|=
name|comm_point_create_tcp
argument_list|(
name|base
argument_list|,
name|ports
operator|->
name|fd
argument_list|,
name|tcp_accept_count
argument_list|,
name|bufsize
argument_list|,
name|cb
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
name|cp
operator|->
name|ssl
operator|=
name|sslctx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ports
operator|->
name|ftype
operator|==
name|listen_type_udpancil
condition|)
name|cp
operator|=
name|comm_point_create_udp_ancil
argument_list|(
name|base
argument_list|,
name|ports
operator|->
name|fd
argument_list|,
name|front
operator|->
name|udp_buff
argument_list|,
name|cb
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|log_err
argument_list|(
literal|"can't create commpoint"
argument_list|)
expr_stmt|;
name|listen_delete
argument_list|(
name|front
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cp
operator|->
name|dtenv
operator|=
name|dtenv
expr_stmt|;
name|cp
operator|->
name|do_not_close
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|listen_cp_insert
argument_list|(
name|cp
argument_list|,
name|front
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|comm_point_delete
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|listen_delete
argument_list|(
name|front
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ports
operator|=
name|ports
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|front
operator|->
name|cps
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not open sockets to accept queries."
argument_list|)
expr_stmt|;
name|listen_delete
argument_list|(
name|front
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|front
return|;
block|}
end_function

begin_function
name|void
name|listen_list_delete
parameter_list|(
name|struct
name|listen_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|listen_list
modifier|*
name|p
init|=
name|list
decl_stmt|,
modifier|*
name|pn
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|pn
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|comm_point_delete
argument_list|(
name|p
operator|->
name|com
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|pn
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|listen_delete
parameter_list|(
name|struct
name|listen_dnsport
modifier|*
name|front
parameter_list|)
block|{
if|if
condition|(
operator|!
name|front
condition|)
return|return;
name|listen_list_delete
argument_list|(
name|front
operator|->
name|cps
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|front
operator|->
name|udp_buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|front
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|listen_port
modifier|*
name|listening_ports_open
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
name|int
modifier|*
name|reuseport
parameter_list|)
block|{
name|struct
name|listen_port
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|int
name|i
decl_stmt|,
name|do_ip4
decl_stmt|,
name|do_ip6
decl_stmt|;
name|int
name|do_tcp
decl_stmt|,
name|do_auto
decl_stmt|;
name|char
name|portbuf
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|portbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|portbuf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|cfg
operator|->
name|port
argument_list|)
expr_stmt|;
name|do_ip4
operator|=
name|cfg
operator|->
name|do_ip4
expr_stmt|;
name|do_ip6
operator|=
name|cfg
operator|->
name|do_ip6
expr_stmt|;
name|do_tcp
operator|=
name|cfg
operator|->
name|do_tcp
expr_stmt|;
name|do_auto
operator|=
name|cfg
operator|->
name|if_automatic
operator|&&
name|cfg
operator|->
name|do_udp
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|incoming_num_tcp
operator|==
literal|0
condition|)
name|do_tcp
operator|=
literal|0
expr_stmt|;
comment|/* getaddrinfo */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
comment|/* no name lookups on our listening ports */
if|if
condition|(
name|cfg
operator|->
name|num_ifs
operator|>
literal|0
condition|)
name|hints
operator|.
name|ai_flags
operator||=
name|AI_NUMERICHOST
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_UNSPEC
expr_stmt|;
ifndef|#
directive|ifndef
name|INET6
name|do_ip6
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|do_ip4
operator|&&
operator|!
name|do_ip6
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* create ip4 and ip6 ports so that return addresses are nice. */
if|if
condition|(
name|do_auto
operator|||
name|cfg
operator|->
name|num_ifs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_ip6
condition|)
block|{
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
if|if
condition|(
operator|!
name|ports_create_if
argument_list|(
name|do_auto
condition|?
literal|"::0"
else|:
literal|"::1"
argument_list|,
name|do_auto
argument_list|,
name|cfg
operator|->
name|do_udp
argument_list|,
name|do_tcp
argument_list|,
operator|&
name|hints
argument_list|,
name|portbuf
argument_list|,
operator|&
name|list
argument_list|,
name|cfg
operator|->
name|so_rcvbuf
argument_list|,
name|cfg
operator|->
name|so_sndbuf
argument_list|,
name|cfg
operator|->
name|ssl_port
argument_list|,
name|reuseport
argument_list|,
name|cfg
operator|->
name|ip_transparent
argument_list|,
name|cfg
operator|->
name|tcp_mss
argument_list|,
name|cfg
operator|->
name|ip_freebind
argument_list|)
condition|)
block|{
name|listening_ports_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|do_ip4
condition|)
block|{
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
operator|!
name|ports_create_if
argument_list|(
name|do_auto
condition|?
literal|"0.0.0.0"
else|:
literal|"127.0.0.1"
argument_list|,
name|do_auto
argument_list|,
name|cfg
operator|->
name|do_udp
argument_list|,
name|do_tcp
argument_list|,
operator|&
name|hints
argument_list|,
name|portbuf
argument_list|,
operator|&
name|list
argument_list|,
name|cfg
operator|->
name|so_rcvbuf
argument_list|,
name|cfg
operator|->
name|so_sndbuf
argument_list|,
name|cfg
operator|->
name|ssl_port
argument_list|,
name|reuseport
argument_list|,
name|cfg
operator|->
name|ip_transparent
argument_list|,
name|cfg
operator|->
name|tcp_mss
argument_list|,
name|cfg
operator|->
name|ip_freebind
argument_list|)
condition|)
block|{
name|listening_ports_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg
operator|->
name|num_ifs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str_is_ip6
argument_list|(
name|cfg
operator|->
name|ifs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|do_ip6
condition|)
continue|continue;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
if|if
condition|(
operator|!
name|ports_create_if
argument_list|(
name|cfg
operator|->
name|ifs
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|cfg
operator|->
name|do_udp
argument_list|,
name|do_tcp
argument_list|,
operator|&
name|hints
argument_list|,
name|portbuf
argument_list|,
operator|&
name|list
argument_list|,
name|cfg
operator|->
name|so_rcvbuf
argument_list|,
name|cfg
operator|->
name|so_sndbuf
argument_list|,
name|cfg
operator|->
name|ssl_port
argument_list|,
name|reuseport
argument_list|,
name|cfg
operator|->
name|ip_transparent
argument_list|,
name|cfg
operator|->
name|tcp_mss
argument_list|,
name|cfg
operator|->
name|ip_freebind
argument_list|)
condition|)
block|{
name|listening_ports_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|do_ip4
condition|)
continue|continue;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
operator|!
name|ports_create_if
argument_list|(
name|cfg
operator|->
name|ifs
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|cfg
operator|->
name|do_udp
argument_list|,
name|do_tcp
argument_list|,
operator|&
name|hints
argument_list|,
name|portbuf
argument_list|,
operator|&
name|list
argument_list|,
name|cfg
operator|->
name|so_rcvbuf
argument_list|,
name|cfg
operator|->
name|so_sndbuf
argument_list|,
name|cfg
operator|->
name|ssl_port
argument_list|,
name|reuseport
argument_list|,
name|cfg
operator|->
name|ip_transparent
argument_list|,
name|cfg
operator|->
name|tcp_mss
argument_list|,
name|cfg
operator|->
name|ip_freebind
argument_list|)
condition|)
block|{
name|listening_ports_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
end_function

begin_function
name|void
name|listening_ports_free
parameter_list|(
name|struct
name|listen_port
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|listen_port
modifier|*
name|nx
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|nx
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_WINSOCK
name|close
argument_list|(
name|list
operator|->
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|closesocket
argument_list|(
name|list
operator|->
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|nx
expr_stmt|;
block|}
block|}
end_function

begin_function
name|size_t
name|listen_get_mem
parameter_list|(
name|struct
name|listen_dnsport
modifier|*
name|listen
parameter_list|)
block|{
name|size_t
name|s
init|=
sizeof|sizeof
argument_list|(
operator|*
name|listen
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|listen
operator|->
name|base
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|listen
operator|->
name|udp_buff
argument_list|)
operator|+
name|sldns_buffer_capacity
argument_list|(
name|listen
operator|->
name|udp_buff
argument_list|)
decl_stmt|;
name|struct
name|listen_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|listen
operator|->
name|cps
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|s
operator|+=
name|comm_point_get_mem
argument_list|(
name|p
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|listen_stop_accept
parameter_list|(
name|struct
name|listen_dnsport
modifier|*
name|listen
parameter_list|)
block|{
comment|/* do not stop the ones that have no tcp_free list 	 * (they have already stopped listening) */
name|struct
name|listen_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|listen
operator|->
name|cps
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|com
operator|->
name|type
operator|==
name|comm_tcp_accept
operator|&&
name|p
operator|->
name|com
operator|->
name|tcp_free
operator|!=
name|NULL
condition|)
block|{
name|comm_point_stop_listening
argument_list|(
name|p
operator|->
name|com
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|listen_start_accept
parameter_list|(
name|struct
name|listen_dnsport
modifier|*
name|listen
parameter_list|)
block|{
comment|/* do not start the ones that have no tcp_free list, it is no 	 * use to listen to them because they have no free tcp handlers */
name|struct
name|listen_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|listen
operator|->
name|cps
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|com
operator|->
name|type
operator|==
name|comm_tcp_accept
operator|&&
name|p
operator|->
name|com
operator|->
name|tcp_free
operator|!=
name|NULL
condition|)
block|{
name|comm_point_start_listening
argument_list|(
name|p
operator|->
name|com
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

