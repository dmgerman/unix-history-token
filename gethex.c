begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************  The author of this software is David M. Gay.  Copyright (C) 1998 by Lucent Technologies All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of Lucent or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ****************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to David M. Gay (dmg at acm dot org,  * with " at " changed at "@" and " dot " changed to ".").	*/
end_comment

begin_include
include|#
directive|include
file|"gdtoaimp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE
end_ifdef

begin_include
include|#
directive|include
file|"locale.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|gethex
parameter_list|(
name|sp
parameter_list|,
name|fpi
parameter_list|,
name|exp
parameter_list|,
name|bp
parameter_list|,
name|sign
parameter_list|)
name|CONST
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
name|FPI
modifier|*
name|fpi
decl_stmt|;
name|Long
modifier|*
name|exp
decl_stmt|;
name|Bigint
modifier|*
modifier|*
name|bp
decl_stmt|;
name|int
name|sign
decl_stmt|;
else|#
directive|else
function|gethex
parameter_list|(
name|CONST
name|char
modifier|*
modifier|*
name|sp
parameter_list|,
name|FPI
modifier|*
name|fpi
parameter_list|,
name|Long
modifier|*
name|exp
parameter_list|,
name|Bigint
modifier|*
modifier|*
name|bp
parameter_list|,
name|int
name|sign
parameter_list|)
endif|#
directive|endif
block|{
name|Bigint
modifier|*
name|b
decl_stmt|;
name|CONST
name|unsigned
name|char
modifier|*
name|decpt
decl_stmt|,
modifier|*
name|s0
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
name|int
name|big
decl_stmt|,
name|esign
decl_stmt|,
name|havedig
decl_stmt|,
name|irv
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|n0
decl_stmt|,
name|nbits
decl_stmt|,
name|up
decl_stmt|,
name|zret
decl_stmt|;
name|ULong
name|L
decl_stmt|,
name|lostbits
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|Long
name|e
decl_stmt|,
name|e1
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_LOCALE_CACHE
specifier|const
name|unsigned
name|char
modifier|*
name|decimalpoint
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|localeconv
argument_list|()
operator|->
name|decimal_point
decl_stmt|;
else|#
directive|else
specifier|const
name|unsigned
name|char
modifier|*
name|decimalpoint
decl_stmt|;
specifier|static
name|unsigned
name|char
modifier|*
name|decimalpoint_cache
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s0
operator|=
name|decimalpoint_cache
operator|)
condition|)
block|{
name|s0
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|localeconv
argument_list|()
operator|->
name|decimal_point
expr_stmt|;
if|if
condition|(
operator|(
name|decimalpoint_cache
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s0
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|decimalpoint_cache
argument_list|,
name|s0
argument_list|)
expr_stmt|;
name|s0
operator|=
name|decimalpoint_cache
expr_stmt|;
block|}
block|}
name|decimalpoint
operator|=
name|s0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|hexdig
index|[
literal|'0'
index|]
condition|)
name|hexdig_init_D2A
argument_list|()
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|havedig
operator|=
literal|0
expr_stmt|;
name|s0
operator|=
operator|*
operator|(
name|CONST
name|unsigned
name|char
operator|*
operator|*
operator|)
name|sp
operator|+
literal|2
expr_stmt|;
while|while
condition|(
name|s0
index|[
name|havedig
index|]
operator|==
literal|'0'
condition|)
name|havedig
operator|++
expr_stmt|;
name|s0
operator|+=
name|havedig
expr_stmt|;
name|s
operator|=
name|s0
expr_stmt|;
name|decpt
operator|=
literal|0
expr_stmt|;
name|zret
operator|=
literal|0
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
name|havedig
operator|++
expr_stmt|;
else|else
block|{
name|zret
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
for|for
control|(
name|i
operator|=
literal|0
init|;
name|decimalpoint
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
name|decimalpoint
index|[
name|i
index|]
condition|)
goto|goto
name|pcheck
goto|;
block|}
name|decpt
operator|=
name|s
operator|+=
name|i
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|'.'
condition|)
goto|goto
name|pcheck
goto|;
name|decpt
operator|=
operator|++
name|s
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
goto|goto
name|pcheck
goto|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
name|zret
operator|=
literal|0
expr_stmt|;
name|havedig
operator|=
literal|1
expr_stmt|;
name|s0
operator|=
name|s
expr_stmt|;
block|}
while|while
condition|(
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
name|s
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|decimalpoint
operator|&&
operator|!
name|decpt
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|decimalpoint
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
name|decimalpoint
index|[
name|i
index|]
condition|)
goto|goto
name|pcheck
goto|;
block|}
name|decpt
operator|=
name|s
operator|+=
name|i
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
operator|!
name|decpt
condition|)
block|{
name|decpt
operator|=
operator|++
name|s
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|hexdig
index|[
operator|*
name|s
index|]
condition|)
name|s
operator|++
expr_stmt|;
block|}
comment|/*}*/
if|if
condition|(
name|decpt
condition|)
name|e
operator|=
operator|-
operator|(
operator|(
call|(
name|Long
call|)
argument_list|(
name|s
operator|-
name|decpt
argument_list|)
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|pcheck
label|:
name|s1
operator|=
name|s
expr_stmt|;
name|big
operator|=
name|esign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
comment|/* no break */
case|case
literal|'+'
case|:
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|hexdig
index|[
operator|*
name|s
index|]
operator|)
operator|==
literal|0
operator|||
name|n
operator|>
literal|0x19
condition|)
block|{
name|s
operator|=
name|s1
expr_stmt|;
break|break;
block|}
name|e1
operator|=
name|n
operator|-
literal|0x10
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|hexdig
index|[
operator|*
operator|++
name|s
index|]
operator|)
operator|!=
literal|0
operator|&&
name|n
operator|<=
literal|0x19
condition|)
block|{
if|if
condition|(
name|e1
operator|&
literal|0xf8000000
condition|)
name|big
operator|=
literal|1
expr_stmt|;
name|e1
operator|=
literal|10
operator|*
name|e1
operator|+
name|n
operator|-
literal|0x10
expr_stmt|;
block|}
if|if
condition|(
name|esign
condition|)
name|e1
operator|=
operator|-
name|e1
expr_stmt|;
name|e
operator|+=
name|e1
expr_stmt|;
block|}
operator|*
name|sp
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|havedig
condition|)
operator|*
name|sp
operator|=
operator|(
name|char
operator|*
operator|)
name|s0
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zret
condition|)
return|return
name|STRTOG_Zero
return|;
if|if
condition|(
name|big
condition|)
block|{
if|if
condition|(
name|esign
condition|)
block|{
switch|switch
condition|(
name|fpi
operator|->
name|rounding
condition|)
block|{
case|case
name|FPI_Round_up
case|:
if|if
condition|(
name|sign
condition|)
break|break;
goto|goto
name|ret_tiny
goto|;
case|case
name|FPI_Round_down
case|:
if|if
condition|(
operator|!
name|sign
condition|)
break|break;
goto|goto
name|ret_tiny
goto|;
block|}
goto|goto
name|retz
goto|;
name|ret_tiny
label|:
name|b
operator|=
name|Balloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|b
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
goto|goto
name|dret
goto|;
block|}
switch|switch
condition|(
name|fpi
operator|->
name|rounding
condition|)
block|{
case|case
name|FPI_Round_near
case|:
goto|goto
name|ovfl1
goto|;
case|case
name|FPI_Round_up
case|:
if|if
condition|(
operator|!
name|sign
condition|)
goto|goto
name|ovfl1
goto|;
goto|goto
name|ret_big
goto|;
case|case
name|FPI_Round_down
case|:
if|if
condition|(
name|sign
condition|)
goto|goto
name|ovfl1
goto|;
goto|goto
name|ret_big
goto|;
block|}
name|ret_big
label|:
name|nbits
operator|=
name|fpi
operator|->
name|nbits
expr_stmt|;
name|n0
operator|=
name|n
operator|=
name|nbits
operator|>>
name|kshift
expr_stmt|;
if|if
condition|(
name|nbits
operator|&
name|kmask
condition|)
operator|++
name|n
expr_stmt|;
for|for
control|(
name|j
operator|=
name|n
operator|,
name|k
operator|=
literal|0
init|;
name|j
operator|>>=
literal|1
condition|;
operator|++
name|k
control|)
empty_stmt|;
operator|*
name|bp
operator|=
name|b
operator|=
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n0
condition|;
operator|++
name|j
control|)
name|b
operator|->
name|x
index|[
name|j
index|]
operator|=
name|ALL_ON
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|n0
condition|)
name|b
operator|->
name|x
index|[
name|j
index|]
operator|=
name|ULbits
operator|>>
operator|(
name|ULbits
operator|-
operator|(
name|nbits
operator|&
name|kmask
operator|)
operator|)
expr_stmt|;
operator|*
name|exp
operator|=
name|fpi
operator|->
name|emin
expr_stmt|;
return|return
name|STRTOG_Normal
operator||
name|STRTOG_Inexlo
return|;
block|}
name|n
operator|=
name|s1
operator|-
name|s0
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|n
operator|>
operator|(
literal|1
operator|<<
name|kshift
operator|-
literal|2
operator|)
operator|-
literal|1
condition|;
name|n
operator|>>=
literal|1
control|)
name|k
operator|++
expr_stmt|;
name|b
operator|=
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|L
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
for|for
control|(
name|i
operator|=
literal|0
init|;
name|decimalpoint
index|[
name|i
operator|+
literal|1
index|]
condition|;
operator|++
name|i
control|)
empty_stmt|;
endif|#
directive|endif
while|while
condition|(
name|s1
operator|>
name|s0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
operator|*
operator|--
name|s1
operator|==
name|decimalpoint
index|[
name|i
index|]
condition|)
block|{
name|s1
operator|-=
name|i
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
if|if
condition|(
operator|*
operator|--
name|s1
operator|==
literal|'.'
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
name|ULbits
condition|)
block|{
operator|*
name|x
operator|++
operator|=
name|L
expr_stmt|;
name|L
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|L
operator||=
operator|(
name|hexdig
index|[
operator|*
name|s1
index|]
operator|&
literal|0x0f
operator|)
operator|<<
name|n
expr_stmt|;
name|n
operator|+=
literal|4
expr_stmt|;
block|}
operator|*
name|x
operator|++
operator|=
name|L
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
operator|=
name|x
operator|-
name|b
operator|->
name|x
expr_stmt|;
name|n
operator|=
name|ULbits
operator|*
name|n
operator|-
name|hi0bits
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|nbits
operator|=
name|fpi
operator|->
name|nbits
expr_stmt|;
name|lostbits
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|nbits
condition|)
block|{
name|n
operator|-=
name|nbits
expr_stmt|;
if|if
condition|(
name|any_on
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|lostbits
operator|=
literal|1
expr_stmt|;
name|k
operator|=
name|n
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|x
index|[
name|k
operator|>>
name|kshift
index|]
operator|&
literal|1
operator|<<
operator|(
name|k
operator|&
name|kmask
operator|)
condition|)
block|{
name|lostbits
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
operator|&&
name|any_on
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
condition|)
name|lostbits
operator|=
literal|3
expr_stmt|;
block|}
block|}
name|rshift
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
name|nbits
condition|)
block|{
name|n
operator|=
name|nbits
operator|-
name|n
expr_stmt|;
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e
operator|-=
name|n
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|>
name|fpi
operator|->
name|emax
condition|)
block|{
name|ovfl
label|:
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ovfl1
label|:
ifndef|#
directive|ifndef
name|NO_ERRNO
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
return|return
name|STRTOG_Infinite
operator||
name|STRTOG_Overflow
operator||
name|STRTOG_Inexhi
return|;
block|}
name|irv
operator|=
name|STRTOG_Normal
expr_stmt|;
if|if
condition|(
name|e
operator|<
name|fpi
operator|->
name|emin
condition|)
block|{
name|irv
operator|=
name|STRTOG_Denormal
expr_stmt|;
name|n
operator|=
name|fpi
operator|->
name|emin
operator|-
name|e
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|nbits
condition|)
block|{
switch|switch
condition|(
name|fpi
operator|->
name|rounding
condition|)
block|{
case|case
name|FPI_Round_near
case|:
if|if
condition|(
name|n
operator|==
name|nbits
operator|&&
operator|(
name|n
operator|<
literal|2
operator|||
name|any_on
argument_list|(
name|b
argument_list|,
name|n
operator|-
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|one_bit
goto|;
break|break;
case|case
name|FPI_Round_up
case|:
if|if
condition|(
operator|!
name|sign
condition|)
goto|goto
name|one_bit
goto|;
break|break;
case|case
name|FPI_Round_down
case|:
if|if
condition|(
name|sign
condition|)
block|{
name|one_bit
label|:
name|x
index|[
literal|0
index|]
operator|=
name|b
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
name|dret
label|:
operator|*
name|bp
operator|=
name|b
expr_stmt|;
operator|*
name|exp
operator|=
name|fpi
operator|->
name|emin
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_ERRNO
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
return|return
name|STRTOG_Denormal
operator||
name|STRTOG_Inexhi
operator||
name|STRTOG_Underflow
return|;
block|}
block|}
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|retz
label|:
ifndef|#
directive|ifndef
name|NO_ERRNO
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
return|return
name|STRTOG_Zero
operator||
name|STRTOG_Inexlo
operator||
name|STRTOG_Underflow
return|;
block|}
name|k
operator|=
name|n
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lostbits
condition|)
name|lostbits
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|lostbits
operator|=
name|any_on
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
index|[
name|k
operator|>>
name|kshift
index|]
operator|&
literal|1
operator|<<
operator|(
name|k
operator|&
name|kmask
operator|)
condition|)
name|lostbits
operator||=
literal|2
expr_stmt|;
name|nbits
operator|-=
name|n
expr_stmt|;
name|rshift
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e
operator|=
name|fpi
operator|->
name|emin
expr_stmt|;
block|}
if|if
condition|(
name|lostbits
condition|)
block|{
name|up
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fpi
operator|->
name|rounding
condition|)
block|{
case|case
name|FPI_Round_zero
case|:
break|break;
case|case
name|FPI_Round_near
case|:
if|if
condition|(
name|lostbits
operator|&
literal|2
operator|&&
operator|(
name|lostbits
operator|&
literal|1
operator|)
operator||
name|x
index|[
literal|0
index|]
operator|&
literal|1
condition|)
name|up
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FPI_Round_up
case|:
name|up
operator|=
literal|1
operator|-
name|sign
expr_stmt|;
break|break;
case|case
name|FPI_Round_down
case|:
name|up
operator|=
name|sign
expr_stmt|;
block|}
if|if
condition|(
name|up
condition|)
block|{
name|k
operator|=
name|b
operator|->
name|wds
expr_stmt|;
name|b
operator|=
name|increment
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|irv
operator|==
name|STRTOG_Denormal
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
name|fpi
operator|->
name|nbits
operator|-
literal|1
operator|&&
name|x
index|[
name|nbits
operator|>>
name|kshift
index|]
operator|&
literal|1
operator|<<
operator|(
name|nbits
operator|&
name|kmask
operator|)
condition|)
name|irv
operator|=
name|STRTOG_Normal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|wds
operator|>
name|k
operator|||
operator|(
name|n
operator|=
name|nbits
operator|&
name|kmask
operator|)
operator|!=
literal|0
operator|&&
name|hi0bits
argument_list|(
name|x
index|[
name|k
operator|-
literal|1
index|]
argument_list|)
operator|<
literal|32
operator|-
name|n
condition|)
block|{
name|rshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|e
operator|>
name|fpi
operator|->
name|emax
condition|)
goto|goto
name|ovfl
goto|;
block|}
name|irv
operator||=
name|STRTOG_Inexhi
expr_stmt|;
block|}
else|else
name|irv
operator||=
name|STRTOG_Inexlo
expr_stmt|;
block|}
operator|*
name|bp
operator|=
name|b
expr_stmt|;
operator|*
name|exp
operator|=
name|e
expr_stmt|;
return|return
name|irv
return|;
block|}
end_function

end_unit

