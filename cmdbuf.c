begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2017  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information, see the README file.  */
end_comment

begin_comment
comment|/*  * Functions which manipulate the command buffer.  * Used only by command() and related functions.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"cmd.h"
end_include

begin_include
include|#
directive|include
file|"charset.h"
end_include

begin_if
if|#
directive|if
name|HAVE_STAT
end_if

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|utf_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cmdbuf
index|[
name|CMDBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for holding a multi-char command */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cmd_col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current column of the cursor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prompt_col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Column of cursor just after prompt */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer into cmdbuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cmd_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into cmdbuf of first displayed char */
end_comment

begin_decl_stmt
specifier|static
name|int
name|literal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next input char should not be interpreted */
end_comment

begin_decl_stmt
specifier|static
name|int
name|updown_match
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix length in up/down movement */
end_comment

begin_if
if|#
directive|if
name|TAB_COMPLETE_FILENAME
end_if

begin_function_decl
specifier|static
name|int
name|cmd_complete
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * These variables are statics used by cmd_complete.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_completion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tk_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tk_original
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tk_ipoint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tk_trial
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|textlist
name|tk_tlist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|cmd_left
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmd_right
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|SPACES_IN_FILENAMES
end_if

begin_decl_stmt
name|public
name|char
name|openquote
init|=
literal|'"'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
name|closequote
init|=
literal|'"'
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CMD_HISTORY
end_if

begin_comment
comment|/* History file */
end_comment

begin_define
define|#
directive|define
name|HISTFILE_FIRST_LINE
value|".less-history-file:"
end_define

begin_define
define|#
directive|define
name|HISTFILE_SEARCH_SECTION
value|".search"
end_define

begin_define
define|#
directive|define
name|HISTFILE_SHELL_SECTION
value|".shell"
end_define

begin_comment
comment|/*  * A mlist structure represents a command history.  */
end_comment

begin_struct
struct|struct
name|mlist
block|{
name|struct
name|mlist
modifier|*
name|next
decl_stmt|;
name|struct
name|mlist
modifier|*
name|prev
decl_stmt|;
name|struct
name|mlist
modifier|*
name|curr_mp
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|modified
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * These are the various command histories that exist.  */
end_comment

begin_decl_stmt
name|struct
name|mlist
name|mlist_search
init|=
block|{
operator|&
name|mlist_search
block|,
operator|&
name|mlist_search
block|,
operator|&
name|mlist_search
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|void
modifier|*
name|ml_search
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mlist_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mlist
name|mlist_examine
init|=
block|{
operator|&
name|mlist_examine
block|,
operator|&
name|mlist_examine
block|,
operator|&
name|mlist_examine
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|void
modifier|*
name|ml_examine
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mlist_examine
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SHELL_ESCAPE
operator|||
name|PIPEC
end_if

begin_decl_stmt
name|struct
name|mlist
name|mlist_shell
init|=
block|{
operator|&
name|mlist_shell
block|,
operator|&
name|mlist_shell
block|,
operator|&
name|mlist_shell
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|void
modifier|*
name|ml_shell
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mlist_shell
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CMD_HISTORY */
end_comment

begin_comment
comment|/* If CMD_HISTORY is off, these are just flags. */
end_comment

begin_decl_stmt
name|public
name|void
modifier|*
name|ml_search
init|=
operator|(
name|void
operator|*
operator|)
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|void
modifier|*
name|ml_examine
init|=
operator|(
name|void
operator|*
operator|)
literal|2
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SHELL_ESCAPE
operator|||
name|PIPEC
end_if

begin_decl_stmt
name|public
name|void
modifier|*
name|ml_shell
init|=
operator|(
name|void
operator|*
operator|)
literal|3
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CMD_HISTORY */
end_comment

begin_comment
comment|/*  * History for the current command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mlist
modifier|*
name|curr_mlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curr_cmdflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cmd_mbc_buf
index|[
name|MAX_UTF_CHAR_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmd_mbc_buf_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmd_mbc_buf_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reset command buffer (to empty).  */
end_comment

begin_function
name|public
name|void
name|cmd_reset
parameter_list|()
block|{
name|cp
operator|=
name|cmdbuf
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cmd_col
operator|=
literal|0
expr_stmt|;
name|cmd_offset
operator|=
literal|0
expr_stmt|;
name|literal
operator|=
literal|0
expr_stmt|;
name|cmd_mbc_buf_len
operator|=
literal|0
expr_stmt|;
name|updown_match
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear command line.  */
end_comment

begin_function
name|public
name|void
name|clear_cmd
parameter_list|()
block|{
name|cmd_col
operator|=
name|prompt_col
operator|=
literal|0
expr_stmt|;
name|cmd_mbc_buf_len
operator|=
literal|0
expr_stmt|;
name|updown_match
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display a string, usually as a prompt for input into the command buffer.  */
end_comment

begin_function
name|public
name|void
name|cmd_putstr
parameter_list|(
name|s
parameter_list|)
name|constant
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|LWCHAR
name|prev_ch
init|=
literal|0
decl_stmt|;
name|LWCHAR
name|ch
decl_stmt|;
name|constant
name|char
modifier|*
name|endline
init|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|ns
init|=
operator|(
name|char
operator|*
operator|)
name|s
decl_stmt|;
name|int
name|width
decl_stmt|;
name|ch
operator|=
name|step_char
argument_list|(
operator|&
name|ns
argument_list|,
operator|+
literal|1
argument_list|,
name|endline
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|ns
condition|)
name|putchr
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|utf_mode
condition|)
name|width
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|is_composing_char
argument_list|(
name|ch
argument_list|)
operator|||
name|is_combining_char
argument_list|(
name|prev_ch
argument_list|,
name|ch
argument_list|)
condition|)
name|width
operator|=
literal|0
expr_stmt|;
else|else
name|width
operator|=
name|is_wide_char
argument_list|(
name|ch
argument_list|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|cmd_col
operator|+=
name|width
expr_stmt|;
name|prompt_col
operator|+=
name|width
expr_stmt|;
name|prev_ch
operator|=
name|ch
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * How many characters are in the command buffer?  */
end_comment

begin_function
name|public
name|int
name|len_cmdbuf
parameter_list|()
block|{
name|char
modifier|*
name|s
init|=
name|cmdbuf
decl_stmt|;
name|char
modifier|*
name|endline
init|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|step_char
argument_list|(
operator|&
name|s
argument_list|,
operator|+
literal|1
argument_list|,
name|endline
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common part of cmd_step_right() and cmd_step_left().  * {{ Returning pwidth and bswidth separately is a historical artifact  *    since they're always the same. Maybe clean this up someday. }}  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cmd_step_common
parameter_list|(
name|p
parameter_list|,
name|ch
parameter_list|,
name|len
parameter_list|,
name|pwidth
parameter_list|,
name|bswidth
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|LWCHAR
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|pwidth
decl_stmt|;
name|int
modifier|*
name|bswidth
decl_stmt|;
block|{
name|char
modifier|*
name|pr
decl_stmt|;
name|int
name|width
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|pr
operator|=
name|prchar
argument_list|(
operator|(
name|int
operator|)
name|ch
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pr
operator|=
name|prutfchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_composing_char
argument_list|(
name|ch
argument_list|)
condition|)
name|width
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|is_ubin_char
argument_list|(
name|ch
argument_list|)
condition|)
name|width
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|pr
argument_list|)
expr_stmt|;
else|else
block|{
name|LWCHAR
name|prev_ch
init|=
name|step_char
argument_list|(
operator|&
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|cmdbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_combining_char
argument_list|(
name|prev_ch
argument_list|,
name|ch
argument_list|)
condition|)
name|width
operator|=
literal|0
expr_stmt|;
else|else
name|width
operator|=
name|is_wide_char
argument_list|(
name|ch
argument_list|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pwidth
operator|!=
name|NULL
condition|)
operator|*
name|pwidth
operator|=
name|width
expr_stmt|;
if|if
condition|(
name|bswidth
operator|!=
name|NULL
condition|)
operator|*
name|bswidth
operator|=
name|width
expr_stmt|;
return|return
operator|(
name|pr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Step a pointer one character right in the command buffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cmd_step_right
parameter_list|(
name|pp
parameter_list|,
name|pwidth
parameter_list|,
name|bswidth
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
modifier|*
name|pwidth
decl_stmt|;
name|int
modifier|*
name|bswidth
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|LWCHAR
name|ch
init|=
name|step_char
argument_list|(
name|pp
argument_list|,
operator|+
literal|1
argument_list|,
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cmd_step_common
argument_list|(
name|p
argument_list|,
name|ch
argument_list|,
operator|*
name|pp
operator|-
name|p
argument_list|,
name|pwidth
argument_list|,
name|bswidth
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Step a pointer one character left in the command buffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cmd_step_left
parameter_list|(
name|pp
parameter_list|,
name|pwidth
parameter_list|,
name|bswidth
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
modifier|*
name|pwidth
decl_stmt|;
name|int
modifier|*
name|bswidth
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|LWCHAR
name|ch
init|=
name|step_char
argument_list|(
name|pp
argument_list|,
operator|-
literal|1
argument_list|,
name|cmdbuf
argument_list|)
decl_stmt|;
return|return
name|cmd_step_common
argument_list|(
operator|*
name|pp
argument_list|,
name|ch
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|,
name|pwidth
argument_list|,
name|bswidth
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Repaint the line from cp onwards.  * Then position the cursor just after the char old_cp (a pointer into cmdbuf).  */
end_comment

begin_function
specifier|static
name|void
name|cmd_repaint
parameter_list|(
name|old_cp
parameter_list|)
name|constant
name|char
modifier|*
name|old_cp
decl_stmt|;
block|{
comment|/* 	 * Repaint the line from the current position. 	 */
name|clear_eol
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|np
init|=
name|cp
decl_stmt|;
name|int
name|width
decl_stmt|;
name|char
modifier|*
name|pr
init|=
name|cmd_step_right
argument_list|(
operator|&
name|np
argument_list|,
operator|&
name|width
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmd_col
operator|+
name|width
operator|>=
name|sc_width
condition|)
break|break;
name|cp
operator|=
name|np
expr_stmt|;
name|putstr
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|cmd_col
operator|+=
name|width
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|np
init|=
name|cp
decl_stmt|;
name|int
name|width
decl_stmt|;
name|char
modifier|*
name|pr
init|=
name|cmd_step_right
argument_list|(
operator|&
name|np
argument_list|,
operator|&
name|width
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
condition|)
break|break;
name|cp
operator|=
name|np
expr_stmt|;
name|putstr
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Back up the cursor to the correct position. 	 */
while|while
condition|(
name|cp
operator|>
name|old_cp
condition|)
name|cmd_left
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put the cursor at "home" (just after the prompt),  * and set cp to the corresponding char in cmdbuf.  */
end_comment

begin_function
specifier|static
name|void
name|cmd_home
parameter_list|()
block|{
while|while
condition|(
name|cmd_col
operator|>
name|prompt_col
condition|)
block|{
name|int
name|width
decl_stmt|,
name|bswidth
decl_stmt|;
name|cmd_step_left
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|bswidth
argument_list|)
expr_stmt|;
while|while
condition|(
name|bswidth
operator|--
operator|>
literal|0
condition|)
name|putbs
argument_list|()
expr_stmt|;
name|cmd_col
operator|-=
name|width
expr_stmt|;
block|}
name|cp
operator|=
operator|&
name|cmdbuf
index|[
name|cmd_offset
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shift the cmdbuf display left a half-screen.  */
end_comment

begin_function
specifier|static
name|void
name|cmd_lshift
parameter_list|()
block|{
name|constant
name|char
modifier|*
name|s
decl_stmt|;
name|constant
name|char
modifier|*
name|save_cp
decl_stmt|;
name|int
name|cols
decl_stmt|;
comment|/* 	 * Start at the first displayed char, count how far to the 	 * right we'd have to move to reach the center of the screen. 	 */
name|s
operator|=
name|cmdbuf
operator|+
name|cmd_offset
expr_stmt|;
name|cols
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cols
operator|<
operator|(
name|sc_width
operator|-
name|prompt_col
operator|)
operator|/
literal|2
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|width
decl_stmt|;
name|cmd_step_right
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|width
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cols
operator|+=
name|width
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|width
decl_stmt|;
name|constant
name|char
modifier|*
name|ns
init|=
name|s
decl_stmt|;
name|cmd_step_right
argument_list|(
operator|&
name|ns
argument_list|,
operator|&
name|width
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
condition|)
break|break;
name|s
operator|=
name|ns
expr_stmt|;
block|}
name|cmd_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|-
name|cmdbuf
argument_list|)
expr_stmt|;
name|save_cp
operator|=
name|cp
expr_stmt|;
name|cmd_home
argument_list|()
expr_stmt|;
name|cmd_repaint
argument_list|(
name|save_cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shift the cmdbuf display right a half-screen.  */
end_comment

begin_function
specifier|static
name|void
name|cmd_rshift
parameter_list|()
block|{
name|constant
name|char
modifier|*
name|s
decl_stmt|;
name|constant
name|char
modifier|*
name|save_cp
decl_stmt|;
name|int
name|cols
decl_stmt|;
comment|/* 	 * Start at the first displayed char, count how far to the 	 * left we'd have to move to traverse a half-screen width 	 * of displayed characters. 	 */
name|s
operator|=
name|cmdbuf
operator|+
name|cmd_offset
expr_stmt|;
name|cols
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cols
operator|<
operator|(
name|sc_width
operator|-
name|prompt_col
operator|)
operator|/
literal|2
operator|&&
name|s
operator|>
name|cmdbuf
condition|)
block|{
name|int
name|width
decl_stmt|;
name|cmd_step_left
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|width
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cols
operator|+=
name|width
expr_stmt|;
block|}
name|cmd_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|-
name|cmdbuf
argument_list|)
expr_stmt|;
name|save_cp
operator|=
name|cp
expr_stmt|;
name|cmd_home
argument_list|()
expr_stmt|;
name|cmd_repaint
argument_list|(
name|save_cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move cursor right one character.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_right
parameter_list|()
block|{
name|char
modifier|*
name|pr
decl_stmt|;
name|char
modifier|*
name|ncp
decl_stmt|;
name|int
name|width
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/* Already at the end of the line. */
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
name|ncp
operator|=
name|cp
expr_stmt|;
name|pr
operator|=
name|cmd_step_right
argument_list|(
operator|&
name|ncp
argument_list|,
operator|&
name|width
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_col
operator|+
name|width
operator|>=
name|sc_width
condition|)
name|cmd_lshift
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd_col
operator|+
name|width
operator|==
name|sc_width
operator|-
literal|1
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|cmd_lshift
argument_list|()
expr_stmt|;
name|cp
operator|=
name|ncp
expr_stmt|;
name|cmd_col
operator|+=
name|width
expr_stmt|;
name|putstr
argument_list|(
name|pr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|pr
operator|=
name|cmd_step_right
argument_list|(
operator|&
name|ncp
argument_list|,
operator|&
name|width
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
condition|)
break|break;
name|putstr
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ncp
expr_stmt|;
block|}
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move cursor left one character.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_left
parameter_list|()
block|{
name|char
modifier|*
name|ncp
decl_stmt|;
name|int
name|width
decl_stmt|,
name|bswidth
decl_stmt|;
if|if
condition|(
name|cp
operator|<=
name|cmdbuf
condition|)
block|{
comment|/* Already at the beginning of the line */
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
name|ncp
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|ncp
operator|>
name|cmdbuf
condition|)
block|{
name|cmd_step_left
argument_list|(
operator|&
name|ncp
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|bswidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|cmd_col
operator|<
name|prompt_col
operator|+
name|width
condition|)
name|cmd_rshift
argument_list|()
expr_stmt|;
name|cp
operator|=
name|ncp
expr_stmt|;
name|cmd_col
operator|-=
name|width
expr_stmt|;
while|while
condition|(
name|bswidth
operator|--
operator|>
literal|0
condition|)
name|putbs
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a char into the command buffer, at the current position.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_ichar
parameter_list|(
name|cs
parameter_list|,
name|clen
parameter_list|)
name|char
modifier|*
name|cs
decl_stmt|;
name|int
name|clen
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cmdbuf
argument_list|)
operator|+
name|clen
operator|>=
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
operator|-
literal|1
condition|)
block|{
comment|/* No room in the command buffer for another char. */
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_ERROR
operator|)
return|;
block|}
comment|/* 	 * Make room for the new character (shift the tail of the buffer right). 	 */
for|for
control|(
name|s
operator|=
operator|&
name|cmdbuf
index|[
name|strlen
argument_list|(
name|cmdbuf
argument_list|)
index|]
init|;
name|s
operator|>=
name|cp
condition|;
name|s
operator|--
control|)
name|s
index|[
name|clen
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Insert the character into the buffer. 	 */
for|for
control|(
name|s
operator|=
name|cp
init|;
name|s
operator|<
name|cp
operator|+
name|clen
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
operator|*
name|cs
operator|++
expr_stmt|;
comment|/* 	 * Reprint the tail of the line from the inserted char. 	 */
name|updown_match
operator|=
operator|-
literal|1
expr_stmt|;
name|cmd_repaint
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cmd_right
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Backspace in the command buffer.  * Delete the char to the left of the cursor.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_erase
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|clen
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|cmdbuf
condition|)
block|{
comment|/* 		 * Backspace past beginning of the buffer: 		 * this usually means abort the command. 		 */
return|return
operator|(
name|CC_QUIT
operator|)
return|;
block|}
comment|/* 	 * Move cursor left (to the char being erased). 	 */
name|s
operator|=
name|cp
expr_stmt|;
name|cmd_left
argument_list|()
expr_stmt|;
name|clen
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|-
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the char from the buffer (shift the buffer left). 	 */
for|for
control|(
name|s
operator|=
name|cp
init|;
condition|;
name|s
operator|++
control|)
block|{
name|s
index|[
literal|0
index|]
operator|=
name|s
index|[
name|clen
index|]
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
block|}
comment|/* 	 * Repaint the buffer after the erased char. 	 */
name|updown_match
operator|=
operator|-
literal|1
expr_stmt|;
name|cmd_repaint
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * We say that erasing the entire command string causes us 	 * to abort the current command, if CF_QUIT_ON_ERASE is set. 	 */
if|if
condition|(
operator|(
name|curr_cmdflags
operator|&
name|CF_QUIT_ON_ERASE
operator|)
operator|&&
name|cp
operator|==
name|cmdbuf
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|CC_QUIT
operator|)
return|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the char under the cursor.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_delete
parameter_list|()
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/* At end of string; there is no char under the cursor. */
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
comment|/* 	 * Move right, then use cmd_erase. 	 */
name|cmd_right
argument_list|()
expr_stmt|;
name|cmd_erase
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the "word" to the left of the cursor.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_werase
parameter_list|()
block|{
if|if
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* 		 * If the char left of cursor is a space, 		 * erase all the spaces left of cursor (to the first non-space). 		 */
while|while
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|(
name|void
operator|)
name|cmd_erase
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the char left of cursor is not a space, 		 * erase all the nonspaces left of cursor (the whole "word"). 		 */
while|while
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
operator|(
name|void
operator|)
name|cmd_erase
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the "word" under the cursor.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_wdelete
parameter_list|()
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
block|{
comment|/* 		 * If the char under the cursor is a space, 		 * delete it and all the spaces right of cursor. 		 */
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
operator|(
name|void
operator|)
name|cmd_delete
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the char under the cursor is not a space, 		 * delete it and all nonspaces right of cursor (the whole word). 		 */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|cmd_delete
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete all chars in the command buffer.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_kill
parameter_list|()
block|{
if|if
condition|(
name|cmdbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Buffer is already empty; abort the current command. */
return|return
operator|(
name|CC_QUIT
operator|)
return|;
block|}
name|cmd_offset
operator|=
literal|0
expr_stmt|;
name|cmd_home
argument_list|()
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|updown_match
operator|=
operator|-
literal|1
expr_stmt|;
name|cmd_repaint
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * We say that erasing the entire command string causes us 	 * to abort the current command, if CF_QUIT_ON_ERASE is set. 	 */
if|if
condition|(
name|curr_cmdflags
operator|&
name|CF_QUIT_ON_ERASE
condition|)
return|return
operator|(
name|CC_QUIT
operator|)
return|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Select an mlist structure to be the current command history.  */
end_comment

begin_function
name|public
name|void
name|set_mlist
parameter_list|(
name|mlist
parameter_list|,
name|cmdflags
parameter_list|)
name|void
modifier|*
name|mlist
decl_stmt|;
name|int
name|cmdflags
decl_stmt|;
block|{
if|#
directive|if
name|CMD_HISTORY
name|curr_mlist
operator|=
operator|(
expr|struct
name|mlist
operator|*
operator|)
name|mlist
expr_stmt|;
name|curr_cmdflags
operator|=
name|cmdflags
expr_stmt|;
comment|/* Make sure the next up-arrow moves to the last string in the mlist. */
if|if
condition|(
name|curr_mlist
operator|!=
name|NULL
condition|)
name|curr_mlist
operator|->
name|curr_mp
operator|=
name|curr_mlist
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|CMD_HISTORY
end_if

begin_comment
comment|/*  * Move up or down in the currently selected command history list.  * Only consider entries whose first updown_match chars are equal to  * cmdbuf's corresponding chars.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_updown
parameter_list|(
name|action
parameter_list|)
name|int
name|action
decl_stmt|;
block|{
name|constant
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|mlist
modifier|*
name|ml
decl_stmt|;
if|if
condition|(
name|curr_mlist
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The current command has no history list. 		 */
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
if|if
condition|(
name|updown_match
operator|<
literal|0
condition|)
block|{
name|updown_match
operator|=
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
name|cmdbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the next history entry which matches. 	 */
for|for
control|(
name|ml
operator|=
name|curr_mlist
operator|->
name|curr_mp
init|;
condition|;
control|)
block|{
name|ml
operator|=
operator|(
name|action
operator|==
name|EC_UP
operator|)
condition|?
name|ml
operator|->
name|prev
else|:
name|ml
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ml
operator|==
name|curr_mlist
condition|)
block|{
comment|/* 			 * We reached the end (or beginning) of the list. 			 */
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cmdbuf
argument_list|,
name|ml
operator|->
name|string
argument_list|,
name|updown_match
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This entry matches; stop here. 			 * Copy the entry into cmdbuf and echo it on the screen. 			 */
name|curr_mlist
operator|->
name|curr_mp
operator|=
name|ml
expr_stmt|;
name|s
operator|=
name|ml
operator|->
name|string
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|""
expr_stmt|;
name|cmd_home
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|cmdbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cmdbuf
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
control|)
name|cmd_right
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
block|}
comment|/* 	 * We didn't find a history entry that matches. 	 */
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Add a string to an mlist.  */
end_comment

begin_function
name|public
name|void
name|cmd_addhist
parameter_list|(
name|mlist
parameter_list|,
name|cmd
parameter_list|,
name|modified
parameter_list|)
name|struct
name|mlist
modifier|*
name|mlist
decl_stmt|;
name|constant
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|modified
decl_stmt|;
block|{
if|#
directive|if
name|CMD_HISTORY
name|struct
name|mlist
modifier|*
name|ml
decl_stmt|;
comment|/* 	 * Don't save a trivial command. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Save the command unless it's a duplicate of the 	 * last command in the history. 	 */
name|ml
operator|=
name|mlist
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|ml
operator|==
name|mlist
operator|||
name|strcmp
argument_list|(
name|ml
operator|->
name|string
argument_list|,
name|cmd
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Did not find command in history. 		 * Save the command and put it at the end of the history list. 		 */
name|ml
operator|=
operator|(
expr|struct
name|mlist
operator|*
operator|)
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlist
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|string
operator|=
name|save
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ml
operator|->
name|modified
operator|=
name|modified
expr_stmt|;
name|ml
operator|->
name|next
operator|=
name|mlist
expr_stmt|;
name|ml
operator|->
name|prev
operator|=
name|mlist
operator|->
name|prev
expr_stmt|;
name|mlist
operator|->
name|prev
operator|->
name|next
operator|=
name|ml
expr_stmt|;
name|mlist
operator|->
name|prev
operator|=
name|ml
expr_stmt|;
block|}
comment|/* 	 * Point to the cmd just after the just-accepted command. 	 * Thus, an UPARROW will always retrieve the previous command. 	 */
name|mlist
operator|->
name|curr_mp
operator|=
name|ml
operator|->
name|next
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Accept the command in the command buffer.  * Add it to the currently selected history list.  */
end_comment

begin_function
name|public
name|void
name|cmd_accept
parameter_list|()
block|{
if|#
directive|if
name|CMD_HISTORY
comment|/* 	 * Nothing to do if there is no currently selected history list. 	 */
if|if
condition|(
name|curr_mlist
operator|==
name|NULL
condition|)
return|return;
name|cmd_addhist
argument_list|(
name|curr_mlist
argument_list|,
name|cmdbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curr_mlist
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Try to perform a line-edit function on the command buffer,  * using a specified char as a line-editing command.  * Returns:  *	CC_PASS	The char does not invoke a line edit function.  *	CC_OK	Line edit function done.  *	CC_QUIT	The char requests the current command to be aborted.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_edit
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|action
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|#
directive|if
name|TAB_COMPLETE_FILENAME
define|#
directive|define
name|not_in_completion
parameter_list|()
value|in_completion = 0
else|#
directive|else
define|#
directive|define
name|not_in_completion
parameter_list|()
endif|#
directive|endif
comment|/* 	 * See if the char is indeed a line-editing command. 	 */
name|flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|CMD_HISTORY
if|if
condition|(
name|curr_mlist
operator|==
name|NULL
condition|)
comment|/* 		 * No current history; don't accept history manipulation cmds. 		 */
name|flags
operator||=
name|EC_NOHISTORY
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TAB_COMPLETE_FILENAME
if|if
condition|(
name|curr_mlist
operator|==
name|ml_search
condition|)
comment|/* 		 * In a search command; don't accept file-completion cmds. 		 */
name|flags
operator||=
name|EC_NOCOMPLETE
expr_stmt|;
endif|#
directive|endif
name|action
operator|=
name|editchar
argument_list|(
name|c
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|EC_RIGHT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_right
argument_list|()
operator|)
return|;
case|case
name|EC_LEFT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_left
argument_list|()
operator|)
return|;
case|case
name|EC_W_RIGHT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|)
name|cmd_right
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cmd_right
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_W_LEFT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|cmd_left
argument_list|()
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
name|cmd_left
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_HOME
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
name|cmd_offset
operator|=
literal|0
expr_stmt|;
name|cmd_home
argument_list|()
expr_stmt|;
name|cmd_repaint
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_END
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cmd_right
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_INSERT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_BACKSPACE
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_erase
argument_list|()
operator|)
return|;
case|case
name|EC_LINEKILL
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_kill
argument_list|()
operator|)
return|;
case|case
name|EC_ABORT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|cmd_kill
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_QUIT
operator|)
return|;
case|case
name|EC_W_BACKSPACE
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_werase
argument_list|()
operator|)
return|;
case|case
name|EC_DELETE
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_delete
argument_list|()
operator|)
return|;
case|case
name|EC_W_DELETE
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_wdelete
argument_list|()
operator|)
return|;
case|case
name|EC_LITERAL
case|:
name|literal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
if|#
directive|if
name|CMD_HISTORY
case|case
name|EC_UP
case|:
case|case
name|EC_DOWN
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_updown
argument_list|(
name|action
argument_list|)
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|TAB_COMPLETE_FILENAME
case|case
name|EC_F_COMPLETE
case|:
case|case
name|EC_B_COMPLETE
case|:
case|case
name|EC_EXPAND
case|:
return|return
operator|(
name|cmd_complete
argument_list|(
name|action
argument_list|)
operator|)
return|;
endif|#
directive|endif
case|case
name|EC_NOACTION
case|:
return|return
operator|(
name|CC_OK
operator|)
return|;
default|default:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_PASS
operator|)
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|TAB_COMPLETE_FILENAME
end_if

begin_comment
comment|/*  * Insert a string into the command buffer, at the current position.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_istr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|action
decl_stmt|;
name|char
modifier|*
name|endline
init|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|char
modifier|*
name|os
init|=
name|s
decl_stmt|;
name|step_char
argument_list|(
operator|&
name|s
argument_list|,
operator|+
literal|1
argument_list|,
name|endline
argument_list|)
expr_stmt|;
name|action
operator|=
name|cmd_ichar
argument_list|(
name|os
argument_list|,
name|s
operator|-
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|CC_OK
condition|)
block|{
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the beginning and end of the "current" word.  * This is the word which the cursor (cp) is inside or at the end of.  * Return pointer to the beginning of the word and put the  * cursor at the end of the word.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|delimit_word
parameter_list|()
block|{
name|char
modifier|*
name|word
decl_stmt|;
if|#
directive|if
name|SPACES_IN_FILENAMES
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|delim_quoted
init|=
literal|0
decl_stmt|;
name|int
name|meta_quoted
init|=
literal|0
decl_stmt|;
name|constant
name|char
modifier|*
name|esc
init|=
name|get_meta_escape
argument_list|()
decl_stmt|;
name|int
name|esclen
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|esc
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Move cursor to end of word. 	 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 		 * Cursor is on a nonspace. 		 * Move cursor right to the next space. 		 */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cmd_right
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
comment|/* 		 * Cursor is on a space, and char to the left is a nonspace. 		 * We're already at the end of the word. 		 */
empty_stmt|;
if|#
directive|if
literal|0
block|} else 	{
comment|/* 		 * Cursor is on a space and char to the left is a space. 		 * Huh? There's no word here. 		 */
block|return (NULL);
endif|#
directive|endif
block|}
comment|/* 	 * Find the beginning of the word which the cursor is in. 	 */
if|if
condition|(
name|cp
operator|==
name|cmdbuf
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|#
directive|if
name|SPACES_IN_FILENAMES
comment|/* 	 * If we have an unbalanced quote (that is, an open quote 	 * without a corresponding close quote), we return everything 	 * from the open quote, including spaces. 	 */
for|for
control|(
name|word
operator|=
name|cmdbuf
init|;
name|word
operator|<
name|cp
condition|;
name|word
operator|++
control|)
if|if
condition|(
operator|*
name|word
operator|!=
literal|' '
condition|)
break|break;
if|if
condition|(
name|word
operator|>=
name|cp
condition|)
return|return
operator|(
name|cp
operator|)
return|;
for|for
control|(
name|p
operator|=
name|cmdbuf
init|;
name|p
operator|<
name|cp
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|meta_quoted
condition|)
block|{
name|meta_quoted
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|esclen
operator|>
literal|0
operator|&&
name|p
operator|+
name|esclen
operator|<
name|cp
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
name|esc
argument_list|,
name|esclen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|meta_quoted
operator|=
literal|1
expr_stmt|;
name|p
operator|+=
name|esclen
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delim_quoted
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|closequote
condition|)
name|delim_quoted
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* (!delim_quoted) */
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|openquote
condition|)
name|delim_quoted
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|word
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|word
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set things up to enter completion mode.  * Expand the word under the cursor into a list of filenames   * which start with that word, and set tk_text to that list.  */
end_comment

begin_function
specifier|static
name|void
name|init_compl
parameter_list|()
block|{
name|char
modifier|*
name|word
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* 	 * Get rid of any previous tk_text. 	 */
if|if
condition|(
name|tk_text
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tk_text
argument_list|)
expr_stmt|;
name|tk_text
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Find the original (uncompleted) word in the command buffer. 	 */
name|word
operator|=
name|delimit_word
argument_list|()
expr_stmt|;
if|if
condition|(
name|word
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Set the insertion point to the point in the command buffer 	 * where the original (uncompleted) word now sits. 	 */
name|tk_ipoint
operator|=
name|word
expr_stmt|;
comment|/* 	 * Save the original (uncompleted) word 	 */
if|if
condition|(
name|tk_original
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tk_original
argument_list|)
expr_stmt|;
name|tk_original
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|cp
operator|-
name|word
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tk_original
argument_list|,
name|word
argument_list|,
name|cp
operator|-
name|word
argument_list|)
expr_stmt|;
comment|/* 	 * Get the expanded filename. 	 * This may result in a single filename, or 	 * a blank-separated list of filenames. 	 */
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|word
operator|!=
name|openquote
condition|)
block|{
name|tk_text
operator|=
name|fcomplete
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|MSDOS_COMPILER
name|char
modifier|*
name|qword
init|=
name|NULL
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|qword
init|=
name|shell_quote
argument_list|(
name|word
operator|+
literal|1
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qword
operator|==
name|NULL
condition|)
name|tk_text
operator|=
name|fcomplete
argument_list|(
name|word
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|tk_text
operator|=
name|fcomplete
argument_list|(
name|qword
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qword
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the next word in the current completion list.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next_compl
parameter_list|(
name|action
parameter_list|,
name|prev
parameter_list|)
name|int
name|action
decl_stmt|;
name|char
modifier|*
name|prev
decl_stmt|;
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|EC_F_COMPLETE
case|:
return|return
operator|(
name|forw_textlist
argument_list|(
operator|&
name|tk_tlist
argument_list|,
name|prev
argument_list|)
operator|)
return|;
case|case
name|EC_B_COMPLETE
case|:
return|return
operator|(
name|back_textlist
argument_list|(
operator|&
name|tk_tlist
argument_list|,
name|prev
argument_list|)
operator|)
return|;
block|}
comment|/* Cannot happen */
return|return
operator|(
literal|"?"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Complete the filename before (or under) the cursor.  * cmd_complete may be called multiple times.  The global in_completion  * remembers whether this call is the first time (create the list),  * or a subsequent time (step thru the list).  */
end_comment

begin_function
specifier|static
name|int
name|cmd_complete
parameter_list|(
name|action
parameter_list|)
name|int
name|action
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|in_completion
operator|||
name|action
operator|==
name|EC_EXPAND
condition|)
block|{
comment|/* 		 * Expand the word under the cursor and  		 * use the first word in the expansion  		 * (or the entire expansion if we're doing EC_EXPAND). 		 */
name|init_compl
argument_list|()
expr_stmt|;
if|if
condition|(
name|tk_text
operator|==
name|NULL
condition|)
block|{
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
if|if
condition|(
name|action
operator|==
name|EC_EXPAND
condition|)
block|{
comment|/* 			 * Use the whole list. 			 */
name|tk_trial
operator|=
name|tk_text
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Use the first filename in the list. 			 */
name|in_completion
operator|=
literal|1
expr_stmt|;
name|init_textlist
argument_list|(
operator|&
name|tk_tlist
argument_list|,
name|tk_text
argument_list|)
expr_stmt|;
name|tk_trial
operator|=
name|next_compl
argument_list|(
name|action
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We already have a completion list. 		 * Use the next/previous filename from the list. 		 */
name|tk_trial
operator|=
name|next_compl
argument_list|(
name|action
argument_list|,
name|tk_trial
argument_list|)
expr_stmt|;
block|}
comment|/*   	 * Remove the original word, or the previous trial completion.   	 */
while|while
condition|(
name|cp
operator|>
name|tk_ipoint
condition|)
operator|(
name|void
operator|)
name|cmd_erase
argument_list|()
expr_stmt|;
if|if
condition|(
name|tk_trial
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * There are no more trial completions. 		 * Insert the original (uncompleted) filename. 		 */
name|in_completion
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd_istr
argument_list|(
name|tk_original
argument_list|)
operator|!=
name|CC_OK
condition|)
goto|goto
name|fail
goto|;
block|}
else|else
block|{
comment|/* 		 * Insert trial completion. 		 */
if|if
condition|(
name|cmd_istr
argument_list|(
name|tk_trial
argument_list|)
operator|!=
name|CC_OK
condition|)
goto|goto
name|fail
goto|;
comment|/* 		 * If it is a directory, append a slash. 		 */
if|if
condition|(
name|is_dir
argument_list|(
name|tk_trial
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
name|closequote
condition|)
operator|(
name|void
operator|)
name|cmd_erase
argument_list|()
expr_stmt|;
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LESSSEPARATOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|PATHNAME_SEP
expr_stmt|;
if|if
condition|(
name|cmd_istr
argument_list|(
name|s
argument_list|)
operator|!=
name|CC_OK
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
name|CC_OK
operator|)
return|;
name|fail
label|:
name|in_completion
operator|=
literal|0
expr_stmt|;
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TAB_COMPLETE_FILENAME */
end_comment

begin_comment
comment|/*  * Process a single character of a multi-character command, such as  * a number, or the pattern of a search command.  * Returns:  *	CC_OK		The char was accepted.  *	CC_QUIT		The char requests the command to be aborted.  *	CC_ERROR	The char could not be accepted due to an error.  */
end_comment

begin_function
name|public
name|int
name|cmd_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|action
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|utf_mode
condition|)
block|{
name|cmd_mbc_buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Perform strict validation in all possible cases.  */
if|if
condition|(
name|cmd_mbc_buf_len
operator|==
literal|0
condition|)
block|{
name|retry
label|:
name|cmd_mbc_buf_index
operator|=
literal|1
expr_stmt|;
operator|*
name|cmd_mbc_buf
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|IS_ASCII_OCTET
argument_list|(
name|c
argument_list|)
condition|)
name|cmd_mbc_buf_len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_UTF8_LEAD
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|cmd_mbc_buf_len
operator|=
name|utf_len
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
else|else
block|{
comment|/* UTF8_INVALID or stray UTF8_TRAIL */
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_ERROR
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_UTF8_TRAIL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|cmd_mbc_buf
index|[
name|cmd_mbc_buf_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|cmd_mbc_buf_index
operator|<
name|cmd_mbc_buf_len
condition|)
return|return
operator|(
name|CC_OK
operator|)
return|;
if|if
condition|(
operator|!
name|is_utf8_well_formed
argument_list|(
name|cmd_mbc_buf
argument_list|,
name|cmd_mbc_buf_index
argument_list|)
condition|)
block|{
comment|/* complete, but not well formed (non-shortest form), sequence */
name|cmd_mbc_buf_len
operator|=
literal|0
expr_stmt|;
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Flush incomplete (truncated) sequence.  */
name|cmd_mbc_buf_len
operator|=
literal|0
expr_stmt|;
name|bell
argument_list|()
expr_stmt|;
comment|/* Handle new char.  */
goto|goto
name|retry
goto|;
block|}
name|len
operator|=
name|cmd_mbc_buf_len
expr_stmt|;
name|cmd_mbc_buf_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|literal
condition|)
block|{
comment|/* 		 * Insert the char, even if it is a line-editing char. 		 */
name|literal
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cmd_ichar
argument_list|(
name|cmd_mbc_buf
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * See if it is a line-editing character. 	 */
if|if
condition|(
name|in_mca
argument_list|()
operator|&&
name|len
operator|==
literal|1
condition|)
block|{
name|action
operator|=
name|cmd_edit
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|CC_OK
case|:
case|case
name|CC_QUIT
case|:
return|return
operator|(
name|action
operator|)
return|;
case|case
name|CC_PASS
case|:
break|break;
block|}
block|}
comment|/* 	 * Insert the char into the command buffer. 	 */
return|return
operator|(
name|cmd_ichar
argument_list|(
name|cmd_mbc_buf
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number currently in the command buffer.  */
end_comment

begin_function
name|public
name|LINENUM
name|cmd_int
parameter_list|(
name|frac
parameter_list|)
name|long
modifier|*
name|frac
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|LINENUM
name|n
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
for|for
control|(
name|p
operator|=
name|cmdbuf
init|;
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|;
name|p
operator|++
control|)
name|n
operator|=
operator|(
name|n
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|*
name|frac
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'.'
condition|)
block|{
operator|*
name|frac
operator|=
name|getfraction
argument_list|(
operator|&
name|p
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
comment|/* {{ do something if err is set? }} */
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the command buffer.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|get_cmdbuf
parameter_list|()
block|{
return|return
operator|(
name|cmdbuf
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CMD_HISTORY
end_if

begin_comment
comment|/*  * Return the last (most recent) string in the current command history.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|cmd_lastpattern
parameter_list|()
block|{
if|if
condition|(
name|curr_mlist
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|curr_mlist
operator|->
name|curr_mp
operator|->
name|prev
operator|->
name|string
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CMD_HISTORY
end_if

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|int
name|mlist_size
parameter_list|(
name|ml
parameter_list|)
name|struct
name|mlist
modifier|*
name|ml
decl_stmt|;
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ml
operator|=
name|ml
operator|->
name|next
init|;
name|ml
operator|->
name|string
operator|!=
name|NULL
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
operator|++
name|size
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/*  * Get the name of the history file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|histfile_name
parameter_list|()
block|{
name|char
modifier|*
name|home
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* See if filename is explicitly specified by $LESSHISTFILE. */
name|name
operator|=
name|lgetenv
argument_list|(
literal|"LESSHISTFILE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"/dev/null"
argument_list|)
operator|==
literal|0
condition|)
comment|/* $LESSHISTFILE == "-" means don't use a history file. */
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|save
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
comment|/* See if history file is disabled in the build. */
if|if
condition|(
name|strcmp
argument_list|(
name|LESSHISTFILE
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|LESSHISTFILE
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Otherwise, file is in $HOME. */
name|home
operator|=
name|lgetenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|home
operator|==
name|NULL
operator|||
operator|*
name|home
operator|==
literal|'\0'
condition|)
block|{
if|#
directive|if
name|OS2
name|home
operator|=
name|lgetenv
argument_list|(
literal|"INIT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|home
operator|==
name|NULL
operator|||
operator|*
name|home
operator|==
literal|'\0'
condition|)
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|home
argument_list|)
operator|+
name|strlen
argument_list|(
name|LESSHISTFILE
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SNPRINTF2
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
literal|"%s/%s"
argument_list|,
name|home
argument_list|,
name|LESSHISTFILE
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a .lesshst file and call a callback for each line in the file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|read_cmdhist2
argument_list|(
name|action
argument_list|,
name|uparam
argument_list|,
name|skip_search
argument_list|,
name|skip_shell
argument_list|)
name|void
argument_list|(
operator|*
name|action
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
expr|struct
name|mlist
operator|*
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|uparam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skip_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skip_shell
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mlist
modifier|*
name|ml
init|=
name|NULL
decl_stmt|;
name|char
name|line
index|[
name|CMDBUF_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|skip
init|=
name|NULL
decl_stmt|;
name|filename
operator|=
name|histfile_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|line
argument_list|,
name|HISTFILE_FIRST_LINE
argument_list|,
name|strlen
argument_list|(
name|HISTFILE_FIRST_LINE
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
name|line
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
name|HISTFILE_SEARCH_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ml
operator|=
operator|&
name|mlist_search
expr_stmt|;
name|skip
operator|=
operator|&
name|skip_search
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
name|HISTFILE_SHELL_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|SHELL_ESCAPE
operator|||
name|PIPEC
name|ml
operator|=
operator|&
name|mlist_shell
expr_stmt|;
name|skip
operator|=
operator|&
name|skip_shell
expr_stmt|;
else|#
directive|else
name|ml
operator|=
name|NULL
expr_stmt|;
name|skip
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|line
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|ml
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|skip
operator|!=
name|NULL
operator|&&
operator|*
name|skip
operator|>
literal|0
condition|)
operator|--
operator|(
operator|*
name|skip
operator|)
expr_stmt|;
else|else
call|(
modifier|*
name|action
call|)
argument_list|(
name|uparam
argument_list|,
name|ml
argument_list|,
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|void
name|read_cmdhist
argument_list|(
name|action
argument_list|,
name|uparam
argument_list|,
name|skip_search
argument_list|,
name|skip_shell
argument_list|)
name|void
argument_list|(
operator|*
name|action
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
expr|struct
name|mlist
operator|*
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|uparam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skip_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skip_shell
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|read_cmdhist2
argument_list|(
name|action
argument_list|,
name|uparam
argument_list|,
name|skip_search
argument_list|,
name|skip_shell
argument_list|)
expr_stmt|;
call|(
modifier|*
name|action
call|)
argument_list|(
name|uparam
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* signal end of file */
block|}
end_block

begin_function
specifier|static
name|void
name|addhist_init
parameter_list|(
name|void
modifier|*
name|uparam
parameter_list|,
name|struct
name|mlist
modifier|*
name|ml
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|ml
operator|==
name|NULL
operator|||
name|string
operator|==
name|NULL
condition|)
return|return;
name|cmd_addhist
argument_list|(
name|ml
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CMD_HISTORY */
end_comment

begin_comment
comment|/*  * Initialize history from a .lesshist file.  */
end_comment

begin_function
name|public
name|void
name|init_cmdhist
parameter_list|()
block|{
if|#
directive|if
name|CMD_HISTORY
name|read_cmdhist
argument_list|(
operator|&
name|addhist_init
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CMD_HISTORY */
block|}
end_function

begin_comment
comment|/*  * Write the header for a section of the history file.  */
end_comment

begin_if
if|#
directive|if
name|CMD_HISTORY
end_if

begin_function
specifier|static
name|void
name|write_mlist_header
parameter_list|(
name|ml
parameter_list|,
name|f
parameter_list|)
name|struct
name|mlist
modifier|*
name|ml
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|ml
operator|==
operator|&
name|mlist_search
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|HISTFILE_SEARCH_SECTION
argument_list|)
expr_stmt|;
if|#
directive|if
name|SHELL_ESCAPE
operator|||
name|PIPEC
elseif|else
if|if
condition|(
name|ml
operator|==
operator|&
name|mlist_shell
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|HISTFILE_SHELL_SECTION
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Write all modified entries in an mlist to the history file.  */
end_comment

begin_function
specifier|static
name|void
name|write_mlist
parameter_list|(
name|ml
parameter_list|,
name|f
parameter_list|)
name|struct
name|mlist
modifier|*
name|ml
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
for|for
control|(
name|ml
operator|=
name|ml
operator|->
name|next
init|;
name|ml
operator|->
name|string
operator|!=
name|NULL
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ml
operator|->
name|modified
condition|)
continue|continue;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\"%s\n"
argument_list|,
name|ml
operator|->
name|string
argument_list|)
expr_stmt|;
name|ml
operator|->
name|modified
operator|=
literal|0
expr_stmt|;
block|}
name|ml
operator|->
name|modified
operator|=
literal|0
expr_stmt|;
comment|/* entire mlist is now unmodified */
block|}
end_function

begin_comment
comment|/*  * Make a temp name in the same directory as filename.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_tempname
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
name|lastch
decl_stmt|;
name|char
modifier|*
name|tempname
init|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|tempname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|lastch
operator|=
name|tempname
index|[
name|strlen
argument_list|(
name|tempname
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|tempname
index|[
name|strlen
argument_list|(
name|tempname
argument_list|)
operator|-
literal|1
index|]
operator|=
operator|(
name|lastch
operator|==
literal|'Q'
operator|)
condition|?
literal|'Z'
else|:
literal|'Q'
expr_stmt|;
return|return
name|tempname
return|;
block|}
end_function

begin_struct
struct|struct
name|save_ctx
block|{
name|struct
name|mlist
modifier|*
name|mlist
decl_stmt|;
name|FILE
modifier|*
name|fout
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Copy entries from the saved history file to a new file.  * At the end of each mlist, append any new entries  * created during this session.  */
end_comment

begin_function
specifier|static
name|void
name|copy_hist
parameter_list|(
name|void
modifier|*
name|uparam
parameter_list|,
name|struct
name|mlist
modifier|*
name|ml
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|save_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|save_ctx
operator|*
operator|)
name|uparam
decl_stmt|;
if|if
condition|(
name|ml
operator|!=
name|ctx
operator|->
name|mlist
condition|)
block|{
comment|/* We're changing mlists. */
if|if
condition|(
name|ctx
operator|->
name|mlist
condition|)
comment|/* Append any new entries to the end of the current mlist. */
name|write_mlist
argument_list|(
name|ctx
operator|->
name|mlist
argument_list|,
name|ctx
operator|->
name|fout
argument_list|)
expr_stmt|;
comment|/* Write the header for the new mlist. */
name|ctx
operator|->
name|mlist
operator|=
name|ml
expr_stmt|;
name|write_mlist_header
argument_list|(
name|ctx
operator|->
name|mlist
argument_list|,
name|ctx
operator|->
name|fout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|string
operator|!=
name|NULL
condition|)
block|{
comment|/* Copy the entry. */
name|fprintf
argument_list|(
name|ctx
operator|->
name|fout
argument_list|,
literal|"\"%s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ml
operator|==
name|NULL
condition|)
comment|/* End of file */
block|{
comment|/* Write any sections that were not in the original file. */
if|if
condition|(
name|mlist_search
operator|.
name|modified
condition|)
block|{
name|write_mlist_header
argument_list|(
operator|&
name|mlist_search
argument_list|,
name|ctx
operator|->
name|fout
argument_list|)
expr_stmt|;
name|write_mlist
argument_list|(
operator|&
name|mlist_search
argument_list|,
name|ctx
operator|->
name|fout
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SHELL_ESCAPE
operator|||
name|PIPEC
if|if
condition|(
name|mlist_shell
operator|.
name|modified
condition|)
block|{
name|write_mlist_header
argument_list|(
operator|&
name|mlist_shell
argument_list|,
name|ctx
operator|->
name|fout
argument_list|)
expr_stmt|;
name|write_mlist
argument_list|(
operator|&
name|mlist_shell
argument_list|,
name|ctx
operator|->
name|fout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CMD_HISTORY */
end_comment

begin_comment
comment|/*  * Make a file readable only by its owner.  */
end_comment

begin_function
specifier|static
name|void
name|make_file_private
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_FCHMOD
name|int
name|do_chmod
init|=
literal|1
decl_stmt|;
if|#
directive|if
name|HAVE_STAT
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|r
init|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
comment|/* Don't chmod if not a regular file. */
name|do_chmod
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|do_chmod
condition|)
name|fchmod
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Does the history file need to be updated?  */
end_comment

begin_function
specifier|static
name|int
name|histfile_modified
parameter_list|()
block|{
if|if
condition|(
name|mlist_search
operator|.
name|modified
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|SHELL_ESCAPE
operator|||
name|PIPEC
if|if
condition|(
name|mlist_shell
operator|.
name|modified
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Update the .lesshst file.  */
end_comment

begin_function
name|public
name|void
name|save_cmdhist
parameter_list|()
block|{
if|#
directive|if
name|CMD_HISTORY
name|char
modifier|*
name|histname
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|int
name|skip_search
decl_stmt|;
name|int
name|skip_shell
decl_stmt|;
name|struct
name|save_ctx
name|ctx
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|FILE
modifier|*
name|fout
init|=
name|NULL
decl_stmt|;
name|int
name|histsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|histfile_modified
argument_list|()
condition|)
return|return;
name|histname
operator|=
name|histfile_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|histname
operator|==
name|NULL
condition|)
return|return;
name|tempname
operator|=
name|make_tempname
argument_list|(
name|histname
argument_list|)
expr_stmt|;
name|fout
operator|=
name|fopen
argument_list|(
name|tempname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fout
operator|!=
name|NULL
condition|)
block|{
name|make_file_private
argument_list|(
name|fout
argument_list|)
expr_stmt|;
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LESSHISTSIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|histsize
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|histsize
operator|<=
literal|0
condition|)
name|histsize
operator|=
literal|100
expr_stmt|;
name|skip_search
operator|=
name|mlist_size
argument_list|(
operator|&
name|mlist_search
argument_list|)
operator|-
name|histsize
expr_stmt|;
if|#
directive|if
name|SHELL_ESCAPE
operator|||
name|PIPEC
name|skip_shell
operator|=
name|mlist_size
argument_list|(
operator|&
name|mlist_shell
argument_list|)
operator|-
name|histsize
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%s\n"
argument_list|,
name|HISTFILE_FIRST_LINE
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|fout
operator|=
name|fout
expr_stmt|;
name|ctx
operator|.
name|mlist
operator|=
name|NULL
expr_stmt|;
name|read_cmdhist
argument_list|(
name|copy_hist
argument_list|,
operator|&
name|ctx
argument_list|,
name|skip_search
argument_list|,
name|skip_shell
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fout
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
comment|/* 		 * Windows rename doesn't remove an existing file, 		 * making it useless for atomic operations. Sigh. 		 */
name|remove
argument_list|(
name|histname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rename
argument_list|(
name|tempname
argument_list|,
name|histname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|histname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CMD_HISTORY */
block|}
end_function

end_unit

