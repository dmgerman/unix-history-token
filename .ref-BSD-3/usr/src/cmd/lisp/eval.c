begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*   file: eval.i							*/
end_comment

begin_comment
comment|/*   contents: evaluator and namestack maintenance routines		*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* eval *****************************************************************/
end_comment

begin_comment
comment|/* returns the value of the pointer passed as the argument.		*/
end_comment

begin_function
name|lispval
name|eval
parameter_list|(
name|actarg
parameter_list|)
name|lispval
name|actarg
decl_stmt|;
block|{
define|#
directive|define
name|argptr
value|handy
specifier|register
name|lispval
name|a
init|=
name|actarg
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|namptr
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|workp
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|np
decl_stmt|;
name|struct
name|argent
modifier|*
name|poplbot
decl_stmt|;
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|;
name|lispval
name|Ifcall
argument_list|()
decl_stmt|,
name|Iarray
argument_list|()
decl_stmt|;
comment|/*debugging  	printf("Eval:"); 	printr(a,stdout); 	fflush(stdout);  */
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
name|handy
operator|=
name|a
operator|->
name|clb
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|CNIL
condition|)
block|{
name|handy
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Unbound Variable:"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|handy
operator|)
return|;
case|case
name|VALUE
case|:
return|return
operator|(
name|a
operator|->
name|l
operator|)
return|;
case|case
name|DTPR
case|:
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|a
expr_stmt|;
comment|/* push form on namestack */
name|lbot
operator|=
name|np
expr_stmt|;
comment|/* define beginning of argstack */
name|oldbnp
operator|=
name|bnp
expr_stmt|;
comment|/* remember start of bind stack */
name|a
operator|=
name|a
operator|->
name|car
expr_stmt|;
comment|/* function name or lambda-expr */
for|for
control|(
name|EVER
control|)
block|{
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
comment|/*  get function binding  */
if|if
condition|(
name|a
operator|->
name|fnbnd
operator|==
name|nil
operator|&&
name|a
operator|->
name|clb
operator|!=
name|nil
condition|)
block|{
name|a
operator|=
name|a
operator|->
name|clb
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
operator|==
name|ATOM
condition|)
name|a
operator|=
name|a
operator|->
name|fnbnd
expr_stmt|;
block|}
else|else
name|a
operator|=
name|a
operator|->
name|fnbnd
expr_stmt|;
break|break;
case|case
name|VALUE
case|:
name|a
operator|=
name|a
operator|->
name|l
expr_stmt|;
comment|/*  get value  */
break|break;
block|}
name|vtemp
operator|=
operator|(
name|CNIL
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* sentinel value for error test */
name|funcal
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|BCD
case|:
comment|/* function */
name|argptr
operator|=
name|actarg
operator|->
name|cdr
expr_stmt|;
comment|/* decide whether lambda, nlambda or 				   macro and push args onto argstack 				   accordingly.				*/
if|if
condition|(
name|a
operator|->
name|discipline
operator|==
name|nlambda
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|discipline
operator|==
name|macro
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|actarg
expr_stmt|;
name|TNP
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|eval
argument_list|(
name|argptr
operator|->
name|car
argument_list|)
expr_stmt|;
name|TNP
expr_stmt|;
block|}
comment|/* go for it */
if|if
condition|(
name|TYPE
argument_list|(
name|a
operator|->
name|discipline
argument_list|)
operator|==
name|INT
condition|)
name|vtemp
operator|=
name|Ifcall
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|vtemp
operator|=
operator|(
operator|*
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|a
operator|->
name|entry
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|vtemp
operator|=
name|Iarray
argument_list|(
name|a
argument_list|,
name|actarg
operator|->
name|cdr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTPR
case|:
comment|/* push args on argstack according to 					   type				*/
name|argptr
operator|=
name|a
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|argptr
operator|==
name|lambda
condition|)
block|{
for|for
control|(
name|argptr
operator|=
name|actarg
operator|->
name|cdr
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|eval
argument_list|(
name|argptr
operator|->
name|car
argument_list|)
expr_stmt|;
name|TNP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argptr
operator|==
name|nlambda
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|actarg
operator|->
name|cdr
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argptr
operator|==
name|macro
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|actarg
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argptr
operator|==
name|lexpr
condition|)
block|{
for|for
control|(
name|argptr
operator|=
name|actarg
operator|->
name|cdr
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|eval
argument_list|(
name|argptr
operator|->
name|car
argument_list|)
expr_stmt|;
name|TNP
expr_stmt|;
block|}
name|handy
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|car
operator|=
operator|(
name|lispval
operator|)
name|lbot
expr_stmt|;
name|handy
operator|->
name|cdr
operator|=
operator|(
name|lispval
operator|)
name|np
expr_stmt|;
name|PUSHDOWN
argument_list|(
name|lexpr_atom
argument_list|,
name|handy
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|inewint
argument_list|(
operator|(
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|cdr
operator|)
operator|-
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
comment|/* something is wrong - this isn't a proper function */
name|argptr
operator|=
operator|(
name|a
operator|->
name|cdr
operator|)
operator|->
name|car
expr_stmt|;
name|namptr
operator|=
name|bnp
expr_stmt|;
name|workp
operator|=
name|lbot
expr_stmt|;
if|if
condition|(
name|bnp
operator|+
operator|(
name|np
operator|-
name|lbot
operator|)
operator|>
name|bnplim
condition|)
name|binderr
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|argptr
operator|!=
operator|(
name|lispval
operator|)
name|nil
condition|;
name|workp
operator|++
operator|,
name|argptr
operator|=
name|argptr
operator|->
name|cdr
control|)
comment|/* rebind formal names (shallow) */
block|{
if|if
condition|(
name|argptr
operator|->
name|car
operator|==
name|nil
condition|)
continue|continue;
comment|/*if(((namptr)->atm = argptr->car)==nil) 						error("Attempt to lambda bind nil",FALSE);*/
name|namptr
operator|->
name|atm
operator|=
name|argptr
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|workp
operator|<
name|np
condition|)
block|{
name|namptr
operator|->
name|val
operator|=
name|namptr
operator|->
name|atm
operator|->
name|clb
expr_stmt|;
name|namptr
operator|->
name|atm
operator|->
name|clb
operator|=
name|workp
operator|->
name|val
expr_stmt|;
block|}
else|else
name|bnp
operator|=
name|namptr
operator|,
name|error
argument_list|(
literal|"Too few actual parameters"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|namptr
operator|++
expr_stmt|;
block|}
name|bnp
operator|=
name|namptr
expr_stmt|;
if|if
condition|(
name|workp
operator|<
name|np
condition|)
name|error
argument_list|(
literal|"Too many actual parameters"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* execute body, implied prog allowed */
for|for
control|(
name|handy
operator|=
name|a
operator|->
name|cdr
operator|->
name|cdr
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|cdr
control|)
block|{
name|vtemp
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vtemp
operator|!=
operator|(
name|CNIL
operator|-
literal|1
operator|)
condition|)
comment|/* if we get here with a believable value, */
comment|/* we must have executed a function. */
block|{
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
comment|/* in case some clown trashed t */
name|tatom
operator|->
name|clb
operator|=
operator|(
name|lispval
operator|)
name|tatom
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|car
operator|==
name|macro
condition|)
return|return
operator|(
name|eval
argument_list|(
name|vtemp
argument_list|)
operator|)
return|;
comment|/* It is of the most wonderful  					   coincidence that the offset 					   for car is the same as for 					   discipline so we get bcd macros 					   for free here ! */
else|else
return|return
operator|(
name|vtemp
operator|)
return|;
block|}
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|lispval
operator|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"BAD FUNCTION"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|actarg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|a
operator|)
return|;
comment|/* other data types are considered constants */
block|}
end_function

begin_comment
comment|/* popnames *************************************************************/
end_comment

begin_comment
comment|/* removes from the name stack all entries above the first argument.	*/
end_comment

begin_comment
comment|/* routine should usually be used to clean up the name stack as it	*/
end_comment

begin_comment
comment|/* knows about the special cases.  np is returned pointing to the	*/
end_comment

begin_comment
comment|/* same place as the argument passed.					*/
end_comment

begin_function
name|lispval
name|popnames
parameter_list|(
name|llimit
parameter_list|)
specifier|register
name|struct
name|nament
modifier|*
name|llimit
decl_stmt|;
block|{
specifier|register
name|struct
name|nament
modifier|*
name|rnp
decl_stmt|;
for|for
control|(
name|rnp
operator|=
name|bnp
operator|-
literal|1
init|;
name|rnp
operator|>=
name|llimit
condition|;
name|rnp
operator|--
control|)
name|rnp
operator|->
name|atm
operator|->
name|clb
operator|=
name|rnp
operator|->
name|val
expr_stmt|;
name|bnp
operator|=
name|llimit
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*   file: apply.c							*/
end_comment

begin_comment
comment|/*	Caveat -- Work in Progress -- not guaranteed! not tested! /*									*/
end_comment

begin_comment
comment|/* apply  ***************************************************************/
end_comment

begin_function
name|lispval
name|Lapply
parameter_list|()
block|{
specifier|register
name|lispval
name|a
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|workp
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|namptr
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|np
decl_stmt|;
name|lispval
name|vtemp
decl_stmt|;
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|;
name|struct
name|argent
modifier|*
name|oldlbot
init|=
name|lbot
decl_stmt|;
comment|/* Bottom of my frame! */
name|a
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|argptr
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
if|if
condition|(
name|np
operator|-
name|lbot
operator|!=
literal|2
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Apply: Wrong number of args."
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|999
argument_list|,
name|a
argument_list|,
name|argptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|argptr
argument_list|)
operator|!=
name|DTPR
operator|&&
name|argptr
operator|!=
name|nil
condition|)
name|argptr
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Apply: non-list of args"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|998
argument_list|,
name|argptr
argument_list|)
expr_stmt|;
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|a
expr_stmt|;
comment|/* push form on namestack */
name|TNP
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
comment|/* bottom of current frame */
for|for
control|(
name|EVER
control|)
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
operator|==
name|ATOM
condition|)
name|a
operator|=
name|a
operator|->
name|fnbnd
expr_stmt|;
comment|/* get function defn (unless calling form */
comment|/* is itself a lambda-expr) */
name|vtemp
operator|=
name|CNIL
expr_stmt|;
comment|/* sentinel value for error test */
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|BCD
case|:
comment|/* printf("BCD\n");*/
comment|/* push arguments - value of a */
if|if
condition|(
name|a
operator|->
name|discipline
operator|==
name|nlambda
operator|||
name|a
operator|->
name|discipline
operator|==
name|macro
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
expr_stmt|;
name|TNP
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
operator|->
name|car
expr_stmt|;
name|TNP
expr_stmt|;
block|}
name|vtemp
operator|=
operator|(
operator|*
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|a
operator|->
name|entry
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
comment|/* go for it */
break|break;
case|case
name|ARRAY
case|:
name|vtemp
operator|=
name|Iarray
argument_list|(
name|a
argument_list|,
name|argptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTPR
case|:
if|if
condition|(
name|a
operator|->
name|car
operator|==
name|nlambda
operator|||
name|a
operator|->
name|car
operator|==
name|macro
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|car
operator|==
name|lambda
condition|)
for|for
control|(
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
operator|->
name|car
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|car
operator|==
name|lexpr
condition|)
block|{
for|for
control|(
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
operator|->
name|car
expr_stmt|;
name|TNP
expr_stmt|;
block|}
name|handy
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|car
operator|=
operator|(
name|lispval
operator|)
name|lbot
expr_stmt|;
name|handy
operator|->
name|cdr
operator|=
operator|(
name|lispval
operator|)
name|np
expr_stmt|;
name|PUSHDOWN
argument_list|(
name|lexpr_atom
argument_list|,
name|handy
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|inewint
argument_list|(
operator|(
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|cdr
operator|)
operator|-
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
comment|/* something is wrong - this isn't a proper function */
name|rebind
argument_list|(
name|a
operator|->
name|cdr
operator|->
name|car
argument_list|,
name|lbot
argument_list|)
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
for|for
control|(
name|handy
operator|=
name|a
operator|->
name|cdr
operator|->
name|cdr
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|cdr
control|)
block|{
name|vtemp
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
comment|/* go for it */
block|}
block|}
if|if
condition|(
name|vtemp
operator|!=
name|CNIL
condition|)
comment|/* if we get here with a believable value, */
comment|/* we must have executed a function. */
block|{
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
comment|/* in case some clown trashed t */
name|tatom
operator|->
name|clb
operator|=
operator|(
name|lispval
operator|)
name|tatom
expr_stmt|;
return|return
operator|(
name|vtemp
operator|)
return|;
block|}
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|oldlbot
operator|->
name|val
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|lispval
operator|)
name|error
argument_list|(
literal|"BAD FUNCTION"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/*NOT REACHED*/
block|}
end_function

begin_comment
comment|/*  * Rebind -- rebind formal names  */
end_comment

begin_expr_stmt
name|rebind
argument_list|(
name|argptr
argument_list|,
name|workp
argument_list|)
specifier|register
name|lispval
name|argptr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* argptr points to list of atoms */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|argent
modifier|*
name|workp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* workp points to position on stack 					   where evaluated args begin */
end_comment

begin_block
block|{
specifier|register
name|lispval
name|vtemp
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|namptr
init|=
name|bnp
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|np
decl_stmt|;
for|for
control|(
init|;
name|argptr
operator|!=
operator|(
name|lispval
operator|)
name|nil
condition|;
name|workp
operator|++
operator|,
name|argptr
operator|=
name|argptr
operator|->
name|cdr
control|)
comment|/* rebind formal names (shallow) */
block|{
if|if
condition|(
name|argptr
operator|->
name|car
operator|==
name|nil
condition|)
continue|continue;
name|namptr
operator|->
name|atm
operator|=
name|argptr
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|workp
operator|<
name|np
condition|)
block|{
name|namptr
operator|->
name|val
operator|=
name|namptr
operator|->
name|atm
operator|->
name|clb
expr_stmt|;
name|namptr
operator|->
name|atm
operator|->
name|clb
operator|=
name|workp
operator|->
name|val
expr_stmt|;
block|}
else|else
name|bnp
operator|=
name|namptr
operator|,
name|error
argument_list|(
literal|"Too few actual parameters"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|namptr
operator|++
expr_stmt|;
if|if
condition|(
name|namptr
operator|>
name|bnplim
condition|)
name|binderr
argument_list|()
expr_stmt|;
block|}
name|bnp
operator|=
name|namptr
expr_stmt|;
if|if
condition|(
name|workp
operator|<
name|np
condition|)
name|error
argument_list|(
literal|"Too many actual parameters"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|lispval
name|Lfuncal
parameter_list|()
block|{
specifier|register
name|lispval
name|a
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|oldlbot
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
modifier|*
name|namptr
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|np
decl_stmt|;
name|lispval
name|Ifcall
argument_list|()
decl_stmt|,
name|Llist
argument_list|()
decl_stmt|,
name|Iarray
argument_list|()
decl_stmt|;
name|lispval
name|vtemp
decl_stmt|;
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|;
name|int
name|typ
decl_stmt|;
specifier|extern
name|lispval
name|end
index|[]
decl_stmt|;
comment|/*debugging stufff  	printf("In funcal: "); 	printr(lbot->val,stdout); 	fflush(stdout);  	printf("\n"); */
name|oldlbot
operator|=
name|lbot
expr_stmt|;
comment|/* bottom of my namestack frame */
name|a
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
comment|/* function I am evaling.	*/
name|lbot
operator|++
expr_stmt|;
for|for
control|(
name|EVER
control|)
block|{
name|typ
operator|=
name|TYPE
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|typ
operator|==
name|ATOM
condition|)
name|a
operator|=
name|a
operator|->
name|fnbnd
operator|,
name|typ
operator|=
name|TYPE
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* get function defn (unless calling form */
comment|/* is itself a lambda-expr) */
name|vtemp
operator|=
name|CNIL
expr_stmt|;
comment|/* sentinel value for error test */
switch|switch
condition|(
name|typ
condition|)
block|{
case|case
name|ARRAY
case|:
name|vtemp
operator|=
name|Iarray
argument_list|(
name|a
argument_list|,
name|Llist
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BCD
case|:
if|if
condition|(
name|a
operator|->
name|discipline
operator|==
name|nlambda
condition|)
block|{
if|if
condition|(
name|np
operator|==
name|lbot
condition|)
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
comment|/* default is nil */
while|while
condition|(
name|np
operator|-
name|lbot
operator|!=
literal|1
operator|||
operator|(
name|lbot
operator|->
name|val
operator|!=
name|nil
operator|&&
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|DTPR
operator|)
condition|)
block|{
name|lbot
operator|->
name|val
operator|=
name|error
argument_list|(
literal|"Bad funcall arg(s) to fexpr."
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|np
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* go for it */
if|if
condition|(
name|TYPE
argument_list|(
name|a
operator|->
name|discipline
argument_list|)
operator|==
name|INT
condition|)
name|vtemp
operator|=
name|Ifcall
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|vtemp
operator|=
operator|(
operator|*
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|a
operator|->
name|entry
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|discipline
operator|==
name|macro
condition|)
name|vtemp
operator|=
name|eval
argument_list|(
name|vtemp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTPR
case|:
if|if
condition|(
name|a
operator|->
name|car
operator|==
name|lambda
condition|)
block|{
empty_stmt|;
comment|/* VOID */
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|car
operator|==
name|nlambda
operator|||
name|a
operator|->
name|car
operator|==
name|macro
condition|)
block|{
if|if
condition|(
name|np
operator|==
name|lbot
condition|)
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
comment|/* default */
while|while
condition|(
name|np
operator|-
name|lbot
operator|!=
literal|1
operator|||
operator|(
name|lbot
operator|->
name|val
operator|!=
name|nil
operator|&&
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|DTPR
operator|)
condition|)
block|{
name|lbot
operator|->
name|val
operator|=
name|error
argument_list|(
literal|"Bad funcall arg(s) to fexpr."
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|np
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|car
operator|==
name|lexpr
condition|)
block|{
name|handy
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|car
operator|=
operator|(
name|lispval
operator|)
name|lbot
expr_stmt|;
name|handy
operator|->
name|cdr
operator|=
operator|(
name|lispval
operator|)
name|np
expr_stmt|;
name|PUSHDOWN
argument_list|(
name|lexpr_atom
argument_list|,
name|handy
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|inewint
argument_list|(
operator|(
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|cdr
operator|)
operator|-
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
comment|/* something is wrong - this isn't a proper function */
name|rebind
argument_list|(
name|a
operator|->
name|cdr
operator|->
name|car
argument_list|,
name|lbot
argument_list|)
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
for|for
control|(
name|handy
operator|=
name|a
operator|->
name|cdr
operator|->
name|cdr
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|cdr
control|)
block|{
name|vtemp
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
comment|/* go for it */
block|}
if|if
condition|(
name|a
operator|->
name|car
operator|==
name|macro
condition|)
name|vtemp
operator|=
name|eval
argument_list|(
name|vtemp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vtemp
operator|!=
name|CNIL
condition|)
comment|/* if we get here with a believable value, */
comment|/* we must have executed a function. */
block|{
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
comment|/* in case some clown trashed t */
name|tatom
operator|->
name|clb
operator|=
operator|(
name|lispval
operator|)
name|tatom
expr_stmt|;
comment|/*debugging 			if(a>(lispval) end){printf(" leaving:"); 			printr(a,stdout); 			fflush(stdout);} */
return|return
operator|(
name|vtemp
operator|)
return|;
block|}
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|oldlbot
operator|->
name|val
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|lispval
operator|)
name|error
argument_list|(
literal|"BAD FUNCTION"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/*NOT REACHED*/
block|}
end_function

begin_comment
comment|/* protect **************************************************************/
end_comment

begin_comment
comment|/* pushes the first argument onto namestack, thereby protecting from gc */
end_comment

begin_function
name|lispval
name|protect
parameter_list|(
name|a
parameter_list|)
name|lispval
name|a
decl_stmt|;
block|{
comment|/* (np++)->val = a; 	   if (np>=  nplim) 		namerr(); 	 */
asm|asm("	movl	4(ap),(r6)+");
asm|asm("	cmpl	r6,_nplim");
asm|asm("	jlss	out1");
asm|asm("	calls	$0,_namerr");
asm|asm("out1:	ret");
block|}
end_function

begin_comment
comment|/* unprot ****************************************************************/
end_comment

begin_comment
comment|/* returns the top thing on the name stack.  Underflow had better not	*/
end_comment

begin_comment
comment|/* occur.								*/
end_comment

begin_function
name|lispval
name|unprot
parameter_list|()
block|{
asm|asm("	movl	-(r6),r0");
block|}
end_function

begin_function
name|lispval
name|linterp
parameter_list|()
block|{
name|error
argument_list|(
literal|"BYTE INTERPRETER CALLED ERRONEOUSLY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undeff - called from qfuncl when it detects a call to a undefined 	function from compiled code, we print out a message and 	dont allow continuation */
end_comment

begin_function
name|lispval
name|Undeff
parameter_list|(
name|atmn
parameter_list|)
name|lispval
name|atmn
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\n%s - "
argument_list|,
name|atmn
operator|->
name|pname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Undefined function called from compiled code"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|bindfix
argument_list|(
argument|firstarg
argument_list|)
end_macro

begin_decl_stmt
name|lispval
name|firstarg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|lispval
modifier|*
name|argp
init|=
operator|&
name|firstarg
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|mybnp
init|=
name|bnp
decl_stmt|;
while|while
condition|(
operator|*
name|argp
operator|!=
name|nil
condition|)
block|{
name|mybnp
operator|->
name|atm
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|mybnp
operator|->
name|val
operator|=
name|mybnp
operator|->
name|atm
operator|->
name|clb
expr_stmt|;
name|mybnp
operator|->
name|atm
operator|->
name|clb
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|bnp
operator|=
name|mybnp
operator|++
expr_stmt|;
block|}
block|}
end_block

end_unit

