begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_comment
comment|/* various functions from the c math library */
end_comment

begin_decl_stmt
name|double
name|sin
argument_list|()
decl_stmt|,
name|cos
argument_list|()
decl_stmt|,
name|asin
argument_list|()
decl_stmt|,
name|acos
argument_list|()
decl_stmt|,
name|atan2
argument_list|()
decl_stmt|,
name|sqrt
argument_list|()
decl_stmt|,
name|log
argument_list|()
decl_stmt|,
name|exp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|lispval
name|Imath
parameter_list|(
name|func
parameter_list|)
function|double func
parameter_list|()
function|;
end_function

begin_block
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|double
name|res
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
operator|=
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|res
operator|=
name|func
argument_list|(
operator|(
name|double
operator|)
name|handy
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|res
operator|=
name|func
argument_list|(
name|handy
operator|->
name|r
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non fixnum or flonum to math function"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|handy
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|handy
operator|->
name|r
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_block

begin_function
name|lispval
name|Lsin
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|sin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcos
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|cos
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lasin
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|asin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lacos
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|acos
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsqrt
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|sqrt
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lexp
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|exp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Llog
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|log
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* although we call this atan, it is really atan2 to the c-world,    that is, it takes two args  */
end_comment

begin_function
name|lispval
name|Latan
parameter_list|()
block|{
specifier|register
name|lispval
name|arg
decl_stmt|;
specifier|register
name|double
name|arg1v
decl_stmt|;
specifier|register
name|double
name|res
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|arg
operator|=
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|arg1v
operator|=
operator|(
name|double
operator|)
name|arg
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|arg1v
operator|=
name|arg
operator|->
name|r
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non fixnum or flonum arg to atan2"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|TYPE
argument_list|(
name|arg
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|res
operator|=
name|atan2
argument_list|(
name|arg1v
argument_list|,
operator|(
name|double
operator|)
name|arg
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|res
operator|=
name|atan2
argument_list|(
name|arg1v
argument_list|,
name|arg
operator|->
name|r
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non fixnum or flonum to atan2"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|arg
operator|->
name|r
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|arg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* (random) returns a fixnum in the range -2**30 to 2**30 -1    (random fixnum) returns a fixnum in the range 0 to fixnum-1  */
end_comment

begin_function
name|lispval
name|Lrandom
parameter_list|()
block|{
specifier|register
name|int
name|curval
decl_stmt|;
name|float
name|pow
parameter_list|()
function_decl|;
name|curval
operator|=
name|rand
argument_list|()
expr_stmt|;
comment|/* get numb from 0 to 2**31-1 */
if|if
condition|(
name|np
operator|==
name|lbot
condition|)
return|return
operator|(
name|inewint
argument_list|(
name|curval
operator|-
operator|(
name|int
operator|)
name|pow
argument_list|(
operator|(
name|double
operator|)
literal|2
argument_list|,
operator|(
name|double
operator|)
literal|30
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|<=
literal|0
operator|)
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"random: non fixnum arg:"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|curval
operator|%
name|lbot
operator|->
name|val
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lmakunb
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|nil
operator|||
operator|(
name|TYPE
argument_list|(
name|work
argument_list|)
operator|!=
name|ATOM
operator|)
condition|)
return|return
operator|(
name|work
operator|)
return|;
name|work
operator|->
name|clb
operator|=
name|CNIL
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lpolyev
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|double
modifier|*
name|handy
decl_stmt|,
modifier|*
name|base
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|,
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|lispval
name|result
decl_stmt|;
name|int
name|type
decl_stmt|;
name|count
operator|=
literal|2
operator|*
operator|(
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|-
operator|(
name|int
operator|)
name|lbot
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|==
literal|8
condition|)
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
name|base
operator|=
name|handy
operator|=
operator|(
name|double
operator|*
operator|)
name|alloca
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|lbot
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|type
operator|=
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|DOUB
operator|&&
name|type
operator|!=
name|INT
condition|)
name|argp
operator|->
name|val
operator|=
operator|(
name|lispval
operator|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"%%machine-polyev:non-real arg"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|73
argument_list|,
name|lbot
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|==
name|INT
condition|)
block|{
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
block|}
else|else
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|r
expr_stmt|;
block|}
name|count
operator|=
name|count
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|-
literal|2
expr_stmt|;
asm|asm("polyd	(r9),r11,8(r9)");
asm|asm("movd	r0,(r9)");
name|result
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|result
operator|->
name|r
operator|=
operator|*
name|base
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

