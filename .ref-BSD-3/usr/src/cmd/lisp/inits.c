begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*                                                                      */
end_comment

begin_comment
comment|/*   file: inits.i                                                      */
end_comment

begin_comment
comment|/*   contents: initialization routines                                  */
end_comment

begin_comment
comment|/*                                                                      */
end_comment

begin_comment
comment|/* initial **************************************************************/
end_comment

begin_comment
comment|/* initializes the parts of the system that cannot be automatically	*/
end_comment

begin_comment
comment|/* accomplished in the declarations.					*/
end_comment

begin_decl_stmt
name|int
name|reborn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  flag to tell whether we are in fast-load version  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|stabf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fvirgin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|keywait
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern sigstruck
operator|,
extern|sigdelay;
end_extern

begin_macro
name|initial
argument_list|()
end_macro

begin_block
block|{
name|int
name|sigalrmh
argument_list|()
decl_stmt|,
name|sigfpeh
argument_list|()
decl_stmt|,
name|siginth
argument_list|()
decl_stmt|;
name|lispval
name|Isstatus
argument_list|()
decl_stmt|,
name|Istsrch
argument_list|()
decl_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
comment|/* signals SIGBUS and SIGSEGV will be set up when the status list 	   is set up when the lisp is virgin, and will be set up according 	   to the current value on the status list if the lisp is reborn 	*/
if|if
condition|(
name|reborn
condition|)
block|{
specifier|register
name|FILE
modifier|*
name|p
init|=
name|_iob
operator|+
literal|3
decl_stmt|;
specifier|static
name|FILE
name|empty
decl_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|_iob
operator|+
name|_NFILE
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|empty
expr_stmt|;
name|np
operator|=
name|lbot
operator|=
name|orgnp
expr_stmt|;
name|stabf
operator|=
literal|0
expr_stmt|;
name|fvirgin
operator|=
literal|1
expr_stmt|;
name|loading
operator|->
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* set up SIGBUS and SIGSEGV from current value  		   of status flag dumpcore 		*/
name|Isstatus
argument_list|(
name|matom
argument_list|(
literal|"dumpcore"
argument_list|)
argument_list|,
operator|(
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"dumpcore"
argument_list|)
argument_list|)
operator|)
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|cdr
argument_list|)
expr_stmt|;
name|makenv
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|HASHTOP
condition|;
name|hash
operator|++
control|)
name|hasht
index|[
name|hash
index|]
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
expr_stmt|;
name|sbrk
argument_list|(
name|NBPG
operator|-
operator|(
operator|(
operator|(
name|int
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|)
operator|%
name|NBPG
operator|)
argument_list|)
expr_stmt|;
comment|/* even up the break */
name|makevals
argument_list|()
expr_stmt|;
name|orgnp
operator|=
name|np
expr_stmt|;
name|makenv
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|makenv
argument_list|()
block|{
specifier|register
name|lispval
name|env
block|,
name|temp
block|;
specifier|register
name|char
operator|*
name|p
block|,
operator|*
name|q
block|;
specifier|register
expr|struct
name|argent
operator|*
name|lbot
block|,
operator|*
name|np
block|;
name|char
operator|*
operator|*
name|envp
block|,
name|envstr
index|[
literal|64
index|]
block|;
specifier|extern
name|char
operator|*
operator|*
name|environ
block|;
name|lbot
operator|=
name|np
block|;
name|env
operator|=
name|nil
block|;
name|np
operator|++
operator|->
name|val
operator|=
name|env
block|;
for|for
control|(
name|envp
operator|=
name|environ
init|;
operator|*
name|envp
operator|!=
name|NULL
condition|;
name|envp
operator|++
control|)
empty_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|--
name|envp
operator|>=
name|environ
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|*
name|envp
operator|,
name|q
operator|=
name|envstr
init|;
operator|(
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'='
condition|;
control|)
empty_stmt|;
operator|*
operator|--
name|q
operator|=
literal|0
expr_stmt|;
comment|/* at this point lbot->val==env, so it is protected 		   from gc */
name|lbot
operator|->
name|val
operator|=
name|temp
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|temp
operator|->
name|cdr
operator|=
name|env
expr_stmt|;
name|env
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|temp
operator|->
name|car
operator|=
name|matom
argument_list|(
name|envstr
argument_list|)
expr_stmt|;
name|temp
operator|->
name|cdr
operator|=
name|matom
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|env
operator|->
name|car
operator|=
name|temp
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|matom
argument_list|(
literal|"environment"
argument_list|)
operator|->
name|clb
operator|=
name|env
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  siginth
operator|(
name|signo
operator|)
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|siginth
argument_list|)
block|;
name|sigstruck
operator||=
operator|(
literal|1
operator|<<
name|signo
operator|)
block|;
comment|/*if(signo==SIGBUS || signo==SIGBUS || keywait)*/
name|sigcall
argument_list|(
name|signo
argument_list|)
block|; }
name|sigcall
argument_list|(
name|which
argument_list|)
specifier|register
name|which
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|lispval
name|Lfuncal
parameter_list|()
function_decl|;
specifier|extern
name|lispval
name|sigacts
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|argent
modifier|*
name|oldlbot
decl_stmt|,
modifier|*
name|oldnp
decl_stmt|,
name|saved
decl_stmt|;
if|if
condition|(
name|sigacts
index|[
name|which
index|]
operator|!=
operator|(
operator|(
name|lispval
operator|)
literal|0
operator|)
condition|)
block|{
name|oldlbot
operator|=
name|lbot
expr_stmt|;
name|oldnp
operator|=
name|np
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|->
name|val
operator|=
name|sigacts
index|[
name|which
index|]
expr_stmt|;
name|INRNP
expr_stmt|;
name|np
operator|->
name|val
operator|=
name|inewint
argument_list|(
name|which
argument_list|)
expr_stmt|;
name|INRNP
expr_stmt|;
name|Lfuncal
argument_list|()
expr_stmt|;
name|lbot
operator|=
name|oldlbot
expr_stmt|;
name|np
operator|=
name|oldnp
expr_stmt|;
block|}
name|sigstruck
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|which
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|delayoff
argument_list|()
end_macro

begin_block
block|{
name|sigdelay
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sigstruck
condition|)
name|dosig
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|dosig
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|which
decl_stmt|;
if|if
condition|(
operator|!
name|sigdelay
condition|)
for|for
control|(
name|which
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|65536
condition|;
name|which
operator|++
operator|,
name|i
operator|<<=
literal|1
control|)
block|{
name|keywait
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sigstruck
operator|&
name|i
condition|)
name|sigcall
argument_list|(
name|which
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|badmemr
argument_list|(
argument|number
argument_list|)
end_macro

begin_block
block|{
name|signal
argument_list|(
name|number
argument_list|,
name|badmemr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Internal bad memory reference, you are advised to (reset)."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

