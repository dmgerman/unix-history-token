begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"lfuncs.h"
end_include

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_define
define|#
directive|define
name|round
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
value|((((x)-1)& ~((s)-1)) + (s))
end_define

begin_define
define|#
directive|define
name|STRLIM
value|2048
end_define

begin_comment
comment|/* this is the original fasl, which used nld to do relocation.  * On nov 4, it was replaced by rfasl  */
end_comment

begin_function_decl
specifier|static
name|lispval
name|mkptr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|stabbuf
index|[
literal|32
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|exec
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lispval
modifier|*
name|linkaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fildes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|currend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|stabf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fvirgin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lispval
name|currtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lispval
name|curibase
decl_stmt|;
end_decl_stmt

begin_function
name|lispval
name|Loldfasl
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mlbot
init|=
name|lbot
decl_stmt|;
specifier|register
name|lispval
name|work
decl_stmt|;
name|int
name|totsize
decl_stmt|,
name|readsize
decl_stmt|;
name|lispval
name|csegment
argument_list|()
decl_stmt|,
name|errorh
argument_list|()
decl_stmt|;
name|char
modifier|*
name|sbrk
argument_list|()
decl_stmt|,
modifier|*
name|tfile
decl_stmt|,
name|cbuf
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|mytemp
argument_list|()
decl_stmt|,
modifier|*
name|gstab
argument_list|()
decl_stmt|;
name|struct
name|nament
modifier|*
name|obnp
init|=
name|bnp
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|-
name|mlbot
operator|!=
literal|1
operator|||
name|TYPE
argument_list|(
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|)
operator|!=
name|ATOM
condition|)
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"fasl: Incorrect .o file specification:"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Invoke loader. 	 */
name|currend
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tfile
operator|=
name|mytemp
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"/usr/lib/lisp/nld -A %s -T %x -N %s -o %s"
argument_list|,
name|gstab
argument_list|()
argument_list|,
name|currend
argument_list|,
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|pname
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
comment|/* printf(cbuf); fflush(stdout);   debugging */
name|printf
argument_list|(
literal|"[fasl: %s]"
argument_list|,
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|pname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|cbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* signal end of nld */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fildes
operator|=
name|open
argument_list|(
name|tfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
if|if
condition|(
name|fvirgin
condition|)
name|fvirgin
operator|=
literal|0
expr_stmt|;
else|else
name|unlink
argument_list|(
name|stabf
argument_list|)
expr_stmt|;
name|strcpyn
argument_list|(
name|stabbuf
argument_list|,
name|tfile
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|stabf
operator|=
name|stabbuf
expr_stmt|;
comment|/* 	 * Read a.out header to find out how much room to 	 * allocate and attempt to do so. 	 */
if|if
condition|(
name|read
argument_list|(
name|fildes
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
name|readsize
operator|=
name|header
operator|.
name|a_text
expr_stmt|;
name|totsize
operator|=
name|readsize
expr_stmt|;
name|totsize
operator|=
name|round
argument_list|(
name|totsize
argument_list|,
name|PAGSIZ
argument_list|)
expr_stmt|;
comment|/* 	 * Fix up system indicators, typing info, etc. 	 */
name|currend
operator|=
operator|(
name|char
operator|*
operator|)
name|csegment
argument_list|(
name|int_name
argument_list|,
name|totsize
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readsize
operator|!=
name|read
argument_list|(
name|fildes
argument_list|,
name|currend
argument_list|,
name|readsize
argument_list|)
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|linkaddr
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
name|currend
expr_stmt|;
name|currtab
operator|=
name|Vreadtable
operator|->
name|clb
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|strtab
expr_stmt|;
name|curibase
operator|=
name|ibase
operator|->
name|clb
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|do_linker
argument_list|()
expr_stmt|;
name|do_binder
argument_list|()
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|curibase
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|currtab
expr_stmt|;
name|chkrtab
argument_list|(
name|currtab
argument_list|)
expr_stmt|;
comment|/* added by jkf, shouldnt be needed */
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|mybuff
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|mytemp
parameter_list|()
block|{
specifier|static
name|seed
operator|=
literal|0
operator|,
name|mypid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mypid
operator|==
literal|0
condition|)
name|mypid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|mybuff
argument_list|,
literal|"/tmp/Li%d.%d"
argument_list|,
name|mypid
argument_list|,
name|seed
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|mybuff
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|do_linker
argument_list|()
block|{
specifier|register
name|int
operator|*
name|i
block|,
operator|*
name|end
block|,
name|temp
block|;
name|char
name|array
index|[
name|STRLIM
index|]
block|;
specifier|extern
name|lispval
operator|*
name|bind_lists
block|;
comment|/* first link this linkage table to the garbage 	   collector's list.  We will try to be tricky        so that if the garbage collector is invoked        by mkptr we will not cause markdp() to go off        the deep end. 	*/
operator|*
operator|(
name|linkaddr
operator|-
literal|1
operator|)
operator|=
operator|(
name|lispval
operator|)
name|bind_lists
block|;
name|bind_lists
operator|=
name|linkaddr
block|;
name|i
operator|=
operator|(
name|int
operator|*
operator|)
name|linkaddr
block|;
name|end
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|currend
operator|+
name|header
operator|.
name|a_text
operator|-
literal|7
operator|)
block|;
for|for
control|(
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
operator|*
name|i
expr_stmt|;
operator|*
name|i
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* clobber to short circuit gc */
name|findstr
argument_list|(
name|temp
argument_list|,
name|array
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|int
operator|)
name|mkptr
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_macro
unit|} static
name|do_binder
argument_list|()
end_macro

begin_block
block|{
name|char
name|array
index|[
name|STRLIM
index|]
decl_stmt|;
name|struct
name|argent
modifier|*
name|onp
init|=
name|np
decl_stmt|;
name|int
name|pos
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
struct|struct
block|{
name|lispval
function_decl|(
modifier|*
name|b_entry
function_decl|)
parameter_list|()
function_decl|;
name|int
name|b_atmlnk
decl_stmt|;
name|int
name|b_type
decl_stmt|;
block|}
name|bindage
struct|;
name|snpand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|lseek
argument_list|(
name|fildes
argument_list|,
operator|(
sizeof|sizeof
name|header
operator|)
operator|+
name|header
operator|.
name|a_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|read
argument_list|(
name|fildes
argument_list|,
operator|&
name|bindage
argument_list|,
sizeof|sizeof
name|bindage
argument_list|)
operator|==
sizeof|sizeof
name|bindage
operator|&&
name|bindage
operator|.
name|b_atmlnk
operator|!=
operator|-
literal|1
condition|)
block|{
name|np
operator|=
name|onp
expr_stmt|;
if|if
condition|(
name|bindage
operator|.
name|b_type
operator|==
literal|99
condition|)
block|{
comment|/* we must evaluate this form for effect */
comment|/* and must take care that setsyntax works 			   on the proper read table */
name|findstr
argument_list|(
name|bindage
operator|.
name|b_atmlnk
argument_list|,
name|array
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISNIL
argument_list|(
name|copval
argument_list|(
name|gcload
argument_list|,
name|CNIL
argument_list|)
argument_list|)
operator|&&
name|loading
operator|->
name|clb
operator|!=
name|tatom
condition|)
name|gc
argument_list|(
name|CNIL
argument_list|)
expr_stmt|;
comment|/*  do a gc if gc will be off  */
name|handy
operator|=
operator|(
name|mkptr
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|curibase
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|currtab
expr_stmt|;
name|eval
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|strtab
expr_stmt|;
name|curibase
operator|=
name|ibase
operator|->
name|clb
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|handy
operator|=
name|newfunct
argument_list|()
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|handy
operator|->
name|entry
operator|=
name|bindage
operator|.
name|b_entry
expr_stmt|;
name|handy
operator|->
name|discipline
operator|=
operator|(
name|bindage
operator|.
name|b_type
operator|==
literal|0
condition|?
name|lambda
else|:
name|bindage
operator|.
name|b_type
operator|==
literal|1
condition|?
name|nlambda
else|:
name|macro
operator|)
expr_stmt|;
name|findstr
argument_list|(
name|bindage
operator|.
name|b_atmlnk
argument_list|,
name|array
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|array
operator|!=
literal|'('
condition|)
name|mkptr
argument_list|(
name|array
argument_list|)
operator|->
name|fnbnd
operator|=
name|handy
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|lispval
name|prop
decl_stmt|,
name|atom
decl_stmt|;
name|i
operator|=
name|index
argument_list|(
name|array
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|j
operator|=
name|index
argument_list|(
name|array
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
literal|0
expr_stmt|;
operator|*
name|j
operator|=
literal|0
expr_stmt|;
name|protect
argument_list|(
name|prop
operator|=
name|mkptr
argument_list|(
name|array
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|atom
operator|=
name|mkptr
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Iputprop
argument_list|(
name|atom
argument_list|,
name|handy
argument_list|,
name|prop
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|pos
operator|=
name|lseek
argument_list|(
name|fildes
argument_list|,
name|pos
operator|+
sizeof|sizeof
name|bindage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|findstr
argument_list|(
argument|ptr
argument_list|,
argument|array
argument_list|)
name|int
name|ptr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|lseek
argument_list|(
name|fildes
argument_list|,
sizeof|sizeof
name|header
operator|+
name|header
operator|.
name|a_text
operator|+
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|<
name|STRLIM
operator|&&
name|read
argument_list|(
name|fildes
argument_list|,
operator|&
name|array
index|[
name|cnt
index|]
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
operator|&&
name|array
index|[
name|cnt
index|]
operator|!=
literal|0
condition|)
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>=
name|STRLIM
condition|)
name|error
argument_list|(
literal|"fasl string table overflow"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|lispval
name|mkptr
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|lispval
name|work
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|p
init|=
name|stdin
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* find free file descriptor */
for|for
control|(
init|;
name|p
operator|->
name|_flag
operator|&
operator|(
name|_IOREAD
operator||
name|_IOWRT
operator|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|>=
name|_iob
operator|+
name|_NFILE
condition|)
name|error
argument_list|(
literal|"Too many open files to do readlist"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p
operator|->
name|_flag
operator|=
name|_IOREAD
operator||
name|_IOSTRG
expr_stmt|;
name|p
operator|->
name|_base
operator|=
name|p
operator|->
name|_ptr
operator|=
name|str
expr_stmt|;
name|p
operator|->
name|_cnt
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|=
name|Lread
argument_list|()
expr_stmt|;
name|p
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_ptr
operator|=
name|p
operator|->
name|_base
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_file
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_flag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

end_unit

