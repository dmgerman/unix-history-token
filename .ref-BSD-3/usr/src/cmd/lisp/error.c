begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_comment
comment|/* error ****************************************************************/
end_comment

begin_comment
comment|/* this routine is always called on a non-fatal error.  The first argu-	*/
end_comment

begin_comment
comment|/* ment is printed out.  The second a boolean flag indicating if the	*/
end_comment

begin_comment
comment|/* error routine is permitted to return a pointer to a lisp value if	*/
end_comment

begin_comment
comment|/* the "cont" command is executed.					*/
end_comment

begin_comment
comment|/* error from lisp C code, this temporarily replaces the old error  * allowing us to interface with the new errset scheme with minimum  * difficulty.  We assume that an error which comes to this routine  * is of an "undefined error type" ER%misc .  Soon all calls to this  * routine will be removed.  *  */
end_comment

begin_function
name|lispval
name|error
parameter_list|(
name|mesg
parameter_list|,
name|contvl
parameter_list|)
name|char
modifier|*
name|mesg
decl_stmt|;
name|lispval
name|contvl
decl_stmt|;
block|{
name|lispval
name|errorh
parameter_list|()
function_decl|;
return|return
operator|(
name|errorh
argument_list|(
name|Vermisc
argument_list|,
name|mesg
argument_list|,
name|nil
argument_list|,
name|contvl
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* new error handler, works with errset   *   * call is errorh(type,message,valret,contuab) where  * type is an atom which classifys the error, and whose clb, if not nil  * is the name of a function to call to handle the error.  * message is a character string to print to describe the error  * valret is the value to return to an errset if one is found,  * and contuab is non nil if this error is continuable.  */
end_comment

begin_include
include|#
directive|include
file|"catchframe.h"
end_include

begin_function
name|lispval
name|errorh
parameter_list|(
name|type
parameter_list|,
name|message
parameter_list|,
name|valret
parameter_list|,
name|contuab
parameter_list|,
name|uniqid
parameter_list|)
name|lispval
name|type
decl_stmt|,
name|valret
decl_stmt|;
name|int
name|uniqid
decl_stmt|,
name|contuab
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
specifier|register
name|struct
name|catchfr
modifier|*
name|curp
decl_stmt|;
comment|/* must be first register decl */
specifier|register
name|lispval
name|handy
decl_stmt|;
name|lispval
modifier|*
name|work
init|=
literal|1
operator|+
operator|(
name|lispval
operator|*
operator|)
operator|&
name|uniqid
decl_stmt|;
name|int
name|limit
init|=
name|nargs
argument_list|()
operator|-
literal|5
decl_stmt|;
name|lispval
name|Lread
argument_list|()
decl_stmt|,
name|calhan
argument_list|()
decl_stmt|;
name|struct
name|argent
modifier|*
name|savedlbot
init|=
name|lbot
decl_stmt|;
name|struct
name|nament
modifier|*
name|savedbnp
init|=
name|bnp
decl_stmt|;
name|int
name|curdep
decl_stmt|;
comment|/* error depth */
typedef|typedef
name|struct
name|catchfr
modifier|*
name|cp
typedef|;
specifier|extern
name|int
name|errp
decl_stmt|;
name|int
name|myerrp
init|=
name|errp
decl_stmt|,
name|what
decl_stmt|;
name|int
name|saveme
index|[
name|SAVSIZE
index|]
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|clb
operator|!=
name|nil
condition|)
comment|/* if there is an error handler */
block|{
name|handy
operator|=
name|calhan
argument_list|(
name|limit
argument_list|,
name|work
argument_list|,
name|type
operator|->
name|clb
argument_list|,
name|uniqid
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|contuab
operator|&&
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|DTPR
operator|)
condition|)
return|return
operator|(
name|handy
operator|->
name|car
operator|)
return|;
block|}
comment|/* search stack for error catcher */
for|for
control|(
name|curp
operator|=
operator|(
name|cp
operator|)
name|errp
init|;
name|curp
operator|!=
operator|(
name|cp
operator|)
name|nil
condition|;
name|curp
operator|=
name|curp
operator|->
name|link
control|)
block|{
if|if
condition|(
operator|(
name|curp
operator|->
name|labl
operator|==
name|type
operator|)
operator|||
operator|(
operator|(
name|TYPE
argument_list|(
name|curp
operator|->
name|labl
argument_list|)
operator|==
name|DTPR
operator|)
operator|&&
operator|(
name|curp
operator|->
name|labl
operator|->
name|car
operator|==
name|Verall
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|curp
operator|->
name|flag
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|type
operator|!=
name|Vererr
operator|)
condition|)
block|{
comment|/* print the full error message */
name|printf
argument_list|(
literal|"%s  "
argument_list|,
name|message
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|--
operator|>
literal|0
condition|)
block|{
name|printr
argument_list|(
operator|*
name|work
operator|++
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|popnames
argument_list|(
name|curp
operator|->
name|svbnp
argument_list|)
expr_stmt|;
comment|/* un shallow bind */
name|errp
operator|=
operator|(
name|int
operator|)
name|curp
operator|->
name|link
expr_stmt|;
comment|/* set error to next frame */
asm|asm("	addl3	$16,r11,sp");
comment|/* skip link,flag,labl,svbnp */
asm|asm("	movc3	$40,(sp),_setsav");
comment|/*restore (return) context*/
asm|asm("	movab	40(sp),sp");
comment|/* skip past ""     "" */
asm|asm("	popr	$0x2540");
comment|/* restore registers */
asm|asm("	movl	12(ap),r0");
comment|/* set return value */
asm|asm("	rsb");
comment|/* return to errset */
comment|/* NOT REACHED */
block|}
block|}
comment|/* no one will catch this error, we must see if there is an 	   error-goes-to-top-level catcher */
if|if
condition|(
name|Vertpl
operator|->
name|clb
operator|!=
name|nil
condition|)
block|{
name|handy
operator|=
name|calhan
argument_list|(
name|limit
argument_list|,
name|work
argument_list|,
name|Vertpl
argument_list|,
name|uniqid
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|contuab
operator|&&
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|DTPR
operator|)
condition|)
return|return
operator|(
name|handy
operator|->
name|car
operator|)
return|;
block|}
comment|/* at this point, print error mssage and break, just like 	   the current error scheme */
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|message
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|--
operator|>
literal|0
condition|)
block|{
name|printr
argument_list|(
operator|*
name|work
operator|++
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|curdep
operator|=
operator|++
name|depth
expr_stmt|;
name|getexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
while|while
condition|(
name|what
operator|=
name|setexit
argument_list|()
condition|)
block|{
name|errp
operator|=
name|myerrp
expr_stmt|;
name|depth
operator|=
name|curdep
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|BRRETB
case|:
if|if
condition|(
name|curdep
operator|==
operator|(
name|int
operator|)
name|contval
condition|)
block|{
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|savedlbot
expr_stmt|;
continue|continue;
block|}
default|default:
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
name|reset
argument_list|(
name|what
argument_list|)
expr_stmt|;
case|case
name|BRRETN
case|:
if|if
condition|(
name|contuab
condition|)
block|{
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|savedlbot
expr_stmt|;
name|depth
operator|=
name|curdep
operator|-
literal|1
expr_stmt|;
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
return|return
operator|(
name|contval
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"CAN'T CONTINUE\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|P
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|eofa
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n%d:>"
argument_list|,
name|curdep
argument_list|)
expr_stmt|;
name|dmpport
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|vtemp
operator|=
name|Lread
argument_list|()
expr_stmt|;
if|if
condition|(
name|vtemp
operator|==
name|eofa
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|eval
argument_list|(
name|vtemp
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|lispval
name|calhan
argument_list|(
name|limit
argument_list|,
name|work
argument_list|,
name|handler
argument_list|,
name|uniqid
argument_list|,
name|message
argument_list|)
decl|register
name|lispval
modifier|*
name|work
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|handler
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|limit
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uniqid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|handler
operator|->
name|clb
argument_list|)
expr_stmt|;
comment|/* funcall the handler */
name|protect
argument_list|(
name|handy
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
comment|/* with a list consisting of */
name|handy
operator|->
name|car
operator|=
name|inewint
argument_list|(
name|uniqid
argument_list|)
expr_stmt|;
comment|/* identifying number, */
name|handy
operator|=
name|handy
operator|->
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|car
operator|=
name|matom
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|/* message to be typed out, */
while|while
condition|(
name|limit
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* any other args. */
name|handy
operator|=
name|handy
operator|->
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|car
operator|=
operator|*
name|work
operator|++
expr_stmt|;
block|}
name|handy
operator|->
name|cdr
operator|=
name|nil
expr_stmt|;
name|handy
operator|=
name|Lfuncal
argument_list|()
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
block|}
end_block

begin_comment
comment|/* lispend **************************************************************/
end_comment

begin_comment
comment|/* Fatal errors come here, with their epitaph.				*/
end_comment

begin_macro
name|lispend
argument_list|(
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|char
name|mesg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dmpport
argument_list|(
name|poport
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|errport
argument_list|,
literal|"%s\n"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|dmpport
argument_list|(
name|errport
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* namerr ***************************************************************/
end_comment

begin_comment
comment|/* handles namestack overflow, at present by simply giving a message	*/
end_comment

begin_macro
name|namerr
argument_list|()
end_macro

begin_block
block|{
name|np
operator|-=
literal|10
expr_stmt|;
name|error
argument_list|(
literal|"NAMESTACK OVERFLOW"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_block

begin_macro
name|binderr
argument_list|()
end_macro

begin_block
block|{
name|bnp
operator|-=
literal|10
expr_stmt|;
name|error
argument_list|(
literal|"Bindstack overflow."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rtaberr
argument_list|()
end_macro

begin_block
block|{
name|bindfix
argument_list|(
name|Vreadtable
argument_list|,
name|strtab
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Illegal read table."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|badmem
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"Attempt to allocate beyond static structures."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

