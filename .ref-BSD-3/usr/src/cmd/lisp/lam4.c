begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_define
define|#
directive|define
name|protect
parameter_list|(
name|z
parameter_list|)
value|(np++->val = (z))
end_define

begin_typedef
typedef|typedef
name|struct
name|argent
modifier|*
name|ap
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|restype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prunep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|adbig
argument_list|()
decl_stmt|,
name|subbig
argument_list|()
decl_stmt|,
name|mulbig
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|lispval
name|Ladd
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|ap
name|result
decl_stmt|,
name|mynp
decl_stmt|,
name|oldnp
decl_stmt|,
name|lbot
decl_stmt|,
name|np
decl_stmt|;
name|int
name|itemp
decl_stmt|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|rdrsdot
argument_list|)
expr_stmt|;
name|rdrsdot
operator|->
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|rdrsdot
operator|->
name|I
operator|=
literal|0
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|mynp
operator|=
name|lbot
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|+=
name|work
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|dmlad
argument_list|(
name|result
operator|->
name|val
argument_list|,
literal|1
argument_list|,
name|work
operator|->
name|i
argument_list|)
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
name|error
argument_list|(
literal|"Don't know how to make bignums into reals, yet"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|result
operator|->
name|val
operator|=
name|adbig
argument_list|(
name|work
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TYPE
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|rdrsdot
operator|->
name|I
operator|=
name|result
operator|->
name|val
operator|->
name|I
expr_stmt|;
name|rdrsdot
operator|->
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|rdrsdot
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|prunep
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
if|if
condition|(
name|result
operator|->
name|val
operator|->
name|CDR
operator|==
operator|(
name|lispval
operator|)
literal|0
condition|)
block|{
name|protect
argument_list|(
name|newdoub
argument_list|()
argument_list|)
expr_stmt|;
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|r
operator|=
name|result
operator|->
name|val
operator|->
name|i
operator|+
name|work
operator|->
name|r
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|np
operator|--
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Don't know how to make bignums into reals, yet"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|+=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Non-number to add"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|restype
operator|==
name|DOUB
operator|||
name|prunep
operator|==
name|FALSE
condition|)
return|return
operator|(
name|result
operator|->
name|val
operator|)
return|;
elseif|else
if|if
condition|(
name|result
operator|->
name|val
operator|->
name|CDR
operator|==
operator|(
name|lispval
operator|)
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
name|result
operator|->
name|val
operator|->
name|I
argument_list|)
operator|)
return|;
else|else
block|{
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|adbig
argument_list|(
operator|&
name|dummybig
argument_list|,
name|result
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
name|urk
label|:
name|error
argument_list|(
literal|"Internal error in (add,sub,quo,times)"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|Lsub
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|ap
name|result
decl_stmt|,
name|mynp
decl_stmt|,
name|oldnp
decl_stmt|,
name|lbot
decl_stmt|,
name|np
decl_stmt|;
name|int
name|itemp
decl_stmt|;
name|lispval
name|Lminus
parameter_list|()
function_decl|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|mynp
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
name|protect
argument_list|(
name|rdrsdot
argument_list|)
expr_stmt|;
name|rdrsdot
operator|->
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|rdrsdot
operator|->
name|I
operator|=
literal|0
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|oldnp
operator|==
name|lbot
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|oldnp
operator|==
name|mynp
condition|)
return|return
operator|(
name|Lminus
argument_list|()
operator|)
return|;
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|rdrsdot
operator|->
name|I
operator|=
name|work
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|result
operator|->
name|val
operator|=
name|adbig
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|result
operator|->
name|val
argument_list|)
operator|==
name|INT
condition|)
block|{
name|rdrsdot
operator|->
name|I
operator|=
name|result
operator|->
name|val
operator|->
name|i
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|rdrsdot
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|work
operator|->
name|r
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
block|}
for|for
control|(
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|-=
name|work
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|dmlad
argument_list|(
name|result
operator|->
name|val
argument_list|,
literal|1
argument_list|,
operator|-
name|work
operator|->
name|i
argument_list|)
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
name|error
argument_list|(
literal|"Don't know how to make bignums into reals, yet"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|result
operator|->
name|val
operator|=
name|subbig
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TYPE
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|rdrsdot
operator|->
name|I
operator|=
name|result
operator|->
name|val
operator|->
name|I
expr_stmt|;
name|rdrsdot
operator|->
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|rdrsdot
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|prunep
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
if|if
condition|(
name|result
operator|->
name|val
operator|->
name|CDR
operator|==
operator|(
name|lispval
operator|)
literal|0
condition|)
block|{
name|protect
argument_list|(
name|newdoub
argument_list|()
argument_list|)
expr_stmt|;
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|r
operator|=
name|result
operator|->
name|val
operator|->
name|i
operator|-
name|work
operator|->
name|r
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|np
operator|--
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Don't know how to make bignums into reals, yet"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|-=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Non-number to minus"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|restype
operator|==
name|DOUB
operator|||
name|prunep
operator|==
name|FALSE
condition|)
return|return
operator|(
name|result
operator|->
name|val
operator|)
return|;
elseif|else
if|if
condition|(
name|result
operator|->
name|val
operator|->
name|CDR
operator|==
operator|(
name|lispval
operator|)
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
name|result
operator|->
name|val
operator|->
name|I
argument_list|)
operator|)
return|;
else|else
block|{
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|adbig
argument_list|(
operator|&
name|dummybig
argument_list|,
name|result
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
name|urk
label|:
name|error
argument_list|(
literal|"Internal error in (add,sub,quo,times)"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|Ltimes
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|ap
name|result
decl_stmt|,
name|mynp
decl_stmt|,
name|oldnp
decl_stmt|,
name|lbot
decl_stmt|,
name|np
decl_stmt|;
name|int
name|itemp
decl_stmt|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|rdrsdot
argument_list|)
expr_stmt|;
name|rdrsdot
operator|->
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|rdrsdot
operator|->
name|I
operator|=
literal|1
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|mynp
operator|=
name|lbot
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|*=
name|work
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|dmlad
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|work
operator|->
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
name|error
argument_list|(
literal|"Don't know how to make bignums into reals, yet"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|result
operator|->
name|val
operator|=
name|mulbig
argument_list|(
name|work
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TYPE
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
if|if
condition|(
name|result
operator|->
name|val
operator|->
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|result
operator|->
name|val
operator|)
return|;
name|rdrsdot
operator|->
name|I
operator|=
name|result
operator|->
name|val
operator|->
name|I
expr_stmt|;
name|rdrsdot
operator|->
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|rdrsdot
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|prunep
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
if|if
condition|(
name|result
operator|->
name|val
operator|->
name|CDR
operator|==
operator|(
name|lispval
operator|)
literal|0
condition|)
block|{
name|protect
argument_list|(
name|newdoub
argument_list|()
argument_list|)
expr_stmt|;
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|r
operator|=
name|result
operator|->
name|val
operator|->
name|i
operator|*
name|work
operator|->
name|r
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|np
operator|--
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Don't know how to make bignums into reals, yet"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|*=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Non-number to times"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|restype
operator|==
name|DOUB
operator|||
name|prunep
operator|==
name|FALSE
condition|)
return|return
operator|(
name|result
operator|->
name|val
operator|)
return|;
elseif|else
if|if
condition|(
name|result
operator|->
name|val
operator|->
name|CDR
operator|==
operator|(
name|lispval
operator|)
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
name|result
operator|->
name|val
operator|->
name|I
argument_list|)
operator|)
return|;
else|else
block|{
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|adbig
argument_list|(
operator|&
name|dummybig
argument_list|,
name|result
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
name|urk
label|:
name|error
argument_list|(
literal|"Internal error in (add,sub,quo,times)"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|Lquo
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|lispval
name|result
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|mynp
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|oldnp
decl_stmt|,
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|bigflag
init|=
literal|0
decl_stmt|,
name|realflag
init|=
literal|0
decl_stmt|,
name|itemp
decl_stmt|;
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|lispval
name|divbig
argument_list|()
decl_stmt|,
modifier|*
name|resaddr
decl_stmt|;
name|mynp
operator|=
name|lbot
expr_stmt|;
name|oldnp
operator|=
name|np
operator|-
literal|1
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mynp
operator|>
name|oldnp
condition|)
goto|goto
name|out
goto|;
name|work
operator|=
operator|(
name|mynp
operator|++
operator|)
operator|->
name|val
expr_stmt|;
name|itemp
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|itemp
condition|)
block|{
case|case
name|INT
case|:
name|dummybig
operator|.
name|I
operator|=
name|work
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|realflag
operator|=
literal|1
expr_stmt|;
name|protect
argument_list|(
name|result
operator|=
name|newdoub
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|->
name|r
operator|=
name|work
operator|->
name|r
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|protect
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|resaddr
operator|=
operator|&
operator|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
expr_stmt|;
name|bigflag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Don't know how to divide this type."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|mynp
operator|<=
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
name|itemp
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|itemp
condition|)
block|{
case|case
name|INT
case|:
if|if
condition|(
name|work
operator|->
name|i
operator|==
literal|0
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|realflag
condition|)
name|result
operator|->
name|r
operator|/=
name|work
operator|->
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|bigflag
condition|)
block|{
name|dummybig
operator|.
name|I
operator|=
name|work
operator|->
name|i
expr_stmt|;
name|divbig
argument_list|(
operator|*
name|resaddr
argument_list|,
operator|&
name|dummybig
argument_list|,
name|resaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dummybig
operator|.
name|I
operator|/=
name|work
operator|->
name|i
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
if|if
condition|(
name|realflag
condition|)
name|result
operator|->
name|r
operator|/=
name|work
operator|->
name|r
expr_stmt|;
elseif|else
if|if
condition|(
name|bigflag
condition|)
name|error
argument_list|(
literal|"Don't know how to make bignums into reals, yet"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|realflag
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|result
operator|->
name|r
operator|=
operator|(
name|double
operator|)
name|dummybig
operator|.
name|I
operator|/
name|work
operator|->
name|r
expr_stmt|;
name|protect
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SDOT
case|:
if|if
condition|(
name|realflag
condition|)
name|error
argument_list|(
literal|"Don't know how to divide reals by bignums "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bigflag
condition|)
name|divbig
argument_list|(
operator|*
name|resaddr
argument_list|,
name|work
argument_list|,
name|resaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|bigflag
operator|=
literal|1
expr_stmt|;
name|protect
argument_list|(
name|newsdot
argument_list|()
argument_list|)
expr_stmt|;
name|resaddr
operator|=
operator|&
operator|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
expr_stmt|;
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|i
operator|=
name|dummybig
operator|.
name|I
expr_stmt|;
name|divbig
argument_list|(
operator|*
name|resaddr
argument_list|,
name|work
argument_list|,
name|resaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Don't know how to divide this type"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|realflag
condition|)
return|return
operator|(
name|result
operator|)
return|;
elseif|else
if|if
condition|(
name|bigflag
condition|)
return|return
operator|(
operator|*
name|resaddr
operator|)
return|;
else|else
block|{
name|result
operator|=
name|inewint
argument_list|(
name|dummybig
operator|.
name|I
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
end_function

end_unit

