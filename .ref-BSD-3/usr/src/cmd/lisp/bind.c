begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_define
define|#
directive|define
name|STRLIM
value|1024
end_define

begin_function_decl
specifier|static
name|lispval
name|mkptr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|exec
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|nlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lispval
modifier|*
name|linkaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bindaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fildes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lispval
name|currtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lispval
name|curibase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fvirgin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initflag
decl_stmt|;
end_decl_stmt

begin_function
name|lispval
name|Lbind
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mlbot
init|=
name|lbot
decl_stmt|;
specifier|register
name|lispval
name|work
decl_stmt|;
name|char
modifier|*
name|sbrk
argument_list|()
decl_stmt|,
modifier|*
name|tfile
decl_stmt|,
name|cbuf
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|mytemp
argument_list|()
decl_stmt|,
modifier|*
name|gstab
argument_list|()
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cbuf
argument_list|,
name|gstab
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"getting symbol table from %s\n"
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fildes
operator|=
name|open
argument_list|(
name|cbuf
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/* 	 * Read a.out header to find out where symbol table is. 	 */
if|if
condition|(
name|read
argument_list|(
name|fildes
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
name|lseek
argument_list|(
name|fildes
argument_list|,
name|header
operator|.
name|a_text
operator|+
name|header
operator|.
name|a_data
operator|+
name|header
operator|.
name|a_trsize
operator|+
name|header
operator|.
name|a_drsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|currtab
operator|=
name|Vreadtable
operator|->
name|clb
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|strtab
expr_stmt|;
name|curibase
operator|=
name|ibase
operator|->
name|clb
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
sizeof|sizeof
name|nlist
operator|)
operator|==
name|read
argument_list|(
name|fildes
argument_list|,
operator|&
name|nlist
argument_list|,
sizeof|sizeof
name|nlist
argument_list|)
condition|)
block|{
if|if
condition|(
name|nlist
operator|.
name|n_name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|nlist
operator|.
name|n_name
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
continue|continue;
name|linkaddr
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
name|nlist
operator|.
name|n_value
expr_stmt|;
name|bindaddr
operator|=
operator|(
name|int
operator|*
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|nlist
operator|.
name|n_value
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
name|do_linker
argument_list|()
expr_stmt|;
name|do_binder
argument_list|()
expr_stmt|;
block|}
name|ibase
operator|->
name|clb
operator|=
name|curibase
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|currtab
expr_stmt|;
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|do_linker
argument_list|()
block|{
specifier|register
name|int
operator|*
name|i
block|,
operator|*
name|end
block|,
name|temp
block|;
name|char
name|array
index|[
name|STRLIM
index|]
block|;
specifier|extern
name|lispval
operator|*
name|bind_lists
block|;
comment|/* first link this linkage table to the garbage 	   collector's list.  We will try to be tricky        so that if the garbage collector is invoked        by mkptr we will not cause markdp() to go off        the deep end. 	*/
operator|*
operator|(
name|linkaddr
operator|-
literal|1
operator|)
operator|=
operator|(
name|lispval
operator|)
name|bind_lists
block|;
name|bind_lists
operator|=
name|linkaddr
block|;
name|i
operator|=
operator|(
name|int
operator|*
operator|)
name|linkaddr
block|;
name|initflag
operator|=
name|TRUE
block|;
for|for
control|(
init|;
operator|*
name|i
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
operator|*
name|i
expr_stmt|;
operator|*
name|i
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* clobber to short circuit gc */
name|findstr
argument_list|(
name|temp
argument_list|,
name|array
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|int
operator|)
name|mkptr
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
name|initflag
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_macro
unit|} static
name|do_binder
argument_list|()
end_macro

begin_block
block|{
name|char
name|array
index|[
name|STRLIM
index|]
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
struct|struct
name|binder
block|{
name|lispval
function_decl|(
modifier|*
name|b_entry
function_decl|)
parameter_list|()
function_decl|;
name|int
name|b_atmlnk
decl_stmt|;
name|int
name|b_type
decl_stmt|;
block|}
name|bindage
struct|,
modifier|*
name|pos
struct|;
name|pos
operator|=
operator|(
expr|struct
name|binder
operator|*
operator|)
name|bindaddr
expr_stmt|;
name|initflag
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|bindage
operator|=
operator|*
name|pos
operator|++
init|;
name|bindage
operator|.
name|b_atmlnk
operator|!=
operator|-
literal|1
condition|;
name|bindage
operator|=
operator|*
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|bindage
operator|.
name|b_type
operator|==
literal|99
condition|)
block|{
name|struct
name|argent
modifier|*
name|olbot
decl_stmt|;
comment|/* we must evaluate this form for effect */
name|findstr
argument_list|(
name|bindage
operator|.
name|b_atmlnk
argument_list|,
name|array
argument_list|)
expr_stmt|;
comment|/* garbage collection appears to 			   cause problems at this point */
comment|/* if(ISNIL(copval(gcload,CNIL))&& loading->clb != tatom) 				gc(CNIL);	/*  do a gc if gc will be off  */
name|handy
operator|=
name|mkptr
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|olbot
operator|=
name|lbot
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|curibase
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|currtab
expr_stmt|;
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|handy
expr_stmt|;
name|Leval
argument_list|()
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|strtab
expr_stmt|;
name|curibase
operator|=
name|ibase
operator|->
name|clb
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
name|lbot
operator|=
name|olbot
expr_stmt|;
block|}
else|else
block|{
name|handy
operator|=
name|newfunct
argument_list|()
expr_stmt|;
name|handy
operator|->
name|entry
operator|=
name|bindage
operator|.
name|b_entry
expr_stmt|;
name|handy
operator|->
name|discipline
operator|=
operator|(
name|bindage
operator|.
name|b_type
operator|==
literal|0
condition|?
name|lambda
else|:
name|bindage
operator|.
name|b_type
operator|==
literal|1
condition|?
name|nlambda
else|:
name|macro
operator|)
expr_stmt|;
name|findstr
argument_list|(
name|bindage
operator|.
name|b_atmlnk
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|mkptr
argument_list|(
name|array
argument_list|)
operator|->
name|fnbnd
operator|=
name|handy
expr_stmt|;
block|}
block|}
name|initflag
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|findstr
argument_list|(
argument|ptr
argument_list|,
argument|array
argument_list|)
name|int
name|ptr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|ptr
operator|+
operator|(
name|char
operator|*
operator|)
name|bindaddr
expr_stmt|;
while|while
condition|(
name|cnt
operator|<
name|STRLIM
operator|&&
operator|(
name|array
index|[
name|cnt
operator|++
index|]
operator|=
operator|*
name|cp
operator|++
operator|)
condition|)
empty_stmt|;
block|}
end_block

begin_function
specifier|static
name|lispval
name|mkptr
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|lispval
name|work
decl_stmt|,
name|Lread
argument_list|()
decl_stmt|;
name|FILE
modifier|*
name|opiport
init|=
name|piport
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|p
init|=
name|stdin
decl_stmt|;
name|struct
name|argent
modifier|*
name|olbot
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* find free file descriptor */
for|for
control|(
init|;
name|p
operator|->
name|_flag
operator|&
operator|(
name|_IOREAD
operator||
name|_IOWRT
operator|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|>=
name|_iob
operator|+
name|_NFILE
condition|)
name|error
argument_list|(
literal|"Too many open files to do readlist"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p
operator|->
name|_flag
operator|=
name|_IOREAD
operator||
name|_IOSTRG
expr_stmt|;
name|p
operator|->
name|_base
operator|=
name|p
operator|->
name|_ptr
operator|=
name|str
expr_stmt|;
name|p
operator|->
name|_cnt
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|olbot
operator|=
name|lbot
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|piport
operator|=
name|p
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|=
name|Lread
argument_list|()
expr_stmt|;
name|piport
operator|=
name|opiport
expr_stmt|;
name|lbot
operator|=
name|olbot
expr_stmt|;
name|p
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_ptr
operator|=
name|p
operator|->
name|_base
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_file
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_flag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

end_unit

