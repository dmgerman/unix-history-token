begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_define
define|#
directive|define
name|b
value|0x40000000
end_define

begin_define
define|#
directive|define
name|toint
parameter_list|(
name|p
parameter_list|)
value|((int) (p))
end_define

begin_macro
name|divbig
argument_list|(
argument|dividend
argument_list|,
argument|divisor
argument_list|,
argument|quotient
argument_list|,
argument|remainder
argument_list|)
end_macro

begin_decl_stmt
name|lispval
name|dividend
decl_stmt|,
name|divisor
decl_stmt|,
modifier|*
name|quotient
decl_stmt|,
modifier|*
name|remainder
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
name|ujp
operator|,
operator|*
name|vip
expr_stmt|;
name|int
modifier|*
name|sp
argument_list|()
decl_stmt|,
modifier|*
name|alloca
argument_list|()
decl_stmt|,
name|d
decl_stmt|,
name|negflag
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|,
name|carry
decl_stmt|,
name|rem
decl_stmt|,
name|qhat
decl_stmt|,
name|j
decl_stmt|;
name|int
name|borrow
decl_stmt|,
name|negrem
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|utop
init|=
name|sp
argument_list|()
decl_stmt|,
modifier|*
name|ubot
decl_stmt|,
modifier|*
name|vbot
decl_stmt|,
modifier|*
name|qbot
decl_stmt|;
specifier|register
name|lispval
name|work
decl_stmt|;
name|lispval
name|export
parameter_list|()
function_decl|;
comment|/* copy dividend */
for|for
control|(
name|work
operator|=
name|dividend
init|;
name|work
condition|;
name|work
operator|=
name|work
operator|->
name|CDR
control|)
name|stack
argument_list|(
name|work
operator|->
name|I
argument_list|)
expr_stmt|;
name|ubot
operator|=
name|sp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|ubot
operator|<
literal|0
condition|)
block|{
comment|/* knuth's division alg works only for pos 					bignums				*/
name|negflag
operator|^=
literal|1
expr_stmt|;
name|negrem
operator|=
literal|1
expr_stmt|;
name|dsmult
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|ubot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ubot
operator|=
name|sp
argument_list|()
expr_stmt|;
comment|/*copy divisor */
for|for
control|(
name|work
operator|=
name|divisor
init|;
name|work
condition|;
name|work
operator|=
name|work
operator|->
name|CDR
control|)
name|stack
argument_list|(
name|work
operator|->
name|I
argument_list|)
expr_stmt|;
name|vbot
operator|=
name|sp
argument_list|()
expr_stmt|;
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vbot
operator|<
literal|0
condition|)
block|{
name|negflag
operator|^=
literal|1
expr_stmt|;
name|dsmult
argument_list|(
name|ubot
operator|-
literal|1
argument_list|,
name|vbot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* check validity of data */
name|n
operator|=
name|ubot
operator|-
name|vbot
expr_stmt|;
name|m
operator|=
name|utop
operator|-
name|ubot
operator|-
name|n
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* do destructive division by  a single. */
name|rem
operator|=
name|dsdiv
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|ubot
argument_list|,
operator|*
name|vbot
argument_list|)
expr_stmt|;
if|if
condition|(
name|negrem
condition|)
name|rem
operator|=
operator|-
name|rem
expr_stmt|;
if|if
condition|(
name|negflag
condition|)
name|dsmult
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|ubot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
condition|)
operator|*
name|remainder
operator|=
name|inewint
argument_list|(
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|quotient
condition|)
operator|*
name|quotient
operator|=
name|export
argument_list|(
name|utop
argument_list|,
name|ubot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|remainder
condition|)
operator|*
name|remainder
operator|=
name|dividend
expr_stmt|;
if|if
condition|(
name|quotient
condition|)
operator|*
name|quotient
operator|=
name|inewint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|qbot
operator|=
name|alloca
argument_list|(
name|toint
argument_list|(
name|utop
argument_list|)
operator|+
name|toint
argument_list|(
name|vbot
argument_list|)
operator|-
literal|2
operator|*
name|toint
argument_list|(
name|ubot
argument_list|)
argument_list|)
expr_stmt|;
name|d1
label|:
name|d
operator|=
name|b
operator|/
operator|(
operator|*
name|vbot
operator|+
literal|1
operator|)
expr_stmt|;
name|dsmult
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|ubot
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|dsmult
argument_list|(
name|ubot
operator|-
literal|1
argument_list|,
name|vbot
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d2
label|:
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|ujp
operator|=
name|ubot
init|;
name|j
operator|<=
name|m
condition|;
name|j
operator|++
operator|,
name|ujp
operator|++
control|)
block|{
name|d3
label|:
name|qhat
operator|=
name|calqhat
argument_list|(
name|ujp
argument_list|,
name|vbot
argument_list|)
expr_stmt|;
name|d4
label|:
if|if
condition|(
operator|(
name|borrow
operator|=
name|mlsb
argument_list|(
name|ujp
operator|+
name|n
argument_list|,
name|ujp
argument_list|,
name|ubot
argument_list|,
operator|-
name|qhat
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|adback
argument_list|(
name|ujp
operator|+
name|n
argument_list|,
name|ujp
argument_list|,
name|ubot
argument_list|)
expr_stmt|;
name|qhat
operator|--
expr_stmt|;
block|}
name|qbot
index|[
name|j
index|]
operator|=
name|qhat
expr_stmt|;
block|}
name|d8
label|:
if|if
condition|(
name|remainder
condition|)
block|{
name|dsdiv
argument_list|(
name|utop
argument_list|,
name|utop
operator|-
name|n
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|negrem
condition|)
name|dsmult
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|utop
operator|-
name|n
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|remainder
operator|=
name|export
argument_list|(
name|utop
argument_list|,
name|utop
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quotient
condition|)
block|{
if|if
condition|(
name|negflag
condition|)
name|dsmult
argument_list|(
name|qbot
operator|+
name|m
argument_list|,
name|qbot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|quotient
operator|=
name|export
argument_list|(
name|qbot
operator|+
name|m
operator|+
literal|1
argument_list|,
name|qbot
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*static*/
end_comment

begin_expr_stmt
name|calqhat
argument_list|(
name|ujp
argument_list|,
name|v1p
argument_list|)
specifier|register
name|int
operator|*
name|ujp
operator|,
operator|*
name|v1p
expr_stmt|;
end_expr_stmt

begin_block
block|{
asm|asm("	movl	$0x3fffffff,r0");
asm|asm("	cmpl	(r10),(r11)");
asm|asm("	beql	on1");
asm|asm("	emul	(r11),$0x40000000,4(r11),r1");
asm|asm("	ediv	(r10),r1,r0,r5");
asm|asm("on1:");
asm|asm("	emul	r0,4(r10),$0,r1");
asm|asm("	emul	r5,$0x40000000,8(r11),r3");
asm|asm("	subl2	r3,r1");
asm|asm("	sbwc	r4,r2");
asm|asm("	bleq	out1");
asm|asm("	decl	r0");
asm|asm("out1:");
block|}
end_block

begin_comment
comment|/*static*/
end_comment

begin_expr_stmt
name|mlsb
argument_list|(
name|utop
argument_list|,
name|ubot
argument_list|,
name|vtop
argument_list|,
name|nqhat
argument_list|)
specifier|register
name|int
operator|*
name|utop
operator|,
operator|*
name|ubot
operator|,
operator|*
name|vtop
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|nqhat
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm("	clrl	r0");
asm|asm("loop2:	addl2	(r11),r0");
asm|asm("	emul	r8,-(r9),r0,r2");
asm|asm("	extzv	$0,$30,r2,(r11)");
asm|asm("	extv	$30,$32,r2,r0");
asm|asm("	acbl	r10,$-4,r11,loop2");
block|}
end_block

begin_comment
comment|/*static*/
end_comment

begin_expr_stmt
name|adback
argument_list|(
name|utop
argument_list|,
name|ubot
argument_list|,
name|vtop
argument_list|)
specifier|register
name|int
operator|*
name|utop
operator|,
operator|*
name|ubot
operator|,
operator|*
name|vtop
expr_stmt|;
end_expr_stmt

begin_block
block|{
asm|asm("	clrl	r0");
asm|asm("loop3:	addl2	-(r9),r0");
asm|asm("	addl2	(r11),r0");
asm|asm("	extzv	$0,$30,r0,(r11)");
asm|asm("	extv	$30,$2,r0,r0");
asm|asm("	acbl	r10,$-4,r11,loop3");
block|}
end_block

begin_comment
comment|/*static*/
end_comment

begin_expr_stmt
name|dsdiv
argument_list|(
name|top
argument_list|,
name|bot
argument_list|,
name|div
argument_list|)
specifier|register
name|int
operator|*
name|bot
expr_stmt|;
end_expr_stmt

begin_block
block|{
asm|asm("	clrl	r0");
asm|asm("loop4:	emul	r0,$0x40000000,(r11),r1");
asm|asm("	ediv	12(ap),r1,(r11),r0");
asm|asm("	acbl	4(ap),$4,r11,loop4");
block|}
end_block

begin_comment
comment|/*static*/
end_comment

begin_expr_stmt
name|dsmult
argument_list|(
name|top
argument_list|,
name|bot
argument_list|,
name|mult
argument_list|)
specifier|register
name|int
operator|*
name|top
expr_stmt|;
end_expr_stmt

begin_block
block|{
asm|asm("	clrl	r0");
asm|asm("loop5:	emul	12(ap),(r11),r0,r1");
asm|asm("	extzv	$0,$30,r1,(r11)");
asm|asm("	extv	$30,$32,r1,r0");
asm|asm("	acbl	8(ap),$-4,r11,loop5");
asm|asm("	movl	r1,4(r11)");
block|}
end_block

begin_comment
comment|/*static*/
end_comment

begin_function
name|lispval
name|export
parameter_list|(
name|top
parameter_list|,
name|bot
parameter_list|)
specifier|register
name|lispval
name|bot
decl_stmt|;
block|{
specifier|register
name|r10
operator|,
name|r9
operator|,
name|r8
operator|,
name|r7
operator|,
name|r6
expr_stmt|;
asm|asm("	movl	4(ap),r10");
asm|asm("	movl	$0xC0000000,r4");
asm|asm("	jmp	Bexport");
block|}
end_function

begin_define
define|#
directive|define
name|MAXINT
value|0x8000000L
end_define

begin_expr_stmt
name|Ihau
argument_list|(
name|fix
argument_list|)
specifier|register
name|int
name|fix
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|count
expr_stmt|;
if|if
condition|(
name|fix
operator|==
name|MAXINT
condition|)
return|return
operator|(
literal|32
operator|)
return|;
if|if
condition|(
name|fix
operator|<
literal|0
condition|)
name|fix
operator|=
operator|-
name|fix
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|fix
condition|;
name|count
operator|++
control|)
name|fix
operator|/=
literal|2
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_function
name|lispval
name|Lhau
parameter_list|()
block|{
specifier|register
name|count
expr_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|dum1
operator|,
name|dum2
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|lispval
name|Labsval
parameter_list|()
function_decl|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|top
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|count
operator|=
name|Ihau
argument_list|(
name|handy
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|lbot
operator|->
name|val
operator|=
name|Labsval
argument_list|()
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|handy
operator|->
name|CDR
operator|!=
operator|(
operator|(
name|lispval
operator|)
literal|0
operator|)
condition|;
name|handy
operator|=
name|handy
operator|->
name|CDR
control|)
name|count
operator|+=
literal|30
expr_stmt|;
name|count
operator|+=
name|Ihau
argument_list|(
name|handy
operator|->
name|I
argument_list|)
expr_stmt|;
break|break;
default|default:
name|handy
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Haulong: bad argument"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|997
argument_list|,
name|handy
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
return|return
operator|(
name|inewint
argument_list|(
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lhaipar
parameter_list|()
block|{
name|int
modifier|*
name|sp
parameter_list|()
function_decl|;
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|n
expr_stmt|;
specifier|register
name|int
modifier|*
name|top
init|=
name|sp
argument_list|()
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
modifier|*
name|bot
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|mylen
decl_stmt|;
comment|/*chkarg(2);*/
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
comment|/* copy data onto stack */
name|on1
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|stack
argument_list|(
name|work
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
for|for
control|(
init|;
name|work
operator|!=
operator|(
operator|(
name|lispval
operator|)
literal|0
operator|)
condition|;
name|work
operator|=
name|work
operator|->
name|CDR
control|)
name|stack
argument_list|(
name|work
operator|->
name|I
argument_list|)
expr_stmt|;
break|break;
default|default:
name|work
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Haipart: bad first argument"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|996
argument_list|,
name|work
argument_list|)
expr_stmt|;
goto|goto
name|on1
goto|;
block|}
name|bot
operator|=
name|sp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|bot
operator|<
literal|0
condition|)
block|{
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dsmult
argument_list|(
name|top
argument_list|,
name|bot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bot
operator|--
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|bot
operator|==
literal|0
operator|&&
name|bot
operator|<
name|top
condition|;
name|bot
operator|++
control|)
empty_stmt|;
comment|/* recalculate haulong internally */
name|mylen
operator|=
operator|(
name|top
operator|-
name|bot
operator|)
operator|*
literal|30
operator|+
name|Ihau
argument_list|(
operator|*
name|bot
argument_list|)
expr_stmt|;
comment|/* get second argument		  */
name|work
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
operator|!=
name|INT
condition|)
name|work
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Haipart: 2nd arg not int"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|995
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|n
operator|=
name|work
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|mylen
operator|||
operator|-
name|n
operator|>=
name|mylen
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* Here we want n most significant bits 				   so chop off mylen - n bits */
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|mylen
operator|-
name|n
expr_stmt|;
for|for
control|(
name|n
init|;
name|n
operator|>=
literal|30
condition|;
name|n
operator|-=
literal|30
control|)
name|top
operator|--
expr_stmt|;
if|if
condition|(
name|top
operator|<
name|bot
condition|)
name|error
argument_list|(
literal|"Internal error in haipart #1"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dsdiv
argument_list|(
name|top
argument_list|,
name|bot
argument_list|,
literal|1
operator|<<
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* here we want abs(n) low order bits */
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bot
operator|=
name|top
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|n
operator|<=
literal|0
condition|;
name|n
operator|+=
literal|30
control|)
name|bot
operator|--
expr_stmt|;
name|n
operator|=
literal|30
operator|-
name|n
expr_stmt|;
operator|*
name|bot
operator|&=
operator|~
operator|(
operator|-
literal|1
operator|<<
name|n
operator|)
expr_stmt|;
block|}
name|done
label|:
return|return
operator|(
name|export
argument_list|(
name|top
operator|+
literal|1
argument_list|,
name|bot
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

