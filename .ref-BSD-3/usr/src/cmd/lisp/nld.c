begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  *  link editor for VAX  *  *  Written by J. Reiser, modified by K. sklower to have an incremental  *  loading facility  */
end_comment

begin_comment
comment|/*	layout of a.out file:  *  *	header of 8 words	magic number 0410: 					data starts at 1st 0777 					boundary above text 				magic number 0407: 					data starts immediately after 					text  *				text size	)  *				data size	) in bytes  *				bss size	)  *				symbol table size  *				entry point  *				size of text relocation info  *				size of data relocation info  *  *  'segment'   origin   comments  *	header:		0  *	text:		32       0 padded to multiple of 4 bytes  *	data:		32+textsize     0 padded to multiple of 4 bytes  *	text relocation:	32+textsize+datasize  *	data relocation:	32+textsize+datasize+textrelocationsize  *	symbol table:	32+textsize+datasize+textrelocationsize+datarelocationsize  *  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
name|hiword
decl_stmt|;
name|short
name|loword
decl_stmt|;
block|}
typedef|*
name|bless
typedef|;
end_typedef

begin_comment
comment|/* stupid fp-11 */
end_comment

begin_expr_stmt
name|fixl
argument_list|(
name|p
argument_list|)
specifier|register
name|long
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
name|t
decl_stmt|;
name|t
operator|=
operator|(
operator|(
name|bless
operator|)
name|p
operator|)
operator|->
name|hiword
expr_stmt|;
operator|(
operator|(
name|bless
operator|)
name|p
operator|)
operator|->
name|hiword
operator|=
operator|(
operator|(
name|bless
operator|)
name|p
operator|)
operator|->
name|loword
expr_stmt|;
operator|(
operator|(
name|bless
operator|)
name|p
operator|)
operator|->
name|loword
operator|=
name|t
expr_stmt|;
block|}
end_block

begin_macro
name|writel
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|vax
name|fwrite
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|n
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|fwrite
argument_list|(
operator|&
operator|(
operator|*
name|p
operator|)
operator|.
name|loword
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
operator|*
name|p
operator|)
operator|.
name|hiword
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_function
name|long
name|htoi
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
comment|/* hex to integer conversion */
specifier|register
name|long
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|n
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|<=
literal|'9'
operator|&&
operator|*
name|p
operator|>=
literal|'0'
condition|)
name|n
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|<=
literal|'f'
operator|&&
operator|*
name|p
operator|>=
literal|'a'
condition|)
name|n
operator|+=
operator|*
name|p
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|<=
literal|'F'
operator|&&
operator|*
name|p
operator|>=
literal|'A'
condition|)
name|n
operator|+=
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|char
modifier|*
name|STRING
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|BOOL
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|OMAGIC
value|0407
end_define

begin_define
define|#
directive|define
name|NMAGIC
value|0410
end_define

begin_comment
comment|/*  * Symbol types  */
end_comment

begin_define
define|#
directive|define
name|UNDEF
value|0x0
end_define

begin_define
define|#
directive|define
name|ABS
value|0x2
end_define

begin_define
define|#
directive|define
name|TEXT
value|0x4
end_define

begin_define
define|#
directive|define
name|DATA
value|0x6
end_define

begin_define
define|#
directive|define
name|BSS
value|0x8
end_define

begin_define
define|#
directive|define
name|DATAO
value|0xA
end_define

begin_define
define|#
directive|define
name|BSSO
value|0xC
end_define

begin_define
define|#
directive|define
name|TEXTO
value|0xE
end_define

begin_define
define|#
directive|define
name|ABSO
value|0x10
end_define

begin_define
define|#
directive|define
name|COMM
value|0x12
end_define

begin_comment
comment|/* for internal use only */
end_comment

begin_define
define|#
directive|define
name|EXTERN
value|0x1
end_define

begin_define
define|#
directive|define
name|TYPE
value|0x1E
end_define

begin_define
define|#
directive|define
name|STABTYPS
value|0xE0
end_define

begin_comment
comment|/*  * address reference types  */
end_comment

begin_define
define|#
directive|define
name|PCREL
value|1
end_define

begin_define
define|#
directive|define
name|LEN1
value|0
end_define

begin_define
define|#
directive|define
name|LEN2
value|2
end_define

begin_define
define|#
directive|define
name|LEN4
value|4
end_define

begin_define
define|#
directive|define
name|HW
value|01
end_define

begin_define
define|#
directive|define
name|FW
value|03
end_define

begin_define
define|#
directive|define
name|DW
value|07
end_define

begin_define
define|#
directive|define
name|PAGRND
value|0777
end_define

begin_define
define|#
directive|define
name|TYPMASK
value|0x1E
end_define

begin_define
define|#
directive|define
name|TYMASK
value|(0x1E)
end_define

begin_define
define|#
directive|define
name|TMASK
value|0x1F
end_define

begin_define
define|#
directive|define
name|RABS
value|(ABS)
end_define

begin_define
define|#
directive|define
name|RTEXT
value|TEXT
end_define

begin_define
define|#
directive|define
name|RDATA
value|DATA
end_define

begin_define
define|#
directive|define
name|RBSS
value|BSS
end_define

begin_define
define|#
directive|define
name|RDATAO
value|DATAO
end_define

begin_define
define|#
directive|define
name|RBSSO
value|BSSO
end_define

begin_define
define|#
directive|define
name|RTEXTO
value|TEXTO
end_define

begin_define
define|#
directive|define
name|RABSO
value|ABSO
end_define

begin_define
define|#
directive|define
name|REXT
value|(01<<3)
end_define

begin_define
define|#
directive|define
name|ROFF
value|(02<<3)
end_define

begin_define
define|#
directive|define
name|REFMASK
value|0x7
end_define

begin_define
define|#
directive|define
name|NOVLY
value|1
end_define

begin_define
define|#
directive|define
name|RELFLG
value|01
end_define

begin_define
define|#
directive|define
name|NROUT
value|256
end_define

begin_define
define|#
directive|define
name|NSYM
value|1103
end_define

begin_define
define|#
directive|define
name|NSYMPR
value|500
end_define

begin_decl_stmt
name|char
name|premeof
index|[]
init|=
literal|"Premature EOF"
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|loc
decl_stmt|;
block|}
name|LIBLIST
typedef|;
end_typedef

begin_comment
comment|/* overlay management */
end_comment

begin_decl_stmt
name|int
name|vindex
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|argsav
decl_stmt|;
name|int
name|symsav
decl_stmt|;
name|LIBLIST
modifier|*
name|libsav
decl_stmt|;
name|STRING
name|vname
decl_stmt|;
name|long
name|ctsav
decl_stmt|,
name|cdsav
decl_stmt|,
name|cbsav
decl_stmt|;
name|long
name|offt
decl_stmt|,
name|offd
decl_stmt|,
name|offb
decl_stmt|,
name|offtr
decl_stmt|,
name|offdr
decl_stmt|,
name|offs
decl_stmt|;
block|}
name|OVERLAY
typedef|;
end_typedef

begin_decl_stmt
name|OVERLAY
name|vnodes
index|[
name|NOVLY
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input management */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
modifier|*
name|fakeptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|nuser
decl_stmt|;
name|char
name|buff
index|[
literal|512
index|]
decl_stmt|;
block|}
name|PAGE
typedef|;
end_typedef

begin_decl_stmt
name|PAGE
name|page
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|short
modifier|*
name|fakeptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|nuser
decl_stmt|;
block|}
name|fpage
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|long
name|size
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|PAGE
modifier|*
name|pno
decl_stmt|;
block|}
name|STREAM
typedef|;
end_typedef

begin_decl_stmt
name|STREAM
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STREAM
name|reloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ar_hdr
name|archdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|exec
name|filhdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one entry for each archive member referenced;  * set in first pass; needs restoring for overlays  */
end_comment

begin_decl_stmt
name|LIBLIST
name|liblist
index|[
name|NROUT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBLIST
modifier|*
name|libp
init|=
name|liblist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol management */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|sname
index|[
literal|8
index|]
decl_stmt|;
name|char
name|stype
decl_stmt|;
name|char
name|spare
decl_stmt|;
name|short
name|symhash
decl_stmt|;
comment|/* index of hash table entry pointing to this symbol */
name|long
name|svalue
decl_stmt|;
block|}
name|SYMBOL
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|locindex
decl_stmt|;
comment|/* index to symbol in file */
name|SYMBOL
modifier|*
name|locsymbol
decl_stmt|;
comment|/* ptr to symbol table */
block|}
name|LOCAL
typedef|;
end_typedef

begin_decl_stmt
name|SYMBOL
name|cursym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current symbol */
end_comment

begin_decl_stmt
name|SYMBOL
modifier|*
name|symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actual symbols */
end_comment

begin_decl_stmt
name|SYMBOL
modifier|*
name|lastsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last symbol entered */
end_comment

begin_decl_stmt
name|SYMBOL
modifier|*
name|nextsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next available symbol table entry */
end_comment

begin_decl_stmt
name|SYMBOL
modifier|*
name|addsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first symbol defined during incremental 				   load */
end_comment

begin_decl_stmt
name|int
name|nsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols allocated in symtab */
end_comment

begin_decl_stmt
name|SYMBOL
modifier|*
name|hshtab
index|[
name|NSYM
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for symbols */
end_comment

begin_decl_stmt
name|LOCAL
modifier|*
name|local
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal symbols */
end_comment

begin_decl_stmt
name|SYMBOL
modifier|*
name|p_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMBOL
modifier|*
name|p_etext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMBOL
modifier|*
name|p_edata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMBOL
modifier|*
name|p_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMBOL
modifier|*
name|entrypt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags */
end_comment

begin_decl_stmt
name|int
name|xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard local symbols */
end_comment

begin_decl_stmt
name|int
name|Xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard locals starting with 'L' */
end_comment

begin_decl_stmt
name|int
name|Sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard all except locals and globals*/
end_comment

begin_decl_stmt
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preserve relocation bits, don't define common */
end_comment

begin_decl_stmt
name|int
name|arflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original copy of rflag */
end_comment

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard all symbols */
end_comment

begin_decl_stmt
name|int
name|nflag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pure procedure */
end_comment

begin_decl_stmt
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* define common even with rflag */
end_comment

begin_decl_stmt
name|int
name|iflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/D space separated */
end_comment

begin_decl_stmt
name|BOOL
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* overlays used */
end_comment

begin_decl_stmt
name|int
name|Aflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* doing incremental load */
end_comment

begin_decl_stmt
name|int
name|RFflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to escape while reading fundament file*/
end_comment

begin_decl_stmt
name|int
name|ofilfnd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ofilename
init|=
literal|"l.out"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|infil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|textbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cumulative sizes set in pass 1 */
end_comment

begin_decl_stmt
name|long
name|tsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|trsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|drsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ssize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol relocation; both passes */
end_comment

begin_decl_stmt
name|long
name|ctrel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cdrel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cbrel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ctorel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cdorel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cborel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errlev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delarg
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|tout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|dout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|doutn
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|trout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|troutn
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|drout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|droutn
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|sout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|soutn
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
name|get
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
name|getb
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|short
name|gets
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|get3
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|getl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|SYMBOL
modifier|*
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|tcreat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|round
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|SYMBOL
modifier|*
modifier|*
name|slookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|SYMBOL
modifier|*
name|lookloc
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|symwrite
argument_list|(
argument|sp
argument_list|,
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|SYMBOL
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|vax
name|fwrite
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|symtab
argument_list|)
argument_list|,
name|n
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|fwrite
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|symtab
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|svalue
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|svalue
operator|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_macro
name|delexit
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
literal|"l.out"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|doutn
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|troutn
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|droutn
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|soutn
argument_list|)
expr_stmt|;
if|if
condition|(
name|delarg
operator|==
literal|0
condition|)
name|chmod
argument_list|(
name|ofilename
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|delarg
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|num
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|BOOL
name|found
decl_stmt|;
name|int
name|vscan
decl_stmt|;
name|char
name|save
decl_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|nextsym
operator|=
name|symtab
operator|=
operator|(
name|SYMBOL
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nsym
operator|=
literal|0
expr_stmt|;
comment|/* scan files once to find symdefs */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|trace
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|filname
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'o'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Bad output file"
argument_list|)
expr_stmt|;
name|ofilename
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|ofilfnd
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Bad 'use' or 'entry'"
argument_list|)
expr_stmt|;
name|enter
argument_list|(
name|slookup
argument_list|(
operator|*
name|p
operator|++
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|entrypt
operator|=
name|lastsym
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-A: arg missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Aflag
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"-A: Only one fundament file allowed"
argument_list|)
expr_stmt|;
name|Aflag
operator|=
name|TRUE
expr_stmt|;
name|nflag
operator|=
name|FALSE
expr_stmt|;
name|fundament
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'v'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-v: arg missing"
argument_list|)
expr_stmt|;
name|vflag
operator|=
name|TRUE
expr_stmt|;
name|vscan
operator|=
name|vindex
expr_stmt|;
name|found
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|--
name|vscan
operator|>=
literal|0
operator|&&
name|found
operator|==
name|FALSE
condition|)
name|found
operator|=
name|eq
argument_list|(
name|vnodes
index|[
name|vscan
index|]
operator|.
name|vname
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
name|endload
argument_list|(
name|c
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|restore
argument_list|(
name|vscan
argument_list|)
expr_stmt|;
block|}
else|else
name|record
argument_list|(
name|c
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-D: arg missing"
argument_list|)
expr_stmt|;
name|num
operator|=
name|htoi
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
name|num
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-D: too small"
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|num
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-T: arg missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|!=
literal|0
operator|&&
operator|!
name|Aflag
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-T: too late, some text already loaded"
argument_list|)
expr_stmt|;
name|textbase
operator|=
name|htoi
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
name|save
operator|=
name|ap
index|[
operator|--
name|i
index|]
expr_stmt|;
name|ap
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
name|load1arg
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ap
index|[
name|i
index|]
operator|=
name|save
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'X'
case|:
name|Xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
name|Sflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflag
operator|++
expr_stmt|;
name|arflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|sflag
operator|++
expr_stmt|;
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'N'
case|:
name|nflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|dflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|iflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|trace
operator|++
expr_stmt|;
continue|continue;
default|default:
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad flag"
argument_list|)
expr_stmt|;
block|}
comment|/*endsw*/
break|break;
block|}
comment|/*endfor*/
block|}
else|else
name|load1arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|endload
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* used after pass 1 */
end_comment

begin_decl_stmt
name|long
name|torigin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dorigin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|borigin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|database
decl_stmt|;
end_decl_stmt

begin_macro
name|endload
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|long
name|dnum
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|brk
argument_list|(
name|nextsym
argument_list|)
expr_stmt|;
name|filname
operator|=
literal|0
expr_stmt|;
name|middle
argument_list|()
expr_stmt|;
name|setupout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|LOCAL
operator|*
operator|)
operator|-
literal|1
operator|==
operator|(
name|local
operator|=
operator|(
name|LOCAL
operator|*
operator|)
name|sbrk
argument_list|(
name|NSYMPR
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|local
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Memory overflow"
argument_list|)
expr_stmt|;
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|libp
operator|=
name|liblist
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'D'
case|:
for|for
control|(
name|dnum
operator|=
name|htoi
argument_list|(
operator|*
name|p
argument_list|)
init|;
name|dorigin
operator|<
name|dnum
condition|;
name|dorigin
operator|++
control|)
name|putc
argument_list|(
literal|0
argument_list|,
name|dout
argument_list|)
expr_stmt|;
case|case
literal|'T'
case|:
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
case|case
literal|'o'
case|:
case|case
literal|'v'
case|:
operator|++
name|c
expr_stmt|;
operator|++
name|p
expr_stmt|;
default|default:
continue|continue;
case|case
literal|'A'
case|:
name|fund2
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
name|ap
index|[
operator|--
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
name|load2arg
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*endsw*/
break|break;
block|}
comment|/*endfor*/
block|}
else|else
name|load2arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|finishout
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|record
argument_list|(
argument|c
argument_list|,
argument|nam
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|nam
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|OVERLAY
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|vnodes
index|[
name|vindex
operator|++
index|]
expr_stmt|;
name|v
operator|->
name|argsav
operator|=
name|c
expr_stmt|;
name|v
operator|->
name|symsav
operator|=
name|nextsym
operator|-
name|symtab
expr_stmt|;
name|v
operator|->
name|libsav
operator|=
name|libp
expr_stmt|;
name|v
operator|->
name|vname
operator|=
name|nam
expr_stmt|;
name|v
operator|->
name|offt
operator|=
name|tsize
expr_stmt|;
name|v
operator|->
name|offd
operator|=
name|dsize
expr_stmt|;
name|v
operator|->
name|offb
operator|=
name|bsize
expr_stmt|;
name|v
operator|->
name|offtr
operator|=
name|trsize
expr_stmt|;
name|v
operator|->
name|offdr
operator|=
name|drsize
expr_stmt|;
name|v
operator|->
name|offs
operator|=
name|ssize
expr_stmt|;
name|v
operator|->
name|ctsav
operator|=
name|ctrel
expr_stmt|;
name|v
operator|->
name|cdsav
operator|=
name|cdrel
expr_stmt|;
name|v
operator|->
name|cbsav
operator|=
name|cbrel
expr_stmt|;
block|}
end_block

begin_macro
name|restore
argument_list|(
argument|vscan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vscan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|OVERLAY
modifier|*
name|v
decl_stmt|;
specifier|register
name|SYMBOL
modifier|*
name|saved
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|v
operator|=
operator|&
name|vnodes
index|[
name|vscan
index|]
expr_stmt|;
name|vindex
operator|=
name|vscan
operator|+
literal|1
expr_stmt|;
name|libp
operator|=
name|v
operator|->
name|libsav
expr_stmt|;
name|ctrel
operator|=
name|v
operator|->
name|ctsav
expr_stmt|;
name|cdrel
operator|=
name|v
operator|->
name|cdsav
expr_stmt|;
name|cbrel
operator|=
name|v
operator|->
name|cbsav
expr_stmt|;
name|tsize
operator|=
name|v
operator|->
name|offt
expr_stmt|;
name|dsize
operator|=
name|v
operator|->
name|offd
expr_stmt|;
name|bsize
operator|=
name|v
operator|->
name|offb
expr_stmt|;
name|trsize
operator|=
name|v
operator|->
name|offtr
expr_stmt|;
name|drsize
operator|=
name|v
operator|->
name|offdr
expr_stmt|;
name|ssize
operator|=
name|v
operator|->
name|offs
expr_stmt|;
name|saved
operator|=
name|symtab
operator|+
name|v
operator|->
name|symsav
expr_stmt|;
name|sp
operator|=
name|nextsym
expr_stmt|;
while|while
condition|(
name|sp
operator|>
name|saved
condition|)
name|hshtab
index|[
operator|(
operator|--
name|sp
operator|)
operator|->
name|symhash
index|]
operator|=
literal|0
expr_stmt|;
name|nextsym
operator|=
name|saved
expr_stmt|;
block|}
end_block

begin_comment
comment|/* scan file to find defined symbols */
end_comment

begin_expr_stmt
name|load1arg
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|long
name|loc
decl_stmt|;
if|if
condition|(
name|getfile
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
name|load1
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
else|else
block|{
name|loc
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
name|libp
operator|->
name|loc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|libp
operator|>=
name|liblist
operator|+
name|NROUT
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"liblist overflow"
argument_list|)
expr_stmt|;
comment|/* thanks to Dennis Wasley */
return|return;
block|}
name|mget
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|archdr
argument_list|,
sizeof|sizeof
name|archdr
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|load1
argument_list|(
literal|1
argument_list|,
name|loc
operator|+
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|)
condition|)
block|{
name|libp
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|libp
operator|++
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|vax
if|if
condition|(
name|archdr
operator|.
name|ar_size
operator|.
name|loword
operator|==
literal|0
condition|)
name|fixl
argument_list|(
operator|&
name|archdr
operator|.
name|ar_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|loc
operator|+=
name|round
argument_list|(
name|archdr
operator|.
name|ar_size
argument_list|,
literal|1
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* single file or archive member */
end_comment

begin_macro
name|load1
argument_list|(
argument|libflg
argument_list|,
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|long
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SYMBOL
modifier|*
name|sp
decl_stmt|;
name|SYMBOL
modifier|*
name|savnext
decl_stmt|;
name|int
name|ndef
decl_stmt|,
name|nlocal
decl_stmt|,
name|type
decl_stmt|;
name|readhdr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|ctrel
operator|=
name|tsize
expr_stmt|;
name|cdrel
operator|+=
name|dsize
expr_stmt|;
name|cbrel
operator|+=
name|bsize
expr_stmt|;
name|ndef
operator|=
literal|0
expr_stmt|;
name|nlocal
operator|=
sizeof|sizeof
argument_list|(
name|cursym
argument_list|)
expr_stmt|;
name|savnext
operator|=
name|nextsym
expr_stmt|;
comment|/*	if (filhdr.a_trsize+filhdr.a_drsize==0) { /*		error(0, "No relocation bits"); /*		return(0); /*	} */
name|loc
operator|+=
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
operator|+
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|symget
argument_list|(
operator|&
name|cursym
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|type
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|EXTERN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Xflag
operator|==
literal|0
operator|||
name|cursym
operator|.
name|sname
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|||
name|type
operator|&
name|STABTYPS
condition|)
name|nlocal
operator|+=
sizeof|sizeof
name|cursym
expr_stmt|;
continue|continue;
block|}
name|symreloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|enter
argument_list|(
name|lookup
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|=
name|lastsym
operator|)
operator|->
name|stype
operator|!=
name|EXTERN
operator|+
name|UNDEF
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|svalue
operator|>
name|sp
operator|->
name|svalue
condition|)
name|sp
operator|->
name|svalue
operator|=
name|cursym
operator|.
name|svalue
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|svalue
operator|!=
literal|0
operator|&&
name|cursym
operator|.
name|stype
operator|==
name|EXTERN
operator|+
name|TEXT
condition|)
continue|continue;
name|ndef
operator|++
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|cursym
operator|.
name|svalue
expr_stmt|;
block|}
if|if
condition|(
name|libflg
operator|==
literal|0
operator|||
name|ndef
condition|)
block|{
name|tsize
operator|+=
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|dsize
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_data
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|bsize
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_bss
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|ssize
operator|+=
name|nlocal
expr_stmt|;
name|trsize
operator|+=
name|filhdr
operator|.
name|a_trsize
expr_stmt|;
name|drsize
operator|+=
name|filhdr
operator|.
name|a_drsize
expr_stmt|;
if|if
condition|(
name|RFflag
condition|)
name|textbase
operator|=
operator|(
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|)
operator|)
operator|->
name|svalue
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * No symbols defined by this library member. 	 * Rip out the hash table entries and reset the symbol table. 	 */
while|while
condition|(
name|nextsym
operator|>
name|savnext
condition|)
name|hshtab
index|[
operator|(
operator|--
name|nextsym
operator|)
operator|->
name|symhash
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|middle
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|SYMBOL
modifier|*
name|sp
decl_stmt|,
modifier|*
name|symp
decl_stmt|;
name|long
name|csize
decl_stmt|,
name|t
decl_stmt|,
name|corigin
decl_stmt|,
name|ocsize
decl_stmt|;
name|int
name|nund
decl_stmt|,
name|rnd
decl_stmt|;
name|char
name|s
decl_stmt|;
name|torigin
operator|=
literal|0
expr_stmt|;
name|dorigin
operator|=
literal|0
expr_stmt|;
name|borigin
operator|=
literal|0
expr_stmt|;
name|p_data
operator|=
operator|*
name|slookup
argument_list|(
literal|"_data"
argument_list|)
expr_stmt|;
name|p_etext
operator|=
operator|*
name|slookup
argument_list|(
literal|"_etext"
argument_list|)
expr_stmt|;
name|p_edata
operator|=
operator|*
name|slookup
argument_list|(
literal|"_edata"
argument_list|)
expr_stmt|;
name|p_end
operator|=
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|)
expr_stmt|;
comment|/* 	 * If there are any undefined symbols, save the relocation bits. 	 */
name|symp
operator|=
name|nextsym
expr_stmt|;
if|if
condition|(
name|rflag
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|symp
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
operator|&&
name|sp
operator|->
name|svalue
operator|==
literal|0
operator|&&
name|sp
operator|!=
name|p_end
operator|&&
name|sp
operator|!=
name|p_edata
operator|&&
name|sp
operator|!=
name|p_etext
operator|&&
name|sp
operator|!=
name|p_data
condition|)
block|{
name|rflag
operator|++
expr_stmt|;
name|dflag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rflag
condition|)
name|sflag
operator|=
name|iflag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Assign common locations. 	 */
name|csize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Aflag
condition|)
name|addsym
operator|=
name|symtab
expr_stmt|;
name|database
operator|=
name|round
argument_list|(
name|tsize
operator|+
name|textbase
argument_list|,
operator|(
name|nflag
condition|?
name|PAGRND
else|:
name|FW
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
operator|||
name|rflag
operator|==
literal|0
condition|)
block|{
name|ldrsym
argument_list|(
name|p_data
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|EXTERN
operator|+
name|DATA
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|p_etext
argument_list|,
name|tsize
argument_list|,
name|EXTERN
operator|+
name|TEXT
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|p_edata
argument_list|,
name|dsize
argument_list|,
name|EXTERN
operator|+
name|DATA
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|p_end
argument_list|,
name|bsize
argument_list|,
name|EXTERN
operator|+
name|BSS
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|addsym
init|;
name|sp
operator|<
name|symp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|sp
operator|->
name|stype
operator|)
operator|==
name|EXTERN
operator|+
name|UNDEF
operator|&&
operator|(
name|t
operator|=
name|sp
operator|->
name|svalue
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|>
name|DW
condition|)
name|rnd
operator|=
name|DW
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|>
name|FW
condition|)
name|rnd
operator|=
name|FW
expr_stmt|;
else|else
name|rnd
operator|=
name|HW
expr_stmt|;
name|csize
operator|=
name|round
argument_list|(
name|csize
argument_list|,
name|rnd
argument_list|)
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|csize
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|EXTERN
operator|+
name|COMM
expr_stmt|;
name|ocsize
operator|=
name|csize
expr_stmt|;
name|csize
operator|+=
name|t
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|s
operator|&
name|TMASK
operator|)
operator|==
name|EXTERN
operator|+
name|UNDEF
operator|)
operator|&&
operator|(
name|s
operator|&
name|STABTYPS
operator|)
condition|)
block|{
name|sp
operator|->
name|svalue
operator|=
name|ocsize
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
operator|(
name|s
operator|&
name|STABTYPS
operator|)
operator||
operator|(
name|EXTERN
operator|+
name|COMM
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now set symbols to their final value 	 */
name|csize
operator|=
name|round
argument_list|(
name|csize
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|torigin
operator|=
name|textbase
expr_stmt|;
name|dorigin
operator|=
name|database
expr_stmt|;
name|corigin
operator|=
name|dorigin
operator|+
name|dsize
expr_stmt|;
name|borigin
operator|=
name|corigin
operator|+
name|csize
expr_stmt|;
name|cdorel
operator|=
literal|0
expr_stmt|;
name|cborel
operator|=
name|dsize
operator|+
name|csize
expr_stmt|;
name|nund
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|addsym
init|;
name|sp
operator|<
name|symp
condition|;
name|sp
operator|++
control|)
switch|switch
condition|(
name|sp
operator|->
name|stype
operator|&
name|TMASK
condition|)
block|{
case|case
name|EXTERN
operator|+
name|UNDEF
case|:
name|errlev
operator||=
literal|01
expr_stmt|;
if|if
condition|(
operator|(
name|arflag
operator|==
literal|0
operator|||
name|dflag
operator|)
operator|&&
name|sp
operator|->
name|svalue
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nund
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Undefined:\n"
argument_list|)
expr_stmt|;
name|nund
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%.8s\n"
argument_list|,
name|sp
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|EXTERN
operator|+
name|ABS
case|:
default|default:
continue|continue;
case|case
name|EXTERN
operator|+
name|TEXT
case|:
name|sp
operator|->
name|svalue
operator|+=
name|torigin
expr_stmt|;
continue|continue;
case|case
name|EXTERN
operator|+
name|DATA
case|:
name|sp
operator|->
name|svalue
operator|+=
name|dorigin
expr_stmt|;
continue|continue;
case|case
name|EXTERN
operator|+
name|BSS
case|:
name|sp
operator|->
name|svalue
operator|+=
name|borigin
expr_stmt|;
continue|continue;
case|case
name|EXTERN
operator|+
name|COMM
case|:
name|sp
operator|->
name|stype
operator|=
operator|(
name|sp
operator|->
name|stype
operator|&
name|STABTYPS
operator|)
operator||
operator|(
name|EXTERN
operator|+
name|BSS
operator|)
expr_stmt|;
name|sp
operator|->
name|svalue
operator|+=
name|corigin
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
name|ssize
operator|=
literal|0
expr_stmt|;
name|bsize
operator|+=
name|csize
expr_stmt|;
name|nsym
operator|=
name|ssize
operator|/
operator|(
sizeof|sizeof
name|cursym
operator|)
expr_stmt|;
if|if
condition|(
name|Aflag
condition|)
block|{
name|fixspec
argument_list|(
name|p_data
argument_list|,
name|dorigin
argument_list|)
expr_stmt|;
name|fixspec
argument_list|(
name|p_etext
argument_list|,
name|torigin
argument_list|)
expr_stmt|;
name|fixspec
argument_list|(
name|p_edata
argument_list|,
name|dorigin
argument_list|)
expr_stmt|;
name|fixspec
argument_list|(
name|p_end
argument_list|,
name|borigin
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|fixspec
argument_list|(
argument|sym
argument_list|,
argument|offset
argument_list|)
end_macro

begin_decl_stmt
name|SYMBOL
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sym
operator|<
name|addsym
operator|&&
name|sym
operator|!=
literal|0
condition|)
name|sym
operator|->
name|svalue
operator|+=
name|offset
expr_stmt|;
block|}
end_block

begin_macro
name|ldrsym
argument_list|(
argument|asp
argument_list|,
argument|val
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|long
name|val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMBOL
modifier|*
name|asp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SYMBOL
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|asp
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|sp
operator|->
name|stype
operator|!=
name|EXTERN
operator|+
name|UNDEF
operator|||
name|sp
operator|->
name|svalue
operator|)
operator|&&
operator|!
name|Aflag
condition|)
block|{
name|printf
argument_list|(
literal|"%.8s: "
argument_list|,
name|sp
operator|->
name|sname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|"Multiply defined (internal)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|stype
operator|=
name|type
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|val
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|char
name|_sibuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the space is forced upon us; might as well use it */
end_comment

begin_macro
name|setupout
argument_list|()
end_macro

begin_block
block|{
name|tout
operator|=
name|fopen
argument_list|(
name|ofilename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tout
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"cannot create output"
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|tout
argument_list|,
name|_sibuf
argument_list|)
expr_stmt|;
name|dout
operator|=
name|tcreat
argument_list|(
operator|&
name|doutn
argument_list|,
literal|"/tmp/ldaaXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflag
operator|==
literal|0
operator|||
name|xflag
operator|==
literal|0
condition|)
name|sout
operator|=
name|tcreat
argument_list|(
operator|&
name|soutn
argument_list|,
literal|"/tmp/ldbaXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|trout
operator|=
name|tcreat
argument_list|(
operator|&
name|troutn
argument_list|,
literal|"/tmp/ldcaXXXXX"
argument_list|)
expr_stmt|;
name|drout
operator|=
name|tcreat
argument_list|(
operator|&
name|droutn
argument_list|,
literal|"/tmp/lddaXXXXX"
argument_list|)
expr_stmt|;
block|}
name|filhdr
operator|.
name|a_magic
operator|=
name|nflag
condition|?
name|NMAGIC
else|:
name|OMAGIC
expr_stmt|;
name|filhdr
operator|.
name|a_text
operator|=
name|nflag
condition|?
name|tsize
else|:
name|round
argument_list|(
name|tsize
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|filhdr
operator|.
name|a_data
operator|=
name|dsize
expr_stmt|;
name|filhdr
operator|.
name|a_bss
operator|=
name|bsize
expr_stmt|;
name|filhdr
operator|.
name|a_trsize
operator|=
name|trsize
expr_stmt|;
name|filhdr
operator|.
name|a_drsize
operator|=
name|drsize
expr_stmt|;
name|filhdr
operator|.
name|a_syms
operator|=
name|sflag
condition|?
literal|0
else|:
operator|(
name|ssize
operator|+
operator|(
sizeof|sizeof
name|cursym
operator|)
operator|*
operator|(
name|nextsym
operator|-
name|symtab
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|entrypt
condition|)
block|{
if|if
condition|(
name|entrypt
operator|->
name|stype
operator|!=
name|EXTERN
operator|+
name|TEXT
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"Entry point not in text"
argument_list|)
expr_stmt|;
else|else
name|filhdr
operator|.
name|a_entry
operator|=
name|entrypt
operator|->
name|svalue
expr_stmt|;
block|}
else|else
name|filhdr
operator|.
name|a_entry
operator|=
literal|0
expr_stmt|;
name|filhdr
operator|.
name|a_trsize
operator|=
operator|(
name|rflag
condition|?
name|trsize
else|:
literal|0
operator|)
expr_stmt|;
name|filhdr
operator|.
name|a_drsize
operator|=
operator|(
name|rflag
condition|?
name|drsize
else|:
literal|0
operator|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|filhdr
argument_list|,
literal|8
argument_list|,
name|tout
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|FILE
modifier|*
name|tcreat
parameter_list|(
name|namep
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
modifier|*
name|namep
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|tnm
decl_stmt|;
name|tnm
operator|=
name|mktemp
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|tnm
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Cannot create temp file"
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|tnm
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
operator|*
name|namep
operator|=
name|tnm
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_block

begin_macro
name|load2arg
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|LIBLIST
modifier|*
name|lp
decl_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
if|if
condition|(
name|getfile
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|>=
name|acp
operator|&&
operator|*
operator|--
name|cp
operator|!=
literal|'/'
condition|)
empty_stmt|;
name|mkfsym
argument_list|(
operator|++
name|cp
argument_list|)
expr_stmt|;
name|load2
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* scan archive members referenced */
for|for
control|(
name|lp
operator|=
name|libp
init|;
name|lp
operator|->
name|loc
operator|!=
operator|-
literal|1
condition|;
name|lp
operator|++
control|)
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|lp
operator|->
name|loc
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|archdr
argument_list|,
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|mkfsym
argument_list|(
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
name|load2
argument_list|(
name|lp
operator|->
name|loc
operator|+
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|libp
operator|=
operator|++
name|lp
expr_stmt|;
block|}
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|load2
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|long
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SYMBOL
modifier|*
name|sp
decl_stmt|;
specifier|register
name|LOCAL
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|symno
decl_stmt|;
name|int
name|type
decl_stmt|;
name|readhdr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RFflag
condition|)
block|{
name|ctrel
operator|=
name|torigin
expr_stmt|;
name|cdrel
operator|+=
name|dorigin
expr_stmt|;
name|cbrel
operator|+=
name|borigin
expr_stmt|;
block|}
comment|/* 	 * Reread the symbol table, recording the numbering 	 * of symbols for fixing external references. 	 */
name|lp
operator|=
name|local
expr_stmt|;
name|symno
operator|=
operator|-
literal|1
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|symno
operator|++
expr_stmt|;
name|symget
argument_list|(
operator|&
name|cursym
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|symreloc
argument_list|()
expr_stmt|;
name|type
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|EXTERN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sflag
operator|&&
operator|!
name|xflag
operator|&&
operator|(
operator|!
name|Xflag
operator|||
name|cursym
operator|.
name|sname
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|||
name|type
operator|&
name|STABTYPS
operator|)
condition|)
name|symwrite
argument_list|(
operator|&
name|cursym
argument_list|,
literal|1
argument_list|,
name|sout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|RFflag
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|()
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"internal error: symbol not found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
if|if
condition|(
name|lp
operator|>=
name|local
operator|+
name|NSYMPR
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Local symbol overflow"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|locindex
operator|=
name|symno
expr_stmt|;
name|lp
operator|++
operator|->
name|locsymbol
operator|=
name|sp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cursym
operator|.
name|stype
operator|&
name|STABTYPS
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|stype
operator|!=
name|sp
operator|->
name|stype
operator|||
name|cursym
operator|.
name|svalue
operator|!=
name|sp
operator|->
name|svalue
condition|)
block|{
name|printf
argument_list|(
literal|"%.8s: "
argument_list|,
name|cursym
operator|.
name|sname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|"Multiply defined"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RFflag
condition|)
return|return;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
argument_list|,
name|filhdr
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|lp
argument_list|,
name|ctrel
argument_list|,
name|tout
argument_list|,
name|trout
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
argument_list|,
name|filhdr
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
argument_list|,
name|filhdr
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|lp
argument_list|,
name|cdrel
argument_list|,
name|dout
argument_list|,
name|drout
argument_list|)
expr_stmt|;
while|while
condition|(
name|filhdr
operator|.
name|a_data
operator|&
name|FW
condition|)
block|{
name|putc
argument_list|(
literal|0
argument_list|,
name|dout
argument_list|)
expr_stmt|;
name|filhdr
operator|.
name|a_data
operator|++
expr_stmt|;
block|}
name|torigin
operator|+=
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|dorigin
operator|+=
name|filhdr
operator|.
name|a_data
expr_stmt|;
name|borigin
operator|+=
name|filhdr
operator|.
name|a_bss
expr_stmt|;
name|cdorel
operator|+=
name|filhdr
operator|.
name|a_data
expr_stmt|;
name|cborel
operator|+=
name|filhdr
operator|.
name|a_bss
expr_stmt|;
block|}
end_block

begin_macro
name|load2td
argument_list|(
argument|lp
argument_list|,
argument|creloc
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|)
end_macro

begin_decl_stmt
name|LOCAL
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|creloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|b1
decl_stmt|,
modifier|*
name|b2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r1
expr_stmt|;
specifier|register
name|char
name|r2
decl_stmt|;
specifier|register
name|long
name|t
decl_stmt|;
specifier|register
name|SYMBOL
modifier|*
name|sp
decl_stmt|;
name|long
name|tw
decl_stmt|,
name|u
decl_stmt|,
name|l
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|reloc
operator|.
name|size
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|text
operator|.
name|size
condition|)
name|putc
argument_list|(
name|get
argument_list|(
operator|&
name|text
argument_list|)
argument_list|,
name|b1
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|getl
argument_list|(
operator|&
name|reloc
argument_list|)
expr_stmt|;
comment|/* position of relocatable stuff */
if|if
condition|(
name|rflag
condition|)
name|putl
argument_list|(
name|t
operator|+
name|creloc
argument_list|,
name|b2
argument_list|)
expr_stmt|;
comment|/* remember for subsequent link editing */
while|while
condition|(
name|text
operator|.
name|pos
operator|<
name|t
condition|)
name|putc
argument_list|(
name|get
argument_list|(
operator|&
name|text
argument_list|)
argument_list|,
name|b1
argument_list|)
expr_stmt|;
comment|/* advance to proper position */
name|r1
operator|=
name|get3
argument_list|(
operator|&
name|reloc
argument_list|)
expr_stmt|;
comment|/* kind of relocation */
name|r2
operator|=
name|getb
argument_list|(
operator|&
name|reloc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r2
operator|&
literal|06
condition|)
block|{
comment|/* read raw datum according to its length */
case|case
name|LEN1
case|:
name|tw
operator|=
name|get
argument_list|(
operator|&
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEN2
case|:
name|tw
operator|=
name|gets
argument_list|(
operator|&
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEN4
case|:
name|tw
operator|=
name|getl
argument_list|(
operator|&
name|text
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r2
operator|&
name|REXT
condition|)
block|{
name|sp
operator|=
name|lookloc
argument_list|(
name|lp
argument_list|,
name|r1
argument_list|)
expr_stmt|;
comment|/* find the symbol */
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
comment|/* still undefined */
name|r2
operator|=
operator|(
name|r2
operator|&
operator|(
name|REFMASK
operator|+
name|REXT
operator|+
name|ROFF
operator|)
operator|)
expr_stmt|;
name|r1
operator|=
name|nsym
operator|+
operator|(
name|sp
operator|-
name|symtab
operator|)
expr_stmt|;
comment|/* new reloc */
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|DATA
operator|&&
name|r2
operator|&
name|ROFF
condition|)
block|{
name|r1
operator|=
name|RDATAO
expr_stmt|;
name|r2
operator|&=
name|REFMASK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|BSS
operator|&&
name|r2
operator|&
name|ROFF
condition|)
block|{
name|r1
operator|=
name|RBSSO
expr_stmt|;
name|r2
operator|&=
name|REFMASK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|ABS
operator|&&
name|r2
operator|&
name|ROFF
condition|)
block|{
name|r1
operator|=
name|RABSO
expr_stmt|;
name|r2
operator|&=
name|REFMASK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|TEXT
operator|&&
name|r2
operator|&
name|ROFF
condition|)
block|{
name|r1
operator|=
name|RTEXTO
expr_stmt|;
name|r2
operator|&=
name|REFMASK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r2
operator|&
name|ROFF
condition|)
block|{
if|if
condition|(
name|rflag
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|"!-r; see JFR"
argument_list|)
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|tw
operator|+=
name|database
expr_stmt|;
name|r1
operator|=
name|sp
operator|->
name|stype
operator|&
name|TYPE
expr_stmt|;
name|r2
operator|&=
name|REFMASK
expr_stmt|;
block|}
name|tw
operator|+=
name|sp
operator|->
name|svalue
operator|-
name|database
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|r1
operator|&
name|TYMASK
condition|)
block|{
case|case
name|RTEXT
case|:
name|tw
operator|+=
name|ctrel
expr_stmt|;
break|break;
case|case
name|RTEXTO
case|:
name|tw
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_text
argument_list|,
name|PAGRND
argument_list|)
operator|+
name|ctrel
operator|-
name|database
expr_stmt|;
break|break;
case|case
name|RDATA
case|:
name|tw
operator|+=
name|cdrel
expr_stmt|;
break|break;
case|case
name|RDATAO
case|:
name|tw
operator|+=
name|cdorel
expr_stmt|;
break|break;
case|case
name|RBSS
case|:
name|tw
operator|+=
name|cbrel
expr_stmt|;
break|break;
case|case
name|RBSSO
case|:
name|tw
operator|+=
name|cborel
operator|-
name|filhdr
operator|.
name|a_data
expr_stmt|;
break|break;
case|case
name|RABSO
case|:
name|tw
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_text
argument_list|,
name|PAGRND
argument_list|)
operator|-
name|database
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rflag
condition|)
block|{
comment|/* remember for subsequent link editing */
name|put3
argument_list|(
name|r1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|putb
argument_list|(
name|r2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r2
operator|&
name|PCREL
condition|)
name|tw
operator|-=
name|creloc
expr_stmt|;
comment|/* assembler already subtracted text.pos */
switch|switch
condition|(
name|r2
operator|&
literal|06
condition|)
block|{
comment|/* output relocated datum according to its length */
case|case
name|LEN1
case|:
name|l
operator|=
operator|-
literal|128
expr_stmt|;
name|u
operator|=
literal|127
expr_stmt|;
name|putc
argument_list|(
operator|(
name|char
operator|)
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEN2
case|:
name|l
operator|=
operator|-
literal|32768
expr_stmt|;
name|u
operator|=
literal|32767
expr_stmt|;
name|puts
argument_list|(
operator|(
name|short
operator|)
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEN4
case|:
name|l
operator|=
literal|0x80000000
expr_stmt|;
name|u
operator|=
literal|0x7FFFFFFF
expr_stmt|;
name|putl
argument_list|(
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tw
operator|<
name|l
operator|||
name|u
operator|<
name|tw
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"Displacement overflow"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|finishout
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|nflag
condition|)
while|while
condition|(
name|tsize
operator|&
name|FW
condition|)
block|{
name|putc
argument_list|(
literal|0
argument_list|,
name|tout
argument_list|)
expr_stmt|;
name|tsize
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|dout
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|doutn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|fclose
argument_list|(
name|trout
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|troutn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|drout
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|droutn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xflag
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|sout
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|soutn
argument_list|)
expr_stmt|;
block|}
name|symwrite
argument_list|(
name|symtab
argument_list|,
name|nextsym
operator|-
name|symtab
argument_list|,
name|tout
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ofilfnd
condition|)
block|{
name|unlink
argument_list|(
literal|"a.out"
argument_list|)
expr_stmt|;
name|link
argument_list|(
literal|"l.out"
argument_list|,
literal|"a.out"
argument_list|)
expr_stmt|;
name|ofilename
operator|=
literal|"a.out"
expr_stmt|;
block|}
name|delarg
operator|=
name|errlev
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|copy
argument_list|(
argument|np
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|np
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"cannot recopy output"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|tout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mkfsym
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
return|return;
name|cp8c
argument_list|(
name|s
argument_list|,
name|cursym
operator|.
name|sname
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|stype
operator|=
name|TEXT
expr_stmt|;
name|cursym
operator|.
name|svalue
operator|=
name|torigin
expr_stmt|;
name|symwrite
argument_list|(
operator|&
name|cursym
argument_list|,
literal|1
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|mget
argument_list|(
name|loc
argument_list|,
name|n
argument_list|,
name|sp
argument_list|)
specifier|register
name|STREAM
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|nibuf
operator|-=
name|n
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|size
operator|-=
name|n
operator|)
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|sp
operator|->
name|ptr
expr_stmt|;
name|sp
operator|->
name|pos
operator|+=
name|n
expr_stmt|;
do|do
operator|*
name|loc
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|n
condition|)
do|;
name|sp
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return;
block|}
else|else
name|sp
operator|->
name|size
operator|+=
name|n
expr_stmt|;
block|}
name|sp
operator|->
name|nibuf
operator|+=
name|n
expr_stmt|;
do|do
block|{
operator|*
name|loc
operator|++
operator|=
name|get
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
end_block

begin_function
name|short
name|gets
parameter_list|(
name|sp
parameter_list|)
name|STREAM
modifier|*
name|sp
decl_stmt|;
block|{
name|short
name|t
decl_stmt|;
name|mget
argument_list|(
operator|&
name|t
argument_list|,
literal|2
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|char
name|getb
parameter_list|(
name|sp
parameter_list|)
name|STREAM
modifier|*
name|sp
decl_stmt|;
block|{
name|char
name|t
decl_stmt|;
name|mget
argument_list|(
operator|&
name|t
argument_list|,
literal|1
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|long
name|get3
parameter_list|(
name|sp
parameter_list|)
name|STREAM
modifier|*
name|sp
decl_stmt|;
block|{
name|long
name|t
decl_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
name|mget
argument_list|(
operator|&
name|t
argument_list|,
literal|3
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|long
name|getl
parameter_list|(
name|sp
parameter_list|)
name|STREAM
modifier|*
name|sp
decl_stmt|;
block|{
name|long
name|t
decl_stmt|;
name|mget
argument_list|(
operator|&
name|t
argument_list|,
literal|4
argument_list|,
name|sp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax
name|fixl
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_macro
name|symget
argument_list|(
argument|sp
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|SYMBOL
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STREAM
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mget
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax
name|fixl
argument_list|(
operator|&
name|sp
operator|->
name|svalue
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|dseek
argument_list|(
name|sp
argument_list|,
name|loc
argument_list|,
name|s
argument_list|)
specifier|register
name|STREAM
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|loc
decl_stmt|,
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PAGE
modifier|*
name|p
decl_stmt|;
specifier|register
name|b
operator|,
name|o
expr_stmt|;
name|int
name|n
decl_stmt|;
name|b
operator|=
name|loc
operator|>>
literal|9
expr_stmt|;
name|o
operator|=
name|loc
operator|&
literal|0777
expr_stmt|;
if|if
condition|(
name|o
operator|&
literal|01
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"loader error; odd offset"
argument_list|)
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
operator|&&
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|1
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
condition|)
if|if
condition|(
name|p
operator|->
name|nuser
operator|==
literal|0
operator|||
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|nuser
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|==
literal|0
operator|&&
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|==
literal|0
condition|)
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|<
name|page
index|[
literal|1
index|]
operator|.
name|bno
condition|)
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|lseek
argument_list|(
name|infil
argument_list|,
name|loc
operator|&
operator|~
literal|0777L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|infil
argument_list|,
name|p
operator|->
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|buff
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nibuf
operator|=
name|n
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"No pages"
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|s
operator|!=
operator|-
literal|1
condition|)
block|{
name|sp
operator|->
name|size
operator|=
name|s
expr_stmt|;
name|sp
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|->
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|buff
operator|+
name|o
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|nibuf
operator|=
name|p
operator|->
name|nibuf
operator|-
name|o
operator|)
operator|<=
literal|0
condition|)
name|sp
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|char
name|get
parameter_list|(
name|asp
parameter_list|)
name|STREAM
modifier|*
name|asp
decl_stmt|;
block|{
specifier|register
name|STREAM
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|asp
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|nibuf
operator|-=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dseek
argument_list|(
name|sp
argument_list|,
operator|(
call|(
name|long
call|)
argument_list|(
name|sp
operator|->
name|bno
operator|+
literal|1
argument_list|)
operator|<<
literal|9
operator|)
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|nibuf
operator|-=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|premeof
argument_list|)
expr_stmt|;
operator|++
name|fpage
operator|.
name|nuser
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
operator|(
name|PAGE
operator|*
operator|)
operator|&
name|fpage
expr_stmt|;
block|}
name|sp
operator|->
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|sp
operator|->
name|ptr
operator|++
operator|)
return|;
block|}
end_function

begin_macro
name|getfile
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|STRING
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|arcmag
decl_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
name|infil
operator|=
operator|-
literal|1
expr_stmt|;
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|filname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|cp
operator|=
literal|"-la"
expr_stmt|;
name|filname
operator|=
literal|"/usr/lib/libxxxxxxxxxxxxxxx"
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|cp
index|[
name|c
operator|+
literal|2
index|]
condition|;
name|c
operator|++
control|)
name|filname
index|[
name|c
operator|+
literal|12
index|]
operator|=
name|cp
index|[
name|c
operator|+
literal|2
index|]
expr_stmt|;
name|filname
index|[
name|c
operator|+
literal|12
index|]
operator|=
literal|'.'
expr_stmt|;
name|filname
index|[
name|c
operator|+
literal|13
index|]
operator|=
literal|'a'
expr_stmt|;
name|filname
index|[
name|c
operator|+
literal|14
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|infil
operator|=
name|open
argument_list|(
name|filname
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|filname
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|infil
operator|==
operator|-
literal|1
operator|&&
operator|(
name|infil
operator|=
name|open
argument_list|(
name|filname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"cannot open"
argument_list|)
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|bno
operator|=
operator|-
literal|1
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|=
literal|0
expr_stmt|;
name|text
operator|.
name|pno
operator|=
name|reloc
operator|.
name|pno
operator|=
operator|(
name|PAGE
operator|*
operator|)
operator|&
name|fpage
expr_stmt|;
name|fpage
operator|.
name|nuser
operator|=
literal|2
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
literal|0L
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|premeof
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|&
name|arcmag
argument_list|,
sizeof|sizeof
argument_list|(
name|arcmag
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
return|return
operator|(
name|arcmag
operator|==
name|ARMAG
operator|)
return|;
block|}
end_block

begin_function
name|SYMBOL
modifier|*
modifier|*
name|lookup
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|BOOL
name|clash
decl_stmt|;
specifier|register
name|SYMBOL
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursym
operator|.
name|sname
init|;
name|cp
operator|<
operator|&
name|cursym
operator|.
name|sname
index|[
literal|8
index|]
condition|;
control|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|&
name|hshtab
index|[
operator|(
name|i
operator|&
literal|077777
operator|)
operator|%
name|NSYM
operator|+
literal|2
index|]
init|;
operator|*
name|hp
operator|!=
literal|0
condition|;
control|)
block|{
name|cp1
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|sname
expr_stmt|;
name|clash
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursym
operator|.
name|sname
init|;
name|cp
operator|<
operator|&
name|cursym
operator|.
name|sname
index|[
literal|8
index|]
condition|;
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
operator|*
name|cp1
operator|++
condition|)
block|{
name|clash
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|clash
condition|)
block|{
if|if
condition|(
operator|++
name|hp
operator|>=
operator|&
name|hshtab
index|[
name|NSYM
operator|+
literal|2
index|]
condition|)
name|hp
operator|=
name|hshtab
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|hp
operator|)
return|;
block|}
end_function

begin_function
name|SYMBOL
modifier|*
modifier|*
name|slookup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|cp8c
argument_list|(
name|s
argument_list|,
name|cursym
operator|.
name|sname
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|stype
operator|=
name|EXTERN
operator|+
name|UNDEF
expr_stmt|;
name|cursym
operator|.
name|svalue
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|lookup
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|enter
argument_list|(
name|hp
argument_list|)
specifier|register
name|SYMBOL
operator|*
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|SYMBOL
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|*
name|hp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nextsym
operator|-
name|symtab
operator|)
operator|>=
name|NSYM
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Symbol table overflow"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nextsym
operator|-
name|symtab
operator|)
operator|>=
name|nsym
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|sbrk
argument_list|(
name|NSYM
operator|/
literal|5
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|symtab
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Memory overflow"
argument_list|)
expr_stmt|;
name|nsym
operator|+=
name|NSYM
operator|/
literal|5
expr_stmt|;
block|}
operator|*
name|hp
operator|=
name|lastsym
operator|=
name|sp
operator|=
name|nextsym
operator|++
expr_stmt|;
name|cp8c
argument_list|(
name|cursym
operator|.
name|sname
argument_list|,
name|sp
operator|->
name|sname
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
name|sp
operator|->
name|symhash
operator|=
name|hp
operator|-
name|hshtab
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|cursym
operator|.
name|svalue
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|lastsym
operator|=
operator|*
name|hp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|symreloc
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|RFflag
condition|)
return|return;
switch|switch
condition|(
name|cursym
operator|.
name|stype
operator|&
literal|017
condition|)
block|{
case|case
name|TEXT
case|:
case|case
name|EXTERN
operator|+
name|TEXT
case|:
name|cursym
operator|.
name|svalue
operator|+=
name|ctrel
expr_stmt|;
return|return;
case|case
name|DATA
case|:
case|case
name|EXTERN
operator|+
name|DATA
case|:
name|cursym
operator|.
name|svalue
operator|+=
name|cdrel
expr_stmt|;
return|return;
case|case
name|BSS
case|:
case|case
name|EXTERN
operator|+
name|BSS
case|:
name|cursym
operator|.
name|svalue
operator|+=
name|cbrel
expr_stmt|;
return|return;
case|case
name|EXTERN
operator|+
name|UNDEF
case|:
return|return;
block|}
if|if
condition|(
name|cursym
operator|.
name|stype
operator|&
name|EXTERN
condition|)
name|cursym
operator|.
name|stype
operator|=
name|EXTERN
operator|+
name|ABS
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|errlev
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ld:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filname
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
if|if
condition|(
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"(%.14s)"
argument_list|,
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|delexit
argument_list|()
expr_stmt|;
name|errlev
operator|=
literal|2
expr_stmt|;
block|}
end_block

begin_function
name|SYMBOL
modifier|*
name|lookloc
parameter_list|(
name|lp
parameter_list|,
name|r
parameter_list|)
specifier|register
name|LOCAL
modifier|*
name|lp
decl_stmt|;
block|{
specifier|register
name|LOCAL
modifier|*
name|clp
decl_stmt|;
specifier|register
name|sn
expr_stmt|;
name|sn
operator|=
name|r
expr_stmt|;
for|for
control|(
name|clp
operator|=
name|local
init|;
name|clp
operator|<
name|lp
condition|;
name|clp
operator|++
control|)
if|if
condition|(
name|clp
operator|->
name|locindex
operator|==
name|sn
condition|)
return|return
operator|(
name|clp
operator|->
name|locsymbol
operator|)
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"Local symbol botch"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|readhdr
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|long
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax
for|for
control|(
name|p
operator|=
operator|&
name|filhdr
operator|,
name|i
operator|=
literal|8
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|fixl
argument_list|(
name|p
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|filhdr
operator|.
name|a_magic
operator|!=
name|A_MAGIC1
operator|&&
name|filhdr
operator|.
name|a_magic
operator|!=
name|A_MAGIC2
operator|&&
name|filhdr
operator|.
name|a_magic
operator|!=
name|A_MAGIC3
operator|&&
name|filhdr
operator|.
name|a_magic
operator|!=
name|A_MAGIC4
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Bad magic number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filhdr
operator|.
name|a_text
operator|&
literal|01
operator|||
name|filhdr
operator|.
name|a_data
operator|&
literal|01
condition|)
block|{
name|printf
argument_list|(
literal|"tsize=%X  dsize=%X\n"
argument_list|,
name|filhdr
operator|.
name|a_text
argument_list|,
name|filhdr
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"Text/data size odd"
argument_list|)
expr_stmt|;
block|}
name|filhdr
operator|.
name|a_bss
operator|=
name|round
argument_list|(
name|filhdr
operator|.
name|a_bss
argument_list|,
name|FW
argument_list|)
expr_stmt|;
if|if
condition|(
name|filhdr
operator|.
name|a_magic
operator|==
name|NMAGIC
condition|)
block|{
name|cdrel
operator|=
operator|-
name|round
argument_list|(
name|filhdr
operator|.
name|a_text
argument_list|,
name|PAGRND
argument_list|)
expr_stmt|;
name|cbrel
operator|=
name|cdrel
operator|-
name|filhdr
operator|.
name|a_data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filhdr
operator|.
name|a_magic
operator|==
name|OMAGIC
condition|)
block|{
name|cdrel
operator|=
operator|-
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|cbrel
operator|=
name|cdrel
operator|-
name|filhdr
operator|.
name|a_data
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"Bad format"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cp8c
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|te
decl_stmt|;
name|f
operator|=
name|from
expr_stmt|;
name|t
operator|=
name|to
expr_stmt|;
name|te
operator|=
name|t
operator|+
literal|8
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
operator|)
operator|&&
name|t
operator|<
name|te
condition|)
empty_stmt|;
while|while
condition|(
name|t
operator|<
name|te
condition|)
operator|*
name|t
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|eq
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|s1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
operator|(
operator|*
name|s1
operator|++
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_function
name|long
name|round
parameter_list|(
name|v
parameter_list|,
name|r
parameter_list|)
name|long
name|v
decl_stmt|;
name|unsigned
name|r
decl_stmt|;
block|{
name|v
operator|+=
name|r
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|long
operator|)
name|r
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_macro
name|puts
argument_list|(
argument|w
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fwrite
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putb
argument_list|(
argument|w
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fwrite
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|put3
argument_list|(
argument|w
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fwrite
argument_list|(
operator|&
name|w
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putl
argument_list|(
argument|w
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|vax
name|fixl
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fwrite
argument_list|(
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fundament
argument_list|(
argument|name
argument_list|)
name|STRING
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|RFflag
operator|=
name|TRUE
expr_stmt|;
name|load1arg
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|trsize
operator|=
name|drsize
operator|=
name|tsize
operator|=
name|dsize
operator|=
name|bsize
operator|=
name|ctrel
operator|=
name|cdrel
operator|=
name|cbrel
operator|=
literal|0
expr_stmt|;
name|RFflag
operator|=
name|FALSE
expr_stmt|;
name|addsym
operator|=
name|nextsym
expr_stmt|;
block|}
end_block

begin_macro
name|fund2
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|RFflag
operator|=
name|TRUE
expr_stmt|;
name|load2arg
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|RFflag
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

end_unit

