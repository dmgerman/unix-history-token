begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  *  *	UNIX debugger  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|setup
operator|.
name|c
literal|2.5
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MSG
name|BADNAM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|BADMAG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|txtmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|datmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYMSLAVE
modifier|*
name|symvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|wtflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|fcor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|fsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|maxfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|maxstor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|txtsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|datsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|datbas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|stksiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|errflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|magic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|symbas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|symnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|entrypt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|argcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|signo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|user
name|u
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|symfil
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|corfil
init|=
literal|"core"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TXTHDRSIZ
value|(sizeof(txthdr))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|EDDT
end_ifndef

begin_macro
name|readl
argument_list|(
argument|f
argument_list|,
argument|p
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|vax
name|int
name|t
init|=
literal|0
decl_stmt|;
do|do
block|{
name|t
operator|+=
name|read
argument_list|(
name|f
argument_list|,
operator|&
operator|(
name|p
operator|->
name|loword
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|t
operator|+=
name|read
argument_list|(
name|f
argument_list|,
operator|&
operator|(
name|p
operator|->
name|hiword
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
return|return
operator|(
name|t
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|setsym
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|EDDT
name|INT
name|relflg
decl_stmt|;
name|INT
name|symval
decl_stmt|,
name|symflg
decl_stmt|;
name|SYMSLAVE
modifier|*
name|symptr
decl_stmt|;
name|SYMPTR
name|symp
decl_stmt|;
name|TXTHDR
name|txthdr
decl_stmt|;
name|fsym
operator|=
name|getfile
argument_list|(
name|symfil
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|txtmap
operator|.
name|ufd
operator|=
name|fsym
expr_stmt|;
name|IF
name|readl
argument_list|(
name|fsym
argument_list|,
name|txthdr
argument_list|,
name|TXTHDRSIZ
operator|/
sizeof|sizeof
argument_list|(
name|txthdr
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl|==
name|TXTHDRSIZ
name|THEN
name|magic
init|=
name|txthdr
index|[
literal|0
index|]
decl_stmt|;
name|IF
name|magic
operator|!=
literal|0410
name|ANDF
name|magic
operator|!=
literal|0407
name|ANDF
name|magic
operator|!=
literal|0412
name|ANDF
name|magic
operator|!=
literal|0413
name|THEN
name|magic
operator|=
literal|0
expr_stmt|;
name|ELSE
name|symnum
init|=
name|txthdr
index|[
literal|4
index|]
operator|/
name|SYMTABSIZ
decl_stmt|;
name|txtsiz
operator|=
name|txthdr
index|[
literal|1
index|]
expr_stmt|;
name|datsiz
operator|=
name|txthdr
index|[
literal|2
index|]
expr_stmt|;
name|symbas
operator|=
name|txtsiz
operator|+
name|datsiz
expr_stmt|;
name|txtmap
operator|.
name|f1
operator|=
name|txtmap
operator|.
name|f2
operator|=
name|TXTHDRSIZ
expr_stmt|;
switch|switch
condition|(
name|magic
condition|)
block|{
case|case
literal|0412
case|:
name|txtmap
operator|.
name|f1
operator|=
name|txtmap
operator|.
name|f2
operator|=
operator|(
name|CLSIZE
operator|*
name|NBPG
operator|)
expr_stmt|;
case|case
literal|0407
case|:
name|txtmap
operator|.
name|b1
operator|=
literal|0
expr_stmt|;
name|txtmap
operator|.
name|e1
operator|=
name|symbas
expr_stmt|;
name|txtmap
operator|.
name|b2
operator|=
name|datbas
operator|=
literal|0
expr_stmt|;
name|txtmap
operator|.
name|e2
operator|=
name|symbas
expr_stmt|;
break|break;
case|case
literal|0413
case|:
name|txtmap
operator|.
name|f1
operator|=
name|txtmap
operator|.
name|f2
operator|=
operator|(
name|CLSIZE
operator|*
name|NBPG
operator|)
expr_stmt|;
case|case
literal|0410
case|:
name|txtmap
operator|.
name|b1
operator|=
literal|0
expr_stmt|;
name|txtmap
operator|.
name|e1
operator|=
name|txtsiz
expr_stmt|;
name|txtmap
operator|.
name|b2
operator|=
name|datbas
operator|=
name|round
argument_list|(
name|txtsiz
argument_list|,
name|TXTRNDSIZ
argument_list|)
expr_stmt|;
name|txtmap
operator|.
name|e2
operator|=
name|datbas
operator|+
name|datsiz
expr_stmt|;
name|txtmap
operator|.
name|f2
operator|+=
name|txtmap
operator|.
name|e1
expr_stmt|;
block|}
name|entrypt
operator|=
name|txthdr
index|[
literal|5
index|]
expr_stmt|;
name|symbas
operator|+=
name|txthdr
index|[
literal|6
index|]
operator|+
name|txthdr
index|[
literal|7
index|]
expr_stmt|;
name|symbas
operator|+=
name|magic
operator|==
literal|0412
operator|||
name|magic
operator|==
literal|0413
condition|?
operator|(
name|CLSIZE
operator|*
name|NBPG
operator|)
else|:
name|TXTHDRSIZ
expr_stmt|;
comment|/* set up symvec */
name|symvec
operator|=
name|sbrk
argument_list|(
name|shorten
argument_list|(
operator|(
literal|1
operator|+
name|symnum
operator|)
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|SYMSLAVE
argument_list|)
argument_list|)
expr_stmt|;
name|IF
argument_list|(
name|symptr
operator|=
name|symvec
argument_list|)
operator|==
operator|-
literal|1
name|THEN
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|BADNAM
argument_list|)
expr_stmt|;
name|symptr
operator|=
name|symvec
operator|=
name|sbrk
argument_list|(
sizeof|sizeof
argument_list|(
name|SYMSLAVE
argument_list|)
argument_list|)
expr_stmt|;
name|ELSE
name|symset
parameter_list|()
function_decl|;
name|WHILE
argument_list|(
argument|symp=symget()
argument_list|)
name|ANDF
name|errflg
operator|==
literal|0
name|DO
name|symflg
operator|=
name|symp
operator|->
name|symf
expr_stmt|;
name|symptr
operator|->
name|valslave
operator|=
name|symp
operator|->
name|symv
expr_stmt|;
name|symptr
operator|->
name|typslave
operator|=
name|SYMTYPE
argument_list|(
name|symflg
argument_list|)
expr_stmt|;
define|#
directive|define
name|STABTYPES
value|0340
comment|/* from<a.out.h> */
name|IF
argument_list|(
name|symflg
operator|&
name|STABTYPES
argument_list|)
operator|!=
literal|0
name|THEN
name|symptr
operator|->
name|typslave
operator|=
name|XSYM
expr_stmt|;
name|FI
name|symptr
operator|++
expr_stmt|;
name|OD
name|FI
name|symptr
operator|->
name|typslave
init|=
name|ESYM
decl_stmt|;
name|FI
name|FI
name|IF
name|magic
operator|==
literal|0
name|THEN
name|txtmap
operator|.
name|e1
operator|=
name|maxfile
expr_stmt|;
name|FI
endif|#
directive|endif
block|}
end_block

begin_macro
name|setcor
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|EDDT
name|fcor
operator|=
name|getfile
argument_list|(
name|corfil
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|datmap
operator|.
name|ufd
operator|=
name|fcor
expr_stmt|;
name|IF
name|read
argument_list|(
name|fcor
argument_list|,
operator|&
name|u
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|)
decl|==
name|ctob
argument_list|(
name|UPAGES
argument_list|)
name|ANDF
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_ksp
operator|&
literal|0xF0000000L
argument_list|)
decl|==0x80000000L
name|ANDF
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_usp
operator|&
literal|0xF0000000L
argument_list|)
decl|==0x70000000L
name|THEN
name|signo
init|=
name|u
operator|.
name|u_arg
index|[
literal|0
index|]
operator|&
literal|017
decl_stmt|;
name|txtsiz
operator|=
name|ctob
argument_list|(
name|u
operator|.
name|u_tsize
argument_list|)
expr_stmt|;
name|datsiz
operator|=
name|ctob
argument_list|(
name|u
operator|.
name|u_dsize
argument_list|)
expr_stmt|;
name|stksiz
operator|=
name|ctob
argument_list|(
name|u
operator|.
name|u_ssize
argument_list|)
expr_stmt|;
name|datmap
operator|.
name|b1
operator|=
name|datbas
operator|=
operator|(
name|magic
operator|==
literal|0410
condition|?
name|round
argument_list|(
name|txtsiz
argument_list|,
name|TXTRNDSIZ
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|magic
operator|==
literal|0413
condition|)
name|datmap
operator|.
name|b1
operator|=
name|datbas
operator|=
name|txtsiz
expr_stmt|;
name|datmap
operator|.
name|e1
operator|=
operator|(
name|magic
operator|==
literal|0407
condition|?
name|txtsiz
else|:
name|datmap
operator|.
name|b1
operator|)
operator|+
name|datsiz
expr_stmt|;
name|datmap
operator|.
name|f1
operator|=
name|ctob
argument_list|(
name|UPAGES
argument_list|)
expr_stmt|;
name|datmap
operator|.
name|b2
operator|=
name|maxstor
operator|-
name|stksiz
expr_stmt|;
name|datmap
operator|.
name|e2
operator|=
name|maxstor
expr_stmt|;
name|datmap
operator|.
name|f2
operator|=
name|ctob
argument_list|(
name|UPAGES
argument_list|)
operator|+
operator|(
operator|(
name|magic
operator|==
literal|0410
operator|||
name|magic
operator|==
literal|0413
operator|)
condition|?
name|datsiz
else|:
name|datmap
operator|.
name|e1
operator|)
expr_stmt|;
name|signo
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|ctob
argument_list|(
name|UPAGES
argument_list|)
operator|-
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
name|IF
name|magic
name|ANDF
name|magic
operator|!=
name|u
operator|.
name|u_exdata
operator|.
name|ux_mag
name|THEN
name|printf
argument_list|(
literal|"%s , object = %o, core = %o\n"
argument_list|,
name|BADMAG
argument_list|,
name|magic
argument_list|,
name|u
operator|.
name|u_exdata
operator|.
name|ux_mag
argument_list|)
expr_stmt|;
name|FI
name|ELSE
name|datmap
operator|.
name|e1
init|=
name|maxfile
decl_stmt|;
name|FI
endif|#
directive|endif
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|EDDT
end_ifndef

begin_macro
name|create
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|IF
argument_list|(
name|fd
operator|=
name|creat
argument_list|(
name|f
argument_list|,
literal|0644
argument_list|)
argument_list|)
operator|>=
literal|0
name|THEN
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|open
argument_list|(
name|f
argument_list|,
name|wtflag
argument_list|)
operator|)
return|;
name|ELSE
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|FI
block|}
end_block

begin_macro
name|getfile
argument_list|(
argument|filnam
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|filnam
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|INT
name|fsym
decl_stmt|;
name|IF
operator|!
name|eqstr
argument_list|(
literal|"-"
argument_list|,
argument|filnam
argument_list|)
name|THEN
name|fsym
operator|=
name|open
argument_list|(
name|filnam
argument_list|,
name|wtflag
argument_list|)
expr_stmt|;
name|IF
name|fsym
operator|<
literal|0
name|ANDF
name|argcount
operator|>
name|cnt
name|THEN
name|IF
name|wtflag
name|THEN
name|fsym
operator|=
name|create
argument_list|(
name|filnam
argument_list|)
expr_stmt|;
name|FI
name|IF
name|fsym
operator|<
literal|0
name|THEN
name|printf
argument_list|(
literal|"cannot open `%s'\n"
argument_list|,
name|filnam
argument_list|)
expr_stmt|;
name|FI
name|FI
name|ELSE
name|fsym
init|=
operator|-
literal|1
decl_stmt|;
name|FI
return|return
operator|(
name|fsym
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

