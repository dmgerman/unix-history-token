begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"mfile1"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* temporarily */
end_comment

begin_comment
comment|/* lexical actions */
end_comment

begin_define
define|#
directive|define
name|A_ERR
value|0
end_define

begin_comment
comment|/* illegal character */
end_comment

begin_define
define|#
directive|define
name|A_LET
value|1
end_define

begin_comment
comment|/* saw a letter */
end_comment

begin_define
define|#
directive|define
name|A_DIG
value|2
end_define

begin_comment
comment|/* saw a digit */
end_comment

begin_define
define|#
directive|define
name|A_1C
value|3
end_define

begin_comment
comment|/* return a single character */
end_comment

begin_define
define|#
directive|define
name|A_STR
value|4
end_define

begin_comment
comment|/* string */
end_comment

begin_define
define|#
directive|define
name|A_CC
value|5
end_define

begin_comment
comment|/* character constant */
end_comment

begin_define
define|#
directive|define
name|A_BCD
value|6
end_define

begin_comment
comment|/* GCOS BCD constant */
end_comment

begin_define
define|#
directive|define
name|A_SL
value|7
end_define

begin_comment
comment|/* saw a / */
end_comment

begin_define
define|#
directive|define
name|A_DOT
value|8
end_define

begin_comment
comment|/* saw a . */
end_comment

begin_define
define|#
directive|define
name|A_PL
value|9
end_define

begin_comment
comment|/* + */
end_comment

begin_define
define|#
directive|define
name|A_MI
value|10
end_define

begin_comment
comment|/* - */
end_comment

begin_define
define|#
directive|define
name|A_EQ
value|11
end_define

begin_comment
comment|/* = */
end_comment

begin_define
define|#
directive|define
name|A_NOT
value|12
end_define

begin_comment
comment|/* ! */
end_comment

begin_define
define|#
directive|define
name|A_LT
value|13
end_define

begin_comment
comment|/*< */
end_comment

begin_define
define|#
directive|define
name|A_GT
value|14
end_define

begin_comment
comment|/*> */
end_comment

begin_define
define|#
directive|define
name|A_AND
value|16
end_define

begin_comment
comment|/*& */
end_comment

begin_define
define|#
directive|define
name|A_OR
value|17
end_define

begin_comment
comment|/* | */
end_comment

begin_define
define|#
directive|define
name|A_WS
value|18
end_define

begin_comment
comment|/* whitespace (not \n) */
end_comment

begin_define
define|#
directive|define
name|A_NL
value|19
end_define

begin_comment
comment|/* \n */
end_comment

begin_comment
comment|/* character classes */
end_comment

begin_define
define|#
directive|define
name|LEXLET
value|01
end_define

begin_define
define|#
directive|define
name|LEXDIG
value|02
end_define

begin_define
define|#
directive|define
name|LEXOCT
value|04
end_define

begin_define
define|#
directive|define
name|LEXHEX
value|010
end_define

begin_define
define|#
directive|define
name|LEXWS
value|020
end_define

begin_define
define|#
directive|define
name|LEXDOT
value|040
end_define

begin_comment
comment|/* reserved word actions */
end_comment

begin_define
define|#
directive|define
name|AR_TY
value|0
end_define

begin_comment
comment|/* type word */
end_comment

begin_define
define|#
directive|define
name|AR_RW
value|1
end_define

begin_comment
comment|/* simple reserved word */
end_comment

begin_define
define|#
directive|define
name|AR_CL
value|2
end_define

begin_comment
comment|/* storage class word */
end_comment

begin_define
define|#
directive|define
name|AR_S
value|3
end_define

begin_comment
comment|/* struct */
end_comment

begin_define
define|#
directive|define
name|AR_U
value|4
end_define

begin_comment
comment|/* union */
end_comment

begin_define
define|#
directive|define
name|AR_E
value|5
end_define

begin_comment
comment|/* enum */
end_comment

begin_define
define|#
directive|define
name|AR_A
value|6
end_define

begin_comment
comment|/* asm */
end_comment

begin_comment
comment|/* text buffer */
end_comment

begin_define
define|#
directive|define
name|LXTSZ
value|100
end_define

begin_decl_stmt
name|char
name|yytext
index|[
name|LXTSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lxgcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|proflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gdebug
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|LINT
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|lastloc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|mainp1
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* control multiple files */
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|extern
name|int
name|idebug
decl_stmt|,
name|bdebug
decl_stmt|,
name|tdebug
decl_stmt|,
name|edebug
decl_stmt|,
name|ddebug
decl_stmt|,
name|xdebug
decl_stmt|,
name|gdebug
decl_stmt|;
name|int
name|fdef
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
operator|)
operator|==
literal|'-'
operator|&&
operator|*
operator|++
name|cp
operator|==
literal|'X'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'d'
case|:
operator|++
name|ddebug
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
operator|++
name|idebug
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|++
name|bdebug
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|++
name|tdebug
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
operator|++
name|edebug
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
operator|++
name|xdebug
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* profiling */
operator|++
name|proflg
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
operator|++
name|gdebug
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|)
operator|!=
literal|'-'
condition|)
switch|switch
condition|(
name|fdef
operator|++
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
if|if
condition|(
name|freopen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|fdef
operator|==
literal|1
condition|?
literal|"r"
else|:
literal|"w"
argument_list|,
name|fdef
operator|==
literal|1
condition|?
name|stdin
else|:
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ccom:can't open %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|ONEPASS
name|p2init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMTSZ
condition|;
operator|++
name|i
control|)
name|stab
index|[
name|i
index|]
operator|.
name|stype
operator|=
name|TNULL
expr_stmt|;
name|lxinit
argument_list|()
expr_stmt|;
name|tinit
argument_list|()
expr_stmt|;
name|mkdope
argument_list|()
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
comment|/* dimension table initialization */
name|dimtab
index|[
name|NULL
index|]
operator|=
literal|0
expr_stmt|;
name|dimtab
index|[
name|CHAR
index|]
operator|=
name|SZCHAR
expr_stmt|;
name|dimtab
index|[
name|INT
index|]
operator|=
name|SZINT
expr_stmt|;
name|dimtab
index|[
name|FLOAT
index|]
operator|=
name|SZFLOAT
expr_stmt|;
name|dimtab
index|[
name|DOUBLE
index|]
operator|=
name|SZDOUBLE
expr_stmt|;
name|dimtab
index|[
name|LONG
index|]
operator|=
name|SZLONG
expr_stmt|;
name|dimtab
index|[
name|SHORT
index|]
operator|=
name|SZSHORT
expr_stmt|;
name|dimtab
index|[
name|UCHAR
index|]
operator|=
name|SZCHAR
expr_stmt|;
name|dimtab
index|[
name|USHORT
index|]
operator|=
name|SZSHORT
expr_stmt|;
name|dimtab
index|[
name|UNSIGNED
index|]
operator|=
name|SZINT
expr_stmt|;
name|dimtab
index|[
name|ULONG
index|]
operator|=
name|SZLONG
expr_stmt|;
comment|/* starts past any of the above */
name|curdim
operator|=
literal|16
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|yyaccpt
argument_list|()
expr_stmt|;
name|ejobcode
argument_list|(
name|nerrors
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerrors
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|ibm
end_ifdef

begin_define
define|#
directive|define
name|CSMASK
value|0377
end_define

begin_define
define|#
directive|define
name|CSSZ
value|256
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CSMASK
value|0177
end_define

begin_define
define|#
directive|define
name|CSSZ
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|short
name|lxmask
index|[
name|CSSZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|lxenter
argument_list|(
name|s
argument_list|,
name|m
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* enter a mask into lxmask */
specifier|register
name|c
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
name|lxmask
index|[
name|c
operator|+
literal|1
index|]
operator||=
name|m
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|lxget
parameter_list|(
name|c
parameter_list|,
name|m
parameter_list|)
value|(lxgcp=yytext,lxmore(c,m))
end_define

begin_expr_stmt
name|lxmore
argument_list|(
name|c
argument_list|,
name|m
argument_list|)
specifier|register
name|c
operator|,
name|m
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
operator|*
operator|(
name|cp
operator|=
name|lxgcp
operator|)
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|getchar
argument_list|()
operator|,
name|lxmask
index|[
name|c
operator|+
literal|1
index|]
operator|&
name|m
condition|)
block|{
if|if
condition|(
name|cp
operator|<
operator|&
name|yytext
index|[
name|LXTSZ
operator|-
literal|1
index|]
condition|)
block|{
operator|*
operator|++
name|cp
operator|=
name|c
expr_stmt|;
block|}
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
operator|*
operator|(
name|lxgcp
operator|=
name|cp
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|lxdope
block|{
name|short
name|lxch
decl_stmt|;
comment|/* the character */
name|short
name|lxact
decl_stmt|;
comment|/* the action to be performed */
name|short
name|lxtok
decl_stmt|;
comment|/* the token number to be returned */
name|short
name|lxval
decl_stmt|;
comment|/* the value to be returned */
block|}
name|lxdope
index|[]
init|=
block|{
literal|'$'
block|,
name|A_ERR
block|,
literal|0
block|,
literal|0
block|,
comment|/* illegal characters go here... */
literal|'_'
block|,
name|A_LET
block|,
literal|0
block|,
literal|0
block|,
comment|/* letters point here */
literal|'0'
block|,
name|A_DIG
block|,
literal|0
block|,
literal|0
block|,
comment|/* digits point here */
literal|' '
block|,
name|A_WS
block|,
literal|0
block|,
literal|0
block|,
comment|/* whitespace goes here */
literal|'\n'
block|,
name|A_NL
block|,
literal|0
block|,
literal|0
block|,
literal|'"'
block|,
name|A_STR
block|,
literal|0
block|,
literal|0
block|,
comment|/* character string */
literal|'\''
block|,
name|A_CC
block|,
literal|0
block|,
literal|0
block|,
comment|/* character constant */
literal|'`'
block|,
name|A_BCD
block|,
literal|0
block|,
literal|0
block|,
comment|/* GCOS BCD constant */
literal|'('
block|,
name|A_1C
block|,
name|LP
block|,
literal|0
block|,
literal|')'
block|,
name|A_1C
block|,
name|RP
block|,
literal|0
block|,
literal|'{'
block|,
name|A_1C
block|,
name|LC
block|,
literal|0
block|,
literal|'}'
block|,
name|A_1C
block|,
name|RC
block|,
literal|0
block|,
literal|'['
block|,
name|A_1C
block|,
name|LB
block|,
literal|0
block|,
literal|']'
block|,
name|A_1C
block|,
name|RB
block|,
literal|0
block|,
literal|'*'
block|,
name|A_1C
block|,
name|MUL
block|,
name|MUL
block|,
literal|'?'
block|,
name|A_1C
block|,
name|QUEST
block|,
literal|0
block|,
literal|':'
block|,
name|A_1C
block|,
name|COLON
block|,
literal|0
block|,
literal|'+'
block|,
name|A_PL
block|,
name|PLUS
block|,
name|PLUS
block|,
literal|'-'
block|,
name|A_MI
block|,
name|MINUS
block|,
name|MINUS
block|,
literal|'/'
block|,
name|A_SL
block|,
name|DIVOP
block|,
name|DIV
block|,
literal|'%'
block|,
name|A_1C
block|,
name|DIVOP
block|,
name|MOD
block|,
literal|'&'
block|,
name|A_AND
block|,
name|AND
block|,
name|AND
block|,
literal|'|'
block|,
name|A_OR
block|,
name|OR
block|,
name|OR
block|,
literal|'^'
block|,
name|A_1C
block|,
name|ER
block|,
name|ER
block|,
literal|'!'
block|,
name|A_NOT
block|,
name|UNOP
block|,
name|NOT
block|,
literal|'~'
block|,
name|A_1C
block|,
name|UNOP
block|,
name|COMPL
block|,
literal|','
block|,
name|A_1C
block|,
name|CM
block|,
name|CM
block|,
literal|';'
block|,
name|A_1C
block|,
name|SM
block|,
literal|0
block|,
literal|'.'
block|,
name|A_DOT
block|,
name|STROP
block|,
name|DOT
block|,
literal|'<'
block|,
name|A_LT
block|,
name|RELOP
block|,
name|LT
block|,
literal|'>'
block|,
name|A_GT
block|,
name|RELOP
block|,
name|GT
block|,
literal|'='
block|,
name|A_EQ
block|,
name|ASSIGN
block|,
name|ASSIGN
block|,
operator|-
literal|1
block|,
name|A_1C
block|,
literal|0
block|,
literal|0
block|, 	}
struct|;
end_struct

begin_decl_stmt
name|struct
name|lxdope
modifier|*
name|lxcp
index|[
name|CSSZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|lxinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|lxdope
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* set up character classes */
name|lxenter
argument_list|(
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
argument_list|,
name|LEXLET
argument_list|)
expr_stmt|;
name|lxenter
argument_list|(
literal|"0123456789"
argument_list|,
name|LEXDIG
argument_list|)
expr_stmt|;
name|lxenter
argument_list|(
literal|"0123456789abcdefABCDEF"
argument_list|,
name|LEXHEX
argument_list|)
expr_stmt|;
name|lxenter
argument_list|(
literal|" \t\r\b\f"
argument_list|,
name|LEXWS
argument_list|)
expr_stmt|;
name|lxenter
argument_list|(
literal|"01234567"
argument_list|,
name|LEXOCT
argument_list|)
expr_stmt|;
name|lxmask
index|[
literal|'.'
operator|+
literal|1
index|]
operator||=
name|LEXDOT
expr_stmt|;
comment|/* make lxcp point to appropriate lxdope entry for each character */
comment|/* initialize error entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|CSSZ
condition|;
operator|++
name|i
control|)
name|lxcp
index|[
name|i
index|]
operator|=
name|lxdope
expr_stmt|;
comment|/* make unique entries */
for|for
control|(
name|p
operator|=
name|lxdope
init|;
condition|;
operator|++
name|p
control|)
block|{
name|lxcp
index|[
name|p
operator|->
name|lxch
operator|+
literal|1
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lxch
operator|<
literal|0
condition|)
break|break;
block|}
comment|/* handle letters, digits, and whitespace */
comment|/* by convention, first, second, and third places */
name|cp
operator|=
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|lxcp
index|[
operator|*
name|cp
operator|++
operator|+
literal|1
index|]
operator|=
operator|&
name|lxdope
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|=
literal|"123456789"
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|lxcp
index|[
operator|*
name|cp
operator|++
operator|+
literal|1
index|]
operator|=
operator|&
name|lxdope
index|[
literal|2
index|]
expr_stmt|;
name|cp
operator|=
literal|"\t\b\r\f"
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|lxcp
index|[
operator|*
name|cp
operator|++
operator|+
literal|1
index|]
operator|=
operator|&
name|lxdope
index|[
literal|3
index|]
expr_stmt|;
comment|/* first line might have title */
name|lxtitle
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|lxmatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character to be matched in char or string constant */
end_comment

begin_macro
name|lxstr
argument_list|(
argument|ct
argument_list|)
end_macro

begin_block
block|{
comment|/* match a string or character constant, up to lxmatch */
specifier|register
name|c
expr_stmt|;
specifier|register
name|val
expr_stmt|;
specifier|register
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|lxmatch
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|uerror
argument_list|(
literal|"unexpected EOF"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|uerror
argument_list|(
literal|"newline in string or char constant"
argument_list|)
expr_stmt|;
operator|++
name|lineno
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|lineno
expr_stmt|;
continue|continue;
default|default:
name|val
operator|=
name|c
expr_stmt|;
goto|goto
name|mkcc
goto|;
case|case
literal|'n'
case|:
name|val
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|mkcc
goto|;
case|case
literal|'r'
case|:
name|val
operator|=
literal|'\r'
expr_stmt|;
goto|goto
name|mkcc
goto|;
case|case
literal|'b'
case|:
name|val
operator|=
literal|'\b'
expr_stmt|;
goto|goto
name|mkcc
goto|;
case|case
literal|'t'
case|:
name|val
operator|=
literal|'\t'
expr_stmt|;
goto|goto
name|mkcc
goto|;
case|case
literal|'f'
case|:
name|val
operator|=
literal|'\f'
expr_stmt|;
goto|goto
name|mkcc
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|val
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* try for 2 */
if|if
condition|(
name|lxmask
index|[
name|c
operator|+
literal|1
index|]
operator|&
name|LEXOCT
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|<<
literal|3
operator|)
operator||
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* try for 3 */
if|if
condition|(
name|lxmask
index|[
name|c
operator|+
literal|1
index|]
operator|&
name|LEXOCT
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|<<
literal|3
operator|)
operator||
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
else|else
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
goto|goto
name|mkcc1
goto|;
block|}
default|default:
name|val
operator|=
name|c
expr_stmt|;
name|mkcc
label|:
name|val
operator|=
name|CCTRANS
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|mkcc1
label|:
if|if
condition|(
name|lxmatch
operator|==
literal|'\''
condition|)
block|{
name|val
operator|=
name|CHARCAST
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* it is, after all, a "character" constant */
name|makecc
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* stash the byte into the string */
if|if
condition|(
name|strflg
condition|)
block|{
if|if
condition|(
name|ct
operator|==
literal|0
operator|||
name|i
operator|<
name|ct
condition|)
name|putbyte
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|ct
condition|)
name|werror
argument_list|(
literal|"non-null byte ignored in string initializer"
argument_list|)
expr_stmt|;
block|}
else|else
name|bycode
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* end of string or  char constant */
if|if
condition|(
name|lxmatch
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|strflg
condition|)
block|{
comment|/* end the string */
if|if
condition|(
name|ct
operator|==
literal|0
operator|||
name|i
operator|<
name|ct
condition|)
name|putbyte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* the null at the end */
block|}
else|else
block|{
comment|/* the initializer gets a null byte */
name|bycode
argument_list|(
literal|0
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|bycode
argument_list|(
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dimtab
index|[
name|curdim
index|]
operator|=
name|i
expr_stmt|;
comment|/* in case of later sizeof ... */
block|}
block|}
else|else
block|{
comment|/* end the character constant */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|uerror
argument_list|(
literal|"empty character constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
operator|(
name|SZINT
operator|/
name|SZCHAR
operator|)
operator|||
operator|(
operator|(
name|pflag
operator|||
name|hflag
operator|)
operator|&&
name|i
operator|>
literal|1
operator|)
condition|)
name|uerror
argument_list|(
literal|"too many characters in character constant"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|lxcom
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
comment|/* saw a /*: process a comment */
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
name|EOF
case|:
name|uerror
argument_list|(
literal|"unexpected EOF"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\n'
case|:
operator|++
name|lineno
expr_stmt|;
default|default:
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'/'
condition|)
return|return;
else|else
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|LINT
case|case
literal|'V'
case|:
name|lxget
argument_list|(
name|c
argument_list|,
name|LEXLET
operator||
name|LEXDIG
argument_list|)
expr_stmt|;
block|{
specifier|extern
name|int
name|vaflag
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|yytext
index|[
literal|7
index|]
condition|?
name|yytext
index|[
literal|7
index|]
operator|-
literal|'0'
else|:
literal|0
expr_stmt|;
name|yytext
index|[
literal|7
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|yytext
argument_list|,
literal|"VARARGS"
argument_list|)
condition|)
continue|continue;
name|vaflag
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
case|case
literal|'L'
case|:
name|lxget
argument_list|(
name|c
argument_list|,
name|LEXLET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|yytext
argument_list|,
literal|"LINTLIBRARY"
argument_list|)
condition|)
continue|continue;
block|{
specifier|extern
name|int
name|libflag
decl_stmt|;
name|libflag
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'A'
case|:
name|lxget
argument_list|(
name|c
argument_list|,
name|LEXLET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|yytext
argument_list|,
literal|"ARGSUSED"
argument_list|)
condition|)
continue|continue;
block|{
specifier|extern
name|int
name|argflag
decl_stmt|,
name|vflag
decl_stmt|;
name|argflag
operator|=
literal|1
expr_stmt|;
name|vflag
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
case|case
literal|'N'
case|:
name|lxget
argument_list|(
name|c
argument_list|,
name|LEXLET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|yytext
argument_list|,
literal|"NOTREACHED"
argument_list|)
condition|)
continue|continue;
name|reached
operator|=
literal|0
expr_stmt|;
continue|continue;
endif|#
directive|endif
block|}
block|}
block|}
end_block

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|lxchar
expr_stmt|;
specifier|register
name|struct
name|lxdope
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
name|int
name|id
decl_stmt|;
switch|switch
condition|(
operator|(
name|p
operator|=
name|lxcp
index|[
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|+
literal|1
index|]
operator|)
operator|->
name|lxact
condition|)
block|{
name|onechar
label|:
name|ungetc
argument_list|(
name|lxchar
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
case|case
name|A_1C
case|:
comment|/* eat up a single character, and return an opcode */
name|yylval
operator|.
name|intval
operator|=
name|p
operator|->
name|lxval
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|lxtok
operator|)
return|;
case|case
name|A_ERR
case|:
name|uerror
argument_list|(
literal|"illegal character: %03o (octal)"
argument_list|,
name|lxchar
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_LET
case|:
comment|/* collect an identifier, check for reserved word, and return */
name|lxget
argument_list|(
name|lxchar
argument_list|,
name|LEXLET
operator||
name|LEXDIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lxchar
operator|=
name|lxres
argument_list|()
operator|)
operator|>
literal|0
condition|)
return|return
operator|(
name|lxchar
operator|)
return|;
comment|/* reserved word */
if|if
condition|(
name|lxchar
operator|==
literal|0
condition|)
continue|continue;
name|id
operator|=
name|lookup
argument_list|(
name|yytext
argument_list|,
operator|(
name|stwart
operator|&
operator|(
name|INSTRUCT
operator||
name|INUNION
operator||
name|FUNNYNAME
operator|)
operator|)
condition|?
name|SMOS
else|:
literal|0
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|stab
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sclass
operator|==
name|TYPEDEF
operator|&&
operator|!
name|stwart
condition|)
block|{
name|stwart
operator|=
name|instruct
expr_stmt|;
name|yylval
operator|.
name|nodep
operator|=
name|mkty
argument_list|(
name|sp
operator|->
name|stype
argument_list|,
name|sp
operator|->
name|dimoff
argument_list|,
name|sp
operator|->
name|sizoff
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE
operator|)
return|;
block|}
name|stwart
operator|=
operator|(
name|stwart
operator|&
name|SEENAME
operator|)
condition|?
name|instruct
else|:
literal|0
expr_stmt|;
name|yylval
operator|.
name|intval
operator|=
name|id
expr_stmt|;
return|return
operator|(
name|NAME
operator|)
return|;
case|case
name|A_DIG
case|:
comment|/* collect a digit string, then look at last one... */
name|lastcon
operator|=
literal|0
expr_stmt|;
name|lxget
argument_list|(
name|lxchar
argument_list|,
name|LEXDIG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lxchar
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|!=
literal|'0'
operator|&&
operator|!
name|yytext
index|[
literal|1
index|]
condition|)
name|uerror
argument_list|(
literal|"illegal hex constant"
argument_list|)
expr_stmt|;
name|lxmore
argument_list|(
name|lxchar
argument_list|,
name|LEXHEX
argument_list|)
expr_stmt|;
comment|/* convert the value */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|yytext
operator|+
literal|2
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
block|{
comment|/* this code won't work for all wild character sets, 						   but seems ok for ascii and ebcdic */
name|lastcon
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|lastcon
operator|+=
operator|*
name|cp
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|lastcon
operator|+=
operator|*
name|cp
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
name|lastcon
operator|+=
operator|*
name|cp
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
block|}
name|hexlong
label|:
comment|/* criterion for longness for hex and octal constants is that it 				   fit within 0177777 */
if|if
condition|(
name|lastcon
operator|&
operator|~
literal|0177777L
condition|)
name|yylval
operator|.
name|intval
operator|=
literal|1
expr_stmt|;
else|else
name|yylval
operator|.
name|intval
operator|=
literal|0
expr_stmt|;
goto|goto
name|islong
goto|;
case|case
literal|'.'
case|:
name|lxmore
argument_list|(
name|lxchar
argument_list|,
name|LEXDIG
argument_list|)
expr_stmt|;
name|getfp
label|:
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'e'
operator|||
name|lxchar
operator|==
literal|'E'
condition|)
block|{
comment|/* exponent */
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'+'
operator|||
name|lxchar
operator|==
literal|'-'
condition|)
block|{
operator|*
name|lxgcp
operator|++
operator|=
literal|'e'
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|lxchar
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|lxchar
operator|=
literal|'e'
expr_stmt|;
block|}
name|lxmore
argument_list|(
name|lxchar
argument_list|,
name|LEXDIG
argument_list|)
expr_stmt|;
comment|/* now have the whole thing... */
block|}
else|else
block|{
comment|/* no exponent */
name|ungetc
argument_list|(
name|lxchar
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|isitfloat
argument_list|(
name|yytext
argument_list|)
operator|)
return|;
default|default:
name|ungetc
argument_list|(
name|lxchar
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
comment|/* convert in octal */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|yytext
operator|+
literal|1
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
block|{
name|lastcon
operator|<<=
literal|3
expr_stmt|;
name|lastcon
operator|+=
operator|*
name|cp
operator|-
literal|'0'
expr_stmt|;
block|}
goto|goto
name|hexlong
goto|;
block|}
else|else
block|{
comment|/* convert in decimal */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|yytext
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
block|{
name|lastcon
operator|=
name|lastcon
operator|*
literal|10
operator|+
operator|*
name|cp
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
comment|/* decide if it is long or not (decimal case) */
comment|/* if it is positive and fits in 15 bits, or negative and 				   and fits in 15 bits plus an extended sign, it is int; otherwise long */
comment|/* if there is an l or L following, all bets are off... */
block|{
name|CONSZ
name|v
decl_stmt|;
name|v
operator|=
name|lastcon
operator|&
operator|~
literal|077777L
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
operator|||
name|v
operator|==
operator|~
literal|077777L
condition|)
name|yylval
operator|.
name|intval
operator|=
literal|0
expr_stmt|;
else|else
name|yylval
operator|.
name|intval
operator|=
literal|1
expr_stmt|;
block|}
name|islong
label|:
comment|/* finally, look for trailing L or l */
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'L'
operator|||
name|lxchar
operator|==
literal|'l'
condition|)
name|yylval
operator|.
name|intval
operator|=
literal|1
expr_stmt|;
else|else
name|ungetc
argument_list|(
name|lxchar
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
return|return
operator|(
name|ICON
operator|)
return|;
block|}
case|case
name|A_DOT
case|:
comment|/* look for a dot: if followed by a digit, floating point */
name|lxchar
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|lxmask
index|[
name|lxchar
operator|+
literal|1
index|]
operator|&
name|LEXDIG
condition|)
block|{
name|ungetc
argument_list|(
name|lxchar
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|lxget
argument_list|(
literal|'.'
argument_list|,
name|LEXDIG
argument_list|)
expr_stmt|;
goto|goto
name|getfp
goto|;
block|}
name|stwart
operator|=
name|FUNNYNAME
expr_stmt|;
goto|goto
name|onechar
goto|;
case|case
name|A_STR
case|:
comment|/* string constant */
name|lxmatch
operator|=
literal|'"'
expr_stmt|;
return|return
operator|(
name|STRING
operator|)
return|;
case|case
name|A_CC
case|:
comment|/* character constant */
name|lxmatch
operator|=
literal|'\''
expr_stmt|;
name|lastcon
operator|=
literal|0
expr_stmt|;
name|lxstr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|intval
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ICON
operator|)
return|;
case|case
name|A_BCD
case|:
block|{
specifier|register
name|i
expr_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LXTSZ
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'`'
condition|)
break|break;
if|if
condition|(
name|j
operator|==
literal|'\n'
condition|)
block|{
name|uerror
argument_list|(
literal|"newline in BCD constant"
argument_list|)
expr_stmt|;
break|break;
block|}
name|yytext
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
name|yytext
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|6
condition|)
name|uerror
argument_list|(
literal|"BCD constant exceeds 6 characters"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|gcos
else|else
name|strtob
argument_list|(
name|yytext
argument_list|,
operator|&
name|lastcon
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lastcon
operator|>>=
literal|6
operator|*
operator|(
literal|6
operator|-
name|i
operator|)
expr_stmt|;
else|#
directive|else
name|uerror
argument_list|(
literal|"gcos BCD constant illegal"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yylval
operator|.
name|intval
operator|=
literal|0
expr_stmt|;
comment|/* not long */
return|return
operator|(
name|ICON
operator|)
return|;
block|}
case|case
name|A_SL
case|:
comment|/* / */
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'*'
condition|)
goto|goto
name|onechar
goto|;
name|lxcom
argument_list|()
expr_stmt|;
case|case
name|A_WS
case|:
continue|continue;
case|case
name|A_NL
case|:
operator|++
name|lineno
expr_stmt|;
name|lxtitle
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|A_NOT
case|:
comment|/* ! */
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'='
condition|)
goto|goto
name|onechar
goto|;
name|yylval
operator|.
name|intval
operator|=
name|NE
expr_stmt|;
return|return
operator|(
name|EQUOP
operator|)
return|;
case|case
name|A_MI
case|:
comment|/* - */
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'-'
condition|)
block|{
name|yylval
operator|.
name|intval
operator|=
name|DECR
expr_stmt|;
return|return
operator|(
name|INCOP
operator|)
return|;
block|}
if|if
condition|(
name|lxchar
operator|!=
literal|'>'
condition|)
goto|goto
name|onechar
goto|;
name|stwart
operator|=
name|FUNNYNAME
expr_stmt|;
name|yylval
operator|.
name|intval
operator|=
name|STREF
expr_stmt|;
return|return
operator|(
name|STROP
operator|)
return|;
case|case
name|A_PL
case|:
comment|/* + */
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'+'
condition|)
goto|goto
name|onechar
goto|;
name|yylval
operator|.
name|intval
operator|=
name|INCR
expr_stmt|;
return|return
operator|(
name|INCOP
operator|)
return|;
case|case
name|A_AND
case|:
comment|/*& */
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'&'
condition|)
goto|goto
name|onechar
goto|;
return|return
operator|(
name|yylval
operator|.
name|intval
operator|=
name|ANDAND
operator|)
return|;
case|case
name|A_OR
case|:
comment|/* | */
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'|'
condition|)
goto|goto
name|onechar
goto|;
return|return
operator|(
name|yylval
operator|.
name|intval
operator|=
name|OROR
operator|)
return|;
case|case
name|A_LT
case|:
comment|/*< */
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'<'
condition|)
block|{
name|yylval
operator|.
name|intval
operator|=
name|LS
expr_stmt|;
return|return
operator|(
name|SHIFTOP
operator|)
return|;
block|}
if|if
condition|(
name|lxchar
operator|!=
literal|'='
condition|)
goto|goto
name|onechar
goto|;
name|yylval
operator|.
name|intval
operator|=
name|LE
expr_stmt|;
return|return
operator|(
name|RELOP
operator|)
return|;
case|case
name|A_GT
case|:
comment|/*> */
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'>'
condition|)
block|{
name|yylval
operator|.
name|intval
operator|=
name|RS
expr_stmt|;
return|return
operator|(
name|SHIFTOP
operator|)
return|;
block|}
if|if
condition|(
name|lxchar
operator|!=
literal|'='
condition|)
goto|goto
name|onechar
goto|;
name|yylval
operator|.
name|intval
operator|=
name|GE
expr_stmt|;
return|return
operator|(
name|RELOP
operator|)
return|;
case|case
name|A_EQ
case|:
comment|/* = */
switch|switch
condition|(
name|lxchar
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|yylval
operator|.
name|intval
operator|=
name|EQ
expr_stmt|;
return|return
operator|(
name|EQUOP
operator|)
return|;
case|case
literal|'+'
case|:
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|PLUS
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|MINUS
expr_stmt|;
name|warn
label|:
if|if
condition|(
name|lxmask
index|[
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|+
literal|1
index|]
operator|&
operator|(
name|LEXLET
operator||
name|LEXDIG
operator||
name|LEXDOT
operator|)
condition|)
block|{
name|werror
argument_list|(
literal|"ambiguous assignment: assignment op taken"
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|lxchar
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|MUL
expr_stmt|;
goto|goto
name|warn
goto|;
case|case
literal|'/'
case|:
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|DIV
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|MOD
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|AND
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|OR
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|ER
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'<'
condition|)
block|{
name|uerror
argument_list|(
literal|"=<%c illegal"
argument_list|,
name|lxchar
argument_list|)
expr_stmt|;
block|}
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|LS
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
operator|(
name|lxchar
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'>'
condition|)
block|{
name|uerror
argument_list|(
literal|"=>%c illegal"
argument_list|,
name|lxchar
argument_list|)
expr_stmt|;
block|}
name|yylval
operator|.
name|intval
operator|=
name|ASG
name|RS
expr_stmt|;
break|break;
default|default:
goto|goto
name|onechar
goto|;
block|}
return|return
operator|(
name|ASOP
operator|)
return|;
default|default:
name|cerror
argument_list|(
literal|"yylex error, character %03o (octal)"
argument_list|,
name|lxchar
argument_list|)
expr_stmt|;
block|}
comment|/* ordinarily, repeat here... */
name|cerror
argument_list|(
literal|"out of switch in yylex"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_struct
struct|struct
name|lxrdope
block|{
comment|/* dope for reserved, in alphabetical order */
name|char
modifier|*
name|lxrch
decl_stmt|;
comment|/* name of reserved word */
name|short
name|lxract
decl_stmt|;
comment|/* reserved word action */
name|short
name|lxrval
decl_stmt|;
comment|/* value to be returned */
block|}
name|lxrdope
index|[]
init|=
block|{
literal|"asm"
block|,
name|AR_A
block|,
literal|0
block|,
literal|"auto"
block|,
name|AR_CL
block|,
name|AUTO
block|,
literal|"break"
block|,
name|AR_RW
block|,
name|BREAK
block|,
literal|"char"
block|,
name|AR_TY
block|,
name|CHAR
block|,
literal|"case"
block|,
name|AR_RW
block|,
name|CASE
block|,
literal|"continue"
block|,
name|AR_RW
block|,
name|CONTINUE
block|,
literal|"double"
block|,
name|AR_TY
block|,
name|DOUBLE
block|,
literal|"default"
block|,
name|AR_RW
block|,
name|DEFAULT
block|,
literal|"do"
block|,
name|AR_RW
block|,
name|DO
block|,
literal|"extern"
block|,
name|AR_CL
block|,
name|EXTERN
block|,
literal|"else"
block|,
name|AR_RW
block|,
name|ELSE
block|,
literal|"enum"
block|,
name|AR_E
block|,
name|ENUM
block|,
literal|"for"
block|,
name|AR_RW
block|,
name|FOR
block|,
literal|"float"
block|,
name|AR_TY
block|,
name|FLOAT
block|,
literal|"fortran"
block|,
name|AR_CL
block|,
name|FORTRAN
block|,
literal|"goto"
block|,
name|AR_RW
block|,
name|GOTO
block|,
literal|"if"
block|,
name|AR_RW
block|,
name|IF
block|,
literal|"int"
block|,
name|AR_TY
block|,
name|INT
block|,
literal|"long"
block|,
name|AR_TY
block|,
name|LONG
block|,
literal|"return"
block|,
name|AR_RW
block|,
name|RETURN
block|,
literal|"register"
block|,
name|AR_CL
block|,
name|REGISTER
block|,
literal|"switch"
block|,
name|AR_RW
block|,
name|SWITCH
block|,
literal|"struct"
block|,
name|AR_S
block|,
literal|0
block|,
literal|"sizeof"
block|,
name|AR_RW
block|,
name|SIZEOF
block|,
literal|"short"
block|,
name|AR_TY
block|,
name|SHORT
block|,
literal|"static"
block|,
name|AR_CL
block|,
name|STATIC
block|,
literal|"typedef"
block|,
name|AR_CL
block|,
name|TYPEDEF
block|,
literal|"unsigned"
block|,
name|AR_TY
block|,
name|UNSIGNED
block|,
literal|"union"
block|,
name|AR_U
block|,
literal|0
block|,
literal|"while"
block|,
name|AR_RW
block|,
name|WHILE
block|,
literal|""
block|,
literal|0
block|,
literal|0
block|,
comment|/* to stop the search */
block|}
struct|;
end_struct

begin_macro
name|lxres
argument_list|()
end_macro

begin_block
block|{
comment|/* check to see of yytext is reserved; if so, 	/* do the appropriate action and return */
comment|/* otherwise, return -1 */
specifier|register
name|c
operator|,
name|ch
expr_stmt|;
specifier|register
name|struct
name|lxrdope
modifier|*
name|p
decl_stmt|;
name|ch
operator|=
name|yytext
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|islower
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|c
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|c
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|c
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|c
operator|=
literal|9
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|c
operator|=
literal|15
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|c
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|c
operator|=
literal|18
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|19
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|c
operator|=
literal|21
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|26
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|c
operator|=
literal|27
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|c
operator|=
literal|29
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|p
operator|=
name|lxrdope
operator|+
name|c
init|;
name|p
operator|->
name|lxrch
index|[
literal|0
index|]
operator|==
name|ch
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|yytext
argument_list|,
name|p
operator|->
name|lxrch
argument_list|)
condition|)
block|{
comment|/* match */
switch|switch
condition|(
name|p
operator|->
name|lxract
condition|)
block|{
case|case
name|AR_TY
case|:
comment|/* type word */
name|stwart
operator|=
name|instruct
expr_stmt|;
name|yylval
operator|.
name|nodep
operator|=
name|mkty
argument_list|(
operator|(
name|TWORD
operator|)
name|p
operator|->
name|lxrval
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|lxrval
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE
operator|)
return|;
case|case
name|AR_RW
case|:
comment|/* ordinary reserved word */
return|return
operator|(
name|yylval
operator|.
name|intval
operator|=
name|p
operator|->
name|lxrval
operator|)
return|;
case|case
name|AR_CL
case|:
comment|/* class word */
name|yylval
operator|.
name|intval
operator|=
name|p
operator|->
name|lxrval
expr_stmt|;
return|return
operator|(
name|CLASS
operator|)
return|;
case|case
name|AR_S
case|:
comment|/* struct */
name|stwart
operator|=
name|INSTRUCT
operator||
name|SEENAME
expr_stmt|;
name|yylval
operator|.
name|intval
operator|=
name|INSTRUCT
expr_stmt|;
return|return
operator|(
name|STRUCT
operator|)
return|;
case|case
name|AR_U
case|:
comment|/* union */
name|stwart
operator|=
name|INUNION
operator||
name|SEENAME
expr_stmt|;
name|yylval
operator|.
name|intval
operator|=
name|INUNION
expr_stmt|;
return|return
operator|(
name|STRUCT
operator|)
return|;
case|case
name|AR_E
case|:
comment|/* enums */
name|stwart
operator|=
name|SEENAME
expr_stmt|;
return|return
operator|(
name|yylval
operator|.
name|intval
operator|=
name|ENUM
operator|)
return|;
case|case
name|AR_A
case|:
comment|/* asm */
name|lxget
argument_list|(
literal|' '
argument_list|,
name|LEXWS
argument_list|)
expr_stmt|;
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|'('
condition|)
goto|goto
name|badasm
goto|;
name|lxget
argument_list|(
literal|' '
argument_list|,
name|LEXWS
argument_list|)
expr_stmt|;
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|'"'
condition|)
goto|goto
name|badasm
goto|;
ifndef|#
directive|ifndef
name|ONEPASS
ifndef|#
directive|ifndef
name|LINT
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
goto|goto
name|badasm
goto|;
ifndef|#
directive|ifndef
name|LINT
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|lxget
argument_list|(
literal|' '
argument_list|,
name|LEXWS
argument_list|)
expr_stmt|;
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|')'
condition|)
goto|goto
name|badasm
goto|;
ifndef|#
directive|ifndef
name|LINT
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|badasm
label|:
name|uerror
argument_list|(
literal|"bad asm construction"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|cerror
argument_list|(
literal|"bad AR_?? action"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|labelno
decl_stmt|;
end_decl_stmt

begin_macro
name|lxtitle
argument_list|()
end_macro

begin_block
block|{
comment|/* called after a newline; set linenumber and file name */
specifier|register
name|c
operator|,
name|val
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* might be several such lines in a row */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'#'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LINT
if|if
condition|(
name|lastloc
operator|!=
name|PROG
condition|)
return|return;
name|cp
operator|=
name|ftitle
expr_stmt|;
name|cq
operator|=
name|ititle
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
operator|*
name|cq
operator|++
condition|)
return|return;
if|if
condition|(
operator|*
name|cq
condition|)
return|return;
name|psline
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|lxget
argument_list|(
literal|' '
argument_list|,
name|LEXWS
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|getchar
argument_list|()
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
name|getchar
argument_list|()
control|)
block|{
name|val
operator|=
name|val
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|val
expr_stmt|;
name|lxget
argument_list|(
literal|' '
argument_list|,
name|LEXWS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|ftitle
init|;
name|c
operator|!=
literal|'\n'
condition|;
name|c
operator|=
name|getchar
argument_list|()
operator|,
operator|++
name|cp
control|)
block|{
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|LINT
if|if
condition|(
name|ititle
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|cp
operator|=
name|ftitle
expr_stmt|;
name|cq
operator|=
name|ititle
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
operator|*
name|cq
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|cq
operator|=
literal|'\0'
expr_stmt|;
operator|*
operator|--
name|cq
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|ititle
operator|+
literal|1
init|;
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
condition|;
name|cp
operator|+=
literal|8
control|)
block|{
name|pstab
argument_list|(
name|cp
argument_list|,
name|N_SO
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdebug
condition|)
name|printf
argument_list|(
literal|"0,0,LL%d\n"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
block|}
operator|*
name|cq
operator|=
literal|'"'
expr_stmt|;
name|printf
argument_list|(
literal|"LL%d:\n"
argument_list|,
name|labelno
operator|++
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_block

end_unit

