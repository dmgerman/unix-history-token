begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* UNIX DEPENDENT PROCEDURES */
end_comment

begin_comment
comment|/* DEFAULT RULES FOR UNIX */
end_comment

begin_decl_stmt
name|char
modifier|*
name|builtin
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|pwb
literal|".SUFFIXES : .L .out .o .c .f .e .r .y .yr .ye .l .s .z .x .t .h"
block|,
else|#
directive|else
literal|".SUFFIXES : .out .o .c .f .e .r .y .yr .ye .l .s"
block|,
endif|#
directive|endif
literal|"YACC=yacc"
block|,
literal|"YACCR=yacc -r"
block|,
literal|"YACCE=yacc -e"
block|,
literal|"YFLAGS="
block|,
literal|"LEX=lex"
block|,
literal|"LFLAGS="
block|,
literal|"CC=cc"
block|,
ifdef|#
directive|ifdef
name|vax
literal|"AS=as"
block|,
else|#
directive|else
literal|"AS=as -"
block|,
endif|#
directive|endif
literal|"CFLAGS="
block|,
literal|"RC=f77"
block|,
literal|"RFLAGS="
block|,
literal|"EC=f77"
block|,
literal|"EFLAGS="
block|,
literal|"FFLAGS="
block|,
literal|"LOADLIBES="
block|,
ifdef|#
directive|ifdef
name|pwb
literal|"SCOMP=scomp"
block|,
literal|"SCFLAGS="
block|,
literal|"CMDICT=cmdict"
block|,
literal|"CMFLAGS="
block|,
endif|#
directive|endif
literal|".c.o :"
block|,
literal|"\t$(CC) $(CFLAGS) -c $<"
block|,
literal|".e.o .r.o .f.o :"
block|,
literal|"\t$(EC) $(RFLAGS) $(EFLAGS) $(FFLAGS) -c $<"
block|,
literal|".s.o :"
block|,
literal|"\t$(AS) -o $@ $<"
block|,
literal|".y.o :"
block|,
literal|"\t$(YACC) $(YFLAGS) $<"
block|,
literal|"\t$(CC) $(CFLAGS) -c y.tab.c"
block|,
literal|"\trm y.tab.c"
block|,
literal|"\tmv y.tab.o $@"
block|,
literal|".yr.o:"
block|,
literal|"\t$(YACCR) $(YFLAGS) $<"
block|,
literal|"\t$(RC) $(RFLAGS) -c y.tab.r"
block|,
literal|"\trm y.tab.r"
block|,
literal|"\tmv y.tab.o $@"
block|,
literal|".ye.o :"
block|,
literal|"\t$(YACCE) $(YFLAGS) $<"
block|,
literal|"\t$(EC) $(RFLAGS) -c y.tab.e"
block|,
literal|"\trm y.tab.e"
block|,
literal|"\tmv y.tab.o $@"
block|,
literal|".l.o :"
block|,
literal|"\t$(LEX) $(LFLAGS) $<"
block|,
literal|"\t$(CC) $(CFLAGS) -c lex.yy.c"
block|,
literal|"\trm lex.yy.c"
block|,
literal|"\tmv lex.yy.o $@"
block|,
literal|".y.c :"
block|,
literal|"\t$(YACC) $(YFLAGS) $<"
block|,
literal|"\tmv y.tab.c $@"
block|,
literal|".l.c :"
block|,
literal|"\t$(LEX) $(LFLAGS) $<"
block|,
literal|"\tmv lex.yy.c $@"
block|,
literal|".yr.r:"
block|,
literal|"\t$(YACCR) $(YFLAGS) $<"
block|,
literal|"\tmv y.tab.r $@"
block|,
literal|".ye.e :"
block|,
literal|"\t$(YACCE) $(YFLAGS) $<"
block|,
literal|"\tmv y.tab.e $@"
block|,
ifdef|#
directive|ifdef
name|pwb
literal|".o.L .c.L .t.L:"
block|,
literal|"\t$(SCOMP) $(SCFLAGS) $<"
block|,
literal|".t.o:"
block|,
literal|"\t$(SCOMP) $(SCFLAGS) -c $<"
block|,
literal|".t.c:"
block|,
literal|"\t$(SCOMP) $(SCFLAGS) -t $<"
block|,
literal|".h.z .t.z:"
block|,
literal|"\t$(CMDICT) $(CMFLAGS) $<"
block|,
literal|".h.x .t.x:"
block|,
literal|"\t$(CMDICT) $(CMFLAGS) -c $<"
block|,
endif|#
directive|endif
literal|".s.out .c.out .o.out :"
block|,
literal|"\t$(CC) $(CFLAGS) $< $(LOADLIBES) -o $@"
block|,
literal|".f.out .r.out .e.out :"
block|,
literal|"\t$(EC) $(EFLAGS) $(RFLAGS) $(FFLAGS) $< $(LOADLIBES) -o $@"
block|,
literal|"\t-rm $*.o"
block|,
literal|".y.out :"
block|,
literal|"\t$(YACC) $(YFLAGS) $<"
block|,
literal|"\t$(CC) $(CFLAGS) y.tab.c $(LOADLIBES) -ly -o $@"
block|,
literal|"\trm y.tab.c"
block|,
literal|".l.out :"
block|,
literal|"\t$(LEX) $(LFLAGS) $<"
block|,
literal|"\t$(CC) $(CFLAGS) lex.yy.c $(LOADLIBES) -ll -o $@"
block|,
literal|"\trm lex.yy.c"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_include
include|#
directive|include
file|"defs"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_function
name|TIMETYPE
name|exists
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
include|#
directive|include
file|<sys/stat.h>
name|struct
name|stat
name|buf
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|TIMETYPE
name|lookarch
parameter_list|()
function_decl|;
for|for
control|(
name|s
operator|=
name|filename
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|'('
condition|;
operator|++
name|s
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
operator|(
name|lookarch
argument_list|(
name|filename
argument_list|)
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|buf
operator|.
name|st_mtime
operator|)
return|;
block|}
end_function

begin_function
name|TIMETYPE
name|prestime
parameter_list|()
block|{
name|TIMETYPE
name|t
decl_stmt|;
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_decl_stmt
name|FSTATIC
name|char
name|n15
index|[
literal|15
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FSTATIC
name|char
modifier|*
name|n15end
init|=
operator|&
name|n15
index|[
literal|14
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|depblock
modifier|*
name|srchdir
parameter_list|(
name|pat
parameter_list|,
name|mkchain
parameter_list|,
name|nextdbl
parameter_list|)
specifier|register
name|char
modifier|*
name|pat
decl_stmt|;
comment|/* pattern to be matched in directory */
name|int
name|mkchain
decl_stmt|;
comment|/* nonzero if results to be remembered */
name|struct
name|depblock
modifier|*
name|nextdbl
decl_stmt|;
comment|/* final value for chain */
block|{
name|FILE
modifier|*
name|dirf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nread
decl_stmt|,
name|cldir
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|dirpref
decl_stmt|,
modifier|*
name|endir
decl_stmt|,
modifier|*
name|filepat
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|char
name|fullname
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|struct
name|nameblock
modifier|*
name|q
decl_stmt|;
name|struct
name|depblock
modifier|*
name|thisdbl
decl_stmt|;
name|struct
name|opendir
modifier|*
name|od
decl_stmt|;
name|struct
name|pattern
modifier|*
name|patp
decl_stmt|;
name|struct
name|direct
name|entry
index|[
literal|32
index|]
decl_stmt|;
name|thisdbl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mkchain
operator|==
name|NO
condition|)
for|for
control|(
name|patp
operator|=
name|firstpat
init|;
name|patp
condition|;
name|patp
operator|=
name|patp
operator|->
name|nxtpattern
control|)
if|if
condition|(
operator|!
name|unequal
argument_list|(
name|pat
argument_list|,
name|patp
operator|->
name|patval
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|patp
operator|=
name|ALLOC
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|patp
operator|->
name|nxtpattern
operator|=
name|firstpat
expr_stmt|;
name|firstpat
operator|=
name|patp
expr_stmt|;
name|patp
operator|->
name|patval
operator|=
name|copys
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|endir
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pat
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|endir
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|endir
operator|==
literal|0
condition|)
block|{
name|dirname
operator|=
literal|"."
expr_stmt|;
name|dirpref
operator|=
literal|""
expr_stmt|;
name|filepat
operator|=
name|pat
expr_stmt|;
block|}
else|else
block|{
name|dirname
operator|=
name|pat
expr_stmt|;
operator|*
name|endir
operator|=
literal|'\0'
expr_stmt|;
name|dirpref
operator|=
name|concat
argument_list|(
name|dirname
argument_list|,
literal|"/"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|filepat
operator|=
name|endir
operator|+
literal|1
expr_stmt|;
block|}
name|dirf
operator|=
name|NULL
expr_stmt|;
name|cldir
operator|=
name|NO
expr_stmt|;
for|for
control|(
name|od
operator|=
name|firstod
init|;
name|od
condition|;
name|od
operator|=
name|od
operator|->
name|nxtopendir
control|)
if|if
condition|(
operator|!
name|unequal
argument_list|(
name|dirname
argument_list|,
name|od
operator|->
name|dirn
argument_list|)
condition|)
block|{
name|dirf
operator|=
name|od
operator|->
name|dirfc
expr_stmt|;
name|fseek
argument_list|(
name|dirf
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start over at the beginning  */
break|break;
block|}
if|if
condition|(
name|dirf
operator|==
name|NULL
condition|)
block|{
name|dirf
operator|=
name|fopen
argument_list|(
name|dirname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nopdir
operator|>=
name|MAXDIR
condition|)
name|cldir
operator|=
name|YES
expr_stmt|;
else|else
block|{
operator|++
name|nopdir
expr_stmt|;
name|od
operator|=
name|ALLOC
argument_list|(
name|opendir
argument_list|)
expr_stmt|;
name|od
operator|->
name|nxtopendir
operator|=
name|firstod
expr_stmt|;
name|firstod
operator|=
name|od
expr_stmt|;
name|od
operator|->
name|dirfc
operator|=
name|dirf
expr_stmt|;
name|od
operator|->
name|dirn
operator|=
name|copys
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dirf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Directory %s: "
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"Cannot open"
argument_list|)
expr_stmt|;
block|}
else|else
do|do
block|{
name|nread
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|entry
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
argument_list|,
literal|32
argument_list|,
name|dirf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nread
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|entry
index|[
name|i
index|]
operator|.
name|d_ino
operator|!=
literal|0
condition|)
block|{
name|p1
operator|=
name|entry
index|[
name|i
index|]
operator|.
name|d_name
expr_stmt|;
name|p2
operator|=
name|n15
expr_stmt|;
while|while
condition|(
operator|(
name|p2
operator|<
name|n15end
operator|)
operator|&&
operator|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
name|amatch
argument_list|(
name|n15
argument_list|,
name|filepat
argument_list|)
condition|)
block|{
name|concat
argument_list|(
name|dirpref
argument_list|,
name|n15
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|srchname
argument_list|(
name|fullname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|q
operator|=
name|makename
argument_list|(
name|copys
argument_list|(
name|fullname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkchain
condition|)
block|{
name|thisdbl
operator|=
name|ALLOC
argument_list|(
name|depblock
argument_list|)
expr_stmt|;
name|thisdbl
operator|->
name|nxtdepblock
operator|=
name|nextdbl
expr_stmt|;
name|thisdbl
operator|->
name|depname
operator|=
name|q
expr_stmt|;
name|nextdbl
operator|=
name|thisdbl
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|nread
operator|==
literal|32
condition|)
do|;
if|if
condition|(
name|endir
operator|!=
literal|0
condition|)
operator|*
name|endir
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|cldir
condition|)
name|fclose
argument_list|(
name|dirf
argument_list|)
expr_stmt|;
return|return
operator|(
name|thisdbl
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* stolen from glob through find */
end_comment

begin_expr_stmt
specifier|static
name|amatch
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|)
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|cc
decl_stmt|,
name|scc
decl_stmt|,
name|k
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lc
decl_stmt|;
name|scc
operator|=
operator|*
name|s
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
condition|)
block|{
case|case
literal|'['
case|:
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|']'
case|:
if|if
condition|(
name|k
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'-'
case|:
name|k
operator||=
operator|(
name|lc
operator|<=
name|scc
operator|)
operator|&
operator|(
name|scc
operator|<=
operator|(
name|cc
operator|=
name|p
index|[
literal|1
index|]
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|scc
operator|==
operator|(
name|lc
operator|=
name|cc
operator|)
condition|)
name|k
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'?'
case|:
name|caseq
label|:
if|if
condition|(
name|scc
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|umatch
argument_list|(
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
operator|!
name|scc
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|scc
condition|)
goto|goto
name|caseq
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|umatch
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|)
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|amatch
argument_list|(
name|s
operator|++
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|METERFILE
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_decl_stmt
name|int
name|meteron
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default: metering off */
end_comment

begin_macro
name|meter
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TIMETYPE
name|tvec
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ctime
argument_list|()
decl_stmt|;
name|FILE
modifier|*
name|mout
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|,
modifier|*
name|getpwuid
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|0
operator|||
name|meteron
operator|==
literal|0
condition|)
return|return;
name|pwd
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|tvec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mout
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|ctime
argument_list|(
operator|&
name|tvec
argument_list|)
expr_stmt|;
name|p
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|mout
argument_list|,
literal|"User %s, %s\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* look inside archives for notations a(b) and a((b)) 	a(b)	is file member   b   in archive a 	a((b))	is entry point  _b  in object archive a */
end_comment

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|ar_hdr
name|arhead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|arfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|arpos
decl_stmt|,
name|arlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|exec
name|objhead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|objentry
decl_stmt|;
end_decl_stmt

begin_function
name|TIMETYPE
name|lookarch
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|send
decl_stmt|,
name|s
index|[
literal|15
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nc
decl_stmt|,
name|nsym
decl_stmt|,
name|objarch
decl_stmt|;
for|for
control|(
name|p
operator|=
name|filename
init|;
operator|*
name|p
operator|!=
literal|'('
condition|;
operator|++
name|p
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|openarch
argument_list|(
name|filename
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'('
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|objarch
operator|=
name|YES
expr_stmt|;
name|nc
operator|=
literal|8
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
name|objarch
operator|=
name|NO
expr_stmt|;
name|nc
operator|=
literal|14
expr_stmt|;
block|}
name|send
operator|=
name|s
operator|+
name|nc
expr_stmt|;
for|for
control|(
name|q
operator|=
name|s
init|;
name|q
operator|<
name|send
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|')'
condition|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
control|)
empty_stmt|;
while|while
condition|(
name|q
operator|<
name|send
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|getarch
argument_list|()
condition|)
block|{
if|if
condition|(
name|objarch
condition|)
block|{
name|getobj
argument_list|()
expr_stmt|;
name|nsym
operator|=
name|objhead
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
name|objentry
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsym
condition|;
operator|++
name|i
control|)
block|{
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|objentry
argument_list|,
sizeof|sizeof
argument_list|(
name|objentry
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|objentry
operator|.
name|n_type
operator|&
name|N_EXT
operator|)
operator|&&
operator|(
operator|(
name|objentry
operator|.
name|n_type
operator|&
operator|~
name|N_EXT
operator|)
operator|||
name|objentry
operator|.
name|n_value
operator|)
operator|&&
name|eqstr
argument_list|(
name|objentry
operator|.
name|n_name
argument_list|,
name|s
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|clarch
argument_list|()
expr_stmt|;
return|return
operator|(
name|arhead
operator|.
name|ar_date
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|eqstr
argument_list|(
name|arhead
operator|.
name|ar_name
argument_list|,
name|s
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|clarch
argument_list|()
expr_stmt|;
return|return
operator|(
name|arhead
operator|.
name|ar_date
operator|)
return|;
block|}
block|}
name|clarch
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0L
operator|)
return|;
block|}
end_function

begin_macro
name|clarch
argument_list|()
end_macro

begin_block
block|{
name|fclose
argument_list|(
name|arfd
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|openarch
argument_list|(
name|f
argument_list|)
specifier|register
name|char
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|word
decl_stmt|;
include|#
directive|include
file|<sys/stat.h>
name|struct
name|stat
name|buf
decl_stmt|;
name|stat
argument_list|(
name|f
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|arlen
operator|=
name|buf
operator|.
name|st_size
expr_stmt|;
name|arfd
operator|=
name|fopen
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arfd
operator|==
name|NULL
condition|)
name|fatal1
argument_list|(
literal|"cannot open %s"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|word
argument_list|,
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|!=
name|ARMAG
condition|)
name|fatal1
argument_list|(
literal|"%s is not an archive"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|arpos
operator|=
literal|0
expr_stmt|;
name|arhead
operator|.
name|ar_size
operator|=
literal|2
operator|-
sizeof|sizeof
argument_list|(
name|arhead
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getarch
argument_list|()
end_macro

begin_block
block|{
name|arpos
operator|+=
sizeof|sizeof
argument_list|(
name|arhead
argument_list|)
expr_stmt|;
name|arpos
operator|+=
operator|(
name|arhead
operator|.
name|ar_size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1L
expr_stmt|;
if|if
condition|(
name|arpos
operator|>=
name|arlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fseek
argument_list|(
name|arfd
argument_list|,
name|arpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|arhead
argument_list|,
sizeof|sizeof
argument_list|(
name|arhead
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|getobj
argument_list|()
end_macro

begin_block
block|{
name|long
name|int
name|skip
decl_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|objhead
argument_list|,
sizeof|sizeof
argument_list|(
name|objhead
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|objhead
operator|.
name|a_magic
operator|!=
name|A_MAGIC1
operator|&&
name|objhead
operator|.
name|a_magic
operator|!=
name|A_MAGIC2
operator|&&
name|objhead
operator|.
name|a_magic
operator|!=
name|A_MAGIC3
operator|&&
name|objhead
operator|.
name|a_magic
operator|!=
name|A_MAGIC4
condition|)
name|fatal1
argument_list|(
literal|"%s is not an object module"
argument_list|,
name|arhead
operator|.
name|ar_name
argument_list|)
expr_stmt|;
name|skip
operator|=
name|objhead
operator|.
name|a_text
operator|+
name|objhead
operator|.
name|a_data
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
name|skip
operator|+=
name|objhead
operator|.
name|a_trsize
operator|+
name|objhead
operator|.
name|a_drsize
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|objhead
operator|.
name|a_flag
condition|)
name|skip
operator|*=
literal|2
expr_stmt|;
endif|#
directive|endif
name|fseek
argument_list|(
name|arfd
argument_list|,
name|skip
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|eqstr
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|a
operator|,
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|a
operator|++
operator|!=
operator|*
name|b
operator|++
condition|)
return|return
operator|(
name|NO
operator|)
return|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

end_unit

