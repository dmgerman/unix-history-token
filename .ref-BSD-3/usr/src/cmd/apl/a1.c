begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"apl.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|continu
init|=
literal|"continue"
decl_stmt|;
end_decl_stmt

begin_macro
name|execute
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|data
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
name|struct
name|item
modifier|*
name|p1
decl_stmt|;
name|int
name|j
decl_stmt|;
name|data
argument_list|(
operator|*
name|f
argument_list|)
argument_list|()
decl_stmt|,
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|SOMED
if|if
condition|(
name|debug
condition|)
name|dump
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|loop
label|:
name|i
operator|=
operator|*
name|s
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|FULLD
if|if
condition|(
name|debug
condition|)
block|{
specifier|extern
name|char
modifier|*
name|opname
index|[]
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|aprintf
argument_list|(
literal|"exec eof\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|<=
name|i
operator|&&
name|i
operator|<
literal|103
condition|)
block|{
name|aprintf
argument_list|(
literal|"exec "
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|opname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|aputchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
name|aprintf
argument_list|(
literal|"exec %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHORTD
if|if
condition|(
name|debug
condition|)
name|aprintf
argument_list|(
literal|"exec %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"exec B"
argument_list|)
expr_stmt|;
case|case
name|EOF
case|:
return|return;
case|case
name|EOL
case|:
name|pop
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|COMNT
case|:
name|push
argument_list|(
name|newdat
argument_list|(
name|DA
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|ADD
case|:
case|case
name|SUB
case|:
case|case
name|MUL
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|MIN
case|:
case|case
name|MAX
case|:
case|case
name|PWR
case|:
case|case
name|LOG
case|:
case|case
name|CIR
case|:
case|case
name|COMB
case|:
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|NAND
case|:
case|case
name|NOR
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|NE
case|:
name|f
operator|=
name|exop
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|fetch2
argument_list|()
expr_stmt|;
name|p1
operator|=
name|sp
index|[
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|DA
operator|||
name|p1
operator|->
name|type
operator|!=
name|DA
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|CH
operator|&&
name|p1
operator|->
name|type
operator|==
name|CH
condition|)
block|{
name|charfun
argument_list|(
name|i
argument_list|,
name|p
argument_list|,
name|p1
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
else|else
name|error
argument_list|(
literal|"dyadic T E"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|rank
operator|||
name|p
operator|->
name|rank
operator|==
literal|1
operator|&&
name|p
operator|->
name|size
operator|==
literal|1
condition|)
block|{
name|d
operator|=
name|p
operator|->
name|datap
index|[
literal|0
index|]
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
name|dp
operator|=
name|p
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|d
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
operator|!
name|p1
operator|->
name|rank
operator|||
name|p1
operator|->
name|rank
operator|==
literal|1
operator|&&
name|p1
operator|->
name|size
operator|==
literal|1
condition|)
block|{
name|sp
operator|--
expr_stmt|;
name|d
operator|=
name|p1
operator|->
name|datap
index|[
literal|0
index|]
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dp
operator|=
name|p
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|dp
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|p1
operator|->
name|rank
operator|!=
name|p
operator|->
name|rank
condition|)
name|error
argument_list|(
literal|"dyadic C E"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|rank
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dim
index|[
name|i
index|]
operator|!=
name|p1
operator|->
name|dim
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"dyadic C E"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|p1
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|p
operator|->
name|datap
index|[
name|i
index|]
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
name|pop
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|SGN
case|:
case|case
name|RECIP
case|:
case|case
name|ABS
case|:
case|case
name|FLOOR
case|:
case|case
name|CEIL
case|:
case|case
name|EXP
case|:
case|case
name|LOGE
case|:
case|case
name|PI
case|:
case|case
name|RAND
case|:
case|case
name|FAC
case|:
case|case
name|NOT
case|:
name|f
operator|=
name|exop
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|DA
condition|)
name|error
argument_list|(
literal|"monadic T E"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|p
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
case|case
name|MEPS
case|:
comment|/*      execute         */
case|case
name|MENC
case|:
comment|/*      monadic encode  */
case|case
name|DRHO
case|:
case|case
name|DIOT
case|:
case|case
name|EPS
case|:
case|case
name|REP
case|:
case|case
name|BASE
case|:
case|case
name|DEAL
case|:
case|case
name|DTRN
case|:
case|case
name|CAT
case|:
case|case
name|CATK
case|:
case|case
name|TAKE
case|:
case|case
name|DROP
case|:
case|case
name|DDOM
case|:
case|case
name|MDOM
case|:
case|case
name|GDU
case|:
case|case
name|GDUK
case|:
case|case
name|GDD
case|:
case|case
name|GDDK
case|:
case|case
name|COM
case|:
case|case
name|COM0
case|:
case|case
name|COMK
case|:
case|case
name|EXD
case|:
case|case
name|EXD0
case|:
case|case
name|EXDK
case|:
case|case
name|ROT
case|:
case|case
name|ROT0
case|:
case|case
name|ROTK
case|:
case|case
name|MRHO
case|:
case|case
name|MTRN
case|:
case|case
name|RAV
case|:
case|case
name|RAVK
case|:
case|case
name|RED
case|:
case|case
name|RED0
case|:
case|case
name|REDK
case|:
case|case
name|SCAN
case|:
case|case
name|SCANK
case|:
case|case
name|SCAN0
case|:
case|case
name|REV
case|:
case|case
name|REV0
case|:
case|case
name|REVK
case|:
case|case
name|ASGN
case|:
case|case
name|INDEX
case|:
case|case
name|ELID
case|:
case|case
name|IPROD
case|:
case|case
name|OPROD
case|:
case|case
name|IMMED
case|:
case|case
name|HPRINT
case|:
case|case
name|PRINT
case|:
case|case
name|MIOT
case|:
case|case
name|MIBM
case|:
case|case
name|DIBM
case|:
case|case
name|BRAN0
case|:
case|case
name|BRAN
case|:
case|case
name|FUN
case|:
case|case
name|ARG1
case|:
case|case
name|ARG2
case|:
case|case
name|AUTO
case|:
case|case
name|REST
case|:
name|pcp
operator|=
name|s
expr_stmt|;
call|(
modifier|*
name|exop
index|[
name|i
index|]
call|)
argument_list|()
expr_stmt|;
name|s
operator|=
name|pcp
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|NAME
case|:
name|s
operator|+=
name|copy
argument_list|(
name|IN
argument_list|,
name|s
argument_list|,
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|>
name|staktop
condition|)
name|newstak
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|QUOT
case|:
name|j
operator|=
name|CH
expr_stmt|;
goto|goto
name|con
goto|;
case|case
name|CONST
case|:
name|j
operator|=
name|DA
expr_stmt|;
name|con
label|:
name|i
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|p
operator|=
name|newdat
argument_list|(
name|j
argument_list|,
name|i
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|copy
argument_list|(
name|j
argument_list|,
name|s
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|QUAD
case|:
name|push
argument_list|(
name|newdat
argument_list|(
name|QD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|QQUAD
case|:
name|push
argument_list|(
name|newdat
argument_list|(
name|QQ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|CQUAD
case|:
name|push
argument_list|(
name|newdat
argument_list|(
name|QC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|comop
decl_stmt|;
end_decl_stmt

begin_macro
name|charfun
argument_list|(
argument|op
argument_list|,
argument|p
argument_list|,
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|item
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|cxi
decl_stmt|;
specifier|register
name|double
modifier|*
name|dxi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|comop
operator|=
name|op
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"Y D E"
argument_list|)
expr_stmt|;
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|NE
case|:
comment|/* OK */
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|rank
condition|)
block|{
name|c
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|datap
operator|)
operator|)
expr_stmt|;
name|cxi
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p1
operator|->
name|datap
operator|)
expr_stmt|;
name|push
argument_list|(
name|newdat
argument_list|(
name|DA
argument_list|,
name|p1
operator|->
name|rank
argument_list|,
name|p1
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|IN
argument_list|,
name|p1
operator|->
name|dim
argument_list|,
name|sp
index|[
operator|-
literal|1
index|]
operator|->
name|dim
argument_list|,
name|p1
operator|->
name|rank
argument_list|)
expr_stmt|;
name|dxi
operator|=
name|sp
index|[
operator|-
literal|1
index|]
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p1
operator|->
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|dxi
operator|++
operator|=
operator|(
name|double
operator|)
name|charcom
argument_list|(
name|c
argument_list|,
operator|*
name|cxi
operator|++
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|p1
operator|->
name|rank
condition|)
block|{
name|c
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p1
operator|->
name|datap
operator|)
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|cxi
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|datap
operator|)
expr_stmt|;
name|push
argument_list|(
name|newdat
argument_list|(
name|DA
argument_list|,
name|p
operator|->
name|rank
argument_list|,
name|p
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|IN
argument_list|,
name|p
operator|->
name|dim
argument_list|,
name|sp
index|[
operator|-
literal|1
index|]
operator|->
name|dim
argument_list|,
name|p
operator|->
name|rank
argument_list|)
expr_stmt|;
name|dxi
operator|=
name|sp
index|[
operator|-
literal|1
index|]
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|dxi
operator|++
operator|=
operator|(
name|double
operator|)
name|charcom
argument_list|(
operator|*
name|cxi
operator|++
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p1
operator|->
name|rank
operator|!=
name|p
operator|->
name|rank
condition|)
name|error
argument_list|(
literal|"dyadic Y C E"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|rank
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dim
index|[
name|i
index|]
operator|!=
name|p1
operator|->
name|dim
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"dyadic Y C E"
argument_list|)
expr_stmt|;
name|cxi
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p1
operator|->
name|datap
operator|)
expr_stmt|;
name|push
argument_list|(
name|newdat
argument_list|(
name|DA
argument_list|,
name|p
operator|->
name|rank
argument_list|,
name|p
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|IN
argument_list|,
name|p
operator|->
name|dim
argument_list|,
name|sp
index|[
operator|-
literal|1
index|]
operator|->
name|dim
argument_list|,
name|p
operator|->
name|rank
argument_list|)
expr_stmt|;
name|dxi
operator|=
name|sp
index|[
operator|-
literal|1
index|]
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|dxi
operator|++
operator|=
operator|(
name|double
operator|)
name|charcom
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|datap
operator|)
operator|)
index|[
name|i
index|]
argument_list|,
operator|*
name|cxi
operator|++
argument_list|)
expr_stmt|;
name|done
label|:
name|dealloc
argument_list|(
name|sp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|dealloc
argument_list|(
name|sp
index|[
operator|-
literal|3
index|]
argument_list|)
expr_stmt|;
name|sp
index|[
operator|-
literal|3
index|]
operator|=
name|sp
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|sp
operator|-=
literal|2
expr_stmt|;
return|return;
block|}
end_block

begin_expr_stmt
name|charcom
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
specifier|register
name|char
name|c1
operator|,
name|c2
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|comop
condition|)
block|{
case|case
name|LE
case|:
return|return
name|c1
operator|<=
name|c2
return|;
case|case
name|LT
case|:
return|return
name|c1
operator|<
name|c2
return|;
case|case
name|EQ
case|:
return|return
name|c1
operator|==
name|c2
return|;
case|case
name|NE
case|:
return|return
name|c1
operator|!=
name|c2
return|;
case|case
name|GT
case|:
return|return
name|c1
operator|>
name|c2
return|;
case|case
name|GE
case|:
return|return
name|c1
operator|>=
name|c2
return|;
block|}
name|error
argument_list|(
literal|"Y B"
argument_list|)
expr_stmt|;
comment|/*  "Cannot happen"  */
block|}
end_block

begin_decl_stmt
name|int
name|ex_add
argument_list|()
decl_stmt|,
name|ex_plus
argument_list|()
decl_stmt|,
name|ex_sub
argument_list|()
decl_stmt|,
name|ex_minus
argument_list|()
decl_stmt|,
name|ex_mul
argument_list|()
decl_stmt|,
name|ex_sgn
argument_list|()
decl_stmt|,
name|ex_div
argument_list|()
decl_stmt|,
name|ex_recip
argument_list|()
decl_stmt|,
name|ex_mod
argument_list|()
decl_stmt|,
name|ex_abs
argument_list|()
decl_stmt|,
name|ex_min
argument_list|()
decl_stmt|,
name|ex_floor
argument_list|()
decl_stmt|,
name|ex_max
argument_list|()
decl_stmt|,
name|ex_ceil
argument_list|()
decl_stmt|,
name|ex_pwr
argument_list|()
decl_stmt|,
name|ex_exp
argument_list|()
decl_stmt|,
name|ex_log
argument_list|()
decl_stmt|,
name|ex_loge
argument_list|()
decl_stmt|,
name|ex_cir
argument_list|()
decl_stmt|,
name|ex_pi
argument_list|()
decl_stmt|,
name|ex_comb
argument_list|()
decl_stmt|,
name|ex_fac
argument_list|()
decl_stmt|,
name|ex_deal
argument_list|()
decl_stmt|,
name|ex_rand
argument_list|()
decl_stmt|,
name|ex_drho
argument_list|()
decl_stmt|,
name|ex_mrho
argument_list|()
decl_stmt|,
name|ex_diot
argument_list|()
decl_stmt|,
name|ex_miot
argument_list|()
decl_stmt|,
name|ex_rot0
argument_list|()
decl_stmt|,
name|ex_rev0
argument_list|()
decl_stmt|,
name|ex_dtrn
argument_list|()
decl_stmt|,
name|ex_mtrn
argument_list|()
decl_stmt|,
name|ex_dibm
argument_list|()
decl_stmt|,
name|ex_mibm
argument_list|()
decl_stmt|,
name|ex_gdu
argument_list|()
decl_stmt|,
name|ex_gduk
argument_list|()
decl_stmt|,
name|ex_gdd
argument_list|()
decl_stmt|,
name|ex_gddk
argument_list|()
decl_stmt|,
name|ex_exd
argument_list|()
decl_stmt|,
name|ex_scan
argument_list|()
decl_stmt|,
name|ex_exdk
argument_list|()
decl_stmt|,
name|ex_scnk
argument_list|()
decl_stmt|,
name|ex_iprod
argument_list|()
decl_stmt|,
name|ex_oprod
argument_list|()
decl_stmt|,
name|ex_br0
argument_list|()
decl_stmt|,
name|ex_br
argument_list|()
decl_stmt|,
name|ex_ddom
argument_list|()
decl_stmt|,
name|ex_mdom
argument_list|()
decl_stmt|,
name|ex_com
argument_list|()
decl_stmt|,
name|ex_red
argument_list|()
decl_stmt|,
name|ex_comk
argument_list|()
decl_stmt|,
name|ex_redk
argument_list|()
decl_stmt|,
name|ex_rot
argument_list|()
decl_stmt|,
name|ex_rev
argument_list|()
decl_stmt|,
name|ex_rotk
argument_list|()
decl_stmt|,
name|ex_revk
argument_list|()
decl_stmt|,
name|ex_cat
argument_list|()
decl_stmt|,
name|ex_rav
argument_list|()
decl_stmt|,
name|ex_catk
argument_list|()
decl_stmt|,
name|ex_ravk
argument_list|()
decl_stmt|,
name|ex_print
argument_list|()
decl_stmt|,
name|ex_elid
argument_list|()
decl_stmt|,
name|ex_index
argument_list|()
decl_stmt|,
name|ex_hprint
argument_list|()
decl_stmt|,
name|ex_lt
argument_list|()
decl_stmt|,
name|ex_le
argument_list|()
decl_stmt|,
name|ex_gt
argument_list|()
decl_stmt|,
name|ex_ge
argument_list|()
decl_stmt|,
name|ex_eq
argument_list|()
decl_stmt|,
name|ex_ne
argument_list|()
decl_stmt|,
name|ex_and
argument_list|()
decl_stmt|,
name|ex_or
argument_list|()
decl_stmt|,
name|ex_nand
argument_list|()
decl_stmt|,
name|ex_nor
argument_list|()
decl_stmt|,
name|ex_not
argument_list|()
decl_stmt|,
name|ex_eps
argument_list|()
decl_stmt|,
name|ex_meps
argument_list|()
decl_stmt|,
name|ex_rep
argument_list|()
decl_stmt|,
name|ex_take
argument_list|()
decl_stmt|,
name|ex_drop
argument_list|()
decl_stmt|,
name|ex_exd0
argument_list|()
decl_stmt|,
name|ex_asgn
argument_list|()
decl_stmt|,
name|ex_immed
argument_list|()
decl_stmt|,
name|ex_fun
argument_list|()
decl_stmt|,
name|ex_arg1
argument_list|()
decl_stmt|,
name|ex_arg2
argument_list|()
decl_stmt|,
name|ex_auto
argument_list|()
decl_stmt|,
name|ex_rest
argument_list|()
decl_stmt|,
name|ex_com0
argument_list|()
decl_stmt|,
name|ex_red0
argument_list|()
decl_stmt|,
name|ex_exd0
argument_list|()
decl_stmt|,
name|ex_scn0
argument_list|()
decl_stmt|,
name|ex_base
argument_list|()
decl_stmt|,
name|ex_menc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|exop
index|[]
function_decl|)
parameter_list|()
init|=
block|{
literal|0
operator|,
comment|/* 0 */
function_decl|ex_add
operator|,
comment|/* 1 */
function_decl|ex_plus
operator|,
comment|/* 2 */
function_decl|ex_sub
operator|,
comment|/* 3 */
function_decl|ex_minus
operator|,
comment|/* 4 */
function_decl|ex_mul
operator|,
comment|/* 5 */
function_decl|ex_sgn
operator|,
comment|/* 6 */
function_decl|ex_div
operator|,
comment|/* 7 */
function_decl|ex_recip
operator|,
comment|/* 8 */
function_decl|ex_mod
operator|,
comment|/* 9 */
function_decl|ex_abs
operator|,
comment|/* 10 */
function_decl|ex_min
operator|,
comment|/* 11 */
function_decl|ex_floor
operator|,
comment|/* 12 */
function_decl|ex_max
operator|,
comment|/* 13 */
function_decl|ex_ceil
operator|,
comment|/* 14 */
function_decl|ex_pwr
operator|,
comment|/* 15 */
function_decl|ex_exp
operator|,
comment|/* 16 */
function_decl|ex_log
operator|,
comment|/* 17 */
function_decl|ex_loge
operator|,
comment|/* 18 */
function_decl|ex_cir
operator|,
comment|/* 19 */
function_decl|ex_pi
operator|,
comment|/* 20 */
function_decl|ex_comb
operator|,
comment|/* 21 */
function_decl|ex_fac
operator|,
comment|/* 22 */
function_decl|ex_deal
operator|,
comment|/* 23 */
function_decl|ex_rand
operator|,
comment|/* 24 */
function_decl|ex_drho
operator|,
comment|/* 25 */
function_decl|ex_mrho
operator|,
comment|/* 26 */
function_decl|ex_diot
operator|,
comment|/* 27 */
function_decl|ex_miot
operator|,
comment|/* 28 */
function_decl|ex_rot0
operator|,
comment|/* 29 */
function_decl|ex_rev0
operator|,
comment|/* 30 */
function_decl|ex_dtrn
operator|,
comment|/* 31 */
function_decl|ex_mtrn
operator|,
comment|/* 32 */
function_decl|ex_dibm
operator|,
comment|/* 33 */
function_decl|ex_mibm
operator|,
comment|/* 34 */
function_decl|ex_gdu
operator|,
comment|/* 35 */
function_decl|ex_gduk
operator|,
comment|/* 36 */
function_decl|ex_gdd
operator|,
comment|/* 37 */
function_decl|ex_gddk
operator|,
comment|/* 38 */
function_decl|ex_exd
operator|,
comment|/* 39 */
function_decl|ex_scan
operator|,
comment|/* 40 */
function_decl|ex_exdk
operator|,
comment|/* 41 */
function_decl|ex_scnk
operator|,
comment|/* 42 */
function_decl|ex_iprod
operator|,
comment|/* 43 */
function_decl|ex_oprod
operator|,
comment|/* 44 */
function_decl|0
operator|,
comment|/* 45 */
function_decl|0
operator|,
comment|/* 46 */
function_decl|ex_br0
operator|,
comment|/* 47 */
function_decl|ex_br
operator|,
comment|/* 48 */
function_decl|ex_ddom
operator|,
comment|/* 49 */
function_decl|ex_mdom
operator|,
comment|/* 50 */
function_decl|ex_com
operator|,
comment|/* 51 */
function_decl|ex_red
operator|,
comment|/* 52 */
function_decl|ex_comk
operator|,
comment|/* 53 */
function_decl|ex_redk
operator|,
comment|/* 54 */
function_decl|ex_rot
operator|,
comment|/* 55 */
function_decl|ex_rev
operator|,
comment|/* 56 */
function_decl|ex_rotk
operator|,
comment|/* 57 */
function_decl|ex_revk
operator|,
comment|/* 58 */
function_decl|ex_cat
operator|,
comment|/* 59 */
function_decl|ex_rav
operator|,
comment|/* 60 */
function_decl|ex_catk
operator|,
comment|/* 61 */
function_decl|ex_ravk
operator|,
comment|/* 62 */
function_decl|ex_print
operator|,
comment|/* 63 */
function_decl|0
operator|,
comment|/* 64 */
function_decl|ex_elid
operator|,
comment|/* 65 */
function_decl|0
operator|,
comment|/* 66 */
function_decl|0
operator|,
comment|/* 67 */
function_decl|ex_index
operator|,
comment|/* 68 */
function_decl|ex_hprint
operator|,
comment|/* 69 */
function_decl|0
operator|,
comment|/* 70 */
function_decl|ex_lt
operator|,
comment|/* 71 */
function_decl|ex_le
operator|,
comment|/* 72 */
function_decl|ex_gt
operator|,
comment|/* 73 */
function_decl|ex_ge
operator|,
comment|/* 74 */
function_decl|ex_eq
operator|,
comment|/* 75 */
function_decl|ex_ne
operator|,
comment|/* 76 */
function_decl|ex_and
operator|,
comment|/* 77 */
function_decl|ex_or
operator|,
comment|/* 78 */
function_decl|ex_nand
operator|,
comment|/* 79 */
function_decl|ex_nor
operator|,
comment|/* 80 */
function_decl|ex_not
operator|,
comment|/* 81 */
function_decl|ex_eps
operator|,
comment|/* 82 */
function_decl|ex_meps
operator|,
comment|/* 83 */
function_decl|ex_rep
operator|,
comment|/* 84 */
function_decl|ex_take
operator|,
comment|/* 85 */
function_decl|ex_drop
operator|,
comment|/* 86 */
function_decl|ex_exd0
operator|,
comment|/* 87 */
function_decl|ex_asgn
operator|,
comment|/* 88 */
function_decl|ex_immed
operator|,
comment|/* 89 */
function_decl|0
operator|,
comment|/* 90 */
function_decl|0
operator|,
comment|/* 91 */
function_decl|ex_fun
operator|,
comment|/* 92 */
function_decl|ex_arg1
operator|,
comment|/* 93 */
function_decl|ex_arg2
operator|,
comment|/* 94 */
function_decl|ex_auto
operator|,
comment|/* 95 */
function_decl|ex_rest
operator|,
comment|/* 96 */
function_decl|ex_com0
operator|,
comment|/* 97 */
function_decl|ex_red0
operator|,
comment|/* 98 */
function_decl|ex_exd0
operator|,
comment|/* 99 */
function_decl|ex_scn0
operator|,
comment|/*100 */
function_decl|ex_base
operator|,
comment|/*101 */
function_decl|ex_menc
operator|,
end_function_decl

begin_comment
comment|/*102 */
end_comment

begin_comment
comment|/*      monadic encod   */
end_comment

unit|};
end_unit

