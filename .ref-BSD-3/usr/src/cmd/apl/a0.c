begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"apl.h"
end_include

begin_comment
comment|/*#include "/usr/sys/tty.h"	/* pick up TECO-mode bit */
end_comment

begin_define
define|#
directive|define
name|APLMOD
value|01000
end_define

begin_decl_stmt
name|short
name|TERMtype
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for now ( very stupid variable) */
end_comment

begin_decl_stmt
name|short
name|chartab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|partab
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ifile
init|=
literal|0
decl_stmt|,
name|ofile
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|data
name|zero
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|data
name|one
init|=
literal|1.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|data
name|pi
init|=
literal|3.141592653589793238462643383
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|data
name|maxexp
init|=
literal|88.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|env
name|thread
init|=
block|{
literal|1.0e-13
block|,
literal|1
block|,
literal|9
block|,
literal|72
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
specifier|register
name|a
operator|,
name|c
expr_stmt|;
name|int
name|fflag
decl_stmt|;
name|int
name|intr
parameter_list|()
function_decl|;
name|int
name|floatover
parameter_list|()
function_decl|;
extern|extern headline[];
name|memstart
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Reset
argument_list|()
expr_stmt|;
name|signal
argument_list|(
literal|8
argument_list|,
name|floatover
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ac
operator|&&
operator|*
name|av
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
operator|++
name|echoflg
expr_stmt|;
name|time
argument_list|(
name|stime
argument_list|)
expr_stmt|;
name|setterm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* turn off APL mode */
name|aprintf
argument_list|(
name|headline
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyname
argument_list|(
literal|0
argument_list|)
operator|==
literal|'x'
condition|)
name|echoflg
operator|++
expr_stmt|;
name|a
operator|=
literal|"apl_ws"
expr_stmt|;
while|while
condition|(
operator|(
name|wfile
operator|=
name|open
argument_list|(
name|a
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|creat
argument_list|(
name|a
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|aprintf
argument_list|(
literal|"cannot create apl_ws"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|fflag
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|stack
expr_stmt|;
name|signal
argument_list|(
literal|2
argument_list|,
name|intr
argument_list|)
expr_stmt|;
name|setexit
argument_list|()
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|open
argument_list|(
literal|"continue"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|aprintf
argument_list|(
literal|"clear ws\n"
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|wsload
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
literal|" continue\n"
argument_list|)
expr_stmt|;
block|}
name|loop
label|:
while|while
condition|(
name|sp
operator|>
name|stack
condition|)
name|pop
argument_list|()
expr_stmt|;
name|Reset
argument_list|()
expr_stmt|;
name|signal
argument_list|(
literal|8
argument_list|,
name|floatover
argument_list|)
expr_stmt|;
if|if
condition|(
name|intflg
condition|)
name|error
argument_list|(
literal|"I"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifile
operator|&&
name|ofile
operator|==
literal|1
condition|)
name|aputchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|a
operator|=
name|rline
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ifile
condition|)
block|{
name|ifile
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|ctrld
argument_list|()
expr_stmt|;
block|}
name|c
operator|=
name|compile
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|afree
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
goto|goto
name|loop
goto|;
name|execute
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|afree
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_function

begin_comment
comment|/* this procedure is for trapping floating point exceptions, and        */
end_comment

begin_comment
comment|/* then reset the program.  added june 1979				*/
end_comment

begin_macro
name|floatover
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"\t\nerror -- floating point exception\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
literal|8
argument_list|,
name|floatover
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|setterm
argument_list|(
argument|toggle
argument_list|)
end_macro

begin_block
block|{
name|TERMtype
operator|=
name|toggle
expr_stmt|;
name|aplmod
argument_list|(
name|toggle
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nargs
argument_list|()
end_macro

begin_block
block|{
return|return
literal|1
return|;
block|}
end_block

begin_macro
name|Reset
argument_list|()
end_macro

begin_block
block|{
name|afree
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|cs_size
operator|=
name|STKS
expr_stmt|;
name|stack
operator|=
name|alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|*
name|STKS
argument_list|)
expr_stmt|;
comment|/* Set up internal stack */
name|sp
operator|=
name|stack
expr_stmt|;
name|staktop
operator|=
operator|&
name|stack
index|[
name|STKS
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|intr
argument_list|()
end_macro

begin_block
block|{
name|intflg
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
literal|2
argument_list|,
name|intr
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rline
argument_list|(
argument|s
argument_list|)
end_macro

begin_block
block|{
name|int
name|rlcmp
parameter_list|()
function_decl|;
name|char
name|line
index|[
name|CANBS
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|c
operator|,
name|col
expr_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|short
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
name|col
operator|=
name|s
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
name|loop
label|:
name|c
operator|=
name|agetchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|intflg
condition|)
name|error
argument_list|(
literal|"I"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
operator|-
literal|1
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\b'
case|:
if|if
condition|(
name|col
condition|)
name|col
operator|--
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'\t'
case|:
name|col
operator|=
operator|(
name|col
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|' '
case|:
case|case
literal|016
case|:
comment|/* cursor right */
name|col
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'\r'
case|:
name|col
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
default|default:
operator|*
name|p
operator|++
operator|=
name|col
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|&
literal|0177
expr_stmt|;
name|col
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|033
case|:
comment|/* escape - APL line feed */
for|for
control|(
name|cp
operator|=
name|dp
operator|=
name|line
init|;
name|cp
operator|<
name|p
condition|;
name|cp
operator|+=
literal|2
control|)
if|if
condition|(
operator|*
name|cp
operator|<
name|col
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
block|}
name|p
operator|=
name|dp
expr_stmt|;
name|aputchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putto
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|aputchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|aputchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putto
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'\n'
case|:
empty_stmt|;
block|}
name|qsort
argument_list|(
name|line
argument_list|,
operator|(
name|p
operator|-
name|line
operator|)
operator|/
literal|2
argument_list|,
literal|2
argument_list|,
name|rlcmp
argument_list|)
expr_stmt|;
name|c
operator|=
name|p
index|[
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|line
condition|)
name|c
operator|=
literal|1
expr_stmt|;
comment|/* check for blank line */
operator|*
name|p
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|=
name|alloc
argument_list|(
call|(
name|int
call|)
argument_list|(
name|c
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|col
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
name|c
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|line
init|;
name|p
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|;
name|p
operator|+=
literal|2
control|)
block|{
while|while
condition|(
operator|++
name|col
operator|!=
name|p
index|[
literal|0
index|]
condition|)
operator|*
operator|++
name|cp
operator|=
literal|' '
expr_stmt|;
operator|*
operator|++
name|cp
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|p
index|[
literal|2
index|]
operator|==
name|col
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|!=
operator|*
name|cp
condition|)
block|{
name|i
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
name|p
index|[
literal|3
index|]
expr_stmt|;
break|break;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
name|col
condition|)
continue|continue;
while|while
condition|(
name|p
index|[
literal|2
index|]
operator|==
name|col
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|!=
operator|*
name|cp
condition|)
goto|goto
name|yuck
goto|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|i
operator||=
operator|*
name|cp
operator|<<
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|41
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|i
operator|.
name|c
index|[
literal|0
index|]
operator|==
name|chartab
index|[
name|j
index|]
operator|.
name|a1
operator|)
operator|&&
operator|(
name|i
operator|.
name|c
index|[
literal|1
index|]
operator|==
name|chartab
index|[
name|j
index|]
operator|.
name|a2
operator|)
condition|)
block|{
operator|*
name|cp
operator|=
name|j
operator||
literal|0200
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
condition|)
block|{
name|yuck
label|:
operator|*
name|cp
operator|=
literal|'\n'
expr_stmt|;
name|pline
argument_list|(
name|c
argument_list|,
operator|++
name|col
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Y E"
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
operator|++
name|cp
operator|=
literal|'\n'
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|rlcmp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|=
name|a
index|[
literal|0
index|]
operator|-
name|b
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|c
operator|)
return|;
return|return
operator|(
name|a
index|[
literal|1
index|]
operator|-
name|b
index|[
literal|1
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|pline
argument_list|(
argument|str
argument_list|,
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
operator|,
name|l
operator|,
name|col
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|loc
condition|)
name|col
operator|=
name|column
expr_stmt|;
name|aputchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|col
condition|)
block|{
name|putto
argument_list|(
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|TERMtype
operator|==
literal|0
condition|)
name|aputchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
else|else
name|aputchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|aputchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|putto
argument_list|(
argument|col
argument_list|)
end_macro

begin_block
block|{
while|while
condition|(
name|col
operator|>
name|column
operator|+
literal|8
condition|)
name|aputchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
while|while
condition|(
name|col
operator|>
name|column
condition|)
name|aputchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|term
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
literal|"apl_ws"
argument_list|)
expr_stmt|;
name|aputchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|aplmod
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*turn off APL mode */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fix
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|data
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|i
operator|=
name|floor
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|xeq_mark
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|now_xeq
operator|.
name|name
condition|)
block|{
name|aprintf
argument_list|(
name|now_xeq
operator|.
name|name
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
literal|" ;%d'\n"
argument_list|,
name|now_xeq
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
name|now_xeq
operator|.
name|name
operator|=
name|now_xeq
operator|.
name|line
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|intflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifile
condition|)
name|close
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofile
operator|&&
name|ofile
operator|!=
literal|1
condition|)
name|close
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|ifile
operator|=
literal|0
expr_stmt|;
name|ofile
operator|=
literal|1
expr_stmt|;
name|xeq_mark
argument_list|()
expr_stmt|;
name|cp
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'L'
case|:
name|c
operator|=
literal|"length"
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|c
operator|=
literal|"\ninterrupt"
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|c
operator|=
literal|"conformability"
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|c
operator|=
literal|"syntax"
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|c
operator|=
literal|"rank"
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|c
operator|=
literal|"index"
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|c
operator|=
literal|"character"
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|c
operator|=
literal|"memory"
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|c
operator|=
literal|"domain"
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|c
operator|=
literal|"type"
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|c
operator|=
literal|"error"
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
default|default:
name|c
operator|=
literal|"botch"
expr_stmt|;
block|}
name|aprintf
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|aputchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|aputchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* procedure to catch control d and prevent it from logging out the user*/
end_comment

begin_macro
name|ctrld
argument_list|()
end_macro

begin_block
block|{
name|aprintf
argument_list|(
literal|"\nto exit type \"off\nto exit and save workspace type \"continue\n"
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|aprintf
argument_list|(
argument|f
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
operator|*
name|p
expr_stmt|;
name|s
operator|=
name|f
expr_stmt|;
name|p
operator|=
operator|&
name|a
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'d'
condition|)
block|{
name|putn
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
name|aputchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|putn
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|a
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|aprintf
argument_list|(
literal|"2147483648"
argument_list|)
expr_stmt|;
return|return;
block|}
name|aputchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
comment|/* apl minus sign */
block|}
if|if
condition|(
name|a
operator|=
name|n
operator|/
literal|10
condition|)
name|putn
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aputchar
argument_list|(
name|n
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|agetchar
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|read
argument_list|(
name|ifile
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|echoflg
condition|)
name|write
argument_list|(
literal|1
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|aputchar
argument_list|(
name|c
argument_list|)
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|unsigned
name|char
name|c2
decl_stmt|;
specifier|extern
name|unsigned
name|char
name|changeoutput
index|[]
decl_stmt|;
if|if
condition|(
name|TERMtype
operator|==
literal|1
condition|)
comment|/* ascii terminal */
name|c
operator|=
name|changeoutput
index|[
operator|(
literal|0377
operator|&
name|c
operator|)
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
return|return;
case|case
literal|'\b'
case|:
if|if
condition|(
name|column
condition|)
name|column
operator|--
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|column
operator|=
operator|(
name|column
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|column
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|column
operator|++
expr_stmt|;
block|}
comment|/* for encode numbers */
if|if
condition|(
name|mencflg
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|mencflg
operator|=
literal|1
expr_stmt|;
operator|*
name|mencptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mencflg
operator|>
literal|1
condition|)
name|mencptr
operator|+=
name|rowsz
expr_stmt|;
else|else
name|mencflg
operator|=
literal|2
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|intflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|&
literal|0200
condition|)
block|{
name|i
operator|=
name|chartab
index|[
name|c
operator|&
literal|0177
index|]
expr_stmt|;
name|aputchar
argument_list|(
name|i
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|c
operator|=
name|i
operator|&
literal|0177
expr_stmt|;
name|aputchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
name|c2
operator|=
name|c
expr_stmt|;
name|write
argument_list|(
name|ofile
argument_list|,
operator|&
name|c2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|fuzz
argument_list|(
argument|d1
argument_list|,
argument|d2
argument_list|)
end_macro

begin_decl_stmt
name|data
name|d1
decl_stmt|,
name|d2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|f1
operator|=
name|d1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0.
condition|)
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|f2
operator|=
name|d2
expr_stmt|;
if|if
condition|(
name|f2
operator|<
literal|0.
condition|)
name|f2
operator|=
operator|-
name|f2
expr_stmt|;
if|if
condition|(
name|f2
operator|>
name|f1
condition|)
name|f1
operator|=
name|f2
expr_stmt|;
name|f1
operator|*=
name|thread
operator|.
name|fuzz
expr_stmt|;
if|if
condition|(
name|d1
operator|>
name|d2
condition|)
block|{
if|if
condition|(
name|d2
operator|+
name|f1
operator|>=
name|d1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|d1
operator|+
name|f1
operator|>=
name|d2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|pop
argument_list|()
end_macro

begin_block
block|{
name|dealloc
argument_list|(
operator|*
operator|--
name|sp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|erase
argument_list|(
argument|np
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
name|p
expr_stmt|;
name|p
operator|=
name|np
operator|->
name|itemp
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
switch|switch
condition|(
name|np
operator|->
name|use
condition|)
block|{
case|case
name|NF
case|:
case|case
name|MF
case|:
case|case
name|DF
case|:
for|for
control|(
init|;
operator|*
name|p
operator|>
literal|0
condition|;
operator|(
operator|*
name|p
operator|)
operator|--
control|)
name|afree
argument_list|(
name|p
index|[
operator|*
name|p
index|]
argument_list|)
expr_stmt|;
block|}
name|afree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|np
operator|->
name|itemp
operator|=
literal|0
expr_stmt|;
block|}
name|np
operator|->
name|use
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|dealloc
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|item
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|DA
case|:
case|case
name|CH
case|:
case|case
name|QQ
case|:
case|case
name|QD
case|:
case|case
name|QC
case|:
case|case
name|EL
case|:
name|afree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|newdat
argument_list|(
argument|type
argument_list|,
argument|rank
argument_list|,
argument|size
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|rank
operator|>
name|MRANK
condition|)
name|error
argument_list|(
literal|"R E"
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
expr|*
name|p
operator|+
name|rank
operator|*
name|SINT
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DA
condition|)
name|i
operator|+=
name|size
operator|*
name|SDAT
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|CH
condition|)
name|i
operator|+=
name|size
expr_stmt|;
name|p
operator|=
name|alloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|rank
operator|=
name|rank
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|p
operator|->
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rank
operator|==
literal|1
condition|)
name|p
operator|->
name|dim
index|[
literal|0
index|]
operator|=
name|size
expr_stmt|;
name|p
operator|->
name|datap
operator|=
operator|&
name|p
operator|->
name|dim
index|[
name|rank
index|]
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|copy
argument_list|(
argument|type
argument_list|,
argument|from
argument_list|,
argument|to
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|size
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|a
operator|=
name|from
expr_stmt|;
name|b
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DA
condition|)
name|i
operator|*=
name|SDAT
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|IN
condition|)
name|i
operator|*=
name|SINT
expr_stmt|;
name|s
operator|=
name|i
expr_stmt|;
do|do
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_macro
name|fetch1
argument_list|()
end_macro

begin_block
block|{
return|return
name|sp
index|[
operator|-
literal|1
index|]
operator|=
name|fetch
argument_list|(
name|sp
index|[
operator|-
literal|1
index|]
argument_list|)
return|;
block|}
end_block

begin_macro
name|fetch2
argument_list|()
end_macro

begin_block
block|{
name|sp
index|[
operator|-
literal|2
index|]
operator|=
name|fetch
argument_list|(
name|sp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|sp
index|[
operator|-
literal|1
index|]
operator|=
name|fetch
argument_list|(
name|sp
index|[
operator|-
literal|1
index|]
argument_list|)
return|;
block|}
end_block

begin_macro
name|fetch
argument_list|(
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|ubset
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|c
decl_stmt|;
name|p
operator|=
name|ip
expr_stmt|;
name|loop
label|:
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|QQ
case|:
name|afree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|c
operator|=
name|rline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"eof"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|->
name|c
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
continue|continue;
name|p
operator|=
name|newdat
argument_list|(
name|CH
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|CH
argument_list|,
name|c
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|QD
case|:
case|case
name|QC
case|:
if|if
condition|(
operator|!
name|ifile
operator|&&
name|ofile
operator|==
literal|1
condition|)
name|aprintf
argument_list|(
literal|"L>\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|rline
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"eof"
argument_list|)
expr_stmt|;
name|c
operator|=
name|compile
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|afree
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
goto|goto
name|loop
goto|;
name|i
operator|=
name|pcp
expr_stmt|;
name|execute
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|pcp
operator|=
name|i
expr_stmt|;
name|afree
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|afree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
operator|--
name|sp
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|DA
case|:
case|case
name|CH
case|:
name|p
operator|->
name|index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|LV
case|:
if|if
condition|(
name|p
operator|->
name|use
operator|!=
name|DA
condition|)
block|{
name|ubset
operator|=
name|ip
operator|->
name|namep
expr_stmt|;
name|xeq_mark
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|ubset
condition|)
name|aputchar
argument_list|(
operator|*
name|ubset
operator|++
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"> used before set\n"
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|itemp
expr_stmt|;
name|q
operator|=
name|newdat
argument_list|(
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|rank
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|IN
argument_list|,
name|p
operator|->
name|dim
argument_list|,
name|q
operator|->
name|dim
argument_list|,
name|p
operator|->
name|rank
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|q
operator|->
name|datap
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"fetch B"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|topfix
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|DA
operator|||
name|p
operator|->
name|size
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"topval C"
argument_list|)
expr_stmt|;
name|i
operator|=
name|fix
argument_list|(
name|p
operator|->
name|datap
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|bidx
argument_list|(
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ip
expr_stmt|;
name|idx
operator|.
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|idx
operator|.
name|rank
operator|=
name|p
operator|->
name|rank
expr_stmt|;
name|copy
argument_list|(
name|IN
argument_list|,
name|p
operator|->
name|dim
argument_list|,
name|idx
operator|.
name|dim
argument_list|,
name|idx
operator|.
name|rank
argument_list|)
expr_stmt|;
name|size
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|size
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|s
expr_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|idx
operator|.
name|rank
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|idx
operator|.
name|del
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
name|s
operator|*=
name|idx
operator|.
name|dim
index|[
name|i
index|]
expr_stmt|;
block|}
name|idx
operator|.
name|size
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_macro
name|colapse
argument_list|(
argument|k
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
operator|||
name|k
operator|>=
name|idx
operator|.
name|rank
condition|)
name|error
argument_list|(
literal|"collapse X"
argument_list|)
expr_stmt|;
name|idx
operator|.
name|dimk
operator|=
name|idx
operator|.
name|dim
index|[
name|k
index|]
expr_stmt|;
name|idx
operator|.
name|delk
operator|=
name|idx
operator|.
name|del
index|[
name|k
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|k
init|;
name|i
operator|<
name|idx
operator|.
name|rank
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|.
name|del
index|[
name|i
index|]
operator|=
name|idx
operator|.
name|del
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|idx
operator|.
name|dim
index|[
name|i
index|]
operator|=
name|idx
operator|.
name|dim
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|idx
operator|.
name|size
operator|/=
name|idx
operator|.
name|dimk
expr_stmt|;
name|idx
operator|.
name|rank
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|forloop
argument_list|(
argument|co
argument_list|,
argument|arg
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|co
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|idx
operator|.
name|rank
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|co
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
while|while
condition|(
name|i
operator|<
name|idx
operator|.
name|rank
condition|)
name|idx
operator|.
name|idx
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|co
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|idx
operator|.
name|idx
index|[
name|i
operator|-
literal|1
index|]
operator|>=
name|idx
operator|.
name|dim
index|[
name|i
operator|-
literal|1
index|]
condition|)
if|if
condition|(
operator|--
name|i
operator|<=
literal|0
condition|)
return|return;
block|}
block|}
end_block

begin_macro
name|access
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|n
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idx
operator|.
name|rank
condition|;
name|i
operator|++
control|)
name|n
operator|+=
name|idx
operator|.
name|idx
index|[
name|i
index|]
operator|*
name|idx
operator|.
name|del
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_function
name|data
name|getdat
parameter_list|(
name|ip
parameter_list|)
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|data
name|d
decl_stmt|;
name|p
operator|=
name|ip
expr_stmt|;
name|i
operator|=
name|p
operator|->
name|index
expr_stmt|;
while|while
condition|(
name|i
operator|>=
name|p
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"getdat B"
argument_list|)
expr_stmt|;
name|i
operator|-=
name|p
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|DA
condition|)
block|{
name|d
operator|=
name|p
operator|->
name|datap
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|CH
condition|)
block|{
name|d
operator|=
name|p
operator|->
name|datap
operator|->
name|c
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"getdat B"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_macro
name|putdat
argument_list|(
argument|ip
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|data
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|p
operator|=
name|ip
expr_stmt|;
name|i
operator|=
name|p
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|p
operator|->
name|size
condition|)
name|error
argument_list|(
literal|"putdat B"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|DA
condition|)
block|{
name|p
operator|->
name|datap
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|CH
condition|)
block|{
name|p
operator|->
name|datap
operator|->
name|c
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"putdat B"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_macro
name|aplmod
argument_list|(
argument|xyz
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|firstvisit
operator|=
literal|0
expr_stmt|;
specifier|static
name|short
name|old
index|[
literal|3
index|]
decl_stmt|,
name|new
index|[
literal|3
index|]
decl_stmt|;
specifier|static
name|short
name|diff
decl_stmt|;
if|if
condition|(
name|xyz
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|firstvisit
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gtty
argument_list|(
literal|0
argument_list|,
name|old
argument_list|)
operator|<
literal|0
condition|)
block|{
name|diff
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|diff
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|==
literal|1
condition|)
block|{
name|gtty
argument_list|(
literal|0
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|xyz
operator|==
literal|1
condition|)
name|new
index|[
literal|1
index|]
operator|=
literal|'W'
operator||
literal|'A'
operator|<<
literal|8
expr_stmt|;
comment|/* apl terminal */
else|else
name|new
index|[
literal|1
index|]
operator|=
literal|'
literal|'
operator||
literal|'@'
operator|<<
literal|8
expr_stmt|;
comment|/* ascii terminal */
name|stty
argument_list|(
literal|0
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstvisit
condition|)
if|if
condition|(
name|xyz
operator|==
literal|1
condition|)
name|aprintf
argument_list|(
literal|"erase%KWK kill%KAK\n\n"
argument_list|)
expr_stmt|;
else|else
name|aprintf
argument_list|(
literal|"erase ^H kill @\n\n"
argument_list|)
expr_stmt|;
block|}
name|firstvisit
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|diff
condition|)
name|stty
argument_list|(
literal|0
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

