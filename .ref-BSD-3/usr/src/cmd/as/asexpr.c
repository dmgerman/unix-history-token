begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asexpr.h"
end_include

begin_comment
comment|/*  * Tables for combination of operands.  */
end_comment

begin_comment
comment|/*  *	table for +  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|pltab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|XTEXT
block|,
name|XDATA
block|,
name|XBSS
block|,
name|XXTRN
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|XTEXT
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|XDATA
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|XBSS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|XXTRN
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	table for -  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|mintab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|XTEXT
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|XDATA
block|,
name|ERR
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|XBSS
block|,
name|ERR
block|,
name|ERR
block|,
name|XABS
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|XXTRN
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   *	table for other operators  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|othtab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|exp
modifier|*
name|combine
parameter_list|(
name|op
parameter_list|,
name|exp1
parameter_list|,
name|exp2
parameter_list|)
specifier|register
name|struct
name|exp
modifier|*
name|exp1
decl_stmt|,
decl|*
name|exp2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|e1_type
operator|,
name|e2_type
expr_stmt|;
specifier|register
name|type
expr_stmt|;
name|lastnam
operator|=
literal|0
expr_stmt|;
comment|/* kludge for jxxx instructions */
name|e1_type
operator|=
name|exp1
operator|->
name|xtype
operator|&
name|XTYPE
expr_stmt|;
name|e2_type
operator|=
name|exp2
operator|->
name|xtype
operator|&
name|XTYPE
expr_stmt|;
if|if
condition|(
name|exp1
operator|->
name|xtype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
name|e1_type
operator|=
name|XTXRN
expr_stmt|;
if|if
condition|(
name|exp2
operator|->
name|xtype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
name|e2_type
operator|=
name|XTXRN
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
if|if
condition|(
name|exp1
operator|->
name|xloc
operator|!=
name|exp2
operator|->
name|xloc
operator|&&
name|e1_type
operator|==
name|e2_type
condition|)
name|e1_type
operator|=
name|e2_type
operator|=
name|XTXRN
expr_stmt|;
comment|/* error on != loc ctrs */
name|e1_type
operator|>>=
literal|1
expr_stmt|;
comment|/*dispost of the external (XXTRN) bit*/
name|e2_type
operator|>>=
literal|1
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|PLUS
case|:
name|exp1
operator|->
name|xvalue
operator|+=
name|exp2
operator|->
name|xvalue
expr_stmt|;
name|type
operator|=
name|pltab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|exp1
operator|->
name|xvalue
operator|-=
name|exp2
operator|->
name|xvalue
expr_stmt|;
name|type
operator|=
name|mintab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|exp1
operator|->
name|xvalue
operator||=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|XOR
case|:
name|exp1
operator|->
name|xvalue
operator|^=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|AND
case|:
name|exp1
operator|->
name|xvalue
operator|&=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|ORNOT
case|:
name|exp1
operator|->
name|xvalue
operator||=
operator|~
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|LSH
case|:
name|exp1
operator|->
name|xvalue
operator|<<=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|RSH
case|:
name|exp1
operator|->
name|xvalue
operator|>>=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|TILDE
case|:
name|exp1
operator|->
name|xvalue
operator||=
operator|~
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|MUL
case|:
name|exp1
operator|->
name|xvalue
operator|*=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|DIV
case|:
if|if
condition|(
name|exp2
operator|->
name|xvalue
operator|==
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Divide check"
argument_list|)
expr_stmt|;
else|else
name|exp1
operator|->
name|xvalue
operator|/=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|REGOP
case|:
if|if
condition|(
name|exp2
operator|->
name|xvalue
operator|==
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Divide check (modulo)"
argument_list|)
expr_stmt|;
else|else
name|exp1
operator|->
name|xvalue
operator|%=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
name|comm
label|:
name|type
operator|=
name|othtab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
default|default:
name|yyerror
argument_list|(
literal|"Internal error: unknown operator"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e2_type
operator|==
operator|(
name|XTXRN
operator|>>
literal|1
operator|)
condition|)
name|exp1
operator|->
name|xname
operator|=
name|exp2
operator|->
name|xname
expr_stmt|;
name|exp1
operator|->
name|xtype
operator|=
name|type
operator||
operator|(
operator|(
name|exp1
operator|->
name|xtype
operator||
name|exp2
operator|->
name|xtype
operator|)
operator|&
operator|(
name|XFORW
operator||
name|XXTRN
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ERR
condition|)
name|yyerror
argument_list|(
literal|"Relocation error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp1
operator|)
return|;
block|}
end_block

begin_macro
name|buildtokensets
argument_list|()
end_macro

begin_block
block|{
define|#
directive|define
name|clobber
parameter_list|(
name|val
parameter_list|,
name|set
parameter_list|)
value|tokensets[(val)] |= (set)
name|clobber
argument_list|(
name|SEMI
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|NL
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|NAME
argument_list|,
name|YUKKYEXPRBEG
operator|+
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INSTn
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INST0
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|REG
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INT
argument_list|,
name|SAFEEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|FLTNUM
argument_list|,
name|SAFEEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|PLUS
argument_list|,
name|ADDOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|MINUS
argument_list|,
name|ADDOPS
operator|+
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|LP
argument_list|,
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|IOR
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|XOR
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|AND
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|ORNOT
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|TILDE
argument_list|,
name|MULOPS
operator|+
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|LSH
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|RSH
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|MUL
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|DIV
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|REGOP
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
comment|/* % */
block|}
end_block

begin_comment
comment|/*  *	We keep the current token class in this global variable, so   *	the recursive descent expression analyzers can talk amongst  *	themselves, and so that we may use the macros shift and shift over  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the value of the lexical value*/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|exp
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the next free expression slot*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|val
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|exprparse
parameter_list|(
name|inval
parameter_list|,
name|backexpr
parameter_list|)
comment|/*return the value the read head is sitting on*/
name|int
name|inval
decl_stmt|;
name|struct
name|exp
modifier|*
modifier|*
name|backexpr
decl_stmt|;
block|{
specifier|register
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|int
name|op
decl_stmt|;
name|val
operator|=
name|inval
expr_stmt|;
name|lexpr
operator|=
name|boolterm
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|ADDOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|boolterm
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|*
name|backexpr
operator|=
name|lexpr
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|boolterm
parameter_list|()
block|{
specifier|register
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|int
name|op
decl_stmt|;
name|lexpr
operator|=
name|term
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|BOOLOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|term
parameter_list|()
block|{
specifier|register
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|int
name|op
decl_stmt|;
name|lexpr
operator|=
name|factor
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|MULOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|factor
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|factor
parameter_list|()
block|{
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|int
name|op
decl_stmt|;
specifier|extern
name|int
name|droppedLP
decl_stmt|;
comment|/*called exprparse after consuming an LP*/
if|if
condition|(
name|val
operator|==
name|LP
operator|||
name|droppedLP
condition|)
block|{
if|if
condition|(
name|droppedLP
condition|)
name|droppedLP
operator|=
literal|0
expr_stmt|;
else|else
name|shift
expr_stmt|;
comment|/*the LP*/
name|val
operator|=
name|exprparse
argument_list|(
name|val
argument_list|,
operator|&
name|lexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|RP
condition|)
name|yyerror
argument_list|(
literal|"right parenthesis expected"
argument_list|)
expr_stmt|;
else|else
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
condition|)
block|{
name|lexpr
operator|=
name|yukkyexpr
argument_list|(
name|val
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|SAFEEXPRBEG
argument_list|)
condition|)
block|{
name|lexpr
operator|=
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|==
name|TILDE
operator|)
operator|||
operator|(
name|val
operator|==
name|MINUS
operator|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|xp
operator|++
expr_stmt|;
name|lexpr
operator|->
name|xtype
operator|=
name|XABS
expr_stmt|;
name|lexpr
operator|->
name|xvalue
operator|=
literal|0
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|factor
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyerror
argument_list|(
literal|"Bad expression syntax"
argument_list|)
expr_stmt|;
name|lexpr
operator|=
name|xp
operator|++
expr_stmt|;
name|lexpr
operator|->
name|xtype
operator|=
name|XABS
expr_stmt|;
name|lexpr
operator|->
name|xvalue
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|exp
modifier|*
name|yukkyexpr
argument_list|(
name|val
argument_list|,
name|np
argument_list|)
name|int
name|val
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|np
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
specifier|extern
name|int
name|exprisname
decl_stmt|;
comment|/*last factor is a name*/
name|exprisname
operator|=
literal|0
expr_stmt|;
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NAME
condition|)
block|{
name|exprisname
operator|++
expr_stmt|;
name|locxp
operator|->
name|xtype
operator|=
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
block|{
comment|/*forward*/
name|locxp
operator|->
name|xname
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
expr_stmt|;
name|locxp
operator|->
name|xvalue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|type
operator||=
name|XFORW
expr_stmt|;
block|}
else|else
block|{
comment|/*otherwise, just get the value*/
name|locxp
operator|->
name|xvalue
operator|=
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|value
expr_stmt|;
name|locxp
operator|->
name|xname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*INSTn or INST0 or REG*/
name|locxp
operator|->
name|xtype
operator|=
name|XABS
expr_stmt|;
name|locxp
operator|->
name|xvalue
operator|=
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|locxp
operator|->
name|xloc
operator|=
literal|0
expr_stmt|;
name|locxp
operator|->
name|xname
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|locxp
operator|)
return|;
block|}
end_block

end_unit

