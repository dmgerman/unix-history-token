begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"assyms.h"
end_include

begin_include
include|#
directive|include
file|"asexpr.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_decl_stmt
name|int
name|curlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	variables to manage the assembly input  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dotsname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the current file name; managed by the parser*/
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*current line number; managed by the parser*/
end_comment

begin_decl_stmt
name|int
name|silent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*don't complain about any errors*/
end_comment

begin_decl_stmt
name|int
name|savelabels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*write the labels to the a.out file*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|toktrace
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|long
name|datbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|endcore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*where to get more symbol space*/
end_comment

begin_decl_stmt
name|struct
name|hdr
name|hdr
init|=
block|{
literal|0410
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|vax
end_ifndef

begin_struct
struct|struct
block|{
name|short
name|hiword
decl_stmt|;
name|short
name|loword
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* stupid fp-11 */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|writel
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|,
name|f
parameter_list|)
value|fwrite( (long) p, sizeof (long), n, f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|tmpn1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tmpn2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tmpn3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|exp
name|usedot
index|[
name|NLOC
operator|+
name|NLOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|usefile
index|[
name|NLOC
operator|+
name|NLOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rusefile
index|[
name|NLOC
operator|+
name|NLOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|sibuf
index|[
name|TOKBUFLG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*buffer used for all input*/
end_comment

begin_decl_stmt
name|char
name|sobuf
index|[
name|TOKBUFLG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*buffer used for all output*/
end_comment

begin_comment
comment|/*except stdout and relfil*/
end_comment

begin_decl_stmt
name|char
name|stdoutbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*stdout buffer*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|njxxx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*number of jumpxxx  instructs*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|d124
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*allocate 1,2 or 4 bytes for unknowns*/
end_comment

begin_function_decl
name|int
name|delexit
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|innames
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*names of the files being assembled*/
end_comment

begin_decl_stmt
name|int
name|ninfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*how many interesting files there are*/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|locindex
decl_stmt|;
name|long
name|v
decl_stmt|;
name|char
modifier|*
name|outfile
init|=
literal|"a.out"
decl_stmt|;
name|int
name|filestep
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|stdoutbuf
argument_list|)
expr_stmt|;
name|ninfiles
operator|=
literal|0
expr_stmt|;
name|silent
operator|=
literal|0
expr_stmt|;
name|useVM
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *	Give the error processor something to complain about 	 *	if there is an error processing an argument 	 */
name|dotsname
operator|=
literal|"<argv error>"
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|cp
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
comment|/* 			 *	We can throw away single minus signs, so 			 *	that make scripts for the PDP 11 assembler work 			 *	on this assembler too 			 */
while|while
condition|(
operator|*
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
default|default:
name|yyerror
argument_list|(
literal|"Unknown flag: %c"
argument_list|,
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|d124
operator|=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|d124
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|d124
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|d124
operator|!=
literal|4
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"-d[124] only"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|yyerror
argument_list|(
literal|"-o what???"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|outfile
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'V'
case|:
name|useVM
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|fooiearg
case|case
literal|'M'
case|:
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|yyerror
argument_list|(
literal|"Mode what?"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
literal|'0'
operator|<=
operator|*
name|cp
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'7'
operator|)
condition|)
name|hdr
operator|.
name|magic
operator|=
name|hdr
operator|.
name|magic
operator|<<
literal|3
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'W'
case|:
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|toktrace
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|METRIC
case|case
literal|'C'
case|:
name|outcounters
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'L'
case|:
name|savelabels
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/*end of the switch*/
block|}
comment|/*end of pulling out all arguments*/
block|}
comment|/*end of a flag argument*/
else|else
block|{
comment|/*file name*/
if|if
condition|(
name|ninfiles
operator|>
literal|32
condition|)
block|{
name|yyerror
argument_list|(
literal|"More than 32 file names"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|innames
index|[
name|ninfiles
operator|++
index|]
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
name|nextarg
label|:
empty_stmt|;
block|}
comment|/*end of looking at all of the arguments*/
if|if
condition|(
name|anyerrs
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|endcore
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *	Install symbols in the table 	 */
name|symtabinit
argument_list|()
expr_stmt|;
name|syminstall
argument_list|()
expr_stmt|;
comment|/* 	 *	mark usedot: first NLOC slots for named text segments, 	 *	the next for named data segments. 	 */
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|usedot
index|[
name|locindex
index|]
operator|.
name|xtype
operator|=
name|XTEXT
expr_stmt|;
name|usedot
index|[
name|locindex
operator|+
name|NLOC
index|]
operator|.
name|xtype
operator|=
name|XDATA
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
name|tmpn1
operator|=
operator|(
name|char
operator|*
operator|)
name|mktemp
argument_list|(
literal|"/tmp/asXXXXX"
argument_list|)
expr_stmt|;
name|tmpfil
operator|=
name|fopen
argument_list|(
name|tmpn1
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Bad pass 1 temporary file for writing %s"
argument_list|,
name|tmpn1
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|tmpfil
argument_list|,
name|sobuf
argument_list|)
expr_stmt|;
name|inittmpfile
argument_list|()
expr_stmt|;
name|buildtokensets
argument_list|()
expr_stmt|;
comment|/*sets to implement expression lookahead*/
if|if
condition|(
name|ninfiles
operator|==
literal|0
condition|)
block|{
comment|/*take the input from stdin directly*/
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|sibuf
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|dotsname
operator|=
literal|"<stdin>"
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/*we have the names tanked*/
for|for
control|(
name|filestep
operator|=
literal|0
init|;
name|filestep
operator|<
name|ninfiles
condition|;
name|filestep
operator|++
control|)
block|{
name|new_dot_s
argument_list|(
name|innames
index|[
name|filestep
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|innames
index|[
name|filestep
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Can't open source file %s\n"
argument_list|,
name|innames
index|[
name|filestep
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|sibuf
argument_list|)
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
block|}
block|}
name|closetmpfile
argument_list|()
expr_stmt|;
comment|/*kick out the last buffered intermediate text*/
if|if
condition|(
name|anyerrs
condition|)
name|delexit
argument_list|()
expr_stmt|;
comment|/* 	 *	Pass 1.5 	 */
name|sortsymtab
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|dumpsymtab
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|jxxxfix
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|dumpsymtab
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|METRIC
name|lgtmpfile
operator|=
name|ftell
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fclose
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|tmpfil
operator|=
name|fopen
argument_list|(
name|tmpn1
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Bad pass 2 temporary file for reading %s"
argument_list|,
name|tmpn1
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|tmpfil
argument_list|,
name|sibuf
argument_list|)
expr_stmt|;
comment|/* 	 *	round and assign text segment origins  	 */
name|tsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|v
operator|=
name|round
argument_list|(
name|usedot
index|[
name|locindex
index|]
operator|.
name|xvalue
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|usedot
index|[
name|locindex
index|]
operator|.
name|xvalue
operator|=
name|tsize
expr_stmt|;
name|tsize
operator|+=
name|v
expr_stmt|;
block|}
comment|/* 	 *	round and assign data segment origins  	 */
name|datbase
operator|=
name|round
argument_list|(
name|tsize
argument_list|,
name|PAGRND
argument_list|)
expr_stmt|;
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|v
operator|=
name|round
argument_list|(
name|usedot
index|[
name|NLOC
operator|+
name|locindex
index|]
operator|.
name|xvalue
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|usedot
index|[
name|NLOC
operator|+
name|locindex
index|]
operator|.
name|xvalue
operator|=
name|datbase
operator|+
name|dsize
expr_stmt|;
name|dsize
operator|+=
name|v
expr_stmt|;
block|}
name|hdr
operator|.
name|bsize
operator|=
name|dsize
expr_stmt|;
comment|/* 	 *	Assign final values to symbols 	 */
name|freezesymtab
argument_list|()
expr_stmt|;
name|stabfix
argument_list|()
expr_stmt|;
name|hdr
operator|.
name|bsize
operator|-=
name|dsize
expr_stmt|;
name|txtfil
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txtfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Cannot create %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|txtfil
argument_list|,
name|sobuf
argument_list|)
expr_stmt|;
name|usefile
index|[
literal|0
index|]
operator|=
name|txtfil
expr_stmt|;
name|tmpn2
operator|=
operator|(
name|char
operator|*
operator|)
name|mktemp
argument_list|(
literal|"/tmp/aaatXXXXX"
argument_list|)
expr_stmt|;
name|tmpn3
operator|=
operator|(
name|char
operator|*
operator|)
name|mktemp
argument_list|(
literal|"/tmp/abatXXXXX"
argument_list|)
expr_stmt|;
name|relfil
operator|=
name|fopen
argument_list|(
name|tmpn3
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|relfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Bad temp file for writing extra text segments %s"
argument_list|,
name|tmpn3
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|rusefile
index|[
literal|0
index|]
operator|=
name|relfil
expr_stmt|;
name|hdr
operator|.
name|tsize
operator|=
name|tsize
expr_stmt|;
name|hdr
operator|.
name|dsize
operator|=
name|dsize
expr_stmt|;
name|hdr
operator|.
name|ssize
operator|=
name|sizesymtab
argument_list|()
expr_stmt|;
comment|/* 	 *	hdr.trsize, hdr.drsize set by outrel  	 */
comment|/* *************** PASS 2 **************** */
name|writel
argument_list|(
operator|&
name|hdr
argument_list|,
literal|8
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|tsize
operator|=
literal|0
expr_stmt|;
name|dsize
operator|=
literal|0
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"\n\n\n\t\tPASS 2\n\n\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|passno
operator|=
literal|2
expr_stmt|;
name|inittmpfile
argument_list|()
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|closetmpfile
argument_list|()
expr_stmt|;
comment|/* 	 *	round csects to FW  	 */
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
if|if
condition|(
name|usefile
index|[
name|locindex
index|]
condition|)
block|{
name|txtfil
operator|=
name|usefile
index|[
name|locindex
index|]
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
name|locindex
index|]
expr_stmt|;
while|while
condition|(
name|usedot
index|[
name|locindex
index|]
operator|.
name|xvalue
operator|&
name|FW
condition|)
name|outb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|locindex
operator|>
literal|0
condition|)
name|fclose
argument_list|(
name|usefile
index|[
name|locindex
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rusefile
index|[
name|locindex
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usefile
index|[
name|NLOC
operator|+
name|locindex
index|]
condition|)
block|{
name|txtfil
operator|=
name|usefile
index|[
name|NLOC
operator|+
name|locindex
index|]
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
name|locindex
operator|+
name|NLOC
index|]
expr_stmt|;
name|relfil
operator|=
name|rusefile
index|[
name|NLOC
operator|+
name|locindex
index|]
expr_stmt|;
while|while
condition|(
name|usedot
index|[
name|locindex
operator|+
name|NLOC
index|]
operator|.
name|xvalue
operator|&
name|FW
condition|)
name|outb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfil
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|relfil
argument_list|)
expr_stmt|;
block|}
block|}
name|txtfil
operator|=
name|usefile
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 *	append csect text onto text for csect 0  	 */
for|for
control|(
name|locindex
operator|=
literal|1
init|;
name|locindex
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|usefile
index|[
name|locindex
index|]
condition|)
block|{
name|tmpn2
index|[
name|TMPC
index|]
operator|=
name|locindex
operator|+
literal|'a'
expr_stmt|;
name|relfil
operator|=
name|fopen
argument_list|(
name|tmpn2
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|relfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"cannot reopen temp"
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
operator|!
name|feof
argument_list|(
name|relfil
argument_list|)
condition|)
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|relfil
argument_list|)
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|relfil
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 *	append relocation info onto text  	 */
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|rusefile
index|[
name|locindex
index|]
condition|)
block|{
name|tmpn3
index|[
name|TMPC
index|]
operator|=
name|locindex
operator|+
literal|'a'
expr_stmt|;
name|relfil
operator|=
name|fopen
argument_list|(
name|tmpn3
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|relfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"cannot reopen temp"
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
operator|!
name|feof
argument_list|(
name|relfil
argument_list|)
condition|)
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|relfil
argument_list|)
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|relfil
argument_list|)
expr_stmt|;
block|}
block|}
name|symwrite
argument_list|(
name|txtfil
argument_list|)
expr_stmt|;
comment|/* 	 *	Go back and patch up rsize 	 */
name|fseek
argument_list|(
name|txtfil
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
name|hdr
argument_list|,
literal|8
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|delete
argument_list|()
expr_stmt|;
if|if
condition|(
name|anyerrs
operator|==
literal|0
operator|&&
name|orgwarn
condition|)
name|yyerror
argument_list|(
literal|"Caution: absolute origins.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|METRIC
name|pcounters
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|anyerrs
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*end of main*/
end_comment

begin_macro
name|delexit
argument_list|()
end_macro

begin_block
block|{
name|delete
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|METRIC
name|pcounters
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sawabort
argument_list|()
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|METRIC
name|pcounters
argument_list|()
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|delete
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*although the previous pass will also exit non zero*/
block|}
end_block

begin_macro
name|delete
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|locindex
expr_stmt|;
if|if
condition|(
name|tmpn1
condition|)
name|unlink
argument_list|(
name|tmpn1
argument_list|)
expr_stmt|;
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
if|if
condition|(
name|tmpn2
condition|)
block|{
name|tmpn2
index|[
name|TMPC
index|]
operator|=
name|locindex
operator|+
literal|'a'
expr_stmt|;
name|unlink
argument_list|(
name|tmpn2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpn3
condition|)
block|{
name|tmpn3
index|[
name|TMPC
index|]
operator|=
name|locindex
operator|+
literal|'a'
expr_stmt|;
name|unlink
argument_list|(
name|tmpn3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|METRIC
end_ifdef

begin_macro
name|pcounters
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
struct|struct
block|{
name|long
name|p_user
decl_stmt|;
name|long
name|p_sys
decl_stmt|;
name|long
name|c_user
decl_stmt|;
name|long
name|c_sys
decl_stmt|;
block|}
name|tbuffer
struct|;
if|if
condition|(
operator|!
name|outcounters
condition|)
return|return;
name|printf
argument_list|(
literal|"Assembly of files: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|innames
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"<Standard Input.>\n"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninfiles
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|innames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useVM
condition|)
name|printf
argument_list|(
literal|"Using "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"NOT using "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Virtual Memory for the interpass temporary file.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d hashing collsions\n"
argument_list|,
name|nhcollisions
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d hash table accesses\n"
argument_list|,
name|nhashed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d values entered in the hash table\n"
argument_list|,
name|nentered
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d byte length of the temporary file\n"
argument_list|,
name|lgtmpfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d symbols in the symbol table\n"
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d labels in the symbol table\n"
argument_list|,
name|nlabels
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d forgotten symbols\n"
argument_list|,
name|nforgotten
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d iterations through all symbols to remove jxxxes\n"
argument_list|,
name|jxxxiterate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d jumps resolved via tunnelling\n"
argument_list|,
name|jxxxtunnel
argument_list|)
expr_stmt|;
if|if
condition|(
name|jxdeadlock
condition|)
name|printf
argument_list|(
literal|"%d DEADLOCKED JXXXentries: Resolved by %s jumping\n"
argument_list|,
name|jxdeadlock
argument_list|,
name|nbadjxsegs
operator|==
literal|0
condition|?
literal|"short"
else|:
literal|"long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbadjxsegs
condition|)
name|printf
argument_list|(
literal|"%d Segments with jxxx over aligns.\n"
argument_list|,
name|nbadjxsegs
argument_list|)
expr_stmt|;
name|times
argument_list|(
operator|&
name|tbuffer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%1.2fu 1.2fs\n"
argument_list|,
operator|(
operator|(
name|float
operator|)
name|tbuffer
operator|.
name|p_user
operator|)
operator|/
literal|60.0
argument_list|,
operator|(
operator|(
name|float
operator|)
name|tbuffer
operator|.
name|p_sys
operator|)
operator|/
literal|60.0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

